<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="259">Simplex algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Simplex algorithm</h1>
<hr/>

<p><mtpl></mtpl></p>

<p>In <a href="optimization_(mathematics)" title="wikilink">mathematical optimization</a>, <a href="George_Dantzig" title="wikilink">Dantzig</a>'s <strong>simplex algorithm</strong> (or <strong>simplex method</strong>) is a popular <a class="uri" href="algorithm" title="wikilink">algorithm</a> for <a href="linear_programming" title="wikilink">linear programming</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The journal <em><a href="Computing_in_Science_and_Engineering" title="wikilink">Computing in Science and Engineering</a></em> listed it as one of the top 10 algorithms of the twentieth century.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>The name of the algorithm is derived from the concept of a <a class="uri" href="simplex" title="wikilink">simplex</a> and was suggested by <a href="Theodore_Motzkin" title="wikilink">T. S. Motzkin</a>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Simplices are not actually used in the method, but one interpretation of it is that it operates on simplicial <em><a href="cone_(geometry)" title="wikilink">cones</a></em>, and these become proper simplices with an additional constraint.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> The simplicial cones in question are the corners (i.e., the neighborhoods of the vertices) of a geometric object called a <a class="uri" href="polytope" title="wikilink">polytope</a>. The shape of this polytope is defined by the <a href="System_of_linear_inequalities" title="wikilink">constraints</a> applied to the objective function.</p>
<h2 id="overview">Overview</h2>

<p><mtpl></mtpl> </p>
<figure><b>(Figure)</b>
<figcaption>Polyhedron of simplex algorithm in 3D</figcaption>
</figure>

<p>The simplex algorithm operates on linear programs in <a href="canonical_form" title="wikilink">standard form</a>:</p>
<dl>
<dd>Maximize

<p>

<math display="block" id="Simplex_algorithm:0">
 <semantics>
  <mrow>
   <mi>𝐜</mi>
   <mo>⋅</mo>
   <mi>𝐱</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <ci>𝐜</ci>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{c}\cdot\mathbf{x}
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>Subject to

<p>

<math display="block" id="Simplex_algorithm:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐀𝐱</mi>
    <mo>=</mo>
    <mi>𝐛</mi>
   </mrow>
   <mo rspace="4.2pt">,</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>≥</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>𝐀𝐱</ci>
     <ci>𝐛</ci>
    </apply>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}\mathbf{x}=\mathbf{b},\,x_{i}\geq 0
  </annotation>
 </semantics>
</math>

</p>
</dd>
</dl>

<p>with 

<math display="inline" id="Simplex_algorithm:2">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo rspace="4.2pt">,</mo>
    <mi mathvariant="normal">…</mi>
    <mo rspace="4.2pt">,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=(x_{1},\,\dots,\,x_{n})
  </annotation>
 </semantics>
</math>

 the variables of the problem, 

<math display="inline" id="Simplex_algorithm:3">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>c</mi>
     <mn>1</mn>
    </msub>
    <mo rspace="4.2pt">,</mo>
    <mi mathvariant="normal">…</mi>
    <mo rspace="4.2pt">,</mo>
    <msub>
     <mi>c</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>c</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=(c_{1},\,\dots,\,c_{n})
  </annotation>
 </semantics>
</math>

 are the coefficients of the objective function <em>A</em>, a <em>p×n</em> matrix, and 

<math display="inline" id="Simplex_algorithm:4">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>b</mi>
     <mn>1</mn>
    </msub>
    <mo rspace="4.2pt">,</mo>
    <mi mathvariant="normal">…</mi>
    <mo rspace="4.2pt">,</mo>
    <msub>
     <mi>b</mi>
     <mi>p</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>b</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>p</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b=(b_{1},\,\dots,\,b_{p})
  </annotation>
 </semantics>
</math>

 constants with 

<math display="inline" id="Simplex_algorithm:5">
 <semantics>
  <mrow>
   <msub>
    <mi>b</mi>
    <mi>j</mi>
   </msub>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <ci>j</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{j}\geq 0
  </annotation>
 </semantics>
</math>

. There is a straightforward process to convert any linear program into one in standard form so this results in no loss of generality.</p>

<p>In geometric terms, the <a href="feasible_region" title="wikilink">feasible region</a></p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Simplex_algorithm:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐀𝐱</mi>
    <mo>≤</mo>
    <mi>𝐛</mi>
   </mrow>
   <mo rspace="4.2pt">,</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>≥</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <leq></leq>
     <ci>𝐀𝐱</ci>
     <ci>𝐛</ci>
    </apply>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}\mathbf{x}\leq\mathbf{b},\,x_{i}\geq 0
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>is a (possibly unbounded) <a href="convex_polytope" title="wikilink">convex polytope</a>. There is a simple characterization of the extreme points or vertices of this polytope, namely 

<math display="inline" id="Simplex_algorithm:7">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo rspace="4.2pt">,</mo>
    <mi mathvariant="normal">…</mi>
    <mo rspace="4.2pt">,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=(x_{1},\,\dots,\,x_{n})
  </annotation>
 </semantics>
</math>

 is an extreme point if and only if the subset of column vectors 

<math display="inline" id="Simplex_algorithm:8">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}
  </annotation>
 </semantics>
</math>

 corresponding to the nonzero entries of <em>x</em> (

<math display="inline" id="Simplex_algorithm:9">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}\neq 0
  </annotation>
 </semantics>
</math>

) are <a href="Linear_independence" title="wikilink">linearly independent</a>.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> In this context such a point is known as a <em>basic feasible solution</em> (BFS).</p>

<p>It can be shown that for a linear program in standard form, if the objective function has a maximum value on the feasible region then it has this value on (at least) one of the extreme points.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> This in itself reduces the problem to a finite computation since there is a finite number of extreme points, but the number of extreme points is unmanageably large for all but the smallest linear programs.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>It can also be shown that if an extreme point is not a maximum point of the objective function then there is an edge containing the point so that the objective function is strictly increasing on the edge moving away from the point.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> If the edge is finite then the edge connects to another extreme point where the objective function has a greater value, otherwise the objective function is unbounded above on the edge and the linear program has no solution. The simplex algorithm applies this insight by walking along edges of the polytope to extreme points with greater and greater objective values. This continues until the maximum value is reached or an unbounded edge is visited, concluding that the problem has no solution. The algorithm always terminates because the number of vertices in the polytope is finite; moreover since we jump between vertices always in the same direction (that of the objective function), we hope that the number of vertices visited will be small.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>The solution of a linear program is accomplished in two steps. In the first step, known as Phase I, a starting extreme point is found. Depending on the nature of the program this may be trivial, but in general it can be solved by applying the simplex algorithm to a modified version of the original program. The possible results of Phase I are either a basic feasible solution is found or that the feasible region is empty. In the latter case the linear program is called <em>infeasible</em>. In the second step, Phase II, the simplex algorithm is applied using the basic feasible solution found in Phase I as a starting point. The possible results from Phase II are either an optimum basic feasible solution or an infinite edge on which the objective function is unbounded below.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>
<h2 id="history">History</h2>

<p>George Dantzig worked on planning methods for the US Air Force during World War II using a desk calculator. During 1946 his colleague challenged him to mechanize the planning process in order to entice him into not taking another job. Dantzig formulated the problem as linear inequalities inspired by the work of <a href="Wassily_Leontief" title="wikilink">Wassily Leontief</a>, however, at that time he didn't include an objective as part of his formulation. Without an objective, a vast number of solutions can be feasible, and therefore to find the "best" feasible solution, military-specified "ground rules" must be used that describe how goals can be achieved as opposed to specifying a goal itself. Dantzig's core insight was to realize that most such ground rules can be translated into a linear objective function that needs to be maximized.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> Development of the simplex method was evolutionary and happened over a period of about a year.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>

<p>After Dantzig included an objective function as part of his formulation during mid-1947, the problem was mathematically more tractable. Dantzig realized that one of the unsolved problems that <a href="George_Dantzig#Urban_Legend" title="wikilink">he mistook</a> as homework in his professor <a href="Jerzy_Neyman" title="wikilink">Jerzy Neyman</a>'s class (and actually later solved), was applicable to finding an algorithm for linear programs. This problem involved finding the existence of Lagrange multipliers for general linear programs over a continuum of variables, each bounded between zero and one, and satisfying linear constraints expressed in the form of Lebesgue integrals. Dantzig later published his "homework" as a thesis to earn his doctorate. The column geometry used in this thesis gave Dantzig insight that made him believe that the Simplex method would be very efficient.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>
<h2 id="standard-form">Standard form</h2>

<p>The transformation of a linear program to one in standard form may be accomplished as follows.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> First, for each variable with a lower bound other than 0, a new variable is introduced representing the difference between the variable and bound. The original variable can then be eliminated by substitution. For example, given the constraint</p>

<p>

<math display="block" id="Simplex_algorithm:10">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>≥</mo>
   <mn>5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}\geq 5
  </annotation>
 </semantics>
</math>

</p>

<p>a new variable, 

<math display="inline" id="Simplex_algorithm:11">
 <semantics>
  <msub>
   <mi>y</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{1}
  </annotation>
 </semantics>
</math>

, is introduced with</p>

<p>

<math display="inline" id="Simplex_algorithm:12">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>-</mo>
    <mn>5</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">5</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle y_{1}=x_{1}-5
  </annotation>
 </semantics>
</math>


</p>

<p>The second equation may be used to eliminate 

<math display="inline" id="Simplex_algorithm:13">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

 from the linear program. In this way, all lower bound constraints may be changed to non-negativity restrictions.</p>

<p>Second, for each remaining inequality constraint, a new variable, called a <em>slack variable</em>, is introduced to change the constraint to an equality constraint. This variable represents the difference between the two sides of the inequality and is assumed to be nonnegative. For example the inequalities</p>

<p>

<math display="inline" id="Simplex_algorithm:14">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>+</mo>
   <mrow>
    <mn>2</mn>
    <msub>
     <mi>x</mi>
     <mn>3</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle x_{2}+2x_{3}
  </annotation>
 </semantics>
</math>


</p>

<p>are replaced with</p>

<p>

<math display="inline" id="Simplex_algorithm:15">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>+</mo>
   <mrow>
    <mn>2</mn>
    <msub>
     <mi>x</mi>
     <mn>3</mn>
    </msub>
   </mrow>
   <mo>+</mo>
   <msub>
    <mi>s</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle x_{2}+2x_{3}+s_{1}
  </annotation>
 </semantics>
</math>


</p>

<p>It is much easier to perform algebraic manipulation on inequalities in this form. In inequalities where ≥ appears such as the second one, some authors refer to the variable introduced as a <mtpl></mtpl><em>surplus variable</em>.</p>

<p>Third, each unrestricted variable is eliminated from the linear program. This can be done in two ways, one is by solving for the variable in one of the equations in which it appears and then eliminating the variable by substitution. The other is to replace the variable with the difference of two restricted variables. For example if 

<math display="inline" id="Simplex_algorithm:16">
 <semantics>
  <msub>
   <mi>z</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>z</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{1}
  </annotation>
 </semantics>
</math>

 is unrestricted then write</p>

<p>

<math display="inline" id="Simplex_algorithm:17">
 <semantics>
  <mrow>
   <mi>z</mi>
   <msub>
    <mo>;</mo>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <msubsup>
    <mi>z</mi>
    <mn>1</mn>
    <mo>+</mo>
   </msubsup>
   <mo>-</mo>
   <msubsup>
    <mi>z</mi>
    <mn>1</mn>
    <mo>-</mo>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">z</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-;</ci>
     <cn type="integer">1</cn>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">1</cn>
     </apply>
     <plus></plus>
    </apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">1</cn>
     </apply>
     <minus></minus>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle z;_{1}=z_{1}^{+}-z_{1}^{-}
  </annotation>
 </semantics>
</math>


</p>

<p>The equation may be used to eliminate 

<math display="inline" id="Simplex_algorithm:18">
 <semantics>
  <msub>
   <mi>z</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>z</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{1}
  </annotation>
 </semantics>
</math>

 from the linear program.</p>

<p>When this process is complete the feasible region will be in the form</p>

<p>

<math display="block" id="Simplex_algorithm:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐀𝐱</mi>
    <mo>=</mo>
    <mi>𝐛</mi>
   </mrow>
   <mo rspace="4.2pt">,</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>≥</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>𝐀𝐱</ci>
     <ci>𝐛</ci>
    </apply>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}\mathbf{x}=\mathbf{b},\,x_{i}\geq 0
  </annotation>
 </semantics>
</math>

</p>

<p>It is also useful to assume that the rank of 

<math display="inline" id="Simplex_algorithm:20">
 <semantics>
  <mi>𝐀</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}
  </annotation>
 </semantics>
</math>

 is the number of rows. This results in no loss of generality since otherwise either the system 

<math display="inline" id="Simplex_algorithm:21">
 <semantics>
  <mrow>
   <mi>𝐀𝐱</mi>
   <mo>≥</mo>
   <mi>𝐛</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>𝐀𝐱</ci>
    <ci>𝐛</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}\mathbf{x}\geq\mathbf{b}
  </annotation>
 </semantics>
</math>

 has redundant equations which can be dropped, or the system is inconsistent and the linear program has no solution.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>
<h2 id="simplex-tableaux">Simplex tableaux</h2>

<p>A linear program in standard form can be represented as a <em>tableau</em> of the form</p>

<p>

<math display="block" id="Simplex_algorithm:22">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <msup>
        <mi>𝐜</mi>
        <mi>T</mi>
       </msup>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mi>𝐀</mi>
     </mtd>
     <mtd columnalign="center">
      <mi>𝐛</mi>
     </mtd>
    </mtr>
   </mtable>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="integer">1</cn>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐜</ci>
       <ci>T</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <ci>𝐀</ci>
     <ci>𝐛</ci>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}1&-\mathbf{c}^{T}&0\\
0&\mathbf{A}&\mathbf{b}\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>The first row defines the objective function and the remaining rows specify the constraints. (Note, different authors use different conventions as to the exact layout.) If the columns of A can be rearranged so that it contains the <a href="identity_matrix" title="wikilink">identity matrix</a> of order <em>p</em> (the number of rows in A) then the tableau is said to be in <em>canonical form</em>.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> The variables corresponding to the columns of the identity matrix are called <em>basic variables</em> while the remaining variables are called <em>nonbasic</em> or <em>free variables</em>. If the nonbasic variables are assumed to be 0, then the values of the basic variables are easily obtained as entries in <em>b</em> and this solution is a basic feasible solution.</p>

<p>Conversely, given a basic feasible solution, the columns corresponding to the nonzero variables can be expanded to a nonsingular matrix. If the corresponding tableau is multiplied by the inverse of this matrix then the result is a tableau in canonical form.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>

<p>Let</p>

<p>

<math display="block" id="Simplex_algorithm:23">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <msubsup>
        <mi>𝐜</mi>
        <mi>B</mi>
        <mi>T</mi>
       </msubsup>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <msubsup>
        <mi>𝐜</mi>
        <mi>D</mi>
        <mi>T</mi>
       </msubsup>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mi>I</mi>
     </mtd>
     <mtd columnalign="center">
      <mi>𝐃</mi>
     </mtd>
     <mtd columnalign="center">
      <mi>𝐛</mi>
     </mtd>
    </mtr>
   </mtable>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="integer">1</cn>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐜</ci>
        <ci>T</ci>
       </apply>
       <ci>B</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐜</ci>
        <ci>T</ci>
       </apply>
       <ci>D</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <ci>I</ci>
     <ci>𝐃</ci>
     <ci>𝐛</ci>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}1&-\mathbf{c}^{T}_{B}&-\mathbf{c}^{T}_{D}&0\\
0&I&\mathbf{D}&\mathbf{b}\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>be a tableau in canonical form. Additional <a href="Elementary_matrix#Row-addition_transformations" title="wikilink">row-addition transformations</a> can be applied to remove the coefficients <mtpl></mtpl> from the objective function. This process is called <em>pricing out</em> and results in a canonical tableau</p>

<p>

<math display="block" id="Simplex_algorithm:24">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <msubsup>
        <mover accent="true">
         <mi>𝐜</mi>
         <mo stretchy="false">¯</mo>
        </mover>
        <mi>D</mi>
        <mi>T</mi>
       </msubsup>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <msub>
       <mi>z</mi>
       <mi>B</mi>
      </msub>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mi>I</mi>
     </mtd>
     <mtd columnalign="center">
      <mi>𝐃</mi>
     </mtd>
     <mtd columnalign="center">
      <mi>𝐛</mi>
     </mtd>
    </mtr>
   </mtable>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="integer">1</cn>
     <cn type="integer">0</cn>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <ci>normal-¯</ci>
         <ci>𝐜</ci>
        </apply>
        <ci>T</ci>
       </apply>
       <ci>D</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <ci>B</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <ci>I</ci>
     <ci>𝐃</ci>
     <ci>𝐛</ci>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}1&0&-\bar{\mathbf{c}}^{T}_{D}&z_{B}\\
0&I&\mathbf{D}&\mathbf{b}\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>z</em><sub><em>B</em></sub> is the value of the objective function at the corresponding basic feasible solution. The updated coefficients, also known as <em>relative cost coefficients</em>, are the rates of change of the objective function with respect to the nonbasic variables.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>
<h2 id="pivot-operations">Pivot operations</h2>

<p>The geometrical operation of moving from a basic feasible solution to an adjacent basic feasible solution is implemented as a <em>pivot operation</em>. First, a nonzero <em>pivot element</em> is selected in a nonbasic column. The row containing this element is <a href="Elementary_matrix#Row-multiplying_transformations" title="wikilink">multiplied</a> by its reciprocal to change this element to 1, and then multiples of the row are added to the other rows to change the other entries in the column to 0. The result is that, if the pivot element is in row <em>r</em>, then the column becomes the <em>r</em>-th column of the identity matrix. The variable for this column is now a basic variable, replacing the variable which corresponded to the <em>r</em>-th column of the identity matrix before the operation. In effect, the variable corresponding to the pivot column enters the set of basic variables and is called the <em>entering variable</em>, and the variable being replaced leaves the set of basic variables and is called the <em>leaving variable</em>. The tableau is still in canonical form but with the set of basic variables changed by one element.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a><a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>
<h2 id="algorithm">Algorithm</h2>

<p>Let a linear program be given by a canonical tableau. The simplex algorithm proceeds by performing successive pivot operations which each give an improved basic feasible solution; the choice of pivot element at each step is largely determined by the requirement that this pivot improve the solution.</p>
<h3 id="entering-variable-selection">Entering variable selection</h3>

<p>Since the entering variable will, in general, increase from 0 to a positive number, the value of the objective function will decrease if the derivative of the objective function with respect to this variable is negative. Equivalently, the value of the objective function is decreased if the pivot column is selected so that the corresponding entry in the objective row of the tableau is positive.</p>

<p>If there is more than one column so that the entry in the objective row is positive then the choice of which one to add to the set of basic variables is somewhat arbitrary and several <em>entering variable choice rules</em><a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> have been developed.</p>

<p>If all the entries in the objective row are less than or equal to 0 then no choice of entering variable can be made and the solution is in fact optimal. It is easily seen to be optimal since the objective row now corresponds to an equation of the form</p>

<p>

<math display="block" id="Simplex_algorithm:25">
 <semantics>
  <mrow>
   <mrow>
    <mi>z</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>z</mi>
     <mi>B</mi>
    </msub>
    <mo>+</mo>
    <mtext>nonnegative terms corresponding to nonbasic variables</mtext>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>z</ci>
     <ci>𝐱</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <ci>B</ci>
     </apply>
     <mtext>nonnegative terms corresponding to nonbasic variables</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z(\mathbf{x})=z_{B}+\text{nonnegative terms corresponding to nonbasic variables}
  </annotation>
 </semantics>
</math>

</p>

<p>Note that by changing the entering variable choice rule so that it selects a column where the entry in the objective row is negative, the algorithm is changed so that it finds the maximum of the objective function rather than the minimum.</p>
<h3 id="leaving-variable-selection">Leaving variable selection</h3>

<p>Once the pivot column has been selected, the choice of pivot row is largely determined by the requirement that the resulting solution be feasible. First, only positive entries in the pivot column are considered since this guarantees that the value of the entering variable will be nonnegative. If there are no positive entries in the pivot column then the entering variable can take any nonnegative value with the solution remaining feasible. In this case the objective function is unbounded below and there is no minimum.</p>

<p>Next, the pivot row must be selected so that all the other basic variables remain positive. A calculation shows that this occurs when the resulting value of the entering variable is at a minimum. In other words, if the pivot column is <em>c</em>, then the pivot row <em>r</em> is chosen so that</p>

<p>

<math display="block" id="Simplex_algorithm:26">
 <semantics>
  <mrow>
   <msub>
    <mi>b</mi>
    <mi>r</mi>
   </msub>
   <mo>/</mo>
   <mpadded width="+1.7pt">
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>r</mi>
      <mi>c</mi>
     </mrow>
    </msub>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <ci>r</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{r}/a_{rc}\,
  </annotation>
 </semantics>
</math>

</p>

<p>is the minimum over all <em>r</em> so that <em>a</em><sub><em>rc</em></sub> &gt; 0. This is called the <em>minimum ratio test</em>.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> If there is more than one row for which the minimum is achieved then a <em>dropping variable choice rule</em><a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> can be used to make the determination.</p>
<h3 id="example">Example</h3>

<p><mtpl></mtpl> Consider the linear program</p>
<dl>
<dd>Minimize

<p>

<math display="block" id="Simplex_algorithm:27">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mn>2</mn>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mn>3</mn>
     <mi>y</mi>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mn>4</mn>
     <mpadded width="+1.7pt">
      <mi>z</mi>
     </mpadded>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Z</ci>
    <apply>
     <minus></minus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">3</cn>
      <ci>y</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">4</cn>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z=-2x-3y-4z\,
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>Subject to

<p>:<math>\begin{align}</math></p>
</dd>
</dl>

<p><code> 3 x + 2 y + z &amp;\le 10\\</code><br/>
<code> 2 x + 5 y + 3 z &amp;\le 15\\</code><br/>
<code> x,\,y,\,z &amp;\ge 0</code></p>

<p>\end{align}</p>

<p>With the addition of slack variables <em>s</em> and <em>t</em>, this is represented by the canonical tableau</p>

<p>

<math display="block" id="Simplex_algorithm:28">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>2</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>3</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>4</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>3</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>2</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>10</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>2</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>5</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>3</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>15</mn>
     </mtd>
    </mtr>
   </mtable>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
     <cn type="integer">4</cn>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">3</cn>
     <cn type="integer">2</cn>
     <cn type="integer">1</cn>
     <cn type="integer">1</cn>
     <cn type="integer">0</cn>
     <cn type="integer">10</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">2</cn>
     <cn type="integer">5</cn>
     <cn type="integer">3</cn>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <cn type="integer">15</cn>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}1&2&3&4&0&0&0\\
0&3&2&1&1&0&10\\
0&2&5&3&0&1&15\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>where columns 5 and 6 represent the basic variables <em>s</em> and <em>t</em> and the corresponding basic feasible solution is</p>

<p>

<math display="block" id="Simplex_algorithm:29">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>=</mo>
    <mi>y</mi>
    <mo>=</mo>
    <mi>z</mi>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo rspace="4.2pt">,</mo>
   <mrow>
    <mrow>
     <mi>s</mi>
     <mo>=</mo>
     <mn>10</mn>
    </mrow>
    <mo rspace="4.2pt">,</mo>
    <mrow>
     <mi>t</mi>
     <mo>=</mo>
     <mn>15.</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <ci>z</ci>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <ci>s</ci>
      <cn type="integer">10</cn>
     </apply>
     <apply>
      <eq></eq>
      <ci>t</ci>
      <cn type="float">15.</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=y=z=0,\,s=10,\,t=15.
  </annotation>
 </semantics>
</math>

</p>

<p>Columns 2, 3, and 4 can be selected as pivot columns, for this example column 4 is selected. The values of <em>z</em> resulting from the choice of rows 2 and 3 as pivot rows are 10/1 = 10 and 15/3 = 5 respectively. Of these the minimum is 5, so row 3 must be the pivot row. Performing the pivot produces</p>

<p>

<math display="block" id="Simplex_algorithm:30">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <mstyle displaystyle="false">
        <mfrac>
         <mn>2</mn>
         <mn>3</mn>
        </mfrac>
       </mstyle>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <mstyle displaystyle="false">
        <mfrac>
         <mn>11</mn>
         <mn>3</mn>
        </mfrac>
       </mstyle>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <mstyle displaystyle="false">
        <mfrac>
         <mn>4</mn>
         <mn>3</mn>
        </mfrac>
       </mstyle>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <mn>20</mn>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mstyle displaystyle="false">
       <mfrac>
        <mn>7</mn>
        <mn>3</mn>
       </mfrac>
      </mstyle>
     </mtd>
     <mtd columnalign="center">
      <mstyle displaystyle="false">
       <mfrac>
        <mn>1</mn>
        <mn>3</mn>
       </mfrac>
      </mstyle>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <mstyle displaystyle="false">
        <mfrac>
         <mn>1</mn>
         <mn>3</mn>
        </mfrac>
       </mstyle>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mn>5</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mstyle displaystyle="false">
       <mfrac>
        <mn>2</mn>
        <mn>3</mn>
       </mfrac>
      </mstyle>
     </mtd>
     <mtd columnalign="center">
      <mstyle displaystyle="false">
       <mfrac>
        <mn>5</mn>
        <mn>3</mn>
       </mfrac>
      </mstyle>
     </mtd>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mstyle displaystyle="false">
       <mfrac>
        <mn>1</mn>
        <mn>3</mn>
       </mfrac>
      </mstyle>
     </mtd>
     <mtd columnalign="center">
      <mn>5</mn>
     </mtd>
    </mtr>
   </mtable>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="integer">1</cn>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">2</cn>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">11</cn>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">4</cn>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">20</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <apply>
      <divide></divide>
      <cn type="integer">7</cn>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">3</cn>
     </apply>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <cn type="integer">5</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <apply>
      <divide></divide>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">5</cn>
      <cn type="integer">3</cn>
     </apply>
     <cn type="integer">1</cn>
     <cn type="integer">0</cn>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">3</cn>
     </apply>
     <cn type="integer">5</cn>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}1&-\tfrac{2}{3}&-\tfrac{11}{3}&0&0&-\tfrac{4}{3}&-20\\
0&\tfrac{7}{3}&\tfrac{1}{3}&0&1&-\tfrac{1}{3}&5\\
0&\tfrac{2}{3}&\tfrac{5}{3}&1&0&\tfrac{1}{3}&5\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>Now columns 4 and 5 represent the basic variables <em>z</em> and <em>s</em> and the corresponding basic feasible solution is</p>

<p>

<math display="block" id="Simplex_algorithm:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>=</mo>
    <mi>y</mi>
    <mo>=</mo>
    <mi>t</mi>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo rspace="4.2pt">,</mo>
   <mrow>
    <mrow>
     <mi>z</mi>
     <mo>=</mo>
     <mn>5</mn>
    </mrow>
    <mo rspace="4.2pt">,</mo>
    <mrow>
     <mi>s</mi>
     <mo>=</mo>
     <mn>5.</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <ci>t</ci>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <ci>z</ci>
      <cn type="integer">5</cn>
     </apply>
     <apply>
      <eq></eq>
      <ci>s</ci>
      <cn type="float">5.</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=y=t=0,\,z=5,\,s=5.
  </annotation>
 </semantics>
</math>

</p>

<p>For the next step, there are no positive entries in the objective row and in fact</p>

<p>

<math display="block" id="Simplex_algorithm:32">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mn>20</mn>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mstyle displaystyle="false">
      <mfrac>
       <mn>2</mn>
       <mn>3</mn>
      </mfrac>
     </mstyle>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mstyle displaystyle="false">
      <mfrac>
       <mn>11</mn>
       <mn>3</mn>
      </mfrac>
     </mstyle>
     <mi>y</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mstyle displaystyle="false">
      <mfrac>
       <mn>4</mn>
       <mn>3</mn>
      </mfrac>
     </mstyle>
     <mi>t</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Z</ci>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <cn type="integer">20</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">2</cn>
       <cn type="integer">3</cn>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">11</cn>
       <cn type="integer">3</cn>
      </apply>
      <ci>y</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">4</cn>
       <cn type="integer">3</cn>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z=-20+\tfrac{2}{3}x+\tfrac{11}{3}y+\tfrac{4}{3}t
  </annotation>
 </semantics>
</math>

 so the minimum value of <em>Z</em> is −20.</p>
<h2 id="finding-an-initial-canonical-tableau">Finding an initial canonical tableau</h2>

<p>In general, a linear program will not be given in canonical form and an equivalent canonical tableau must be found before the simplex algorithm can start. This can be accomplished by the introduction of <em>artificial variables</em>. Columns of the identity matrix are added as column vectors for these variables. If the b value for a constraint equation is negative, the equation is negated before adding the identity matrix columns. This does not change the set of feasible solutions or the optimal solution, and it ensures that the slack variables will constitute an initial feasible solution. The new tableau is in canonical form but it is not equivalent to the original problem. So a new objective function, equal to the sum of the artificial variables, is introduced and the simplex algorithm is applied to find the minimum; the modified linear program is called the <em>Phase I</em> problem.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></p>

<p>The simplex algorithm applied to the Phase I problem must terminate with a minimum value for the new objective function since, being the sum of nonnegative variables, its value is bounded below by 0. If the minimum is 0 then the artificial variables can be eliminated from the resulting canonical tableau producing a canonical tableau equivalent to the original problem. The simplex algorithm can then be applied to find the solution; this step is called <em>Phase II</em>. If the minimum is positive then there is no feasible solution for the Phase I problem where the artificial variables are all zero. This implies that the feasible region for the original problem is empty, and so the original problem has no solution.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a><a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a><a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a></p>
<h3 id="example-1">Example</h3>

<p>Consider the linear program</p>
<dl>
<dd>Minimize

<p>

<math display="block" id="Simplex_algorithm:33">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mn>2</mn>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mn>3</mn>
     <mi>y</mi>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mn>4</mn>
     <mpadded width="+1.7pt">
      <mi>z</mi>
     </mpadded>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Z</ci>
    <apply>
     <minus></minus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">3</cn>
      <ci>y</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">4</cn>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z=-2x-3y-4z\,
  </annotation>
 </semantics>
</math>

</p>
</dd>
</dl>
<dl>
<dd>Subject to

<p>:<math>\begin{align}</math></p>
</dd>
</dl>

<p><code>3 x + 2 y + z &amp;= 10\\</code><br/>
<code>2 x + 5 y + 3 z &amp;= 15\\</code><br/>
<code>x,\, y,\, z &amp;\ge 0</code></p>

<p>\end{align}</p>

<p>This is represented by the (non-canonical) tableau</p>

<p>

<math display="block" id="Simplex_algorithm:34">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>2</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>3</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>4</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>3</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>2</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>10</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>2</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>5</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>3</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>15</mn>
     </mtd>
    </mtr>
   </mtable>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
     <cn type="integer">4</cn>
     <cn type="integer">0</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">3</cn>
     <cn type="integer">2</cn>
     <cn type="integer">1</cn>
     <cn type="integer">10</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">2</cn>
     <cn type="integer">5</cn>
     <cn type="integer">3</cn>
     <cn type="integer">15</cn>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}1&2&3&4&0\\
0&3&2&1&10\\
0&2&5&3&15\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>Introduce artificial variables <em>u</em> and <em>v</em> and objective function <em>W</em> = <em>u</em> + <em>v</em>, giving a new tableau</p>

<p>

<math display="block" id="Simplex_algorithm:35">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>2</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>3</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>4</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>3</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>2</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>10</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>2</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>5</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>3</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>15</mn>
     </mtd>
    </mtr>
   </mtable>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="integer">1</cn>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">0</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
     <cn type="integer">4</cn>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <cn type="integer">3</cn>
     <cn type="integer">2</cn>
     <cn type="integer">1</cn>
     <cn type="integer">1</cn>
     <cn type="integer">0</cn>
     <cn type="integer">10</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <cn type="integer">2</cn>
     <cn type="integer">5</cn>
     <cn type="integer">3</cn>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <cn type="integer">15</cn>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}1&0&0&0&0&-1&-1&0\\
0&1&2&3&4&0&0&0\\
0&0&3&2&1&1&0&10\\
0&0&2&5&3&0&1&15\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>Note that the equation defining the original objective function is retained in anticipation of Phase II.</p>

<p>After pricing out this becomes</p>

<p>

<math display="block" id="Simplex_algorithm:36">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>5</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>7</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>4</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>25</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>2</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>3</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>4</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>3</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>2</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>10</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>2</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>5</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>3</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>15</mn>
     </mtd>
    </mtr>
   </mtable>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="integer">1</cn>
     <cn type="integer">0</cn>
     <cn type="integer">5</cn>
     <cn type="integer">7</cn>
     <cn type="integer">4</cn>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <cn type="integer">25</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
     <cn type="integer">4</cn>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <cn type="integer">3</cn>
     <cn type="integer">2</cn>
     <cn type="integer">1</cn>
     <cn type="integer">1</cn>
     <cn type="integer">0</cn>
     <cn type="integer">10</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <cn type="integer">2</cn>
     <cn type="integer">5</cn>
     <cn type="integer">3</cn>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <cn type="integer">15</cn>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}1&0&5&7&4&0&0&25\\
0&1&2&3&4&0&0&0\\
0&0&3&2&1&1&0&10\\
0&0&2&5&3&0&1&15\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>Select column 5 as a pivot column, so the pivot row must be row 4, and the updated tableau is</p>

<p>

<math display="block" id="Simplex_algorithm:37">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mstyle displaystyle="false">
       <mfrac>
        <mn>7</mn>
        <mn>3</mn>
       </mfrac>
      </mstyle>
     </mtd>
     <mtd columnalign="center">
      <mstyle displaystyle="false">
       <mfrac>
        <mn>1</mn>
        <mn>3</mn>
       </mfrac>
      </mstyle>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <mstyle displaystyle="false">
        <mfrac>
         <mn>4</mn>
         <mn>3</mn>
        </mfrac>
       </mstyle>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mn>5</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <mstyle displaystyle="false">
        <mfrac>
         <mn>2</mn>
         <mn>3</mn>
        </mfrac>
       </mstyle>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <mstyle displaystyle="false">
        <mfrac>
         <mn>11</mn>
         <mn>3</mn>
        </mfrac>
       </mstyle>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <mstyle displaystyle="false">
        <mfrac>
         <mn>4</mn>
         <mn>3</mn>
        </mfrac>
       </mstyle>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <mn>20</mn>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mstyle displaystyle="false">
       <mfrac>
        <mn>7</mn>
        <mn>3</mn>
       </mfrac>
      </mstyle>
     </mtd>
     <mtd columnalign="center">
      <mstyle displaystyle="false">
       <mfrac>
        <mn>1</mn>
        <mn>3</mn>
       </mfrac>
      </mstyle>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <mstyle displaystyle="false">
        <mfrac>
         <mn>1</mn>
         <mn>3</mn>
        </mfrac>
       </mstyle>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mn>5</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mstyle displaystyle="false">
       <mfrac>
        <mn>2</mn>
        <mn>3</mn>
       </mfrac>
      </mstyle>
     </mtd>
     <mtd columnalign="center">
      <mstyle displaystyle="false">
       <mfrac>
        <mn>5</mn>
        <mn>3</mn>
       </mfrac>
      </mstyle>
     </mtd>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mstyle displaystyle="false">
       <mfrac>
        <mn>1</mn>
        <mn>3</mn>
       </mfrac>
      </mstyle>
     </mtd>
     <mtd columnalign="center">
      <mn>5</mn>
     </mtd>
    </mtr>
   </mtable>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="integer">1</cn>
     <cn type="integer">0</cn>
     <apply>
      <divide></divide>
      <cn type="integer">7</cn>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">3</cn>
     </apply>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">4</cn>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <cn type="integer">5</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">2</cn>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">11</cn>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">4</cn>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">20</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <apply>
      <divide></divide>
      <cn type="integer">7</cn>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">3</cn>
     </apply>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <cn type="integer">5</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <apply>
      <divide></divide>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">5</cn>
      <cn type="integer">3</cn>
     </apply>
     <cn type="integer">1</cn>
     <cn type="integer">0</cn>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">3</cn>
     </apply>
     <cn type="integer">5</cn>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}1&0&\tfrac{7}{3}&\tfrac{1}{3}&0&0&-\tfrac{4}{3}&5\\
0&1&-\tfrac{2}{3}&-\tfrac{11}{3}&0&0&-\tfrac{4}{3}&-20\\
0&0&\tfrac{7}{3}&\tfrac{1}{3}&0&1&-\tfrac{1}{3}&5\\
0&0&\tfrac{2}{3}&\tfrac{5}{3}&1&0&\tfrac{1}{3}&5\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>Now select column 3 as a pivot column, for which row 3 must be the pivot row, to get</p>

<p>

<math display="block" id="Simplex_algorithm:38">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <mstyle displaystyle="false">
        <mfrac>
         <mn>25</mn>
         <mn>7</mn>
        </mfrac>
       </mstyle>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mstyle displaystyle="false">
       <mfrac>
        <mn>2</mn>
        <mn>7</mn>
       </mfrac>
      </mstyle>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <mstyle displaystyle="false">
        <mfrac>
         <mn>10</mn>
         <mn>7</mn>
        </mfrac>
       </mstyle>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <mstyle displaystyle="false">
        <mfrac>
         <mn>130</mn>
         <mn>7</mn>
        </mfrac>
       </mstyle>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mstyle displaystyle="false">
       <mfrac>
        <mn>1</mn>
        <mn>7</mn>
       </mfrac>
      </mstyle>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mstyle displaystyle="false">
       <mfrac>
        <mn>3</mn>
        <mn>7</mn>
       </mfrac>
      </mstyle>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <mstyle displaystyle="false">
        <mfrac>
         <mn>1</mn>
         <mn>7</mn>
        </mfrac>
       </mstyle>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mstyle displaystyle="false">
       <mfrac>
        <mn>15</mn>
        <mn>7</mn>
       </mfrac>
      </mstyle>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mstyle displaystyle="false">
       <mfrac>
        <mn>11</mn>
        <mn>7</mn>
       </mfrac>
      </mstyle>
     </mtd>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <mstyle displaystyle="false">
        <mfrac>
         <mn>2</mn>
         <mn>7</mn>
        </mfrac>
       </mstyle>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mstyle displaystyle="false">
       <mfrac>
        <mn>3</mn>
        <mn>7</mn>
       </mfrac>
      </mstyle>
     </mtd>
     <mtd columnalign="center">
      <mstyle displaystyle="false">
       <mfrac>
        <mn>25</mn>
        <mn>7</mn>
       </mfrac>
      </mstyle>
     </mtd>
    </mtr>
   </mtable>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="integer">1</cn>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">0</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <cn type="integer">0</cn>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">25</cn>
       <cn type="integer">7</cn>
      </apply>
     </apply>
     <cn type="integer">0</cn>
     <apply>
      <divide></divide>
      <cn type="integer">2</cn>
      <cn type="integer">7</cn>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">10</cn>
       <cn type="integer">7</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">130</cn>
       <cn type="integer">7</cn>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">7</cn>
     </apply>
     <cn type="integer">0</cn>
     <apply>
      <divide></divide>
      <cn type="integer">3</cn>
      <cn type="integer">7</cn>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">7</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">15</cn>
      <cn type="integer">7</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <apply>
      <divide></divide>
      <cn type="integer">11</cn>
      <cn type="integer">7</cn>
     </apply>
     <cn type="integer">1</cn>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">2</cn>
       <cn type="integer">7</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">3</cn>
      <cn type="integer">7</cn>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">25</cn>
      <cn type="integer">7</cn>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}1&0&0&0&0&-1&-1&0\\
0&1&0&-\tfrac{25}{7}&0&\tfrac{2}{7}&-\tfrac{10}{7}&-\tfrac{130}{7}\\
0&0&1&\tfrac{1}{7}&0&\tfrac{3}{7}&-\tfrac{1}{7}&\tfrac{15}{7}\\
0&0&0&\tfrac{11}{7}&1&-\tfrac{2}{7}&\tfrac{3}{7}&\tfrac{25}{7}\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>The artificial variables are now 0 and they may be dropped giving a canonical tableau equivalent to the original problem:</p>

<p>

<math display="block" id="Simplex_algorithm:39">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <mstyle displaystyle="false">
        <mfrac>
         <mn>25</mn>
         <mn>7</mn>
        </mfrac>
       </mstyle>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo>-</mo>
       <mstyle displaystyle="false">
        <mfrac>
         <mn>130</mn>
         <mn>7</mn>
        </mfrac>
       </mstyle>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mstyle displaystyle="false">
       <mfrac>
        <mn>1</mn>
        <mn>7</mn>
       </mfrac>
      </mstyle>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mstyle displaystyle="false">
       <mfrac>
        <mn>15</mn>
        <mn>7</mn>
       </mfrac>
      </mstyle>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mstyle displaystyle="false">
       <mfrac>
        <mn>11</mn>
        <mn>7</mn>
       </mfrac>
      </mstyle>
     </mtd>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mstyle displaystyle="false">
       <mfrac>
        <mn>25</mn>
        <mn>7</mn>
       </mfrac>
      </mstyle>
     </mtd>
    </mtr>
   </mtable>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="integer">1</cn>
     <cn type="integer">0</cn>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">25</cn>
       <cn type="integer">7</cn>
      </apply>
     </apply>
     <cn type="integer">0</cn>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">130</cn>
       <cn type="integer">7</cn>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">7</cn>
     </apply>
     <cn type="integer">0</cn>
     <apply>
      <divide></divide>
      <cn type="integer">15</cn>
      <cn type="integer">7</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
     <apply>
      <divide></divide>
      <cn type="integer">11</cn>
      <cn type="integer">7</cn>
     </apply>
     <cn type="integer">1</cn>
     <apply>
      <divide></divide>
      <cn type="integer">25</cn>
      <cn type="integer">7</cn>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}1&0&-\tfrac{25}{7}&0&-\tfrac{130}{7}\\
0&1&\tfrac{1}{7}&0&\tfrac{15}{7}\\
0&0&\tfrac{11}{7}&1&\tfrac{25}{7}\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>This is, fortuitously, already optimal and the optimum value for the original linear program is −130/7.</p>
<h2 id="advanced-topics">Advanced topics</h2>
<h3 id="implementation">Implementation</h3>

<p><mtpl></mtpl> The tableau form used above to describe the algorithm lends itself to an immediate implementation in which the tableau is maintained as a rectangular (<em>m</em> + 1)-by-(<em>m</em> + <em>n</em> + 1) array. It is straightforward to avoid storing the m explicit columns of the identity matrix that will occur within the tableau by virtue of <strong>B</strong> being a subset of the columns of [<strong>A</strong>, <strong>I</strong>]. This implementation is referred to as the "<em>standard</em> simplex algorithm". The storage and computation overhead are such that the standard simplex method is a prohibitively expensive approach to solving large linear programming problems.</p>

<p>In each simplex iteration, the only data required are the first row of the tableau, the (pivotal) column of the tableau corresponding to the entering variable and the right-hand-side. The latter can be updated using the pivotal column and the first row of the tableau can be updated using the (pivotal) row corresponding to the leaving variable. Both the pivotal column and pivotal row may be computed directly using the solutions of linear systems of equations involving the matrix <strong>B</strong> and a matrix-vector product using <strong>A</strong>. These observations motivate the "<a href="Revised_simplex_algorithm" title="wikilink"><em>revised</em> simplex algorithm</a>", for which implementations are distinguished by their invertible representation of <strong>B</strong>.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a></p>

<p>In large linear-programming problems <strong>A</strong> is typically a <a href="sparse_matrix" title="wikilink">sparse matrix</a> and, when the resulting sparsity of <strong>B</strong> is exploited when maintaining its invertible representation, the revised simplex algorithm is a much more efficient than the standard simplex method. Commercial simplex solvers are based on the revised simplex algorithm.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a><a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a><a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a><a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a><a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a></p>
<h3 id="degeneracy-stalling-and-cycling">Degeneracy: Stalling and cycling</h3>

<p>If the values of all basic variables are strictly positive, then a pivot must result in an improvement in the objective value. When this is always the case no set of basic variables occurs twice and the simplex algorithm must terminate after a finite number of steps. Basic feasible solutions where at least one of the ''basic ''variables is zero are called <em>degenerate</em> and may result in pivots for which there is no improvement in the objective value. In this case there is no actual change in the solution but only a change in the set of basic variables. When several such pivots occur in succession, there is no improvement; in large industrial applications, degeneracy is common and such "<em>stalling</em>" is notable. Worse than stalling is the possibility the same set of basic variables occurs twice, in which case, the deterministic pivoting rules of the simplex algorithm will produce an infinite loop, or "cycle". While degeneracy is the rule in practice and stalling is common, cycling is rare in practice. A discussion of an example of practical cycling occurs in Padberg.<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> <a href="Bland's_rule" title="wikilink">Bland's rule</a> prevents cycling and thus guarantees that the simplex algorithm always terminates.<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a><a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a><a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a> Another pivoting algorithm, the <a href="criss-cross_algorithm" title="wikilink">criss-cross algorithm</a> never cycles on linear programs.<a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a></p>
<h3 id="efficiency">Efficiency</h3>

<p>The simplex method is remarkably efficient in practice and was a great improvement over earlier methods such as <a href="Fourier–Motzkin_elimination" title="wikilink">Fourier–Motzkin elimination</a>. However, in 1972, Klee and Minty<a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a> gave an example showing that the worst-case complexity of simplex method as formulated by Dantzig is <a href="exponential_time" title="wikilink">exponential time</a>. Since then, for almost every variation on the method, it has been shown that there is a family of linear programs for which it performs badly. It is an open question if there is a variation with <a href="polynomial_time" title="wikilink">polynomial time</a>, or even sub-exponential worst-case complexity.<a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a><a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a></p>

<p>Analyzing and quantifying the observation that the simplex algorithm is efficient in practice, even though it has exponential worst-case complexity, has led to the development of other measures of complexity. The simplex algorithm has polynomial-time <a href="Best,_worst_and_average_case" title="wikilink">average-case complexity</a> under various <a href="probability_distribution" title="wikilink">probability distributions</a>, with the precise average-case performance of the simplex algorithm depending on the choice of a probability distribution for the <a href="random_matrix" title="wikilink">random matrices</a>.<a class="footnoteRef" href="#fn51" id="fnref51"><sup>51</sup></a><a class="footnoteRef" href="#fn52" id="fnref52"><sup>52</sup></a> Another approach to studying "<a href="porous_set" title="wikilink">typical phenoma</a>" uses <a href="Baire_category_theory" title="wikilink">Baire category theory</a> from <a href="general_topology" title="wikilink">general topology</a>, and to show that (topologically) "most" matrices can be solved by the simplex algorithm in a polynomial number of steps. Another method to analyze the performance of the simplex algorithm studies the behavior of worst-case scenarios under small perturbation – are worst-case scenarios stable under a small change (in the sense of <a href="structural_stability" title="wikilink">structural stability</a>), or do they become tractable? Formally, this method uses random problems to which is added a <a href="normal_distribution" title="wikilink">Gaussian</a> <a href="random_vector" title="wikilink">random vector</a> ("<a href="smoothed_complexity" title="wikilink">smoothed complexity</a>").<a class="footnoteRef" href="#fn53" id="fnref53"><sup>53</sup></a></p>
<h2 id="other-algorithms">Other algorithms</h2>

<p>Other algorithms for solving linear-programming problems are described in the <a href="linear_programming" title="wikilink">linear-programming</a> article. Another basis-exchange pivoting algorithm is the <a href="criss-cross_algorithm" title="wikilink">criss-cross algorithm</a>.<a class="footnoteRef" href="#fn54" id="fnref54"><sup>54</sup></a><a class="footnoteRef" href="#fn55" id="fnref55"><sup>55</sup></a> There are polynomial-time algorithms for linear programming that use interior point methods: These include <a class="uri" href="Khachiyan" title="wikilink">Khachiyan</a>'s <a href="ellipsoidal_algorithm" title="wikilink">ellipsoidal algorithm</a>, <a class="uri" href="Karmarkar" title="wikilink">Karmarkar</a>'s <a href="Karmarkar's_algorithm" title="wikilink">projective algorithm</a>, and <a href="interior_point_method" title="wikilink">path-following algorithms</a>.<a class="footnoteRef" href="#fn56" id="fnref56"><sup>56</sup></a></p>
<h2 id="linear-fractional-programming">Linear-fractional programming</h2>

<p><mtpl></mtpl> <a href="Linear-fractional_programming" title="wikilink">Linear–fractional programming</a> (LFP) is a generalization of <a href="linear_programming" title="wikilink">linear programming</a> (LP) where the objective function of linear programs are <a href="linear_functional" title="wikilink">linear functions</a> and the objective function of a linear–fractional program is a ratio of two linear functions. In other words, a linear program is a fractional–linear program in which the denominator is the constant function having the value one everywhere. A linear–fractional program can be solved by a variant of the simplex algorithm<a class="footnoteRef" href="#fn57" id="fnref57"><sup>57</sup></a><a class="footnoteRef" href="#fn58" id="fnref58"><sup>58</sup></a><a class="footnoteRef" href="#fn59" id="fnref59"><sup>59</sup></a><a class="footnoteRef" href="#fn60" id="fnref60"><sup>60</sup></a> or by the <a href="criss-cross_algorithm" title="wikilink">criss-cross algorithm</a>.<a class="footnoteRef" href="#fn61" id="fnref61"><sup>61</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Criss-cross_algorithm" title="wikilink">Criss-cross algorithm</a></li>
<li><a href="Fourier–Motzkin_elimination" title="wikilink">Fourier–Motzkin elimination</a></li>
<li><a href="Karmarkar's_algorithm" title="wikilink">Karmarkar's algorithm</a></li>
<li><a href="Nelder–Mead_method" title="wikilink">Nelder–Mead simplicial heuristic</a></li>
<li><a href="Bland's_rule" title="wikilink">Pivoting rule of Bland</a>, which avoids cycling</li>
</ul>
<h2 id="notes">Notes</h2>

<p><mtpl></mtpl></p>
<h2 id="references">References</h2>
<ul>
<li><mtpl></mtpl></li>
</ul>
<h2 id="further-reading">Further reading</h2>

<p>These introductions are written for students of <a href="computer_science" title="wikilink">computer science</a> and <a href="operations_research" title="wikilink">operations research</a>:</p>
<ul>
<li><a href="Thomas_H._Cormen" title="wikilink">Thomas H. Cormen</a>, <a href="Charles_E._Leiserson" title="wikilink">Charles E. Leiserson</a>, <a href="Ronald_L._Rivest" title="wikilink">Ronald L. Rivest</a>, and <a href="Clifford_Stein" title="wikilink">Clifford Stein</a>. <em>Introduction to Algorithms</em>, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Section 29.3: The simplex algorithm, pp. 790–804.</li>
<li>Frederick S. Hillier and Gerald J. Lieberman: <em>Introduction to Operations Research</em>, 8th edition. McGraw-Hill. ISBN 0-07-123828-X</li>
<li><mtpl></mtpl></li>
</ul>
<h2 id="external-links">External links</h2>

<p><mtpl></mtpl></p>
<ul>
<li><a href="http://www.isye.gatech.edu/~spyros/LP/LP.html">An Introduction to Linear Programming and the Simplex Algorithm</a> by Spyros Reveliotis of the Georgia Institute of Technology.</li>
<li>Greenberg, Harvey J., <em>Klee-Minty Polytope Shows Exponential Time Complexity of Simplex Method</em> University of Colorado at Denver (1997) <a href="http://glossary.computing.society.informs.org/notes/Klee-Minty.pdf">PDF download</a></li>
<li><a href="http://www.lokminglui.com/lpch3.pdf">Simplex Method</a> A tutorial for Simplex Method with examples (also two-phase and M-method).</li>
<li><a href="http://math.uww.edu/~mcfarlat/s-prob.htm">Example of Simplex Procedure for a Standard Linear Programming Problem</a> by Thomas McFarland of the University of Wisconsin-Whitewater.</li>
<li><a href="http://www.phpsimplex.com/simplex/simplex.htm?l=en">PHPSimplex: online tool to solve Linear Programming Problems</a> by Daniel Izquierdo and Juan José Ruiz of the University of Málaga (UMA, Spain)</li>
<li><a href="http://www.simplex-m.com">simplex-m</a> Online Simplex Solver</li>
</ul>

<p><mtpl></mtpl> <mtpl></mtpl></p>

<p><mtpl></mtpl> "</p>

<p><a href="Category:Optimization_algorithms_and_methods" title="wikilink">Category:Optimization algorithms and methods</a> <a href="Category:Operations_research" title="wikilink">Category:Operations research</a> <a href="Category:1947_in_computer_science" title="wikilink">Category:1947 in computer science</a> <a href="Category:Exchange_algorithms" title="wikilink">Category:Exchange algorithms</a> <a href="Category:Linear_programming" title="wikilink">Category:Linear programming</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><mtpl></mtpl><a href="#fnref1">↩</a></li>
<li id="fn2">Richard W. Cottle, ed. <em>The Basic George B. Dantzig</em>. Stanford Business Books, Stanford University Press, Stanford, California, 2003. (Selected papers by <a href="George_B._Dantzig" title="wikilink">George B. Dantzig</a>)<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="George_B._Dantzig" title="wikilink">George B. Dantzig</a> and Mukund N. Thapa. 1997. <em>Linear programming 1: Introduction</em>. Springer-Verlag.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="George_B._Dantzig" title="wikilink">George B. Dantzig</a> and Mukund N. Thapa. 2003. <em>Linear Programming 2: Theory and Extensions</em>. Springer-Verlag.<a href="#fnref4">↩</a></li>
<li id="fn5"><mtpl></mtpl> (Invited survey, from the International Symposium on Mathematical Programming.)<a href="#fnref5">↩</a></li>
<li id="fn6"><em>Computing in Science and Engineering</em>, volume 2, no. 1, 2000 <a href="http://www.computer.org/csdl/mags/cs/2000/01/c1022.html">html version</a><a href="#fnref6">↩</a></li>
<li id="fn7"><mtpl></mtpl><a href="#fnref7">↩</a></li>
<li id="fn8"><mtpl></mtpl><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><mtpl></mtpl><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><mtpl></mtpl><a href="#fnref12">↩</a></li>
<li id="fn13"><mtpl></mtpl><a href="#fnref13">↩</a></li>
<li id="fn14"><mtpl></mtpl><a href="#fnref14">↩</a></li>
<li id="fn15"><mtpl></mtpl><a href="#fnref15">↩</a></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19">Robert J. Vanderbei, <a href="http://www.princeton.edu/~rvdb/LPbook/"><em>Linear Programming: Foundations and Extensions</em></a>, 3rd ed., International Series in Operations Research &amp; Management Science, Vol. 114, Springer Verlag, 2008. ISBN 978-0-387-74387-5.<a href="#fnref19">↩</a></li>
<li id="fn20"><mtpl></mtpl><a href="#fnref20">↩</a></li>
<li id="fn21"><mtpl></mtpl><a href="#fnref21">↩</a></li>
<li id="fn22"><mtpl></mtpl><a href="#fnref22">↩</a></li>
<li id="fn23"><mtpl></mtpl><a href="#fnref23">↩</a></li>
<li id="fn24"><mtpl></mtpl><a href="#fnref24">↩</a></li>
<li id="fn25"><mtpl></mtpl><a href="#fnref25">↩</a></li>
<li id="fn26"><mtpl></mtpl><a href="#fnref26">↩</a></li>
<li id="fn27">Evar D. Nering and <a href="Albert_W._Tucker" title="wikilink">Albert W. Tucker</a>, 1993, <em>Linear Programs and Related Problems</em>, Academic Press. (elementary)<a href="#fnref27">↩</a></li>
<li id="fn28"></li>
<li id="fn29"></li>
<li id="fn30"><mtpl></mtpl><a href="#fnref30">↩</a></li>
<li id="fn31"></li>
<li id="fn32"><mtpl></mtpl><a href="#fnref32">↩</a></li>
<li id="fn33"><mtpl></mtpl><a href="#fnref33">↩</a></li>
<li id="fn34"></li>
<li id="fn35"></li>
<li id="fn36"></li>
<li id="fn37"></li>
<li id="fn38"></li>
<li id="fn39">M. Padberg, <em>Linear Optimization and Extensions</em>, Second Edition, Springer-Verlag, 1999.<a href="#fnref39">↩</a></li>
<li id="fn40">Dmitris Alevras and Manfred W. Padberg, <em>Linear Optimization and Extensions: Problems and Extensions</em>, Universitext, Springer-Verlag, 2001. (Problems from Padberg with solutions.)<a href="#fnref40">↩</a></li>
<li id="fn41"><mtpl></mtpl><a href="#fnref41">↩</a></li>
<li id="fn42"><mtpl></mtpl><a href="#fnref42">↩</a></li>
<li id="fn43"></li>
<li id="fn44"></li>
<li id="fn45"><mtpl></mtpl><a href="#fnref45">↩</a></li>
<li id="fn46"><mtpl></mtpl><a href="#fnref46">↩</a></li>
<li id="fn47">There are abstract optimization problems, called <a href="oriented_matroid" title="wikilink">oriented matroid</a> programs, on which Bland's rule cycles (incorrectly) while the <a href="criss-cross_algorithm" title="wikilink">criss-cross algorithm</a> terminates correctly.<a href="#fnref47">↩</a></li>
<li id="fn48"><mtpl></mtpl><a href="#fnref48">↩</a></li>
<li id="fn49"><a href="Christos_H._Papadimitriou" title="wikilink">Christos H. Papadimitriou</a> and Kenneth Steiglitz, <em>Combinatorial Optimization: Algorithms and Complexity</em>, Corrected republication with a new preface, Dover. (computer science)<a href="#fnref49">↩</a></li>
<li id="fn50"><a href="Alexander_Schrijver" title="wikilink">Alexander Schrijver</a>, <em>Theory of Linear and Integer Programming</em>. John Wiley &amp; sons, 1998, ISBN 0-471-98232-6 (mathematical)<a href="#fnref50">↩</a></li>
<li id="fn51"></li>
<li id="fn52">The simplex algorithm takes on average <em>D</em> steps for a cube. <mtpl></mtpl>: <mtpl></mtpl><a href="#fnref52">↩</a></li>
<li id="fn53"><mtpl></mtpl><a href="#fnref53">↩</a></li>
<li id="fn54"><mtpl></mtpl><a href="#fnref54">↩</a></li>
<li id="fn55"><mtpl></mtpl><a href="#fnref55">↩</a></li>
<li id="fn56"></li>
<li id="fn57"><mtpl></mtpl><a href="#fnref57">↩</a></li>
<li id="fn58">Chapter five: <mtpl></mtpl><a href="#fnref58">↩</a></li>
<li id="fn59"><mtpl></mtpl><a href="#fnref59">↩</a></li>
<li id="fn60"><mtpl></mtpl><a href="#fnref60">↩</a></li>
<li id="fn61"><a href="#fnref61">↩</a></li>
</ol>
</section>
</body>
</html>
