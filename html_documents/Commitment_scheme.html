<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="914">Commitment scheme</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Commitment scheme</h1>
<hr/>

<p>In <a class="uri" href="cryptography" title="wikilink">cryptography</a>, a <strong>commitment scheme</strong> allows one to commit to a chosen value (or chosen statement) while keeping it hidden to others, with the ability to reveal the committed value later.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Commitment schemes are designed so that a party cannot change the value or statement after they have committed to it: that is, commitment schemes are <em>binding</em>. Commitment schemes have important applications in a number of <a href="cryptographic_protocol" title="wikilink">cryptographic protocols</a> including secure <a href="coin_flipping#Coin_flipping_in_telecommunications" title="wikilink">coin flipping</a>, <a href="zero-knowledge_proof" title="wikilink">zero-knowledge proofs</a>, and <a href="secure_computation" title="wikilink">secure computation</a>.</p>

<p>A way to visualize a commitment scheme is to think of a sender as putting a message in a locked box, and giving the box to a receiver. The message in the box is hidden from the receiver, who cannot open the lock themselves. Since the receiver has the box, the message inside cannot be changed—merely revealed if the sender chooses to give them the key at some later time.</p>

<p>Interactions in a commitment scheme take place in two phases:</p>
<ol>
<li>the <em>commit phase</em> during which a value is chosen and specified</li>
<li>the <em>reveal phase</em> during which the value is revealed and checked</li>
</ol>

<p>In simple protocols, the commit phase consists of a single message from the sender to the receiver. This message is called <em>the commitment</em>. It is essential that the specific value chosen cannot be known by the receiver at that time (this is called the <em>hiding</em> property). A simple reveal phase would consist of a single message, <em>the opening</em>, from the sender to the receiver, followed by a check performed by the receiver. The value chosen during the commit phase must be the only one that the sender can compute and that validates during the reveal phase (this is called the <em>binding</em> property).</p>

<p>The concept of commitment schemes was first formalized by <a href="Gilles_Brassard" title="wikilink">Gilles Brassard</a>, <a href="David_Chaum" title="wikilink">David Chaum</a>, and <a href="Claude_Crepeau" title="wikilink">Claude Crepeau</a> in 1988,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> but the concept was used without being treated formally prior to that.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The notion of commitments appeared earliest in works by <a href="Manuel_Blum" title="wikilink">Manuel Blum</a>,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> <a href="Shimon_Even" title="wikilink">Shimon Even</a>,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> and <a href="Adi_Shamir" title="wikilink">Shamir</a> et al.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> The terminology seems to have been originated by Blum,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> although commitment schemes can be interchangeably called <strong>bit commitment schemes</strong>—sometimes reserved for the special case where the committed value is a binary <a class="uri" href="bit" title="wikilink">bit</a>.</p>
<h2 id="applications">Applications</h2>
<h3 id="coin-flipping">Coin flipping</h3>

<p>Suppose <a href="Alice_and_Bob" title="wikilink">Alice and Bob</a> want to resolve some dispute via <a href="coin_flipping" title="wikilink">coin flipping</a>. If they are physically in the same place, a typical procedure might be:</p>
<ol>
<li>Alice "calls" the coin flip</li>
<li>Bob flips the coin</li>
<li>If Alice's call is correct, she wins, otherwise Bob wins</li>
</ol>

<p>If Alice and Bob are not in the same place a problem arises. Once Alice has "called" the coin flip, Bob can stipulate the flip "results" to be whatever is most desirable for him. Similarly, if Alice doesn't announce her "call" to Bob, after Bob flips the coin and announces the result, Alice can report that she called whatever result is most desirable for her. Alice and Bob can use commitments in a procedure that will allow both to trust the outcome:</p>
<ol>
<li>Alice "calls" the coin flip but only tells Bob a <em>commitment</em> to her call,</li>
<li>Bob flips the coin and reports the result,</li>
<li>Alice reveals what she committed to,</li>
<li>Bob verifies that Alice's call matches her commitment,</li>
<li>If Alice's revelation matches the coin result Bob reported, Alice wins</li>
</ol>

<p>For Bob to be able to skew the results to his favor, he must be able to understand the call hidden in Alice's commitment. If the commitment scheme is a good one, Bob cannot skew the results. Similarly, Alice cannot affect the result if she cannot change the value she commits to.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h3 id="zero-knowledge-proofs">Zero-knowledge proofs</h3>

<p>One particular motivating example is the use of commitment schemes in <a href="zero-knowledge_proof" title="wikilink">zero-knowledge proofs</a>. Commitments are used in zero-knowledge proofs for two main purposes: first, to allow the prover to participate in "cut and choose" proofs where the verifier will be presented with a choice of what to learn, and the prover will reveal only what corresponds to the verifier's choice. Commitment schemes allow the prover to specify all the information in advance in a commitment, and only reveal what should be revealed later in the proof.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> Commitments are also used in zero-knowledge proofs by the verifier, who will often specify their choices ahead of time in a commitment. This allows zero-knowledge proofs to be composed in parallel without revealing additional information.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h3 id="signature-schemes">Signature schemes</h3>

<p>The <a href="Lamport_signature" title="wikilink">Lamport signature scheme</a> is a <a href="digital_signature" title="wikilink">digital signature</a> system that relies on maintaining two sets of secret data packets, publishing <a href="Cryptographic_hash_function" title="wikilink">verifiable hashes</a> of the data packets, and then selectively revealing partial secret data packets in a manner that conforms specifically to the data to be signed. In this way, the prior public commitment to the secret values becomes a critical part of the functioning of the system.</p>

<p>Because the <a href="Lamport_signature" title="wikilink">Lamport signature</a> system cannot be used more than once (see the <a href="Lamport_signature" title="wikilink">relevant article</a> for details), a system to combine many Lamport Key-sets under a single public value that can be tied to a person and verified by others was developed. This system uses trees of <a href="Cryptographic_hash_function" title="wikilink">hashes</a> to compress many published lamport-key-commitments sets into a single hash value that can be associated with the prospective author of later verified data.</p>
<h3 id="verifiable-secret-sharing">Verifiable secret sharing</h3>

<p>Another important application of commitments is in <a href="verifiable_secret_sharing" title="wikilink">verifiable secret sharing</a>, a critical building block of <a href="secure_multiparty_computation" title="wikilink">secure multiparty computation</a>. In a <a href="secret_sharing" title="wikilink">secret sharing</a> scheme, each of several parties receive "shares" of a value that is meant to be hidden from everyone. If enough parties get together, their shares can be used to reconstruct the secret, but even a malicious <a class="uri" href="cabal" title="wikilink">cabal</a> of insufficient size should learn nothing. Secret sharing is at the root of many protocols for <a href="secure_computation" title="wikilink">secure computation</a>: in order to securely compute a function of some shared input, the secret shares are manipulated instead. However, if shares are to be generated by malicious parties, it may be important that those shares can be checked for correctness. In a verifiable secret sharing scheme, the distribution of a secret is accompanied by commitments to the individual shares. The commitments reveal nothing that can help a dishonest cabal, but the shares allow each individual party to check to see if their shares are correct.</p>
<h2 id="defining-the-security-of-commitment-schemes">Defining the security of commitment schemes</h2>

<p>Formal definitions of commitment schemes vary strongly in notation and in flavour. The first such flavour is whether the commitment scheme provides perfect or computational security with respect to the hiding or binding properties. Another such flavour is whether the commitment is interactive, i.e. whether both the commit phase and the reveal phase can be seen as being executed by a <a href="cryptographic_protocol" title="wikilink">cryptographic protocol</a> or whether they are non-interactive, consisting of two algorithms <em>Commit</em> and <em>CheckReveal</em>. In the latter case <em>CheckReveal</em> can often be seen as a derandomised version of <em>Commit</em>, with the randomness used by <em>Commit</em> constituting the opening information.</p>

<p>If the commitment <em>C</em> to a value <em>x</em> is computed as <em>C:=Commit(x,open)</em> with <em>open</em> the randomness used for computing the commitment, then <em>CheckReveal(C,x,open)</em> simply consists in verifying the equation <em>C=Commit(x,open)</em>.</p>

<p>Using this notation and some knowledge about <a href="mathematical_function" title="wikilink">mathematical functions</a> and <a href="probability_theory" title="wikilink">probability theory</a> we formalise different versions of the binding and hiding properties of commitments. The two most important combinations of these properties are perfectly binding and computationally hiding commitment schemes and computationally binding and perfectly hiding commitment schemes. Note that no commitment scheme can be at the same time perfectly binding and perfectly hiding - a computationally unbounded adversary can simply generate <em>Commit(x,open)</em> for every value of <em>x</em> and <em>open</em> until finding a pair that outputs <em>C</em>, and in a perfectly binding scheme this uniquely identifies <em>x</em>.</p>
<h3 id="computational-binding">Computational binding</h3>

<p>Let <em>open</em> be chosen from a set of size 

<math display="inline" id="Commitment_scheme:0">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{k}
  </annotation>
 </semantics>
</math>

, i.e., it can represented as a <em>k</em> bit string, and let 

<math display="inline" id="Commitment_scheme:1">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mi>o</mi>
   <mi>m</mi>
   <mi>m</mi>
   <mi>i</mi>
   <msub>
    <mi>t</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>o</ci>
    <ci>m</ci>
    <ci>m</ci>
    <ci>i</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Commit_{k}
  </annotation>
 </semantics>
</math>

 be the corresponding commitment scheme. As the size of <em>k</em> determines the security of the commitment scheme it is called the security parameter.</p>

<p>Then for all <a href="Uniformity_(complexity)" title="wikilink">non-uniform</a> probabilistic polynomial time algorithms that output 

<math display="inline" id="Commitment_scheme:2">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>,</mo>
   <msup>
    <mi>x</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,x^{\prime}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Commitment_scheme:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>o</mi>
    <mi>p</mi>
    <mi>e</mi>
    <mi>n</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>o</mi>
    <mi>p</mi>
    <mi>e</mi>
    <msup>
     <mi>n</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>p</ci>
     <ci>e</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>p</ci>
     <ci>e</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   open,open^{\prime}
  </annotation>
 </semantics>
</math>


 of increasing length <em>k</em>, the probability that 

<math display="inline" id="Commitment_scheme:4">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≠</mo>
   <msup>
    <mi>x</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\neq x^{\prime}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Commitment_scheme:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mi>o</mi>
    <mi>m</mi>
    <mi>m</mi>
    <mi>i</mi>
    <msub>
     <mi>t</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mrow>
      <mi>o</mi>
      <mi>p</mi>
      <mi>e</mi>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>C</mi>
    <mi>o</mi>
    <mi>m</mi>
    <mi>m</mi>
    <mi>i</mi>
    <msub>
     <mi>t</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>x</mi>
      <mo>′</mo>
     </msup>
     <mo>,</mo>
     <mrow>
      <mi>o</mi>
      <mi>p</mi>
      <mi>e</mi>
      <msup>
       <mi>n</mi>
       <mo>′</mo>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>o</ci>
     <ci>m</ci>
     <ci>m</ci>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>k</ci>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>o</ci>
       <ci>p</ci>
       <ci>e</ci>
       <ci>n</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>o</ci>
     <ci>m</ci>
     <ci>m</ci>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>k</ci>
     </apply>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <times></times>
       <ci>o</ci>
       <ci>p</ci>
       <ci>e</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Commit_{k}(x,open)=Commit_{k}(x^{\prime},open^{\prime})
  </annotation>
 </semantics>
</math>

 is a <a href="negligible_function" title="wikilink">negligible function</a> in <em>k</em>.</p>

<p>This is a form of <a href="asymptotic_analysis" title="wikilink">asymptotic analysis</a>. It is also possible to state the same requirement using <a href="concrete_security" title="wikilink">concrete security</a>: A commitment scheme <em>Commit</em> is 

<math display="inline" id="Commitment_scheme:6">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>t</mi>
   <mo>,</mo>
   <mi>ϵ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>t</ci>
    <ci>ϵ</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (t,\epsilon)
  </annotation>
 </semantics>
</math>

 secure, if for all algorithms that run in time <em>t</em> and output 

<math display="inline" id="Commitment_scheme:7">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>,</mo>
   <msup>
    <mi>x</mi>
    <mo>′</mo>
   </msup>
   <mo>,</mo>
   <mrow>
    <mi>o</mi>
    <mi>p</mi>
    <mi>e</mi>
    <mi>n</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>o</mi>
    <mi>p</mi>
    <mi>e</mi>
    <msup>
     <mi>n</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>p</ci>
     <ci>e</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>p</ci>
     <ci>e</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,x^{\prime},open,open^{\prime}
  </annotation>
 </semantics>
</math>

 the probability that 

<math display="inline" id="Commitment_scheme:8">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≠</mo>
   <msup>
    <mi>x</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\neq x^{\prime}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Commitment_scheme:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mi>o</mi>
    <mi>m</mi>
    <mi>m</mi>
    <mi>i</mi>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mrow>
      <mi>o</mi>
      <mi>p</mi>
      <mi>e</mi>
      <mi>n</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>C</mi>
    <mi>o</mi>
    <mi>m</mi>
    <mi>m</mi>
    <mi>i</mi>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>x</mi>
      <mo>′</mo>
     </msup>
     <mo>,</mo>
     <mrow>
      <mi>o</mi>
      <mi>p</mi>
      <mi>e</mi>
      <msup>
       <mi>n</mi>
       <mo>′</mo>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>o</ci>
     <ci>m</ci>
     <ci>m</ci>
     <ci>i</ci>
     <ci>t</ci>
     <interval closure="open">
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>o</ci>
       <ci>p</ci>
       <ci>e</ci>
       <ci>n</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>o</ci>
     <ci>m</ci>
     <ci>m</ci>
     <ci>i</ci>
     <ci>t</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <times></times>
       <ci>o</ci>
       <ci>p</ci>
       <ci>e</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Commit(x,open)=Commit(x^{\prime},open^{\prime})
  </annotation>
 </semantics>
</math>

 is at most 

<math display="inline" id="Commitment_scheme:10">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="perfect-statistical-and-computational-hiding">Perfect, statistical, and computational hiding</h3>

<p>Let 

<math display="inline" id="Commitment_scheme:11">
 <semantics>
  <msub>
   <mi>U</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>U</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U_{k}
  </annotation>
 </semantics>
</math>

 be the uniform distribution over the 

<math display="inline" id="Commitment_scheme:12">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{k}
  </annotation>
 </semantics>
</math>

 opening values for security parameter <em>k</em>. A commitment scheme is perfect, statistical, computational hiding, if for all 

<math display="inline" id="Commitment_scheme:13">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≠</mo>
   <msup>
    <mi>x</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\neq x^{\prime}
  </annotation>
 </semantics>
</math>


 the <a href="probability_ensemble" title="wikilink">probability ensembles</a> 

<math display="inline" id="Commitment_scheme:14">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>C</mi>
     <mi>o</mi>
     <mi>m</mi>
     <mi>m</mi>
     <mi>i</mi>
     <msub>
      <mi>t</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <msub>
       <mi>U</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>∈</mo>
    <mi class="ltx_font_mathcaligraphic">𝒩</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <set>
     <apply>
      <times></times>
      <ci>C</ci>
      <ci>o</ci>
      <ci>m</ci>
      <ci>m</ci>
      <ci>i</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>k</ci>
      </apply>
      <interval closure="open">
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>U</ci>
        <ci>k</ci>
       </apply>
      </interval>
     </apply>
    </set>
    <apply>
     <in></in>
     <ci>k</ci>
     <ci>𝒩</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{Commit_{k}(x,U_{k})\}_{k\in\mathcal{N}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Commitment_scheme:15">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>C</mi>
     <mi>o</mi>
     <mi>m</mi>
     <mi>m</mi>
     <mi>i</mi>
     <msub>
      <mi>t</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>x</mi>
       <mo>′</mo>
      </msup>
      <mo>,</mo>
      <msub>
       <mi>U</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>∈</mo>
    <mi class="ltx_font_mathcaligraphic">𝒩</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <set>
     <apply>
      <times></times>
      <ci>C</ci>
      <ci>o</ci>
      <ci>m</ci>
      <ci>m</ci>
      <ci>i</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>k</ci>
      </apply>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>U</ci>
        <ci>k</ci>
       </apply>
      </interval>
     </apply>
    </set>
    <apply>
     <in></in>
     <ci>k</ci>
     <ci>𝒩</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{Commit_{k}(x^{\prime},U_{k})\}_{k\in\mathcal{N}}
  </annotation>
 </semantics>
</math>

 are <a class="uri" href="equal" title="wikilink">equal</a>, <a href="statistically_close" title="wikilink">statistically close</a>, or <a href="computationally_indistinguishable" title="wikilink">computationally indistinguishable</a>.</p>
<h2 id="constructing-commitment-schemes">Constructing commitment schemes</h2>

<p>A commitment scheme can either be perfectly binding (it is impossible for Alice to alter her commitment after she has made it, even if she has unbounded computational resources) or perfectly concealing (it is impossible for Bob to find out the commitment without Alice revealing it, even if he has unbounded computational resources) but not both.</p>
<h3 id="bit-commitment-from-any-one-way-permutation">Bit-commitment from any one-way permutation</h3>

<p>One can create a bit-commitment scheme from any <a href="one-way_function" title="wikilink">one-way function</a> that is injective. The scheme relies on the fact that every one-way function can be modified (via the <a href="Goldreich-Levin_theorem" title="wikilink">Goldreich-Levin theorem</a>) to possess a computationally <a href="hard-core_predicate" title="wikilink">hard-core predicate</a> (while retaining the injective property). Let <em>f</em> be an injective one-way function, with <em>h</em> a hard-core predicate. Then to commit to a bit <em>b</em> Alice picks a random input <em>x</em> and sends the triple</p>

<p>

<math display="block" id="Commitment_scheme:16">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>h</mi>
   <mo>,</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>b</mi>
    <mo>⊕</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>h</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <ci>b</ci>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (h,f(x),b\oplus h(x))
  </annotation>
 </semantics>
</math>

 to Bob, where 

<math display="inline" id="Commitment_scheme:17">
 <semantics>
  <mo>⊕</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">direct-sum</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \oplus
  </annotation>
 </semantics>
</math>

 denotes XOR, i.e. addition modulo 2. To decommit Alice simply sends <em>x</em> to Bob. Bob verifies by computing <em>f(x)</em> and comparing to the committed value. This scheme is concealing because for Bob to recover <em>b</em> he must recover <em>h(x)</em>. Since <em>h</em> is a computationally hard-core predicate, recovering <em>h(x)</em> from <em>f(x)</em> with probability greater than one-half is as hard as inverting <em>f</em>. Perfect binding follows from the fact that <em>f</em> is injective and thus <em>f(x)</em> has exactly one preimage.</p>
<h3 id="bit-commitment-from-a-pseudo-random-generator">Bit-commitment from a pseudo-random generator</h3>

<p>Note that since we do not know how to construct a one-way permutation from any one-way function, this section reduces the strength of the cryptographic assumption necessary to construct a bit-commitment protocol.</p>

<p>In 1991 Moni Naor<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> showed how to create a bit-commitment scheme from a <a href="cryptographically_secure_pseudorandom_number_generator" title="wikilink">cryptographically secure pseudorandom number generator</a>. The construction is as follows. If <em>G</em> is pseudo-random generator such that <em>G</em> takes <em>n</em> bits to 3<em>n</em> bits, then if Alice wants to commit to a bit <em>b</em>:</p>
<ul>
<li>Bob selects a random 3<em>n</em>-bit vector <em>R</em> and sends <em>R</em> to Alice.</li>
<li>Alice selects a random <em>n</em>-bit vector <em>Y</em> and computes the 3<em>n</em>-bit vector <em>G(Y)</em>.</li>
<li>If <em>b</em>=1 Alice sends <em>G(Y)</em> to Bob, otherwise she sends the bitwise <a href="Exclusive_disjunction" title="wikilink">exclusive-or</a> of <em>G(Y)</em> and <em>R</em> to Bob.</li>
</ul>

<p>To decommit Alice sends <em>Y</em> to Bob, who can then check whether he initially received <em>G(Y)</em> or 

<math display="inline" id="Commitment_scheme:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>⊕</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">direct-sum</csymbol>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>Y</ci>
    </apply>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(Y)\oplus R
  </annotation>
 </semantics>
</math>


.</p>

<p>This scheme is statistically binding, meaning that even if Alice is computationally unbounded she cannot cheat with probability greater than 2<sup>−<em>n</em></sup>. For Alice to cheat, she would need to find a <em>Y'</em>, such that 

<math display="inline" id="Commitment_scheme:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>Y</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>G</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊕</mo>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>G</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Y</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>Y</ci>
     </apply>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(Y^{\prime})=G(Y)\oplus R
  </annotation>
 </semantics>
</math>

. If she could find such a value, she could decommit by sending the truth and <em>Y</em>, or send the opposite answer and <em>Y'</em>. However, <em>G(Y)</em> and <em>G(Y')</em> are only able to produce 2<sup><em>n</em></sup> possible values each (that's 2<sup>2<em>n</em></sup>) while <em>R</em> is picked out of 2<sup>3<em>n</em></sup> values. She does not pick <em>R</em>, so there is a 2<sup>2<em>n</em></sup>/2<sup>3<em>n</em></sup> = 2<sup>−<em>n</em></sup> probability that a <em>Y'</em> satisfying the equation required to cheat will not exist.</p>

<p>The concealing property follows from a standard reduction, if Bob can tell whether Alice committed to a zero or one, he can also distinguish the output of the pseudo-random generator <em>G</em> from true-random, which contradicts the cryptographic security of <em>G</em>.</p>
<h3 id="a-perfectly-binding-scheme-based-on-the-discrete-log-problem">A perfectly binding scheme based on the discrete log problem</h3>

<p>Alice chooses a <a href="group_(mathematics)" title="wikilink">group</a> of prime order <em>p</em>, with generator <em>g</em>.</p>

<p>Alice randomly picks a secret value <em>x</em> from <em>0</em> to <em>p</em> − 1 to commit to and calculates <em>c</em> = <em>g</em><sup><em>x</em></sup> and publishes <em>c</em>. The <a href="discrete_logarithm_problem" title="wikilink">discrete logarithm problem</a> dictates that from <em>c</em>, it is computationally infeasible to compute <em>x</em>, so under this assumption, Bob cannot compute <em>x</em>. On the other hand, Alice cannot compute a <em>x</em>'  <em>x</em>, such that <em>g</em><sup><em>x</em>'</sup> = <em>c</em>, so the scheme is binding.</p>

<p>This scheme isn't perfectly concealing as someone could find the commitment if he manages to solve the <a href="discrete_logarithm_problem" title="wikilink">discrete logarithm problem</a>. In fact, this scheme isn't hiding at all with respect to the standard hiding game, where an adversary should be unable to guess which of two messages he chose were committed to - similar to the <a class="uri" href="IND-CPA" title="wikilink">IND-CPA</a> game. One consequence of this is that if the space of possible values of <em>x</em> is small, then an attacker could simply try them all and the commitment would not be hiding.</p>

<p>A better example of a perfectly binding commitment scheme is one where the commitment is the encryption of <em>x</em> under a <a href="semantically_secure" title="wikilink">semantically secure</a>, public-key encryption scheme with perfect completeness, and the decommitment is the string of random bits used to encrypt <em>x</em>. An example of an information-theoretically hiding commitment scheme is the Pedersen commitment scheme, which is binding under the discrete logarithm assumption. Additionally to the scheme above, it uses another generator <em>h</em> of the prime group and a random number <em>r</em>. The commitment is set 

<math display="inline" id="Commitment_scheme:20">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>g</mi>
     <mi>x</mi>
    </msup>
    <msup>
     <mi>h</mi>
     <mi>r</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>c</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>h</ci>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=g^{x}h^{r}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="quantum-bit-commitment">Quantum bit commitment</h2>

<p>It is an interesting question in <a href="quantum_cryptography" title="wikilink">quantum cryptography</a> if <em>unconditionally secure</em> bit commitment protocols exist on the quantum level, that is, protocols which are (at least asymptotically) binding and concealing even if there are no restrictions on the computational resources. One could hope that there might be a way to exploit the intrinsic properties of quantum mechanics, as in the protocols for <a href="Quantum_key_distribution" title="wikilink">unconditionally secure key distribution</a>.</p>

<p>However, this is impossible, as Dominic Mayers showed in 1996 (see <a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> for the original proof). Any such protocol can be reduced to a protocol where the system is in one of two pure states after the commitment phase, depending on the bit Alice wants to commit. If the protocol is unconditionally concealing, then Alice can unitarily transform these states into each other using the properties of the <a href="Schmidt_decomposition" title="wikilink">Schmidt decomposition</a>, effectively defeating the binding property.</p>

<p>One subtle assumption of the proof is that the commit phase must be finished at some point in time. This leaves room for protocols that require a continuing information flow until the bit is unveiled or the protocol is cancelled, in which case it is not binding anymore.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Accumulator_(cryptography)" title="wikilink">Accumulator (cryptography)</a></li>
<li><a href="Key_signing_party" title="wikilink">Key signing party</a></li>
<li><a href="Web_of_trust" title="wikilink">Web of trust</a></li>
<li><a class="uri" href="Zerocoin" title="wikilink">Zerocoin</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li>[<a class="uri" href="http://xstructure.inr.ac.ru/x-bin/theme3.py?level=1&amp;index1">http://xstructure.inr.ac.ru/x-bin/theme3.py?level=1&amp;index1;</a>;=355717 Quantum bit commitment on arxiv.org]</li>
</ul>

<p>"</p>

<p><a href="Category:Public-key_cryptography" title="wikilink">Category:Public-key cryptography</a> <a href="Category:Zero-knowledge_protocols" title="wikilink">Category:Zero-knowledge protocols</a> <a href="Category:Secret_sharing" title="wikilink">Category:Secret sharing</a> <a href="Category:Cryptographic_primitives" title="wikilink">Category:Cryptographic primitives</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="Oded_Goldreich" title="wikilink">Oded Goldreich</a> (2001). Foundations of Cryptography: Volume 1, Basic Tools, (<a href="http://www.wisdom.weizmann.ac.il/~oded/PSBookFrag/part2N.ps">draft available</a> from author's site). Cambridge University Press. ISBN 0-521-79172-3. (see also <a class="uri" href="http://www.wisdom.weizmann.ac.il/~oded/foc-book.html">http://www.wisdom.weizmann.ac.il/~oded/foc-book.html</a>) <a href="#fnref1">↩</a></li>
<li id="fn2">Gilles Brassard, David Chaum, and Claude Crepeau, <em><a href="http://crypto.cs.mcgill.ca/~crepeau/PDF/BCC88-jcss.pdf">Minimum Disclosure Proofs of Knowledge</a></em>, Journal of Computer and System Sciences, vol. 37, pp. 156–189, 1988.<a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4">Claude Crépeau, <em>Commitment</em>, <a href="http://crypto.cs.mcgill.ca/~crepeau/PDF/Commit.pdf">MCgill.ca</a>, accessed April 11, 2008<a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6">Shimon Even. <em>Protocol for signing contracts.</em> In Allen Gersho, ed., <em>Advances in Cryptography</em> (proceedings of CRYPTO '82), pp. 148–153, Santa Barbara, CA, USA, 1982.<a href="#fnref6">↩</a></li>
<li id="fn7">A. Shamir, R. L. Rivest, and L. Adleman, <em><a href="Mental_Poker" title="wikilink">Mental Poker</a>.</em> In D. Klarner, ed., <em>The Mathematical Gardner</em>, pp. 37–43. Wadsworth, Belmont, California, 1981.<a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9">Moni Naor, <em><a href="http://citeseer.ist.psu.edu/naor91bit.html">Bit Commitment Using Pseudorandomness</a></em>, Journal of Cryptology 4: 2 pp. 151–158, 1991.<a href="#fnref9">↩</a></li>
<li id="fn10">Manuel Blum, <em><a href="http://www.cs.cmu.edu/~mblum/research/pdf/coin/in4.html">Coin Flipping by Telephone</a></em>, Proceedings of <a class="uri" href="CRYPTO" title="wikilink">CRYPTO</a> 1981, pp. 11–15, 1981, reprinted in SIGACT News vol. 15, pp. 23–27, 1983.<a href="#fnref10">↩</a></li>
<li id="fn11"><a href="Oded_Goldreich" title="wikilink">Oded Goldreich</a>, <a href="Silvio_Micali" title="wikilink">Silvio Micali</a>, and <a href="Avi_Wigderson" title="wikilink">Avi Wigderson</a>, <em><a href="http://portal.acm.org/citation.cfm?id=116825.116852">Proofs that yield nothing but their validity, or all languages in NP have zero-knowledge proof systems</a>,</em> <a href="Journal_of_the_ACM" title="wikilink">Journal of the ACM</a>, 38: 3, pp. 690–728, 1991<a href="#fnref11">↩</a></li>
<li id="fn12">Oded Goldreich and <a href="Hugo_Krawczyk" title="wikilink">Hugo Krawczyk</a>, <em><a href="http://citeseer.ist.psu.edu/goldreich90composition.html">On the Composition of Zero-Knowledge Proof Systems</a></em>, <a href="SIAM_Journal_on_Computing" title="wikilink">SIAM Journal on Computing</a>, 25: 1, pp. 169–192, 1996<a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14">Pedersen: Non-interactive and information-theoretic secure verifiable secret sharing. Advances in Cryptology CRYPTO '91 Springer<a href="#fnref14">↩</a></li>
<li id="fn15">Brassard, Crépeau, Mayers, Salvail: <a href="http://arxiv.org/abs/quant-ph/9712023">A brief review on the impossibility of quantum bit commitment</a><a href="#fnref15">↩</a></li>
<li id="fn16">A. Kent: <a href="http://arxiv.org/abs/quant-ph/9906103">Secure classical Bit Commitment using Fixed Capacity Communication Channels</a><a href="#fnref16">↩</a></li>
</ol>
</section>
</body>
</html>
