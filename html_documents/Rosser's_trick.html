<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1238">Rosser's trick</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Rosser's trick</h1>
<hr/>
<dl>
<dd><em>For the theorem about the sparseness of prime numbers, see <a href="Rosser's_theorem" title="wikilink">Rosser's theorem</a>. For a general introduction to the incompleteness theorems, see <a href="Gödel's_incompleteness_theorems" title="wikilink">Gödel's incompleteness theorems</a>.</em>
</dd>
</dl>

<p>In <a href="mathematical_logic" title="wikilink">mathematical logic</a>, <strong>Rosser's trick</strong> is a method for proving <a href="Gödel's_incompleteness_theorems" title="wikilink">Gödel's incompleteness theorems</a> without the assumption that the theory being considered is <a href="Omega-consistency" title="wikilink">ω-consistent</a> (Smorynski 1977, p. 840; Mendelson 1977, p. 160). This method was introduced by <a href="J._Barkley_Rosser" title="wikilink">J. Barkley Rosser</a> in 1936, as an improvement of Gödel's original proof of the incompleteness theorems that was published in 1931.</p>

<p>While Gödel's original proof uses a sentence that says (informally) "This sentence is not provable", Rosser's trick uses a formula that says "If this sentence is provable, there is a shorter proof of its negation".</p>
<h2 id="background">Background</h2>

<p>Rosser's trick begins with the assumptions of Gödel's incompleteness theorem. A theory <em>T</em> is selected which is effective, consistent, and includes a sufficient fragment of elementary arithmetic.</p>

<p>Gödel's proof shows that for any such theory there is a formula Proof<sub>T</sub>(<em>x</em>,<em>y</em>) which has the intended meaning that <em>y</em> is a natural number code (a Gödel number) for a formula and <em>x</em> is the Gödel number for a proof, from the axioms of <em>T</em>, of the formula encoded by <em>y</em>. (In the remainder of this article, no distinction is made between the number <em>y</em> and the formula encoded by <em>y</em>, and the number coding a formula φ is denoted #φ). Furthermore, the formula Pvbl<sub>T</sub>(<em>y</em>) is defined as ∃<em>x</em> Proof<sub>T</sub>(<em>x</em>,<em>y</em>). It is intended to define the set of formulas provable from <em>T</em>.</p>

<p>The assumptions on <em>T</em> also show that it is able to define a negation function neg(<em>y</em>), with the property that if <em>y</em> is a code for a formula φ then neg(<em>y</em>) is a code for the formula ¬φ. The negation function may take any value whatsoever for inputs that are not codes of formulas.</p>

<p>The Gödel sentence of the theory <em>T</em> is a formula φ, sometimes denoted G<sub>T</sub> such that <em>T</em> proves φ ↔ ¬Pvbl<sub>T</sub>(#φ). Gödel's proof shows that if <em>T</em> is consistent then it cannot prove its Gödel sentence; but in order to show that the negation of the Gödel sentence is also not provable, it is necessary to add a stronger assumption that the theory is <a href="omega-consistency" title="wikilink">ω-consistent</a>, not merely consistent. For example, the theory T=PA+¬G<sub>PA</sub> proves ¬G<sub>T</sub>. Rosser (1936) constructed a different self-referential sentence that can be used to replace the Gödel sentence in Gödel's proof, removing the need to assume ω-consistency.</p>
<h2 id="the-rosser-sentence">The Rosser sentence</h2>

<p>For a fixed arithmetical theory <em>T</em>, let Proof<sub><em>T</em></sub>(<em>x</em>,<em>y</em>) and neg(<em>x</em>) be the associated proof predicate and negation function.</p>

<p>A modified proof predicate Proof<sup><em>R</em></sup><sub><em>T</em></sub>(<em>x</em>,<em>y</em>) is defined as:</p>

<p>

<math display="block" id="Rosser's_trick:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mi>Proof</mi>
      <mi>T</mi>
      <mi>R</mi>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>Proof</mi>
       <mi>T</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∧</mo>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mrow>
       <mo>∃</mo>
       <mi>z</mi>
      </mrow>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <msub>
        <mi>Proof</mi>
        <mi>T</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo>,</mo>
        <mrow>
         <mi>neg</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Proof</ci>
        <ci>R</ci>
       </apply>
       <ci>T</ci>
      </apply>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <apply>
      <and></and>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Proof</ci>
        <ci>T</ci>
       </apply>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <not></not>
       <apply>
        <exists></exists>
        <ci>z</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Proof</ci>
         <ci>T</ci>
        </apply>
        <interval closure="open">
         <ci>z</ci>
         <apply>
          <times></times>
          <ci>neg</ci>
          <ci>y</ci>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Proof}^{R}_{T}(x,y)\equiv\mathrm{Proof}_{T}(x,y)\land\lnot\exists z%
\leq x[\mathrm{Proof}_{T}(z,\mathrm{neg}(y))],
  </annotation>
 </semantics>
</math>

 which means that</p>

<p>

<math display="block" id="Rosser's_trick:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <msubsup>
      <mi>Proof</mi>
      <mi>T</mi>
      <mi>R</mi>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <msub>
      <mi>Proof</mi>
      <mi>T</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo>∃</mo>
     <mi>z</mi>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <msub>
        <mi>Proof</mi>
        <mi>T</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo>,</mo>
        <mrow>
         <mi>neg</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <times></times>
      <not></not>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Proof</ci>
        <ci>R</ci>
       </apply>
       <ci>T</ci>
      </apply>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Proof</ci>
       <ci>T</ci>
      </apply>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <exists></exists>
      <ci>z</ci>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>Proof</ci>
         <ci>T</ci>
        </apply>
        <interval closure="open">
         <ci>z</ci>
         <apply>
          <times></times>
          <ci>neg</ci>
          <ci>y</ci>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lnot\mathrm{Proof}^{R}_{T}(x,y)\equiv\mathrm{Proof}_{T}(x,y)\to\exists z\leq x%
[\mathrm{Proof}_{T}(z,\mathrm{neg}(y))].
  </annotation>
 </semantics>
</math>

</p>

<p>This modified proof predicate is used to define a modified provability predicate Pvbl<sup>R</sup><sub>T</sub>(<em>y</em>):</p>

<p>

<math display="block" id="Rosser's_trick:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mi>Pvbl</mi>
      <mi>T</mi>
      <mi>R</mi>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <mi>x</mi>
      <msubsup>
       <mi>Proof</mi>
       <mi>T</mi>
       <mi>R</mi>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Pvbl</ci>
       <ci>R</ci>
      </apply>
      <ci>T</ci>
     </apply>
     <ci>y</ci>
    </apply>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Proof</ci>
        <ci>R</ci>
       </apply>
       <ci>T</ci>
      </apply>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Pvbl}^{R}_{T}(y)\equiv\exists x\mathrm{Proof}^{R}_{T}(x,y).
  </annotation>
 </semantics>
</math>

 Informally, Pvbl<sup>R</sup><sub>T</sub>(<em>y</em>) is the claim that <em>y</em> is provable via some coded proof <em>x</em> such that there is no smaller coded proof of the negation of <em>y</em>. Under the assumption that <em>T</em> is consistent, for each formula φ the formula Pvbl<sup>R</sup><sub>T</sub>(#φ) will hold if and only if Pvbl<sub>T</sub>(#φ) holds. However, these predicates have different properties from the point of view of provability in <em>T</em>.</p>

<p>Using the <a href="diagonal_lemma" title="wikilink">diagonal lemma</a>, let ρ be a formula such that <em>T</em> proves ρ ↔ ¬ Pvbl<sup>R</sup><sub>T</sub>(#ρ). The formula ρ is the <strong>Rosser sentence</strong> of the theory <em>T</em>.</p>
<h2 id="rossers-theorem">Rosser's theorem</h2>

<p>Let <em>T</em> be an effective, consistent theory including a sufficient amount of arithmetic, with Rosser sentence ρ. Then the following hold (Mendelson 1977, p. 160):</p>
<ol>
<li><em>T</em> does not prove ρ</li>
<li><em>T</em> does not prove ¬ρ.</li>
</ol>

<p>The proof of (1) is as in Gödel's proof of the first incompleteness theorem. The proof of (2) is more involved. Assume that <em>T</em> proves ¬ρ and let <em>e</em> be a natural number coding for a proof of ¬ρ in <em>T</em>. Because <em>T</em> is consistent, there is no code for a proof of ρ in <em>T</em>, so Proof<sup>R</sup><sub>T</sub>(<em>e</em>,neg(#ρ)) will hold (because there is no <em>z</em> \forall x ( e \leq x \to \exists z \leq x [ \mathrm{Proof}_T (z,\mathrm{neg}(\#\rho))], and (using the assumption of consistency and the fact that <em>e</em> is a natural number)</p>

<p>

<math display="block" id="Rosser's_trick:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mrow>
      <mo>∃</mo>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo><</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>e</mi>
     </mpadded>
     <msub>
      <mi>Proof</mi>
      <mi>T</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mrow>
       <mi mathvariant="normal">#</mi>
       <mi>ρ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <not></not>
     <apply>
      <exists></exists>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>e</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Proof</ci>
      <ci>T</ci>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <apply>
       <times></times>
       <ci>normal-#</ci>
       <ci>ρ</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lnot\exists x<e\,\mathrm{Proof}_{T}(x,\#\rho).
  </annotation>
 </semantics>
</math>

 From the latter formula, the assumptions on <em>T</em> show that it proves</p>

<p>

<math display="block" id="Rosser's_trick:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>Proof</mi>
      <mi>T</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mrow>
       <mi mathvariant="normal">#</mi>
       <mi>ρ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mi>e</mi>
    <mo>≤</mo>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Proof</ci>
       <ci>T</ci>
      </apply>
      <interval closure="open">
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>normal-#</ci>
        <ci>ρ</ci>
       </apply>
      </interval>
     </apply>
     <ci>e</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Proof}_{T}(x,\#\rho)\to e\leq x.
  </annotation>
 </semantics>
</math>

</p>

<p>Thus <em>T</em> proves</p>

<p>

<math display="block" id="Rosser's_trick:5">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>Proof</mi>
     <mi>T</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi mathvariant="normal">#</mi>
     <mi>ρ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mo>∃</mo>
    <mi>z</mi>
    <mo>≤</mo>
    <mi>x</mi>
    <msub>
     <mi>Proof</mi>
     <mi>T</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo>,</mo>
     <mi>neg</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi mathvariant="normal">#</mi>
      <mi>ρ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Proof</ci>
      <ci>T</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">#</csymbol>
      <csymbol cd="unknown">ρ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <exists></exists>
     <csymbol cd="unknown">z</csymbol>
     <leq></leq>
     <csymbol cd="unknown">x</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Proof</ci>
      <ci>T</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">z</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">neg</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">#</csymbol>
       <csymbol cd="unknown">ρ</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x[\mathrm{Proof}_{T}(x,\#\rho)\to\exists z\leq x\mathrm{Proof}_{T}(z,%
\mathrm{neg}(\#\rho))].
  </annotation>
 </semantics>
</math>

 But this last formula is provably equivalent to ρ in <em>T</em>, by definition of ρ, which means that <em>T</em> proves ρ. This is a contradiction, as <em>T</em> was assumed to prove ¬ρ and assumed to be consistent. Thus <em>T</em> cannot prove ¬ρ under the assumption <em>T</em> is consistent.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Scott's_trick" title="wikilink">Scott's trick</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Mendelson (1977), <em>Introduction to Mathematical Logic</em></li>
<li>Smorynski (1977), "The incompleteness theorems", in <em>Handbook of Mathematical Logic</em>, Jon Barwise, Ed., North Holland, 1982, ISBN 0-444-86388-5</li>
<li>Rosser (1936), "Extensions of some theorems of Gödel and Church", <em>Journal of Symbolic Logic</em>, v. 1, pp. 87–91.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>Avigad (2007), "<a href="http://www.andrew.cmu.edu/user/avigad/Teaching/candi_notes.pdf">Computability and Incompleteness</a>", lecture notes.</li>
</ul>

<p>"</p>

<p><a href="Category:Mathematical_logic" title="wikilink">Category:Mathematical logic</a></p>
</body>
</html>
