<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="59">Principal component analysis</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Principal component analysis</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>PCA of a <a href="multivariate_Gaussian_distribution" title="wikilink">multivariate Gaussian distribution</a> centered at (1,3) with a standard deviation of 3 in roughly the (0.878, 0.478) direction and of 1 in the orthogonal direction. The vectors shown are the eigenvectors of the <a href="covariance_matrix" title="wikilink">covariance matrix</a> scaled by the square root of the corresponding eigenvalue, and shifted so their tails are at the mean.</figcaption>
</figure>

<p><strong>Principal component analysis</strong> (<strong>PCA</strong>) is a statistical procedure that uses an <a href="orthogonal_transformation" title="wikilink">orthogonal transformation</a> to convert a set of observations of possibly correlated variables into a set of values of <a href="Correlation_and_dependence" title="wikilink">linearly uncorrelated</a> variables called <strong>principal components</strong>. The number of principal components is less than or equal to the number of original variables. This transformation is defined in such a way that the first principal component has the largest possible <a class="uri" href="variance" title="wikilink">variance</a> (that is, accounts for as much of the variability in the data as possible), and each succeeding component in turn has the highest variance possible under the constraint that it is <a class="uri" href="orthogonal" title="wikilink">orthogonal</a> to the preceding components. The resulting vectors are an uncorrelated orthogonal basis set. The principal components are orthogonal because they are the <a href="eigenvector" title="wikilink">eigenvectors</a> of the <a href="covariance_matrix" title="wikilink">covariance matrix</a>, which is <a href="Symmetric_matrix#Real_symmetric_matrices" title="wikilink">symmetric</a>. PCA is sensitive to the relative scaling of the original variables.</p>

<p>Depending on the field of application, it is also named the discrete <a href="Karhunenâ€“LoÃ¨ve_theorem" title="wikilink">Karhunenâ€“LoÃ¨ve</a> transform (KLT) in signal processing, the <a href="Harold_Hotelling" title="wikilink">Hotelling</a> transform in multivariate quality control, proper orthogonal decomposition (POD) in mechanical engineering, <a href="singular_value_decomposition" title="wikilink">singular value decomposition</a> (SVD) of <strong>X</strong> (Golub and Van Loan, 1983), <a href="Eigendecomposition" title="wikilink">eigenvalue decomposition</a> (EVD) of <strong>X</strong><sup>T</sup><strong>X</strong> in linear algebra, <a href="factor_analysis" title="wikilink">factor analysis</a> (for a discussion of the differences between PCA and factor analysis see Ch. 7 of<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a>), <a href="Eckartâ€“Young_theorem" title="wikilink">Eckartâ€“Young theorem</a> (Harman, 1960), or <a href="Schmidtâ€“Mirsky_theorem" title="wikilink">Schmidtâ€“Mirsky theorem</a> in psychometrics, <a href="empirical_orthogonal_functions" title="wikilink">empirical orthogonal functions</a> (EOF) in meteorological science, <a href="empirical_eigenfunction_decomposition" title="wikilink">empirical eigenfunction decomposition</a> (Sirovich, 1987), <a href="empirical_component_analysis" title="wikilink">empirical component analysis</a> (Lorenz, 1956), <a href="quasiharmonic_modes" title="wikilink">quasiharmonic modes</a> (Brooks et al., 1988), <a href="Spectral_theorem" title="wikilink">spectral decomposition</a> in noise and vibration, and <a href="Mode_shape" title="wikilink">empirical modal analysis</a> in structural dynamics.</p>

<p>PCA was invented in 1901 by <a href="Karl_Pearson" title="wikilink">Karl Pearson</a>,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> as an analogue of the <a href="principal_axis_theorem" title="wikilink">principal axis theorem</a> in mechanics; it was later independently developed (and named) by <a href="Harold_Hotelling" title="wikilink">Harold Hotelling</a> in the 1930s.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The method is mostly used as a tool in <a href="exploratory_data_analysis" title="wikilink">exploratory data analysis</a> and for making <a href="predictive_modeling" title="wikilink">predictive models</a>. PCA can be done by <a href="Eigendecomposition_of_a_matrix" title="wikilink">eigenvalue decomposition</a> of a data <a class="uri" href="covariance" title="wikilink">covariance</a> (or <a class="uri" href="correlation" title="wikilink">correlation</a>) matrix or <a href="singular_value_decomposition" title="wikilink">singular value decomposition</a> of a <a href="Data_matrix_(multivariate_statistics)" title="wikilink">data matrix</a>, usually after mean centering (and normalizing or using <a href="Z-score" title="wikilink">Z-scores</a>) the data matrix for each attribute.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The results of a PCA are usually discussed in terms of component scores, sometimes called factor scores (the transformed variable values corresponding to a particular data point), and loadings (the weight by which each standardized original variable should be multiplied to get the component score).<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>PCA is the simplest of the true <a href="Eigenvectors" title="wikilink">eigenvector</a>-based multivariate analyses. Often, its operation can be thought of as revealing the internal structure of the data in a way that best explains the variance in the data. If a multivariate dataset is visualised as a set of coordinates in a high-<a href="Dimension_(metadata)" title="wikilink">dimensional</a> data space (1 axis per variable), PCA can supply the user with a lower-dimensional picture, a projection or "shadow" of this object when viewed from its (in some sense; see <a href="#PCA_and_information_theory" title="wikilink">below</a>) most informative viewpoint. This is done by using only the first few principal components so that the dimensionality of the transformed data is reduced.</p>

<p>PCA is closely related to <a href="factor_analysis" title="wikilink">factor analysis</a>. Factor analysis typically incorporates more domain specific assumptions about the underlying structure and solves eigenvectors of a slightly different matrix.</p>

<p>PCA is also related to <a href="Canonical_correlation" title="wikilink">canonical correlation analysis (CCA)</a>. CCA defines coordinate systems that optimally describe the cross-covariance between two datasets while PCA defines a new orthogonal coordinate system that optimally describes variance in a single dataset.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="intuition">Intuition</h2>

<p>PCA can be thought of as fitting an <em>n</em>-dimensional <a class="uri" href="ellipsoid" title="wikilink">ellipsoid</a> to the data, where each axis of the ellipsoid represents a principal component. If some axis of the ellipse is small, then the variance along that axis is also small, and by omitting that axis and its corresponding principal component from our representation of the dataset, we lose only a commensurately small amount of information.</p>

<p>To find the axes of the ellipse, we must first subtract the mean of each variable from the dataset to center the data around the origin. Then, we compute the <a href="covariance_matrix" title="wikilink">covariance matrix</a> of the data, and calculate the eigenvalues and corresponding eigenvectors of this covariance matrix. Then, we must orthogonalize the set of eigenvectors, and normalize each to become unit vectors. Once this is done, each of the mutually orthogonal, unit eigenvectors can be interpreted as an axis of the ellipsoid fitted to the data. The proportion of the variance that each eigenvector represents can be calculated by dividing the eigenvalue corresponding to that eigenvector by the sum of all eigenvalues.</p>

<p>It is important to note that this procedure is sensitive to the scaling of the data, and that there is no consensus as to how to best scale the data to obtain optimal results.</p>
<h2 id="details">Details</h2>

<p>PCA is mathematically defined<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> as an <a href="orthogonal_transformation" title="wikilink">orthogonal</a> <a href="linear_transformation" title="wikilink">linear transformation</a> that transforms the data to a new <a href="coordinate_system" title="wikilink">coordinate system</a> such that the greatest variance by some projection of the data comes to lie on the first coordinate (called the first principal component), the second greatest variance on the second coordinate, and so on.</p>

<p>Consider a data <a href="Matrix_(mathematics)" title="wikilink">matrix</a>, <strong>X</strong>, with column-wise zero <a href="empirical_mean" title="wikilink">empirical mean</a> (the sample mean of each column has been shifted to zero), where each of the <em>n</em> rows represents a different repetition of the experiment, and each of the <em>p</em> columns gives a particular kind of datum (say, the results from a particular sensor).</p>

<p>Mathematically, the transformation is defined by a set of <em>p</em>-dimensional vectors of weights or <em>loadings</em> 

<math display="inline" id="Principal_component_analysis:0">
 <semantics>
  <mrow>
   <msub>
    <mi>ğ°</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>w</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">â€¦</mi>
     <mo>,</mo>
     <msub>
      <mi>w</mi>
      <mi>p</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ°</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-â€¦</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>p</ci>
      </apply>
     </vector>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{w}_{(k)}=(w_{1},\dots,w_{p})_{(k)}
  </annotation>
 </semantics>
</math>

 that map each row vector 

<math display="inline" id="Principal_component_analysis:1">
 <semantics>
  <msub>
   <mi>ğ±</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ğ±</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{(i)}
  </annotation>
 </semantics>
</math>

 of <strong>X</strong> to a new vector of principal component <em>scores</em> 

<math display="inline" id="Principal_component_analysis:2">
 <semantics>
  <mrow>
   <msub>
    <mi>ğ­</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>t</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">â€¦</mi>
     <mo>,</mo>
     <msub>
      <mi>t</mi>
      <mi>p</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ­</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-â€¦</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>p</ci>
      </apply>
     </vector>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{t}_{(i)}=(t_{1},\dots,t_{p})_{(i)}
  </annotation>
 </semantics>
</math>

, given by</p>

<p>

<math display="block" id="Principal_component_analysis:3">
 <semantics>
  <mrow>
   <mmultiscripts>
    <mi>t</mi>
    <mi>k</mi>
    <none></none>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <none></none>
   </mmultiscripts>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>ğ±</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>i</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
    <mo>â‹…</mo>
    <msub>
     <mi>ğ°</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>k</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <apply>
     <ci>normal-â‹…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ğ±</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ğ°</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {t_{k}}_{(i)}=\mathbf{x}_{(i)}\cdot\mathbf{w}_{(k)}
  </annotation>
 </semantics>
</math>

 in such a way that the individual variables of <strong>t</strong> considered over the data set successively inherit the maximum possible variance from <strong>x</strong>, with each loading vector <strong>w</strong> constrained to be a <a href="unit_vector" title="wikilink">unit vector</a>.</p>
<h3 id="first-component">First component</h3>

<p>The first loading vector <strong>w</strong><sub>(1)</sub> thus has to satisfy</p>

<p>

<math display="block" id="Principal_component_analysis:4">
 <semantics>
  <mrow>
   <msub>
    <mi>ğ°</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <munder accentunder="true">
      <mrow>
       <mpadded width="+1.7pt">
        <mi>arg</mi>
       </mpadded>
       <mi>max</mi>
      </mrow>
      <mrow>
       <mrow>
        <mo>âˆ¥</mo>
        <mi>ğ°</mi>
        <mo>âˆ¥</mo>
       </mrow>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
     </munder>
    </mpadded>
    <mrow>
     <mo>{</mo>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">âˆ‘</mo>
       <mi>i</mi>
      </munder>
      <msubsup>
       <mrow>
        <mo>(</mo>
        <msub>
         <mi>t</mi>
         <mn>1</mn>
        </msub>
        <mo>)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>i</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msubsup>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <munder accentunder="true">
      <mrow>
       <mpadded width="+1.7pt">
        <mi>arg</mi>
       </mpadded>
       <mi>max</mi>
      </mrow>
      <mrow>
       <mrow>
        <mo>âˆ¥</mo>
        <mi>ğ°</mi>
        <mo>âˆ¥</mo>
       </mrow>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
     </munder>
    </mpadded>
    <mrow>
     <mo>{</mo>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">âˆ‘</mo>
       <mi>i</mi>
      </munder>
      <msup>
       <mrow>
        <mo>(</mo>
        <mrow>
         <msub>
          <mi>ğ±</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>i</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </msub>
         <mo>â‹…</mo>
         <mi>ğ°</mi>
        </mrow>
        <mo>)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ğ°</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <apply>
        <eq></eq>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <ci>ğ°</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <arg></arg>
        <ci>max</ci>
       </apply>
      </apply>
      <set>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>t</ci>
           <cn type="integer">1</cn>
          </apply>
          <cn type="integer">2</cn>
         </apply>
         <ci>i</ci>
        </apply>
       </apply>
      </set>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <apply>
        <eq></eq>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <ci>ğ°</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <arg></arg>
        <ci>max</ci>
       </apply>
      </apply>
      <set>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <ci>normal-â‹…</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>ğ±</ci>
           <ci>i</ci>
          </apply>
          <ci>ğ°</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{w}_{(1)}=\underset{\|\mathbf{w}\|=1}{\operatorname{\arg\,max}}\,\left%
\{\sum_{i}\left(t_{1}\right)^{2}_{(i)}\right\}=\underset{\|\mathbf{w}\|=1}{%
\operatorname{\arg\,max}}\,\left\{\sum_{i}\left(\mathbf{x}_{(i)}\cdot\mathbf{w%
}\right)^{2}\right\}
  </annotation>
 </semantics>
</math>

</p>

<p>Equivalently, writing this in matrix form gives</p>

<p>

<math display="block" id="Principal_component_analysis:5">
 <semantics>
  <mrow>
   <msub>
    <mi>ğ°</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <munder accentunder="true">
      <mrow>
       <mpadded width="+1.7pt">
        <mi>arg</mi>
       </mpadded>
       <mi>max</mi>
      </mrow>
      <mrow>
       <mrow>
        <mo>âˆ¥</mo>
        <mi>ğ°</mi>
        <mo>âˆ¥</mo>
       </mrow>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
     </munder>
    </mpadded>
    <mrow>
     <mo stretchy="false">{</mo>
     <msup>
      <mrow>
       <mo>âˆ¥</mo>
       <mi>ğ—ğ°</mi>
       <mo>âˆ¥</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <munder accentunder="true">
      <mrow>
       <mpadded width="+1.7pt">
        <mi>arg</mi>
       </mpadded>
       <mi>max</mi>
      </mrow>
      <mrow>
       <mrow>
        <mo>âˆ¥</mo>
        <mi>ğ°</mi>
        <mo>âˆ¥</mo>
       </mrow>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
     </munder>
    </mpadded>
    <mrow>
     <mo>{</mo>
     <mrow>
      <msup>
       <mi>ğ°</mi>
       <mi>T</mi>
      </msup>
      <msup>
       <mi>ğ—</mi>
       <mi>T</mi>
      </msup>
      <mi>ğ—ğ°</mi>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ğ°</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <apply>
        <eq></eq>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <ci>ğ°</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <arg></arg>
        <ci>max</ci>
       </apply>
      </apply>
      <set>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <ci>ğ—ğ°</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </set>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <apply>
        <eq></eq>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <ci>ğ°</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <arg></arg>
        <ci>max</ci>
       </apply>
      </apply>
      <set>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ğ°</ci>
         <ci>T</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ğ—</ci>
         <ci>T</ci>
        </apply>
        <ci>ğ—ğ°</ci>
       </apply>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{w}_{(1)}=\underset{\|\mathbf{w}\|=1}{\operatorname{\arg\,max}}\,\{\|%
\mathbf{Xw}\|^{2}\}=\underset{\|\mathbf{w}\|=1}{\operatorname{\arg\,max}}\,%
\left\{\mathbf{w}^{T}\mathbf{X}^{T}\mathbf{Xw}\right\}
  </annotation>
 </semantics>
</math>

</p>

<p>Since <strong>w</strong><sub>(1)</sub> has been defined to be a unit vector, it equivalently also satisfies</p>

<p>

<math display="block" id="Principal_component_analysis:6">
 <semantics>
  <mrow>
   <msub>
    <mi>ğ°</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mrow>
      <mpadded width="+1.7pt">
       <mi>arg</mi>
      </mpadded>
      <mi>max</mi>
     </mrow>
    </mpadded>
    <mrow>
     <mo>{</mo>
     <mfrac>
      <mrow>
       <msup>
        <mi>ğ°</mi>
        <mi>T</mi>
       </msup>
       <msup>
        <mi>ğ—</mi>
        <mi>T</mi>
       </msup>
       <mi>ğ—ğ°</mi>
      </mrow>
      <mrow>
       <msup>
        <mi>ğ°</mi>
        <mi>T</mi>
       </msup>
       <mi>ğ°</mi>
      </mrow>
     </mfrac>
     <mo>}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ°</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <apply>
      <arg></arg>
      <ci>max</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ğ°</ci>
        <ci>T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ğ—</ci>
        <ci>T</ci>
       </apply>
       <ci>ğ—ğ°</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ğ°</ci>
        <ci>T</ci>
       </apply>
       <ci>ğ°</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{w}_{(1)}={\operatorname{\arg\,max}}\,\left\{\frac{\mathbf{w}^{T}%
\mathbf{X}^{T}\mathbf{Xw}}{\mathbf{w}^{T}\mathbf{w}}\right\}
  </annotation>
 </semantics>
</math>

</p>

<p>The quantity to be maximised can be recognised as a <a href="Rayleigh_quotient" title="wikilink">Rayleigh quotient</a>. A standard result for a symmetric matrix such as <strong>X</strong><sup>T</sup><strong>X</strong> is that the quotient's maximum possible value is the largest <a class="uri" href="eigenvalue" title="wikilink">eigenvalue</a> of the matrix, which occurs when <strong><em>w</em></strong> is the corresponding <a class="uri" href="eigenvector" title="wikilink">eigenvector</a>.</p>

<p>With <strong>w</strong><sub>(1)</sub> found, the first component of a data vector <strong>x</strong><sub>(<em>i</em>)</sub> can then be given as a score <em>t</em><sub>1(<em>i</em>)</sub> = <strong>x</strong><sub>(<em>i</em>)</sub> â‹… <strong>w</strong><sub>(1)</sub> in the transformed co-ordinates, or as the corresponding vector in the original variables, {<strong>x</strong><sub>(<em>i</em>)</sub> â‹… <strong>w</strong><sub>(1)</sub>} <strong>w</strong><sub>(1)</sub>.</p>
<h3 id="further-components">Further components</h3>

<p>The <em>k</em>th component can be found by subtracting the first <em>k</em>Â âˆ’Â 1 principal components from <strong>X</strong>:</p>

<p>

<math display="block" id="Principal_component_analysis:7">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>ğ—</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>ğ—</mi>
    <mo>-</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">âˆ‘</mo>
      <mrow>
       <mi>s</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mrow>
       <mi>k</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </munderover>
     <mrow>
      <msub>
       <mi>ğ—ğ°</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msub>
      <msubsup>
       <mi>ğ°</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi mathvariant="normal">T</mi>
      </msubsup>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>ğ—</ci>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>ğ—</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>s</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ğ—ğ°</ci>
        <ci>s</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ğ°</ci>
         <ci>s</ci>
        </apply>
        <ci>normal-T</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\hat{X}}_{k}=\mathbf{X}-\sum_{s=1}^{k-1}\mathbf{X}\mathbf{w}_{(s)}%
\mathbf{w}_{(s)}^{\rm T}
  </annotation>
 </semantics>
</math>

</p>

<p>and then finding the loading vector which extracts the maximum variance from this new data matrix</p>

<p>

<math display="block" id="Principal_component_analysis:8">
 <semantics>
  <mrow>
   <msub>
    <mi>ğ°</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <munder accentunder="true">
     <mrow>
      <mpadded width="+1.7pt">
       <mi>arg</mi>
      </mpadded>
      <mi>max</mi>
     </mrow>
     <mrow>
      <mrow>
       <mo>âˆ¥</mo>
       <mi>ğ°</mi>
       <mo>âˆ¥</mo>
      </mrow>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
    </munder>
    <mrow>
     <mo>{</mo>
     <msup>
      <mrow>
       <mo>âˆ¥</mo>
       <mrow>
        <msub>
         <mover accent="true">
          <mi>ğ—</mi>
          <mo stretchy="false">^</mo>
         </mover>
         <mi>k</mi>
        </msub>
        <mi>ğ°</mi>
       </mrow>
       <mo>âˆ¥</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo>}</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mrow>
      <mpadded width="+1.7pt">
       <mi>arg</mi>
      </mpadded>
      <mi>max</mi>
     </mrow>
    </mpadded>
    <mrow>
     <mo>{</mo>
     <mstyle displaystyle="false">
      <mfrac>
       <mrow>
        <msup>
         <mi>ğ°</mi>
         <mi>T</mi>
        </msup>
        <msubsup>
         <mover accent="true">
          <mi>ğ—</mi>
          <mo stretchy="false">^</mo>
         </mover>
         <mi>k</mi>
         <mi>T</mi>
        </msubsup>
        <msub>
         <mover accent="true">
          <mi>ğ—</mi>
          <mo stretchy="false">^</mo>
         </mover>
         <mi>k</mi>
        </msub>
        <mi>ğ°</mi>
       </mrow>
       <mrow>
        <msup>
         <mi>ğ°</mi>
         <mi>T</mi>
        </msup>
        <mi>ğ°</mi>
       </mrow>
      </mfrac>
     </mstyle>
     <mo>}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ğ°</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <apply>
        <eq></eq>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <ci>ğ°</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <times></times>
        <ci>arg</ci>
        <ci>max</ci>
       </apply>
      </apply>
      <set>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <apply>
            <ci>normal-^</ci>
            <ci>ğ—</ci>
           </apply>
           <ci>k</ci>
          </apply>
          <ci>ğ°</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </set>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <arg></arg>
       <ci>max</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ğ°</ci>
         <ci>T</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <ci>normal-^</ci>
           <ci>ğ—</ci>
          </apply>
          <ci>k</ci>
         </apply>
         <ci>T</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-^</ci>
          <ci>ğ—</ci>
         </apply>
         <ci>k</ci>
        </apply>
        <ci>ğ°</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ğ°</ci>
         <ci>T</ci>
        </apply>
        <ci>ğ°</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{w}_{(k)}=\underset{\|\mathbf{w}\|=1}{\operatorname{arg\,max}}\left\{\|%
\mathbf{\hat{X}}_{k}\mathbf{w}\|^{2}\right\}={\operatorname{\arg\,max}}\,\left%
\{\tfrac{\mathbf{w}^{T}\mathbf{\hat{X}}_{k}^{T}\mathbf{\hat{X}}_{k}\mathbf{w}}%
{\mathbf{w}^{T}\mathbf{w}}\right\}
  </annotation>
 </semantics>
</math>

</p>

<p>It turns out that this gives the remaining eigenvectors of <strong>X</strong><sup>T</sup><strong>X</strong>, with the maximum values for the quantity in brackets given by their corresponding eigenvalues.</p>

<p>The <em>k</em>th principal component of a data vector <strong>x</strong><sub>(<em>i</em>)</sub> can therefore be given as a score <em>t</em><sub><em>k</em>(<em>i</em>)</sub> = <strong>x</strong><sub>(<em>i</em>)</sub> â‹… <strong>w</strong><sub>(<em>k</em>)</sub> in the transformed co-ordinates, or as the corresponding vector in the space of the original variables, {<strong>x</strong><sub>(<em>i</em>)</sub> â‹… <strong>w</strong><sub>(<em>k</em>)</sub>} <strong>w</strong><sub>(<em>k</em>)</sub>, where <strong>w</strong><sub>(<em>k</em>)</sub> is the <em>k</em>th eigenvector of <strong>X</strong><sup>T</sup><strong>X</strong>.</p>

<p>The full principal components decomposition of <strong>X</strong> can therefore be given as</p>

<p>

<math display="block" id="Principal_component_analysis:9">
 <semantics>
  <mrow>
   <mi>ğ“</mi>
   <mo>=</mo>
   <mi>ğ—ğ–</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ“</ci>
    <ci>ğ—ğ–</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{T}=\mathbf{X}\mathbf{W}
  </annotation>
 </semantics>
</math>

 where <strong>W</strong> is a <em>p</em>-by-<em>p</em> matrix whose columns are the eigenvectors of <strong>X</strong><sup>T</sup><strong>X</strong></p>
<h3 id="covariances">Covariances</h3>

<p><strong>X</strong><sup>T</sup><strong>X</strong> itself can be recognised as proportional to the empirical sample <a href="covariance_matrix" title="wikilink">covariance matrix</a> of the dataset <strong>X</strong>.</p>

<p>The sample covariance <em>Q</em> between two of the different principal components over the dataset is given by:</p>

<p>

<math display="inline" id="Principal_component_analysis:10">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>PC</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>j</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>PC</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Q</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>PC</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>PC</ci>
      <ci>k</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle Q(\mathrm{PC}_{(j)},\mathrm{PC}_{(k)})
  </annotation>
 </semantics>
</math>


</p>

<p>where the eigenvalue property of <strong>w</strong><sub>(<em>k</em>)</sub> has been used to move from line 2 to line 3. However eigenvectors <strong>w</strong><sub>(<em>j</em>)</sub> and <strong>w</strong><sub>(<em>k</em>)</sub> corresponding to eigenvalues of a symmetric matrix are orthogonal (if the eigenvalues are different), or can be orthogonalised (if the vectors happen to share an equal repeated value). The product in the final line is therefore zero; there is no sample covariance between different principal components over the dataset.</p>

<p>Another way to characterise the principal components transformation is therefore as the transformation to coordinates which diagonalise the empirical sample covariance matrix.</p>

<p>In matrix form, the empirical covariance matrix for the original variables can be written</p>

<p>

<math display="block" id="Principal_component_analysis:11">
 <semantics>
  <mrow>
   <mi>ğ</mi>
   <mo>âˆ</mo>
   <mrow>
    <msup>
     <mi>ğ—</mi>
     <mi>T</mi>
    </msup>
    <mi>ğ—</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>ğ–</mi>
    <mi>ğš²</mi>
    <msup>
     <mi>ğ–</mi>
     <mi>T</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">proportional-to</csymbol>
     <ci>ğ</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ğ—</ci>
       <ci>T</ci>
      </apply>
      <ci>ğ—</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>ğ–</ci>
      <ci>ğš²</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ğ–</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Q}\propto\mathbf{X}^{T}\mathbf{X}=\mathbf{W}\mathbf{\Lambda}\mathbf{W}%
^{T}
  </annotation>
 </semantics>
</math>

</p>

<p>The empirical covariance matrix between the principal components becomes</p>

<p>

<math display="block" id="Principal_component_analysis:12">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>ğ–</mi>
     <mi>T</mi>
    </msup>
    <mi>ğğ–</mi>
   </mrow>
   <mo>âˆ</mo>
   <mrow>
    <msup>
     <mi>ğ–</mi>
     <mi>T</mi>
    </msup>
    <mpadded width="+1.7pt">
     <mi>ğ–</mi>
    </mpadded>
    <mpadded width="+1.7pt">
     <mi>ğš²</mi>
    </mpadded>
    <msup>
     <mi>ğ–</mi>
     <mi>T</mi>
    </msup>
    <mi>ğ–</mi>
   </mrow>
   <mo>=</mo>
   <mi>ğš²</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">proportional-to</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ğ–</ci>
       <ci>T</ci>
      </apply>
      <ci>ğğ–</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ğ–</ci>
       <ci>T</ci>
      </apply>
      <ci>ğ–</ci>
      <ci>ğš²</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ğ–</ci>
       <ci>T</ci>
      </apply>
      <ci>ğ–</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>ğš²</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{W}^{T}\mathbf{Q}\mathbf{W}\propto\mathbf{W}^{T}\mathbf{W}\,\mathbf{%
\Lambda}\,\mathbf{W}^{T}\mathbf{W}=\mathbf{\Lambda}
  </annotation>
 </semantics>
</math>

</p>

<p>where <strong>Î›</strong> is the diagonal matrix of eigenvalues <em>Î»</em><sub>(<em>k</em>)</sub> of <strong>X</strong><sup>T</sup><strong>X</strong></p>

<p>(Î»<sub>(k)</sub> being equal to the sum of the squares over the dataset associated with each component <em>k</em>: <em>Î»</em><sub>(<em>k</em>)</sub> = Î£<sub><em>i</em></sub> <em>t</em><sub><em>k</em></sub><sup>2</sup><sub>(<em>i</em>)</sub> = Î£<sub><em>i</em></sub> (<strong>x</strong><sub>(<em>i</em>)</sub> â‹… <strong>w</strong><sub>(<em>k</em>)</sub>)<sup>2</sup>)</p>
<h3 id="dimensionality-reduction">Dimensionality reduction</h3>

<p>The faithful transformation <strong>T</strong> = <strong>X</strong> <strong>W</strong> maps a data vector <strong>x</strong><sub>(<em>i</em>)</sub> from an original space of <em>p</em> variables to a new space of <em>p</em> variables which are uncorrelated over the dataset. However, not all the principal components need to be kept. Keeping only the first <em>L</em> principal components, produced by using only the first <em>L</em> loading vectors, gives the truncated transformation</p>

<p>

<math display="block" id="Principal_component_analysis:13">
 <semantics>
  <mrow>
   <msub>
    <mi>ğ“</mi>
    <mi>L</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>ğ—ğ–</mi>
    <mi>L</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ“</ci>
     <ci>L</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ—ğ–</ci>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{T}_{L}=\mathbf{X}\mathbf{W}_{L}
  </annotation>
 </semantics>
</math>

</p>

<p>where the matrix <strong>T</strong><sub>L</sub> now has <em>n</em> rows but only <em>L</em> columns. In other words, PCA learns a linear transformation 

<math display="inline" id="Principal_component_analysis:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>t</mi>
     <mo>=</mo>
     <mrow>
      <msup>
       <mi>W</mi>
       <mi>T</mi>
      </msup>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mi>x</mi>
      <mo>âˆˆ</mo>
      <msup>
       <mi>R</mi>
       <mi>p</mi>
      </msup>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>t</mi>
      <mo>âˆˆ</mo>
      <msup>
       <mi>R</mi>
       <mi>L</mi>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>t</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>W</ci>
       <ci>T</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>R</ci>
       <ci>p</ci>
      </apply>
     </apply>
     <apply>
      <in></in>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>R</ci>
       <ci>L</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=W^{T}x,x\in R^{p},t\in R^{L},
  </annotation>
 </semantics>
</math>

 where the columns of 

<math display="inline" id="Principal_component_analysis:15">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mi mathvariant="normal">Ã—</mi>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>normal-Ã—</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   pÃ—L
  </annotation>
 </semantics>
</math>

 matrix <em>W</em> form an orthogonal basis for the <em>L</em> features (the components of representation <em>t</em>) that are decorrelated.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> By construction, of all the transformed data matrices with only <em>L</em> columns, this score matrix maximises the variance in the original data that has been preserved, while minimising the total squared reconstruction error 

<math display="inline" id="Principal_component_analysis:16">
 <semantics>
  <msubsup>
   <mrow>
    <mo>âˆ¥</mo>
    <mrow>
     <msup>
      <mi>ğ“ğ–</mi>
      <mi>T</mi>
     </msup>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>ğ“</mi>
       <mi>L</mi>
      </msub>
      <msubsup>
       <mi>ğ–</mi>
       <mi>L</mi>
       <mi>T</mi>
      </msubsup>
     </mrow>
    </mrow>
    <mo>âˆ¥</mo>
   </mrow>
   <mn>2</mn>
   <mn>2</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ğ“ğ–</ci>
        <ci>T</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ğ“</ci>
         <ci>L</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>ğ–</ci>
          <ci>T</ci>
         </apply>
         <ci>L</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\mathbf{T}\mathbf{W}^{T}-\mathbf{T}_{L}\mathbf{W}^{T}_{L}\|_{2}^{2}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Principal_component_analysis:17">
 <semantics>
  <msubsup>
   <mrow>
    <mo>âˆ¥</mo>
    <mrow>
     <mi>ğ—</mi>
     <mo>-</mo>
     <msub>
      <mi>ğ—</mi>
      <mi>L</mi>
     </msub>
    </mrow>
    <mo>âˆ¥</mo>
   </mrow>
   <mn>2</mn>
   <mn>2</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <ci>ğ—</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ğ—</ci>
        <ci>L</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|\mathbf{X}-\mathbf{X}_{L}\|_{2}^{2}
  </annotation>
 </semantics>
</math>

.</p>

<p> Such <a href="dimensionality_reduction" title="wikilink">dimensionality reduction</a> can be a very useful step for visualising and processing high-dimensional datasets, while still retaining as much of the variance in the dataset as possible. For example, selecting <em>L</em>Â =Â 2 and keeping only the first two principal components finds the two-dimensional plane through the high-dimensional dataset in which the data is most spread out, so if the data contains <a href="Cluster_analysis" title="wikilink">clusters</a> these too may be most spread out, and therefore most visible to be plotted out in a two-dimensional diagram; whereas if two directions through the data (or two of the original variables) are chosen at random, the clusters may be much less spread apart from each other, and may in fact be much more likely to substantially overlay each other, making them indistinguishable.</p>

<p>Similarly, in <a href="regression_analysis" title="wikilink">regression analysis</a>, the larger the number of <a href="explanatory_variable" title="wikilink">explanatory variables</a> allowed, the greater is the chance of <a class="uri" href="overfitting" title="wikilink">overfitting</a> the model, producing conclusions that fail to generalise to other datasets. One approach, especially when there are strong correlations between different possible explanatory variables, is to reduce them to a few principal components and then run the regression against them, a method called <a href="principal_component_regression" title="wikilink">principal component regression</a>.</p>

<p>Dimensionality reduction may also be appropriate when the variables in a dataset are noisy. If each column of the dataset contains independent identically distributed Gaussian noise, then the columns of <strong>T</strong> will also contain similarly identically distributed Gaussian noise (such a distribution is invariant under the effects of the matrix <strong>W</strong>, which can be thought of as a high-dimensional rotation of the co-ordinate axes). However, with more of the total variance concentrated in the first few principal components compared to the same noise variance, the proportionate effect of the noise is lessâ€”the first few components achieve a higher <a href="signal-to-noise_ratio" title="wikilink">signal-to-noise ratio</a>. PCA thus can have the effect of concentrating much of the signal into the first few principal components, which can usefully be captured by dimensionality reduction; while the later principal components may be dominated by noise, and so disposed of without great loss.</p>
<h3 id="singular-value-decomposition">Singular value decomposition</h3>

<p>The principal components transformation can also be associated with another matrix factorisation, the <a href="singular_value_decomposition" title="wikilink">singular value decomposition</a> (SVD) of <strong>X</strong>,</p>

<p>

<math display="block" id="Principal_component_analysis:18">
 <semantics>
  <mrow>
   <mi>ğ—</mi>
   <mo>=</mo>
   <mrow>
    <mi>ğ”</mi>
    <mi>ğšº</mi>
    <msup>
     <mi>ğ–</mi>
     <mi>T</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ—</ci>
    <apply>
     <times></times>
     <ci>ğ”</ci>
     <ci>ğšº</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ğ–</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{X}=\mathbf{U}\mathbf{\Sigma}\mathbf{W}^{T}
  </annotation>
 </semantics>
</math>

 Here <strong>Î£</strong> is a <em>n</em>-by-<em>p</em> <a href="Diagonal_matrix" title="wikilink">rectangular diagonal matrix</a> of positive numbers <em>Ïƒ</em><sub>(<em>k</em>)</sub>, called the singular values of <strong>X</strong>; <strong>U</strong> is an <em>n</em>-by-<em>n</em> matrix, the columns of which are orthogonal unit vectors of length <em>n</em> called the left singular vectors of <strong>X</strong>; and <strong>W</strong> is a <em>p</em>-by-<em>p</em> whose columns are orthogonal unit vectors of length <em>p</em> and called the right singular vectors of <strong>X</strong>.</p>

<p>In terms of this factorisation, the matrix <strong>X</strong><sup>T</sup><strong>X</strong> can be written</p>

<p>

<math display="inline" id="Principal_component_analysis:19">
 <semantics>
  <mrow>
   <msup>
    <mi>ğ—</mi>
    <mi>T</mi>
   </msup>
   <mi>ğ—</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ğ—</ci>
     <ci>T</ci>
    </apply>
    <ci>ğ—</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\mathbf{X}^{T}\mathbf{X}
  </annotation>
 </semantics>
</math>


</p>

<p>Comparison with the eigenvector factorisation of <strong>X</strong><sup>T</sup><strong>X</strong> establishes that the right singular vectors <strong>W</strong> of <strong>X</strong> are equivalent to the eigenvectors of <strong>X</strong><sup>T</sup><strong>X</strong>, while the singular values <em>Ïƒ</em><sub>(<em>k</em>)</sub> of <strong>X</strong> are equal to the square roots of the eigenvalues <em>Î»</em><sub>(<em>k</em>)</sub> of <strong>X</strong><sup>T</sup><strong>X</strong>.</p>

<p>Using the singular value decomposition the score matrix <strong>T</strong> can be written</p>

<p>

<math display="inline" id="Principal_component_analysis:20">
 <semantics>
  <mi>ğ“</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ“</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\mathbf{T}
  </annotation>
 </semantics>
</math>


 so each column of <strong>T</strong> is given by one of the left singular vectors of <strong>X</strong> multiplied by the corresponding singular value. This form is also the <a href="polar_decomposition" title="wikilink">polar decomposition</a> of <strong>T</strong>.</p>

<p>Efficient algorithms exist to calculate the SVD of <strong>X</strong> without having to form the matrix <strong>X</strong><sup>T</sup><strong>X</strong>, so computing the SVD is now the standard way to calculate a principal components analysis from a data matrix, unless only a handful of components are required.</p>

<p>As with the eigen-decomposition, a truncated 

<math display="inline" id="Principal_component_analysis:21">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">Ã—</mi>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-Ã—</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   nÃ—L
  </annotation>
 </semantics>
</math>

 score matrix <strong>T</strong><sub>L</sub> can be obtained by considering only the first L largest singular values and their singular vectors:</p>

<p>

<math display="block" id="Principal_component_analysis:22">
 <semantics>
  <mrow>
   <msub>
    <mi>ğ“</mi>
    <mi>L</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>ğ”</mi>
     <mi>L</mi>
    </msub>
    <msub>
     <mi>ğšº</mi>
     <mi>L</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>ğ—ğ–</mi>
    <mi>L</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ğ“</ci>
      <ci>L</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ğ”</ci>
       <ci>L</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ğšº</ci>
       <ci>L</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ğ—ğ–</ci>
      <ci>L</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{T}_{L}=\mathbf{U}_{L}\mathbf{\Sigma}_{L}=\mathbf{X}\mathbf{W}_{L}
  </annotation>
 </semantics>
</math>

 The truncation of a matrix <strong>M</strong> or <strong>T</strong> using a truncated singular value decomposition in this way produces a truncated matrix that is the nearest possible matrix of <a href="Rank_(linear_algebra)" title="wikilink">rank</a> <em>L</em> to the original matrix, in the sense of the difference between the two having the smallest possible <a href="Frobenius_norm" title="wikilink">Frobenius norm</a>, a result known as the Eckartâ€“Young theorem [1936].</p>
<h2 id="further-considerations">Further considerations</h2>

<p>Given a set of points in <a href="Euclidean_space" title="wikilink">Euclidean space</a>, the first principal component corresponds to a line that passes through the multidimensional mean and minimizes the sum of squares of the distances of the points from the line. The second principal component corresponds to the same concept after all correlation with the first principal component has been subtracted from the points. The singular values (in <strong>Î£</strong>) are the square roots of the <a href="eigenvalue" title="wikilink">eigenvalues</a> of the matrix <strong>X</strong><sup>T</sup><strong>X</strong>. Each eigenvalue is proportional to the portion of the "variance" (more correctly of the sum of the squared distances of the points from their multidimensional mean) that is correlated with each eigenvector. The sum of all the eigenvalues is equal to the sum of the squared distances of the points from their multidimensional mean. PCA essentially rotates the set of points around their mean in order to align with the principal components. This moves as much of the variance as possible (using an orthogonal transformation) into the first few dimensions. The values in the remaining dimensions, therefore, tend to be small and may be dropped with minimal loss of information (see <a href="Principle_Component_Analysis#PCA_and_Information_Theory" title="wikilink">below</a>). PCA is often used in this manner for <a href="dimensionality_reduction" title="wikilink">dimensionality reduction</a>. PCA has the distinction of being the optimal orthogonal transformation for keeping the subspace that has largest "variance" (as defined above). This advantage, however, comes at the price of greater computational requirements if compared, for example and when applicable, to the <a href="discrete_cosine_transform" title="wikilink">discrete cosine transform</a>, and in particular to the DCT-II which is simply known as the "DCT". <a href="Nonlinear_dimensionality_reduction" title="wikilink">Nonlinear dimensionality reduction</a> techniques tend to be more computationally demanding than PCA.</p>

<p>PCA is sensitive to the scaling of the variables. If we have just two variables and they have the same <a href="sample_variance" title="wikilink">sample variance</a> and are positively correlated, then the PCA will entail a rotation by 45Â° and the "loadings" for the two variables with respect to the principal component will be equal. But if we multiply all values of the first variable by 100, then the first principal component will be almost the same as that variable, with a small contribution from the other variable, whereas the second component will be almost aligned with the second original variable. This means that whenever the different variables have different units (like temperature and mass), PCA is a somewhat arbitrary method of analysis. (Different results would be obtained if one used Fahrenheit rather than Celsius for example.) Note that Pearson's original paper was entitled "On Lines and Planes of Closest Fit to Systems of Points in Space" â€“ "in space" implies physical Euclidean space where such concerns do not arise. One way of making the PCA less arbitrary is to use variables scaled so as to have unit variance, by standardizing the data and hence use the autocorrelation matrix instead of the autocovariance matrix as a basis for PCA. However, this compresses (or expands) the fluctuations in all dimensions of the signal space to unit variance.</p>

<p>Mean subtraction (a.k.a. "mean centering") is necessary for performing PCA to ensure that the first principal component describes the direction of maximum variance. If mean subtraction is not performed, the first principal component might instead correspond more or less to the mean of the data. A mean of zero is needed for finding a basis that minimizes the <a href="Minimum_mean_square_error" title="wikilink">mean square error</a> of the approximation of the data.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>PCA is equivalent to <a href="empirical_orthogonal_functions" title="wikilink">empirical orthogonal functions</a> (EOF), a name which is used in <a class="uri" href="meteorology" title="wikilink">meteorology</a>.</p>

<p>An <a class="uri" href="autoencoder" title="wikilink">autoencoder</a> <a href="Artificial_neural_network" title="wikilink">neural network</a> with a linear hidden layer is similar to PCA. Upon convergence, the weight vectors of the <em>K</em> neurons in the hidden layer will form a basis for the space spanned by the first <em>K</em> principal components. Unlike PCA, this technique will not necessarily produce <a class="uri" href="orthogonal" title="wikilink">orthogonal</a> vectors.</p>

<p>PCA is a popular primary technique in <a href="pattern_recognition" title="wikilink">pattern recognition</a>. It is not, however, optimized for class separability.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> An alternative is the <a href="linear_discriminant_analysis" title="wikilink">linear discriminant analysis</a>, which does take this into account.</p>
<h2 id="table-of-symbols-and-abbreviations">Table of symbols and abbreviations</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Symbol</p></th>
<th style="text-align: left;">
<p>Meaning</p></th>
<th style="text-align: left;">
<p>Dimensions</p></th>
<th style="text-align: left;">
<p>Indices</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:23">
 <semantics>
  <mrow>
   <mi>ğ—</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>X</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>i</mi>
      <mo>,</mo>
      <mi>j</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ—</ci>
    <set>
     <apply>
      <times></times>
      <ci>X</ci>
      <interval closure="closed">
       <ci>i</ci>
       <ci>j</ci>
      </interval>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{X}=\{X[i,j]\}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>data matrix, consisting of the set of all data vectors, one vector per row</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:24">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>Ã—</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times p
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:25">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">â€¦</mi>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-â€¦</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1\ldots n
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="Principal_component_analysis:26">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">â€¦</mi>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>j</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-â€¦</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j=1\ldots p
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:27">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>n</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\,
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p>the number of row vectors in the data set</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:28">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>Ã—</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">1</cn>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\times 1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><em>scalar</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:29">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>p</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>the number of elements in each row vector (dimension)</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:30">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>Ã—</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">1</cn>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\times 1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><em>scalar</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:31">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>L</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\,
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>the number of dimensions in the dimensionally reduced subspace, 

<math display="inline" id="Principal_component_analysis:32">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>â‰¤</mo>
   <mi>L</mi>
   <mo>â‰¤</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>L</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq L\leq p
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:33">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>Ã—</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">1</cn>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\times 1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><em>scalar</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:34">
 <semantics>
  <mrow>
   <mi>ğ®</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>u</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>j</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ®</ci>
    <set>
     <apply>
      <times></times>
      <ci>u</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>j</ci>
      </apply>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}=\{u[j]\}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>vector of empirical <a href="mean" title="wikilink">means</a>, one mean for each column <em>j</em> of the data matrix</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:35">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>Ã—</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\times 1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:36">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">â€¦</mi>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>j</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-â€¦</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j=1\ldots p
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:37">
 <semantics>
  <mrow>
   <mi>ğ¬</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>j</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ¬</ci>
    <set>
     <apply>
      <times></times>
      <ci>s</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>j</ci>
      </apply>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}=\{s[j]\}
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p>vector of empirical <a href="standard_deviation" title="wikilink">standard deviations</a>, one standard deviation for each column <em>j</em> of the data matrix</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:38">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>Ã—</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\times 1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:39">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">â€¦</mi>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>j</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-â€¦</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j=1\ldots p
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:40">
 <semantics>
  <mrow>
   <mi>ğ¡</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>i</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ¡</ci>
    <set>
     <apply>
      <times></times>
      <ci>h</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>i</ci>
      </apply>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{h}=\{h[i]\}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>vector of all 1's</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:41">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>Ã—</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">1</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\times n
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:42">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">â€¦</mi>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-â€¦</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1\ldots n
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:43">
 <semantics>
  <mrow>
   <mi>ğ</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>i</mi>
      <mo>,</mo>
      <mi>j</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ</ci>
    <set>
     <apply>
      <times></times>
      <ci>B</ci>
      <interval closure="closed">
       <ci>i</ci>
       <ci>j</ci>
      </interval>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{B}=\{B[i,j]\}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><a href="Standard_deviation" title="wikilink">deviations</a> from the mean of each column <em>j</em> of the data matrix</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:44">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>Ã—</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times p
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:45">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">â€¦</mi>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-â€¦</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1\ldots n
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="Principal_component_analysis:46">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">â€¦</mi>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>j</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-â€¦</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j=1\ldots p
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:47">
 <semantics>
  <mrow>
   <mi>ğ™</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>Z</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>m</mi>
      <mo>,</mo>
      <mi>n</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ™</ci>
    <set>
     <apply>
      <times></times>
      <ci>Z</ci>
      <interval closure="closed">
       <ci>m</ci>
       <ci>n</ci>
      </interval>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Z}=\{Z[m,n]\}
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p><a href="z-score" title="wikilink">z-scores</a>, computed using the mean and standard deviation for each row <em>m</em> of the data matrix</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:48">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>Ã—</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times p
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:49">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">â€¦</mi>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-â€¦</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1\ldots n
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="Principal_component_analysis:50">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">â€¦</mi>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>j</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-â€¦</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j=1\ldots p
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:51">
 <semantics>
  <mrow>
   <mi>ğ‚</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>k</mi>
      <mo>,</mo>
      <mi>l</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ‚</ci>
    <set>
     <apply>
      <times></times>
      <ci>C</ci>
      <interval closure="closed">
       <ci>k</ci>
       <ci>l</ci>
      </interval>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C}=\{C[k,l]\}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><a href="covariance_matrix" title="wikilink">covariance matrix</a></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:52">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>Ã—</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\times p
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:53">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">â€¦</mi>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-â€¦</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=1\ldots p
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="Principal_component_analysis:54">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">â€¦</mi>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>l</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-â€¦</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l=1\ldots p
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:55">
 <semantics>
  <mrow>
   <mi>ğ‘</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>k</mi>
      <mo>,</mo>
      <mi>l</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ‘</ci>
    <set>
     <apply>
      <times></times>
      <ci>R</ci>
      <interval closure="closed">
       <ci>k</ci>
       <ci>l</ci>
      </interval>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{R}=\{R[k,l]\}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><a href="correlation_matrix" title="wikilink">correlation matrix</a></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:56">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>Ã—</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\times p
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:57">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">â€¦</mi>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-â€¦</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=1\ldots p
  </annotation>
 </semantics>
</math>


<br/>


<math display="inline" id="Principal_component_analysis:58">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">â€¦</mi>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>l</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-â€¦</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l=1\ldots p
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:59">
 <semantics>
  <mrow>
   <mi>ğ•</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>j</mi>
      <mo>,</mo>
      <mi>k</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ•</ci>
    <set>
     <apply>
      <times></times>
      <ci>V</ci>
      <interval closure="closed">
       <ci>j</ci>
       <ci>k</ci>
      </interval>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}=\{V[j,k]\}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>matrix consisting of the set of all <a class="uri" href="eigenvectors" title="wikilink">eigenvectors</a> of <strong>C</strong>, one eigenvector per column</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:60">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>Ã—</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\times p
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:61">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">â€¦</mi>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>j</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-â€¦</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j=1\ldots p
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="Principal_component_analysis:62">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">â€¦</mi>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-â€¦</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=1\ldots p
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:63">
 <semantics>
  <mrow>
   <mi>ğƒ</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>D</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>k</mi>
      <mo>,</mo>
      <mi>l</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğƒ</ci>
    <set>
     <apply>
      <times></times>
      <ci>D</ci>
      <interval closure="closed">
       <ci>k</ci>
       <ci>l</ci>
      </interval>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{D}=\{D[k,l]\}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><a href="diagonal_matrix" title="wikilink">diagonal matrix</a> consisting of the set of all <a class="uri" href="eigenvalues" title="wikilink">eigenvalues</a> of <strong>C</strong> along its <a href="principal_diagonal" title="wikilink">principal diagonal</a>, and 0 for all other elements</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:64">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>Ã—</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\times p
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:65">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">â€¦</mi>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-â€¦</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=1\ldots p
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="Principal_component_analysis:66">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">â€¦</mi>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>l</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-â€¦</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l=1\ldots p
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:67">
 <semantics>
  <mrow>
   <mi>ğ–</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>W</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>j</mi>
      <mo>,</mo>
      <mi>k</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ–</ci>
    <set>
     <apply>
      <times></times>
      <ci>W</ci>
      <interval closure="closed">
       <ci>j</ci>
       <ci>k</ci>
      </interval>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{W}=\{W[j,k]\}
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p>matrix of basis vectors, one vector per column, where each basis vector is one of the eigenvectors of <strong>C</strong>, and where the vectors in <strong>W</strong> are a sub-set of those in <strong>V</strong></p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:68">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>Ã—</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\times L
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:69">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">â€¦</mi>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>j</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-â€¦</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j=1\ldots p
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="Principal_component_analysis:70">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">â€¦</mi>
    <mi>L</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-â€¦</ci>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=1\ldots L
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:71">
 <semantics>
  <mrow>
   <mi>ğ“</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>i</mi>
      <mo>,</mo>
      <mi>k</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ“</ci>
    <set>
     <apply>
      <times></times>
      <ci>T</ci>
      <interval closure="closed">
       <ci>i</ci>
       <ci>k</ci>
      </interval>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{T}=\{T[i,k]\}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>matrix consisting of <em>n</em> row vectors, where each vector is the projection of the corresponding data vector from matrix <strong>X</strong> onto the basis vectors contained in the columns of matrix <strong>W</strong>.</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:72">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>Ã—</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times L
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Principal_component_analysis:73">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">â€¦</mi>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-â€¦</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1\ldots n
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="Principal_component_analysis:74">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">â€¦</mi>
    <mi>L</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-â€¦</ci>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=1\ldots L
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>
<h2 id="properties-and-limitations-of-pca">Properties and limitations of PCA</h2>
<h3 id="properties">Properties<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></h3>
<dl>
<dd><big><strong><em>Property 1</em>:</strong></big> For any integer <em>q, 1 â‰¤ q â‰¤ p,</em> consider the orthogonal <a href="linear_transformation" title="wikilink">linear transformation</a>

<p>

<math display="block" id="Principal_component_analysis:75">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>ğ</mi>
     <mo>â€²</mo>
    </msup>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ğ</ci>
      <ci>normal-â€²</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=\mathbf{B^{\prime}}x
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>where 

<math display="inline" id="Principal_component_analysis:76">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is a <em>q-element</em> vector and 

<math display="inline" id="Principal_component_analysis:77">
 <semantics>
  <msup>
   <mi>ğ</mi>
   <mo>â€²</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ğ</ci>
    <ci>normal-â€²</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{B^{\prime}}
  </annotation>
 </semantics>
</math>


 is a <em>(q Ã— p)</em> matrix, and let 

<math display="inline" id="Principal_component_analysis:78">
 <semantics>
  <mrow>
   <msub>
    <mi>ğšº</mi>
    <mi>y</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>ğ</mi>
     <mo>â€²</mo>
    </msup>
    <mi>ğšº</mi>
    <mi>ğ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğšº</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ğ</ci>
      <ci>normal-â€²</ci>
     </apply>
     <ci>ğšº</ci>
     <ci>ğ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{{\Sigma}}_{y}=\mathbf{B^{\prime}}\mathbf{\Sigma}\mathbf{B}
  </annotation>
 </semantics>
</math>

 be the <a class="uri" href="variance" title="wikilink">variance</a>-<a class="uri" href="covariance" title="wikilink">covariance</a> matrix for 

<math display="inline" id="Principal_component_analysis:79">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

. Then the trace of 

<math display="inline" id="Principal_component_analysis:80">
 <semantics>
  <msub>
   <mi>ğšº</mi>
   <mi>y</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ğšº</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\Sigma}_{y}
  </annotation>
 </semantics>
</math>

, denoted 

<math display="inline" id="Principal_component_analysis:81">
 <semantics>
  <mrow>
   <mtext>tr</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ğšº</mi>
     <mi>y</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>tr</mtext>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğšº</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{tr}(\mathbf{\Sigma}_{y})
  </annotation>
 </semantics>
</math>

, is maximized by taking 

<math display="inline" id="Principal_component_analysis:82">
 <semantics>
  <mrow>
   <mi>ğ</mi>
   <mo>=</mo>
   <msub>
    <mi>ğ€</mi>
    <mi>q</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ€</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{B}=\mathbf{A}_{q}
  </annotation>
 </semantics>
</math>


, where 

<math display="inline" id="Principal_component_analysis:83">
 <semantics>
  <msub>
   <mi>ğ€</mi>
   <mi>q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ğ€</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}_{q}
  </annotation>
 </semantics>
</math>

 consists of the first <em>q</em> columns of 

<math display="inline" id="Principal_component_analysis:84">
 <semantics>
  <mi>ğ€</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ€</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Principal_component_analysis:85">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msup>
    <mi>ğ</mi>
    <mo>â€²</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ğ</ci>
     <ci>normal-â€²</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbf{B^{\prime}}
  </annotation>
 </semantics>
</math>

 is the transposition of 

<math display="inline" id="Principal_component_analysis:86">
 <semantics>
  <mrow>
   <mi>ğ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">B</csymbol>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{B})
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
<dl>
<dd><big><strong><em>Property 2</em>:</strong></big> Consider again the <a href="orthonormal_transformation" title="wikilink">orthonormal transformation</a>

<p>

<math display="block" id="Principal_component_analysis:87">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>ğ</mi>
     <mo>â€²</mo>
    </msup>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ğ</ci>
      <ci>normal-â€²</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=\mathbf{B^{\prime}}x
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>with 

<math display="inline" id="Principal_component_analysis:88">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>,</mo>
   <mi>ğ</mi>
   <mo>,</mo>
   <mi>ğ€</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>x</ci>
    <ci>ğ</ci>
    <ci>ğ€</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,\mathbf{B},\mathbf{A}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Principal_component_analysis:89">
 <semantics>
  <msub>
   <mi>ğšº</mi>
   <mi>y</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ğšº</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\Sigma}_{y}
  </annotation>
 </semantics>
</math>

 defined as before. Then 

<math display="inline" id="Principal_component_analysis:90">
 <semantics>
  <mrow>
   <mtext>tr</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ğšº</mi>
     <mi>y</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>tr</mtext>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğšº</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{tr}(\mathbf{\Sigma}_{y})
  </annotation>
 </semantics>
</math>

 is minimized by taking 

<math display="inline" id="Principal_component_analysis:91">
 <semantics>
  <mrow>
   <mrow>
    <mi>ğ</mi>
    <mo>=</mo>
    <msubsup>
     <mi>ğ€</mi>
     <mi>q</mi>
     <mo>*</mo>
    </msubsup>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ğ€</ci>
      <ci>q</ci>
     </apply>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{B}=\mathbf{A}_{q}^{*},
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Principal_component_analysis:92">
 <semantics>
  <msubsup>
   <mi>ğ€</mi>
   <mi>q</mi>
   <mo>*</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ€</ci>
     <ci>q</ci>
    </apply>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}_{q}^{*}
  </annotation>
 </semantics>
</math>


 consists of the last <em>q</em> columns of 

<math display="inline" id="Principal_component_analysis:93">
 <semantics>
  <mi>ğ€</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ€</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{A}
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>

<p>The statistical implication of this property is that the last few PCs are not simply unstructured left-overs after removing the important PCs. Because these last PCs have variances as small as possible they are useful in their own right. They can help to detect unsuspected near-constant linear relationships between the elements of 

<math display="inline" id="Principal_component_analysis:94">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, and they may also be useful in <a href="regression_analysis" title="wikilink">regression</a>, in selecting a subset of variables from 

<math display="inline" id="Principal_component_analysis:95">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, and in outlier detection.</p>
<dl>
<dd><big><strong><em>Property 3</em>:</strong></big> (Spectral Decomposition of 

<math display="inline" id="Principal_component_analysis:96">
 <semantics>
  <mi>ğšº</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğšº</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Î£}
  </annotation>
 </semantics>
</math>

)

<p>

<math display="block" id="Principal_component_analysis:97">
 <semantics>
  <mrow>
   <mi>ğšº</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>Î»</mi>
      <mn>1</mn>
     </msub>
     <msub>
      <mi>Î±</mi>
      <mn>1</mn>
     </msub>
     <msubsup>
      <mi>Î±</mi>
      <mn>1</mn>
      <mo>â€²</mo>
     </msubsup>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">â‹¯</mi>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>Î»</mi>
      <mi>p</mi>
     </msub>
     <msub>
      <mi>Î±</mi>
      <mi>p</mi>
     </msub>
     <msubsup>
      <mi>Î±</mi>
      <mi>p</mi>
      <mo>â€²</mo>
     </msubsup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğšº</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Î»</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Î±</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Î±</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-â€²</ci>
      </apply>
     </apply>
     <ci>normal-â‹¯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Î»</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Î±</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Î±</ci>
        <ci>p</ci>
       </apply>
       <ci>normal-â€²</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{{\Sigma}}=\lambda_{1}\alpha_{1}\alpha_{1}^{\prime}+\cdots+\lambda_{p}%
\alpha_{p}\alpha_{p}^{\prime}
  </annotation>
 </semantics>
</math>

</p>
</dd>
</dl>

<p>Before we look at its usage, we first look at <a class="uri" href="diagonal" title="wikilink">diagonal</a> elements,</p>

<p>

<math display="block" id="Principal_component_analysis:98">
 <semantics>
  <mrow>
   <mrow>
    <mtext>Var</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">âˆ‘</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>P</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>Î»</mi>
      <mi>k</mi>
     </msub>
     <msubsup>
      <mi>Î±</mi>
      <mrow>
       <mi>k</mi>
       <mi>j</mi>
      </mrow>
      <mn>2</mn>
     </msubsup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>Var</mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>P</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Î»</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Î±</ci>
        <apply>
         <times></times>
         <ci>k</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{Var}(x_{j})=\sum_{k=1}^{P}\lambda_{k}\alpha_{kj}^{2}
  </annotation>
 </semantics>
</math>

 Then, perhaps the main statistical implication of the result is that not only can we decompose the combined variances of all the elements of 

<math display="inline" id="Principal_component_analysis:99">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 into decreasing contributions due to each PC, but we can also decompose the whole <a href="covariance_matrix" title="wikilink">covariance matrix</a> into contributions 

<math display="inline" id="Principal_component_analysis:100">
 <semantics>
  <mrow>
   <msub>
    <mi>Î»</mi>
    <mi>k</mi>
   </msub>
   <msub>
    <mi>Î±</mi>
    <mi>k</mi>
   </msub>
   <msubsup>
    <mi>Î±</mi>
    <mi>k</mi>
    <mo>â€²</mo>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Î»</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Î±</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Î±</ci>
      <ci>k</ci>
     </apply>
     <ci>normal-â€²</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{k}\alpha_{k}\alpha_{k}^{\prime}
  </annotation>
 </semantics>
</math>

 from each PC. Although not strictly decreasing, the elements of 

<math display="inline" id="Principal_component_analysis:101">
 <semantics>
  <mrow>
   <msub>
    <mi>Î»</mi>
    <mi>k</mi>
   </msub>
   <msub>
    <mi>Î±</mi>
    <mi>k</mi>
   </msub>
   <msubsup>
    <mi>Î±</mi>
    <mi>k</mi>
    <mo>â€²</mo>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Î»</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Î±</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Î±</ci>
      <ci>k</ci>
     </apply>
     <ci>normal-â€²</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{k}\alpha_{k}\alpha_{k}^{\prime}
  </annotation>
 </semantics>
</math>

 will tend to become smaller as 

<math display="inline" id="Principal_component_analysis:102">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>


 increases, as 

<math display="inline" id="Principal_component_analysis:103">
 <semantics>
  <mrow>
   <msub>
    <mi>Î»</mi>
    <mi>k</mi>
   </msub>
   <msub>
    <mi>Î±</mi>
    <mi>k</mi>
   </msub>
   <msubsup>
    <mi>Î±</mi>
    <mi>k</mi>
    <mo>â€²</mo>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Î»</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Î±</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Î±</ci>
      <ci>k</ci>
     </apply>
     <ci>normal-â€²</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{k}\alpha_{k}\alpha_{k}^{\prime}
  </annotation>
 </semantics>
</math>

 decreases for increasing 

<math display="inline" id="Principal_component_analysis:104">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, whereas the elements of 

<math display="inline" id="Principal_component_analysis:105">
 <semantics>
  <msub>
   <mi>Î±</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Î±</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{k}
  </annotation>
 </semantics>
</math>

 tend to stay 'about the same size'because of the normalization constraints

<math display="block" id="Principal_component_analysis:106">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mi>Î±</mi>
      <mi>k</mi>
      <mo>â€²</mo>
     </msubsup>
     <msub>
      <mi>Î±</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">â‹¯</mi>
     <mo>,</mo>
     <mi>p</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Î±</ci>
        <ci>k</ci>
       </apply>
       <ci>normal-â€²</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Î±</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <eq></eq>
     <ci>k</ci>
     <list>
      <cn type="integer">1</cn>
      <ci>normal-â‹¯</ci>
      <ci>p</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{k}^{\prime}\alpha_{k}=1,k=1,\cdots,p
  </annotation>
 </semantics>
</math>

</p>
<h3 id="limitations">Limitations</h3>

<p>As noted above, the results of PCA depend on the scaling of the variables. A scale-invariant form of PCA has been developed.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>The applicability of PCA is limited by certain assumptions<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> made in its derivation.</p>
<h3 id="pca-and-information-theory">PCA and information theory</h3>

<p>The claim that the PCA used for dimensionality reduction preserves most of the information of the data is misleading. Indeed, without any assumption on the signal model, PCA cannot help to reduce the amount of information lost during dimensionality reduction, where information was measured using <a href="Entropy_(information_theory)" title="wikilink">Shannon entropy</a>.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>Under the assumption that</p>

<p>

<math display="block" id="Principal_component_analysis:107">
 <semantics>
  <mrow>
   <mi>ğ±</mi>
   <mo>=</mo>
   <mrow>
    <mi>ğ¬</mi>
    <mo>+</mo>
    <mi>ğ§</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ±</ci>
    <apply>
     <plus></plus>
     <ci>ğ¬</ci>
     <ci>ğ§</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}=\mathbf{s}+\mathbf{n}
  </annotation>
 </semantics>
</math>

</p>

<p>i.e., that the data vector 

<math display="inline" id="Principal_component_analysis:108">
 <semantics>
  <mi>ğ±</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ±</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 is the sum of the desired information-bearing signal 

<math display="inline" id="Principal_component_analysis:109">
 <semantics>
  <mi>ğ¬</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ¬</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}
  </annotation>
 </semantics>
</math>

 and a noise signal 

<math display="inline" id="Principal_component_analysis:110">
 <semantics>
  <mi>ğ§</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ§</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{n}
  </annotation>
 </semantics>
</math>

 one can show that PCA can be optimal for dimensionality reduction also from an information-theoretic point-of-view.</p>

<p>In particular, Linsker showed that if 

<math display="inline" id="Principal_component_analysis:111">
 <semantics>
  <mi>ğ¬</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ¬</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}
  </annotation>
 </semantics>
</math>

 is Gaussian and 

<math display="inline" id="Principal_component_analysis:112">
 <semantics>
  <mi>ğ§</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ§</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{n}
  </annotation>
 </semantics>
</math>


 is Gaussian noise with a covariance matrix proportional to the identity matrix, the PCA maximizes the <a href="mutual_information" title="wikilink">mutual information</a> 

<math display="inline" id="Principal_component_analysis:113">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ğ²</mi>
    <mo>;</mo>
    <mi>ğ¬</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <list>
     <ci>ğ²</ci>
     <ci>ğ¬</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(\mathbf{y};\mathbf{s})
  </annotation>
 </semantics>
</math>

 between the desired information 

<math display="inline" id="Principal_component_analysis:114">
 <semantics>
  <mi>ğ¬</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ¬</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}
  </annotation>
 </semantics>
</math>

 and the dimensionality-reduced output 

<math display="inline" id="Principal_component_analysis:115">
 <semantics>
  <mrow>
   <mi>ğ²</mi>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>ğ–</mi>
     <mi>L</mi>
     <mi>T</mi>
    </msubsup>
    <mi>ğ±</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ²</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ğ–</ci>
       <ci>L</ci>
      </apply>
      <ci>T</ci>
     </apply>
     <ci>ğ±</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}=\mathbf{W}_{L}^{T}\mathbf{x}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>If the noise is still Gaussian and has a covariance matrix proportional to the identity matrix (i.e., the components of the vector 

<math display="inline" id="Principal_component_analysis:116">
 <semantics>
  <mi>ğ§</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ§</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{n}
  </annotation>
 </semantics>
</math>

 are <a class="uri" href="iid" title="wikilink">iid</a>), but the information-bearing signal 

<math display="inline" id="Principal_component_analysis:117">
 <semantics>
  <mi>ğ¬</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ¬</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}
  </annotation>
 </semantics>
</math>


 is non-Gaussian (which is a common scenario), PCA at least minimizes an upper bound on the <em>information loss</em>, which is defined as<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>

<p>

<math display="block" id="Principal_component_analysis:118">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>I</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ğ±</mi>
      <mo>;</mo>
      <mi>ğ¬</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>I</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ğ²</mi>
      <mo>;</mo>
      <mi>ğ¬</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>I</ci>
     <list>
      <ci>ğ±</ci>
      <ci>ğ¬</ci>
     </list>
    </apply>
    <apply>
     <times></times>
     <ci>I</ci>
     <list>
      <ci>ğ²</ci>
      <ci>ğ¬</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(\mathbf{x};\mathbf{s})-I(\mathbf{y};\mathbf{s}).
  </annotation>
 </semantics>
</math>

</p>

<p>The optimality of PCA is also preserved if the noise 

<math display="inline" id="Principal_component_analysis:119">
 <semantics>
  <mi>ğ§</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ§</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{n}
  </annotation>
 </semantics>
</math>

 is iid and at least more Gaussian (in terms of the <a href="Kullbackâ€“Leibler_divergence" title="wikilink">Kullbackâ€“Leibler divergence</a>) than the information-bearing signal 

<math display="inline" id="Principal_component_analysis:120">
 <semantics>
  <mi>ğ¬</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ¬</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> In general, even if the above signal model holds, PCA loses its information-theoretic optimality as soon as the noise 

<math display="inline" id="Principal_component_analysis:121">
 <semantics>
  <mi>ğ§</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ§</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{n}
  </annotation>
 </semantics>
</math>

 becomes dependent.</p>
<h2 id="computing-pca-using-the-covariance-method">Computing PCA using the covariance method</h2>

<p>The following is a detailed description of PCA using the covariance method (see also <a href="http://www.cs.otago.ac.nz/cosc453/student_tutorials/principal_components.pdf">here</a>) as opposed to the correlation method.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> But note that it is better to use the singular value decomposition (using standard software). </p>

<p>The goal is to transform a given data set <strong>X</strong> of dimension <em>p</em> to an alternative data set <strong>Y</strong> of smaller dimension <em>L</em>. Equivalently, we are seeking to find the matrix <strong>Y</strong>, where <strong>Y</strong> is the <a href="Karhunenâ€“LoÃ¨ve_transform" title="wikilink">Karhunenâ€“LoÃ¨ve transform</a> (KLT) of matrix <strong>X</strong>:</p>

<p>

<math display="block" id="Principal_component_analysis:122">
 <semantics>
  <mrow>
   <mi>ğ˜</mi>
   <mo>=</mo>
   <mrow>
    <mi>ğ•‚</mi>
    <mi>ğ•ƒ</mi>
    <mi>ğ•‹</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>ğ—</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ˜</ci>
    <apply>
     <times></times>
     <ci>ğ•‚</ci>
     <ci>ğ•ƒ</ci>
     <ci>ğ•‹</ci>
     <set>
      <ci>ğ—</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Y}=\mathbb{KLT}\{\mathbf{X}\}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="organize-the-data-set">Organize the data set</h3>

<p><strong>Suppose</strong> you have data comprising a set of observations of <em>p</em> variables, and you want to reduce the data so that each observation can be described with only <em>L</em> variables, <em>L</em> \mathbf{x}_1 \ldots \mathbf{x}_n with each 

<math display="inline" id="Principal_component_analysis:123">
 <semantics>
  <msub>
   <mi>ğ±</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ğ±</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{i}
  </annotation>
 </semantics>
</math>

 representing a single grouped observation of the <em>p</em> variables.</p>
<ul>
<li>Write 

<math display="inline" id="Principal_component_analysis:124">
 <semantics>
  <mrow>
   <msub>
    <mi>ğ±</mi>
    <mn>1</mn>
   </msub>
   <mi mathvariant="normal">â€¦</mi>
   <msub>
    <mi>ğ±</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ±</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-â€¦</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ğ±</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{1}\ldots\mathbf{x}_{n}
  </annotation>
 </semantics>
</math>

 as row vectors, each of which has <em>p</em> columns.</li>
<li>Place the row vectors into a single matrix <strong>X</strong> of dimensions <em>n</em> Ã— <em>p</em>.</li>
</ul>
<h3 id="calculate-the-empirical-mean">Calculate the empirical mean</h3>
<ul>
<li>Find the empirical mean along each dimension <em>j</em> = 1,Â ...,Â <em>p</em>.</li>
<li>Place the calculated mean values into an empirical mean vector <strong>u</strong> of dimensions <em>p</em> Ã— 1.</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Principal_component_analysis:125">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>j</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>n</mi>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">âˆ‘</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </msubsup>
     <mrow>
      <mi>X</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>i</mi>
       <mo>,</mo>
       <mi>j</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>u</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>X</ci>
       <interval closure="closed">
        <ci>i</ci>
        <ci>j</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u[j]={1\over n}\sum_{i=1}^{n}X[i,j]
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<h3 id="calculate-the-deviations-from-the-mean">Calculate the deviations from the mean</h3>

<p>Mean subtraction is an integral part of the solution towards finding a principal component basis that minimizes the mean square error of approximating the data.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> Hence we proceed by centering the data as follows:</p>
<ul>
<li>Subtract the empirical mean vector <strong>u</strong> from each row of the data matrix <strong>X</strong>.</li>
<li>Store mean-subtracted data in the <em>n</em> Ã— <em>p</em> matrix <strong>B</strong>.</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Principal_component_analysis:126">
 <semantics>
  <mrow>
   <mi>ğ</mi>
   <mo>=</mo>
   <mrow>
    <mi>ğ—</mi>
    <mo>-</mo>
    <msup>
     <mi>ğ¡ğ®</mi>
     <mi>T</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ</ci>
    <apply>
     <minus></minus>
     <ci>ğ—</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ğ¡ğ®</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{B}=\mathbf{X}-\mathbf{h}\mathbf{u}^{T}
  </annotation>
 </semantics>
</math>


</dd>
<dd>where <strong>h</strong> is an 

<math display="inline" id="Principal_component_analysis:127">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">Ã—</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-Ã—</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   nÃ—1
  </annotation>
 </semantics>
</math>


 column vector of allÂ 1s:
</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Principal_component_analysis:128">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>i</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mrow>
    <mrow>
     <mtext>for</mtext>
     <mi>i</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">â€¦</mi>
     <mo>,</mo>
     <mi>n</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>h</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>i</ci>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <mtext>for</mtext>
      <ci>i</ci>
     </apply>
     <list>
      <cn type="integer">1</cn>
      <ci>normal-â€¦</ci>
      <ci>n</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h[i]=1\,\qquad\qquad\text{for }i=1,\ldots,n
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<h3 id="find-the-covariance-matrix">Find the covariance matrix</h3>
<ul>
<li>Find the <em>p</em> Ã— <em>p</em> empirical <a href="covariance_matrix" title="wikilink">covariance matrix</a> <strong>C</strong> from the <a href="outer_product" title="wikilink">outer product</a> of matrix <strong>B</strong> with itself:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Principal_component_analysis:129">
 <semantics>
  <mrow>
   <mi>ğ‚</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </mfrac>
     <msup>
      <mi>ğ</mi>
      <mo>*</mo>
     </msup>
    </mrow>
    <mo>â‹…</mo>
    <mi>ğ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ‚</ci>
    <apply>
     <ci>normal-â‹…</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ğ</ci>
       <times></times>
      </apply>
     </apply>
     <ci>ğ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{C}={1\over{n-1}}\mathbf{B}^{*}\cdot\mathbf{B}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>where 

<math display="inline" id="Principal_component_analysis:130">
 <semantics>
  <mo>*</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *
  </annotation>
 </semantics>
</math>

 is the <a href="conjugate_transpose" title="wikilink">conjugate transpose</a> operator. Note that if <strong>B</strong> consists entirely of real numbers, which is the case in many applications, the "conjugate transpose" is the same as the regular <a class="uri" href="transpose" title="wikilink">transpose</a>.
</dd>
</dl>
<ul>
<li>Please note that outer products apply to vectors. For tensor cases we should apply tensor products, but the covariance matrix in PCA is a sum of outer products between its sample vectors; indeed, it could be represented as B*.B. See the covariance matrix sections on the discussion page for more information.</li>
<li>The reasoning behind using 

<math display="inline" id="Principal_component_analysis:131">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mi mathvariant="normal">âˆ’</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>normal-âˆ’</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Nâˆ’1
  </annotation>
 </semantics>
</math>

 instead of <em>N</em> to calculate the covariance is <a href="Bessel's_correction" title="wikilink">Bessel's correction</a></li>
</ul>
<h3 id="find-the-eigenvectors-and-eigenvalues-of-the-covariance-matrix">Find the eigenvectors and eigenvalues of the covariance matrix</h3>
<ul>
<li>Compute the matrix <strong>V</strong> of <a href="eigenvector" title="wikilink">eigenvectors</a> which <a href="diagonalizable_matrix" title="wikilink">diagonalizes</a> the covariance matrix <strong>C</strong>:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Principal_component_analysis:132">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>ğ•</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>ğ‚ğ•</mi>
   </mrow>
   <mo>=</mo>
   <mi>ğƒ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ğ•</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>ğ‚ğ•</ci>
    </apply>
    <ci>ğƒ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{V}^{-1}\mathbf{C}\mathbf{V}=\mathbf{D}
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
</dl>
<dl>
<dd>where <strong>D</strong> is the <a href="diagonal_matrix" title="wikilink">diagonal matrix</a> of <a href="eigenvalue" title="wikilink">eigenvalues</a> of <strong>C</strong>. This step will typically involve the use of a computer-based algorithm for computing eigenvectors and eigenvalues. These algorithms are readily available as sub-components of most <a href="matrix_algebra" title="wikilink">matrix algebra</a> systems, such as <a href="R_(programming_language)" title="wikilink">R</a>, <a class="uri" href="MATLAB" title="wikilink">MATLAB</a>,<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a><a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> <a class="uri" href="Mathematica" title="wikilink">Mathematica</a>,<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> <a class="uri" href="SciPy" title="wikilink">SciPy</a>, <a href="IDL_(programming_language)" title="wikilink">IDL</a> (<a href="Interactive_Data_Language" title="wikilink">Interactive Data Language</a>), or <a href="GNU_Octave" title="wikilink">GNU Octave</a> as well as <a class="uri" href="OpenCV" title="wikilink">OpenCV</a>.
</dd>
</dl>
<ul>
<li>Matrix <strong>D</strong> will take the form of an <em>p</em> Ã— <em>p</em> diagonal matrix, where</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Principal_component_analysis:133">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>D</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>k</mi>
      <mo>,</mo>
      <mi>l</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>Î»</mi>
     <mi>k</mi>
    </msub>
   </mrow>
   <mrow>
    <mrow>
     <mtext>for</mtext>
     <mi>k</mi>
    </mrow>
    <mo>=</mo>
    <mi>l</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>D</ci>
      <interval closure="closed">
       <ci>k</ci>
       <ci>l</ci>
      </interval>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Î»</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <mtext>for</mtext>
      <ci>k</ci>
     </apply>
     <ci>l</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[k,l]=\lambda_{k}\qquad\text{for }k=l
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>is the <em>j</em>th eigenvalue of the covariance matrix <strong>C</strong>, and

<p>

<math display="block" id="Principal_component_analysis:134">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>D</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>k</mi>
       <mo>,</mo>
       <mi>l</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mrow>
     <mrow>
      <mtext>for</mtext>
      <mi>k</mi>
     </mrow>
     <mo>â‰ </mo>
     <mi>l</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>D</ci>
      <interval closure="closed">
       <ci>k</ci>
       <ci>l</ci>
      </interval>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <neq></neq>
     <apply>
      <times></times>
      <mtext>for</mtext>
      <ci>k</ci>
     </apply>
     <ci>l</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D[k,l]=0\qquad\text{for }k\neq l.
  </annotation>
 </semantics>
</math>

</p>
</dd>
</dl>
<ul>
<li>Matrix <strong>V</strong>, also of dimension <em>p</em> Ã— <em>p</em>, contains <em>p</em> column vectors, each of length <em>p</em>, which represent the <em>p</em> eigenvectors of the covariance matrix <strong>C</strong>.</li>
<li>The eigenvalues and eigenvectors are ordered and paired. The <em>j</em>th eigenvalue corresponds to the <em>j</em>th eigenvector.</li>
</ul>
<h3 id="rearrange-the-eigenvectors-and-eigenvalues">Rearrange the eigenvectors and eigenvalues</h3>
<ul>
<li>Sort the columns of the eigenvector matrix <strong>V</strong> and eigenvalue matrix <strong>D</strong> in order of <em>decreasing</em> eigenvalue.</li>
<li>Make sure to maintain the correct pairings between the columns in each matrix.</li>
</ul>
<h3 id="compute-the-cumulative-energy-content-for-each-eigenvector">Compute the cumulative energy content for each eigenvector</h3>
<ul>
<li>The eigenvalues represent the distribution of the source data's energy among each of the eigenvectors, where the eigenvectors form a <a href="basis_(linear_algebra)" title="wikilink">basis</a> for the data. The cumulative energy content <em>g</em> for the <em>j</em>th eigenvector is the sum of the energy content across all of the eigenvalues from 1 through <em>j</em>:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Principal_component_analysis:135">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>j</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">âˆ‘</mo>
       <mrow>
        <mi>k</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>j</mi>
      </msubsup>
      <mrow>
       <mi>D</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>k</mi>
        <mo>,</mo>
        <mi>k</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </mrow>
     <mi>for</mi>
    </mrow>
   </mrow>
   <mrow>
    <mi>j</mi>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">â€¦</mi>
     <mo>,</mo>
     <mi>p</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>g</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>j</ci>
      </apply>
     </apply>
     <list>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>j</ci>
       </apply>
       <apply>
        <times></times>
        <ci>D</ci>
        <interval closure="closed">
         <ci>k</ci>
         <ci>k</ci>
        </interval>
       </apply>
      </apply>
      <ci>for</ci>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <ci>j</ci>
     <list>
      <cn type="integer">1</cn>
      <ci>normal-â€¦</ci>
      <ci>p</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g[j]=\sum_{k=1}^{j}D[k,k]\qquad\mathrm{for}\qquad j=1,\dots,p
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<h3 id="select-a-subset-of-the-eigenvectors-as-basis-vectors">Select a subset of the eigenvectors as basis vectors</h3>
<ul>
<li>Save the first <em>L</em> columns of <strong>V</strong> as the <em>p</em> Ã— <em>L</em> matrix <strong>W</strong>:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Principal_component_analysis:136">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>W</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>k</mi>
      <mo>,</mo>
      <mi>l</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>V</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>k</mi>
       <mo>,</mo>
       <mi>l</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mi>for</mi>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mi>k</mi>
     <mo>=</mo>
     <mrow>
      <mn>1</mn>
      <mo>,</mo>
      <mi mathvariant="normal">â€¦</mi>
      <mo>,</mo>
      <mi>p</mi>
     </mrow>
    </mrow>
    <mrow>
     <mi>l</mi>
     <mo>=</mo>
     <mrow>
      <mn>1</mn>
      <mo>,</mo>
      <mi mathvariant="normal">â€¦</mi>
      <mo>,</mo>
      <mi>L</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>W</ci>
      <interval closure="closed">
       <ci>k</ci>
       <ci>l</ci>
      </interval>
     </apply>
     <list>
      <apply>
       <times></times>
       <ci>V</ci>
       <interval closure="closed">
        <ci>k</ci>
        <ci>l</ci>
       </interval>
      </apply>
      <ci>for</ci>
     </list>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <list>
       <cn type="integer">1</cn>
       <ci>normal-â€¦</ci>
       <ci>p</ci>
      </list>
     </apply>
     <apply>
      <eq></eq>
      <ci>l</ci>
      <list>
       <cn type="integer">1</cn>
       <ci>normal-â€¦</ci>
       <ci>L</ci>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W[k,l]=V[k,l]\qquad\mathrm{for}\qquad k=1,\dots,p\qquad l=1,\dots,L
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>where
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Principal_component_analysis:137">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>â‰¤</mo>
    <mi>L</mi>
    <mo>â‰¤</mo>
    <mi>p</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>L</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq L\leq p.
  </annotation>
 </semantics>
</math>



</dd>
</dl>
</dd>
</dl>
<ul>
<li>Use the vector <strong>g</strong> as a guide in choosing an appropriate value for <em>L</em>. The goal is to choose a value of <em>L</em> as small as possible while achieving a reasonably high value of <em>g</em> on a percentage basis. For example, you may want to choose <em>L</em> so that the cumulative energy <em>g</em> is above a certain threshold, like 90 percent. In this case, choose the smallest value of <em>L</em> such that</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Principal_component_analysis:138">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>L</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>p</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>â‰¥</mo>
   <mpadded width="+1.7pt">
    <mn>0.9</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>g</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>L</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>g</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
    <cn type="float">0.9</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{g[L]}{g[p]}\geq 0.9\,
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<h3 id="convert-the-source-data-to-z-scores-optional">Convert the source data to z-scores (optional)</h3>
<ul>
<li>Create an <em>p</em> Ã— 1 empirical standard deviation vector <strong>s</strong> from the square root of each element along the main diagonal of the diagonalized covariance matrix <strong>C</strong>. (Note, that scaling operations do not commute with the KLT thus we must scale by the variances of the already-decorrelated vector, which is the diagonal of <strong>C</strong>) :</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Principal_component_analysis:139">
 <semantics>
  <mrow>
   <mrow>
    <mi>ğ¬</mi>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>s</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>j</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <msqrt>
      <mrow>
       <mi>C</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>j</mi>
        <mo>,</mo>
        <mi>j</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </msqrt>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mtext>for</mtext>
     <mi>j</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">â€¦</mi>
     <mo>,</mo>
     <mi>p</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <ci>ğ¬</ci>
      <set>
       <apply>
        <times></times>
        <ci>s</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>j</ci>
        </apply>
       </apply>
      </set>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <set>
       <apply>
        <root></root>
        <apply>
         <times></times>
         <ci>C</ci>
         <interval closure="closed">
          <ci>j</ci>
          <ci>j</ci>
         </interval>
        </apply>
       </apply>
      </set>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <mtext>for</mtext>
      <ci>j</ci>
     </apply>
     <list>
      <cn type="integer">1</cn>
      <ci>normal-â€¦</ci>
      <ci>p</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}=\{s[j]\}=\{\sqrt{C[j,j]}\}\qquad\text{for }j=1,\ldots,p
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<ul>
<li>Calculate the <em>n</em> Ã— <em>p</em> <a href="standard_score" title="wikilink">z-score</a> matrix:</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Principal_component_analysis:140">
 <semantics>
  <mrow>
   <mi>ğ™</mi>
   <mo>=</mo>
   <mfrac>
    <mi>ğ</mi>
    <mrow>
     <mi>ğ¡</mi>
     <mo>â‹…</mo>
     <msup>
      <mi>ğ¬</mi>
      <mi>T</mi>
     </msup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ™</ci>
    <apply>
     <divide></divide>
     <ci>ğ</ci>
     <apply>
      <ci>normal-â‹…</ci>
      <ci>ğ¡</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ğ¬</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Z}={\mathbf{B}\over\mathbf{h}\cdot\mathbf{s}^{T}}
  </annotation>
 </semantics>
</math>

 (divide element-by-element)
</dd>
</dl>
</dd>
</dl>
<ul>
<li>Note: While this step is useful for various applications as it normalizes the data set with respect to its variance, it is not integral part of PCA/KLT</li>
</ul>
<h3 id="project-the-z-scores-of-the-data-onto-the-new-basis">Project the z-scores of the data onto the new basis</h3>
<ul>
<li>The projected vectors are the columns of the matrix</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Principal_component_analysis:141">
 <semantics>
  <mrow>
   <mrow>
    <mi>ğ“</mi>
    <mo>=</mo>
    <mrow>
     <mi>ğ™</mi>
     <mo>â‹…</mo>
     <mi>ğ–</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>ğ•‚</mi>
     <mi>ğ•ƒ</mi>
     <mi>ğ•‹</mi>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>ğ—</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>ğ“</ci>
     <apply>
      <ci>normal-â‹…</ci>
      <ci>ğ™</ci>
      <ci>ğ–</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>ğ•‚</ci>
      <ci>ğ•ƒ</ci>
      <ci>ğ•‹</ci>
      <set>
       <ci>ğ—</ci>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{T}=\mathbf{Z}\cdot\mathbf{W}=\mathbb{KLT}\{\mathbf{X}\}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<ul>
<li>The rows of matrix <strong>T</strong> represent the <a href="Karhunenâ€“Loeve_transform" title="wikilink">Karhunenâ€“Loeve transforms</a> (KLT) of the data vectors in the rows of matrixÂ <strong>X</strong>.</li>
</ul>
<h2 id="derivation-of-pca-using-the-covariance-method">Derivation of PCA using the covariance method</h2>

<p>Let <strong>X</strong> be a <em>d</em>-dimensional random vector expressed as column vector. Without loss of generality, assume <strong>X</strong> has zero mean.</p>

<p>We want to find 

<math display="inline" id="Principal_component_analysis:142">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mo>âˆ—</mo>
   <mo rspace="4.2pt" stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-âˆ—</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\ast)\,
  </annotation>
 </semantics>
</math>


 a 

<math display="inline" id="Principal_component_analysis:143">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi mathvariant="normal">Ã—</mi>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>normal-Ã—</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   dÃ—d
  </annotation>
 </semantics>
</math>

 <a href="orthonormal_basis" title="wikilink">orthonormal transformation matrix</a> <strong>P</strong> so that <strong>PX</strong> has a diagonal covariant matrix (<em>i.e.</em> <strong>PX</strong> is a random vector with all its distinct components pairwise uncorrelated).</p>

<p>A quick computation assuming 

<math display="inline" id="Principal_component_analysis:144">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 were unitary yields:</p>

<p>

<math display="inline" id="Principal_component_analysis:145">
 <semantics>
  <mrow>
   <mo>var</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>P</mi>
     <mi>X</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>var</ci>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\operatorname{var}(PX)
  </annotation>
 </semantics>
</math>


</p>

<p>Hence 

<math display="inline" id="Principal_component_analysis:146">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mo>âˆ—</mo>
   <mo rspace="4.2pt" stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-âˆ—</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\ast)\,
  </annotation>
 </semantics>
</math>


 holds if and only if 

<math display="inline" id="Principal_component_analysis:147">
 <semantics>
  <mrow>
   <mo>var</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>var</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{var}(X)
  </annotation>
 </semantics>
</math>

 were diagonalisable by 

<math display="inline" id="Principal_component_analysis:148">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

.</p>

<p>This is very constructive, as var(<strong>X</strong>) is guaranteed to be a non-negative definite matrix and thus is guaranteed to be diagonalisable by some unitary matrix.</p>
<h3 id="iterative-computation">Iterative computation</h3>

<p>In practical implementations especially with high dimensional data (large <em>p</em>), the covariance method is rarely used because it is not efficient. One way to compute the first principal component efficiently<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> is shown in the following pseudo-code, for a data matrix <strong>X</strong> with zero mean, without ever computing its covariance matrix.</p>

<p>

<math display="inline" id="Principal_component_analysis:149">
 <semantics>
  <mrow>
   <mi>ğ«</mi>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ«</ci>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r}=
  </annotation>
 </semantics>
</math>

<code>Â aÂ randomÂ vectorÂ ofÂ lengthÂ </code><em><code>p</code></em><br/>
<code>doÂ </code><em><code>c</code></em><code>Â times:</code><br/>
<code>Â Â Â Â Â Â </code>

<math display="inline" id="Principal_component_analysis:150">
 <semantics>
  <mrow>
   <mi>ğ¬</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ¬</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}=0
  </annotation>
 </semantics>
</math>

<code>Â (aÂ vectorÂ ofÂ lengthÂ </code><em><code>p</code></em><code>)</code><br/>
<code>Â Â Â Â Â Â forÂ eachÂ rowÂ </code>

<math display="inline" id="Principal_component_analysis:151">
 <semantics>
  <mrow>
   <mi>ğ±</mi>
   <mo>âˆˆ</mo>
   <mi>ğ—</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ğ±</ci>
    <ci>ğ—</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}\in\mathbf{X}
  </annotation>
 </semantics>
</math>


</p>

<p>

<math display="inline" id="Principal_component_analysis:152">
 <semantics>
  <mrow>
   <mi>ğ¬</mi>
   <mo>=</mo>
   <mrow>
    <mi>ğ¬</mi>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>ğ±</mi>
       <mo>â‹…</mo>
       <mi>ğ«</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>ğ±</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ¬</ci>
    <apply>
     <plus></plus>
     <ci>ğ¬</ci>
     <apply>
      <times></times>
      <apply>
       <ci>normal-â‹…</ci>
       <ci>ğ±</ci>
       <ci>ğ«</ci>
      </apply>
      <ci>ğ±</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{s}=\mathbf{s}+(\mathbf{x}\cdot\mathbf{r})\mathbf{x}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Principal_component_analysis:153">
 <semantics>
  <mrow>
   <mi>ğ«</mi>
   <mo>=</mo>
   <mfrac>
    <mi>ğ¬</mi>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>ğ¬</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ«</ci>
    <apply>
     <divide></divide>
     <ci>ğ¬</ci>
     <apply>
      <abs></abs>
      <ci>ğ¬</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r}=\frac{\mathbf{s}}{|\mathbf{s}|}
  </annotation>
 </semantics>
</math>

</p>

<p><code>returnÂ </code>

<math display="inline" id="Principal_component_analysis:154">
 <semantics>
  <mi>ğ«</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ«</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r}
  </annotation>
 </semantics>
</math>

</p>

<p>This algorithm is simply an efficient way of calculating <strong>X<sup>T</sup>X r</strong>, normalizing, and placing the result back in <strong>r</strong> (<a href="power_iteration" title="wikilink">power iteration</a>). It avoids the <em>np</em><sup>2</sup> operations of calculating the covariance matrix. <strong>r</strong> will typically get close to the first principal component of <strong>X</strong> within a small number of iterations, <em>c</em>. (The magnitude of <strong>s</strong> will be larger after each iteration. Convergence can be detected when it increases by an amount too small for the precision of the machine.)</p>

<p>Subsequent principal components can be computed by subtracting component <strong>r</strong> from <strong>X</strong> (see <a class="uri" href="Gramâ€“Schmidt" title="wikilink">Gramâ€“Schmidt</a>) and then repeating this algorithm to find the next principal component. However this simple approach is not numerically stable if more than a small number of principal components are required, because imprecisions in the calculations will additively affect the estimates of subsequent principal components. More advanced methods build on this basic idea, as with the closely related <a href="Lanczos_algorithm" title="wikilink">Lanczos algorithm</a>.</p>

<p>One way to compute the eigenvalue that corresponds with each principal component is to measure the difference in mean-squared-distance between the rows and the centroid, before and after subtracting out the principal component. The eigenvalue that corresponds with the component that was removed is equal to this difference.</p>
<h3 id="the-nipals-method">The NIPALS method</h3>

<p>For very-high-dimensional datasets, such as those generated in the *omics sciences (e.g., <a class="uri" href="genomics" title="wikilink">genomics</a>, <a class="uri" href="metabolomics" title="wikilink">metabolomics</a>) it is usually only necessary to compute the first few PCs. The <a href="non-linear_iterative_partial_least_squares" title="wikilink">non-linear iterative partial least squares</a> (NIPALS) algorithm calculates <strong>t<sub>1</sub></strong> and <strong>w<sub>1</sub></strong><sup>T</sup> from <strong>X</strong>. The outer product, <strong>t<sub>1</sub>w<sub>1</sub></strong><sup>T</sup> can then be subtracted from <strong>X</strong> leaving the residual matrix <strong>E<sub>1</sub></strong>. This can be then used to calculate subsequent PCs.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> This results in a dramatic reduction in computational time since calculation of the covariance matrix is avoided.</p>

<p>However, for large data matrices, or matrices that have a high degree of column collinearity, NIPALS suffers from loss of orthogonality due to machine precision limitations accumulated in each iteration step.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> A Gramâ€“Schmidt (GS) re-orthogonalization algorithm is applied to both the scores and the loadings at each iteration step to eliminate this loss of orthogonality.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></p>
<h3 id="onlinesequential-estimation">Online/sequential estimation</h3>

<p>In an "online" or "streaming" situation with data arriving piece by piece rather than being stored in a single batch, it is useful to make an estimate of the PCA projection that can be updated sequentially. This can be done efficiently, but requires different algorithms.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>
<h2 id="pca-and-qualitative-variables">PCA and qualitative variables</h2>

<p>In PCA, it is common that we want to introduce qualitative variables as supplementary elements. For example, many quantitative variables have been measured on plants. For these plants, some qualitative variables are available as, for example, the species to which the plant belongs. These data were subjected to PCA for quantitative variables. When analyzing the results, it is natural to connect the principal components to the qualitative variable <em>species</em>. For this, the following results are produced.</p>
<ul>
<li>Identification, on the factorial planes, of the different species e.g. using different colors.</li>
<li>Representation, on the factorial planes, of the centers of gravity of plants belonging to the same species.</li>
<li>For each center of gravity and each axis, p-value to judge the significance of the difference between the center of gravity and origin.</li>
</ul>

<p>These results are what is called <em>introducing a qualitative variable as supplementary element</em>. This procedure is detailed in and Husson, LÃª &amp; PagÃ¨s 2009 and PagÃ¨s 2013. Few software offer this option in an "automatic" way. This is the case of <a href="http://www.coheris.com/produits/analytics/logiciel-data-mining/">SPAD</a> that historically, following the work of <a href="Ludovic_Lebart" title="wikilink">Ludovic Lebart</a>, was the first to propose this option, and the R package <a href="http://factominer.free.fr/">FactoMineR</a>.</p>
<h2 id="applications">Applications</h2>
<h3 id="neuroscience">Neuroscience</h3>

<p>A variant of principal components analysis is used in <a class="uri" href="neuroscience" title="wikilink">neuroscience</a> to identify the specific properties of a stimulus that increase a <a class="uri" href="neuron" title="wikilink">neuron</a>'s probability of generating an <a href="action_potential" title="wikilink">action potential</a>.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> This technique is known as <a href="Spike-triggered_covariance" title="wikilink">spike-triggered covariance analysis</a>. In a typical application an experimenter presents a <a href="white_noise" title="wikilink">white noise</a> process as a stimulus (usually either as a sensory input to a test subject, or as a <a href="Electric_current" title="wikilink">current</a> injected directly into the neuron) and records a train of action potentials, or spikes, produced by the neuron as a result. Presumably, certain features of the stimulus make the neuron more likely to spike. In order to extract these features, the experimenter calculates the <a href="covariance_matrix" title="wikilink">covariance matrix</a> of the <em>spike-triggered ensemble</em>, the set of all stimuli (defined and discretized over a finite time window, typically on the order of 100 ms) that immediately preceded a spike. The <a href="Eigenvectors_and_eigenvalues" title="wikilink">eigenvectors</a> of the difference between the spike-triggered covariance matrix and the covariance matrix of the <em>prior stimulus ensemble</em> (the set of all stimuli, defined over the same length time window) then indicate the directions in the <a href="Vector_space" title="wikilink">space</a> of stimuli along which the variance of the spike-triggered ensemble differed the most from that of the prior stimulus ensemble. Specifically, the eigenvectors with the largest positive eigenvalues correspond to the directions along which the variance of the spike-triggered ensemble showed the largest positive change compared to the variance of the prior. Since these were the directions in which varying the stimulus led to a spike, they are often good approximations of the sought after relevant stimulus features.</p>

<p>In neuroscience, PCA is also used to discern the identity of a neuron from the shape of its action potential. <a href="Spike_sorting" title="wikilink">Spike sorting</a> is an important procedure because <a href="Electrophysiology#Extracellular_recording" title="wikilink">extracellular</a> recording techniques often pick up signals from more than one neuron. In spike sorting, one first uses PCA to reduce the dimensionality of the space of action potential waveforms, and then performs <a href="Cluster_analysis" title="wikilink">clustering analysis</a> to associate specific action potentials with individual neurons.</p>
<h2 id="relation-between-pca-and-k-means-clustering">Relation between PCA and <em>K</em>-means clustering</h2>

<p>It was asserted in <a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a><a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> that the relaxed solution of <mtpl></mtpl>-means clustering, specified by the cluster indicators, is given by the PCA (principal component analysis) principal components, and the PCA subspace spanned by the principal directions is identical to the cluster centroid subspace. However, that PCA is a useful relaxation of k-means clustering was not a new result (see, for example,<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a>), and it is straightforward to uncover counterexamples to the statement that the cluster centroid subspace is spanned by the principal directions.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a></p>
<h2 id="relation-between-pca-and-factor-analysis">Relation between PCA and factor analysis<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a></h2>

<p>Principal component analysis creates variables that are linear combinations of the original variables. The new variables have the property that the variables are all orthogonal. The principal components can be used to find clusters in a set of data. PCA is a variance-focused approach seeking to reproduce the total variable variance, in which components reflect both common and unique variance of the variable. PCA is generally preferred for purposes of data reduction (i.e., translating variable space into optimal factor space) but not when the goal is to detect the latent construct or factors.</p>

<p><a href="Factor_analysis" title="wikilink">Factor analysis</a> is similar to principal component analysis, in that factor analysis also involves linear combinations of variables. Different from PCA, factor analysis is a correlation-focused approach seeking to reproduce the inter-correlations among variables, in which the factors â€œrepresent the common variance of variables, excluding unique variance<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a>" . In terms of the correlation matrix, this corresponds with focusing on explaining the off-diagonal terms (i.e. shared co-variance), while PCA focuses on explaining the terms that sit on the diagonal. However, as a side result, when trying to reproduce the on-diagonal terms, PCA also tends to fit relatively well the off-diagonal correlations<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a>. Results given by PCA and factor analysis are very similar in most situations, but this is not always the case, and there are some problems where the results are significantly different. Factor analysis is generally used when the research purpose is detecting data structure (i.e., latent constructs or factors) or causal modeling.</p>
<h2 id="correspondence-analysis">Correspondence analysis</h2>

<p><strong><a href="Correspondence_analysis" title="wikilink">Correspondence analysis</a></strong> (CA) was developed by <a href="Jean-Paul_BenzÃ©cri" title="wikilink">Jean-Paul BenzÃ©cri</a><a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> and is conceptually similar to PCA, but scales the data (which should be non-negative) so that rows and columns are treated equivalently. It is traditionally applied to <a href="contingency_tables" title="wikilink">contingency tables</a>. CA decomposes the <a href="chi-squared_statistic" title="wikilink">chi-squared statistic</a> associated to this table into orthogonal factors.<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a> Because CA is a descriptive technique, it can be applied to tables for which the chi-squared statistic is appropriate or not. Several variants of CA are available including <a href="detrended_correspondence_analysis" title="wikilink">detrended correspondence analysis</a> and <a href="canonical_correspondence_analysis" title="wikilink">canonical correspondence analysis</a>. One special extension is <a href="multiple_correspondence_analysis" title="wikilink">multiple correspondence analysis</a>, which may be seen as the counterpart of principal component analysis for categorical data.<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a></p>
<h2 id="generalizations">Generalizations</h2>
<h3 id="nonlinear-generalizations">Nonlinear generalizations</h3>
<figure><b>(Figure)</b>
<figcaption> Linear PCA versus nonlinear Principal Manifolds<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> for <a href="Scientific_visualization" title="wikilink">visualization</a> of <a href="breast_cancer" title="wikilink">breast cancer</a> <a class="uri" href="microarray" title="wikilink">microarray</a> data: a) Configuration of nodes and 2D Principal Surface in the 3D PCA linear manifold. The dataset is curved and cannot be mapped adequately on a 2D principal plane; b) The distribution in the internal 2D non-linear principal surface coordinates (ELMap2D) together with an estimation of the density of points; c) The same as b), but for the linear 2D PCA manifold (PCA2D). The "basal" breast cancer subtype is visualized more adequately with ELMap2D and some features of the distribution become better resolved in comparison to PCA2D. Principal manifolds are produced by the <a href="elastic_map" title="wikilink">elastic maps</a> algorithm. Data are available for public competition.<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a> Software is available for free non-commercial use.<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a></figcaption>
</figure>

<p>Most of the modern methods for <a href="nonlinear_dimensionality_reduction" title="wikilink">nonlinear dimensionality reduction</a> find their theoretical and algorithmic roots in PCA or K-means. Pearson's original idea was to take a straight line (or plane) which will be "the best fit" to a set of data points. <strong>Principal <a href="curve" title="wikilink">curves</a> and <a href="manifold" title="wikilink">manifolds</a></strong><a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a> give the natural geometric framework for PCA generalization and extend the geometric interpretation of PCA by explicitly constructing an embedded manifold for data <a class="uri" href="approximation" title="wikilink">approximation</a>, and by encoding using standard geometric <a href="Projection_(mathematics)" title="wikilink">projection</a> onto the manifold, as it is illustrated by Fig. See also the <a href="elastic_map" title="wikilink">elastic map</a> algorithm and <a href="principal_geodesic_analysis" title="wikilink">principal geodesic analysis</a>. Another popular generalization is <a href="kernel_PCA" title="wikilink">kernel PCA</a>, which corresponds to PCA performed in a reproducing kernel Hilbert space associated with a positive definite kernel.</p>
<h3 id="multilinear-generalizations">Multilinear generalizations</h3>

<p>In <a href="multilinear_subspace_learning" title="wikilink">multilinear subspace learning</a>,<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a> PCA is generalized to <a href="multilinear_principal_component_analysis" title="wikilink">multilinear PCA</a> (MPCA) that extracts features directly from tensor representations. MPCA is solved by performing PCA in each mode of the tensor iteratively. MPCA has been applied to face recognition, gait recognition, etc. MPCA is further extended to uncorrelated MPCA, non-negative MPCA and robust MPCA.</p>
<h3 id="higher-order">Higher order</h3>

<p><em>N</em>-way principal component analysis may be performed with models such as <a href="Tucker_decomposition" title="wikilink">Tucker decomposition</a>, <a class="uri" href="PARAFAC" title="wikilink">PARAFAC</a>, multiple factor analysis, co-inertia analysis, STATIS, and DISTATIS.</p>
<h3 id="robustness-weighted-pca">Robustness â€“ weighted PCA</h3>

<p>While PCA finds the mathematically optimal method (as in minimizing the squared error), it is sensitive to <a href="outlier" title="wikilink">outliers</a> in the data that produce large errors PCA tries to avoid. It therefore is common practice to remove outliers before computing PCA. However, in some contexts, outliers can be difficult to identify. For example in <a href="data_mining" title="wikilink">data mining</a> algorithms like <a href="correlation_clustering" title="wikilink">correlation clustering</a>, the assignment of points to clusters and outliers is not known beforehand. A recently proposed generalization of PCA<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a> based on a <strong>weighted PCA</strong> increases robustness by assigning different weights to data objects based on their estimated relevancy.</p>
<h3 id="robust-pca-via-decomposition-in-low-rank-and-sparse-matrices">Robust PCA via Decomposition in Low Rank and Sparse Matrices</h3>

<p><a href="Robust_principal_component_analysis" title="wikilink">Robust principal component analysis</a> (RPCA) is a modification of the widely used statistical procedure Principal component analysis (PCA) which works well with respect to grossly corrupted observations.</p>
<h3 id="sparse-pca">Sparse PCA</h3>

<p>A particular disadvantage of PCA is that the principal components are usually linear combinations of all input variables. <a href="Sparse_PCA" title="wikilink">Sparse PCA</a> overcomes this disadvantage by finding linear combinations that contain just a few input variables.</p>
<h2 id="softwaresource-code">Software/source code</h2>
<ul>
<li>An Open <a href="https://code.msdn.microsoft.com/Machine-Learnin-in-2f63c0ac/">Source Code</a> and Tutorial in MATLAB and C++.</li>
<li><a href="http://factominer.free.fr/">FactoMineR</a> â€“ A library of functions for exploratory data analysis.</li>
<li><a class="uri" href="XLSTAT" title="wikilink">XLSTAT</a> - Principal Compent Analysis is a part of XLSTAT core module<a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a></li>
<li><a class="uri" href="Mathematica" title="wikilink">Mathematica</a> â€“ Implements principal component analysis with the PrincipalComponents command<a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a> using both covariance and correlation methods.</li>
<li><a class="uri" href="DataMelt" title="wikilink">DataMelt</a> - A Java free program that implements several classes to build PCA analysis and to calculate eccentricity of random distributions.</li>
<li><a href="NAG_Numerical_Library" title="wikilink">NAG Library</a> â€“ Principal components analysis is implemented via the <code>g03aa</code> routine (available in both the Fortran<a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a> and the C<a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a> versions of the Library).</li>
<li><a class="uri" href="SIMCA" title="wikilink">SIMCA</a> â€“ Commercial software package available to perform PCA analysis.<a class="footnoteRef" href="#fn51" id="fnref51"><sup>51</sup></a></li>
<li><a class="uri" href="CORICO" title="wikilink">CORICO</a> - Commercial software, offers principal components analysis coupled with <a href=":fr:Iconographie_des_correlations" title="wikilink">Iconographie des correlations</a>.</li>
<li><a class="uri" href="MATLAB" title="wikilink">MATLAB</a> Statistics Toolbox â€“ The functions <code>princomp</code> and <code>pca</code> (R2012b) give the principal components, while the function <code>pcares</code> gives the residuals and reconstructed matrix for a low-rank PCA approximation. An example MATLAB implementation of PCA is available.<a class="footnoteRef" href="#fn52" id="fnref52"><sup>52</sup></a></li>
<li><a href="Oracle_Database" title="wikilink">Oracle Database</a> 12c â€“ Implemented via <code>DBMS_DATA_MINING.SVDS_SCORING_MODE</code> by specifying setting value <code>SVDS_SCORING_PCA</code> <a class="footnoteRef" href="#fn53" id="fnref53"><sup>53</sup></a></li>
<li><a href="GNU_Octave" title="wikilink">GNU Octave</a> â€“ Free software computational environment mostly compatible with MATLAB, the function <code>princomp</code><a class="footnoteRef" href="#fn54" id="fnref54"><sup>54</sup></a> gives the principal component.</li>
<li><a href="R_(programming_language)" title="wikilink">R</a> â€“ <a href="free_software" title="wikilink">Free</a> statistical package, the functions <code>princomp</code><a class="footnoteRef" href="#fn55" id="fnref55"><sup>55</sup></a> and <code>prcomp</code><a class="footnoteRef" href="#fn56" id="fnref56"><sup>56</sup></a> can be used for principal component analysis; <code>prcomp</code> uses <a href="singular_value_decomposition" title="wikilink">singular value decomposition</a> which generally gives better numerical accuracy. Some packages that implement PCA in R, include, but are not limited to: <code>ade4</code>, <code>vegan</code>, <code>ExPosition</code>, and <code>FactoMineR</code><a class="footnoteRef" href="#fn57" id="fnref57"><sup>57</sup></a></li>
<li>SAS, PROC FACTOR â€“ Offers principal components analysis.<a class="footnoteRef" href="#fn58" id="fnref58"><sup>58</sup></a></li>
<li><a href="MLPACK_(C++_library)" title="wikilink">MLPACK</a> â€“ Provides an implementation of principal component analysis in <a class="uri" href="C++" title="wikilink">C++</a>.</li>
<li>XLMiner â€“ The principal components tab can be used for principal component analysis.</li>
<li>Stata â€“ The <code>pca</code> command provides principal components analysis.<a class="footnoteRef" href="#fn59" id="fnref59"><sup>59</sup></a></li>
<li>Cornell Spectrum Imager â€“ Open-source toolset built on ImageJ, enables PCA analysis for 3D datacubes.<a class="footnoteRef" href="#fn60" id="fnref60"><sup>60</sup></a></li>
<li>imDEV â€“ Free Excel addon to calculate principal components using R package<a class="footnoteRef" href="#fn61" id="fnref61"><sup>61</sup></a><a class="footnoteRef" href="#fn62" id="fnref62"><sup>62</sup></a></li>
<li>ViSta: The Visual Statistics System â€“ Free software that provides principal components analysis, simple and multiple correspondence analysis.<a class="footnoteRef" href="#fn63" id="fnref63"><sup>63</sup></a></li>
<li>Spectramap â€“ Software to create a <a class="uri" href="biplot" title="wikilink">biplot</a> using principal components analysis, correspondence analysis or spectral map analysis.<a class="footnoteRef" href="#fn64" id="fnref64"><sup>64</sup></a></li>
<li>FinMath â€“ <a href=".NET_Framework" title="wikilink">.NET</a> numerical library containing an implementation of PCA.<a class="footnoteRef" href="#fn65" id="fnref65"><sup>65</sup></a></li>
<li><a href="Unscrambler_X" title="wikilink">Unscrambler X</a> â€“ Multivariate analysis software enabling Principal Component Analysis (PCA) with PCA Projection.{<a class="footnoteRef" href="#fn66" id="fnref66"><sup>66</sup></a>}</li>
<li>OpenCV<a class="footnoteRef" href="#fn67" id="fnref67"><sup>67</sup></a></li>
<li><a class="uri" href="NMath" title="wikilink">NMath</a> â€“ Proprietary numerical library containing PCA for the <a href=".NET_Framework" title="wikilink">.NET Framework</a>.</li>
<li><a href="IDL_(programming_language)" title="wikilink">IDL</a> â€“ The principal components can be calculated using the function <code>pcomp</code>.<a class="footnoteRef" href="#fn68" id="fnref68"><sup>68</sup></a></li>
<li><a href="Weka_(machine_learning)" title="wikilink">Weka</a> â€“ Computes principal components.<a class="footnoteRef" href="#fn69" id="fnref69"><sup>69</sup></a></li>
<li><a class="uri" href="Qlucore" title="wikilink">Qlucore</a> â€“ Commercial software for analyzing multivariate data with instant response using PCA<a class="footnoteRef" href="#fn70" id="fnref70"><sup>70</sup></a></li>
<li><a href="Orange_(software)" title="wikilink">Orange (software)</a> â€“ Supports PCA through its Linear Projection widget.</li>
<li>EIGENSOFT â€“ Provides a version of PCA adapted for <a href="population_genetics" title="wikilink">population genetics</a> analysis.<a class="footnoteRef" href="#fn71" id="fnref71"><sup>71</sup></a></li>
<li>Partek Genomics Suite â€“ Statistical software able to perform PCA.<a class="footnoteRef" href="#fn72" id="fnref72"><sup>72</sup></a></li>
<li><a href="https://sourceforge.net/projects/libpca/">libpca C++ library</a> â€“ Offers PCA and corresponding transformations.</li>
<li><a href="Origin_(software)" title="wikilink">Origin</a> â€“ Contains PCA in its Pro version.</li>
<li><a class="uri" href="Scikit-learn" title="wikilink">Scikit-learn</a> â€“ Python library for machine learning which contains PCA, Probabilistic PCA, Kernel PCA, Sparse PCA and other techniques in the decomposition module.<a class="footnoteRef" href="#fn73" id="fnref73"><sup>73</sup></a></li>
<li>Knime<a class="footnoteRef" href="#fn74" id="fnref74"><sup>74</sup></a>- A java based nodal arrenging software for Analysis, in this the nodes called PCA, PCA compute, PCA Apply, PCA inverse make it easily.</li>
<li><a href="Julia_language" title="wikilink">Julia</a> â€“ Supports PCA with the <code>pca</code> function in the MultivariateStats package <a class="footnoteRef" href="#fn75" id="fnref75"><sup>75</sup></a></li>
<li><a href="https://github.com/Netflix/Surus">Netflix Surus</a> â€“ Provides a <a class="uri" href="Java" title="wikilink">Java</a> implementation of <a href="Robust_principal_component_analysis" title="wikilink">robust PCA</a> with wrappers for <a href="Pig_(programming_tool)" title="wikilink">Pig</a>.</li>
<li><a href="http://www.insightomics.com/principal-component-analysis">Insightomics</a> - Run principal component analysis directly on your browser.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Correspondence_analysis" title="wikilink">Correspondence analysis</a> (for contingency tables)</li>
<li><a href="Multiple_correspondence_analysis" title="wikilink">Multiple correspondence analysis</a> (for qualitative variables)</li>
<li><a href="Factor_analysis_of_mixed_data" title="wikilink">Factor analysis of mixed data</a> (for quantitative <strong>and</strong> qualitative variables)</li>
<li><a href="Canonical_correlation" title="wikilink">Canonical correlation</a></li>
<li><a href="CUR_matrix_approximation" title="wikilink">CUR matrix approximation</a> (can replace of low-rank SVD approximation)</li>
<li><a href="Detrended_correspondence_analysis" title="wikilink">Detrended correspondence analysis</a></li>
<li><a href="Dynamic_mode_decomposition" title="wikilink">Dynamic mode decomposition</a></li>
<li><a class="uri" href="Eigenface" title="wikilink">Eigenface</a></li>
<li><a href="v:Exploratory_factor_analysis" title="wikilink">Exploratory factor analysis</a> (Wikiversity)</li>
<li><a href="Factorial_code" title="wikilink">Factorial code</a></li>
<li><a href="Functional_principal_component_analysis" title="wikilink">Functional principal component analysis</a></li>
<li><a href="Geometric_data_analysis" title="wikilink">Geometric data analysis</a></li>
<li><a href="Independent_component_analysis" title="wikilink">Independent component analysis</a></li>
<li><a href="Kernel_PCA" title="wikilink">Kernel PCA</a></li>
<li><a href="Low-rank_approximation" title="wikilink">Low-rank approximation</a></li>
<li><a href="Matrix_decomposition" title="wikilink">Matrix decomposition</a></li>
<li><a href="Non-negative_matrix_factorization" title="wikilink">Non-negative matrix factorization</a></li>
<li><a href="Nonlinear_dimensionality_reduction" title="wikilink">Nonlinear dimensionality reduction</a></li>
<li><a href="Oja's_rule" title="wikilink">Oja's rule</a></li>
<li><a href="Point_distribution_model" title="wikilink">Point distribution model</a> (PCA applied to morphometry and computer vision)</li>
<li><a href="b:Statistics/Multivariate_Data_Analysis/Principal_Component_Analysis" title="wikilink">Principal component analysis</a> (Wikibooks)</li>
<li><a href="Principal_component_regression" title="wikilink">Principal component regression</a></li>
<li><a href="Singular_spectrum_analysis" title="wikilink">Singular spectrum analysis</a></li>
<li><a href="Singular_value_decomposition" title="wikilink">Singular value decomposition</a></li>
<li><a href="Sparse_PCA" title="wikilink">Sparse PCA</a></li>
<li><a href="Transform_coding" title="wikilink">Transform coding</a></li>
<li><a href="Weighted_least_squares" title="wikilink">Weighted least squares</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>Jackson, J.E. (1991). <em>A User's Guide to Principal Components</em> (Wiley).</li>
<li></li>
<li>Jolliffe, I.T. (2002). <em>Principal Component Analysis,</em> second edition (Springer).</li>
<li>Husson FranÃ§ois, LÃª SÃ©bastien &amp; PagÃ¨s JÃ©rÃ´me (2009). <em>Exploratory Multivariate Analysis by Example Using R</em>. Chapman &amp; Hall/CRC The R Series, London. 224p. |isbn=978-2-7535-0938-2</li>
<li>PagÃ¨s JÃ©rÃ´me (2014). <em>Multiple Factor Analysis by Example Using R</em>. Chapman &amp; Hall/CRC The R Series London 272 p</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li></li>
<li><a href="http://arxiv.org/abs/1404.1100">A Tutorial on Principal Component Analysis</a></li>
<li>

<p>(a video of less than 100 seconds.)</p></li>
<li>See also the list of <a href="#Software/source_code" title="wikilink">Software implementations</a></li>
</ul>

<p>"</p>

<p><a href="Category:Multivariate_statistics" title="wikilink">Category:Multivariate statistics</a> <a href="Category:Matrix_decompositions" title="wikilink">Category:Matrix decompositions</a> <a href="Category:Data_analysis" title="wikilink">Category:Data analysis</a> <a href="Category:Dimension_reduction" title="wikilink">Category:Dimension reduction</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Jolliffe I.T. <a href="http://www.springer.com/west/home/new+%26+forthcoming+titles+%28default%29?SGWID=4-40356-22-2285433-0">Principal Component Analysis</a>, Series: <a href="http://www.springer.com/west/home/statistics/statistical+theory+and+methods?SGWID=4-10129-69-173621571-0">Springer Series in Statistics</a>, 2nd ed., Springer, NY, 2002, XXIX, 487 p. 28 illus. ISBN 978-0-387-95442-4<a href="#fnref1">â†©</a></li>
<li id="fn2"><a href="#fnref2">â†©</a></li>
<li id="fn3">Hotelling, H. (1933). Analysis of a complex of statistical variables into principal components. <em><a href="Journal_of_Educational_Psychology" title="wikilink">Journal of Educational Psychology</a></em>, <strong>24</strong>, 417â€“441, and 498â€“520.<br/>
Hotelling, H. (1936). Relations between two sets of variates. <em><a class="uri" href="Biometrika" title="wikilink">Biometrika</a></em>, <strong>27</strong>, 321â€“77<a href="#fnref3">â†©</a></li>
<li id="fn4"><a href="#fnref4">â†©</a></li>
<li id="fn5">Shaw P.J.A. (2003) <em>Multivariate statistics for the Environmental Sciences</em>, Hodder-Arnold. ISBN 0-340-80763-6. <a href="#fnref5">â†©</a></li>
<li id="fn6"><a href="#fnref6">â†©</a></li>
<li id="fn7"><a href="#fnref7">â†©</a></li>
<li id="fn8"></li>
<li id="fn9"><a href="#fnref9">â†©</a></li>
<li id="fn10">A. A. Miranda, Y. A. Le Borgne, and G. Bontempi. <a href="http://www.ulb.ac.be/di/map/yleborgn/pub/NPL_PCA_07.pdf">New Routes from Minimal Approximation Error to Principal Components</a>, Volume 27, Number 3 / June, 2008, Neural Processing Letters, Springer<a href="#fnref10">â†©</a></li>
<li id="fn11"><a href="#fnref11">â†©</a></li>
<li id="fn12">Jolliffe, I. T. (2002). <em>Principal Component Analysis,</em> second edition Springer-Verlag. ISBN 978-0-387-95442-4.<a href="#fnref12">â†©</a></li>
<li id="fn13">Leznik, M; Tofallis, C. 2005 [uhra.herts.ac.uk/bitstream/handle/2299/715/S56.pdf Estimating Invariant Principal Components Using Diagonal Regression.]<a href="#fnref13">â†©</a></li>
<li id="fn14">Jonathon Shlens, <a href="http://arxiv.org/abs/1404.1100">A Tutorial on Principal Component Analysis.</a><a href="#fnref14">â†©</a></li>
<li id="fn15"><a href="#fnref15">â†©</a></li>
<li id="fn16"><a href="#fnref16">â†©</a></li>
<li id="fn17"><a href="#fnref17">â†©</a></li>
<li id="fn18">Tech Note<a href="#fnref18">â†©</a></li>
<li id="fn19"><a href="#fnref19">â†©</a></li>
<li id="fn20"><a href="#fnref20">â†©</a></li>
<li id="fn21">A.A. Miranda, Y.-A. Le Borgne, and G. Bontempi. <a href="http://www.ulb.ac.be/di/map/yleborgn/pub/NPL_PCA_07.pdf">New Routes from Minimal Approximation Error to Principal Components</a>, Volume 27, Number 3 / June, 2008, Neural Processing Letters, Springer<a href="#fnref21">â†©</a></li>
<li id="fn22"><a href="http://www.mathworks.com/access/helpdesk/help/techdoc/ref/eig.html#998306">eig function</a> Matlab documentation<a href="#fnref22">â†©</a></li>
<li id="fn23"><a href="http://www.mathworks.com/matlabcentral/fileexchange/24634">MATLAB PCA-based Face recognition software</a><a href="#fnref23">â†©</a></li>
<li id="fn24"><a href="http://reference.wolfram.com/mathematica/ref/Eigenvalues.html">Eigenvalues function</a> Mathematica documentation<a href="#fnref24">â†©</a></li>
<li id="fn25">Roweis, Sam. "EM Algorithms for PCA and SPCA." Advances in Neural Information Processing Systems. Ed. Michael I. Jordan, Michael J. Kearns, and Sara A. Solla The MIT Press, 1998.<a href="#fnref25">â†©</a></li>
<li id="fn26"><a href="#fnref26">â†©</a></li>
<li id="fn27"><a href="#fnref27">â†©</a></li>
<li id="fn28"><a href="#fnref28">â†©</a></li>
<li id="fn29"><a href="#fnref29">â†©</a></li>
<li id="fn30">Brenner, N., Bialek, W., &amp; de Ruyter van Steveninck, R.R. (2000).<a href="#fnref30">â†©</a></li>
<li id="fn31"><a href="#fnref31">â†©</a></li>
<li id="fn32"><a href="#fnref32">â†©</a></li>
<li id="fn33"><a href="#fnref33">â†©</a></li>
<li id="fn34"><a href="#fnref34">â†©</a></li>
<li id="fn35"><a class="uri" href="http://www.linkedin.com/groups/What-is-difference-between-factor-107833.S.162765950">http://www.linkedin.com/groups/What-is-difference-between-factor-107833.S.162765950</a><a href="#fnref35">â†©</a></li>
<li id="fn36">Timothy A. Brown. Confirmatory Factor Analysis for Applied Research Methodology in the social sciences. Guilford Press, 2006<a href="#fnref36">â†©</a></li>
<li id="fn37">I.T. Jolliffe. Principal Component Analysis, Second Edition. Chapter 7. 2002<a href="#fnref37">â†©</a></li>
<li id="fn38"><a href="#fnref38">â†©</a></li>
<li id="fn39"><a href="#fnref39">â†©</a></li>
<li id="fn40"><a href="#fnref40">â†©</a></li>
<li id="fn41"><a href="Alexander_Nikolaevich_Gorban" title="wikilink">A. N. Gorban</a>, A. Y. Zinovyev, <a href="http://arxiv.org/abs/0809.0490">Principal Graphs and Manifolds</a>, In: Handbook of Research on Machine Learning Applications and Trends: Algorithms, Methods and Techniques, Olivas E.S. et al Eds. Information Science Reference, IGI Global: Hershey, PA, USA, 2009. 28â€“59.<a href="#fnref41">â†©</a></li>
<li id="fn42">Wang, Y., Klijn, J.G., Zhang, Y., Sieuwerts, A.M., Look, M.P., Yang, F., Talantov, D., Timmermans, M., Meijer-van Gelder, M.E., Yu, J. et al.: Gene expression profiles to predict distant metastasis of lymph-node-negative primary breast cancer" <em>Lancet</em> 365, 671â€“679 (2005); <a href="http://www.ihes.fr/~zinovyev/princmanif2006/">Data online</a><a href="#fnref42">â†©</a></li>
<li id="fn43">A. Zinovyev, <a href="http://bioinfo-out.curie.fr/projects/vidaexpert/">ViDaExpert</a> â€“ Multidimensional Data Visualization Tool (free for non-commercial use). <a href="Curie_Institute_(Paris)" title="wikilink">Institut Curie</a>, Paris.<a href="#fnref43">â†©</a></li>
<li id="fn44">A.N. Gorban, B. Kegl, D.C. Wunsch, A. Zinovyev (Eds.), <a href="http://pca.narod.ru/contentsgkwz.htm">Principal Manifolds for Data Visualisation and Dimension Reduction,</a> LNCSE 58, Springer, Berlin â€“ Heidelberg â€“ New York, 2007. ISBN 978-3-540-73749-0<a href="#fnref44">â†©</a></li>
<li id="fn45"><a href="#fnref45">â†©</a></li>
<li id="fn46"><a href="#fnref46">â†©</a></li>
<li id="fn47"><a class="uri" href="http://www.kovcomp.co.uk/support/XL-Tut/">http://www.kovcomp.co.uk/support/XL-Tut/</a><a href="#fnref47">â†©</a></li>
<li id="fn48"><a href="http://reference.wolfram.com/mathematica/ref/PrincipalComponents.html">PrincipalComponents</a> Mathematica Documentation<a href="#fnref48">â†©</a></li>
<li id="fn49"><a href="#fnref49">â†©</a></li>
<li id="fn50"><a href="#fnref50">â†©</a></li>
<li id="fn51"><a href="http://www.umetrics.com/products/simca"><code>PcaPress</code></a> <a class="uri" href="http://www.umetrics.com/products/simca">http://www.umetrics.com/products/simca</a><a href="#fnref51">â†©</a></li>
<li id="fn52"><a href="http://www.utdallas.edu/~herve/abdi-PCA4Wiley.zip"><code>PcaPress</code></a> www.utdallas.edu<a href="#fnref52">â†©</a></li>
<li id="fn53">Oracle documentation <a href="http://docs.oracle.com/database/121/ARPLS/d_datmin.htm#ARPLS73749">1</a> <a class="uri" href="http://docs.oracle.com">http://docs.oracle.com</a><a href="#fnref53">â†©</a></li>
<li id="fn54"><a href="http://octave.sourceforge.net/statistics/function/princomp.html"><code>princomp</code></a> octave.sourceforge.net<a href="#fnref54">â†©</a></li>
<li id="fn55"><a href="http://stat.ethz.ch/R-manual/R-patched/library/stats/html/princomp.html"><code>princomp</code></a><a href="#fnref55">â†©</a></li>
<li id="fn56"><a href="http://stat.ethz.ch/R-manual/R-patched/library/stats/html/prcomp.html"><code>prcomp</code></a><a href="#fnref56">â†©</a></li>
<li id="fn57"><a href="http://cran.r-project.org/web/views/Multivariate.html">Multivariate</a> cran.r-project.org<a href="#fnref57">â†©</a></li>
<li id="fn58"><a class="uri" href="http://support.sas.com/documentation/cdl/en/statug/63347/HTML/default/viewer.htm#statug_factor_sect028.htm">http://support.sas.com/documentation/cdl/en/statug/63347/HTML/default/viewer.htm#statug_factor_sect028.htm</a><a href="#fnref58">â†©</a></li>
<li id="fn59"><a href="#fnref59">â†©</a></li>
<li id="fn60"><a href="https://code.google.com/p/cornell-spectrum-imager/wiki/Home">Cornell Spectrum Imager </a><a class="uri" href="https://code.google.com/p/cornell-spectrum-imager/wiki/Home">https://code.google.com/p/cornell-spectrum-imager/wiki/Home</a><a href="#fnref60">â†©</a></li>
<li id="fn61"><a href="https://sourceforge.net/apps/mediawiki/imdev/index.php?title=Main_Page">imDEV</a> sourceforge.net<a href="#fnref61">â†©</a></li>
<li id="fn62"><a href="http://www.bioconductor.org/packages/1.9/bioc/html/pcaMethods.html">pcaMethods</a> www.bioconductor.org<a href="#fnref62">â†©</a></li>
<li id="fn63"><a href="http://www.mdp.edu.ar/psicologia/vista/vista.htm">"ViSta: The Visual Statistics System"</a> www.mdp.edu.ar<a href="#fnref63">â†©</a></li>
<li id="fn64"><a href="http://www.coloritto.com">"Spectramap"</a> www.coloritto.com<a href="#fnref64">â†©</a></li>
<li id="fn65"><a href="https://rtmath.net/products/finmath/">FinMath</a> rtmath.net<a href="#fnref65">â†©</a></li>
<li id="fn66"><a class="uri" href="http://www.camo.com">http://www.camo.com</a><a href="#fnref66">â†©</a></li>
<li id="fn67"><a href="http://sourceforge.net/projects/opencvlibrary/">Computer Vision Library</a> sourceforge.net<a href="#fnref67">â†©</a></li>
<li id="fn68"><a href="http://www.exelisvis.com/docs/PCOMP.html">PCOMP (IDL Reference) | Exelis VIS Docs Center</a> IDL online documentation<a href="#fnref68">â†©</a></li>
<li id="fn69"><a href="http://weka.sourceforge.net/doc.dev/weka/attributeSelection/PrincipalComponents.html">javadoc</a> weka.sourceforge.net<a href="#fnref69">â†©</a></li>
<li id="fn70"><a href="http://www.qlucore.com">Software for analyzing multivariate data with instant response using PCA</a> www.qlucore.com<a href="#fnref70">â†©</a></li>
<li id="fn71"><a href="http://genepath.med.harvard.edu/~reich/Software.htm">EIGENSOFT</a> genepath.med.harvard.edu<a href="#fnref71">â†©</a></li>
<li id="fn72"><a href="http://www.partek.com/partekgs">Partek Genomics Suite</a> www.partek.com<a href="#fnref72">â†©</a></li>
<li id="fn73"><a href="http://scikit-learn.org/stable/modules/classes.html">2</a> <a class="uri" href="http://scikit-learn.org">http://scikit-learn.org</a><a href="#fnref73">â†©</a></li>
<li id="fn74"><a href="https://www.knime.org">3</a><a href="#fnref74">â†©</a></li>
<li id="fn75"><a href="https://github.com/JuliaStats/MultivariateStats.jl">MultivariateStats.jl</a> www.github.com<a href="#fnref75">â†©</a></li>
</ol>
</section>
</body>
</html>
