<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="614">Bisimulation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Bisimulation</h1>
<hr/>

<p>In <a href="theoretical_computer_science" title="wikilink">theoretical computer science</a> a <strong>bisimulation</strong> is a <a href="binary_relation" title="wikilink">binary relation</a> between <a href="state_transition_system" title="wikilink">state transition systems</a>, associating systems that behave in the same way in the sense that one system simulates the other and vice versa.</p>

<p>Intuitively two systems are <strong>bisimilar</strong> if they match each other's moves. In this sense, each of the systems cannot be distinguished from the other by an observer.</p>
<h2 id="formal-definition">Formal definition</h2>

<p>Given a <a href="state_transition_system" title="wikilink">labelled state transition system</a> (

<math display="inline" id="Bisimulation:0">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, Λ, →), a <em>bisimulation</em> <a href="Relation_(mathematics)" title="wikilink">relation</a> is a <a href="binary_relation" title="wikilink">binary relation</a> 

<math display="inline" id="Bisimulation:1">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 over 

<math display="inline" id="Bisimulation:2">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 (i.e., 

<math display="inline" id="Bisimulation:3">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 ⊆ 

<math display="inline" id="Bisimulation:4">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 × 

<math display="inline" id="Bisimulation:5">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

) such that both 

<math display="inline" id="Bisimulation:6">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

<sup>−1</sup> and 

<math display="inline" id="Bisimulation:7">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 are <a href="simulation_preorder" title="wikilink">simulations</a>.</p>

<p>Equivalently 

<math display="inline" id="Bisimulation:8">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is a bisimulation if for every pair of elements 

<math display="inline" id="Bisimulation:9">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>,</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>p</ci>
    <ci>q</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p,q
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Bisimulation:10">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Bisimulation:11">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>q</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>p</ci>
    <ci>q</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,q)
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Bisimulation:12">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

, for all α in Λ:</p>

<p>for all 

<math display="inline" id="Bisimulation:13">
 <semantics>
  <msup>
   <mi>p</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>p</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{\prime}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Bisimulation:14">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

,</p>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>p \overset{\alpha}{\rightarrow} p'</p>

<p><code> </code></p>
<dl>
<dd>implies that there is a 

<math display="inline" id="Bisimulation:15">
 <semantics>
  <msup>
   <mi>q</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>q</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q^{\prime}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Bisimulation:16">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 such that
</dd>
</dl>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>q \overset{\alpha}{\rightarrow} q'</p>

<p><code> </code></p>
<dl>
<dd>and 

<math display="inline" id="Bisimulation:17">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>p</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>q</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>q</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p^{\prime},q^{\prime})\in R
  </annotation>
 </semantics>
</math>

;
</dd>
</dl>

<p>and, symmetrically, for all 

<math display="inline" id="Bisimulation:18">
 <semantics>
  <msup>
   <mi>q</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>q</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q^{\prime}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Bisimulation:19">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>q \overset{\alpha}{\rightarrow} q'</p>

<p><code> </code></p>
<dl>
<dd>implies that there is a 

<math display="inline" id="Bisimulation:20">
 <semantics>
  <msup>
   <mi>p</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>p</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{\prime}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Bisimulation:21">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 such that
</dd>
</dl>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>p \overset{\alpha}{\rightarrow} p'</p>

<p><code> </code></p>
<dl>
<dd>and 

<math display="inline" id="Bisimulation:22">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>p</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>q</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>q</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p^{\prime},q^{\prime})\in R
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>

<p>Given two states 

<math display="inline" id="Bisimulation:23">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bisimulation:24">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Bisimulation:25">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Bisimulation:26">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is <strong>bisimilar</strong> to 

<math display="inline" id="Bisimulation:27">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

, written 

<math display="inline" id="Bisimulation:28">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <mi>p</mi>
   </mpadded>
   <mo rspace="4.2pt">∼</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <ci>p</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\sim\,q
  </annotation>
 </semantics>
</math>

, if there is a bisimulation 

<math display="inline" id="Bisimulation:29">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Bisimulation:30">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>q</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>p</ci>
    <ci>q</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,q)
  </annotation>
 </semantics>
</math>

 is in 

<math display="inline" id="Bisimulation:31">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

.</p>

<p>The bisimilarity relation 

<math display="inline" id="Bisimulation:32">
 <semantics>
  <mo lspace="4.2pt" rspace="4.2pt">∼</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">similar-to</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,\sim\,
  </annotation>
 </semantics>
</math>

 is an <a href="equivalence_relation" title="wikilink">equivalence relation</a>. Furthermore, it is the largest bisimulation relation over a given transition system.</p>

<p>Note that it is not always the case that if 

<math display="inline" id="Bisimulation:33">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 simulates 

<math display="inline" id="Bisimulation:34">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bisimulation:35">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 simulates 

<math display="inline" id="Bisimulation:36">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 then they are bisimilar. For 

<math display="inline" id="Bisimulation:37">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bisimulation:38">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 to be bisimilar, the simulation between 

<math display="inline" id="Bisimulation:39">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bisimulation:40">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 must be the <a href="Binary_relation" title="wikilink">inverse</a> of the simulation between 

<math display="inline" id="Bisimulation:41">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bisimulation:42">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

. Counter-example (in <a href="Calculus_of_Communicating_Systems" title="wikilink">CCS</a>, describing a coffee machine) 

<math display="block" id="Bisimulation:43">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mi>p</mi>
   <mo>.</mo>
   <mover accent="true">
    <mi>c</mi>
    <mo>¯</mo>
   </mover>
   <mo>.</mo>
   <mi>M</mi>
   <mo>+</mo>
   <mi>p</mi>
   <mo>.</mo>
   <mover accent="true">
    <mi>t</mi>
    <mo>¯</mo>
   </mover>
   <mo>.</mo>
   <mi>M</mi>
   <mo>+</mo>
   <mi>p</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>c</mi>
     <mo>¯</mo>
    </mover>
    <mo>.</mo>
    <mi>M</mi>
    <mo>+</mo>
    <mover accent="true">
     <mi>t</mi>
     <mo>¯</mo>
    </mover>
    <mo>.</mo>
    <mi>M</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">M</csymbol>
    <eq></eq>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-.</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>c</ci>
    </apply>
    <ci>normal-.</ci>
    <csymbol cd="unknown">M</csymbol>
    <plus></plus>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-.</ci>
    <apply>
     <ci>normal-¯</ci>
     <ci>t</ci>
    </apply>
    <ci>normal-.</ci>
    <csymbol cd="unknown">M</csymbol>
    <plus></plus>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>c</ci>
     </apply>
     <ci>normal-.</ci>
     <csymbol cd="unknown">M</csymbol>
     <plus></plus>
     <apply>
      <ci>normal-¯</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-.</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=p.\overline{c}.M+p.\overline{t}.M+p.(\overline{c}.M+\overline{t}.M)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bisimulation:44">
 <semantics>
  <mrow>
   <msup>
    <mi>M</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mi>p</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>c</mi>
     <mo>¯</mo>
    </mover>
    <mo>.</mo>
    <msup>
     <mi>M</mi>
     <mo>′</mo>
    </msup>
    <mo>+</mo>
    <mover accent="true">
     <mi>t</mi>
     <mo>¯</mo>
    </mover>
    <mo>.</mo>
    <msup>
     <mi>M</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>M</ci>
     <ci>normal-′</ci>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-¯</ci>
      <ci>c</ci>
     </apply>
     <ci>normal-.</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>M</ci>
      <ci>normal-′</ci>
     </apply>
     <plus></plus>
     <apply>
      <ci>normal-¯</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-.</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>M</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M^{\prime}=p.(\overline{c}.M^{\prime}+\overline{t}.M^{\prime})
  </annotation>
 </semantics>
</math>

 simulate each other but are not bisimilar.</p>
<h2 id="alternative-definitions">Alternative definitions</h2>
<h3 id="relational-definition">Relational definition</h3>

<p>Bisimulation can be defined in terms of <a href="composition_of_relations" title="wikilink">composition of relations</a> as follows.</p>

<p>Given a <a href="state_transition_system" title="wikilink">labelled state transition system</a> 

<math display="inline" id="Bisimulation:45">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <mi mathvariant="normal">Λ</mi>
   <mo>,</mo>
   <mo>→</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>S</ci>
    <ci>normal-Λ</ci>
    <ci>normal-→</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S,\Lambda,\rightarrow)
  </annotation>
 </semantics>
</math>

, a <em>bisimulation</em> <a href="Relation_(mathematics)" title="wikilink">relation</a> is a <a href="binary_relation" title="wikilink">binary relation</a> 

<math display="inline" id="Bisimulation:46">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 over 

<math display="inline" id="Bisimulation:47">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 (i.e., 

<math display="inline" id="Bisimulation:48">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 ⊆ 

<math display="inline" id="Bisimulation:49">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 × 

<math display="inline" id="Bisimulation:50">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

) such that 

<math display="inline" id="Bisimulation:51">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>α</mi>
   </mrow>
   <mo>∈</mo>
   <mi mathvariant="normal">Λ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>α</ci>
    </apply>
    <ci>normal-Λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\alpha\in\Lambda
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Bisimulation:52">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>R</mi>
   </mpadded>
   <mo rspace="7.5pt">;</mo>
   <mover accent="true">
    <mo>→</mo>
    <mo>𝛼</mo>
   </mover>
   <mo>⊆</mo>
   <mpadded width="+5pt">
    <mover accent="true">
     <mo>→</mo>
     <mo>𝛼</mo>
    </mover>
   </mpadded>
   <mo rspace="7.5pt">;</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>R</ci>
    <apply>
     <ci>α</ci>
     <ci>normal-→</ci>
    </apply>
    <subset></subset>
    <apply>
     <ci>α</ci>
     <ci>normal-→</ci>
    </apply>
    <ci>R</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\ ;\ \overset{\alpha}{\rightarrow}\quad{\subseteq}\quad\overset{\alpha}{%
\rightarrow}\ ;\ R
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>and

<p>

<math display="block" id="Bisimulation:53">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <msup>
     <mi>R</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mpadded>
   <mo rspace="7.5pt">;</mo>
   <mover accent="true">
    <mo>→</mo>
    <mo>𝛼</mo>
   </mover>
   <mo>⊆</mo>
   <mpadded width="+5pt">
    <mover accent="true">
     <mo>→</mo>
     <mo>𝛼</mo>
    </mover>
   </mpadded>
   <mo rspace="7.5pt">;</mo>
   <msup>
    <mi>R</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <ci>α</ci>
     <ci>normal-→</ci>
    </apply>
    <subset></subset>
    <apply>
     <ci>α</ci>
     <ci>normal-→</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{-1}\ ;\ \overset{\alpha}{\rightarrow}\quad{\subseteq}\quad\overset{\alpha}{%
\rightarrow}\ ;\ R^{-1}
  </annotation>
 </semantics>
</math>

</p>
</dd>
</dl>

<p>From the monotonicity and continuity of relation composition, it follows immediately that the set of the bisimulations is closed under unions (joins in the poset of relations), and a simple algebraic calculation shows that the relation of bisimilarity—the join of all bisimulations—is an equivalence relation. This definition, and the associated treatment of bisimilarity, can be interpreted in any involutive <a class="uri" href="quantale" title="wikilink">quantale</a>.</p>
<h3 id="fixpoint-definition">Fixpoint definition</h3>

<p>Bisimilarity can also be defined in <a href="Order_theory" title="wikilink">order theoretical</a> fashion, in terms of <a href="Knaster–Tarski_theorem" title="wikilink">fixpoint theory</a>, more precisely as the greatest fixed point of a certain function defined below.</p>

<p>Given a <a href="state_transition_system" title="wikilink">labelled state transition system</a> (

<math display="inline" id="Bisimulation:54">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, Λ, →), define 

<math display="inline" id="Bisimulation:55">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">𝒫</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>S</mi>
       <mo>×</mo>
       <mi>S</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">𝒫</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>S</mi>
       <mo>×</mo>
       <mi>S</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>F</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>𝒫</ci>
      <apply>
       <times></times>
       <ci>S</ci>
       <ci>S</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>𝒫</ci>
      <apply>
       <times></times>
       <ci>S</ci>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F:\mathcal{P}(S\times S)\to\mathcal{P}(S\times S)
  </annotation>
 </semantics>
</math>

 to be a function from binary relations over 

<math display="inline" id="Bisimulation:56">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 to binary relations over 

<math display="inline" id="Bisimulation:57">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, as follows:</p>

<p>Let 

<math display="inline" id="Bisimulation:58">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 be any binary relation over 

<math display="inline" id="Bisimulation:59">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Bisimulation:60">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(R)
  </annotation>
 </semantics>
</math>

 is defined to be the set of all pairs 

<math display="inline" id="Bisimulation:61">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>q</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>p</ci>
    <ci>q</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,q)
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Bisimulation:62">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 × 

<math display="inline" id="Bisimulation:63">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 such that:</p>

<p>

<math display="block" id="Bisimulation:64">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>α</mi>
    </mrow>
    <mo>∈</mo>
    <mi mathvariant="normal">Λ</mi>
   </mrow>
   <mo rspace="4.2pt">.</mo>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <msup>
      <mi>p</mi>
      <mo>′</mo>
     </msup>
    </mrow>
    <mo>∈</mo>
    <mi>S</mi>
   </mrow>
   <mo rspace="4.2pt">.</mo>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mover accent="true">
      <mo>→</mo>
      <mo>𝛼</mo>
     </mover>
     <mpadded width="+1.7pt">
      <msup>
       <mi>p</mi>
       <mo>′</mo>
      </msup>
     </mpadded>
    </mrow>
    <mo rspace="4.2pt">⇒</mo>
    <mrow>
     <mo>∃</mo>
     <msup>
      <mi>q</mi>
      <mo>′</mo>
     </msup>
    </mrow>
    <mo>∈</mo>
    <mi>S</mi>
   </mrow>
   <mo rspace="4.2pt">.</mo>
   <mrow>
    <mrow>
     <mi>q</mi>
     <mover accent="true">
      <mo>→</mo>
      <mo>𝛼</mo>
     </mover>
     <mpadded width="+1.7pt">
      <msup>
       <mi>q</mi>
       <mo>′</mo>
      </msup>
     </mpadded>
     <mpadded width="+1.7pt">
      <mtext>and</mtext>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>p</mi>
       <mo>′</mo>
      </msup>
      <mo>,</mo>
      <msup>
       <mi>q</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>α</ci>
     </apply>
     <ci>normal-Λ</ci>
    </apply>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <ci>S</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <ci>normal-⇒</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <apply>
        <ci>α</ci>
        <ci>normal-→</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>p</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
      <apply>
       <exists></exists>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>q</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <ci>S</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <ci>q</ci>
      <apply>
       <ci>α</ci>
       <ci>normal-→</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>q</ci>
       <ci>normal-′</ci>
      </apply>
      <mtext>and</mtext>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>p</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>q</ci>
        <ci>normal-′</ci>
       </apply>
      </interval>
     </apply>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\alpha\in\Lambda.\,\forall p^{\prime}\in S.\,p\overset{\alpha}{%
\rightarrow}p^{\prime}\,\Rightarrow\,\exists q^{\prime}\in S.\,q\overset{%
\alpha}{\rightarrow}q^{\prime}\,\textrm{ and }\,(p^{\prime},q^{\prime})\in R
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Bisimulation:65">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>α</mi>
    </mrow>
    <mo>∈</mo>
    <mi mathvariant="normal">Λ</mi>
   </mrow>
   <mo rspace="4.2pt">.</mo>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <msup>
      <mi>q</mi>
      <mo>′</mo>
     </msup>
    </mrow>
    <mo>∈</mo>
    <mi>S</mi>
   </mrow>
   <mo rspace="4.2pt">.</mo>
   <mrow>
    <mrow>
     <mi>q</mi>
     <mover accent="true">
      <mo>→</mo>
      <mo>𝛼</mo>
     </mover>
     <mpadded width="+1.7pt">
      <msup>
       <mi>q</mi>
       <mo>′</mo>
      </msup>
     </mpadded>
    </mrow>
    <mo rspace="4.2pt">⇒</mo>
    <mrow>
     <mo>∃</mo>
     <msup>
      <mi>p</mi>
      <mo>′</mo>
     </msup>
    </mrow>
    <mo>∈</mo>
    <mi>S</mi>
   </mrow>
   <mo rspace="4.2pt">.</mo>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mover accent="true">
      <mo>→</mo>
      <mo>𝛼</mo>
     </mover>
     <mpadded width="+1.7pt">
      <msup>
       <mi>p</mi>
       <mo>′</mo>
      </msup>
     </mpadded>
     <mpadded width="+1.7pt">
      <mtext>and</mtext>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>p</mi>
       <mo>′</mo>
      </msup>
      <mo>,</mo>
      <msup>
       <mi>q</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>α</ci>
     </apply>
     <ci>normal-Λ</ci>
    </apply>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>q</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <ci>S</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <ci>normal-⇒</ci>
      <apply>
       <times></times>
       <ci>q</ci>
       <apply>
        <ci>α</ci>
        <ci>normal-→</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>q</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
      <apply>
       <exists></exists>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>p</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <ci>S</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <ci>p</ci>
      <apply>
       <ci>α</ci>
       <ci>normal-→</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>p</ci>
       <ci>normal-′</ci>
      </apply>
      <mtext>and</mtext>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>p</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>q</ci>
        <ci>normal-′</ci>
       </apply>
      </interval>
     </apply>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\alpha\in\Lambda.\,\forall q^{\prime}\in S.\,q\overset{\alpha}{%
\rightarrow}q^{\prime}\,\Rightarrow\,\exists p^{\prime}\in S.\,p\overset{%
\alpha}{\rightarrow}p^{\prime}\,\textrm{ and }\,(p^{\prime},q^{\prime})\in R
  </annotation>
 </semantics>
</math>

</p>

<p>Bisimilarity is then defined to be the <a href="greatest_fixed_point" title="wikilink">greatest fixed point</a> of 

<math display="inline" id="Bisimulation:66">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="game-theoretical-definition">Game theoretical definition</h3>

<p>Bisimulation can also be thought of in terms of a game between two players: attacker and defender.</p>

<p>"Attacker" goes first and may choose any valid transition, 

<math display="inline" id="Bisimulation:67">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

, from 

<math display="inline" id="Bisimulation:68">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>q</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>p</ci>
    <ci>q</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,q)
  </annotation>
 </semantics>
</math>

. I.e.:</p>

<p>

<math display="inline" id="Bisimulation:69">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mover accent="true">
    <mo>→</mo>
    <mo>𝛼</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>p</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <interval closure="open">
     <ci>p</ci>
     <ci>q</ci>
    </interval>
    <apply>
     <ci>α</ci>
     <ci>normal-→</ci>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>q</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,q)\overset{\alpha}{\rightarrow}(p^{\prime},q)
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Bisimulation:70">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mover accent="true">
    <mo>→</mo>
    <mo>𝛼</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <msup>
     <mi>q</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <interval closure="open">
     <ci>p</ci>
     <ci>q</ci>
    </interval>
    <apply>
     <ci>α</ci>
     <ci>normal-→</ci>
    </apply>
    <interval closure="open">
     <ci>p</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>q</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,q)\overset{\alpha}{\rightarrow}(p,q^{\prime})
  </annotation>
 </semantics>
</math>

</p>

<p>The "Defender" must then attempt to match that transition, 

<math display="inline" id="Bisimulation:71">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 from either 

<math display="inline" id="Bisimulation:72">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msup>
    <mi>p</mi>
    <mo>′</mo>
   </msup>
   <mo>,</mo>
   <mi>q</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>p</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>q</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p^{\prime},q)
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Bisimulation:73">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>p</mi>
   <mo>,</mo>
   <msup>
    <mi>q</mi>
    <mo>′</mo>
   </msup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>p</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>q</ci>
     <ci>normal-′</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,q^{\prime})
  </annotation>
 </semantics>
</math>

 depending on the attacker's move. I.e., they must find an 

<math display="inline" id="Bisimulation:74">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 such that:</p>

<p>

<math display="inline" id="Bisimulation:75">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>p</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <mi>q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mover accent="true">
    <mo>→</mo>
    <mo>𝛼</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>p</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>q</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>q</ci>
    </interval>
    <apply>
     <ci>α</ci>
     <ci>normal-→</ci>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>q</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p^{\prime},q)\overset{\alpha}{\rightarrow}(p^{\prime},q^{\prime})
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Bisimulation:76">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>,</mo>
    <msup>
     <mi>q</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mover accent="true">
    <mo>→</mo>
    <mo>𝛼</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>p</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>q</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <interval closure="open">
     <ci>p</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>q</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
    <apply>
     <ci>α</ci>
     <ci>normal-→</ci>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>q</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,q^{\prime})\overset{\alpha}{\rightarrow}(p^{\prime},q^{\prime})
  </annotation>
 </semantics>
</math>

</p>

<p>Attacker and defender continue to take alternating turns until:</p>
<ul>
<li>The defender is unable to find any valid transitions to match the attacker's move. In this case the attacker wins.</li>
<li>The game reaches states 

<math display="inline" id="Bisimulation:77">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>q</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>p</ci>
    <ci>q</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,q)
  </annotation>
 </semantics>
</math>

 that are both 'dead' (i.e., there are no transitions from either state) In this case the defender wins</li>
<li>The game goes on forever, in which case the defender wins.</li>
<li>The game reaches states 

<math display="inline" id="Bisimulation:78">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>q</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>p</ci>
    <ci>q</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,q)
  </annotation>
 </semantics>
</math>

, which have already been visited. This is equivalent to an infinite play and counts as a win for the defender.</li>
</ul>

<p>By the above definition the system is a bisimulation if and only if there exists a winning strategy for the defender.</p>
<h3 id="coalgebraic-definition">Coalgebraic definition</h3>

<p>A bisimulation for state transition systems is a special case of coalgebraic bisimulation for the type of covariant powerset functor. Note that every state transition system 

<math display="inline" id="Bisimulation:79">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <mi mathvariant="normal">Λ</mi>
   <mo>,</mo>
   <mo>→</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>S</ci>
    <ci>normal-Λ</ci>
    <ci>normal-→</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S,\Lambda,\rightarrow)
  </annotation>
 </semantics>
</math>

 is bijectively a function 

<math display="inline" id="Bisimulation:80">
 <semantics>
  <msub>
   <mi>ξ</mi>
   <mo>→</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ξ</ci>
    <ci>normal-→</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi_{\rightarrow}
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Bisimulation:81">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 to the powerset of 

<math display="inline" id="Bisimulation:82">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 indexed by 

<math display="inline" id="Bisimulation:83">
 <semantics>
  <mi mathvariant="normal">Λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda
  </annotation>
 </semantics>
</math>

 written as 

<math display="inline" id="Bisimulation:84">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒫</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">Λ</mi>
     <mo>×</mo>
     <mi>S</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒫</ci>
    <apply>
     <times></times>
     <ci>normal-Λ</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}(\Lambda\times S)
  </annotation>
 </semantics>
</math>

, defined by</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Bisimulation:85">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mo>↦</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>α</mi>
       <mo>,</mo>
       <mi>q</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mi>S</mi>
     </mrow>
     <mo>:</mo>
     <mrow>
      <mi>p</mi>
      <mover accent="true">
       <mo>→</mo>
       <mo>𝛼</mo>
      </mover>
      <mi>q</mi>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>p</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <interval closure="open">
       <ci>α</ci>
       <ci>q</ci>
      </interval>
      <ci>S</ci>
     </apply>
     <apply>
      <times></times>
      <ci>p</ci>
      <apply>
       <ci>α</ci>
       <ci>normal-→</ci>
      </apply>
      <ci>q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\mapsto\{(\alpha,q)\in S:p\overset{\alpha}{\rightarrow}q\}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Let 

<math display="inline" id="Bisimulation:86">
 <semantics>
  <mrow>
   <msub>
    <mi>π</mi>
    <mi>i</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mo>×</mo>
     <mi>S</mi>
    </mrow>
    <mo>→</mo>
    <mi>S</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>π</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>S</ci>
     </apply>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{i}\colon S\times S\to S
  </annotation>
 </semantics>
</math>

 be 

<math display="inline" id="Bisimulation:87">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

-th projection mapping 

<math display="inline" id="Bisimulation:88">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>p</mi>
   <mo>,</mo>
   <mi>q</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>p</ci>
    <ci>q</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p,q)
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Bisimulation:89">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bisimulation:90">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 respectively for 

<math display="inline" id="Bisimulation:91">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,2
  </annotation>
 </semantics>
</math>

; and 

<math display="inline" id="Bisimulation:92">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒫</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">Λ</mi>
     <mo>×</mo>
     <msub>
      <mi>π</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒫</ci>
    <apply>
     <times></times>
     <ci>normal-Λ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}(\Lambda\times\pi_{1})
  </annotation>
 </semantics>
</math>

 the forward image of 

<math display="inline" id="Bisimulation:93">
 <semantics>
  <msub>
   <mi>π</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>π</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{1}
  </annotation>
 </semantics>
</math>

 defined by dropping the third component</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Bisimulation:94">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>↦</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>α</mi>
      <mo>,</mo>
      <mi>p</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∈</mo>
     <mrow>
      <mi mathvariant="normal">Λ</mi>
      <mo>×</mo>
      <mi>S</mi>
     </mrow>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mo>∃</mo>
      <mi>q</mi>
     </mrow>
     <mo>.</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>α</mi>
       <mo>,</mo>
       <mi>p</mi>
       <mo>,</mo>
       <mi>q</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mi>P</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>P</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <interval closure="open">
       <ci>α</ci>
       <ci>p</ci>
      </interval>
      <apply>
       <times></times>
       <ci>normal-Λ</ci>
       <ci>S</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <exists></exists>
       <ci>q</ci>
      </apply>
      <apply>
       <in></in>
       <vector>
        <ci>α</ci>
        <ci>p</ci>
        <ci>q</ci>
       </vector>
       <ci>P</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\mapsto\{(\alpha,p)\in\Lambda\times S:\exists q.(\alpha,p,q)\in P\}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where 

<math display="inline" id="Bisimulation:95">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is a subset of 

<math display="inline" id="Bisimulation:96">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Λ</mi>
   <mo>×</mo>
   <mi>S</mi>
   <mo>×</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Λ</ci>
    <ci>S</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda\times S\times S
  </annotation>
 </semantics>
</math>

. Similarly for 

<math display="inline" id="Bisimulation:97">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒫</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">Λ</mi>
     <mo>×</mo>
     <msub>
      <mi>π</mi>
      <mn>2</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒫</ci>
    <apply>
     <times></times>
     <ci>normal-Λ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}(\Lambda\times\pi_{2})
  </annotation>
 </semantics>
</math>

.</p>

<p>Using the above notations, a relation 

<math display="inline" id="Bisimulation:98">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>⊆</mo>
   <mrow>
    <mi>S</mi>
    <mo>×</mo>
    <mi>S</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>R</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\subseteq S\times S
  </annotation>
 </semantics>
</math>

 is a <strong>bisimulation</strong> on a transition system 

<math display="inline" id="Bisimulation:99">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <mi mathvariant="normal">Λ</mi>
   <mo>,</mo>
   <mo>→</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>S</ci>
    <ci>normal-Λ</ci>
    <ci>normal-→</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S,\Lambda,\rightarrow)
  </annotation>
 </semantics>
</math>

 if and only if there exists a transition system 

<math display="inline" id="Bisimulation:100">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mo>:</mo>
   <mrow>
    <mi>R</mi>
    <mo>→</mo>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">𝒫</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi mathvariant="normal">Λ</mi>
       <mo>×</mo>
       <mi>R</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>γ</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>R</ci>
     <apply>
      <times></times>
      <ci>𝒫</ci>
      <apply>
       <times></times>
       <ci>normal-Λ</ci>
       <ci>R</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma\colon R\to\mathcal{P}(\Lambda\times R)
  </annotation>
 </semantics>
</math>

 on the relation 

<math display="inline" id="Bisimulation:101">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 such that the diagram</p>

<p><a href="Image:Coalgebraic_bisimulation.svg" title="wikilink">frameless|upright=1.5</a></p>

<p>commutes, i.e. for 

<math display="inline" id="Bisimulation:102">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,2
  </annotation>
 </semantics>
</math>

, the equations</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Bisimulation:103">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ξ</mi>
     <mo>→</mo>
    </msub>
    <mo>∘</mo>
    <msub>
     <mi>π</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">𝒫</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi mathvariant="normal">Λ</mi>
       <mo>×</mo>
       <msub>
        <mi>π</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∘</mo>
    <mi>γ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ξ</ci>
      <ci>normal-→</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <compose></compose>
     <apply>
      <times></times>
      <ci>𝒫</ci>
      <apply>
       <times></times>
       <ci>normal-Λ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>π</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <ci>γ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi_{\rightarrow}\circ\pi_{i}=\mathcal{P}(\Lambda\times\pi_{i})\circ\gamma
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>hold where 

<math display="inline" id="Bisimulation:104">
 <semantics>
  <msub>
   <mi>ξ</mi>
   <mo>→</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ξ</ci>
    <ci>normal-→</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \xi_{\rightarrow}
  </annotation>
 </semantics>
</math>

 is the functional representation of 

<math display="inline" id="Bisimulation:105">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>S</mi>
   <mo>,</mo>
   <mi mathvariant="normal">Λ</mi>
   <mo>,</mo>
   <mo>→</mo>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>S</ci>
    <ci>normal-Λ</ci>
    <ci>normal-→</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S,\Lambda,\rightarrow)
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="variants-of-bisimulation">Variants of bisimulation</h2>

<p>In special contexts the notion of bisimulation is sometimes refined by adding additional requirements or constraints. For example if the state transition system includes a notion of <em>silent</em> (or <em>internal</em>) action, often denoted with 

<math display="inline" id="Bisimulation:106">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

, i.e. actions that are not visible by external observers, then bisimulation can be relaxed to be <em>weak bisimulation</em>, in which if two states 

<math display="inline" id="Bisimulation:107">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Bisimulation:108">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 are bisimilar and there is some number of internal actions leading from 

<math display="inline" id="Bisimulation:109">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 to some state 

<math display="inline" id="Bisimulation:110">
 <semantics>
  <msup>
   <mi>p</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>p</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{\prime}
  </annotation>
 </semantics>
</math>

 then there must exist state 

<math display="inline" id="Bisimulation:111">
 <semantics>
  <msup>
   <mi>q</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>q</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q^{\prime}
  </annotation>
 </semantics>
</math>

 such that there is some number (possibly zero) of internal actions leading from 

<math display="inline" id="Bisimulation:112">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Bisimulation:113">
 <semantics>
  <msup>
   <mi>q</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>q</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q^{\prime}
  </annotation>
 </semantics>
</math>

.</p>

<p>Typically, if the <a href="state_transition_system" title="wikilink">state transition system</a> gives the <a href="operational_semantics" title="wikilink">operational semantics</a> of a <a href="programming_language" title="wikilink">programming language</a>, then the precise definition of bisimulation will be specific to the restrictions of the programming language. Therefore, in general, there may be more than one kind of bisimulation, (bisimilarity resp.) relationship depending on the context.</p>
<h2 id="bisimulation-and-modal-logic">Bisimulation and modal logic</h2>

<p>Since <a href="Kripke_semantics" title="wikilink">Kripke models</a> are a special case of (labelled) state transition systems, bisimulation is also a topic in <a href="modal_logic" title="wikilink">modal logic</a>. In fact, modal logic is the fragment of <a href="first-order_logic" title="wikilink">first-order logic</a> invariant under bisimulation (<a href="Johan_van_Benthem_(logician)" title="wikilink">Van Benthem's theorem</a>).</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Operational_semantics" title="wikilink">Operational semantics</a></li>
<li><a href="State_transition_system" title="wikilink">State transition systems</a></li>
<li><a href="Simulation_preorder" title="wikilink">Simulation preorder</a></li>
<li><a href="Congruence_relation" title="wikilink">Congruence relation</a></li>
<li><a href="Probabilistic_bisimulation" title="wikilink">Probabilistic bisimulation</a></li>
</ul>
<h2 id="software-tools">Software tools</h2>
<ul>
<li><a class="uri" href="CADP" title="wikilink">CADP</a>: <a href="http://cadp.inria.fr">tools to minimize and compare finite-state systems according to various bisimulations</a></li>
<li><a class="uri" href="mCRL2" title="wikilink">mCRL2</a> tools to minimize and compare finite-state systems according to various bisimulations]</li>
<li><a href="http://www.brics.dk/bisim/">The Bisimulation Game Game</a></li>
</ul>
<h2 id="references">References</h2>
<ol>
<li></li>
<li></li>
</ol>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Davide Sangiorgi. (2011). <em>Introduction to Bisimulation and Coinduction</em>. Cambridge University Press. ISBN 9781107003637</li>
</ul>

<p>"</p>

<p><a href="Category:Theoretical_computer_science" title="wikilink">Category:Theoretical computer science</a> <a href="Category:Formal_methods" title="wikilink">Category:Formal methods</a> <a href="Category:Logic_in_computer_science" title="wikilink">Category:Logic in computer science</a></p>
</body>
</html>
