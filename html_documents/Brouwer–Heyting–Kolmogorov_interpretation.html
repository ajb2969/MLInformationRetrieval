<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1752">Brouwer–Heyting–Kolmogorov interpretation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Brouwer–Heyting–Kolmogorov interpretation</h1>
<hr/>

<p>In <a href="mathematical_logic" title="wikilink">mathematical logic</a>, the <strong>Brouwer–Heyting–Kolmogorov interpretation</strong>, or <strong>BHK interpretation</strong>, of <a href="intuitionistic_logic" title="wikilink">intuitionistic logic</a> was proposed by <a href="L._E._J._Brouwer" title="wikilink">L. E. J. Brouwer</a>, <a href="Arend_Heyting" title="wikilink">Arend Heyting</a> and independently by <a href="Andrey_Kolmogorov" title="wikilink">Andrey Kolmogorov</a>. It is also sometimes called the <strong>realizability interpretation</strong>, because of the connection with the <a class="uri" href="realizability" title="wikilink">realizability</a> theory of <a href="Stephen_Kleene" title="wikilink">Stephen Kleene</a>.</p>
<h2 id="the-interpretation">The interpretation</h2>

<p>The interpretation states exactly what is intended to be a proof of a given <a href="Formula_(mathematical_logic)" title="wikilink">formula</a>. This is specified by <a href="induction_on_the_structure" title="wikilink">induction on the structure</a> of that formula:</p>
<ul>
<li>A proof of 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:0">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>∧</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>P</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\wedge Q
  </annotation>
 </semantics>
</math>

 is a pair  where <em>a</em> is a proof of <em>P</em> and <em>b</em> is a proof of <em>Q</em>.</li>
<li>A proof of 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:1">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>∨</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>P</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\vee Q
  </annotation>
 </semantics>
</math>

 is a pair  where <em>a</em> is 0 and <em>b</em> is a proof of <em>P</em>, or <em>a</em> is 1 and <em>b</em> is a proof of <em>Q</em>.</li>
<li>A proof of 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:2">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>→</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>P</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\to Q
  </annotation>
 </semantics>
</math>

 is a function <em>f</em> that converts a proof of <em>P</em> into a proof of <em>Q</em>.</li>
<li>A proof of 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∃</mo>
     <mi>x</mi>
    </mrow>
    <mo>∈</mo>
    <mi>S</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <in></in>
     <apply>
      <exists></exists>
      <ci>x</ci>
     </apply>
     <ci>S</ci>
    </apply>
    <apply>
     <times></times>
     <ci>φ</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists x\in S:\varphi(x)
  </annotation>
 </semantics>
</math>


 is a pair  where <em>a</em> is an element of <em>S</em>, and <em>b</em> is a proof of <em>φ(a)</em>.</li>
<li>A proof of 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>x</mi>
    </mrow>
    <mo>∈</mo>
    <mi>S</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>x</ci>
     </apply>
     <ci>S</ci>
    </apply>
    <apply>
     <times></times>
     <ci>φ</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\in S:\varphi(x)
  </annotation>
 </semantics>
</math>

 is a function <em>f</em> that converts an element <em>a</em> of <em>S</em> into a proof of <em>φ(a)</em>.</li>
<li>The formula 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:5">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg P
  </annotation>
 </semantics>
</math>

 is defined as 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:6">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>→</mo>
   <mo>⊥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>P</ci>
    <csymbol cd="latexml">bottom</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\to\bot
  </annotation>
 </semantics>
</math>

, so a proof of it is a function <em>f</em> that converts a proof of <em>P</em> into a proof of 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:7">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>

.</li>
<li>There is no proof of 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:8">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>


 (the absurdity).</li>
</ul>

<p>The interpretation of a primitive proposition is supposed to be known from context. In the context of arithmetic, a proof of the formula <em>s</em>=<em>t</em> is a computation reducing the two terms to the same numeral.</p>

<p>Kolmogorov followed the same lines but phrased his interpretation in terms of problems and solutions. To assert a formula is to claim to know a solution to the problem represented by that formula. For instance 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:9">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>→</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>P</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\to Q
  </annotation>
 </semantics>
</math>

 is the problem of reducing <em>Q</em> to <em>P</em>; to solve it requires a method to solve problem <em>Q</em> given a solution to problem <em>P</em>.</p>
<h2 id="examples">Examples</h2>

<p>The identity function is a proof of the formula 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:10">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>→</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>P</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\to P
  </annotation>
 </semantics>
</math>

, no matter what P is.</p>

<p>The <a href="law_of_non-contradiction" title="wikilink">law of non-contradiction</a> 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:11">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>P</mi>
     <mo>∧</mo>
     <mrow>
      <mi mathvariant="normal">¬</mi>
      <mi>P</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <not></not>
    <apply>
     <and></and>
     <ci>P</ci>
     <apply>
      <times></times>
      <not></not>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg(P\wedge\neg P)
  </annotation>
 </semantics>
</math>

 expands to 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:12">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>P</mi>
     <mo>→</mo>
     <mo>⊥</mo>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mo>⊥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">P</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="latexml">bottom</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="latexml">bottom</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (P\wedge(P\to\bot))\to\bot
  </annotation>
 </semantics>
</math>

:</p>
<ul>
<li>A proof of 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:13">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>P</mi>
     <mo>→</mo>
     <mo>⊥</mo>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mo>⊥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">P</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="latexml">bottom</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="latexml">bottom</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (P\wedge(P\to\bot))\to\bot
  </annotation>
 </semantics>
</math>


 is a function <em>f</em> thatconverts a proof of 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:14">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>P</mi>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo>→</mo>
    <mo>⊥</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="unknown">P</csymbol>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="latexml">bottom</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (P\wedge(P\to\bot))
  </annotation>
 </semantics>
</math>

 into a proof of 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:15">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>

.</li>
<li>A proof of 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:16">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>P</mi>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo>→</mo>
    <mo>⊥</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="unknown">P</csymbol>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="latexml">bottom</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (P\wedge(P\to\bot))
  </annotation>
 </semantics>
</math>

 is a pair of proofs , where <em>a</em> is a proof of <em>P</em>, and <em>b</em> is a proof of 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:17">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>→</mo>
   <mo>⊥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>P</ci>
    <csymbol cd="latexml">bottom</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\to\bot
  </annotation>
 </semantics>
</math>

.</li>
<li>A proof of 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:18">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>→</mo>
   <mo>⊥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>P</ci>
    <csymbol cd="latexml">bottom</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\to\bot
  </annotation>
 </semantics>
</math>


 is a function that converts a proof of <em>P</em> into a proof of 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:19">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>Putting it all together, a proof of 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:20">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>P</mi>
     <mo>→</mo>
     <mo>⊥</mo>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mo>⊥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">P</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="latexml">bottom</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="latexml">bottom</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (P\wedge(P\to\bot))\to\bot
  </annotation>
 </semantics>
</math>

 is a function <em>f</em> that converts a pair  – where <em>a</em> is a proof of <em>P</em>, and <em>b</em> is a function that converts a proof of <em>P</em> into a proof of 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:21">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>

 – into a proof of 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:22">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>

. The function 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>b</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <list>
      <ci>a</ci>
      <ci>b</ci>
     </list>
    </apply>
    <apply>
     <times></times>
     <ci>b</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\langle a,b\rangle)=b(a)
  </annotation>
 </semantics>
</math>


 fits the bill, proving the law of non-contradiction, no matter what P is.</p>

<p>On the other hand, the <a href="law_of_excluded_middle" title="wikilink">law of excluded middle</a> 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:24">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>∨</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>P</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>P</ci>
    <apply>
     <times></times>
     <not></not>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\vee(\neg P)
  </annotation>
 </semantics>
</math>

 expands to 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:25">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>∨</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo>→</mo>
    <mo>⊥</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <or></or>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="latexml">bottom</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\vee(P\to\bot)
  </annotation>
 </semantics>
</math>

, and in general has no proof. According to the interpretation, a proof of 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:26">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>∨</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>P</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>P</ci>
    <apply>
     <times></times>
     <not></not>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\vee(\neg P)
  </annotation>
 </semantics>
</math>

 is a pair  where <em>a</em> is 0 and <em>b</em> is a proof of <em>P</em>, or <em>a</em> is 1 and <em>b</em> is a proof of 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:27">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>→</mo>
   <mo>⊥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>P</ci>
    <csymbol cd="latexml">bottom</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\to\bot
  </annotation>
 </semantics>
</math>

. Thus if neither <em>P</em> nor 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:28">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>→</mo>
   <mo>⊥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>P</ci>
    <csymbol cd="latexml">bottom</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\to\bot
  </annotation>
 </semantics>
</math>


 is provable then neither is 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:29">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>∨</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>P</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>P</ci>
    <apply>
     <times></times>
     <not></not>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\vee(\neg P)
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="what-is-absurdity">What is absurdity?</h2>

<p>It is not in general possible for a <a href="logical_system" title="wikilink">logical system</a> to have a formal negation operator such that there is a proof of <em>"not" P</em> exactly when there isn't a proof of <em>P</em> ; see <a href="Gödel's_incompleteness_theorems" title="wikilink">Gödel's incompleteness theorems</a>. The BHK interpretation instead takes <em>"not" P</em> to mean that <em>P</em> leads to absurdity, designated 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:30">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>

, so that a proof of <em>¬P</em> is a function converting a proof of <em>P</em> into a proof of absurdity.</p>

<p>A standard example of absurdity is found in dealing with arithmetic. Assume that 0 = 1, and proceed by <a href="mathematical_induction" title="wikilink">mathematical induction</a>: 0 = 0 by the axiom of equality. Now (induction hypothesis), if 0 were equal to a certain natural number <em>n</em>, then 1 would be equal to <em>n</em>+1, (<a href="Peano_arithmetic" title="wikilink">Peano axiom</a>: <strong>S</strong><em>m</em> = <strong>S</strong><em>n</em> if and only if <em>m</em> = <em>n</em>), but since 0=1, therefore 0 would also be equal to <em>n</em> + 1. By induction, 0 is equal to all numbers, and therefore any two natural numbers become equal.</p>

<p>Therefore, there is a way to go from a proof of 0=1 to a proof of any basic arithmetic equality, and thus to a proof of any complex arithmetic proposition. Furthermore, to get this result it was not necessary to invoke the Peano axiom which states that 0 is "not" the successor of any natural number. This makes 0=1 suitable as 

<math display="inline" id="Brouwer–Heyting–Kolmogorov_interpretation:31">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>

 in Heyting arithmetic (and the Peano axiom is rewritten 0 = <strong>S</strong><em>n</em> → 0 = <strong>S</strong>0). This use of 0 = 1 validates the <a href="principle_of_explosion" title="wikilink">principle of explosion</a>.</p>
<h2 id="what-is-a-function">What is a function?</h2>

<p>The BHK interpretation will depend on the view taken about what constitutes a <em>function</em> that converts one proof to another, or that converts an element of a domain to a proof. Different versions of <a href="constructivism_(mathematics)" title="wikilink">constructivism</a> will diverge on this point.</p>

<p>Kleene's realizability theory identifies the functions with the <a href="computable_function" title="wikilink">computable functions</a>. It deals with <a href="Heyting_arithmetic" title="wikilink">Heyting arithmetic</a>, where the domain of quantification is the natural numbers and the primitive propositions are of the form x=y. A proof of x=y is simply the trivial algorithm if x evaluates to the same number that y does (which is always decidable for natural numbers), otherwise there is no proof. These are then built up by induction into more complex algorithms.</p>

<p>If one takes <a href="lambda_calculus" title="wikilink">lambda calculus</a> as defining the notion of a function, then the BHK interpretation describes the <a href="Curry–Howard_correspondence" title="wikilink">correspondence</a> between natural deduction and functions.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Dependently_typed_programming" title="wikilink">Category:Dependently typed programming</a> <a href="Category:Functional_programming" title="wikilink">Category:Functional programming</a> <a href="Category:Constructivism_(mathematics)" title="wikilink">Category:Constructivism (mathematics)</a></p>
</body>
</html>
