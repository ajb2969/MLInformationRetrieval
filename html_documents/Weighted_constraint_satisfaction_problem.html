<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1175">Weighted constraint satisfaction problem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Weighted constraint satisfaction problem</h1>
<hr/>

<p>Whereas all constraints in a <a href="constraint_satisfaction_problem" title="wikilink">constraint satisfaction problem</a> (CSP) must be satisfied, a <strong>Weighted Constraint Satisfaction Problem</strong> (WCSP) is a constraint satisfaction problem where constraints can be violated (according a violation degree) and in which preferences among solutions can be expressed. Many real problems can be represented as Constraint Satisfaction Problem. However, a wide range of problems are over-constrained (no solution can be found without violating at least one constraint) or have multiple solutions and the goal is to find the solution having minimal cost according to a cost function. This kind of Constraint Satisfaction Problem are called Weighted Constraint Satisfaction Problem (WCSP).</p>
<h2 id="formal-definition">Formal definition</h2>

<p>A Weighted Constraint Network (WCN) is a triplet 

<math display="inline" id="Weighted_constraint_satisfaction_problem:0">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>X</mi>
   <mo>,</mo>
   <mi>C</mi>
   <mo>,</mo>
   <mi>k</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>X</ci>
    <ci>C</ci>
    <ci>k</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle X,C,k\rangle
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Weighted_constraint_satisfaction_problem:1">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is a finite set of variables, 

<math display="inline" id="Weighted_constraint_satisfaction_problem:2">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is a finite set of soft constraints and 

<math display="inline" id="Weighted_constraint_satisfaction_problem:3">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>k</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k>0
  </annotation>
 </semantics>
</math>


 is either a natural integer or 

<math display="inline" id="Weighted_constraint_satisfaction_problem:4">
 <semantics>
  <mi mathvariant="normal">∞</mi>
  <annotation-xml encoding="MathML-Content">
   <infinity></infinity>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \infty
  </annotation>
 </semantics>
</math>

.</p>

<p>Each soft constraint 

<math display="inline" id="Weighted_constraint_satisfaction_problem:5">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mi>S</mi>
   </msub>
   <mo>∈</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>S</ci>
    </apply>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{S}\in C
  </annotation>
 </semantics>
</math>

 involves an ordered set 

<math display="inline" id="Weighted_constraint_satisfaction_problem:6">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 of variables, called its scope, and is defined as a cost function from 

<math display="inline" id="Weighted_constraint_satisfaction_problem:7">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l(S)
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Weighted_constraint_satisfaction_problem:8">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mi>k</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <cn type="integer">0</cn>
    <ci>normal-…</ci>
    <ci>k</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle 0,...,k\rangle
  </annotation>
 </semantics>
</math>


 where 

<math display="inline" id="Weighted_constraint_satisfaction_problem:9">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l(S)
  </annotation>
 </semantics>
</math>

 is the set of possible instantiations of 

<math display="inline" id="Weighted_constraint_satisfaction_problem:10">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

. When an instantiation 

<math display="inline" id="Weighted_constraint_satisfaction_problem:11">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mo>∈</mo>
   <mrow>
    <mi>l</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>I</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I\in l(S)
  </annotation>
 </semantics>
</math>

 is given the cost 

<math display="inline" id="Weighted_constraint_satisfaction_problem:12">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, i.e., 

<math display="inline" id="Weighted_constraint_satisfaction_problem:13">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>c</mi>
     <mi>S</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>I</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>S</ci>
     </apply>
     <ci>I</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{S}(I)=k
  </annotation>
 </semantics>
</math>


, it is said forbidden. Otherwise it is permitted with the corresponding cost (0 being completely satisfactory).</p>

<p>In WCSP, specific subclass of Valued CSP (VCSP), costs are combined with the specific operator 

<math display="inline" id="Weighted_constraint_satisfaction_problem:14">
 <semantics>
  <mo>⊕</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">direct-sum</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \oplus
  </annotation>
 </semantics>
</math>

 defined as

<math display="block" id="Weighted_constraint_satisfaction_problem:15">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>∀</mo>
      <mi>α</mi>
     </mrow>
     <mo>,</mo>
     <mi>β</mi>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>k</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>α</mi>
     <mo>⊕</mo>
     <mi>β</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>m</mi>
     <mi>i</mi>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo>,</mo>
      <mrow>
       <mi>α</mi>
       <mo>+</mo>
       <mi>β</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <list>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>α</ci>
      </apply>
      <ci>β</ci>
     </list>
     <list>
      <cn type="integer">0</cn>
      <ci>normal-…</ci>
      <ci>k</ci>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <ci>α</ci>
      <ci>β</ci>
     </apply>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>i</ci>
      <ci>n</ci>
      <interval closure="open">
       <ci>k</ci>
       <apply>
        <plus></plus>
        <ci>α</ci>
        <ci>β</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\alpha,\beta\in\langle 0,...,k\rangle,\alpha\oplus\beta=min(k,\alpha+\beta)
  </annotation>
 </semantics>
</math>

. The partial inverse of 

<math display="inline" id="Weighted_constraint_satisfaction_problem:16">
 <semantics>
  <mo>⊕</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">direct-sum</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \oplus
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Weighted_constraint_satisfaction_problem:17">
 <semantics>
  <mo>⊖</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">symmetric-difference</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ominus
  </annotation>
 </semantics>
</math>

 defined by: if 

<math display="inline" id="Weighted_constraint_satisfaction_problem:18">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <mi>β</mi>
   <mo>≤</mo>
   <mi>α</mi>
   <mo><</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>β</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>α</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq\beta\leq\alpha<k
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="Weighted_constraint_satisfaction_problem:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>α</mi>
    <mo>⊖</mo>
    <mi>β</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>α</mi>
    <mo>-</mo>
    <mi>β</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">symmetric-difference</csymbol>
     <ci>α</ci>
     <ci>β</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>α</ci>
     <ci>β</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\ominus\beta=\alpha-\beta
  </annotation>
 </semantics>
</math>

 and if 

<math display="inline" id="Weighted_constraint_satisfaction_problem:20">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

.</p>

<p>Without any loss of generality, the existence of a nullary constraint 

<math display="inline" id="Weighted_constraint_satisfaction_problem:21">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{x}
  </annotation>
 </semantics>
</math>

 (a cost) as well as the presence of a unary constraint 

<math display="inline" id="Weighted_constraint_satisfaction_problem:22">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 for every variable 

<math display="inline" id="Weighted_constraint_satisfaction_problem:23">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mo>∈</mo>
   <mrow>
    <mi>l</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>I</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I\in l(S)
  </annotation>
 </semantics>
</math>


 is assumed.</p>

<p>The total cost of an instantiation 

<math display="inline" id="Weighted_constraint_satisfaction_problem:24">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>S</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{S}
  </annotation>
 </semantics>
</math>

 on a soft constraint 

<math display="inline" id="Weighted_constraint_satisfaction_problem:25">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

, includes the cost of 

<math display="inline" id="Weighted_constraint_satisfaction_problem:26">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>S</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{S}
  </annotation>
 </semantics>
</math>

 on 

<math display="inline" id="Weighted_constraint_satisfaction_problem:27">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi mathvariant="normal">∅</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <emptyset></emptyset>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{\emptyset}
  </annotation>
 </semantics>
</math>

 as well as the nullary cost 

<math display="inline" id="Weighted_constraint_satisfaction_problem:28">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>


 and the unary costs for 

<math display="inline" id="Weighted_constraint_satisfaction_problem:29">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 of the variables in 

<math display="inline" id="Weighted_constraint_satisfaction_problem:30">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

.</p>

<p>Considering a WCN, the usual (NP-hard) task of WCSP is to find a complete instantiation with a minimal cost.</p>
<h2 id="resolution-of-binaryternary-wcsps">Resolution of binary/ternary WCSPs</h2>
<h3 id="approach-with-cost-transfer-operations">Approach with cost transfer operations</h3>

<p>Node consistency (NC) and Arc consistency (AC), introduced for the Constraint Satisfaction Problem (CSP), have been studied later in the context of WCSP. Furthermore, several consistencies about the best form of arc consistency have been proposed: <strong>Full Directional Arc consistency (FDAC)</strong>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> <strong>Existencial Directional Arc consistency (EDAC)</strong>,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> <strong>Virtual Arc consistency (VAC)</strong><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and <strong>Optimal Soft Arc consistency (OSAC)</strong>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Algorithms enforcing such properties are based on Equivalence Preserving Transformations (EPT) that allow safe moves of costs among constraints. Three basic costs transfer operations are:</p>
<ul>
<li>Project : cost transfer from constraints to unary constraints</li>
<li>ProjectUnary : cost transfer from unary constraint to nullary constraint</li>
<li>Extend : cost transfer from unary constraint to constraint</li>
</ul>

<p><a href="File:TransfertsWCSP.pdf" title="wikilink">thumb|alt=Basic Equivalence Preserving Transformations|upright=5|center|Basic Equivalence Preserving Transformations.</a></p>

<p>The goal of Equivalence Preserving Transformations is to concentrate costs on the nullary constraint 

<math display="inline" id="Weighted_constraint_satisfaction_problem:31">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 and remove efficiently instantiations and values with a cost, additionned to 

<math display="inline" id="Weighted_constraint_satisfaction_problem:32">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   lb
  </annotation>
 </semantics>
</math>

, that is greater than or equal to the forbidden cost or the cost of the best solution found</p>
<h3 id="approach-without-cost-transfer-operations">Approach without cost transfer operations</h3>

<p>An alternative to cost transfer algorithms is the algorithm <strong>PFC-MRDAC</strong><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> which is a classical branch and bound algorithm that computes lower bound 

<math display="inline" id="Weighted_constraint_satisfaction_problem:33">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>u</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ub
  </annotation>
 </semantics>
</math>


 at each node of the search tree, that corresponds to an under-estimation of the cost of any solution that can be obtained from this node. The cost of the best solution found is 

<math display="inline" id="Weighted_constraint_satisfaction_problem:34">
 <semantics>
  <mrow>
   <mrow>
    <mi>l</mi>
    <mi>b</mi>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mi>u</mi>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <times></times>
     <ci>u</ci>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   lb\geq ub
  </annotation>
 </semantics>
</math>

. When 

<math display="inline" id="Weighted_constraint_satisfaction_problem:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mi>A</mi>
    <msup>
     <mi>C</mi>
     <mi>w</mi>
    </msup>
   </mrow>
   <mo>-</mo>
   <mrow>
    <mi>W</mi>
    <mi>S</mi>
    <mi>T</mi>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>C</ci>
      <ci>w</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>W</ci>
     <ci>S</ci>
     <ci>T</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   GAC^{w}-WSTR
  </annotation>
 </semantics>
</math>

, then the search tree from this node is pruned.</p>
<h2 id="resolution-of-n-ary-wcsps">Resolution of n-ary WCSPs</h2>

<p>Cost transfer algorithms have been shown to be particularly efficient to solve real-world problem when soft constraints are binary or ternary (maximal arity of constraints in the problem is equal to 2 or 3). For soft constraints of large arity, cost transfer becomes a serious issue because the risk of combinatorial explosion has to be controlled.</p>

<p>An algorithm, called <strong><span class="LaTeX">$GAC^w-WSTR$</span></strong>,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> has been proposed to enforce a weak version of the property Generalized Arc Consistency (GAC) on soft constraints defined extensionally by listing tuples and their costs. This algorithm combine two techniques, namely, <strong>Simple Tabular Reduction (STR)</strong><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> and cost transfer. Values that are no longer consistent with respect to GAC are identify and minimum costs of values are computed, which is particularly useful for performing efficiently projection operations that are required to establish GAC.</p>
<h2 id="benchmarks">Benchmarks</h2>

<p>Many real-world WCSP benchmarks are available on <strong><a class="uri" href="http://costfunction.org/en/benchmark">http://costfunction.org/en/benchmark</a></strong><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> and on <strong><a class="uri" href="http://www.cril.univ-artois.fr/~lecoutre/benchmarks.html">http://www.cril.univ-artois.fr/~lecoutre/benchmarks.html</a></strong>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Constraint_satisfaction_problem" title="wikilink">Constraint satisfaction problem</a></li>
<li><a href="Constraint_programming" title="wikilink">Constraint programming</a></li>
<li><a href="Preference-based_planning" title="wikilink">Preference-based planning</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Constraint_programming" title="wikilink">Category:Constraint programming</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">M. Cooper. Reduction operations in fuzzy or valued constraint satisfaction. Fuzzy Sets and Systems, 134(3):311–342, 2003.<a href="#fnref1">↩</a></li>
<li id="fn2">S. de Givry, F. Heras, M. Zytnicki, and J. Larrosa. Existential arc consistency: Getting closer to full arc consistency in weighted CSPs. In Proceedings of IJCAI’05, pages 84–89, 2005.<a href="#fnref2">↩</a></li>
<li id="fn3">M. Cooper, S. de Givry, M. Sanchez, T. Schiex, M. Zytnicki. Virtual Arc Consistency for Weighted CSP. In Proceedings of AAAI’08, pages 253-258, 2008.<a href="#fnref3">↩</a></li>
<li id="fn4">M. Cooper, S. de Givry, M. Sanchez, T. Schiex, M. Zytnicki, and T. Werner. Soft arc consistency revisited. Artificial Intelligence, 174(7-8):449–478, 2010.<a href="#fnref4">↩</a></li>
<li id="fn5">E.C. Freuder and R.J. Wallace. Partial constraint satisfaction. Artificial Intelligence, 58(1- 3):21–70, 1992.<a href="#fnref5">↩</a></li>
<li id="fn6">C. Lecoutre, N. Paris, O. Roussel, S. Tabary. Propagating Soft Table Constraints. In Proceedings of CP’12, pages 390-405, 2012.<a href="#fnref6">↩</a></li>
<li id="fn7">C. Lecoutre. STR2: Optimized simple tabular reduction for table constraint. Constraints, 16(4):341–371, 2011.<a href="#fnref7">↩</a></li>
<li id="fn8">The aims of this web site is to promote cost function network in providing Benchmark and teaching material, solver demo, link to articule about cost function used in the contexte of constraint programming.<a href="#fnref8">↩</a></li>
</ol>
</section>
</body>
</html>
