<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title offset="356">Let expression</title>
   <script type="text/javascript"
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js">
    </script>
</head>
<body>
<h1>Let expression</h1>
<hr/>
<p>In computer science, a <strong>"let" expression</strong> associates a <a href="Function_(computer_science)" title="wikilink">function</a> definition with a restricted <a href="Scope_(computer_science)" title="wikilink">scope</a>.</p>
<p>The <strong>"let" expression</strong> may also be defined in mathematics, where it associates a Boolean condition with a restricted scope.</p>
<p>The "let" expression may be considered as a <a href="Lambda_calculus" title="wikilink">Lambda abstraction</a> applied to a value. Within mathematics, a let expression may also be considered as a <a href="Logical_conjunction" title="wikilink">conjunction</a> of expressions, within an <a href="Universal_quantification" title="wikilink">existential quantifier</a> which restricts the scope of the variable.</p>
<p>The let expression is present in many functional languages to allow the local definition of expression, for use in defining another expression. The let-expression is present in some functional languages in two forms; let or "let rec". Let rec is an extension of the simple let expression which uses the <a href="fixed-point_combinator" title="wikilink">fixed-point combinator</a> to implement <a href="Recursion_(computer_science)" title="wikilink">recursion</a>.</p>
<h2 id="history">History</h2>
<p><a href="Dana_Scott" title="wikilink">Dana Scotts</a> <a href="Programming_Computable_Functions" title="wikilink">LCF language</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> was a stage in the evolution of lambda calculus into modern functional languages. This language introduced the let expression, which has appeared in most functional languages since that time.</p>
<p>The languages <a href="Scheme_(programming_language)" title="wikilink">Scheme</a>,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> <a href="ML_(programming_language)" title="wikilink">ML</a>, and more recently <a href="Haskell_(programming_language)" title="wikilink">Haskell</a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> have inherited let expressions from LCF.</p>
<p>State-full imperative languages such as <a class="uri" href="ALGOL" title="wikilink">ALGOL</a> and <a href="Pascal_(programming_language)" title="wikilink">Pascal</a> essentially implement a let expression, to implement restricted scope of functions, in block structures.</p>
<h2 id="description">Description</h2>
<p>A "let" expression defines a function or value for use in another expression. As well as being a construct used in many functional programming languages, it is a natural language construct often used in mathematical texts. It is an alternate syntactical construct for a where clause.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><p>Let expression</p></th>
<th style="text-align: left;"><p>Where clause</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Let</p>
<p><span class="LaTeX">$$a = 3$$</span> and</p>
<p><span class="LaTeX">$$b = 4$$</span> in</p>
<p><span class="LaTeX">$$\sqrt{a^2 + b^2}$$</span></p></td>
<td style="text-align: left;"><p><span class="LaTeX">$$\sqrt{a^2 + b^2}$$</span> where</p>
<p><span class="LaTeX">$$a = 3$$</span> and</p>
<p><span class="LaTeX">$$b = 4$$</span></p></td>
</tr>
</tbody>
</table>
<p>In both cases the whole construct is an expression whose value is 5. Like the <a href="Conditional_(computer_programming)" title="wikilink">if-then-else</a> the type returned by the expression is not necessarily Boolean.</p>
<p>A let expression comes in 4 main forms,</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><p>Form</p></th>
<th style="text-align: left;"><p>And</p></th>
<th style="text-align: left;"><p>Recursive</p></th>
<th style="text-align: left;"><p>Definition / Constraint</p></th>
<th style="text-align: left;"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Simple</p></td>
<td style="text-align: left;"><p>No</p></td>
<td style="text-align: left;"><p>No</p></td>
<td style="text-align: left;"><p>Definition</p></td>
<td style="text-align: left;"><p>Simple non recursive function definition.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>Recursive</p></td>
<td style="text-align: left;"><p>No</p></td>
<td style="text-align: left;"><p>Yes</p></td>
<td style="text-align: left;"><p>Definition</p></td>
<td style="text-align: left;"><p>Recursive function definition (implemented using the <a href="Fixed-point_combinator" title="wikilink">Y combinator</a>).</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>Mutual</p></td>
<td style="text-align: left;"><p>Yes</p></td>
<td style="text-align: left;"><p>Yes</p></td>
<td style="text-align: left;"><p>Definition</p></td>
<td style="text-align: left;"><p>Mutually recursive function definition.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>Mathematical</p></td>
<td style="text-align: left;"><p>Yes</p></td>
<td style="text-align: left;"><p>Yes</p></td>
<td style="text-align: left;"><p>Constraint</p></td>
<td style="text-align: left;"><p>Mathematical definition supporting a general Boolean let condition.</p></td>
</tr>
</tbody>
</table>
<p>In functional languages the <em>let</em> expression defines functions which may be called in the expression. The scope of the function name is limited to the let expression structure.</p>
<p>In mathematics, the let expression defines a condition, which is a constraint on the expression. The syntax may also support the declaration of existentially quantified variables local to the let expression.</p>
<p>The terminology, syntax and semantics vary from language to language. In <a href="Scheme_(programming_language)" title="wikilink">Scheme</a>, <em>let</em> is used for the simple form and <em>let rec</em> for the recursive form. In ML <em>let</em> marks only the start of a block of declarations with <em>fun</em> marking the start of the function definition. In Haskell, <em>let</em> may be mutually recursive, with the compiler figuring out what is needed.</p>
<h2 id="definition">Definition</h2>
<p>A <a href="Lambda_calculus#Lambda_terms" title="wikilink">lambda abstraction</a> represents a function without a name. This is a <a href="Deductive_lambda_calculus#Logical_inconsistency" title="wikilink">source of the inconsistency</a> in the definition of a lambda abstraction. However lambda abstractions may be composed to represent a function with a name. In this form the inconsistency is removed. The lambda term,</p>
<p><span class="LaTeX">$$(\lambda f.z)\ (\lambda x.y)$$</span></p>
<p>is equivalent to defining the function <span class="LaTeX">$f$</span> by <span class="LaTeX">$f\ x = y$</span> in the expression <span class="LaTeX">$z$</span>, which may be written as the <em>let</em> expression;</p>
<p><span class="LaTeX">$$\operatorname{let} f\ x = y \operatorname{in} z$$</span></p>
<p>The let expression is understandable as a natural language expression. The let expression represents the substitution of a variable for a value. The substitution rule describes the implications of equality as substitution.</p>
<h3 id="let-definition-in-mathematics">Let definition in mathematics</h3>
<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a> the <em>let</em> expression is described as the conjunction of expressions. In functional languages the let expression is also used to limit scope. In mathematics scope is described by quantifiers. The let expression is a conjunction within an existential quantifier.</p>
<p><span class="LaTeX">$$(\exists x E \and F) \iff \operatorname{let} x : E \operatorname{in} F$$</span></p>
<p>where <em>E</em> and <em>F</em> are of type Boolean.</p>
<p>The <em>let</em> expression allows the substitution to be applied to another expression. This substitution may be applied within a restricted scope, to a sub expression. The natural use of the let expression is in application to a restricted scope (called <a href="Lambda_lifting" title="wikilink">lambda dropping</a>). These rules define how the scope may be restricted;</p>
<p><span class="LaTeX">$$x \not \in \operatorname{FV}(E) \and x \in \operatorname{FV}(F) \implies \operatorname{let} x : G \operatorname{in} E\ F = E\  (\operatorname{let} x : G \operatorname{in} F)$$</span></p>
<p><span class="LaTeX">$$x \in \operatorname{FV}(E) \and x \not \in \operatorname{FV}(F) \implies \operatorname{let} x : G \operatorname{in} E\ F = (\operatorname{let} x : G \operatorname{in} E)\ F$$</span></p>
<p><span class="LaTeX">$$x \not \in \operatorname{FV}(E) \and x \not \in \operatorname{FV}(F) \implies \operatorname{let} x : G \operatorname{in} E\ F = E\ F$$</span></p>
<p>where <em>F</em> is <a href="#No_lifting_from_Boolean" title="wikilink">not of type Boolean</a>. From this definition the following standard definition of a let expression, as used in a functional language may be derived.</p>
<p><span class="LaTeX">$$x \not \in \operatorname{FV}(y) \implies (\operatorname{let} x : x = y \operatorname{in} z) = z[x := y] = (\lambda x.z)\ y$$</span></p>
<p>For simplicity the marker specifying the existential variable, <span class="LaTeX">$x :$</span>, will be omitted from the expression where it is clear from the context.</p>
<p><span class="LaTeX">$$x \not \in \operatorname{FV}(y) \implies (\operatorname{let} x = y \operatorname{in} z) = z[x := y] = (\lambda x.z)\ y$$</span></p>
<h4 id="derivation">Derivation</h4>
<p>To derive this result, first assume,</p>
<p><span class="LaTeX">$$x \not \in \operatorname{FV}(L)$$</span></p>
<p>then</p>
<p><span class="LaTeX">$$L\ (\operatorname{let} x : x = y \operatorname{in} z)$$</span></p>
<p><span class="LaTeX">$$\iff (\operatorname{let} x : x = y \operatorname{in} L\ z)$$</span></p>
<p><span class="LaTeX">$$\iff x = y \and L\ z$$</span></p>
<p>Using the rule of substitution,</p>
<p><span class="LaTeX">$$\iff x = y \and(L\ z)[x :=y]$$</span></p>
<p><span class="LaTeX">$$\iff x = y \and(L[x :=y]\ z[x :=y])$$</span></p>
<p><span class="LaTeX">$$\iff x = y \and L\ z[x :=y]$$</span></p>
<p><span class="LaTeX">$$\implies L\ z[x :=y]$$</span> so for all <em>L</em>,</p>
<p><span class="LaTeX">$$L \operatorname{let} x : x = y \operatorname{in} z \implies  L\ z[x :=y]$$</span> Let <span class="LaTeX">$L\ X = (X = K)$</span> where <em>K</em> is a new variable. then,</p>
<p><span class="LaTeX">$$(\operatorname{let} x : x = y \operatorname{in} z) = K \implies  z[x :=y] = K$$</span> So,</p>
<p><span class="LaTeX">$$\operatorname{let} x : x = y \operatorname{in} z = z[x :=y]$$</span></p>
<p>But from the mathematical interpretation of a beta reduction,</p>
<p><span class="LaTeX">$$(\lambda x.z)\ y = z[x :=y]$$</span></p>
<p>Here if y is a function of a variable x, it is not the same x as in z. Alpha renaming may be applied. So we must have,</p>
<p><span class="LaTeX">$$x \not \in \operatorname{FV}(y)$$</span> so,</p>
<p><span class="LaTeX">$$x \not \in \operatorname{FV}(y) \implies \operatorname{let} x : x = y \operatorname{in} z = (\lambda x.z)\ y$$</span></p>
<p>This result is represented in a functional language in an abbreviated form, where the meaning is unambiguous;</p>
<p><span class="LaTeX">$$x \not \in \operatorname{FV}(y) \implies (\operatorname{let} x = y \operatorname{in} z) = z[x := y] = (\lambda x.z)\ y$$</span></p>
<p>Here the variable <em>x</em> is implicitly recognised as both part of the equation defining x, and the variable in the existential quantifier.</p>
<h4 id="no-lifting-from-boolean">No lifting from Boolean</h4>
<p>A contradiction arises if E is defined by <span class="LaTeX">$E = \neg$</span>. In this case,</p>
<p><span class="LaTeX">$$x \not \in \operatorname{FV}(E) \and x \in \operatorname{FV}(F) \implies \operatorname{let} x : G \operatorname{in} E\ F = E\ (\operatorname{let} x : G \operatorname{in} F)$$</span></p>
<p>becomes,</p>
<p><span class="LaTeX">$$\operatorname{let} x : G \operatorname{in} \neg F = \neg\  (\operatorname{let} x : G 
\operatorname{in} F)$$</span></p>
<p>and using,</p>
<p><span class="LaTeX">$$(\exists x E \and F) \iff \operatorname{let} x : E \operatorname{in} F$$</span></p>
<p><span class="LaTeX">$$(\exists x G \and \neg F)  = \neg\ (\exists x G \and F)$$</span></p>
<p><span class="LaTeX">$$= (\exists x \neg G \or \neg F)$$</span></p>
<p>This is false if G is false. To avoid this contradiction <em>F</em> is not allowed to be of type Boolean. For Boolean <em>F</em> the correct statement of the dropping rule uses implication instead of equality,</p>
<p><span class="LaTeX">$$x \not \in \operatorname{FV}(E) \and x \in \operatorname{FV}(F) \implies (\operatorname{let} x : G \operatorname{in} E\ F \to E\ (\operatorname{let} x : G \operatorname{in} F))$$</span></p>
<p>It may appear strange that a different rule applies for Boolean than other types. The reason for this is that the rule,</p>
<p><span class="LaTeX">$$(\exists x E \and F) \iff \operatorname{let} x : E \operatorname{in} F$$</span></p>
<p>only applies where <em>F</em> is Boolean. The combination of the two rules creates a contradiction, so where one rule holds, the other does not.</p>
<h4 id="joining-let-expressions">Joining let expressions</h4>
<p>Let expressions may be defined with multiple variables,</p>
<p><span class="LaTeX">$$(\exists v \cdots \exists w \exists x E \and F) \iff \operatorname{let} v, \ldots ,w , x : E \operatorname{in} F$$</span></p>
<p>then it can be derived,</p>
<p><span class="LaTeX">$$x \not \in FV(E) \implies (\exists v \cdots \exists w \exists x E \and F) \iff (\exists v \cdots \exists w (E \and \exists x F))$$</span></p>
<p>so,</p>
<p><span class="LaTeX">$$x \not \in FV(E) \implies (\operatorname{let} v, \ldots, w, x : E \and F \operatorname{in} L \equiv \operatorname{let} v, \ldots, w: E \operatorname{in} \operatorname{let} x : F  \operatorname{in} L)$$</span></p>
<h3 id="laws-relating-lambda-calculus-and-let-expressions">Laws relating lambda calculus and let expressions</h3>
<p>The <a href="Deductive_lambda_calculus#Eta_reduction_as_mathematics" title="wikilink">Eta reduction</a> gives a rule for describing lambda abstractions. This rule along with the two laws derived above define the relationship between Lambda calculus and let expressions.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><p>Name</p></th>
<th style="text-align: left;"><p>Law</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Eta-reduction equivalence</p></td>
<td style="text-align: left;"><p><span class="LaTeX">$f\ x = y \equiv f = \lambda x.y$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>Let-Lambda equivalence</p></td>
<td style="text-align: left;"><p><span class="LaTeX">$f \not \in FV(E) \implies (\operatorname{let} f : f = E \operatorname{in} L \equiv (\lambda f.L)\ E)$</span> (where f is a variable name).</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>Let joining</p></td>
<td style="text-align: left;"><p><span class="LaTeX">$x \not \in FV(E) \implies (\operatorname{let} v, \ldots, w, x : E \and F \operatorname{in} L \equiv \operatorname{let} v, \ldots, w: E \operatorname{in} \operatorname{let} x : F  \operatorname{in} L)$</span></p></td>
</tr>
</tbody>
</table>
<h3 id="let-definition-defined-from-lambda-calculus">Let definition defined from Lambda calculus</h3>
<p>To avoid the <a href="#No_dropping_to_Boolean" title="wikilink">potential problems</a> associated with the <a href="#Let_definition_in_mathematics" title="wikilink">mathematical definition</a>, <a href="Dana_Scott" title="wikilink">Dana Scott</a> originally defined the <em>let</em> expression from Lambda calculus. This may be considered as the bottom up, or constructive, definition of the <em>let</em> expression, in contrast to the top down, or axiomatic mathematical definition.</p>
<p>The simple, non recursive <em>let</em> expression was defined as being <a href="syntactic_sugar" title="wikilink">syntactic sugar</a> for the lambda abstraction applied to a term. In that definition,</p>
<p><span class="LaTeX">$$(\operatorname{let}_s x = y \operatorname{in} z) \equiv (\lambda x.z)\ y$$</span></p>
<p>The simple <em>let</em> expression definition was then extended to allow recursion using the <a href="fixed-point_combinator" title="wikilink">fixed-point combinator</a>.</p>
<h4 id="fixed-point-combinator">Fixed-point combinator</h4>
<p>The <a href="fixed-point_combinator" title="wikilink">fixed-point combinator</a> may be represented by the expression,</p>
<p><span class="LaTeX">$$\lambda f.\operatorname{let} x = f\ x \operatorname{in} x$$</span></p>
<p>This representation may be converted into a lambda term. A lambda abstraction does not support reference to the variable name, in the applied expression, so <em>x</em> must be passed in as a parameter to <em>x</em>.</p>
<p><span class="LaTeX">$$\lambda f.\operatorname{let} x\ x = f\ (x\ x) \operatorname{in} x\ x$$</span></p>
<p>Using the eta reduction rule,</p>
<p><span class="LaTeX">$$f\ x = y \equiv f = \lambda x.y$$</span></p>
<p>gives,</p>
<p><span class="LaTeX">$$\lambda f.\operatorname{let} x = \lambda x.f\ (x\ x) \operatorname{in} x\ x$$</span></p>
<p>A let expression may be expressed as a lambda abstraction using,</p>
<p><span class="LaTeX">$$n \not \in FV(E) \to (\operatorname{let} n = E \operatorname{in} L \equiv (\lambda n.L)\ E)$$</span></p>
<p>gives,</p>
<p><span class="LaTeX">$$\lambda f.(\lambda x.x\ x)\ (\lambda x.f\ (x\ x))$$</span></p>
<p>This is possibly the simplest implementation of a fixed point combinator in lambda calculus. However one beta reduction gives the more symmetrical form of Curry's Y combinator.</p>
<p><span class="LaTeX">$$\lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))$$</span></p>
<h4 id="recursive-let-expression">Recursive let expression</h4>
<p>The recursive <em>let</em> expression called "let rec" is defined using the Y combinator for recursive let expressions.</p>
<p><span class="LaTeX">$$(\operatorname{let\ rec} x = y \operatorname{in} z) \equiv (\lambda x.z)\ (Y\ (\lambda x.y))$$</span></p>
<h4 id="mutually-recursive-let-expression">Mutually recursive let expression</h4>
<p>This approach is then generalized to support mutual recursion. A mutually recursive let expression may be composed by rearranging the expression to remove any and conditions. This is achieved by replacing multiple function definitions with a single function definition, which sets a list of variables equal to a list of expressions. A version of the Y combinator, called the <em>Y*</em> poly-variadic fix-point combinator <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> is then used to calculate fixed point of all the functions at the same time. The result is a mutually recursive implementation of the <em>let</em> expression.</p>
<h2 id="multiple-values">Multiple values</h2>
<p>A let expression may be used to represent a value that is a member of a set,</p>
<p><span class="LaTeX">$$\operatorname{let} x \in X \operatorname{in} x$$</span></p>
<p>Under function application, of one let expression to another,</p>
<p><span class="LaTeX">$$(\operatorname{let} x \in X \operatorname{in} x)\ (\operatorname{let} y \in Y \operatorname{in} y)$$</span></p>
<p><span class="LaTeX">$$= \operatorname{let} x \in X \and y \in Y \operatorname{in} x\ y$$</span></p>
<p><span class="LaTeX">$$= \operatorname{let} (x, y) \in X \times Y \operatorname{in} x\ y$$</span></p>
<p>But a different rule applies for applying the let expression to itself.</p>
<p><span class="LaTeX">$$(\operatorname{let} x \in X \operatorname{in} x)\ (\operatorname{let} x \in X \operatorname{in} x)$$</span></p>
<p><span class="LaTeX">$$= \operatorname{let} x \in X \operatorname{in} x\ x$$</span></p>
<p>There appear no simple rule for combining values. What is required is a general form of expression that represents a variable whose value is a member of a set of values. The expression should be based on the variable and the set.</p>
<p>Function application applied to this form should give another expression in the same form. In this way any expression on functions of multiple values may be treated as if it had one value.</p>
<p>It is not sufficient for the form to represent only the set of values. Each value must have a condition that determines when the expression takes the value. The resulting construct is a set of pairs of conditions and values, called a "value set". See <a href="narrowing_of_algebraic_value_sets" title="wikilink">narrowing of algebraic value sets</a>.</p>
<h2 id="rules-for-conversion-between-lambda-calculus-and-let-expressions">Rules for conversion between lambda calculus and let expressions</h2>
<p><a href="Metaprogramming" title="wikilink">Meta-functions</a> will be given that describe the conversion between <em>lambda</em> and <em>let</em> expressions. A meta-function is a function that takes a program as a parameter. The program is data for the meta-program. The program and the meta program are at different meta-levels.</p>
<p>The following conventions will be used to distinguish program from the meta program,</p>
<ul>
<li>Square brackets [] will be used to represent function application in the meta program.</li>
<li>Capital letters will be used for variables in the meta program. Lower case letters represent variables in the program.</li>
<li><span class="LaTeX">$\equiv$</span> will be used for equals in the meta program.</li>
</ul>
<p>For simplicity the first rule given that matches will be applied. The rules also assume that the lambda expressions have been pre-processed so that each lambda abstraction has a unique name.</p>
<p>The substitution operator is also used. The expression <span class="LaTeX">$L[G := S]$</span> means substitute every occurrence of <em>G</em> in <em>L</em> by <em>S</em> and return the expression. The definition used is extended to cover the substitution of expressions, from the definition given on the <a href="Lambda_calculus" title="wikilink">Lambda calculus</a> page. The matching of expressions should compare expressions for alpha equivalence (renaming of variables).</p>
<h3 id="conversion-from-lambda-to-let-expressions">Conversion from lambda to let expressions</h3>
<p>The following rules describe how to convert from a Lambda expression to a <em>let</em> expression, without altering the structure.</p>
<ol>
<li><span class="LaTeX">$\operatorname{de-lambda}[V] \equiv V$</span></li>
<li><span class="LaTeX">$\operatorname{de-lambda}[M\ N] \equiv \operatorname{de-lambda}[M]\ \operatorname{de-lambda}[N]$</span></li>
<li><span class="LaTeX">$\operatorname{de-lambda}[F = \lambda P.E] \equiv \operatorname{de-lambda}[F\ P = E]$</span></li>
<li><span class="LaTeX">$\operatorname{de-lambda}[E = F] \equiv \operatorname{de-lambda}[E] = \operatorname{de-lambda}[F]$</span></li>
<li><span class="LaTeX">$\operatorname{de-lambda}[(\lambda F.E) L] \equiv \operatorname{let-combine}[\operatorname{let} F : \operatorname{de-lambda}[F = L] \operatorname{in} E]$</span></li>
<li><span class="LaTeX">$V \not \in \operatorname{FV}[\lambda F.E] \to \operatorname{de-lambda}[\lambda F.E] \equiv \operatorname{let-combine}[\operatorname{let} V : \operatorname{de-lambda}[V\ F = E] \operatorname{in} V]$</span></li>
<li><span class="LaTeX">$V \ne W \to \operatorname{let-combine}[\operatorname{let} V : E \operatorname{in} \operatorname{let} W : F \operatorname{in} G] \equiv \operatorname{let} V, W : E \and F \operatorname{in} G$</span></li>
<li><span class="LaTeX">$\operatorname{let-combine}[\operatorname{let} V : E \operatorname{in} F] \equiv \operatorname{let} V : E \operatorname{in} F$</span></li>
</ol>
<p>Rule 6 creates a unique variable V, as a name for the function.</p>
<h4 id="example">Example</h4>
<p>For example the <a href="Fixed-point_combinator" title="wikilink">Y combinator</a>,</p>
<p><span class="LaTeX">$$\lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))$$</span> is converted to,</p>
<p><span class="LaTeX">$$\operatorname{let} p : p\ f = \operatorname{let} x : x\ q = f\ (q\ q) \operatorname{in} f\ (x\ x) \operatorname{in} p$$</span></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><p>Rule</p></th>
<th style="text-align: left;"><p>Lambda Expression</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>6</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-lambda}[\lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))]$</span></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$V \not \in \operatorname{FV}[\lambda F.E] \to \operatorname{de-lambda}[\lambda F.E]$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$V = p, F = f, E = \lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x)$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{let-combine}[\operatorname{let} V : \operatorname{de-lambda}[V\ F = E] \operatorname{in} V]$</span></p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>4</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;"><p><span class="LaTeX">$\operatorname{let-combine}[\operatorname{let} p : \operatorname{de-lambda}[p\ f = (\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))] \operatorname{in} p]$</span></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-lambda}[p\ f = (\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))]$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-lambda}[E = F]$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$E = p\ f, F = (\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-lambda}[E] = \operatorname{de-lambda}[F]$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-lambda}[p\ f] = \operatorname{de-lambda}[(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))]$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{let-combine}[\operatorname{let} p : \operatorname{de-lambda}[p\ f] = \operatorname{de-lambda}[(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))] \operatorname{in} p]$</span></p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>5</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;"><p><span class="LaTeX">$\operatorname{let-combine}[\operatorname{let} p : \operatorname{de-lambda}[p\ f] = \operatorname{de-lambda}[(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))] \operatorname{in} p]$</span></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-lambda}[(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))]$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-lambda}[(\lambda F.E) L]$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$F = x, E = f\ (x\ x), L = (\lambda x.f\ (x\ x))$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{let-combine}[\operatorname{let} F : \operatorname{de-lambda}[F = L] \operatorname{in} E]$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{let-combine}[\operatorname{let} x : \operatorname{de-lambda}[x = \lambda x.f\ (x\ x)] \operatorname{in} f\ (x\ x)]$</span></p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>3</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;"><p><span class="LaTeX">$\operatorname{let-combine}[\operatorname{let} p : \operatorname{de-lambda}[p\ f] = \operatorname{let-combine}[\operatorname{let} x : \operatorname{de-lambda}[x = \lambda x.f\ (x\ x)] \operatorname{in} f\ (x\ x)] \operatorname{in} p]$</span></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-lambda}[x = \lambda x.f\ (x\ x)]$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-lambda}[F = \lambda P.E]$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$F = x, P = x, E = f\ (x\ x)$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-lambda}[F\ P = E]$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-lambda}[x\ x = f\ (x\ x)]$</span></p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>9</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;"><p><span class="LaTeX">$\operatorname{let-combine}[\operatorname{let} p : \operatorname{de-lambda}[p\ f] = \operatorname{let-combine}[\operatorname{let} x : \operatorname{de-lambda}[x\ x = f\ (x\ x)] \operatorname{in} f\ (x\ x)] \operatorname{in} p]$</span></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{let-combine}[\operatorname{let} x : \operatorname{de-lambda}[x\ x = f\ (x\ x)] \operatorname{in} f\ (x\ x)]$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{let-combine}[Y]$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$Y = \operatorname{let} x : \operatorname{de-lambda}[x\ x = f\ (x\ x)] \operatorname{in} f\ (x\ x)$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$Y$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{let} x : \operatorname{de-lambda}[x\ x = f\ (x\ x)] \operatorname{in} f\ (x\ x)$</span></p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>9</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;"><p><span class="LaTeX">$\operatorname{let-combine}[\operatorname{let} p : \operatorname{de-lambda}[p\ f] = \operatorname{let} x : \operatorname{de-lambda}[x\ x = f\ (x\ x)] \operatorname{in} f\ (x\ x) \operatorname{in} p]$</span></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{let-combine}[Y]$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$Y = \operatorname{let} p : \operatorname{de-lambda}[p\ f = \operatorname{let} x : \operatorname{de-lambda}[x\ x = f\ (x\ x)] \operatorname{in} f\ (x\ x)] \operatorname{in} p$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$Y$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{let} p : p\ f = \operatorname{let} x : \operatorname{de-lambda}[x\ x = f\ (x\ x)] \operatorname{in} f\ (x\ x) \operatorname{in} p$</span></p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>4</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;"><p><span class="LaTeX">$\operatorname{let} p : \operatorname{de-lambda}[p\ f] = \operatorname{let} x : \operatorname{de-lambda}[x\ x = f\ (x\ x)] \operatorname{in} f\ (x\ x) \operatorname{in} p$</span></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-lambda}[x\ x = f\ (x\ x)]$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-lambda}[E = F]$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$E = x\ x, F = f\ (x\ x)$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-lambda}[E] = \operatorname{de-lambda}[F]$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-lambda}[x\ x] = \operatorname{de-lambda}[f\ (x\ x)]$</span></p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>2</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;"><p><span class="LaTeX">$\operatorname{let} p : \operatorname{de-lambda}[p\ f] = \operatorname{let} x : \operatorname{de-lambda}[x\ x] = \operatorname{de-lambda}[f\ (x\ x)] \operatorname{in} f\ (x\ x) \operatorname{in} p$</span></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-lambda}[x\ x], \operatorname{de-lambda}[f\ (x\ x)]$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-lambda}[p\ f], \operatorname{de-lambda}[M_1\ N_1], \operatorname{de-lambda}[M_2\ N_2],$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$M_1 = p, N_1 = f, M_2 = x, N_2 = x, M_3 = f, N_3 = x\ x$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-lambda}[M_1]\ \operatorname{de-lambda}[N_1], \operatorname{de-lambda}[M_2]\ \operatorname{de-lambda}[N_2], \operatorname{de-lambda}[M_3]\ \operatorname{de-lambda}[N_3]$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-lambda}[p]\ \operatorname{de-lambda}[f], \operatorname{de-lambda}[x]\ \operatorname{de-lambda}[x], \operatorname{de-lambda}[f]\ \operatorname{de-lambda}[x]\ \operatorname{de-lambda}[x]$</span></p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>1</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;"><p><span class="LaTeX">$\operatorname{let} p : \operatorname{de-lambda}[p]\ \operatorname{de-lambda}[f] = \operatorname{let} x : \operatorname{de-lambda}[x]\ \operatorname{de-lambda}[x] = \operatorname{de-lambda}[f]\ (\operatorname{de-lambda}[x]\ \operatorname{de-lambda}[x]) \operatorname{in} f\ (x\ x)] \operatorname{in} p$</span></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-lambda}[V]$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$V$</span></p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{let} p : p\ f = \operatorname{let} x : x\ x = f\ (x\ x) \operatorname{in} f\ (x\ x)] \operatorname{in} p$</span></p></td>
</tr>
</tbody>
</table>
<h3 id="conversion-from-let-to-lambda-expressions">Conversion from let to lambda expressions</h3>
<p>These rules reverse the conversion described above. They convert from a <em>let</em> expression to a Lambda expression, without altering the structure. Not all let expressions may be converted using these rules. The rules assume that the expressions are already arranged as if they had been generated by <em>de-lambda</em>.</p>
<ol>
<li><span class="LaTeX">$\operatorname{get-lambda}[F, G\ V = E] = \operatorname{get-lambda}[F, G = \lambda V.E]$</span></li>
<li><span class="LaTeX">$\operatorname{get-lambda}[F, F = E] = \operatorname{de-let}[E]$</span></li>
<li><span class="LaTeX">$\operatorname{de-let}[\lambda V.E] \equiv \lambda V.\operatorname{de-let}[E]$</span></li>
<li><span class="LaTeX">$\operatorname{de-let}[M\ N] \equiv \operatorname{de-let}[M]\ \operatorname{de-let}[N]$</span></li>
<li><span class="LaTeX">$\operatorname{de-let}[V] \equiv V$</span></li>
<li><span class="LaTeX">$V \not \in FV[\operatorname{get-lambda}[V, E]] \to \operatorname{de-let}[\operatorname{let} V : E \operatorname{in} V] \equiv \operatorname{get-lambda}[V, E]$</span></li>
<li><span class="LaTeX">$V \not \in FV[\operatorname{get-lambda}[V, E]] \to \operatorname{de-let}[\operatorname{let} V : E \operatorname{in} L] \equiv (\lambda V.\operatorname{de-let}[L])\ \operatorname{get-lambda}[V, E]$</span></li>
<li><span class="LaTeX">$W \not \in \operatorname{FV}[\operatorname{get-lambda}[V, E]] \to \operatorname{de-let}[\operatorname{let} V, W : E \and F \operatorname{in} G] \equiv \operatorname{de-let}[\operatorname{let} V : E \operatorname{in} \operatorname{let} W : F \operatorname{in} G]$</span></li>
<li><span class="LaTeX">$V \in \operatorname{FV}[\operatorname{get-lambda}[V, E]] \to \operatorname{de-let}[\operatorname{let} V : E \operatorname{in} L] \equiv \operatorname{de-let}[\operatorname{let} V : V\ V = \operatorname{get-lambda}[V, E][V:=V\ V] \operatorname{in} L[V:=V\ V]]$</span></li>
<li><span class="LaTeX">$W \in \operatorname{FV}[\operatorname{get-lambda}[V, E]] \to \operatorname{de-let}[\operatorname{let} V, W : E \and F \operatorname{in} L] \equiv \operatorname{de-let}[\operatorname{let} V: V\ W = \operatorname{get-lambda}[V, E][V:=V\ W] \operatorname{in} \operatorname{let} W: F[V:=V\ W] \operatorname{in} L[V:=V\ W]]$</span></li>
</ol>
<p>There is no exact structural equivalent in lambda calculus for <em>let</em> expressions that have free variables that are used recursively. In this case some addition of parameters is required. Rules 8 and 10 add these parameters.</p>
<p>Rules 8 and 10 are sufficient for two mutually recursive equations in the <em>let</em> expression. However they will not work for three or more mutually recursive equations. The general case needs an extra level of looping which makes the meta function a little more difficult. The rules that follow replace rules 8 and 10 in implementing the general case. Rules 8 and 10 have been left so that the simpler case may be studied first.</p>
<ol>
<li><em>lambda-form</em> - Convert the expression into a conjunction of expressions, each of the form <em>variable</em> = <em>expression</em>.
<ol>
<li><span class="LaTeX">$\operatorname{lambda-form}[G\ V = E] = \operatorname{lambda-form}[G = \lambda V.E]$</span></li>
<li><span class="LaTeX">$\operatorname{lambda-form}[E \and F] = \operatorname{lambda-form}[E] \and \operatorname{lambda-form}[F]$</span></li>
<li><span class="LaTeX">$\operatorname{lambda-form}[V = E] = V = E$</span> ...... where <em>V</em> is a variable.</li>
</ol></li>
<li><em>lift-vars</em> - Get the set of variables that need <em>X</em> as a parameter, because the expression has <em>X</em> as a free variable.
<ol>
<li><span class="LaTeX">$X \in \operatorname{FV}[E] \to \operatorname{lift-vars}[X, V = E] = \{V\}$</span></li>
<li><span class="LaTeX">$X \not \in \operatorname{FV}[E] \to \operatorname{lift-vars}[X, V = E] = \{\}$</span></li>
<li><span class="LaTeX">$\operatorname{lift-vars}[X, E \and F] = \operatorname{lift-vars}[X, E] \cup \operatorname{lift-vars}[X. F]$</span></li>
</ol></li>
<li><em>sub-vars</em> - For each variable in the set substitute it for the variable applied to X in the expression. This makes <em>X</em> a variable passed in as a parameter, instead of being a free variable in the right hand side of the equation.
<ol>
<li><span class="LaTeX">$\operatorname{sub-vars}[E, \{V\} \cup S, X] = \operatorname{sub-vars}[E[V:=V\ X], S, X]$</span></li>
<li><span class="LaTeX">$\operatorname{sub-vars}[E, \{\}, X] = E$</span></li>
</ol></li>
<li><em>de-let</em> - <a href="Lambda_lifting" title="wikilink">Lift</a> each condition in <em>E</em> so that <em>X</em> is not a free variable on the right hand side of the equation.
<ol>
<li><span class="LaTeX">$L = \operatorname{lambda-form}[E] \and S = \operatorname{lift-vars}[X, L] \to \operatorname{de-let}[\operatorname{let} V \ldots W, X : E \and F \operatorname{in} G]$</span></li>
</ol></li>
</ol>
<dl>
<dd><dl>
<dd><math> \equiv \operatorname{de-let}[\operatorname{let} V \ldots W: \operatorname{sub-vars}[L, S, X]
</math></dd>
</dl>
</dd>
</dl>
<p><code>\operatorname{in} \operatorname{let} \operatorname{sub-vars}[\operatorname{lambda-form}[F], S, X] \operatorname{in} \operatorname{sub-vars}[G, S, X]] </code></p>
<h4 id="examples">Examples</h4>
<p>For example the <em>let</em> expression obtained from the <a href="Fixed-point_combinator" title="wikilink">Y combinator</a>,</p>
<p><span class="LaTeX">$$\operatorname{let} p : p\ f = \operatorname{let} x : x\ q = f\ (q\ q) \operatorname{in} f\ (x\ x) \operatorname{in} p$$</span> is converted to,</p>
<p><span class="LaTeX">$$\lambda f.(\lambda x.f\ (x\ x))\ (\lambda q.f\ (q\ q))$$</span></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><p>Rule</p></th>
<th style="text-align: left;"><p>Lambda Expression</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>6</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[\operatorname{let} p : p\ f = \operatorname{let} x : x\ q = f\ (q\ q) \operatorname{in} f\ (x\ x) \operatorname{in} p]$</span></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[\operatorname{let} V : E \operatorname{in} V]$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$V = p, E = p\ f = \operatorname{let} x : x\ q = f\ (q\ q) \operatorname{in} f\ (x\ x)$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{get-lambda}[V, E]$</span></p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>1</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;"><p><span class="LaTeX">$\operatorname{get-lambda}[p, p\ f = \operatorname{let} x : x\ q = f\ (q\ q) \operatorname{in} f\ (x\ x)]$</span></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{get-lambda}[F, G\ V = E]$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$F = p, G = p, V = f, E = \operatorname{let} x : x\ q = f\ (q\ q) \operatorname{in} f\ (x\ x)$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{get-lambda}[F, G = \lambda V.E]$</span></p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>2</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;"><p><span class="LaTeX">$\operatorname{get-lambda}[p, p = \lambda f.\operatorname{let} x : x\ q = f\ (q\ q) \operatorname{in} f\ (x\ x)]$</span></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{get-lambda}[F, F = E]$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$F = p, E = \lambda f.\operatorname{let} x : x\ q = f\ (q\ q) \operatorname{in} f\ (x\ x)$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[E]$</span></p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>3</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[\lambda f.\operatorname{let} x : x\ q = f\ (q\ q) \operatorname{in} f\ (x\ x)]$</span></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[\lambda V.E]$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$V = f, E = \operatorname{let} x : x\ q = f\ (q\ q) \operatorname{in} f\ (x\ x)$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\lambda V.\operatorname{de-let}[E]$</span></p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>7</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;"><p><span class="LaTeX">$\lambda f.\operatorname{de-let}[\operatorname{let} x : x\ q = f\ (q\ q) \operatorname{in} f\ (x\ x)]$</span></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[\operatorname{let} x : x\ q = f\ (q\ q) \operatorname{in} f\ (x\ x)]$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$V \not \in FV[\operatorname{get-lambda}[V, E]] \to \operatorname{de-let}[\operatorname{let} V : E \operatorname{in} L]$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$V = x, E = x\ q = f\ (q\ q), L = f\ (x\ x)$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$(\lambda V.\operatorname{de-let}[L])\ \operatorname{get-lambda}[V, E]$</span></p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>4</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;"><p><span class="LaTeX">$(\lambda x.\operatorname{de-let}[f\ (x\ x)])\ \operatorname{get-lambda}[x, x\ q = f\ (q\ q)]$</span></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[f\ (x\ x)]$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[M\ N]$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$M = f, N = (x\ x)$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[M]\ \operatorname{de-let}[N]$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[f]\ \operatorname{de-let}[x\ x]$</span></p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>4</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;"><p><span class="LaTeX">$(\lambda x.\operatorname{de-let}[f]\ \operatorname{de-let}[x\ x])\ \operatorname{get-lambda}[x, x\ q = f\ (q\ q)]$</span></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[x\ x]$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[M\ N]$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$M = x, N = x$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[M]\ \operatorname{de-let}[N]$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[x]\ \operatorname{de-let}[x]$</span></p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>5</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;"><p><span class="LaTeX">$(\lambda x.\operatorname{de-let}[f]\ (\operatorname{de-let}[x]\ \operatorname{de-let}[x]))\ \operatorname{get-lambda}[x, x\ q = f\ (q\ q)]$</span></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[V]$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$V$</span></p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>1</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;"><p><span class="LaTeX">$(\lambda x.f\ (x\ x))\ \operatorname{get-lambda}[x, x\ q = f\ (q\ q)]$</span></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{get-lambda}[x, x\ q = f\ (q\ q)]$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{get-lambda}[F, G\ V = E]$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$F = x, G = x, V = q, E = f\ (q\ q)$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{get-lambda}[F, G = \lambda V.E]$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{get-lambda}[x, x = \lambda q.f\ (q\ q)]$</span></p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>2</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;"><p><span class="LaTeX">$(\lambda x.f\ (x\ x))\ \operatorname{get-lambda}[x, x = \lambda q.f\ (q\ q)]$</span></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{get-lambda}[x, x = \lambda q.f\ (q\ q)]$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{get-lambda}[F, F = E]$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$F = x, E = \lambda q.f\ (q\ q)$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[E]$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[\lambda q.f\ (q\ q)]$</span></p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>3</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;"><p><span class="LaTeX">$(\lambda x.f\ (x\ x))\ \operatorname{de-let}[\lambda q.f\ (q\ q)]$</span></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[\lambda q.f\ (q\ q)]$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[\lambda V.E]$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$V = q, E = f\ (q\ q)$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$\lambda V.\operatorname{de-let}[E]$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\lambda q.\operatorname{de-let}[f\ (q\ q)]$</span></p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>4</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;"><p><span class="LaTeX">$(\lambda x.f\ (x\ x))\ (\lambda q.\operatorname{de-let}[f\ (q\ q)])$</span></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[f\ (q\ q)]$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[M_1\ N_1]$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$M_1 = f, N_1 = q\ q$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[M_1]\ \operatorname{de-let}[N_1]$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[f]\ \operatorname{de-let}[q\ q]$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[M_2\ N_2]$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$M_2 = q, N_2 = q$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[q]\ \operatorname{de-let}[q]$</span></p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>5</p></td>
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;"><p><span class="LaTeX">$(\lambda x.f\ (x\ x))\ (\lambda q.\operatorname{de-let}[f]\ (\operatorname{de-let}[q]\ \operatorname{de-let}[q]))$</span></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[V]$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p><span class="LaTeX">$$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$V$</span></p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"><p><span class="LaTeX">$(\lambda x.f\ (x\ x))\ (\lambda q.f\ (q\ q))$</span></p></td>
</tr>
</tbody>
</table>
<p>For a second example take the lifted version of the <a href="Fixed-point_combinator" title="wikilink">Y combinator</a>,</p>
<p><span class="LaTeX">$$\operatorname{let}p, q : p\ f\ x = f\ (x\ x) \and q\ p\ f = (p\ f)\ (p\ f) \operatorname{in} q\ p$$</span> is converted to,</p>
<p><span class="LaTeX">$$(\lambda p.(\lambda q.q\ p)\ \lambda p.\lambda f.(p\ f)\ (p\ f))\ \lambda f.\lambda x.f\ (x\ x)$$</span></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><p>Rule</p></th>
<th style="text-align: left;"><p>Lambda Expression</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>8</p></td>
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[\operatorname{let}p, q : p\ f\ x = f\ (x\ x) \and q\ p\ f = (p\ f)\ (p\ f) \operatorname{in} q\ p]$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>7</p></td>
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{de-let}[\operatorname{let} p : p\ f\ x = f\ (x\ x) \operatorname{in} \operatorname{let} q : q\ p\ f = (p\ f)\ (p\ f) \operatorname{in} q\ p]$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>1, 2</p></td>
<td style="text-align: left;"><p><span class="LaTeX">$(\lambda p.\operatorname{de-let}[\operatorname{let} q : q\ p\ f = (p\ f)\ (p\ f) \operatorname{in} q\ p])\ \operatorname{get-lambda}[p, p\ f\ x = f\ (x\ x)]$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>7, 4, 5</p></td>
<td style="text-align: left;"><p><span class="LaTeX">$(\lambda p.\operatorname{de-let}[\operatorname{let} q : q\ p\ f = (p\ f)\ (p\ f) \operatorname{in} q\ p])\ \lambda f.\lambda x.f\ (x\ x)$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>1, 2</p></td>
<td style="text-align: left;"><p><span class="LaTeX">$(\lambda p.(\lambda q.q\ p)\ \operatorname{get-lambda}[q, q\ p\ f = (p\ f)\ (p\ f)])\ \lambda f.\lambda x.f\ (x\ x)$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"><p><span class="LaTeX">$(\lambda p.(\lambda q.q\ p)\ \lambda p.\lambda f.(p\ f)\ (p\ f))\ \lambda f.\lambda x.f\ (x\ x)$</span></p></td>
</tr>
</tbody>
</table>
<p>For a third example the translation of,</p>
<p><span class="LaTeX">$$\operatorname{let} x: x\ f = f\ (x\ f) \operatorname{in} x$$</span> is,</p>
<p><span class="LaTeX">$$(\lambda x.x\ x)\ (\lambda x.\lambda f.f\ (x\ x\ f))$$</span></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><p>Rule</p></th>
<th style="text-align: left;"><p>Lambda Expression</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>9</p></td>
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{let} x : x\ f = f\ (x\ f) \operatorname{in} x$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>1</p></td>
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{let} x : \operatorname{get-lambda}[x, x\ f = f\ (x\ f)][x:=x\ x] \operatorname{in} x[x:=x\ x]$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>2</p></td>
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{let} x : \operatorname{get-lambda}[x, x = \lambda f.f\ (x\ f)][x:=x\ x] \operatorname{in} x\ x$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{let} x : (x = \lambda f.f\ (x\ f))[x:=x\ x] \operatorname{in} x\ x$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>7</p></td>
<td style="text-align: left;"><p><span class="LaTeX">$\operatorname{let} x : (x\ x = \lambda f.f\ (x\ x\ f)) \operatorname{in} x\ x$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>1</p></td>
<td style="text-align: left;"><p><span class="LaTeX">$(\lambda x.x\ x)\ \operatorname{get-lambda}[x, x\ x = \lambda f.f\ (x\ x\ f)]$</span></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>2</p></td>
<td style="text-align: left;"><p><span class="LaTeX">$(\lambda x.x\ x)\ \operatorname{get-lambda}[x, x = \lambda x.\lambda f.f\ (x\ x\ f)]$</span></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"><p><span class="LaTeX">$(\lambda x.x\ x)\ (\lambda x.\lambda f.f\ (x\ x\ f))$</span></p></td>
</tr>
</tbody>
</table>
<h2 id="key-people">Key people</h2>
<ul>
<li><a href="Dana_Scott" title="wikilink">Dana Scott</a></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Scope_(computer_science)" title="wikilink">Scope (computer science)</a></li>
<li><a href="Lambda_lifting" title="wikilink">Lambda lifting</a></li>
<li><a href="Fixed-point_combinator" title="wikilink">Fixed-point combinator</a></li>
<li><a href="Lambda_calculus" title="wikilink">Lambda calculus</a></li>
<li><a href="Curry's_paradox" title="wikilink">Curry's paradox</a></li>
<li><a href="Deductive_lambda_calculus" title="wikilink">Deductive lambda calculus</a></li>
<li><a href="Constraint_logic_programming" title="wikilink">Constraint logic programming</a></li>
<li><a href="Narrowing_of_algebraic_value_sets" title="wikilink">Narrowing of algebraic value sets</a></li>
</ul>
<h2 id="references">References</h2>
<p>"</p>
<p><a href="Category:Lambda_calculus" title="wikilink">Category:Lambda calculus</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">"PCF is a programming language for computable functions, based on LCF, Scott’s logic of computable functions" . <em>Programming Computable Functions</em> is used by . It is also referred to as <em>Programming with Computable Functions</em> or <em>Programming language for Computable Functions</em>.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
