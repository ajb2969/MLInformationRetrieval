<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1736">Monad (functional programming)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Monad (functional programming)</h1>
<hr>In [[functional programming]], a '''monad''' is a structure that represents [[computation]]s defined as sequences of steps: a [[Type (computer science)|type]] with a monad structure defines what it means to [[Block (programming)|chain operations]], or nest [[Function (computer science)|functions]] of that type together. This allows the programmer to build [[Pipeline (software)|pipelines]] that process data in steps, in which each action is [[Decorator pattern|decorated]] with additional processing rules provided by the monad.<ref name="RealWorldHaskell">{{cite book | last1 = O'Sullivan | first1 = Bryan | last2 = Goerzen | first2 = John | last3 = Stewart | first3 = Don | url =http://book.realworldhaskell.org/ | title = Real World Haskell | publisher = O'Reilly | date = 2009 |at = chapter 14 }}</ref> As such, monads have been described as "p<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</hr></body></html>
<body>

<p>rogrammable semicolons"; a semicolon is the operator used to chain together individual <a href="statement_(computer_programming)" title="wikilink">statements</a> in many <a href="imperative_programming" title="wikilink">imperative programming</a> languages,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> thus the expression implies that extra code will be executed between the statements in the pipeline. Monads have also been explained with a <a href="physical_metaphor" title="wikilink">physical metaphor</a> as <a href="assembly_line" title="wikilink">assembly lines</a>, where a conveyor belt transports data between functional units that transform it one step at a time.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> They can also be seen as a functional <a href="design_pattern" title="wikilink">design pattern</a> to build <a href="Parameterized_type" title="wikilink">generic types</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p><a href="Purely_functional" title="wikilink">Purely functional</a> programs can use monads to structure procedures that include sequenced operations like those found in <a href="structured_programming" title="wikilink">structured programming</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Many common programming concepts can be described in terms of a monad structure, including <a href="Side_effect_(computer_science)" title="wikilink">side effects</a> such as <a class="uri" href="input/output" title="wikilink">input/output</a>, variable <a href="Assignment_(computer_science)" title="wikilink">assignment</a>, <a href="exception_handling" title="wikilink">exception handling</a>, <a class="uri" href="parsing" title="wikilink">parsing</a>, <a href="Nondeterministic_programming" title="wikilink">nondeterminism</a>, <a href="Concurrency_(computer_science)" title="wikilink">concurrency</a>, and <a href="continuation" title="wikilink">continuations</a>. This allows these concepts to be defined in a purely functional manner, without major extensions to the language's semantics. Languages like <a href="Haskell_(programming_language)" title="wikilink">Haskell</a> provide monads in the standard core, allowing programmers to reuse large parts of their formal definition and apply in many different libraries the same interfaces for combining functions.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>Formally, a monad consists of a <a href="type_constructor" title="wikilink">type constructor</a> <em>M</em> and two operations, <em>bind</em> and <em>return</em> (where <em>return</em> is often also called <em>unit</em>):</p>
<ul>
<li>The <em>return</em> operation takes a value from a plain type and puts it into a monadic container using the constructor, creating a <em>monadic value</em>.</li>
<li>The <em>bind</em> operation takes as its arguments a monadic value and a function from a plain type to a monadic value, and returns a new monadic value.</li>
</ul>

<p>The operations must fulfill several properties to allow the correct composition of <em>monadic</em> functions (i.e. functions that use values from the monad as their arguments or return value). Because a monad can insert additional operations around a program's domain logic, monads can be considered a sort of <a href="aspect-oriented_programming" title="wikilink">aspect-oriented programming</a>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> The <a href="domain_logic" title="wikilink">domain logic</a> can be defined by the application programmer in the pipeline, while required aside <a href="bookkeeping_code" title="wikilink">bookkeeping</a> operations can be handled by a pre-defined monad built in advance.</p>

<p>The name and concept comes from <a href="category_theory" title="wikilink">category theory</a>, where <a href="Monad_(category_theory)" title="wikilink">monads</a> are one particular kind of <a class="uri" href="functor" title="wikilink">functor</a>, a mapping between categories; although the term <em>monad</em> in functional programming contexts is usually used with a meaning corresponding to that of the term <em><a href="strong_monad" title="wikilink">strong monad</a></em> in category theory.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="history">History</h2>

<p>The <a href="APL_(programming_language)" title="wikilink">APL</a> and <a href="J_(programming_language)" title="wikilink">J</a> programming languages—which tend toward being purely functional—use the term <em>monad</em> as a shorthand for "function taking a single parameter" (as opposed to "dyad," or "function taking two parameters"). Though this predates use of the term in Haskell by nearly thirty years, the meaning is entirely different.</p>

<p>The concept of monad programming appeared in the 1980s in the programming language <a href="Opal_programming_language" title="wikilink">Opal</a> even though it was called "commands" and never formally specified.</p>

<p><a href="Eugenio_Moggi" title="wikilink">Eugenio Moggi</a> first described the general use of monads to structure programs in 1991.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Several people built on his work, including programming language researchers <a href="Philip_Wadler" title="wikilink">Philip Wadler</a> and <a href="Simon_Peyton_Jones" title="wikilink">Simon Peyton Jones</a> (both of whom were involved in the specification of <a href="Haskell_(programming_language)" title="wikilink">Haskell</a>). Early versions of Haskell used a problematic "lazy list" model for I/O, and Haskell 1.3 introduced monads as a more flexible way to combine I/O with <a href="lazy_evaluation" title="wikilink">lazy evaluation</a>.</p>

<p>In addition to I/O, programming language researchers and Haskell library designers have successfully applied monads to topics including parsers and programming language interpreters. The concept of monads along with the Haskell do-notation for them has also been generalized to form <a href="applicative_functor" title="wikilink">applicative functors</a> and <a href="Arrow_(computer_science)" title="wikilink">arrows</a>.</p>

<p>For a long time, Haskell and its derivatives have been the only major users of monads in programming. There also exist formulations in <a href="Scheme_(programming_language)" title="wikilink">Scheme</a>, <a class="uri" href="Perl" title="wikilink">Perl</a>, <a href="Python_(programming_language)" title="wikilink">Python</a>, <a href="Racket_(programming_language)" title="wikilink">Racket</a>, <a class="uri" href="Clojure" title="wikilink">Clojure</a> and <a href="Scala_(programming_language)" title="wikilink">Scala</a>, and monads have been an option in the design of a new <a href="ML_(programming_language)" title="wikilink">ML</a> standard. Recently <a href="F_Sharp_(programming_language)" title="wikilink">F#</a> has included a feature called <a href="computation_expressions" title="wikilink">computation expressions</a> or <em>workflows</em>, which are an attempt to introduce monadic constructs within a syntax more palatable to those programmers whose only prior experience has been with imperative languages.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="motivating-examples">Motivating examples</h2>

<p>The <a href="Haskell_(programming_language)" title="wikilink">Haskell programming language</a> is a functional language that makes heavy use of monads, and includes <a href="syntactic_sugar" title="wikilink">syntactic sugar</a> to make monadic composition more convenient. All of the code samples in this article are written in <a href="Haskell_(programming_language)" title="wikilink">Haskell</a> unless noted otherwise.</p>

<p>We demonstrate two common examples given when introducing monads: the <em>Maybe</em> monad and the <em>I/O</em> monad. Monads are of course not restricted to the Haskell language, though: the second set of examples shows the <em>Writer</em> monad in <a class="uri" href="JavaScript" title="wikilink">JavaScript</a>.</p>
<h3 id="the-maybe-monad">The Maybe monad</h3>

<p>Consider the <a href="option_type" title="wikilink">option type</a> <em>Maybe a</em>, representing a value that is either a single value of type <em>a</em>, or no value at all. To distinguish these, we have two <a href="algebraic_data_type" title="wikilink">algebraic data type</a> constructors: <code>Just t</code>, containing the value <code>t</code>, or <code>Nothing</code>, containing no value.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Maybe</span> t <span class="fu">=</span> <span class="dt">Just</span> t <span class="fu">|</span> <span class="dt">Nothing</span></code></pre></div>

<p>We would like to be able to use this type as a simple sort of <a href="checked_exception" title="wikilink">checked exception</a>: at any point in a computation, the computation may fail, which causes the rest of the computation to be skipped and the final result to be <code>Nothing</code>. If all steps of the calculation succeed, the final result is <code>Just x</code> for some value <code>x</code>.</p>

<p>In the following example, <code>add</code> is a function that takes two arguments of type <em>Maybe Int</em>, and returns a result of the same type. If both <code>mx</code> and <code>my</code> have <code>Just</code> values, we want to return <code>Just</code> their sum; but if either <code>mx</code> or <code>my</code> is <code>Nothing</code>, we want to return <code>Nothing</code>. If we naively attempt to write functions with this kind of behavior, we'll end up with a nested series of "if <code>Nothing</code> then <code>Nothing</code> else do something with the <code>x</code> in <code>Just x</code>" cases that will quickly become unwieldy:<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
add mx my <span class="fu">=</span>
  <span class="kw">case</span> mx <span class="kw">of</span>
    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
    <span class="dt">Just</span> x  <span class="ot">-&gt;</span> <span class="kw">case</span> my <span class="kw">of</span>
                 <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
                 <span class="dt">Just</span> y  <span class="ot">-&gt;</span> <span class="dt">Just</span> (x <span class="fu">+</span> y)</code></pre></div>

<p>To alleviate this, we can define operations for chaining these computations together. The <em>bind</em> binary operator (<code>&gt;&gt;=</code>) chains the results of one computation that could fail, into a function that chooses another computation that could fail. If the first argument is <code>Nothing</code>, the second argument (the function) is ignored and the entire operation simply fails. If the first argument is <code>Just x</code>, we pass <code>x</code> to the function to get a new <em>Maybe</em> value, which may or may not result in a <code>Just</code> value.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&gt;&gt;=) ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b
<span class="dt">Nothing</span>  <span class="fu">&gt;&gt;=</span> _  <span class="fu">=</span>  <span class="dt">Nothing</span>    <span class="co">-- A failed computation returns Nothing</span>
(<span class="dt">Just</span> x) <span class="fu">&gt;&gt;=</span> f  <span class="fu">=</span>  f x        <span class="co">-- Applies function f to value x</span></code></pre></div>

<p>We already have a value constructor that returns a value without affecting the computation's additional state: <code>Just</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">return<span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
return x <span class="fu">=</span> <span class="dt">Just</span> x       <span class="co">-- Wraps value x, returning a value of type (Maybe a)</span></code></pre></div>

<p>We can then write the example as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
add mx my <span class="fu">=</span>             <span class="co">-- Adds two values of type (Maybe Int), where each input value can be Nothing</span>
  mx <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span>         <span class="co">-- Extracts value x if mx is not Nothing</span>
    my <span class="fu">&gt;&gt;=</span> (\y <span class="ot">-&gt;</span>       <span class="co">-- Extracts value y if my is not Nothing</span>
      return (x <span class="fu">+</span> y)))  <span class="co">-- Wraps value (x+y), returning the sum as a value of type (Maybe Int)</span></code></pre></div>

<p>Using some additional <a href="syntactic_sugar" title="wikilink">syntactic sugar</a> known as <a class="uri" href="do-notation" title="wikilink">do-notation</a>, the example can be written as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
add mx my <span class="fu">=</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> mx
  y <span class="ot">&lt;-</span> my
  return (x <span class="fu">+</span> y)</code></pre></div>

<p>Since this type of operation is quite common, there is a standard function in Haskell (<code>liftM2</code>) to take two monadic values (here: two Maybes) and combine their contents (two numbers) using another function (addition), making it possible to write the previous example as</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
add <span class="fu">=</span> liftM2 (<span class="fu">+</span>)</code></pre></div>

<p>(Writing out the definition of liftM2 yields the code presented above in do-notation.)</p>
<h3 id="the-io-monad">The I/O monad</h3>

<p>In a <a href="purely_functional" title="wikilink">purely functional</a> language, such as Haskell, functions cannot have any externally visible side effects as part of the function semantics. Although a function cannot directly cause a side effect, it can construct a value <em>describing</em> a desired side effect, that the caller should apply at a convenient time.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> In the Haskell notation, a value of type <em>IO a</em> represents an action that, when performed, produces a value of type <em>a</em>.</p>

<p>We can think of a value of type <code>IO</code> as an <em>action</em> that takes as its argument the current state of the world, and will return a new world where the state has been changed according to the function's return value. For example, the functions <code>doesFileExist</code> and <code>removeFile</code> in the standard Haskell library have the following types</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">doesFileExist ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span>
<span class="ot">removeFile ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</code></pre></div>

<p>So, one can think of <code>removeFile</code> as a function that, given a <code>FilePath</code>, returns an <code>IO</code> <em>action</em>; this action will ensure that the world, in this case the underlying file system, won't have a file named by that <code>FilePath</code> when it gets <em>executed</em>. Here, the <code>IO</code> internal value is of type <code>()</code> which means that the caller does not care about any other outcomes. On the other hand, in <code>doesFileExist</code>, the function returns an <code>IO</code> <em>action</em> which wraps a boolean value, <code>True</code> or <code>False</code>; this conceptually represents a new state of the world where the caller knows for certain whether that <code>FilePath</code> is present in the file system or not at the time of the <em>action</em> is performed. The state of the world managed in this way can be passed from action to action, thus defining a series of actions which will be applied in order as steps of state changes. This process is similar to how a <a href="temporal_logic" title="wikilink">temporal logic</a> represents the passage of time using only <a href="Declarative_programming" title="wikilink">declarative</a> propositions. The following example clarifies in detail how this chaining of actions occurs in a program, again using Haskell.</p>

<p>We would like to be able to describe all of the basic types of I/O operations, e.g. write text to <a href="standard_output" title="wikilink">standard output</a>, read text from standard input, read and write files, send data over networks, etc. In addition, we need to be able to compose these primitives to form larger programs. For example, we would like to be able to write:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  putStrLn <span class="st">"What is your name?"</span>
  name <span class="ot">&lt;-</span> getLine
  putStrLn (<span class="st">"Nice to meet you, "</span> <span class="fu">++</span> name <span class="fu">++</span> <span class="st">"!"</span>)</code></pre></div>

<p>How can we formalize this intuitive notation? To do this, we need to be able to perform some basic operations with I/O actions:</p>
<ul>
<li>We should be able to sequence two I/O operations together. In Haskell, this is written as an infix operator <code>&gt;&gt;</code>, so that <code>putStrLn "abc" &gt;&gt; putStrLn "def"</code> is an I/O action that prints two lines of text to the console. The type of <code>&gt;&gt;</code> is <em>IO a → IO b → IO b</em>, meaning that the operator takes two I/O operations and returns a third that sequences the two together and returns the value of the second.</li>
<li>We should have an I/O action which does <em>nothing</em>. That is, it returns a value but has no side effects. In Haskell, this action constructor is called <code>return</code>; it has type <em>a → IO a</em>.</li>
<li>More subtly, we should be able to determine our next action based on the results of previous actions. To do this, Haskell has an operator <code>&gt;&gt;=</code> (pronounced <em>bind</em>) with type <em>IO a → (a → IO b) → IO b</em>. That is, the operand on the left is an I/O action that returns a value of type <code>a</code>; the operand on the right is a function that can pick an I/O action based on the value produced by the action on the left. The resulting combined action, when performed, performs the first action, then evaluates the function with the first action's return value, then performs the second action, and finally returns the second action's value.</li>
</ul>
<dl>
<dd>An example of the use of this operator in Haskell would be <code>getLine &gt;&gt;= putStrLn</code>, which reads a single line of text from standard input and echos it to standard output. Note that the first operator, <code>&gt;&gt;</code>, is just a special case of this operator in which the return value of the first action is ignored and the selected second action is always the same.
</dd>
</dl>

<p>It is not necessarily obvious that the three preceding operations, along with a suitable primitive set of I/O operations, allow us to define <em>any program action whatsoever</em>, including data transformations (using <a href="lambda_expressions" title="wikilink">lambda expressions</a>), if/then control flow, and looping control flows (using recursion). We can write the above example as one long expression:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span>
  putStrLn <span class="st">"What is your name?"</span> <span class="fu">&gt;&gt;</span> 
  getLine <span class="fu">&gt;&gt;=</span> \name <span class="ot">-&gt;</span>
  putStrLn (<span class="st">"Nice to meet you, "</span> <span class="fu">++</span> name <span class="fu">++</span> <span class="st">"!"</span>)</code></pre></div>

<p>The pipeline structure of the <em>bind</em> operator ensures that the <em>getLine</em> and <em>putStrLn</em> operations get evaluated only once and in the given order, so that the side-effects of extracting text from the input stream and writing to the output stream are correctly handled in the functional pipeline. This remains true even if the language performs <a href="Out-of-order_execution" title="wikilink">out-of-order</a> or <a href="lazy_evaluation" title="wikilink">lazy evaluation</a> of functions.</p>

<p>Clearly, there is some common structure between the I/O definitions and the Maybe definitions, even though they are different in many ways. Monads are an abstraction upon the structures described above, and many similar structures, that finds and exploits the commonalities. The general monad concept includes any situation where the programmer wants to carry out a purely functional computation while a related computation is carried out on the side.</p>
<h2 id="formal-definition">Formal definition</h2>

<p>A monad is a construction that, given an underlying <a href="type_system" title="wikilink">type system</a>, embeds a corresponding type system (called the <em>monadic type system</em>) into it (that is, each monadic type acts as the underlying type). This monadic type system preserves all significant aspects of the underlying type system, while adding features particular to the monad.</p>

<p>The usual formulation of a monad for programming is known as a <a href="Kleisli_triple" title="wikilink">Kleisli triple</a>, and has the following components:</p>
<ol>
<li>A <em>type constructor</em> that defines, for every underlying type, how to obtain a corresponding monadic type. In Haskell's notation, the name of the monad represents the type constructor. If <em>M</em> is the name of the monad and <em>t</em> is a data type, then <em>M t</em> is the corresponding type in the monad.</li>
<li>A <em>unit function</em> that injects a value in an underlying type to a value in the corresponding monadic type. The unit function has the polymorphic type <em>t→M t</em>. The result is normally the "simplest" value in the corresponding type that completely preserves the original value (simplicity being understood appropriately to the monad). In Haskell, this function is called <code>return</code> due to the way it is used in the do-notation described later.</li>
<li>A <em>binding operation</em> of polymorphic type <em>(M t)→(t→M u)→(M u)</em>, which Haskell represents by the <a href="infix_notation" title="wikilink">infix</a> operator <code>&gt;&gt;=</code>. Its first argument is a value in a monadic type, its second argument is a function that maps from the underlying type of the first argument to another monadic type, and its result is in that other monadic type. Typically, the binding operation can be understood as having four stages:
<ol>
<li>The monad-related structure on the first argument is "pierced" to expose any number of values in the underlying type t.</li>
<li>The given function is applied to all of those values to obtain values of type (M u).</li>
<li>The monad-related structure on those values is also pierced, exposing values of type u.</li>
<li>Finally, the monad-related structure is reassembled over all of the results, giving a single value of type (M u).</li>
</ol></li>
</ol>

<p>Given a type constructor <em>M</em>, in most contexts, a value of type <em>M a</em> can be thought of as an action that returns a value of type <em>a</em>. The <em>return</em> operation takes a value from a plain type <em>a</em> and puts it into a monadic container of type <em>M a</em>; the <em>bind</em> operation chains a monadic value of type <em>M a</em> with a function of type <em>a → M b</em> to create a monadic value of type <em>M b</em>.</p>
<h3 id="monad-laws">Monad laws</h3>

<p>For a monad to behave correctly, the definitions must obey a few axioms, together called the monad laws.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> The ≡ symbol indicates equivalence between two Haskell expressions in the following text.</p>
<ul>
<li><em>return</em> acts approximately as a <a href="neutral_element" title="wikilink">neutral element</a> of <code>&gt;&gt;=</code>, in that:
<ul>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(return x) <span class="fu">&gt;&gt;=</span> f   ≡   f x</code></pre></div></li>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">m <span class="fu">&gt;&gt;=</span> return   ≡   m</code></pre></div></li>
</ul></li>
<li>Binding two functions in succession is the same as binding one function that can be determined from them:
<ul>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(m <span class="fu">&gt;&gt;=</span> f) <span class="fu">&gt;&gt;=</span> g   ≡   m <span class="fu">&gt;&gt;=</span> ( \x <span class="ot">-&gt;</span> (f x <span class="fu">&gt;&gt;=</span> g) )</code></pre></div></li>
</ul></li>
</ul>

<p>The axioms can also be expressed using expressions in <a href="#do-notation" title="wikilink">do-block style</a>:</p>
<ul>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span> { f x }   ≡   <span class="kw">do</span> { v <span class="ot">&lt;-</span> return x; f v }</code></pre></div></li>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span> { m }   ≡   <span class="kw">do</span> { v <span class="ot">&lt;-</span> m; return v }</code></pre></div></li>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span> { x <span class="ot">&lt;-</span> m; y <span class="ot">&lt;-</span> f x; g y }   ≡   <span class="kw">do</span> { y <span class="ot">&lt;-</span> <span class="kw">do</span> { x <span class="ot">&lt;-</span> m; f x }; g y }</code></pre></div></li>
</ul>

<p>or using the monadic composition operator,</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(f <span class="fu">&gt;=&gt;</span> g) x <span class="fu">=</span> (f x) <span class="fu">&gt;&gt;=</span> g</code></pre></div>
<dl>
<dd>
</dd>
</dl>
<ul>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">return <span class="fu">&gt;=&gt;</span> g   ≡   g</code></pre></div></li>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f <span class="fu">&gt;=&gt;</span> return   ≡   f</code></pre></div></li>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(f <span class="fu">&gt;=&gt;</span> g) <span class="fu">&gt;=&gt;</span> h   ≡   f <span class="fu">&gt;=&gt;</span> (g <span class="fu">&gt;=&gt;</span> h)</code></pre></div></li>
</ul>
<h3 id="fmap-and-join">fmap and join</h3>

<p>Although Haskell defines monads in terms of the <em>return</em> and <em>bind</em> functions, it is also possible to define a monad in terms of <em>return</em> and two other operations, <em>join</em> and <em>fmap</em>. This formulation fits more closely with the original definition of monads in category theory. The <em>fmap</em> operation, with type (<em>t</em>→<em>u</em>) → M <em>t</em>→M <em>u</em>,<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> takes a function between two types and produces a function that does the "same thing" to values in the monad. The <em>join</em> operation, with type M (M <em>t</em>)→M <em>t</em>, "flattens" two layers of monadic information into one.</p>

<p>The two formulations are related as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap f m <span class="fu">=</span> m <span class="fu">&gt;&gt;=</span> (return <span class="fu">.</span> f)
join n <span class="fu">=</span> n <span class="fu">&gt;&gt;=</span> id

m <span class="fu">&gt;&gt;=</span> g   ≡   join (fmap g m)</code></pre></div>

<p>Here, m has the type M <em>t</em>, n has the type M (M <em>r</em>), f has the type <em>t</em> → <em>u</em>, and g has the type t → M <em>v</em>, where <em>t</em>, <em>r</em>, <em>u</em> and <em>v</em> are underlying types.</p>

<p>The fmap function is defined for any <a class="uri" href="functor" title="wikilink">functor</a> in the category of types and functions, not just for monads. It is expected to satisfy the functor laws:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap id   ≡   id
fmap (f <span class="fu">.</span> g)   ≡   (fmap f) <span class="fu">.</span> (fmap g)</code></pre></div>

<p>The <em>return</em> function characterizes <a href="pointed_functor" title="wikilink">pointed functors</a> in the same category, by accounting for the ability to "lift" values into the functor. It should satisfy the following law:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">return <span class="fu">.</span> f ≡ fmap f <span class="fu">.</span> return</code></pre></div>

<p>In addition, the <em>join</em> function characterizes monads:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">join <span class="fu">.</span> fmap join     ≡ join <span class="fu">.</span> join
join <span class="fu">.</span> fmap return   ≡ join <span class="fu">.</span> return <span class="fu">=</span> id
join <span class="fu">.</span> fmap (fmap f) ≡ fmap f <span class="fu">.</span> join</code></pre></div>
<h3 id="additive-monads">Additive monads </h3>

<p>An <strong>additive monad</strong> is a monad endowed with a monadic zero <em>mzero</em> and a binary operator <em>mplus</em> satisfying the <a class="uri" href="monoid" title="wikilink">monoid</a> laws, with the monadic zero as unit. The operator <em>mplus</em> has type <em>M t</em> → <em>M t</em> → <em>M t</em> (where <em>M</em> is the monad constructor and <em>t</em> is the underlying data type), satisfies the <a href="associative_law" title="wikilink">associative law</a> and has the zero as both left and right identity. That is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(a <span class="ot">`mplus`</span> b) <span class="ot">`mplus`</span> c   <span class="fu">=</span>   a <span class="ot">`mplus`</span> (b <span class="ot">`mplus`</span> c)
m <span class="ot">`mplus`</span> mzero           ≡   mzero <span class="ot">`mplus`</span> m           ≡    m</code></pre></div>

<p>Thus, an additive monad is also a monoid. For &gt;&gt;=, on the other hand, mzero acts as a null-element. Just as multiplying a number by 0 results in 0, binding <em>mzero</em> with any function produces the zero for the result type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">mzero <span class="fu">&gt;&gt;=</span> f               ≡   mzero</code></pre></div>

<p>Similarly, binding any <em>m</em> with a function that always returns a zero results in a zero</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">m <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> mzero)       ≡   mzero</code></pre></div>

<p>Intuitively, the zero represents a value in the monad that has only monad-related structure and no values from the underlying type. In the Maybe monad, "Nothing" is a zero. In the List monad, "[]" (the empty list) is a zero.</p>
<h2 id="syntactic-sugar-do-notation">Syntactic sugar: <code>do</code>-notation </h2>

<p>Although there are times when it makes sense to use the <em>bind</em> operator <code>&gt;&gt;=</code> directly in a program, it is more typical to use a format called <em>do-notation</em> (<em>perform-notation</em> in <a class="uri" href="OCaml" title="wikilink">OCaml</a>, <em>computation expressions</em> in <a href="F_Sharp_(programming_language)" title="wikilink">F#</a>), that mimics the appearance of imperative languages. The compiler translates do-notation to expressions involving <code>&gt;&gt;=</code>. For example, the following code:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">a <span class="fu">=</span> <span class="kw">do</span> x <span class="ot">&lt;-</span> [<span class="dv">3</span><span class="fu">..</span><span class="dv">4</span>]
       [<span class="dv">1</span><span class="fu">..</span><span class="dv">2</span>]
       return (x, <span class="dv">42</span>)</code></pre></div>

<p>is transformed during compilation into:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">a <span class="fu">=</span> [<span class="dv">3</span><span class="fu">..</span><span class="dv">4</span>] <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">2</span>] <span class="fu">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> return (x, <span class="dv">42</span>)))</code></pre></div>

<p>It is helpful to see the implementation of the list monad, and to know that concatMap maps a function over a list and concatenates (flattens) the resulting lists:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> [] <span class="kw">where</span>
  m <span class="fu">&gt;&gt;=</span> f  <span class="fu">=</span> concat (map f m)
  return x <span class="fu">=</span> [x]
  fail s   <span class="fu">=</span> []</code></pre></div>

<p>Therefore, the following transformations hold and all the following expressions are equivalent:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">a <span class="fu">=</span> [<span class="dv">3</span><span class="fu">..</span><span class="dv">4</span>] <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">2</span>] <span class="fu">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> return (x, <span class="dv">42</span>)))
a <span class="fu">=</span> [<span class="dv">3</span><span class="fu">..</span><span class="dv">4</span>] <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> concatMap (\_ <span class="ot">-&gt;</span> return (x, <span class="dv">42</span>)) [<span class="dv">1</span><span class="fu">..</span><span class="dv">2</span>] )
a <span class="fu">=</span> [<span class="dv">3</span><span class="fu">..</span><span class="dv">4</span>] <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> [(x,<span class="dv">42</span>),(x,<span class="dv">42</span>)] )
a <span class="fu">=</span> concatMap (\x <span class="ot">-&gt;</span> [(x,<span class="dv">42</span>),(x,<span class="dv">42</span>)] ) [<span class="dv">3</span><span class="fu">..</span><span class="dv">4</span>]
a <span class="fu">=</span> [(<span class="dv">3</span>,<span class="dv">42</span>),(<span class="dv">3</span>,<span class="dv">42</span>),(<span class="dv">4</span>,<span class="dv">42</span>),(<span class="dv">4</span>,<span class="dv">42</span>)] </code></pre></div>

<p>Notice that the list <code>[1..2]</code> is not used. The lack of a left-pointing arrow, translated into a binding to a function that ignores its argument, indicates that only the monadic structure is of interest, not the values inside it, e.g. for a state monad this might be used for changing the state without producing any more result values. The do-block notation can be used with any monad as it is simply syntactic sugar for <code>&gt;&gt;=</code>.</p>

<p>The following definitions for safe division for values in the Maybe monad are also equivalent:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">x <span class="fu">//</span> y <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> x  <span class="co">-- Extract the values "inside" x and y, if there are any.</span>
  b <span class="ot">&lt;-</span> y
  <span class="kw">if</span> b <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dt">Nothing</span> <span class="kw">else</span> <span class="dt">Just</span> (a <span class="fu">/</span> b)

x <span class="fu">//</span> y <span class="fu">=</span> x <span class="fu">&gt;&gt;=</span> (\a <span class="ot">-&gt;</span> y <span class="fu">&gt;&gt;=</span> (\b <span class="ot">-&gt;</span> <span class="kw">if</span> b <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dt">Nothing</span> <span class="kw">else</span> <span class="dt">Just</span> (a <span class="fu">/</span> b)))</code></pre></div>

<p>A similar example in F# using a computation expression:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> readNum () =
  <span class="kw">let</span> s = Console<span class="kw">.</span><span class="dt">ReadLine</span>()
  <span class="kw">let</span> succ,v = Int32<span class="kw">.</span><span class="dt">TryParse</span>(s)
  <span class="kw">if</span> (succ) <span class="kw">then</span> <span class="dt">Some</span>(v) <span class="kw">else</span> <span class="dt">None</span>

<span class="kw">let</span> secure_div = 
  maybe { 
    <span class="kw">let</span>! x = readNum()
    <span class="kw">let</span>! y = readNum()
    <span class="kw">if</span> (y = <span class="dv">0</span>) 
    <span class="kw">then</span> <span class="dt">None</span>
    <span class="kw">else</span> return (x / y)
  }</code></pre></div>

<p>The syntactic sugar of the maybe block would get translated internally to the following expression:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml">maybe.<span class="dt">Delay</span>(<span class="kw">fun</span> () -&gt;
  maybe.<span class="dt">Bind</span>(readNum(), <span class="kw">fun</span> x -&gt;
    maybe.<span class="dt">Bind</span>(readNum(), <span class="kw">fun</span> y -&gt;
      <span class="kw">if</span> (y=<span class="dv">0</span>) <span class="kw">then</span> <span class="dt">None</span> <span class="kw">else</span> maybe.<span class="dt">Return</span>(x / y))))</code></pre></div>
<h2 id="generic-monadic-functions">Generic monadic functions</h2>

<p>Given values produced by safe division, we might want to carry on doing calculations without having to check manually if they are <code>Nothing</code> (i.e. resulted from an attempted division by zero). We can do this using a "<a href="Lift_(mathematics)" title="wikilink">lifting</a>" function, which we can define not only for <code>Maybe</code> but for arbitrary monads. In Haskell this is called <code>liftM2</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">liftM2 ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m c
liftM2 op mx my <span class="fu">=</span> <span class="kw">do</span>
    x <span class="ot">&lt;-</span> mx
    y <span class="ot">&lt;-</span> my
    return (op x y)</code></pre></div>

<p>Recall that arrows in a type <a href="Currying#Definition" title="wikilink">associate to the right</a>, so <code>liftM2</code> is a function that takes a binary function as an argument and returns another binary function. The type signature says: If <code>m</code> is a monad, we can "lift" any binary function into it. For example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(.*.) ::</span> (<span class="dt">Monad</span> m, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m a
x <span class="fu">.*.</span> y <span class="fu">=</span> liftM2 (<span class="fu">*</span>) x y</code></pre></div>

<p>defines an operator <code>(.*.)</code> which multiplies two numbers, unless one of them is <code>Nothing</code> (in which case it again returns <code>Nothing</code>). The advantage here is that we need not dive into the details of the implementation of the monad; if we need to do the same kind of thing with another function, or in another monad, using <code>liftM2</code> makes it immediately clear what is meant (see <a href="Code_reuse" title="wikilink">Code reuse</a>).</p>

<p>Mathematically, the liftM2 operator is defined by:</p>

<p>

<math display="block" id="Monad_(functional_programming):0">
 <semantics>
  <mrow>
   <mtext>liftM2</mtext>
   <mo>:</mo>
   <mo>∀</mo>
   <mi>M</mi>
   <mo>:</mo>
   <mtext>monad</mtext>
   <mo rspace="5.3pt">,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>A</mi>
     <mn>1</mn>
    </msub>
    <mo>→</mo>
    <msub>
     <mi>A</mi>
     <mn>2</mn>
    </msub>
    <mo>→</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mpadded width="+1.7pt">
    <mi>M</mi>
   </mpadded>
   <msub>
    <mi>A</mi>
    <mn>1</mn>
   </msub>
   <mo>→</mo>
   <mpadded width="+1.7pt">
    <mi>M</mi>
   </mpadded>
   <msub>
    <mi>A</mi>
    <mn>2</mn>
   </msub>
   <mo>→</mo>
   <mpadded width="+1.7pt">
    <mi>M</mi>
   </mpadded>
   <mi>R</mi>
   <mo>=</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>liftM2</mtext>
    <ci>normal-:</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">M</csymbol>
    <ci>normal-:</ci>
    <mtext>monad</mtext>
    <ci>normal-,</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-→</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">M</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-→</ci>
    <csymbol cd="unknown">M</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-→</ci>
    <csymbol cd="unknown">M</csymbol>
    <csymbol cd="unknown">R</csymbol>
    <eq></eq>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{liftM2}\colon\forall M\colon\text{monad},\;(A_{1}\to A_{2}\to R)\to M\,A%
_{1}\to M\,A_{2}\to M\,R=
  </annotation>
 </semantics>
</math>



<math display="inline" id="Monad_(functional_programming):1">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mi>p</mi>
   <mo>↦</mo>
   <msub>
    <mi>m</mi>
    <mn>1</mn>
   </msub>
   <mo>↦</mo>
   <msub>
    <mi>m</mi>
    <mn>2</mn>
   </msub>
   <mo>↦</mo>
   <mpadded width="+2.8pt">
    <mtext>bind</mtext>
   </mpadded>
   <mpadded width="+2.8pt">
    <msub>
     <mi>m</mi>
     <mn>1</mn>
    </msub>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>↦</mo>
    <mpadded width="+2.8pt">
     <mtext>bind</mtext>
    </mpadded>
    <mpadded width="+2.8pt">
     <msub>
      <mi>m</mi>
      <mn>2</mn>
     </msub>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>a</mi>
      <mn>2</mn>
     </msub>
     <mo>↦</mo>
     <mpadded width="+2.8pt">
      <mtext>return</mtext>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>o</mi>
      <mpadded width="+1.7pt">
       <mi>p</mi>
      </mpadded>
      <mpadded width="+1.7pt">
       <msub>
        <mi>a</mi>
        <mn>1</mn>
       </msub>
      </mpadded>
      <msub>
       <mi>a</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">o</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">1</cn>
    </apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">2</cn>
    </apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <mtext>bind</mtext>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">1</cn>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <mtext>bind</mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <cn type="integer">2</cn>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <mtext>return</mtext>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">o</csymbol>
       <csymbol cd="unknown">p</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   op\mapsto m_{1}\mapsto m_{2}\mapsto\text{bind}\;m_{1}\;(a_{1}\mapsto\text{bind%
}\;m_{2}\;(a_{2}\mapsto\text{return}\;(op\,a_{1}\,a_{2})))
  </annotation>
 </semantics>
</math>

</p>
<h2 id="other-examples">Other examples</h2>
<h3 id="identity-monad">Identity monad</h3>

<p>The simplest monad is the identity monad, which attaches no information to values.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Id</span> t <span class="fu">=</span> t
return x <span class="fu">=</span> x
x <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f x</code></pre></div>

<p>A do-block in this monad performs <a href="Variable_(programming)" title="wikilink">variable</a> substitution; <code>do {x &lt;- 2; return (3*x)}</code> results in 6.</p>

<p>From the category theory point of view, the identity monad is derived from the adjunction between <a href="identity_functor" title="wikilink">identity functors</a>.</p>
<h3 id="collections">Collections</h3>

<p>Some familiar <a href="Collection_(computing)" title="wikilink">collection</a> types, including <a href="Linked_list" title="wikilink">lists</a>, <a href="Set_(computer_science)" title="wikilink">sets</a>, and <a href="multiset" title="wikilink">multisets</a>, are monads. The definition for lists is given here.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- "return" constructs a one-item list.</span>
return x <span class="fu">=</span> [x]
<span class="co">-- "bind" concatenates the lists obtained by applying f to each item in list xs.</span>
xs <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> concat (map f xs)
<span class="co">-- The zero object is an empty list.</span>
mzero <span class="fu">=</span> []</code></pre></div>

<p><a href="List_comprehension" title="wikilink">List comprehensions</a> are a special application of the list monad. For example, the list comprehension <code>[ 2*x | x &lt;- [1..n], isOkay x]</code> corresponds to the computation in the list monad <code>do {x &lt;- [1..n]; if isOkay x then return (2*x) else mzero;}</code>.</p>

<p>The notation of list comprehensions is similar to the <a href="set-builder_notation" title="wikilink">set-builder notation</a>, but sets can't be made into a monad, since there's a restriction on the type of computation to be comparable for equality, whereas a monad does not put any constraints on the types of computations. Actually, the Set is a <strong>restricted monad</strong>.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> The monads for collections naturally represent <a href="Nondeterministic_algorithm" title="wikilink">nondeterministic computation</a>. The list (or other collection) represents all the possible results from different nondeterministic paths of computation at that given time. For example, when one executes <code>x &lt;- [1,2,3,4,5]</code>, one is saying that the variable <code>x</code> can non-deterministically take on any of the values of that list. If one were to return <code>x</code>, it would evaluate to a list of the results from each path of computation. Notice that the bind operator above follows this theme by performing <code>f</code> on each of the current possible results, and then it concatenates the result lists together.</p>

<p>Statements like <code>if condition x y then return () else mzero</code> are also often seen; if the condition is true, the non-deterministic choice is being performed from one dummy path of computation, which returns a value we are not assigning to anything; however, if the condition is false, then the <code>mzero = []</code> monad value non-deterministically chooses from 0 values, effectively terminating that path of computation. Other paths of computations might still succeed. This effectively serves as a "guard" to enforce that only paths of computation that satisfy certain conditions can continue. So collection monads are very useful for solving logic puzzles, Sudoku, and similar problems.</p>

<p>In a language with <a href="lazy_evaluation" title="wikilink">lazy evaluation</a>, like <a href="Haskell_(programming_language)" title="wikilink">Haskell</a>, a list is evaluated only to the degree that its elements are requested: for example, if one asks for the first element of a list, only the first element will be computed. With respect to usage of the list monad for non-deterministic computation that means that we can non-deterministically generate a lazy list of all results of the computation and ask for the first of them, and only as much work will be performed as is needed to get that first result. The process roughly corresponds to backtracking: a path of computation is chosen, and then if it fails at some point (if it evaluates <code>mzero</code>), then it <a href="Backtracking" title="wikilink">backtracks</a> to the last branching point, and follows the next path, and so on. If the second element is then requested, it again does just enough work to get the second solution, and so on. So the list monad is a simple way to implement a backtracking algorithm in a lazy language.</p>

<p>From the category theory point of view, collection monads are derived from <a href="Adjoint_functors" title="wikilink">adjunctions</a> between a <a href="free_functor" title="wikilink">free functor</a> and an underlying functor between the <a href="category_of_sets" title="wikilink">category of sets</a> and a <a href="category_of_monoids" title="wikilink">category of monoids</a>. Taking different types of monoids, we obtain different types of collections, as in the table below:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Type of collections</p></th>
<th style="text-align: left;">
<p>Type of monoids</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>list</p></td>
<td style="text-align: left;">
<p>monoid</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>finite <a class="uri" href="multiset" title="wikilink">multiset</a></p></td>
<td style="text-align: left;">
<p><a href="commutative_monoid" title="wikilink">commutative monoid</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>finite set</p></td>
<td style="text-align: left;">
<p><a class="uri" href="idempotent" title="wikilink">idempotent</a> commutative monoid</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>finite permutation</p></td>
<td style="text-align: left;">
<p><a class="uri" href="idempotent" title="wikilink">idempotent</a> non-commutative monoid</p></td>
</tr>
</tbody>
</table>
<h3 id="state-monads">State monads</h3>

<p>A state monad allows a programmer to attach state information of any type to a calculation. Given any value type, the corresponding type in the state monad is a function which accepts a state, then outputs a new state (of type <code>s</code>) along with a return value (of type <code>t</code>).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">State</span> s t <span class="fu">=</span> s <span class="ot">-&gt;</span> (t, s)</code></pre></div>

<p>Note that this monad, unlike those already seen, takes a type parameter, the type of the state information. The monad operations are defined as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- "return" produces the given value without changing the state.</span>
return x <span class="fu">=</span> \s <span class="ot">-&gt;</span> (x, s)
<span class="co">-- "bind" modifies m so that it applies f to its result.</span>
m <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> \r <span class="ot">-&gt;</span> <span class="kw">let</span> (x, s) <span class="fu">=</span> m r <span class="kw">in</span> (f x) s</code></pre></div>

<p>Useful state operations include:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">get <span class="fu">=</span> \s <span class="ot">-&gt;</span> (s, s) <span class="co">-- Examine the state at this point in the computation.</span>
put s <span class="fu">=</span> \_ <span class="ot">-&gt;</span> ((), s) <span class="co">-- Replace the state.</span>
modify f <span class="fu">=</span> \s <span class="ot">-&gt;</span> ((), f s) <span class="co">-- Update the state</span></code></pre></div>

<p>Another operation applies a state monad to a given initial state:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runState ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, s)
runState t s <span class="fu">=</span> t s</code></pre></div>

<p>do-blocks in a state monad are sequences of operations that can examine and update the state data.</p>

<p>Informally, a state monad of state type <em>S</em> maps the type of return values <em>T</em> into functions of type 

<math display="inline" id="Monad_(functional_programming):2">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>→</mo>
   <mrow>
    <mi>T</mi>
    <mo>×</mo>
    <mi>S</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>S</ci>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\rightarrow T\times S
  </annotation>
 </semantics>
</math>

, where <em>S</em> is the underlying state. The <em>return</em> function is simply:</p>

<p>

<math display="block" id="Monad_(functional_programming):3">
 <semantics>
  <mrow>
   <mtext>return</mtext>
   <mo>:</mo>
   <mrow>
    <mi>T</mi>
    <mo>→</mo>
    <mi>S</mi>
    <mo>→</mo>
    <mrow>
     <mi>T</mi>
     <mo>×</mo>
     <mi>S</mi>
    </mrow>
    <mo>=</mo>
    <mi>t</mi>
    <mo>↦</mo>
    <mi>s</mi>
    <mo>↦</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo>,</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <mtext>return</mtext>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <ci>T</ci>
      <ci>S</ci>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>S</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <share href="#.cmml">
      </share>
      <ci>s</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <share href="#.cmml">
      </share>
      <interval closure="open">
       <ci>t</ci>
       <ci>s</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{return}\colon T\rightarrow S\rightarrow T\times S=t\mapsto s\mapsto(t,s)
  </annotation>
 </semantics>
</math>

 The <em>bind</em> function is:</p>

<p>

<math display="block" id="Monad_(functional_programming):4">
 <semantics>
  <mrow>
   <mtext>bind</mtext>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>→</mo>
    <mi>T</mi>
    <mo>×</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo>→</mo>
    <mi>S</mi>
    <mo>→</mo>
    <msup>
     <mi>T</mi>
     <mo>′</mo>
    </msup>
    <mo>×</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>S</mi>
   <mo>→</mo>
   <msup>
    <mi>T</mi>
    <mo>′</mo>
   </msup>
   <mo>×</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>bind</mtext>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">T</csymbol>
     <times></times>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>T</ci>
      <ci>normal-′</ci>
     </apply>
     <times></times>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">S</csymbol>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>T</ci>
     <ci>normal-′</ci>
    </apply>
    <times></times>
    <csymbol cd="unknown">S</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{bind}\colon(S\rightarrow T\times S)\rightarrow(T\rightarrow S\rightarrow
T%
^{\prime}\times S)\rightarrow S\rightarrow T^{\prime}\times S
  </annotation>
 </semantics>
</math>



<math display="inline" id="Monad_(functional_programming):5">
 <semantics>
  <mrow>
   <mrow>
    <mi></mi>
    <mo lspace="7.5pt">=</mo>
    <mi>m</mi>
    <mo>↦</mo>
    <mi>k</mi>
    <mo>↦</mo>
    <mi>s</mi>
    <mo>↦</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+5pt">
       <mi>k</mi>
      </mpadded>
      <mpadded width="+5pt">
       <mi>t</mi>
      </mpadded>
      <msup>
       <mi>s</mi>
       <mo>′</mo>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mrow>
    <mrow>
     <mpadded width="+2.8pt">
      <mtext>where</mtext>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo>,</mo>
      <msup>
       <mi>s</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>m</mi>
     </mpadded>
     <mi>s</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <csymbol cd="latexml">absent</csymbol>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <share href="#.cmml">
      </share>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <share href="#.cmml">
      </share>
      <ci>s</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <ci>k</ci>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>s</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <mtext>where</mtext>
      <interval closure="open">
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>s</ci>
        <ci>normal-′</ci>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ =m\mapsto k\mapsto s\mapsto(k\ t\ s^{\prime})\quad\text{where}\;(t,s^{\prime%
})=m\,s
  </annotation>
 </semantics>
</math>

.</p>

<p>From the category theory point of view, a state monad is derived from the adjunction between the product functor and the exponential functor, which exists in any <a href="cartesian_closed_category" title="wikilink">cartesian closed category</a> by definition.</p>
<h3 id="environment-monad">Environment monad</h3>

<p>The environment monad (also called the <em>reader monad</em> and the <em>function monad</em>) allows a computation to depend on values from a shared environment. The monad type constructor maps a type <em>T</em> to functions of type <em>E</em> → <em>T</em>, where E is the type of the shared environment. The monad functions are:</p>

<p>

<math display="block" id="Monad_(functional_programming):6">
 <semantics>
  <mrow>
   <mtext>return</mtext>
   <mo>:</mo>
   <mrow>
    <mi>T</mi>
    <mo>→</mo>
    <mi>E</mi>
    <mo>→</mo>
    <mi>T</mi>
    <mo>=</mo>
    <mi>t</mi>
    <mo>↦</mo>
    <mi>e</mi>
    <mo>↦</mo>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <mtext>return</mtext>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <ci>T</ci>
      <ci>E</ci>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <share href="#.cmml">
      </share>
      <ci>T</ci>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <share href="#.cmml">
      </share>
      <ci>e</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <share href="#.cmml">
      </share>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{return}\colon T\rightarrow E\rightarrow T=t\mapsto e\mapsto t
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Monad_(functional_programming):7">
 <semantics>
  <mrow>
   <mtext>bind</mtext>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo>→</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo>→</mo>
    <mi>E</mi>
    <mo>→</mo>
    <msup>
     <mi>T</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>E</mi>
   <mo>→</mo>
   <msup>
    <mi>T</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mi>r</mi>
   <mo>↦</mo>
   <mi>f</mi>
   <mo>↦</mo>
   <mi>e</mi>
   <mo>↦</mo>
   <mpadded width="+1.7pt">
    <mi>f</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+1.7pt">
     <mi>r</mi>
    </mpadded>
    <mi>e</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>bind</mtext>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>T</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">E</csymbol>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>T</ci>
     <ci>normal-′</ci>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">r</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">r</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">e</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{bind}\colon(E\rightarrow T)\rightarrow(T\rightarrow E\rightarrow T^{%
\prime})\rightarrow E\rightarrow T^{\prime}=r\mapsto f\mapsto e\mapsto f\,(r\,%
e)\,e
  </annotation>
 </semantics>
</math>

</p>

<p>The following monadic operations are useful:</p>

<p>

<math display="block" id="Monad_(functional_programming):8">
 <semantics>
  <mrow>
   <mtext>ask</mtext>
   <mo>:</mo>
   <mrow>
    <mi>E</mi>
    <mo>→</mo>
    <mi>E</mi>
    <mo>=</mo>
    <msub>
     <mtext>id</mtext>
     <mi>E</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <mtext>ask</mtext>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <ci>E</ci>
      <ci>E</ci>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>id</mtext>
       <ci>E</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{ask}\colon E\rightarrow E=\text{id}_{E}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Monad_(functional_programming):9">
 <semantics>
  <mrow>
   <mtext>local</mtext>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo>→</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo>→</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>E</mi>
   <mo>→</mo>
   <mi>T</mi>
   <mo>=</mo>
   <mi>f</mi>
   <mo>↦</mo>
   <mi>c</mi>
   <mo>↦</mo>
   <mi>e</mi>
   <mo>↦</mo>
   <mpadded width="+1.7pt">
    <mi>c</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+1.7pt">
     <mi>f</mi>
    </mpadded>
    <mi>e</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>local</mtext>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">E</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">T</csymbol>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">c</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">c</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">f</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{local}\colon(E\rightarrow E)\rightarrow(E\rightarrow T)\rightarrow E%
\rightarrow T=f\mapsto c\mapsto e\mapsto c\,(f\,e)
  </annotation>
 </semantics>
</math>

</p>

<p>The <em>ask</em> operation is used to retrieve the current context, while <em>local</em> executes a computation in a modified subcontext. As in the state monad, computations in the environment monad may be invoked by simply providing an environment value and applying it to an instance of the monad.</p>
<h3 id="writer-monad">Writer monad</h3>

<p>The writer monad allows a program to compute various kinds of auxiliary output which can be "composed" or "accumulated" step-by-step, in addition to the main result of a computation. It is often used for logging or profiling. Given the underlying type <em>T</em>, a value in the writer monad has type <em>W</em> × <em>T</em>, where <em>W</em> is a type endowed with an operation satisfying the <a class="uri" href="monoid" title="wikilink">monoid</a> laws. Namely, <em>W</em> has a binary operation, <em>(a,b) → a*b</em>, which is associative, <em>(a*b)*c = a*(b*c)</em>, and has a neutral element <em>ε</em> with the property <em>x*ε = ε*x = x</em> for all <em>x</em>.</p>

<p>The monad functions are simply:</p>

<p>

<math display="block" id="Monad_(functional_programming):10">
 <semantics>
  <mrow>
   <mtext>return</mtext>
   <mo>:</mo>
   <mrow>
    <mi>T</mi>
    <mo>→</mo>
    <mrow>
     <mi>W</mi>
     <mo>×</mo>
     <mi>T</mi>
    </mrow>
    <mo>=</mo>
    <mi>t</mi>
    <mo>↦</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ϵ</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <mtext>return</mtext>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <ci>T</ci>
      <apply>
       <times></times>
       <ci>W</ci>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <share href="#.cmml">
      </share>
      <interval closure="open">
       <ci>ϵ</ci>
       <ci>t</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{return}\colon T\rightarrow W\times T=t\mapsto(\epsilon,t)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Monad_(functional_programming):11">
 <semantics>
  <mrow>
   <mtext>bind</mtext>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>W</mi>
    <mo>×</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo>→</mo>
    <mi>W</mi>
    <mo>×</mo>
    <msup>
     <mi>T</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>W</mi>
   <mo>×</mo>
   <msup>
    <mi>T</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↦</mo>
   <mi>f</mi>
   <mo>↦</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>w</mi>
    <mo>*</mo>
    <msup>
     <mi>w</mi>
     <mo>′</mo>
    </msup>
    <mo rspace="4.2pt">,</mo>
    <msup>
     <mi>t</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mpadded width="+2.8pt">
    <mtext>where</mtext>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>w</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>t</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mi>f</mi>
   </mpadded>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>bind</mtext>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">W</csymbol>
     <times></times>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">W</csymbol>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>T</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">W</csymbol>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>T</ci>
     <ci>normal-′</ci>
    </apply>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">w</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">w</csymbol>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>w</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci></ci>
    <mtext>where</mtext>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>w</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="unknown">t</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{bind}\colon(W\times T)\rightarrow(T\rightarrow W\times T^{\prime})%
\rightarrow W\times T^{\prime}=(w,t)\mapsto f\mapsto(w*w^{\prime},\,t^{\prime}%
)\quad\text{where}\;(w^{\prime},t^{\prime})=f\,t
  </annotation>
 </semantics>
</math>

 where ε and * are the identity element of the monoid W and its associative operation, respectively.</p>

<p>In JavaScript, a writer instance can be expressed as a two-element array, in which the first element is an arbitrary value and the second element is an array that collects extra information.</p>
<div class="sourceCode"><pre class="sourceCode Javascript"><code class="sourceCode javascript"><span class="kw">var</span> writer <span class="op">=</span> [ value<span class="op">,</span> [] ]<span class="op">;</span></code></pre></div>

<p>The <a href="Bracket#Uses_of_.22.5B.22_and_.22.5D.22" title="wikilink">array brackets</a> work here as the monad's type constructor, creating a value of the monadic type for the Writer monad from simpler components (the value in position 0 of the array, and the log array in position 1).</p>

<p><em>unit</em> (used in place of <em>return</em>, which is a reserved word in JavaScript) creates a new writer instance from a basic value, with an empty accumulator array attached to it.</p>
<div class="sourceCode"><pre class="sourceCode Javascript"><code class="sourceCode javascript"><span class="kw">var</span> unit <span class="op">=</span> <span class="kw">function</span>(value) <span class="op">{</span> <span class="cf">return</span> [ value<span class="op">,</span> [] ]<span class="op">;</span> <span class="op">};</span></code></pre></div>

<p><em>bind</em> applies a function to a writer instance, and returns a new writer instance composed of the result of the application, and the algebraic sum of the initial and new accumulators.</p>
<div class="sourceCode"><pre class="sourceCode Javascript"><code class="sourceCode javascript"><span class="kw">var</span> bind <span class="op">=</span> <span class="kw">function</span>(writer<span class="op">,</span> transform) <span class="op">{</span>
    <span class="kw">var</span> value  <span class="op">=</span> writer[<span class="dv">0</span>]<span class="op">;</span>
    <span class="kw">var</span> log    <span class="op">=</span> writer[<span class="dv">1</span>]<span class="op">;</span>
    <span class="kw">var</span> result <span class="op">=</span> <span class="at">transform</span>(value)<span class="op">;</span>
    <span class="cf">return</span> [ result[<span class="dv">0</span>]<span class="op">,</span> <span class="va">log</span>.<span class="at">concat</span>(result[<span class="dv">1</span>]) ]<span class="op">;</span>
<span class="op">};</span></code></pre></div>

<p><em>pipeline</em> is an auxiliary function that concatenates a sequence of <em>bind</em>s applied to an array of functions.</p>
<div class="sourceCode"><pre class="sourceCode Javascript"><code class="sourceCode javascript"><span class="kw">var</span> pipeline <span class="op">=</span> <span class="kw">function</span>(writer<span class="op">,</span> transforms) <span class="op">{</span>
    <span class="kw">var</span> result <span class="op">=</span> writer<span class="op">;</span>
    <span class="va">transforms</span>.<span class="at">forEach</span>(<span class="kw">function</span> (transform) <span class="op">{</span>
        result <span class="op">=</span> <span class="at">bind</span>(result<span class="op">,</span> transform)<span class="op">;</span>
    <span class="op">}</span>)<span class="op">;</span>
    <span class="cf">return</span> result<span class="op">;</span>
<span class="op">};</span></code></pre></div>

<p>Examples of functions that return values of the type expected by the above writer monad:</p>
<div class="sourceCode"><pre class="sourceCode Javascript"><code class="sourceCode javascript"><span class="kw">var</span> squared <span class="op">=</span> <span class="kw">function</span>(x) <span class="op">{</span>
    <span class="cf">return</span> [ x <span class="op">*</span> x<span class="op">,</span> <span class="st">'was squared.'</span> ]<span class="op">;</span>
<span class="op">};</span>

<span class="kw">var</span> halved <span class="op">=</span> <span class="kw">function</span>(x) <span class="op">{</span>
    <span class="cf">return</span> [ x / <span class="dv">2</span><span class="op">,</span> <span class="st">'was halved.'</span> ]<span class="op">;</span>
<span class="op">};</span></code></pre></div>

<p>Finally, an example of using the monad to build a pipeline of mathematical functions with debug information on the side (that is, an array of debug information is concatenated, and returned with the result, as well):</p>
<div class="sourceCode"><pre class="sourceCode Javascript"><code class="sourceCode javascript"><span class="at">pipeline</span>(<span class="at">unit</span>(<span class="dv">4</span>)<span class="op">,</span> [ squared<span class="op">,</span> halved ])<span class="op">;</span> <span class="co">// [ 8, [ 'was squared.', 'was halved.' ] ]</span></code></pre></div>
<h3 id="continuation-monad">Continuation monad</h3>

<p>A <a class="uri" href="continuation" title="wikilink">continuation</a> monad with return type 

<math display="inline" id="Monad_(functional_programming):12">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 maps type 

<math display="inline" id="Monad_(functional_programming):13">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>


 into functions of type 

<math display="inline" id="Monad_(functional_programming):14">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mi>T</mi>
    <mo>→</mo>
    <mi>R</mi>
    <mo>)</mo>
   </mrow>
   <mo>→</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">R</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(T\rightarrow R\right)\rightarrow R
  </annotation>
 </semantics>
</math>

. It is used to model <a href="continuation-passing_style" title="wikilink">continuation-passing style</a>. The return and bind functions are as follows:</p>

<p>

<math display="block" id="Monad_(functional_programming):15">
 <semantics>
  <mrow>
   <mtext>return</mtext>
   <mo>:</mo>
   <mi>T</mi>
   <mo>→</mo>
   <mrow>
    <mo>(</mo>
    <mi>T</mi>
    <mo>→</mo>
    <mi>R</mi>
    <mo>)</mo>
   </mrow>
   <mo>→</mo>
   <mi>R</mi>
   <mo>=</mo>
   <mi>t</mi>
   <mo>↦</mo>
   <mi>f</mi>
   <mo>↦</mo>
   <mpadded width="+1.7pt">
    <mi>f</mi>
   </mpadded>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>return</mtext>
    <ci>normal-:</ci>
    <csymbol cd="unknown">T</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">R</csymbol>
    <eq></eq>
    <csymbol cd="unknown">t</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="unknown">t</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{return}\colon T\rightarrow\left(T\rightarrow R\right)\rightarrow R=t%
\mapsto f\mapsto f\,t
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Monad_(functional_programming):16">
 <semantics>
  <mrow>
   <mtext>bind</mtext>
   <mo>:</mo>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo>(</mo>
     <mi>T</mi>
     <mo>→</mo>
     <mi>R</mi>
     <mo>)</mo>
    </mrow>
    <mo>→</mo>
    <mi>R</mi>
    <mo>)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo>(</mo>
    <mi>T</mi>
    <mo>→</mo>
    <mrow>
     <mo>(</mo>
     <msup>
      <mi>T</mi>
      <mo>′</mo>
     </msup>
     <mo>→</mo>
     <mi>R</mi>
     <mo>)</mo>
    </mrow>
    <mo>→</mo>
    <mi>R</mi>
    <mo>)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo>(</mo>
    <msup>
     <mi>T</mi>
     <mo>′</mo>
    </msup>
    <mo>→</mo>
    <mi>R</mi>
    <mo>)</mo>
   </mrow>
   <mo>→</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>bind</mtext>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">T</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">R</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>T</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>normal-→</ci>
      <csymbol cd="unknown">R</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>T</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-→</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">R</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{bind}\colon\left(\left(T\rightarrow R\right)\rightarrow R\right)%
\rightarrow\left(T\rightarrow\left(T^{\prime}\rightarrow R\right)\rightarrow R%
\right)\rightarrow\left(T^{\prime}\rightarrow R\right)\rightarrow R
  </annotation>
 </semantics>
</math>



<math display="inline" id="Monad_(functional_programming):17">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mi>c</mi>
   <mo>↦</mo>
   <mi>f</mi>
   <mo>↦</mo>
   <mi>k</mi>
   <mo>↦</mo>
   <mpadded width="+1.7pt">
    <mi>c</mi>
   </mpadded>
   <mrow>
    <mo>(</mo>
    <mi>t</mi>
    <mo>↦</mo>
    <mpadded width="+1.7pt">
     <mi>f</mi>
    </mpadded>
    <mpadded width="+1.7pt">
     <mi>t</mi>
    </mpadded>
    <mi>k</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <csymbol cd="unknown">c</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">k</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">c</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">t</csymbol>
     <csymbol cd="latexml">maps-to</csymbol>
     <csymbol cd="unknown">f</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <csymbol cd="unknown">k</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =c\mapsto f\mapsto k\mapsto c\,\left(t\mapsto f\,t\,k\right)
  </annotation>
 </semantics>
</math>

</p>

<p>The <a class="uri" href="call-with-current-continuation" title="wikilink">call-with-current-continuation</a> function is defined as follows:</p>

<p>

<math display="block" id="Monad_(functional_programming):18">
 <semantics>
  <mrow>
   <mtext>call/cc</mtext>
   <mo>:</mo>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo>(</mo>
     <mi>T</mi>
     <mo>→</mo>
     <mrow>
      <mo>(</mo>
      <msup>
       <mi>T</mi>
       <mo>′</mo>
      </msup>
      <mo>→</mo>
      <mi>R</mi>
      <mo>)</mo>
     </mrow>
     <mo>→</mo>
     <mi>R</mi>
     <mo>)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo>(</mo>
     <mi>T</mi>
     <mo>→</mo>
     <mi>R</mi>
     <mo>)</mo>
    </mrow>
    <mo>→</mo>
    <mi>R</mi>
    <mo>)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo>(</mo>
    <mi>T</mi>
    <mo>→</mo>
    <mi>R</mi>
    <mo>)</mo>
   </mrow>
   <mo>→</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>call/cc</mtext>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">T</csymbol>
      <ci>normal-→</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>T</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>normal-→</ci>
       <csymbol cd="unknown">R</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <csymbol cd="unknown">R</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">T</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">R</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">R</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">R</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{call/cc}\colon\left(\left(T\rightarrow\left(T^{\prime}\rightarrow R%
\right)\rightarrow R\right)\rightarrow\left(T\rightarrow R\right)\rightarrow R%
\right)\rightarrow\left(T\rightarrow R\right)\rightarrow R
  </annotation>
 </semantics>
</math>



<math display="inline" id="Monad_(functional_programming):19">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mi>f</mi>
   <mo>↦</mo>
   <mi>k</mi>
   <mo>↦</mo>
   <mrow>
    <mo>(</mo>
    <mi>f</mi>
    <mrow>
     <mo>(</mo>
     <mi>t</mi>
     <mo>↦</mo>
     <mi>x</mi>
     <mo>↦</mo>
     <mpadded width="+1.7pt">
      <mi>k</mi>
     </mpadded>
     <mi>t</mi>
     <mo rspace="4.2pt">)</mo>
    </mrow>
    <mi>k</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">k</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <csymbol cd="latexml">maps-to</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="latexml">maps-to</csymbol>
      <csymbol cd="unknown">k</csymbol>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">k</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =f\mapsto k\mapsto\left(f\left(t\mapsto x\mapsto k\,t\right)\,k\right)
  </annotation>
 </semantics>
</math>

</p>
<h3 id="others">Others</h3>

<p>Other concepts that researchers have expressed as monads include:</p>
<ul>
<li><a class="uri" href="Iteratee" title="wikilink">Iteratee</a></li>
<li><a href="Exception_handling" title="wikilink">Exception handling</a></li>
<li><a href="Graphical_user_interface" title="wikilink">Graphical user interfaces</a></li>
<li><a href="Interprocess_communication" title="wikilink">Interprocess communication</a></li>
<li><a href="Parser" title="wikilink">Parsers</a></li>
<li><a href="Interpreter_(computing)" title="wikilink">Interpreters</a></li>
<li><a href="Strict_evaluation" title="wikilink">Strict evaluation</a></li>
<li>Interfaces to code written in other languages</li>
</ul>
<h2 id="free-monads">Free monads</h2>

<p>Free monads are similar to <a href="free_monoid" title="wikilink">free monoids</a>, in that they, intuitively speaking, are generic structures that fulfill the monad (monoid) laws without depending on the type in question.</p>

<p>For any type t, the free monoid of <code>t</code> is <code>[t]</code>, with <code>++</code> as the associative binary operation and <code>[]</code> as the unit element. In Haskell, we can write this as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> [] <span class="kw">where</span>
   fmap _ [] <span class="fu">=</span> []
   fmap fun (x<span class="fu">:</span>xs) <span class="fu">=</span> fun x <span class="fu">:</span> fmap fun xs

<span class="kw">instance</span> <span class="dt">Monoid</span> [t] <span class="kw">where</span>
   mappend xs ys <span class="fu">=</span> xs <span class="fu">++</span> ys
   mempty <span class="fu">=</span> []</code></pre></div>

<p>Whereas in a concrete monoid, one could add the values <code>t1,t2,...,tn</code> with its binary operation; in <code>[]</code>, they are simply concatenated into <code>[t1,t2,...,tn]</code>, signifying that they "belong together". What that "belonging together" means, however, is left unspecified.</p>

<p>The free monad is based on the same idea. If we take <code>List t = Nil | Cons t (List t)</code> and insert a <a class="uri" href="Functor" title="wikilink">Functor</a> into it, we get the free monad:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Free</span> f a <span class="fu">=</span> <span class="dt">Return</span> a <span class="fu">|</span> <span class="dt">Bind</span> (f (<span class="dt">Free</span> f a))

<span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Free</span> f) <span class="kw">where</span>
   fmap fun (<span class="dt">Return</span> x) <span class="fu">=</span> <span class="dt">Return</span> (fun x)
   fmap fun (<span class="dt">Bind</span> x) <span class="fu">=</span> <span class="dt">Bind</span> (fmap (fmap fun) x)

<span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Free</span> f) <span class="kw">where</span>
   return x <span class="fu">=</span> <span class="dt">Return</span> x
   x <span class="fu">&gt;&gt;=</span> fun <span class="fu">=</span> <span class="dt">Bind</span> (fmap (<span class="fu">&gt;&gt;=</span> fun) x)</code></pre></div>

<p>Unlike <code>List</code>, which stores a list of values, <code>Free</code> stores a list of functors, wrapped around an initial value. Accordingly, the <code>Functor</code> and <code>Monad</code> instances of <code>Free</code> do nothing other than handing a given function down that list with <code>fmap</code>.</p>
<h2 id="comonads">Comonads</h2>

<p>Comonads are the <a href="categorical_dual" title="wikilink">categorical dual</a> of monads. They are defined by a type constructor W <em>T</em> and two operations: <em>extract</em> with type W <em>T</em> → <em>T</em> for any <em>T</em>, and <em>extend</em> with type (W <em>T</em> → ''T' '') → W <em>T</em> → W ''T' ''. The operations <em>extend</em> and <em>extract</em> are expected to satisfy these laws:</p>

<p>

<math display="block" id="Monad_(functional_programming):20">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+3.4pt">
     <mtext>extend</mtext>
    </mpadded>
    <mtext>extract</mtext>
   </mrow>
   <mo>=</mo>
   <mtext>id</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>extend</mtext>
     <mtext>extract</mtext>
    </apply>
    <mtext>id</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{extend}\,\,\text{extract}=\text{id}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Monad_(functional_programming):21">
 <semantics>
  <mrow>
   <mrow>
    <mtext>extract</mtext>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mtext>extend</mtext>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <mtext>extract</mtext>
     <apply>
      <times></times>
      <mtext>extend</mtext>
      <ci>f</ci>
     </apply>
    </apply>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{extract}\circ(\text{extend}\,f)=f
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Monad_(functional_programming):22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mtext>extend</mtext>
      </mpadded>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mtext>extend</mtext>
      </mpadded>
      <mi>g</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mtext>extend</mtext>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mo>∘</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+1.7pt">
         <mtext>extend</mtext>
        </mpadded>
        <mi>g</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <apply>
      <times></times>
      <mtext>extend</mtext>
      <ci>f</ci>
     </apply>
     <apply>
      <times></times>
      <mtext>extend</mtext>
      <ci>g</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <mtext>extend</mtext>
     <apply>
      <compose></compose>
      <ci>f</ci>
      <apply>
       <times></times>
       <mtext>extend</mtext>
       <ci>g</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\text{extend}\,f)\circ(\text{extend}\,g)=\text{extend}\,(f\circ(\text{extend}%
\,g))
  </annotation>
 </semantics>
</math>

</p>

<p>Alternatively, comonads may be defined in terms of operations <em>fmap</em>, <em>extract</em> and <em>duplicate</em>. The <em>fmap</em> and <em>extract</em> operations define W as a copointed functor. The <em>duplicate</em> operation characterizes comonads: it has type W <em>T</em> → W (W <em>T</em>) and satisfies the following laws:</p>

<p>

<math display="block" id="Monad_(functional_programming):23">
 <semantics>
  <mrow>
   <mrow>
    <mtext>extract</mtext>
    <mo>∘</mo>
    <mtext>duplicate</mtext>
   </mrow>
   <mo>=</mo>
   <mtext>id</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <mtext>extract</mtext>
     <mtext>duplicate</mtext>
    </apply>
    <mtext>id</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{extract}\circ\text{duplicate}=\text{id}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Monad_(functional_programming):24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <mtext>fmap</mtext>
     </mpadded>
     <mtext>extract</mtext>
    </mrow>
    <mo>∘</mo>
    <mtext>duplicate</mtext>
   </mrow>
   <mo>=</mo>
   <mtext>id</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <apply>
      <times></times>
      <mtext>fmap</mtext>
      <mtext>extract</mtext>
     </apply>
     <mtext>duplicate</mtext>
    </apply>
    <mtext>id</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{fmap}\,\text{extract}\circ\text{duplicate}=\text{id}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Monad_(functional_programming):25">
 <semantics>
  <mrow>
   <mrow>
    <mtext>duplicate</mtext>
    <mo>∘</mo>
    <mtext>duplicate</mtext>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <mtext>fmap</mtext>
     </mpadded>
     <mtext>duplicate</mtext>
    </mrow>
    <mo>∘</mo>
    <mtext>duplicate</mtext>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <mtext>duplicate</mtext>
     <mtext>duplicate</mtext>
    </apply>
    <apply>
     <compose></compose>
     <apply>
      <times></times>
      <mtext>fmap</mtext>
      <mtext>duplicate</mtext>
     </apply>
     <mtext>duplicate</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{duplicate}\circ\text{duplicate}=\text{fmap}\,\text{duplicate}\circ\text{duplicate}
  </annotation>
 </semantics>
</math>

</p>

<p>The two formulations are related as follows:</p>

<p>

<math display="block" id="Monad_(functional_programming):26">
 <semantics>
  <mrow>
   <mtext>fmap</mtext>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mpadded width="+1.7pt">
    <mi mathvariant="normal">W</mi>
   </mpadded>
   <mi>A</mi>
   <mo>→</mo>
   <mpadded width="+1.7pt">
    <mi mathvariant="normal">W</mi>
   </mpadded>
   <mi>B</mi>
   <mo>=</mo>
   <mi>f</mi>
   <mo>↦</mo>
   <mpadded width="+1.7pt">
    <mtext>extend</mtext>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo>∘</mo>
    <mtext>extract</mtext>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>fmap</mtext>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">W</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">W</csymbol>
    <csymbol cd="unknown">B</csymbol>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <mtext>extend</mtext>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">f</csymbol>
     <compose></compose>
     <mtext>extract</mtext>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{fmap}:(A\rightarrow B)\rightarrow\mathrm{W}\,A\rightarrow\mathrm{W}\,B=f%
\mapsto\text{extend}\,(f\circ\text{extract})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Monad_(functional_programming):27">
 <semantics>
  <mrow>
   <mtext>duplicate</mtext>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <mi mathvariant="normal">W</mi>
     </mpadded>
     <mi>A</mi>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi mathvariant="normal">W</mi>
     </mpadded>
     <mpadded width="+1.7pt">
      <mi mathvariant="normal">W</mi>
     </mpadded>
     <mi>A</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mtext>extend</mtext>
     </mpadded>
     <mtext>id</mtext>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <mtext>duplicate</mtext>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <times></times>
       <ci>normal-W</ci>
       <ci>A</ci>
      </apply>
      <apply>
       <times></times>
       <ci>normal-W</ci>
       <ci>normal-W</ci>
       <ci>A</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <mtext>extend</mtext>
       <mtext>id</mtext>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{duplicate}:\mathrm{W}\,A\rightarrow\mathrm{W}\,\mathrm{W}\,A=\text{%
extend}\,\text{id}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Monad_(functional_programming):28">
 <semantics>
  <mrow>
   <mtext>extend</mtext>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+1.7pt">
     <mi mathvariant="normal">W</mi>
    </mpadded>
    <mi>A</mi>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mpadded width="+1.7pt">
    <mi mathvariant="normal">W</mi>
   </mpadded>
   <mi>A</mi>
   <mo>→</mo>
   <mpadded width="+1.7pt">
    <mi mathvariant="normal">W</mi>
   </mpadded>
   <mi>B</mi>
   <mo>=</mo>
   <mi>f</mi>
   <mo>↦</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+1.7pt">
     <mtext>fmap</mtext>
    </mpadded>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∘</mo>
   <mtext>duplicate</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>extend</mtext>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">W</csymbol>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">W</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">W</csymbol>
    <csymbol cd="unknown">B</csymbol>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <mtext>fmap</mtext>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <compose></compose>
    <mtext>duplicate</mtext>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{extend}:(\mathrm{W}\,A\rightarrow B)\rightarrow\mathrm{W}\,A\rightarrow%
\mathrm{W}\,B=f\mapsto(\text{fmap}\,f)\circ\text{duplicate}
  </annotation>
 </semantics>
</math>

</p>

<p>Whereas monads could be said to represent side-effects, a comonad <em>W</em> represents a kind of <em>context</em>. The <em>extract</em> functions extracts a value from its context, while the <em>extend</em> function may be used to compose a pipeline of "context-dependent functions" of type W <em>A</em> → <em>B</em>.</p>
<h3 id="identity-comonad">Identity comonad</h3>

<p>The identity comonad is the simplest comonad: it maps type <em>T</em> to itself. The <em>extract</em> operator is the identity and the <em>extend</em> operator is function application.</p>
<h3 id="product-comonad">Product comonad</h3>

<p>The product comonad maps type 

<math display="inline" id="Monad_(functional_programming):29">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 into tuples of type 

<math display="inline" id="Monad_(functional_programming):30">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>×</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\times T
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Monad_(functional_programming):31">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is the context type of the comonad. The comonad operations are:</p>

<p>

<math display="block" id="Monad_(functional_programming):32">
 <semantics>
  <mrow>
   <mtext>extract</mtext>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>C</mi>
      <mo>×</mo>
      <mi>T</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>T</mi>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>↦</mo>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <mtext>extract</mtext>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <times></times>
       <ci>C</ci>
       <ci>T</ci>
      </apply>
      <ci>T</ci>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <interval closure="open">
       <ci>c</ci>
       <ci>t</ci>
      </interval>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <share href="#.cmml">
      </share>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{extract}:(C\times T)\rightarrow T=(c,t)\mapsto t
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Monad_(functional_programming):33">
 <semantics>
  <mrow>
   <mtext>extend</mtext>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>C</mi>
     <mo>×</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>C</mi>
   <mo>×</mo>
   <mi>A</mi>
   <mo>→</mo>
   <mi>C</mi>
   <mo>×</mo>
   <mi>B</mi>
   <mo>=</mo>
   <mi>f</mi>
   <mo>↦</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>c</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↦</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>c</mi>
    <mo>,</mo>
    <mpadded width="+1.7pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo>,</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>extend</mtext>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">C</csymbol>
      <times></times>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">C</csymbol>
    <times></times>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">C</csymbol>
    <times></times>
    <csymbol cd="unknown">B</csymbol>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">c</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">maps-to</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">c</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">f</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">c</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{extend}:((C\times A)\rightarrow B)\rightarrow C\times A\rightarrow C%
\times B=f\mapsto(c,a)\mapsto(c,f\,(c,a))
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Monad_(functional_programming):34">
 <semantics>
  <mrow>
   <mtext>fmap</mtext>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo>×</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>C</mi>
    <mo>×</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>f</mi>
   <mo>↦</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>c</mi>
    <mo>,</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↦</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>c</mi>
    <mo>,</mo>
    <mpadded width="+1.7pt">
     <mi>f</mi>
    </mpadded>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>fmap</mtext>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">C</csymbol>
     <times></times>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">C</csymbol>
     <times></times>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">c</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">maps-to</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">c</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">f</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{fmap}:(A\rightarrow B)\rightarrow(C\times A)\rightarrow(C\times B)=f%
\mapsto(c,a)\mapsto(c,f\,a)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Monad_(functional_programming):35">
 <semantics>
  <mrow>
   <mtext>duplicate</mtext>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>C</mi>
      <mo>×</mo>
      <mi>A</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>C</mi>
      <mo>×</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>C</mi>
        <mo>×</mo>
        <mi>A</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo>,</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>↦</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo>,</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <mtext>duplicate</mtext>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <times></times>
       <ci>C</ci>
       <ci>A</ci>
      </apply>
      <apply>
       <times></times>
       <ci>C</ci>
       <apply>
        <times></times>
        <ci>C</ci>
        <ci>A</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <interval closure="open">
       <ci>c</ci>
       <ci>a</ci>
      </interval>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <share href="#.cmml">
      </share>
      <interval closure="open">
       <ci>c</ci>
       <interval closure="open">
        <ci>c</ci>
        <ci>a</ci>
       </interval>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{duplicate}:(C\times A)\rightarrow(C\times(C\times A))=(c,a)\mapsto(c,(c,%
a))
  </annotation>
 </semantics>
</math>

</p>
<h3 id="function-comonad">Function comonad</h3>

<p>The function comonad maps type 

<math display="inline" id="Monad_(functional_programming):36">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 into functions of type 

<math display="inline" id="Monad_(functional_programming):37">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>→</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>M</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\rightarrow T
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Monad_(functional_programming):38">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>


 is a type endowed with a <a class="uri" href="monoid" title="wikilink">monoid</a> structure. The comonad operations are:</p>

<p>

<math display="block" id="Monad_(functional_programming):39">
 <semantics>
  <mrow>
   <mtext>extract</mtext>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo>→</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>T</mi>
   <mo>=</mo>
   <mi>f</mi>
   <mo>↦</mo>
   <mpadded width="+1.7pt">
    <mi>f</mi>
   </mpadded>
   <mi>ε</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>extract</mtext>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">T</csymbol>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="unknown">ε</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{extract}:(M\rightarrow T)\rightarrow T=f\mapsto f\,\varepsilon
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Monad_(functional_programming):40">
 <semantics>
  <mrow>
   <mtext>extend</mtext>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo>→</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo>→</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>M</mi>
   <mo>→</mo>
   <mi>B</mi>
   <mo>=</mo>
   <mi>f</mi>
   <mo>↦</mo>
   <mi>g</mi>
   <mo>↦</mo>
   <mi>m</mi>
   <mo>↦</mo>
   <mpadded width="+1.7pt">
    <mi>f</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>m</mi>
     <mo>′</mo>
    </msup>
    <mo>↦</mo>
    <mpadded width="+1.7pt">
     <mi>g</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo>*</mo>
     <msup>
      <mi>m</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>extend</mtext>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">M</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">M</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">B</csymbol>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">g</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">m</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <ci>normal-′</ci>
     </apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <csymbol cd="unknown">g</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">m</csymbol>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>m</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{extend}:((M\rightarrow A)\rightarrow B)\rightarrow(M\rightarrow A)%
\rightarrow M\rightarrow B=f\mapsto g\mapsto m\mapsto f\,(m^{\prime}\mapsto g%
\,(m*m^{\prime}))
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Monad_(functional_programming):41">
 <semantics>
  <mrow>
   <mtext>fmap</mtext>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo>→</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>M</mi>
   <mo>→</mo>
   <mi>B</mi>
   <mo>=</mo>
   <mi>f</mi>
   <mo>↦</mo>
   <mi>g</mi>
   <mo>↦</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo>∘</mo>
    <mi>g</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>fmap</mtext>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">M</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">B</csymbol>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">g</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">f</csymbol>
     <compose></compose>
     <csymbol cd="unknown">g</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{fmap}:(A\rightarrow B)\rightarrow(M\rightarrow A)\rightarrow M%
\rightarrow B=f\mapsto g\mapsto(f\circ g)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Monad_(functional_programming):42">
 <semantics>
  <mrow>
   <mtext>duplicate</mtext>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo>→</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>M</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo>→</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>f</mi>
   <mo>↦</mo>
   <mi>m</mi>
   <mo>↦</mo>
   <msup>
    <mi>m</mi>
    <mo>′</mo>
   </msup>
   <mo>↦</mo>
   <mpadded width="+1.7pt">
    <mi>f</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo>*</mo>
    <msup>
     <mi>m</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>duplicate</mtext>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">M</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">m</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>m</ci>
     <ci>normal-′</ci>
    </apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">m</csymbol>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>m</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{duplicate}:(M\rightarrow A)\rightarrow M\rightarrow(M\rightarrow A)=f%
\mapsto m\mapsto m^{\prime}\mapsto f\,(m*m^{\prime})
  </annotation>
 </semantics>
</math>

 where ε is the identity element of 

<math display="inline" id="Monad_(functional_programming):43">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>


 and * is its associative operation.</p>
<h3 id="costate-comonad">Costate comonad</h3>

<p>The costate comonad maps a type 

<math display="inline" id="Monad_(functional_programming):44">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 into type 

<math display="inline" id="Monad_(functional_programming):45">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>→</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>×</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <times></times>
    <csymbol cd="unknown">S</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S\rightarrow T)\times S
  </annotation>
 </semantics>
</math>

, where S is the base type of the store. The comonad operations are:</p>

<p>

<math display="block" id="Monad_(functional_programming):46">
 <semantics>
  <mrow>
   <mtext>extract</mtext>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo>→</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>×</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>T</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↦</mo>
   <mpadded width="+1.7pt">
    <mi>f</mi>
   </mpadded>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>extract</mtext>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">T</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <times></times>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">T</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="unknown">s</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{extract}:((S\rightarrow T)\times S)\rightarrow T=(f,s)\mapsto f\,s
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Monad_(functional_programming):47">
 <semantics>
  <mrow>
   <mtext>extend</mtext>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo>→</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>×</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo>→</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>×</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>×</mo>
   <mpadded width="+1.7pt">
    <mi>S</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>extend</mtext>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">S</csymbol>
       <ci>normal-→</ci>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <times></times>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <times></times>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <times></times>
    <csymbol cd="unknown">S</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{extend}:(((S\rightarrow A)\times S)\rightarrow B)\rightarrow((S%
\rightarrow A)\times S)\rightarrow(S\rightarrow B)\times S\,
  </annotation>
 </semantics>
</math>



<math display="inline" id="Monad_(functional_programming):48">
 <semantics>
  <mrow>
   <mo>=</mo>
   <mi>f</mi>
   <mo>↦</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>g</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↦</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>s</mi>
      <mo>′</mo>
     </msup>
     <mo>↦</mo>
     <mpadded width="+1.7pt">
      <mi>f</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>g</mi>
      <mo>,</mo>
      <msup>
       <mi>s</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">g</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">maps-to</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>normal-′</ci>
      </apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <csymbol cd="unknown">f</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">g</csymbol>
       <ci>normal-,</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>s</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-,</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =f\mapsto(g,s)\mapsto((s^{\prime}\mapsto f\,(g,s^{\prime})),s)
  </annotation>
 </semantics>
</math>


</p>

<p>

<math display="block" id="Monad_(functional_programming):49">
 <semantics>
  <mrow>
   <mtext>fmap</mtext>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo>→</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>×</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>×</mo>
   <mi>S</mi>
   <mo>=</mo>
   <mi>f</mi>
   <mo>↦</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↦</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo>∘</mo>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>fmap</mtext>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <times></times>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <times></times>
    <csymbol cd="unknown">S</csymbol>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-,</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">maps-to</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">f</csymbol>
     <compose></compose>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-,</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{fmap}:(A\rightarrow B)\rightarrow((S\rightarrow A)\times S)\rightarrow(S%
\rightarrow B)\times S=f\mapsto(f^{\prime},s)\mapsto(f\circ f^{\prime},s)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Monad_(functional_programming):50">
 <semantics>
  <mrow>
   <mtext>duplicate</mtext>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo>→</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>×</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo>→</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>×</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>×</mo>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>↦</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>s</mi>
      <mo>′</mo>
     </msup>
     <mo>↦</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo>,</mo>
      <msup>
       <mi>s</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>duplicate</mtext>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <times></times>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">S</csymbol>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">S</csymbol>
       <ci>normal-→</ci>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <times></times>
      <csymbol cd="unknown">S</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <times></times>
    <csymbol cd="unknown">S</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">maps-to</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>normal-′</ci>
      </apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">f</csymbol>
       <ci>normal-,</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>s</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-,</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{duplicate}:((S\rightarrow A)\times S)\rightarrow(S\rightarrow((S%
\rightarrow A)\times S))\times S=(f,s)\mapsto((s^{\prime}\mapsto(f,s^{\prime})%
),s)
  </annotation>
 </semantics>
</math>

</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Arrows_in_functional_programming" title="wikilink">Arrows in functional programming</a> — whereas monads generalize the results of a computation to effects, arrows further generalize the inputs similarly.</li>
<li><a href="Aspect-oriented_programming" title="wikilink">Aspect-oriented programming</a>, a paradigm to increase modularity by isolating secondary or supporting functionality.</li>
<li><a href="Effect_system" title="wikilink">Effect system</a>, an alternative way of describing side effects as types.</li>
<li><a href="Inversion_of_control" title="wikilink">Inversion of control</a> — the abstract principle of calling specific functions from a reusable software entity.</li>
<li><a href="Monad_transformer" title="wikilink">Monad transformers</a> — which allow monads to be composed in a modular and convenient way.</li>
<li><a href="Uniqueness_type" title="wikilink">Uniqueness types</a> - an alternative way of dealing with side-effects in functional languages</li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<h3 id="haskell-monad-tutorials">Haskell monad tutorials</h3>
<ul>
<li><a href="http://haskell.org/haskellwiki/Monad_tutorials_timeline">Monad Tutorials Timeline</a> Probably the most comprehensive collection of links to monad tutorials, ordered by date.</li>
<li>

<p>— The most famous "blog post" tutorial.</p></li>
<li>

<p>— An attempt to explain all of the leading typeclasses in Haskell in an elementary way, with monadic functors considered as only one form, best understood by comparison with others: e.g., the more general idea of a "Functor" as something you can map over; "Applicative" functors, and so forth; contains an extensive bibliography.</p></li>
<li>

<p>— Opposes the idea of making a tutorial about monads in particular.</p></li>
<li><a href="http://haskell.org/haskellwiki/What_a_Monad_is_not">What a Monad is not</a> deals with common misconceptions and oversimplifications in a humorous way.</li>
<li>

<p>— Takes a similar point of view, locating monads in a much wider array of Haskell functor classes, of use only in special circumstances.</p></li>
<li>

<p>— An extremely detailed set of tutorials, deriving monads from first principles.</p></li>
<li>

<p>An explanation of Monads, building on the concepts of Functors, Applicative Functors and Monoids discussed in the <a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids">previous chapter</a>.</p></li>
<li><a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors, Applicatives and Monads in Pictures</a>. A humorous beginner's guide to monads.</li>
</ul>
<h4 id="older-tutorials">Older tutorials</h4>
<ul>
<li><a href="http://www.haskell.org/haskellwiki/All_About_Monads">All About Monads</a></li>
<li><a href="http://haskell.org/haskellwiki/Monads_as_computation">Haskell Wiki: Monads as Computation</a></li>
<li><a href="http://haskell.org/haskellwiki/Monads_as_containers">Haskell Wiki: Monads as Containers</a></li>
<li></li>
<li></li>
<li></li>
<li><a href="http://spbhug.folding-maps.org/wiki/MonadsEn">Monads</a> A monad tutorial providing examples of non-trivial monads apart from the conventional IO/Maybe/List/State monads.</li>
<li></li>
</ul>
<h4 id="other-documentation">Other documentation</h4>
<ul>
<li></li>
<li>

<p>— The original paper suggesting use of monads for programming</p></li>
<li>

<p>— Describes monads in Haskell (before they were implemented)</p></li>
</ul>
<h3 id="scala-monad-tutorials">Scala monad tutorials</h3>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h3 id="monads-in-other-languages">Monads in other languages</h3>
<ul>
<li><a href="http://web.archive.org/web/20080515195640/http://sleepingsquirrel.org/monads/monads.html">Monads in Perl</a></li>
<li><a href="http://moonbase.rydia.net/mental/writings/programming/monads-in-ruby/00introduction.html">Monads in Ruby</a></li>
<li><a href="http://www.valuedlessons.com/2008/01/monads-in-python-with-nice-syntax.html">Monads in Python</a></li>
<li><a href="http://lamp.epfl.ch/~emir/bqbase/2005/01/20/monad.html">Monads in Scala</a></li>
<li><a href="https://web.archive.org/web/20131229232933/http://onclojure.com/2009/03/05/a-monad-tutorial-for-clojure-programmers-part-1/">Monads in Clojure</a></li>
<li><a href="http://labs.mudynamics.com/2009/05/13/monadic-parser-in-javascript/">Monads in JavaScript</a></li>
<li><a href="http://blogs.msdn.com/wesdyer/archive/2008/01/11/the-marvels-of-monads.aspx">Introduction to monads in C# and LINQ</a></li>
<li><a href="https://github.com/louthy/csharp-monad">Library of monads for C#</a></li>
<li><a href="http://blog.enfranchisedmind.com/2007/08/a-monad-tutorial-for-ocaml/">Monads in Ocaml</a></li>
<li><a href="http://blog.ircmaxell.com/2013/07/taking-monads-to-oop-php.html">Monads in PHP</a></li>
</ul>

<p>"</p>

<p><a href="Category:1991_in_computer_science" title="wikilink">Category:1991 in computer science</a> <a href="Category:Functional_programming" title="wikilink">Category:Functional programming</a> <a href="Category:Articles_with_example_Haskell_code" title="wikilink">Category:Articles with example Haskell code</a> <a href="Category:Software_design_patterns" title="wikilink">Category:Software design patterns</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7">De Meuter, Wolfgang. "<a href="http://soft.vub.ac.be/Publications/1997/vub-prog-tr-97-10.pdf">Monads as a theoretical foundation for AOP</a>". Workshop on Aspect Oriented Programming, ECOOP 1997.<a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12"><a href="Simon_Peyton_Jones" title="wikilink">Peyton Jones, Simon L.</a>; Wadler, Philip. <a href="http://citeseer.ist.psu.edu/peytonjones93imperative.html">Imperative Functional Programming</a>. Conference record of the Twentieth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, Charleston, South Carolina. 1993<a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros">How to make Data.Set a monad</a> shows an implementation of the Set restricted monad in <a href="Haskell_(programming_language)" title="wikilink">Haskell</a><a href="#fnref15">↩</a></li>
</ol>
</section>
</body>

