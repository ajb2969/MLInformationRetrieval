<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="593">Concrete category</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Concrete category</h1>
<hr/>

<p>In mathematics, a <strong>concrete category</strong> is a <a href="category_(category_theory)" title="wikilink">category</a> that is equipped with a <a href="faithful_functor" title="wikilink">faithful functor</a> to the <a href="category_of_sets" title="wikilink">category of sets</a>. This functor makes it possible to think of the objects of the category as sets with additional <a href="mathematical_structure" title="wikilink">structure</a>, and of its <a href="morphism" title="wikilink">morphisms</a> as structure-preserving functions. Many important categories have obvious interpretations as concrete categories, for example the <a href="category_of_topological_spaces" title="wikilink">category of topological spaces</a> and the <a href="category_of_groups" title="wikilink">category of groups</a>, and trivially also the category of sets itself. On the other hand, the <a href="homotopy_category_of_topological_spaces" title="wikilink">homotopy category of topological spaces</a> is not <strong>concretizable</strong>, i.e. it does not admit a faithful functor to the category of sets.</p>

<p>A concrete category, when defined without reference to the notion of a category, consists of a <a href="class_(set_theory)" title="wikilink">class</a> of <em>objects</em>, each equipped with an <em>underlying set</em>; and for any two objects <em>A</em> and <em>B</em> a set of functions, called <em>morphisms</em>, from the underlying set of <em>A</em> to the underlying set of <em>B</em>. Furthermore, for every object <em>A</em>, the identity function on the underlying set of <em>A</em> must be a morphism from <em>A</em> to <em>A</em>, and the composition of a morphism from <em>A</em> to <em>B</em> followed by a morphism from <em>B</em> to <em>C</em> must be a morphism from <em>A</em> to <em>C</em>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="definition">Definition</h2>

<p>A <strong>concrete category</strong> is a pair (<em>C</em>,<em>U</em>) such that</p>
<ul>
<li><em>C</em> is a category, and</li>
<li><em>U</em> is a <a href="faithful_functor" title="wikilink">faithful functor</a> <em>C</em> → <strong>Set</strong> (the category of sets and functions).</li>
</ul>

<p>The functor <em>U</em> is to be thought of as a <a href="forgetful_functor" title="wikilink">forgetful functor</a>, which assigns to every object of <em>C</em> its "underlying set", and to every morphism in <em>C</em> its "underlying function".</p>

<p>A category <em>C</em> is <strong>concretizable</strong> if there exists a concrete category (<em>C</em>,<em>U</em>); i.e., if there exists a faithful functor <em>U</em>:<em>C</em> → <strong>Set</strong>. All small categories are concretizable: define <em>U</em> so that its object part maps each object <em>b</em> of <em>C</em> to the set of all morphisms of <em>C</em> whose <a class="uri" href="codomain" title="wikilink">codomain</a> is <em>b</em> (i.e. all morphisms of the form <em>f</em>: <em>a</em> → <em>b</em> for any object <em>a</em> of <em>C</em>), and its morphism part maps each morphism <em>g</em>: <em>b</em> → <em>c</em> of <em>C</em> to the function <em>U</em>(<em>g</em>): <em>U</em>(<em>b</em>) → <em>U</em>(<em>c</em>) which maps each member <em>f</em>: <em>a</em> → <em>b</em> of <em>U</em>(<em>b</em>) to the composition <em>gf</em>: <em>a</em> → <em>c</em>, a member of <em>U</em>(<em>c</em>). (Item 6 under <strong>Further examples</strong> expresses the same <em>U</em> in less elementary language via presheaves.) The <strong>Counter-examples</strong> section exhibits two large categories that are not concretizable.</p>
<h2 id="remarks">Remarks</h2>

<p>It is important to note that, contrary to intuition, concreteness is not a <a href="property_(philosophy)" title="wikilink">property</a> which a category may or may not satisfy, but rather a structure with which a category may or may not be equipped. In particular, a category <em>C</em> may admit several faithful functors into <strong>Set</strong>. Hence there may be several concrete categories (<em>C</em>,<em>U</em>) all corresponding to the same category <em>C</em>.</p>

<p>In practice, however, the choice of faithful functor is often clear and in this case we simply speak of the "concrete category <em>C</em>". For example, "the concrete category <strong>Set</strong>" means the pair (<strong>Set</strong>,<em>I</em>) where <em>I</em> denotes the <a href="identity_functor" title="wikilink">identity functor</a> <strong>Set</strong> → <strong>Set</strong>.</p>

<p>The requirement that <em>U</em> be faithful means that it maps different morphisms between the same objects to different functions. However, <em>U</em> may map different objects to the same set and, if this occurs, it will also map different morphisms to the same function.</p>

<p>For example, if <em>S</em> and <em>T</em> are two different topologies on the same set <em>X</em>, then (<em>X</em>,<em>S</em>) and (<em>X</em>,<em>T</em>) are distinct objects in the category <strong>Top</strong> of topological spaces and continuous maps, but mapped to the same set <em>X</em> by the forgetful functor <strong>Top</strong> → <strong>Set</strong>. Moreover, the identity morphism (<em>X</em>,<em>S</em>) → (<em>X</em>,<em>S</em>) and the identity morphism (<em>X</em>,<em>T</em>) → (<em>X</em>,<em>T</em>) are considered distinct morphisms in <strong>Top</strong>, but they have the same underlying function, namely the identity function on <em>X</em>.</p>

<p>Similarly, any set with 4 elements can be given two non-isomorphic group structures: one isomorphic to 

<math display="inline" id="Concrete_category:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mi>ℤ</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
      <mi>ℤ</mi>
     </mrow>
     <mo>×</mo>
     <mi>ℤ</mi>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <ci>ℤ</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>ℤ</ci>
      </apply>
      <ci>ℤ</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/2\mathbb{Z}\times\mathbb{Z}/2\mathbb{Z}
  </annotation>
 </semantics>
</math>

; the other isomorphic to 

<math display="inline" id="Concrete_category:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mn>4</mn>
   </mrow>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <cn type="integer">4</cn>
    </apply>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/4\mathbb{Z}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="further-examples">Further examples</h2>
<ol>
<li>Any group <em>G</em> may be regarded as an "abstract" category with one object, 

<math display="inline" id="Concrete_category:2">
 <semantics>
  <mo>∗</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-∗</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ast
  </annotation>
 </semantics>
</math>

, and one morphism for each element of the group. This would not be counted as concrete according to the intuitive notion described at the top of this article. But every faithful <a href="group_action" title="wikilink"><em>G</em>-set</a> (equivalently, every representation of <em>G</em> as a <a href="permutation_group" title="wikilink">group of permutations</a>) determines a faithful functor <em>G</em> → <strong>Set</strong>. Since every group acts faithfully on itself, <em>G</em> can be made into a concrete category in at least one way.</li>
<li>Similarly, any <a class="uri" href="poset" title="wikilink">poset</a> <em>P</em> may be regarded as an abstract category with a unique arrow <em>x</em> → <em>y</em> whenever <em>x</em> ≤ <em>y</em>. This can be made concrete by defining a functor <em>D</em> : <em>P</em> → <strong>Set</strong> which maps each object <em>x</em> to 

<math display="inline" id="Concrete_category:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>a</mi>
     <mo>∈</mo>
     <mi>P</mi>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mi>a</mi>
     <mo>≤</mo>
     <mi>x</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>a</ci>
      <ci>P</ci>
     </apply>
     <apply>
      <leq></leq>
      <ci>a</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(x)=\{a\in P:a\leq x\}
  </annotation>
 </semantics>
</math>

 and each arrow <em>x</em> → <em>y</em> to the inclusion map 

<math display="inline" id="Concrete_category:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>↪</mo>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↪</ci>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(x)\hookrightarrow D(y)
  </annotation>
 </semantics>
</math>

.</li>
<li>The category <strong><a href="Category_of_relations" title="wikilink">Rel</a></strong> whose objects are <a href="Set_(mathematics)" title="wikilink">sets</a> and whose morphisms are <a href="Relation_(mathematics)" title="wikilink">relations</a> can be made concrete by taking <em>U</em> to map each set <em>X</em> to its power set 

<math display="inline" id="Concrete_category:5">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>X</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{X}
  </annotation>
 </semantics>
</math>

 and each relation 

<math display="inline" id="Concrete_category:6">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>⊆</mo>
   <mrow>
    <mi>X</mi>
    <mo>×</mo>
    <mi>Y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>R</ci>
    <apply>
     <times></times>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\subseteq X\times Y
  </annotation>
 </semantics>
</math>

 to the function 

<math display="inline" id="Concrete_category:7">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <mi>X</mi>
    </msup>
    <mo>→</mo>
    <msup>
     <mn>2</mn>
     <mi>Y</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>ρ</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>X</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>Y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho:2^{X}\rightarrow 2^{Y}
  </annotation>
 </semantics>
</math>

 defined by 

<math display="inline" id="Concrete_category:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>ρ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>y</mi>
     <mo>∈</mo>
     <mi>Y</mi>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo>∃</mo>
       <mi>x</mi>
      </mrow>
      <mo>∈</mo>
      <mpadded width="+3.3pt">
       <mi>A</mi>
      </mpadded>
     </mrow>
     <mo rspace="5.8pt">.</mo>
     <mrow>
      <mi>x</mi>
      <mi>R</mi>
      <mi>y</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ρ</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>y</ci>
      <ci>Y</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <in></in>
       <apply>
        <exists></exists>
        <ci>x</ci>
       </apply>
       <ci>A</ci>
      </apply>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>R</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(A)=\{y\in Y:\exists x{\in}A~{}.~{}xRy\}
  </annotation>
 </semantics>
</math>

. Noting that power sets are <a href="complete_lattice" title="wikilink">complete lattices</a> under inclusion, those functions between them arising from some relation <em>R</em> in this way are exactly the <a href="Complete_lattice#Morphisms_of_complete_lattices" title="wikilink">supremum-preserving maps</a>. Hence <strong>Rel</strong> is equivalent to a full subcategory of the category <strong>Sup</strong> of <a href="complete_lattices" title="wikilink">complete lattices</a> and their sup-preserving maps. Conversely, starting from this equivalence we can recover <em>U</em> as the composite <strong>Rel</strong> → <strong>Sup</strong> → <strong>Set</strong> of the forgetful functor for <strong>Sup</strong> with this embedding of <strong>Rel</strong> in <strong>Sup</strong>.</li>
<li>The category <strong>Set</strong><sup>op</sup> can be embedded into <strong>Rel</strong> by representing each set as itself and each function <em>f</em>: <em>X</em> → <em>Y</em> as the relation from <em>Y</em> to <em>X</em> formed as the set of pairs (<em>f</em>(<em>x</em>),<em>x</em>) for all <em>x</em> ∈ <em>X</em>; hence <strong>Set</strong><sup>op</sup> is concretizable. The forgetful functor which arises in this way is the <a href="Functor#Examples" title="wikilink">contravariant powerset functor</a> <strong>Set</strong><sup>op</sup> → <strong>Set</strong>.</li>
<li>It follows from the previous example that the opposite of any concretizable category <em>C</em> is again concretizable, since if <em>U</em> is a faithful functor <em>C</em> → <strong>Set</strong> then <em>C</em><sup>op</sup> may be equipped with the composite <em>C</em><sup>op</sup> → <strong>Set</strong><sup>op</sup> → <strong>Set</strong>.</li>
<li>If <em>C</em> is any small category, then there exists a faithful functor <em>P</em> : <strong>Set</strong><sup><em>C</em><sup>op</sup></sup> → <strong>Set</strong> which maps a presheaf <em>X</em> to the coproduct 

<math display="inline" id="Concrete_category:9">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∐</mo>
    <mrow>
     <mi>c</mi>
     <mo>∈</mo>
     <mrow>
      <mi>ob</mi>
      <mi>C</mi>
     </mrow>
    </mrow>
   </msub>
   <mrow>
    <mi>X</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">coproduct</csymbol>
     <apply>
      <in></in>
      <ci>c</ci>
      <apply>
       <times></times>
       <ci>ob</ci>
       <ci>C</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>X</ci>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \coprod_{c\in\mathrm{ob}C}X(c)
  </annotation>
 </semantics>
</math>

. By composing this with the <a href="Yoneda_embedding" title="wikilink">Yoneda embedding</a> <em>Y</em>:<em>C</em> → <strong>Set</strong><sup><em>C</em><sup>op</sup></sup> one obtains a faithful functor <em>C</em> → <strong>Set</strong>.</li>
<li>For technical reasons, the category <strong>Ban</strong><sub>1</sub> of <a href="Banach_spaces" title="wikilink">Banach spaces</a> and <a href="contraction_(operator_theory)" title="wikilink">linear contractions</a> is often equipped not with the "obvious" forgetful functor but the functor <em>U</em><sub>1</sub> : <strong>Ban</strong><sub>1</sub> → <strong>Set</strong> which maps a Banach space to its (closed) <a href="unit_ball" title="wikilink">unit ball</a>.</li>
</ol>
<h2 id="counter-examples">Counter-examples</h2>

<p>The category <strong><a href="homotopy_category_of_topological_spaces" title="wikilink">hTop</a></strong>, where the objects are <a href="topological_space" title="wikilink">topological spaces</a> and the morphisms are <a href="homotopy" title="wikilink">homotopy classes</a> of continuous functions, is an example of a category that is not concretizable. While the objects are sets (with additional structure), the morphisms are not actual functions between them, but rather classes of functions. The fact that there does not exist <em>any</em> faithful functor from <strong>hTop</strong> to <strong>Set</strong> was first proven by <a href="Peter_Freyd" title="wikilink">Peter Freyd</a>. In the same article, Freyd cites an earlier result that the category of "small categories and <a href="natural_equivalence" title="wikilink">natural equivalence</a>-classes of functors" also fails to be concretizable.</p>
<h2 id="implicit-structure-of-concrete-categories">Implicit structure of concrete categories</h2>

<p>Given a concrete category (<em>C</em>,<em>U</em>) and a <a href="cardinal_number" title="wikilink">cardinal number</a> <em>N</em>, let <em>U<sup>N</sup></em> be the functor <em>C</em> → <strong>Set</strong> determined by <em>U<sup>N</sup>(c) = (U(c))<sup>N</sup></em>. Then a <a class="uri" href="subfunctor" title="wikilink">subfunctor</a> of <em>U<sup>N</sup></em> is called an <em>N-ary predicate</em> and a <a href="natural_transformation" title="wikilink">natural transformation</a> <em>U<sup>N</sup></em> → <em>U</em> an <em>N-ary operation</em>.</p>

<p>The class of all <em>N</em>-ary predicates and <em>N</em>-ary operations of a concrete category (<em>C</em>,<em>U</em>), with <em>N</em> ranging over the class of all cardinal numbers, forms a <a href="proper_class" title="wikilink">large</a> <a href="signature_(logic)" title="wikilink">signature</a>. The category of models for this signature then contains a full subcategory which is <a href="equivalence_of_categories" title="wikilink">equivalent</a> to <em>C</em>.</p>
<h2 id="relative-concreteness">Relative concreteness</h2>

<p>In some parts of category theory, most notably <a href="topos_theory" title="wikilink">topos theory</a>, it is common to replace the category <strong>Set</strong> with a different category <em>X</em>, often called a <em>base category</em>. For this reason, it makes sense to call a pair (<em>C</em>,<em>U</em>) where <em>C</em> is a category and <em>U</em> a faithful functor <em>C</em> → <em>X</em> a <strong>concrete category over</strong> <em>X</em>. For example, it may be useful to think of the models of a theory <a href="Structure_(mathematical_logic)#Many-sorted_structures" title="wikilink">with <em>N</em> sorts</a> as forming a concrete category over <strong>Set</strong><sup><em>N</em></sup>.</p>

<p>In this context, a concrete category over <strong>Set</strong> is sometimes called a <em>construct</em>.</p>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li>Adámek, Jiří, Herrlich, Horst, &amp; Strecker, George E.; (1990). <a href="http://katmat.math.uni-bremen.de/acc/acc.pdf"><em>Abstract and Concrete Categories</em></a> (4.2MB PDF). Originally publ. John Wiley &amp; Sons. ISBN 0-471-60922-6. (now free on-line edition).</li>
</ul>
<ul>
<li>Freyd, Peter; (1970). <a href="http://www.tac.mta.ca/tac/reprints/articles/6/tr6abs.html"><em>Homotopy is not concrete</em></a>. Originally published in: The Steenrod Algebra and its Applications, Springer Lecture Notes in Mathematics Vol. 168. Republished in a free on-line journal: Reprints in Theory and Applications of Categories, No. 6 (2004), with the permission of Springer-Verlag.</li>
</ul>
<ul>
<li>Rosický, Jiří; (1981). <em>Concrete categories and infinitary languages</em>. <a href="http://www.sciencedirect.com/science/journal/00224049"><em>Journal of Pure and Applied Algebra</em></a>, Volume 22, Issue 3.</li>
</ul>

<p>"</p>

<p><a href="Category:Category_theory" title="wikilink">Category:Category theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
