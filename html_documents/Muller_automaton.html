<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="664">Muller automaton</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Muller automaton</h1>
<hr/>

<p>In <a href="automata_theory" title="wikilink">automata theory</a>, a <strong>Muller automaton</strong> is a type of an <a class="uri" href="ω-automaton" title="wikilink">ω-automaton</a>. The acceptance condition separates a Muller automaton from other ω-automata. The Muller automata is defined using <a href="ω-automaton#Acceptance_conditions" title="wikilink">Muller acceptance condition</a>, i.e. the set of all states visited infinitely often must be an element of the acceptance set. Both deterministic and non-deterministic Muller automata recognize the <a href="ω-regular_language" title="wikilink">ω-regular languages</a>.</p>
<h2 id="formal-definition">Formal definition</h2>

<p>Formally, a <strong>deterministic Muller-automaton</strong> is a tuple <em>A</em> = (<em>Q</em>,Σ,δ,<em>q</em><sub>0</sub>,<strong>F</strong>) that consists of the following information:</p>
<ul>
<li><em>Q</em> is a <a href="finite_set" title="wikilink">finite set</a>. The elements of <em>Q</em> are called the <em>states</em> of <em>Q</em>.</li>
<li>Σ is a finite set called the <em>alphabet</em> of <em>A</em>.</li>
<li>δ: <em>Q</em> × Σ → <em>Q</em> is a function, called the <em>transition function</em> of <em>A</em>.</li>
<li><em>q</em><sub>0</sub> is an element of <em>Q</em>, called the initial state.</li>
<li><strong>F</strong> is a set of sets of states. Formally, <strong>F</strong> ⊆ <strong>P</strong>(<em>Q</em>) where <strong>P</strong>(<em>Q</em>) is <a class="uri" href="powerset" title="wikilink">powerset</a> of <em>Q</em>. <strong>F</strong> defines the <em>acceptance condition</em>. <em>A</em> accepts exactly those runs in which the set of infinitely often occurring states is an element of <strong><em>F</em></strong></li>
</ul>

<p>In a <strong>non-deterministic Muller automaton</strong>, the transition function δ is replaced with a transition relation Δ that returns a set of states and initial state is <em>q</em><sub>0</sub> is replaced by a set of initial states <em>Q</em><sub>0</sub>. Generally, Muller automaton refers to non-deterministic Muller automaton.</p>

<p>For more comprehensive formalism look at <a class="uri" href="ω-automaton" title="wikilink">ω-automaton</a>.</p>
<h2 id="equivalence-with-other-ω-automata">Equivalence with other ω-automata</h2>

<p>The Muller automata are equally <a href="Ω-automaton#Expressive_power_of_ω-automata" title="wikilink">expressive</a> as <a href="parity_automaton" title="wikilink">parity automata</a>, <a href="Rabin_automaton" title="wikilink">Rabin Automata</a>, <a href="Streett_automaton" title="wikilink">Streett automata</a>, and non-deterministic <a href="Büchi_automaton" title="wikilink">Büchi automata</a>, to mention some, and strictly more expressive than the deterministic Büchi automata. The equivalence of the above automata and non-deterministic Muller automata can be shown very easily as the accepting conditions of these automata can be emulated using the acceptance condition of Muller automata. <a href="McNaughton's_Theorem" title="wikilink">McNaughton's Theorem</a> demonstrates the equivalence of non-deterministic Büchi automaton and deterministic Muller automaton. Thus, deterministic and non-deterministic Muller automaton are equivalent in terms of the languages they can accept.</p>
<h2 id="transformation-to-non-deterministic-muller-automaton">Transformation to non-deterministic muller automaton</h2>

<p>Following is a list of <a href="automata_construction" title="wikilink">automata constructions</a> which transforms a type of ω-automata to a non-deterministic muller automaton.</p>
<dl>
<dt>From <a href="Büchi_automaton" title="wikilink">Büchi automaton</a></dt>
<dd>If 

<math display="inline" id="Muller_automaton:0">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is the set of final states in a Büchi automata with the set of states 

<math display="inline" id="Muller_automaton:1">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

, we can construct a Muller automata with same set of states, transition function and initial state with the muller accepting condition as <strong>F</strong> = { X | X ∈ 2<sup>Q</sup> ∧ X ∩ B ≠ 

<math display="inline" id="Muller_automaton:2">
 <semantics>
  <mi mathvariant="normal">∅</mi>
  <annotation-xml encoding="MathML-Content">
   <emptyset></emptyset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \emptyset
  </annotation>
 </semantics>
</math>

}
</dd>
</dl>
<dl>
<dt>From Rabin automaton/Parity automaton</dt>
<dd>Similarly, the Rabin conditions 

<math display="inline" id="Muller_automaton:3">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>E</mi>
    <mi>j</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>F</mi>
    <mi>j</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>j</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (E_{j},F_{j})
  </annotation>
 </semantics>
</math>

 can be emulated by constructing the acceptance set in the Muller automata as all sets in 

<math display="inline" id="Muller_automaton:4">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>⊆</mo>
   <msup>
    <mn>2</mn>
    <mi>Q</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>F</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\subseteq 2^{Q}
  </annotation>
 </semantics>
</math>

 which satisfy 

<math display="inline" id="Muller_automaton:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mo>∩</mo>
    <msub>
     <mi>E</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">∅</mi>
     <mi mathvariant="italic">and</mi>
     <mi>F</mi>
    </mrow>
    <mo>∩</mo>
    <msub>
     <mi>F</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>≠</mo>
   <mi mathvariant="normal">∅</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <intersect></intersect>
      <ci>F</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <intersect></intersect>
      <apply>
       <times></times>
       <emptyset></emptyset>
       <ci>italic- and</ci>
       <ci>F</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <neq></neq>
     <share href="#.cmml">
     </share>
     <emptyset></emptyset>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\cap E_{j}=\emptyset\and F\cap F_{j}\neq\emptyset
  </annotation>
 </semantics>
</math>

, for some j. Note that this covers the case of Parity automaton too, as the Parity acceptance condition can be expressed as Rabin acceptance condition easily.
</dd>
</dl>
<dl>
<dt>From Streett automaton</dt>
<dd>The Streett conditions 

<math display="inline" id="Muller_automaton:6">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>E</mi>
    <mi>j</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>F</mi>
    <mi>j</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>j</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (E_{j},F_{j})
  </annotation>
 </semantics>
</math>

 can be emulated by constructing the acceptance set in the Muller automata as all sets in 

<math display="inline" id="Muller_automaton:7">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>⊆</mo>
   <msup>
    <mn>2</mn>
    <mi>Q</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>F</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\subseteq 2^{Q}
  </annotation>
 </semantics>
</math>

 which satisfy 

<math display="inline" id="Muller_automaton:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mo>∩</mo>
    <msub>
     <mi>E</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi mathvariant="normal">∅</mi>
   <mo>→</mo>
   <mrow>
    <mi>F</mi>
    <mo>∩</mo>
    <msub>
     <mi>F</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi mathvariant="normal">∅</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <intersect></intersect>
      <ci>F</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <emptyset></emptyset>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <intersect></intersect>
      <ci>F</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <emptyset></emptyset>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\cap E_{j}=\emptyset\rightarrow F\cap F_{j}=\emptyset
  </annotation>
 </semantics>
</math>

, for all j.
</dd>
</dl>
<h2 id="transformation-to-deterministic-muller-automaton">Transformation to deterministic muller automaton</h2>
<dl>
<dt>Union of two deterministic muller automaton</dt>
</dl>
<dl>
<dt>From Büchi automaton</dt>
</dl>

<p><a href="McNaughton's_Theorem" title="wikilink">McNaughton's Theorem</a> provides a procedure to transform non-deterministic Büchi automaton to deterministic Muller automaton.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="http://www.tcs.tifr.res.in/~pandya/grad/aut06/lect4.pdf">Automata on Infinite Words</a> Slides for a tutorial by Paritosh K. Pandya.</li>
<li>Yde Venema (2008) <a href="http://staff.science.uva.nl/~yde/teaching/ml/mu/mu2008.pdf">Lectures on the Modal μ-calculus</a>; the <a href="http://folli.loria.fr/cds/2006/courses/Venema.TheModalMUCalculus.pdf">2006 version</a> was presented at The 18th European Summer School in Logic, Language and Information</li>
</ul>

<p>"</p>

<p><a href="Category:Automata_theory" title="wikilink">Category:Automata theory</a></p>
</body>
</html>
