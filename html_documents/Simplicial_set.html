<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1411">Simplicial set</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Simplicial set</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, a <strong>simplicial set</strong> is a construction in <a href="category_(mathematics)" title="wikilink">categorical</a> <a href="homotopy_theory" title="wikilink">homotopy theory</a> that is a purely algebraic model of the notion of a "<a class="uri" href="well-behaved" title="wikilink">well-behaved</a>" <a href="topological_space" title="wikilink">topological space</a>. Historically, this model arose from earlier work in <a href="combinatorial_topology" title="wikilink">combinatorial topology</a> and in particular from the notion of <a href="simplicial_complex" title="wikilink">simplicial complexes</a>. Simplicial sets are used to define <a href="quasi-category" title="wikilink">quasi-categories</a>, a basic notion of <a href="higher_category_theory" title="wikilink">higher category theory</a>.</p>
<h2 id="motivation">Motivation</h2>

<p>A simplicial set is a categorical (that is, purely algebraic) model capturing those topological spaces that can be built up (or faithfully represented up to homotopy) from <a href="simplex" title="wikilink">simplices</a> and their incidence relations. This is similar to the approach of <a href="CW_complex" title="wikilink">CW complexes</a> to modeling topological spaces, with the crucial difference that simplicial sets are purely algebraic and do not carry any actual topology (this will become clear in the formal definition).</p>

<p>To get back to actual topological spaces, there is a <em>geometric realization</em> <a class="uri" href="functor" title="wikilink">functor</a> which turns simplicial sets into <a href="compactly_generated_Hausdorff_space" title="wikilink">compactly generated Hausdorff spaces</a>. Most classical results on CW complexes in <a href="homotopy_theory" title="wikilink">homotopy theory</a> have analogous versions for simplicial sets which generalize these results. While algebraic topologists largely continue to prefer CW complexes, there is a growing contingent of researchers interested in using simplicial sets for applications in <a href="algebraic_geometry" title="wikilink">algebraic geometry</a> where CW complexes do not naturally exist.</p>
<h2 id="intuition">Intuition</h2>

<p>Simplicial sets can be viewed as a higher-dimensional generalization of <a href="graph_(mathematics)#Directed_graph" title="wikilink">directed multigraphs</a>. A simplicial set contains vertices (known as "0-simplices" in this context) and arrows ("1-simplices") between some of these vertices. Two vertices may be connected by several arrows, and directed loops that connect a vertex to itself are also allowed. Unlike directed multigraphs, simplicial sets may also contain higher simplices. A 2-simplex, for instance, can be thought of as a two-dimensional "triangular" shape bounded by an ordered list of three vertices <em>A</em>, <em>B</em>, <em>C</em> and three arrows <em>f</em>:<em>A</em>‚Üí<em>B</em>, <em>g</em>:<em>B</em>‚Üí<em>C</em> and <em>h</em>:<em>A</em>‚Üí<em>C</em>. In general, an <em>n</em>-simplex is an object made up from an ordered list of <em>n</em>+1 vertices (which are 0-simplices) and <em>n</em>+1 faces (which are (<em>n</em>-1)-simplices). The vertices of the <em>i</em>-th face are the vertices of the <em>n</em>-simplex minus the <em>i</em>-th vertex. The vertices of a simplex need not be distinct and a simplex is not determined by its vertices and faces: two different simplices may share the same list of faces (and therefore the same list of vertices).</p>

<p>Simplicial sets should not be confused with <a href="abstract_simplicial_complex" title="wikilink">abstract simplicial complexes</a>, which generalize <a href="graph_(mathematics)" title="wikilink">simple undirected graphs</a> rather than directed multigraphs.</p>

<p>Formally, a simplicial set <em>X</em> is a collection of sets <em>X</em><sub><em>n</em></sub>, <em>n</em>=0,1,2,..., together with certain maps between these sets: the <em>face maps</em> <em>d</em><sub><em>n</em>,<em>i</em></sub>:<em>X</em><sub><em>n</em></sub>‚Üí<em>X</em><sub><em>n</em>-1</sub> (<em>n</em>=1,2,3,... and 0‚â§<em>i</em>‚â§<em>n</em>) and <em>degeneracy maps</em> <em>s</em><sub><em>n</em>,<em>i</em></sub>:<em>X</em><sub><em>n</em></sub>‚Üí<em>X</em><sub><em>n</em>+1</sub> (<em>n</em>=0,1,2,... and 0‚â§<em>i</em>‚â§<em>n</em>). We think of the elements of <em>X</em><sub><em>n</em></sub> as the <em>n</em>-simplices of <em>X</em>. The map <em>d</em><sub><em>n</em>,<em>i</em></sub> assigns to each such <em>n</em>-simplex its <em>i</em>-th face, the face "opposite to" (i.e. not containing) the <em>i</em>-th vertex. The map <em>s</em><sub><em>n</em>,<em>i</em></sub> assigns to each <em>n</em>-simplex the degenerate (<em>n</em>+1)-simplex which arises from the given one by duplicating the <em>i</em>-th vertex. This description implicitly requires certain consistency relations among the maps <em>d</em><sub><em>n</em>,<em>i</em></sub> and <em>s</em><sub><em>n</em>,<em>i</em></sub>. Rather than requiring these <em>simplicial identities</em> explicitly as part of the definition, the short and elegant modern definition uses the language of <a href="category_theory" title="wikilink">category theory</a>.</p>
<h2 id="formal-definition">Formal definition</h2>

<p>Let Œî denote the <a href="simplex_category" title="wikilink">simplex category</a>. The objects of Œî are nonempty linearly ordered sets of the form</p>
<dl>
<dd>[<em>n</em>] = {0, 1, ..., <em>n</em>}
</dd>
</dl>

<p>with <em>n</em>‚â•0. The morphisms in Œî are (non-strictly) order-preserving functions between these sets.</p>

<p>A <strong>simplicial set</strong> <em>X</em> is a <a href="functor#Covariance_and_contravariance" title="wikilink">contravariant functor</a></p>
<dl>
<dd><em>X</em>: Œî ‚Üí <strong>Set</strong>
</dd>
</dl>

<p>where <strong>Set</strong> is the category of <a href="small_set_(category_theory)" title="wikilink">small sets</a>. (Alternatively and equivalently, one may define simplicial sets as <a href="functor#Covariance_and_contravariance" title="wikilink">covariant functors</a> from the <a href="Dual_(category_theory)" title="wikilink">opposite category</a> Œî<sup>op</sup> to <strong>Set</strong>.) Simplicial sets are therefore nothing but <a href="presheaf_(category_theory)" title="wikilink">presheafs</a> on Œî.</p>

<p>Alternatively, one can think of a simplicial set as a <strong>simplicial object</strong> (see <a href="#Simplicial_objects" title="wikilink">below</a>) in the category <strong>Set</strong>, but this is only different language for the definition just given. If we use a <em>covariant</em> functor <em>X</em>: Œî ‚Üí <strong>Set</strong> instead of a contravariant one, we arrive at the definition of a <strong>cosimplicial set</strong>.</p>

<p>Simplicial sets form a category, usually denoted <strong>sSet</strong>, whose objects are simplicial sets and whose morphisms are <a href="natural_transformations" title="wikilink">natural transformations</a> between them. There is a corresponding category for cosimplicial sets as well, denoted by <strong>cSet</strong>.</p>
<h2 id="face-and-degeneracy-maps">Face and degeneracy maps</h2>

<p>The simplex category Œî is generated by two particularly important families of morphisms (maps), whose images under a given simplicial set functor are called <strong>face maps</strong> and <strong>degeneracy maps</strong> of that simplicial set.</p>

<p>The <em>face maps</em> of a simplicial set are the images in that simplicial set of the morphisms 

<math display="inline" id="Simplicial_set:0">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>Œ¥</mi>
     <mn>0</mn>
    </msup>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <msup>
     <mi>Œ¥</mi>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>‚Üí</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Œ¥</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Œ¥</ci>
      <ci>n</ci>
     </apply>
    </list>
    <apply>
     <ci>normal-‚Üí</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta^{0},\ldots,\delta^{n}\colon[n-1]\to[n]
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Simplicial_set:1">
 <semantics>
  <msup>
   <mi>Œ¥</mi>
   <mi>i</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>Œ¥</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta^{i}
  </annotation>
 </semantics>
</math>

 is the only injection 

<math display="inline" id="Simplicial_set:2">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>‚Üí</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-‚Üí</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [n-1]\to[n]
  </annotation>
 </semantics>
</math>

 that "misses" 

<math display="inline" id="Simplicial_set:3">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

. Let us denote these face maps by 

<math display="inline" id="Simplicial_set:4">
 <semantics>
  <mrow>
   <msub>
    <mi>d</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">‚Ä¶</mi>
   <mo>,</mo>
   <msub>
    <mi>d</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-‚Ä¶</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{0},\ldots,d_{n}
  </annotation>
 </semantics>
</math>

 respectively.</p>

<p>The <em>degeneracy maps</em> of a simplicial set are the images in that simplicial set of the morphisms 

<math display="inline" id="Simplicial_set:5">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>œÉ</mi>
     <mn>0</mn>
    </msup>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <msup>
     <mi>œÉ</mi>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>‚Üí</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>n</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>œÉ</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>œÉ</ci>
      <ci>n</ci>
     </apply>
    </list>
    <apply>
     <ci>normal-‚Üí</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{0},\ldots,\sigma^{n}\colon[n+1]\to[n]
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Simplicial_set:6">
 <semantics>
  <msup>
   <mi>œÉ</mi>
   <mi>i</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>œÉ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{i}
  </annotation>
 </semantics>
</math>

 is the only surjection 

<math display="inline" id="Simplicial_set:7">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>‚Üí</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-‚Üí</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [n+1]\to[n]
  </annotation>
 </semantics>
</math>

 that "hits" 

<math display="inline" id="Simplicial_set:8">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 twice. Let us denote these degeneracy maps by 

<math display="inline" id="Simplicial_set:9">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">‚Ä¶</mi>
   <mo>,</mo>
   <msub>
    <mi>s</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-‚Ä¶</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{0},\ldots,s_{n}
  </annotation>
 </semantics>
</math>

 respectively.</p>

<p>The defined maps satisfy the following <strong>simplicial identities</strong>:</p>
<ol>
<li><em>d<sub>i</sub> d<sub>j</sub></em> = <em>d</em><sub><em>j</em>‚àí1</sub> <em>d</em><sub><em>i</em></sub> if <em>i</em> &lt; <em>j</em></li>
<li><em>d<sub>i</sub> s<sub>j</sub></em> = <em>s</em><sub><em>j</em>‚àí1</sub> <em>d<sub>i</sub></em> if <em>i</em> &lt; <em>j</em></li>
<li><em>d<sub>i</sub> s<sub>j</sub></em> = id if <em>i</em> = <em>j</em> or <em>i</em> = <em>j</em>¬†+¬†1</li>
<li><em>d<sub>i</sub> s<sub>j</sub></em> = <em>s</em><sub><em>j</em></sub> <em>d</em><sub><em>i</em>‚àí1</sub> if <em>i</em> &gt; <em>j</em>¬†+¬†1</li>
<li><em>s<sub>i</sub> s<sub>j</sub></em> = <em>s</em><sub><em>j</em>+1</sub> <em>s</em><sub><em>i</em></sub> if <em>i</em> ‚â§ <em>j</em>.</li>
</ol>
<h2 id="examples">Examples</h2>

<p>Given a <a href="partially_ordered_set" title="wikilink">partially ordered set</a> (<em>S</em>,‚â§), we can define a simplicial set <em>NS</em>, the <a href="nerve_(category_theory)" title="wikilink">nerve</a> of <em>S</em>, as follows: for every object [<em>n</em>] of Œî we set <em>NS</em>([<em>n</em>]) = hom<sub><strong>po-set</strong></sub>( [<em>n</em>] , <em>S</em>), the order-preserving maps from [<em>n</em>] to <em>S</em>. Every morphism œÜ:[<em>n</em>]‚Üí[<em>m</em>] in Œî is an order preserving map, and via composition induces a map <em>NS</em>(œÜ) : <em>NS</em>([<em>m</em>]) ‚Üí <em>NS</em>([<em>n</em>]). It is straightforward to check that <em>NS</em> is a contravariant functor from Œî to <strong>Set</strong>: a simplicial set.</p>

<p>Concretely, the <em>n</em>-simplices of the nerve <em>NS</em>, i.e. the elements of <em>NS</em><sub><em>n</em></sub>=<em>NS</em>([<em>n</em>]), can be thought of as ordered length-(<em>n</em>+1) sequences of elements from <em>S</em>: (<em>a</em><sub>0</sub> ‚â§ <em>a</em><sub>1</sub> ‚â§ ... ‚â§ <em>a</em><sub><em>n</em></sub>). The face map <em>d</em><sub><em>i</em></sub> drops the <em>i</em>-th element from such a list, and the degeneracy maps <em>s</em><sub><em>i</em></sub> duplicates the <em>i</em>-th element.</p>

<p>A similar construction can be performed for every category <em>C</em>, to obtain the nerve <em>NC</em> of <em>C</em>. Here, <em>NC</em>([<em>n</em>]) is the set of all functors from [<em>n</em>] to <em>C</em>, where we consider [<em>n</em>] as a category with objects 0,1,...,<em>n</em> and a single morphism from <em>i</em> to <em>j</em> whenever <em>i</em>‚â§<em>j</em>.</p>

<p>Concretely, the <em>n</em>-simplices of the nerve <em>NC</em> can be thought of as sequences of <em>n</em> composable morphisms in <em>C</em>: <em>a</em><sub>0</sub>‚Üí<em>a</em><sub>1</sub>‚Üí...‚Üí<em>a</em><sub><em>n</em></sub>. (In particular, the 0-simplices are the objects of <em>C</em> and the 1-simplices are the morphisms of <em>C</em>.) The face map <em>d</em><sub>0</sub> drops the first morphism from such a list, the face map <em>d</em><sub><em>n</em></sub> drops the last, and the face map <em>d</em><sub><em>i</em></sub> for 0<em>i</em> lengthen the sequence by inserting an identity morphism at position <em>i</em>.</p>

<p>We can recover the poset <em>S</em> from the nerve <em>NS</em> and the category <em>C</em> from the nerve <em>NC</em>; in this sense simplicial sets generalize posets and categories.</p>

<p>Another important class of examples of simplicial sets is given by the singular set <em>SY</em> of a topological space <em>Y</em>. Here <em>SY</em><sub><em>n</em></sub> consists of all the continuous maps from the standard topological <em>n</em>-simplex to <em>Y</em>. The singular set is further explained below.</p>
<h2 id="the-standard-n-simplex-and-the-category-of-simplices">The standard <em>n</em>-simplex and the category of simplices</h2>

<p>The <strong>standard <em>n</em>-simplex</strong>, denoted Œî<sup><em>n</em></sup>, is a simplicial set defined as the functor hom<sub>Œî</sub>(-, [<em>n</em>]) where [<em>n</em>] denotes the ordered set {0, 1, ... ,<em>n</em>} of the first (<em>n</em> + 1) nonnegative integers. In many texts, it is written instead as hom([<em>n</em>],-) where the homset is understood to be in the opposite category Œî<sup>op</sup>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The geometric realization |Œî<sup><em>n</em></sup>| is just defined to be the standard topological <em>n</em>-<a class="uri" href="simplex" title="wikilink">simplex</a> in general position given by</p>

<p>

<math display="block" id="Simplicial_set:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <msup>
      <mi mathvariant="normal">Œî</mi>
      <mi>n</mi>
     </msup>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>0</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">‚Ä¶</mi>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>‚àà</mo>
      <msup>
       <mi>‚Ñù</mi>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
     <mo>:</mo>
     <mrow>
      <mrow>
       <mn>0</mn>
       <mo>‚â§</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo>‚â§</mo>
       <mn>1</mn>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mrow>
        <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Œî</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>normal-‚Ä¶</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </vector>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>‚Ñù</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <and></and>
       <apply>
        <leq></leq>
        <cn type="integer">0</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <leq></leq>
        <share href="#.cmml">
        </share>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <apply>
        <sum></sum>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\Delta^{n}|=\{(x_{0},\dots,x_{n})\in\mathbb{R}^{n+1}:0\leq x_{i}\leq 1,\sum x%
_{i}=1\}.
  </annotation>
 </semantics>
</math>

</p>

<p>By the <a href="Yoneda_lemma" title="wikilink">Yoneda lemma</a>, the <em>n</em>-simplices of a simplicial set <em>X</em> are classified by natural transformations in hom(Œî<sup><em>n</em></sup>, <em>X</em>). (Specifically, consider 

<math display="inline" id="Simplicial_set:11">
 <semantics>
  <mrow>
   <msup>
    <mi mathvariant="normal">Œî</mi>
    <mi>n</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi mathvariant="normal">Œî</mi>
     <mi>op</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ùêß</mi>
     <mo>,</mo>
     <mo>-</mo>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Œî</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Œî</ci>
      <ci>op</ci>
     </apply>
     <interval closure="open">
      <ci>ùêß</ci>
      <minus></minus>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta^{n}=\Delta^{\mathrm{op}}(\mathbf{n},-)
  </annotation>
 </semantics>
</math>

, then the Yoneda lemma gives 

<math display="inline" id="Simplicial_set:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>Nat</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi mathvariant="normal">Œî</mi>
       <mi>op</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ùêß</mi>
       <mo>,</mo>
       <mo>-</mo>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚âÖ</mo>
   <mrow>
    <mi>X</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ùêß</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>Nat</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-Œî</ci>
        <ci>op</ci>
       </apply>
       <interval closure="open">
        <ci>ùêß</ci>
        <minus></minus>
       </interval>
      </apply>
      <ci>X</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>X</ci>
     <ci>ùêß</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Nat}(\Delta^{\mathrm{op}}(\mathbf{n},-),X)\cong X(\mathbf{n})
  </annotation>
 </semantics>
</math>

) The <em>n</em>-simplices of <em>X</em> are then collectively denoted by <em>X<sub>n</sub></em>. Furthermore, there is a <a href="category_of_elements" title="wikilink">category of simplices</a>, denoted by 

<math display="inline" id="Simplicial_set:13">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Œî</mi>
   <mo>‚Üì</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-‚Üì</ci>
    <ci>normal-Œî</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta\downarrow{X}
  </annotation>
 </semantics>
</math>

 whose objects are maps (<em>i.e.</em> natural transformations) Œî<sup><em>n</em></sup> ‚Üí <em>X</em> and whose morphisms are natural transformations Œî<sup><em>n</em></sup> ‚Üí Œî<sup><em>m</em></sup> over <em>X</em> arising from maps [<em>n</em>] <em>‚Üí</em> [<em>m</em>] in Œî. That is, 

<math display="inline" id="Simplicial_set:14">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Œî</mi>
   <mo>‚Üì</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-‚Üì</ci>
    <ci>normal-Œî</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta\downarrow{X}
  </annotation>
 </semantics>
</math>

 is a <a href="slice_category" title="wikilink">slice category</a> of Œî over <em>X</em>. The following isomorphism shows that a simplicial set <em>X</em> is a <a class="uri" href="colimit" title="wikilink">colimit</a> of its simplices:<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>

<math display="block" id="Simplicial_set:15">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>‚âÖ</mo>
   <mrow>
    <msub>
     <munder accentunder="true">
      <mo movablelimits="false">lim</mo>
      <mo>‚Üí</mo>
     </munder>
     <mrow>
      <msup>
       <mi mathvariant="normal">Œî</mi>
       <mi>n</mi>
      </msup>
      <mo>‚Üí</mo>
      <mi>X</mi>
     </mrow>
    </msub>
    <msup>
     <mi mathvariant="normal">Œî</mi>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>X</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">injective-limit</csymbol>
      <apply>
       <ci>normal-‚Üí</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-Œî</ci>
        <ci>n</ci>
       </apply>
       <ci>X</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Œî</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\cong\underrightarrow{\lim}_{\Delta^{n}\to X}\Delta^{n}
  </annotation>
 </semantics>
</math>

</p>

<p>where the colimit is taken over the category of simplices of <em>X</em>.</p>
<h2 id="geometric-realization">Geometric realization</h2>

<p>There is a functor |‚Ä¢|: <strong>sSet</strong> <em>‚Üí</em> <strong>CGHaus</strong> called the <strong>geometric realization</strong> taking a simplicial set <em>X</em> to its corresponding realization in the category of <a href="compactly-generated_space" title="wikilink">compactly-generated</a> <a href="Hausdorff_topological_space" title="wikilink">Hausdorff topological spaces</a>.</p>

<p>This larger category is used as the target of the functor because, in particular, a product of simplicial sets</p>

<p>

<math display="block" id="Simplicial_set:16">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>√ó</mo>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\times Y
  </annotation>
 </semantics>
</math>

</p>

<p>is realized as a product</p>

<p>

<math display="block" id="Simplicial_set:17">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>X</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <msub>
    <mo>√ó</mo>
    <mrow>
     <mi>K</mi>
     <mi>e</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>Y</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <times></times>
     <apply>
      <times></times>
      <ci>K</ci>
      <ci>e</ci>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <ci>X</ci>
    </apply>
    <apply>
     <abs></abs>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |X|\times_{Ke}|Y|
  </annotation>
 </semantics>
</math>

</p>

<p>of the corresponding topological spaces, where 

<math display="inline" id="Simplicial_set:18">
 <semantics>
  <msub>
   <mo>√ó</mo>
   <mrow>
    <mi>K</mi>
    <mi>e</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <times></times>
    <apply>
     <times></times>
     <ci>K</ci>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \times_{Ke}
  </annotation>
 </semantics>
</math>

 denotes the Kelley space product. This product is the right adjoint functor that takes <em>X</em> to <em>X</em><sub>C</sub> as described <a href="compactly-generated_space#Properties" title="wikilink">here</a>, applied to the ordinary topological product |<em>X</em>| √ó |<em>Y</em>|.</p>

<p>To define the realization functor, we first define it on n-simplices <em>Œî<sup>n</sup></em> as the corresponding topological n-simplex |<em>Œî<sup>n</sup></em>|. The definition then naturally extends to any simplicial set <em>X</em> by setting</p>
<dl>
<dd>|X| = lim<sub><em>Œî<sup>n</sup> ‚Üí X</em></sub> |<em>Œî<sup>n</sup></em>|
</dd>
</dl>

<p>where the colimit is taken over the n-simplex category of <em>X</em>. The geometric realization is functorial on <strong>sSet</strong>.</p>
<h2 id="singular-set-for-a-space">Singular set for a space</h2>

<p>The <strong>singular set</strong> of a topological space <em>Y</em> is the simplicial set <em>S(Y)</em> defined by</p>
<dl>
<dd><em>S(Y)</em>([<em>n</em>]) = <em>hom<sub><strong>Top</strong></sub>(</em>|<em>Œî<sup>n</sup></em>|, <em>Y)</em> for each object [<em>n</em>] <em>‚àà Œî</em>,
</dd>
</dl>

<p>with the obvious functoriality condition on the morphisms. This definition is analogous to a standard idea in <a href="singular_homology" title="wikilink">singular homology</a> of "probing" a target topological space with standard topological n-simplices. Furthermore, the <strong>singular functor</strong> <em>S</em> is <a href="adjoint_functor" title="wikilink">right adjoint</a> to the geometric realization functor described above, i.e.:</p>
<dl>
<dd>hom<sub><strong>Top</strong></sub>(|<em>X</em>|, <em>Y</em>) ‚âÖ hom<sub><strong>S</strong></sub>(<em>X</em>, <em>SY</em>)
</dd>
</dl>

<p>for any simplicial set <em>X</em> and any topological space <em>Y</em>.</p>
<h2 id="homotopy-theory-of-simplicial-sets">Homotopy theory of simplicial sets</h2>

<p>In the category of simplicial sets one can define <a href="fibration" title="wikilink">fibrations</a> to be <a href="Kan_fibration" title="wikilink">Kan fibrations</a>. A map of simplicial sets is defined to be a <a href="weak_equivalence_(homotopy_theory)" title="wikilink">weak equivalence</a> if its geometric realization is a weak equivalence of spaces. A map of simplicial sets is defined to be a <a class="uri" href="cofibration" title="wikilink">cofibration</a> if it is a <a class="uri" href="monomorphism" title="wikilink">monomorphism</a> of simplicial sets. It is a difficult theorem of <a href="Daniel_Quillen" title="wikilink">Daniel Quillen</a> that the category of simplicial sets with these classes of morphisms satisfies the axioms for a <a href="proper_model_category" title="wikilink">proper</a> <a href="closed_model_category" title="wikilink">closed</a> <a href="simplicial_model_category" title="wikilink">simplicial</a> <a href="model_category" title="wikilink">model category</a>.</p>

<p>A key turning point of the theory is that the geometric realization of a Kan fibration is a <a href="Serre_fibration" title="wikilink">Serre fibration</a> of spaces. With the model structure in place, a homotopy theory of simplicial sets can be developed using standard <a href="homotopical_algebra" title="wikilink">homotopical algebra</a> methods. Furthermore, the geometric realization and singular functors give a <a href="Quillen_adjunction" title="wikilink">Quillen equivalence</a> of <a href="closed_model_category" title="wikilink">closed model categories</a> inducing an equivalence of homotopy categories</p>
<dl>
<dd>|‚Ä¢|: <em>Ho</em>(<strong>sSet</strong>) ‚Üî <em>Ho</em>(<strong>Top</strong>)
</dd>
</dl>

<p>between the <a href="homotopy_category" title="wikilink">homotopy category</a> for simplicial sets and the usual homotopy category of CW complexes with homotopy classes of maps between them. It is part of the general definition of a Quillen adjunction that the right adjoint functor (in this case, the singular set functor) carries fibrations (resp. trivial fibrations) to fibrations (resp. trivial fibrations).</p>
<h2 id="simplicial-objects">Simplicial objects</h2>

<p>A <strong>simplicial object</strong> <em>X</em> in a category <em>C</em> is a contravariant functor</p>
<dl>
<dd><em>X: Œî ‚Üí C</em>
</dd>
</dl>

<p>or equivalently a covariant functor</p>
<dl>
<dd><em>X</em>: Œî<sup>op</sup> ‚Üí <em>C</em>
</dd>
</dl>

<p>When <em>C</em> is the <a href="category_of_sets" title="wikilink">category of sets</a>, we are just talking about simplicial sets. Letting <em>C</em> be the <a href="category_of_groups" title="wikilink">category of groups</a> or <a href="category_of_abelian_groups" title="wikilink">category of abelian groups</a>, we obtain the categories <strong>sGrp</strong> of simplicial <a href="group_(mathematics)" title="wikilink">groups</a> and <strong>sAb</strong> of simplicial <a href="abelian_group" title="wikilink">abelian groups</a>, respectively.</p>

<p><a href="Simplicial_group" title="wikilink">Simplicial groups</a> and simplicial abelian groups also carry closed model structures induced by that of the underlying simplicial sets.</p>

<p>The homotopy groups of simplicial abelian groups can be computed by making use of the <a href="Dold-Kan_correspondence" title="wikilink">Dold-Kan correspondence</a> which yields an equivalence of categories between simplicial abelian groups and bounded <a href="chain_complex" title="wikilink">chain complexes</a> and is given by functors</p>
<dl>
<dd><em>N:</em> <strong>sAb</strong> <em>‚Üí Ch<sub>+</sub></em>
</dd>
</dl>

<p>and</p>
<dl>
<dd>''Œì: Ch<sub>+</sub> ‚Üí ''¬†<strong>sAb</strong>.
</dd>
</dl>
<h2 id="history-and-uses-of-simplicial-sets">History and uses of simplicial sets</h2>

<p>Simplicial sets were originally used to give precise and convenient descriptions of <a href="classifying_space" title="wikilink">classifying spaces</a> of <a href="group_(mathematics)" title="wikilink">groups</a>. This idea was vastly extended by <a class="uri" href="Grothendieck" title="wikilink">Grothendieck</a>'s idea of considering classifying spaces of categories, and in particular by <a href="Daniel_Quillen" title="wikilink">Quillen</a>'s work of <a href="algebraic_K-theory" title="wikilink">algebraic K-theory</a>. In this work, which earned him a <a href="Fields_Medal" title="wikilink">Fields Medal</a>, Quillen developed surprisingly efficient methods for manipulating infinite simplicial sets. Later these methods were used in other areas on the border between algebraic geometry and topology. For instance, the <a href="Andr√©-Quillen_cohomology" title="wikilink">Andr√©-Quillen homology</a> of a ring is a "non-abelian homology", defined and studied in this way.</p>

<p>Both the algebraic K-theory and the Andr√©-Quillen homology are defined using algebraic data to write down a simplicial set, and then taking the homotopy groups of this simplicial set. Sometimes one simply defines the algebraic 

<math display="inline" id="Simplicial_set:19">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

-theory as the space.</p>

<p>Simplicial methods are often useful when one wants to prove that a space is a <a href="loop_space" title="wikilink">loop space</a>. The basic idea is that if 

<math display="inline" id="Simplicial_set:20">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 is a group with classifying space 

<math display="inline" id="Simplicial_set:21">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   BG
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Simplicial_set:22">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 is homotopy equivalent to the loop space 

<math display="inline" id="Simplicial_set:23">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Œ©</mi>
   <mi>B</mi>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Œ©</ci>
    <ci>B</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega BG
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Simplicial_set:24">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   BG
  </annotation>
 </semantics>
</math>

 itself is a group, we can iterate the procedure, and 

<math display="inline" id="Simplicial_set:25">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 is homotopy equivalent to the double loop space 

<math display="inline" id="Simplicial_set:26">
 <semantics>
  <mrow>
   <msup>
    <mi mathvariant="normal">Œ©</mi>
    <mn>2</mn>
   </msup>
   <mi>B</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>B</mi>
     <mi>G</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Œ©</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>B</ci>
    <apply>
     <times></times>
     <ci>B</ci>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega^{2}B(BG)
  </annotation>
 </semantics>
</math>

. In case 

<math display="inline" id="Simplicial_set:27">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 is an abelian group, we can actually iterate this infinitely many times, and obtain that 

<math display="inline" id="Simplicial_set:28">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 is an infinite loop space.</p>

<p>Even if 

<math display="inline" id="Simplicial_set:29">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is not an Abelian group, it can happen that it has a composition which is sufficiently commutative so that one can use the above idea to prove that 

<math display="inline" id="Simplicial_set:30">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is an infinite loop space. In this way, one can prove that the algebraic 

<math display="inline" id="Simplicial_set:31">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

-theory of a ring, considered as a topological space, is an infinite loop space.</p>

<p>In recent years, simplicial sets have been used in <a href="higher_category_theory" title="wikilink">higher category theory</a> and <a href="derived_algebraic_geometry" title="wikilink">derived algebraic geometry</a>. Quasi-categories can be thought of as categories in which the composition of morphisms is defined only up to homotopy, and information about the composition of higher homotopies is also retained. Quasi-categories are defined as simplicial sets satisfying one additional condition, the weak Kan condition.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Delta_set" title="wikilink">Delta set</a></li>
<li><a href="Dendroidal_set" title="wikilink">Dendroidal set</a>, a generalization of simplicial set.</li>
<li><a href="Simplicial_presheaf" title="wikilink">Simplicial presheaf</a></li>
<li><a class="uri" href="infinity-category" title="wikilink">infinity-category</a></li>
<li><a href="Homotopy_type_theory" title="wikilink">Homotopy type theory</a></li>
<li><a href="Kan_complex" title="wikilink">Kan complex</a></li>
<li><a href="Dold‚ÄìKan_correspondence" title="wikilink">Dold‚ÄìKan correspondence</a></li>
<li><a href="Simplicial_homotopy" title="wikilink">Simplicial homotopy</a></li>
<li><a href="Simplicial_sphere" title="wikilink">Simplicial sphere</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li>Dylan G.L. Allegretti, <a href="http://www.math.uchicago.edu/~may/VIGRE/VIGRE2008/REUPapers/Allegretti.pdf"><em>Simplicial Sets and van Kampen's Theorem</em></a> <em>(An elementary introduction to simplicial sets)</em>.</li>
</ul>
<ul>
<li>Daniel Quillen: Higher algebraic K-theory: I. In: H. Bass (ed.): Higher K-Theories. Lecture Notes in Mathematics, vol. 341. Springer-Verlag, Berlin 1973. ISBN 3-540-06434-6</li>
</ul>
<ul>
<li>G.B. Segal, Categories and cohomology theories, Topology, 13, (1974), 293 - 312.</li>
</ul>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Algebraic_topology" title="wikilink">Category:Algebraic topology</a> <a href="Category:Homotopy_theory" title="wikilink">Category:Homotopy theory</a> <a href="Category:Simplicial_sets" title="wikilink"> </a> <a class="uri" href="Category:Functors" title="wikilink">Category:Functors</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">S. Gelfand, Yu. Manin, "Methods of Homological Algebra"<a href="#fnref1">‚Ü©</a></li>
<li id="fn2">Goerss &amp; Jardine, p.7<a href="#fnref2">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
