<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1945">Memory refresh</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Memory refresh</h1>
<hr/>

<p><strong>Memory refresh</strong> is the process of periodically reading information from an area of <a href="computer_memory" title="wikilink">computer memory</a> and immediately rewriting the read information to the same area without modification, for the purpose of preserving the information.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Memory refresh is a background maintenance process required during the operation of semiconductor <a href="dynamic_random_access_memory" title="wikilink">dynamic random access memory</a> (DRAM), the most widely used type of computer memory, and in fact is the defining characteristic of this class of memory.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> In a DRAM chip, each <a href="binary_digit" title="wikilink">bit</a> of memory data is stored as the presence or absence of an <a href="electric_charge" title="wikilink">electric charge</a> on a small <a class="uri" href="capacitor" title="wikilink">capacitor</a> on the chip.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> As time passes, the charges in the memory cells leak away, so without being refreshed the stored data would eventually be lost. To prevent this, external circuitry periodically reads each cell and rewrites it, restoring the charge on the capacitor to its original level. Each <em>memory refresh cycle</em> refreshes a succeeding area of memory cells, thus repeatedly refreshing all the cells in a consecutive cycle. This process is conducted automatically, in the background, by the memory circuitry, while the computer is on, and is transparent to the user.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> While a refresh cycle is occurring the memory is not available for normal read and write operations, but in modern memory this "overhead" time is not large enough to significantly slow down memory operation.</p>

<p>Computer memory that does not require refreshing is available, called <a href="static_random_access_memory" title="wikilink">static random access memory</a> (SRAM).<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> SRAM circuits take up more room on the semiconductor chip, because each SRAM <a href="Computer_data_storage" title="wikilink">memory cell</a> requires 4 - 6 <a href="transistor" title="wikilink">transistors</a>, compared to a single transistor and a capacitor for DRAM. For this reason the storage capacity of SRAM chips is much less than DRAM, so SRAM memory is more costly per bit. Therefore DRAM is used for the main memory in computers, video game consoles, graphics cards and most other large uses of <a href="semiconductor_memory" title="wikilink">semiconductor memory</a>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> The need for extra circuitry to perform memory refresh makes DRAM circuits and their timing significantly more complicated than SRAM circuits, but the great advantages of DRAM in density and cost justify this complexity.</p>
<h2 id="how-dram-refresh-works">How DRAM refresh works</h2>

<p>While the memory is operating, each memory cell must be refreshed repetitively, within the maximum interval between refreshes specified by the manufacturer, which is usually in the millisecond region. Refreshing does not employ the normal memory operations (read and write cycles) used to access data, but specialized cycles called <em>refresh cycles</em> which are generated by separate counter circuits in the memory circuitry and interspersed between normal memory accesses.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>The storage cells on a memory chip are laid out in a rectangular array of rows and columns. The read process in DRAM is <em>destructive</em> and removes the charge on the memory cells in an entire row, so there is a row of specialized latches on the chip called <a href="sense_amplifier" title="wikilink">sense amplifiers</a>, one for each column of memory cells, to temporarily hold the data. During a normal read operation, the <a href="sense_amplifier" title="wikilink">sense amplifiers</a> after reading and latching the data, rewrite the data in the accessed row<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> before sending the bit from a single column to output. So the normal read electronics on the chip has the ability to refresh an entire row of memory in parallel, significantly speeding up the refresh process. A normal read or write cycle refreshes a row of memory, but normal memory accesses cannot be relied on to hit all the rows within the necessary time, necessitating a separate refresh process. Rather than use the normal read cycle in the refresh process, to save time an abbreviated cycle called a refresh cycle is used. The refresh cycle is similar to the read cycle, but executes faster for two reasons:</p>
<ul>
<li>For a refresh, only the row address is needed, so a column address doesn't have to be applied to the chip address circuits.</li>
<li>Data read from the cells does not need to be fed into the output buffers or the <a href="Bus_(computing)" title="wikilink">data bus</a> to send to the CPU.</li>
</ul>

<p>The refresh circuitry must perform a refresh cycle on each of the rows on the chip within the refresh time interval, to make sure that each cell gets refreshed.</p>
<h3 id="types-of-refresh-circuits">Types of refresh circuits</h3>

<p>Although in some early systems the <a class="uri" href="microprocessor" title="wikilink">microprocessor</a> controlled refresh, with a timer triggering a periodic <a class="uri" href="interrupt" title="wikilink">interrupt</a> that ran a <a class="uri" href="subroutine" title="wikilink">subroutine</a> that performed the refresh, this meant the microprocessor could not be paused, single-stepped, or put into energy-saving <a href="hibernation_(computing)" title="wikilink">hibernation</a> without stopping the refresh process and losing the data in memory.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> So in modern systems refresh is handled by circuits in the <a href="memory_controller" title="wikilink">memory controller</a>,<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> or increasingly on the chip itself. Some DRAM chips, such as pseudostatic RAM (PSRAM), have all the refresh circuitry on the chip, and function like <a href="Static_random_access_memory" title="wikilink">static RAM</a> as far as the rest of the computer is concerned.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>Usually the refresh circuitry consists of a <em>refresh counter</em> which contains the address of the row to be refreshed which is applied to the chip's row address lines, and a timer that increments the counter to step through the rows.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> This counter may be part of the memory controller circuitry, or on the memory chip itself. Two scheduling strategies have been used:<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<ul>
<li><em>Burst refresh</em> - a series of refresh cycles are performed one after another until all the rows have been refreshed, after which normal memory accesses occur until the next refresh is required</li>
<li><em>Distributed refresh</em> - refresh cycles are performed at regular intervals, interspersed with memory accesses.</li>
</ul>

<p>Burst refresh results in long periods when the memory is unavailable, so distributed refresh has been used in most modern systems,<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> particularly in <a href="Real-time_computing" title="wikilink">real time</a> systems. In distributed refresh, the interval between refresh cycles is</p>

<p>

<math display="block" id="Memory_refresh:0">
 <semantics>
  <mrow>
   <mtext>refresh cycle interval</mtext>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mtext>refresh time</mtext>
    </mpadded>
    <mo rspace="4.2pt">/</mo>
    <mpadded width="+1.7pt">
     <mtext>number of rows</mtext>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <mtext>refresh cycle interval</mtext>
    <apply>
     <divide></divide>
     <mtext>refresh time</mtext>
     <mtext>number of rows</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{refresh cycle interval}=\text{refresh time}\,/\,\text{number of rows}\,
  </annotation>
 </semantics>
</math>

 For example, the current generation of chips (DDR SDRAM) has a refresh time of 64 ms and 8,192 rows, so the refresh cycle interval is 7.8 μs.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>Recent generations of DRAM chips contain an integral refresh counter, and the memory control circuitry can either use this counter or provide a row address from an external counter. These chips have three standard ways to provide refresh, selected by different patterns of signals on the "column select" (CAS) and "row select" (RAS) lines:<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<ul>
<li>"<em>RAS only refresh</em>" - In this mode the address of the row to refresh is provided by the address bus lines, so it is used with external counters in the memory controller.</li>
<li>"<em>CAS before RAS refresh</em>" (CBR) - In this mode the on-chip counter keeps track of the row to be refreshed and the external circuit merely initiates the refresh cycles.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> This mode uses less power because the memory address bus buffers don't have to be powered up. It is used in most modern computers.</li>
<li>"<em>Hidden refresh</em>" - This is an alternate version of the CBR refresh cycle which can be combined with a preceding read or write cycle.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> The refresh is done in parallel during the data transfer, saving time.</li>
</ul>

<p>In the latest (2012) generation of chips the "RAS only" mode has been eliminated, and the internal counter is used to generate refresh. The chip has an additional "sleep mode", for use when the computer is in <a href="hibernation_(computing)" title="wikilink">hibernation</a>, in which an on-chip oscillator generates internal refresh cycles so that the external clock can be shut down.</p>
<h3 id="refresh-overhead">Refresh overhead</h3>

<p>The fraction of time the memory spends on refresh, the refresh overhead, can be calculated from the system timing:<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>

<p>

<math display="block" id="Memory_refresh:1">
 <semantics>
  <mrow>
   <mtext>refresh overhead</mtext>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mfrac>
     <mtext>time required for refresh, ms</mtext>
     <mtext>refresh interval, ms</mtext>
    </mfrac>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <mtext>refresh overhead</mtext>
    <apply>
     <divide></divide>
     <mtext>time required for refresh, ms</mtext>
     <mtext>refresh interval, ms</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{refresh overhead}=\frac{\text{time required for refresh, ms}}{\text{%
refresh interval, ms}}\,
  </annotation>
 </semantics>
</math>

 For example, a recent <a class="uri" href="SDRAM" title="wikilink">SDRAM</a> chip has 2<sup>13</sup> = 8 192 rows, a refresh time of 64 ms, the memory bus runs at 133 MHz, and the refresh cycle takes 4 clock cycles.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> The time for a refresh cycle is<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></p>

<p>

<math display="block" id="Memory_refresh:2">
 <semantics>
  <mrow>
   <mtext>length of refresh cycle</mtext>
   <mo>=</mo>
   <mrow>
    <mn>4</mn>
    <mo>/</mo>
    <mi>f</mi>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>4</mn>
    <mrow>
     <mn>1.33</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mn>10</mn>
       <mn>8</mn>
      </msup>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mtext>Hz</mtext>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mn>30</mn>
    </mpadded>
    <mpadded width="+1.7pt">
     <mtext>ns</mtext>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <mtext>length of refresh cycle</mtext>
     <apply>
      <divide></divide>
      <cn type="integer">4</cn>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">4</cn>
      <apply>
       <times></times>
       <cn type="float">1.33</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">10</cn>
        <cn type="integer">8</cn>
       </apply>
       <mtext>Hz</mtext>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="integer">30</cn>
      <mtext>ns</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{length of refresh cycle}=4/f=\frac{4}{1.33(10^{8})\,\text{Hz}}=30\,\text%
{ns}\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Memory_refresh:3">
 <semantics>
  <mrow>
   <mtext>time required for refresh</mtext>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mtext>length of refresh cycle</mtext>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mtext>rows</mtext>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mn>30</mn>
      </mpadded>
      <mtext>ns</mtext>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>8192</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mn>0.246</mn>
    </mpadded>
    <mpadded width="+1.7pt">
     <mtext>ms</mtext>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <mtext>time required for refresh</mtext>
     <apply>
      <times></times>
      <mtext>length of refresh cycle</mtext>
      <mtext>rows</mtext>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <cn type="integer">30</cn>
       <mtext>ns</mtext>
      </apply>
      <cn type="integer">8192</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="float">0.246</cn>
      <mtext>ms</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{time required for refresh}=(\text{length of refresh cycle})(\text{rows})%
=(30\,\text{ns})(8192)=0.246\,\text{ms}\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Memory_refresh:4">
 <semantics>
  <mrow>
   <mtext>refresh overhead</mtext>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mpadded width="+1.7pt">
      <mn>0.246</mn>
     </mpadded>
     <mtext>ms</mtext>
    </mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <mn>64</mn>
     </mpadded>
     <mtext>ms</mtext>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>.0038</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <mtext>refresh overhead</mtext>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <cn type="float">0.246</cn>
       <mtext>ms</mtext>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">64</cn>
       <mtext>ms</mtext>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">.0038</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{refresh overhead}=\frac{0.246\,\text{ms}}{64\,\text{ms}}=.0038\,
  </annotation>
 </semantics>
</math>

 So less than 0.4% of the memory chip's time will be taken by refresh cycles. In SDRAM chips, the memory in each chip is divided into banks which are refreshed in parallel, saving further time. So the number of refresh cycles needed is the number of rows in a single bank, given in the specifications, which in recent (2012) generations of chips has been frozen at 8 192.</p>
<h2 id="refresh-interval">Refresh interval</h2>

<p>The maximum time interval between refreshes is standardized by <a class="uri" href="JEDEC" title="wikilink">JEDEC</a> for each DRAM technology, and is specified in the manufacturer's chip specifications. It is usually in the range of milliseconds. For current (2012) DDR2 SDRAM chips it is 64 ms.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> It depends on the ratio of charge stored in the memory cell capacitors to leakage currents. Despite the fact that the geometry of the capacitors has been shrinking with each new generation of memory chips, refresh times for DRAM have been improving; from 8 ms for 1M chips, 32 ms for 16M chips, to 64 ms for 256M chips. This improvement is achieved partly by developing transistors that leak significantly less. Longer refresh time means a smaller fraction of the device's time is occupied with refresh, leaving more time for memory accesses. Although refresh overhead occupied up to 10% of chip time in earlier DRAMs, in modern chips this fraction is less than 1%. Because the leakage currents in semiconductors increase with temperature, refresh times must be decreased at high temperature. The current generation of DDR2 SDRAM chips has a temperature-compensated refresh structure; refresh cycle time must be halved when chip case temperature exceeds 85°C (185°F).<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>

<p>The actual persistence of readable charge values and thus data in most DRAM memory cells is much longer than the refresh time, up to 1–10 seconds.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> However transistor leakage currents vary widely between different memory cells on the same chip. In order to make sure that all the memory cells are refreshed before a single bit is lost, manufacturers must set their refresh times conservatively short.</p>

<p>This frequent DRAM refresh consumes a third of the total power drawn by <a href="low-power_electronics" title="wikilink">low-power electronics</a> devices in standby mode. Researchers have proposed several approaches to extending battery run-time between charges by reducing the refresh rate, including temperature-compensated refresh (TCR) and retention-aware placement in DRAM (RAPID). Experiments show that in a typical off-the-shelf DRAM chip, only a few weak cells really require the worst-case 64 ms refresh interval, and even then only at the high end of its specified temperature range. At room temperature (24°C), those same weak cells need to be refreshed once every 500 ms for correct operation. If the system can avoid using the weakest 1% of pages, a typical DRAM only needs to be refreshed once a second, even at 70°C, for correct operation of the remaining 99% of the pages. Some experiments combine these two complementary techniques, giving correct operation at room temperature at refresh intervals of 10 seconds.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>
<h2 id="comparison-of-static-and-dynamic-ram">Comparison of static and dynamic RAM</h2>
<h3 id="sram">SRAM</h3>

<p>In <a href="static_random_access_memory" title="wikilink">static random access memory</a> (SRAM), the other type of semiconductor memory, the data is not stored as charge on a capacitor but in a pair of <a href="transistor" title="wikilink">transistors</a> called a <a href="Flip-flop_(electronics)" title="wikilink">flip-flop</a>, so SRAM does not require refreshing. The two basic types of memory have advantages and disadvantages. Static memory can be considered permanent while powered on, i.e. once written the memory stays until specifically changed and thus its use tends to be simple in terms of system design. However the internal construction of each static memory cell requires six transistors, compared to the single transistor required for a dynamic RAM cell, so the density of SRAM is much lower and price-per-bit much higher than DRAM. The complexity of the static memory cell is also relatively slow to operate thus static memory tends to have lower bandwidths than equivalent dynamic storage. Writing the capacitor of the dynamic cell is very rapid and write-access times on modern dynamic storage can be in single digit nano-seconds.</p>
<h3 id="dram">DRAM</h3>

<p>Modern DRAM modules provide the refresh circuitry on board with no requirement for motherboard circuitry, almost to the point where, at a module level, they may be thought of as static - requiring the CPU to do nothing to preserve their content.</p>
<h4 id="cpu-based-refresh">CPU based refresh</h4>

<p>Some early <a href="microprocessor" title="wikilink">microprocessors</a> (e.g. the <a href="Zilog_Z80" title="wikilink">Zilog Z80</a>) provided special internal registers that could provide the Row-Address Strobe (RAS) to refresh dynamic memory cells, the register being incremented on each refresh cycle. This could also be accomplished by other <a href="integrated_circuit" title="wikilink">integrated circuits</a> already being used in the system, if these already generated cycling accesses across RAM (<em>e.g.</em> the <a href="Motorola_6845" title="wikilink">Motorola 6845</a>). In CPUs such as the Z80, the availability of a RAS refresh was a big selling-point due to its simplifying hardware design. Here, RAS refresh is signalled by a unique combination of address and control wires during operationally redundant clock cycles (T-States), i.e. during instruction decode/execution when the buses may not be required. Instead of the bus being inactive during such T-states, the refresh register would be presented on the address bus along with a combination of control wires to indicate to the refresh circuitry.</p>

<p>In early versions of the Z80, the ubiquity of 16 kB RAM chips (<em>i.e.</em> having 128 rows) and something of a lack of foresight resulted in the R register only incrementing over a 7 bit-wide range (0–127, <em>i.e.</em> 128 rows); the 8th bit could be set by the user, but would be left unchanged by the internal cycling. With the rapid advent of 64 kbit+ DRAM chips (with an 8 bit RAS), extra circuitry or logic had to be built around the refresh signal to synthesize the missing 8th bit and prevent blocks of memory being lost after a few milliseconds. In some contexts, it was possible to utilise <a href="interrupt" title="wikilink">interrupts</a> to flip the 8th bit at the appropriate time and thus cover the entire range of the R register (256 rows). Another method, perhaps more universal but also more complex in terms of hardware, was to use an 8-bit counter chip, whose output would provide the refresh RAS address instead of the R register: the refresh signal from the CPU was used as the clock for this counter, resulting in the memory row to be refreshed being incremented with each refresh cycle. Later versions and licensed "work-alikes" of the Z80 core remedied the non-inclusion of the 8th bit in automatic cycling, and modern CPUs have greatly expanded on such basic provisioning to provide rich all-in-one solutions for DRAM refresh.</p>
<h2 id="other-memory-technologies-using-refresh">Other memory technologies using refresh</h2>

<p>Several early computer memory technologies also required periodical processes similar in purpose. These technologies include <a href="delay_line_memory" title="wikilink">delay line memory</a> and <a href="Williams_tube" title="wikilink">Williams tube</a>. In <a href="magnetic_core_memory" title="wikilink">magnetic core memory</a>, another historical early memory technology, reading the data erased the memory cell, so each memory cell needed to be rewritten after being read.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Memory_scrubbing" title="wikilink">Memory scrubbing</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Computer_memory" title="wikilink">Category:Computer memory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">"refresh cycle" in <a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"> on <a href="http://smithsonianchips.si.edu/">The Chip Collection, Smithsonian website</a><a href="#fnref11">↩</a></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19">, p.20, on <a href="http://www.ecs.baylor.edu/">School of Engineering and Computer Science, Baylor Univ. website</a><a href="#fnref19">↩</a></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"></li>
<li id="fn25"></li>
<li id="fn26">, p.20, on <a href="http://www.ecs.baylor.edu/">School of Engineering and Computer Science, Baylor Univ. website</a><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="http://cs.ecs.baylor.edu/~maurer/CSI5338/JESD79-2B.pdf">JEDEC DDR2 SDRAM Specification, p.49</a><a href="#fnref27">↩</a></li>
<li id="fn28">[<a class="uri" href="http://books.google.com/books?id=SrP3aWed-esC&amp;pg">http://books.google.com/books?id=SrP3aWed-esC&amp;pg;</a>;=PA356&amp;lpg;=PA356&amp;dq;=DRAM+%22refresh+time%22+millisecond&amp;source;=bl&amp;ots;=4PY6yJIIyE&amp;sig;=VowDJ3iFrdWkDa1iDfeHJh_5Q0k&amp;hl;=en&amp;sa;=X&amp;ei;=Yuk5UK2sF-aIiAKFpICQDg&amp;ved;=0CDQQ6AEwAA#v=onepage&amp;q;=refresh&amp;f;=false Jacob, 2007, p.356]<a href="#fnref28">↩</a></li>
<li id="fn29">Ravi K. Venkatesan, Stephen Herr, Eric Rotenberg. <a href="http://people.engr.ncsu.edu/ericro/publications/conference_HPCA-12.pdf">"Retention-Aware Placement in DRAM (RAPID): Software Methods for Quasi-Non-Volatile DRAM"</a>. 2006.<a href="#fnref29">↩</a></li>
</ol>
</section>
</body>
</html>
