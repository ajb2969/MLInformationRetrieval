<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1397">Shor's algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Shor's algorithm</h1>
<hr/>

<p><strong>Shor's algorithm</strong>, named after mathematician <a href="Peter_Shor" title="wikilink">Peter Shor</a>, is a <a href="quantum_algorithm" title="wikilink">quantum algorithm</a> (an <a class="uri" href="algorithm" title="wikilink">algorithm</a> that runs on a <a href="quantum_computer" title="wikilink">quantum computer</a>) for <a href="integer_factorization" title="wikilink">integer factorization</a> formulated in 1994. Informally it solves the following problem: given an integer <em>N</em>, find its <a href="prime_factor" title="wikilink">prime factors</a>.</p>

<p>On a quantum computer, to factor an integer <em>N</em>, Shor's algorithm runs in <a href="polynomial_time" title="wikilink">polynomial time</a> (the time taken is polynomial in log <em>N</em>, which is the size of the input).<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Specifically it takes time and quantum gates of order <mtpl></mtpl>) using fast multiplication,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> demonstrating that the integer factorization problem can be efficiently solved on a quantum computer and is thus in the <a href="complexity_class" title="wikilink">complexity class</a> <strong><a class="uri" href="BQP" title="wikilink">BQP</a></strong>. This is substantially faster than the most efficient known classical factoring algorithm, the <a href="general_number_field_sieve" title="wikilink">general number field sieve</a>, which works in <a href="sub-exponential_time" title="wikilink">sub-exponential time</a> — about <mtpl></mtpl>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The efficiency of Shor's algorithm is due to the efficiency of the <a href="quantum_Fourier_transform" title="wikilink">quantum Fourier transform</a>, and <a href="modular_exponentiation" title="wikilink">modular exponentiation</a> by <a href="exponentiation_by_squaring" title="wikilink">repeated squarings</a>.</p>

<p>If a quantum computer with a sufficient number of <a class="uri" href="qubits" title="wikilink">qubits</a> could operate without succumbing to <a class="uri" href="noise" title="wikilink">noise</a> and other quantum decoherence phenomena, Shor's algorithm could be used to break <a href="public-key_cryptography" title="wikilink">public-key cryptography</a> schemes such as the widely used <a href="RSA_(algorithm)" title="wikilink">RSA</a> scheme. RSA is based on the assumption that factoring large numbers is computationally intractable. So far as is known, this assumption is valid for classical (non-quantum) computers; no classical algorithm is known that can factor in polynomial time. However, Shor's algorithm shows that factoring is efficient on an ideal quantum computer, so it may be feasible to defeat RSA by constructing a large quantum computer. It was also a powerful motivator for the design and construction of quantum computers and for the study of new quantum computer algorithms. It has also facilitated research on new cryptosystems that are secure from quantum computers, collectively called <a href="post-quantum_cryptography" title="wikilink">post-quantum cryptography</a>.</p>

<p>In 2001, Shor's algorithm was demonstrated by a group at IBM, who factored 15 into 3 × 5, using an <a href="Nuclear_magnetic_resonance_(NMR)_quantum_computing" title="wikilink">NMR implementation</a> of a quantum computer with 7 <a class="uri" href="qubits" title="wikilink">qubits</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> After IBM's implementation, two independent groups, one at the <a href="University_of_Science_and_Technology_of_China" title="wikilink">University of Science and Technology of China</a>, and the other one at the University of Queensland, have implemented Shor's algorithm using photonic qubits, emphasizing that multi-qubit entanglement was observed when running the Shor's algorithm circuits.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> In 2012, the factorization of 15 was repeated.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Also in 2012, the factorization of 21 was achieved, setting the record for the largest number factored with a quantum computer.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> In April 2012, the factorization of 143 was achieved, although this used <a href="adiabatic_quantum_computation" title="wikilink">adiabatic quantum computation</a> rather than Shor's algorithm.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> It was discovered in November 2014 that this adiabatic quantum computation in 2012 had in fact also factored larger numbers, the largest being 56153, which is currently the record for the largest integer factored on a quantum device.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h2 id="procedure">Procedure</h2>

<p>The problem we are trying to solve is: given an odd <a href="composite_number" title="wikilink">composite number</a> 

<math display="inline" id="Shor's_algorithm:0">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

, find an integer 

<math display="inline" id="Shor's_algorithm:1">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

, strictly between 

<math display="inline" id="Shor's_algorithm:2">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Shor's_algorithm:3">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

, that divides 

<math display="inline" id="Shor's_algorithm:4">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

. We are interested in odd values of 

<math display="inline" id="Shor's_algorithm:5">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 because any even value of 

<math display="inline" id="Shor's_algorithm:6">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 trivially has the number 

<math display="inline" id="Shor's_algorithm:7">
 <semantics>
  <mn>2</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">2</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2
  </annotation>
 </semantics>
</math>

 as a prime factor. We can use a <a href="primality_testing" title="wikilink">primality testing</a> algorithm to make sure that 

<math display="inline" id="Shor's_algorithm:8">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 is indeed composite.</p>

<p>Moreover, for the algorithm to work, we need 

<math display="inline" id="Shor's_algorithm:9">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 not to be the power of a prime. This can be tested by taking square, cubic, ..., 

<math display="inline" id="Shor's_algorithm:10">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-roots of 

<math display="inline" id="Shor's_algorithm:11">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

, for 

<math display="inline" id="Shor's_algorithm:12">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>≤</mo>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>k</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\leq\log_{2}(N)
  </annotation>
 </semantics>
</math>

, and checking that none of these is an integer. (This actually excludes that 

<math display="inline" id="Shor's_algorithm:13">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <msup>
    <mi>M</mi>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>M</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=M^{k}
  </annotation>
 </semantics>
</math>

 for some integer 

<math display="inline" id="Shor's_algorithm:14">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Shor's_algorithm:15">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>></mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>k</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k>1
  </annotation>
 </semantics>
</math>

.)</p>

<p>Since 

<math display="inline" id="Shor's_algorithm:16">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 is not a power of a prime, it is the product of two <a class="uri" href="coprime" title="wikilink">coprime</a> numbers greater than 

<math display="inline" id="Shor's_algorithm:17">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

. As a consequence of the <a href="Chinese_remainder_theorem" title="wikilink">Chinese remainder theorem</a>, the number 

<math display="inline" id="Shor's_algorithm:18">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 has at least four distinct square roots <a href="modular_arithmetic" title="wikilink">modulo</a> 

<math display="inline" id="Shor's_algorithm:19">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

, two of them being 

<math display="inline" id="Shor's_algorithm:20">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Shor's_algorithm:21">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -1
  </annotation>
 </semantics>
</math>

. The aim of the algorithm is to find a square root 

<math display="inline" id="Shor's_algorithm:22">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 of one, other than 

<math display="inline" id="Shor's_algorithm:23">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Shor's_algorithm:24">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -1
  </annotation>
 </semantics>
</math>

; such a 

<math display="inline" id="Shor's_algorithm:25">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 will lead to a factorization of 

<math display="inline" id="Shor's_algorithm:26">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

, as in other <a href="integer_factorization" title="wikilink">factoring algorithms</a> like the <a href="quadratic_sieve" title="wikilink">quadratic sieve</a>.</p>

<p>In turn, finding such a 

<math display="inline" id="Shor's_algorithm:27">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 is reduced to finding an element 

<math display="inline" id="Shor's_algorithm:28">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 of even period with a certain additional property (as explained below, it is required that the condition of Step 6 of the classical part does not hold). The quantum algorithm is used for finding the period of randomly chosen elements 

<math display="inline" id="Shor's_algorithm:29">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

, as order-finding is a hard problem on a classical computer.</p>

<p>Shor's algorithm consists of two parts:</p>
<ol>
<li>A reduction, which can be done on a classical computer, of the factoring problem to the problem of <a href="Order_(group_theory)" title="wikilink">order</a>-finding.</li>
<li>A quantum algorithm to solve the order-finding problem.</li>
</ol>
<h3 id="classical-part">Classical part</h3>

<p>For example

<math display="block" id="Shor's_algorithm:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>N</mi>
    <mo>=</mo>
    <mn>15</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mo>=</mo>
     <mn>7</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>r</mi>
     <mo>=</mo>
     <mn>4</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>N</ci>
     <cn type="integer">15</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <ci>a</ci>
      <cn type="integer">7</cn>
     </apply>
     <apply>
      <eq></eq>
      <ci>r</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=15,a=7,r=4
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Shor's_algorithm:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mi>c</mi>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mn>7</mn>
       <mn>2</mn>
      </msup>
      <mo>±</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mn>15</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mi>c</mi>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>49</mn>
      <mo>±</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mn>15</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>c</ci>
     <ci>d</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="latexml">plus-or-minus</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">7</cn>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">15</cn>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>c</ci>
     <ci>d</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="latexml">plus-or-minus</csymbol>
       <cn type="integer">49</cn>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">15</cn>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   gcd(7^{2}\pm 1,15)=gcd(49\pm 1,15)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Shor's_algorithm:32">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mi>c</mi>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>48</mn>
     <mo>,</mo>
     <mn>15</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>c</ci>
     <ci>d</ci>
     <interval closure="open">
      <cn type="integer">48</cn>
      <cn type="integer">15</cn>
     </interval>
    </apply>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   gcd(48,15)=3
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Shor's_algorithm:33">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mi>c</mi>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>50</mn>
     <mo>,</mo>
     <mn>15</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>c</ci>
     <ci>d</ci>
     <interval closure="open">
      <cn type="integer">50</cn>
      <cn type="integer">15</cn>
     </interval>
    </apply>
    <cn type="integer">5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   gcd(50,15)=5
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="quantum-part-period-finding-subroutine">Quantum part: Period-finding subroutine</h3>

<p> The quantum circuits used for this algorithm are custom designed for each choice of <em>N</em> and each choice of the random <em>a</em> used in <em>f</em>(<em>x</em>) = <em>a</em><sup><em>x</em></sup> <a href="Modulo_operation" title="wikilink">mod</a> <em>N</em>. Given <em>N</em>, find <em>Q</em> = 2<sup><em>q</em></sup> such that 

<math display="inline" id="Shor's_algorithm:34">
 <semantics>
  <mrow>
   <msup>
    <mi>N</mi>
    <mn>2</mn>
   </msup>
   <mo>≤</mo>
   <mi>Q</mi>
   <mo><</mo>
   <mrow>
    <mn>2</mn>
    <msup>
     <mi>N</mi>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>N</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>Q</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>N</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N^{2}\leq Q<2N^{2}
  </annotation>
 </semantics>
</math>

, which implies 

<math display="inline" id="Shor's_algorithm:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mo>/</mo>
    <mi>r</mi>
   </mrow>
   <mo>></mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <divide></divide>
     <ci>Q</ci>
     <ci>r</ci>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q/r>N
  </annotation>
 </semantics>
</math>

. The input and output <a class="uri" href="qubit" title="wikilink">qubit</a> registers need to hold superpositions of values from 0 to <em>Q</em> − 1, and so have <em>q</em> qubits each. Using what might appear to be twice as many qubits as necessary guarantees that there are at least <em>N</em> different <em>x</em> which produce the same <em>f</em>(<em>x</em>), even as the period <em>r</em> approaches <em>N</em>/2.</p>

<p>Proceed as follows:</p>
<h2 id="explanation-of-the-algorithm">Explanation of the algorithm</h2>

<p>The algorithm is composed of two parts. The first part of the algorithm turns the factoring problem into the problem of finding the period of a function, and may be implemented classically. The second part finds the period using the quantum Fourier transform, and is responsible for the quantum speedup.</p>
<h3 id="obtaining-factors-from-period">Obtaining factors from period</h3>

<p>The integers less than <em>N</em> and <a class="uri" href="coprime" title="wikilink">coprime</a> with <em>N</em> form a finite Abelian <a href="group_(mathematics)" title="wikilink">group</a> 

<math display="inline" id="Shor's_algorithm:36">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 under multiplication <a href="modular_arithmetic" title="wikilink">modulo</a> <em>N</em>. The size is given by <a href="Euler's_totient_function" title="wikilink">Euler's totient function</a> 

<math display="inline" id="Shor's_algorithm:37">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(N)
  </annotation>
 </semantics>
</math>

. By the end of step 3, we have an integer <em>a</em> in this group. Since the group is finite, <em>a</em> must have a finite order <em>r</em>, the smallest positive integer such that</p>

<p>

<math display="block" id="Shor's_algorithm:38">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>a</mi>
     <mi>r</mi>
    </msup>
    <mo>≡</mo>
    <mrow>
     <mpadded width="+5pt">
      <mn>1</mn>
     </mpadded>
     <mpadded width="+5pt">
      <mtext>mod</mtext>
     </mpadded>
     <mi>N</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <ci>r</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <mtext>mod</mtext>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{r}\equiv 1\ \mbox{mod}\ N.\,
  </annotation>
 </semantics>
</math>

 Therefore, <em>N</em> <a class="uri" href="divides" title="wikilink">divides</a> (also written | ) <em>a</em> <sup><em>r</em></sup> − 1 . Suppose we are able to obtain <em>r</em>, and it is even. (If <em>r</em> is odd, see step 5.) Now 

<math display="inline" id="Shor's_algorithm:39">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>≡</mo>
   <mrow>
    <msup>
     <mi>a</mi>
     <mrow>
      <mi>r</mi>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msup>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>b</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <apply>
       <divide></divide>
       <ci>r</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\equiv a^{r/2}\;\;(\mathop{{\rm mod}}N)
  </annotation>
 </semantics>
</math>

 is a square root of 1 modulo 

<math display="inline" id="Shor's_algorithm:40">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

, different from 1. This is because 

<math display="inline" id="Shor's_algorithm:41">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 is the order of 

<math display="inline" id="Shor's_algorithm:42">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 modulo 

<math display="inline" id="Shor's_algorithm:43">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

, so 

<math display="inline" id="Shor's_algorithm:44">
 <semantics>
  <mrow>
   <msup>
    <mi>a</mi>
    <mrow>
     <mi>r</mi>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </msup>
   <mo>≢</mo>
   <mrow>
    <mn>1</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">not-equivalent-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <apply>
      <divide></divide>
      <ci>r</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <ci>pmod</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{r/2}\not\equiv 1\;\;(\mathop{{\rm mod}}N)
  </annotation>
 </semantics>
</math>

, else the order of 

<math display="inline" id="Shor's_algorithm:45">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 in this group would be 

<math display="inline" id="Shor's_algorithm:46">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>r</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r/2
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Shor's_algorithm:47">
 <semantics>
  <mrow>
   <msup>
    <mi>a</mi>
    <mrow>
     <mi>r</mi>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <apply>
      <divide></divide>
      <ci>r</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{r/2}\equiv-1\;\;(\mathop{{\rm mod}}N)
  </annotation>
 </semantics>
</math>

, by step 6 we have to restart the algorithm with a different random number 

<math display="inline" id="Shor's_algorithm:48">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

.</p>

<p>Eventually, we must hit an 

<math display="inline" id="Shor's_algorithm:49">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

, of order 

<math display="inline" id="Shor's_algorithm:50">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Shor's_algorithm:51">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, such that 

<math display="inline" id="Shor's_algorithm:52">
 <semantics>
  <mrow>
   <mrow>
    <mi>b</mi>
    <mo>≡</mo>
    <msup>
     <mi>a</mi>
     <mrow>
      <mi>r</mi>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msup>
    <mo>≢</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <equivalent></equivalent>
      <ci>b</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <apply>
        <divide></divide>
        <ci>r</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">not-equivalent-to</csymbol>
      <share href="#.cmml">
      </share>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\equiv a^{r/2}\not\equiv 1,-1\;\;(\mathop{{\rm mod}}N)
  </annotation>
 </semantics>
</math>

. This is because such a 

<math display="inline" id="Shor's_algorithm:53">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 is a square root of 1 modulo 

<math display="inline" id="Shor's_algorithm:54">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

, other than 1 and 

<math display="inline" id="Shor's_algorithm:55">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -1
  </annotation>
 </semantics>
</math>

, whose existence is guaranteed by the Chinese remainder theorem, since 

<math display="inline" id="Shor's_algorithm:56">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 is not a prime power.</p>

<p>We claim that 

<math display="inline" id="Shor's_algorithm:57">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>=</mo>
   <mrow>
    <mo>gcd</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>b</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>d</ci>
    <apply>
     <ci>gcd</ci>
     <apply>
      <minus></minus>
      <ci>b</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=\operatorname{gcd}(b-1,N)
  </annotation>
 </semantics>
</math>

 is a proper factor of 

<math display="inline" id="Shor's_algorithm:58">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

, that is, 

<math display="inline" id="Shor's_algorithm:59">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>≠</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>d</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>N</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\neq 1,N
  </annotation>
 </semantics>
</math>

. In fact if 

<math display="inline" id="Shor's_algorithm:60">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>=</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>d</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=N
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Shor's_algorithm:61">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 divides 

<math display="inline" id="Shor's_algorithm:62">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>b</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b-1
  </annotation>
 </semantics>
</math>

, so that 

<math display="inline" id="Shor's_algorithm:63">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>≡</mo>
   <mrow>
    <mn>1</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>b</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <ci>pmod</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\equiv 1\;\;(\mathop{{\rm mod}}N)
  </annotation>
 </semantics>
</math>

, against the construction of 

<math display="inline" id="Shor's_algorithm:64">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

. If on the other hand 

<math display="inline" id="Shor's_algorithm:65">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>=</mo>
   <mrow>
    <mo>gcd</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>b</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo>,</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>d</ci>
     <apply>
      <ci>gcd</ci>
      <apply>
       <minus></minus>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=\operatorname{gcd}(b-1,N)=1
  </annotation>
 </semantics>
</math>

, then by <a href="Bézout's_identity" title="wikilink">Bézout's identity</a> there are integers 

<math display="inline" id="Shor's_algorithm:66">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>,</mo>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>u</ci>
    <ci>v</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u,v
  </annotation>
 </semantics>
</math>

 such that</p>

<p>

<math display="block" id="Shor's_algorithm:67">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>b</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>u</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>N</mi>
     <mi>v</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>u</ci>
     </apply>
     <apply>
      <times></times>
      <ci>N</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (b-1)u+Nv=1
  </annotation>
 </semantics>
</math>

. Multiplying both sides by 

<math display="inline" id="Shor's_algorithm:68">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>b</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b+1
  </annotation>
 </semantics>
</math>

 we obtain</p>

<p>

<math display="block" id="Shor's_algorithm:69">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>b</mi>
        <mn>2</mn>
       </msup>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>u</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>N</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>b</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>v</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>b</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>b</ci>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <ci>u</ci>
     </apply>
     <apply>
      <times></times>
      <ci>N</ci>
      <apply>
       <plus></plus>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <ci>b</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (b^{2}-1)u+N(b+1)v=b+1
  </annotation>
 </semantics>
</math>

. Since 

<math display="inline" id="Shor's_algorithm:70">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 divides 

<math display="inline" id="Shor's_algorithm:71">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>b</mi>
     <mn>2</mn>
    </msup>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>a</mi>
      <mi>r</mi>
     </msup>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>r</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b^{2}-1\equiv a^{r}-1\;\;(\mathop{{\rm mod}}N)
  </annotation>
 </semantics>
</math>

, we obtain that 

<math display="inline" id="Shor's_algorithm:72">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 divides 

<math display="inline" id="Shor's_algorithm:73">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>b</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b+1
  </annotation>
 </semantics>
</math>

, so that 

<math display="inline" id="Shor's_algorithm:74">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>b</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\equiv-1\;\;(\mathop{{\rm mod}}N)
  </annotation>
 </semantics>
</math>

, again contradicting the construction of 

<math display="inline" id="Shor's_algorithm:75">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

.</p>

<p>Thus 

<math display="inline" id="Shor's_algorithm:76">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 is the required proper factor of 

<math display="inline" id="Shor's_algorithm:77">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="finding-the-period">Finding the period</h3>

<p>Shor's period-finding algorithm relies heavily on the ability of a <a href="quantum_computer" title="wikilink">quantum computer</a> to be in many states simultaneously. Physicists call this behavior a "<a href="Quantum_superposition" title="wikilink">superposition</a>" of states. To compute the period of a function <em>f</em>, we evaluate the function at all points simultaneously.</p>

<p>Quantum physics does not allow us to access all this information directly, though. A <a href="measurement_in_quantum_mechanics" title="wikilink">measurement</a> will yield only one of all possible values, destroying all others. If not for the <a href="no_cloning_theorem" title="wikilink">no cloning theorem</a>, we could first measure <em>f</em>(<em>x</em>) without measuring <em>x</em>, and then make a few copies of the resulting state (which is a superposition of states all having the same <em>f</em>(<em>x</em>)). Measuring <em>x</em> on these states would provide different <em>x</em> values which give the same <em>f</em>(<em>x</em>), leading to the period. Because we cannot <a href="Quantum_cloning" title="wikilink">make exact copies of a quantum state</a>, this method does not work. Therefore we have to carefully transform the superposition to another state that will return the correct answer with high probability. This is achieved by the <a href="quantum_Fourier_transform" title="wikilink">quantum Fourier transform</a>.</p>

<p>Shor thus had to solve three "implementation" problems. All of them had to be implemented "fast", which means that they can be implemented with a number of <a href="quantum_gate" title="wikilink">quantum gates</a> that is <a href="polynomial#Complexity" title="wikilink">polynomial</a> in 

<math display="inline" id="Shor's_algorithm:78">
 <semantics>
  <mrow>
   <mi>log</mi>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log N
  </annotation>
 </semantics>
</math>

.</p>
<ol>
<li>Create a superposition of states. This can be done by applying <a href="Hadamard_transform" title="wikilink">Hadamard</a> gates to all qubits in the input register. Another approach would be to use the quantum Fourier transform (see below).</li>
<li>Implement the function <em>f</em> as a quantum transform. To achieve this, Shor used <a href="Exponentiating_by_squaring" title="wikilink">repeated squaring</a> for his modular exponentiation transformation. It is important to note that this step is more difficult to implement than the quantum Fourier transform, in that it requires ancillary qubits and substantially more gates to accomplish.</li>
<li>Perform a quantum Fourier transform. By using controlled rotation gates and Hadamard gates, Shor designed a circuit for the quantum Fourier transform (with <em>Q</em> = 2<sup><em>q</em></sup>) that uses just 

<math display="inline" id="Shor's_algorithm:79">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>q</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>log</mi>
        <mi>Q</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>q</ci>
      <apply>
       <minus></minus>
       <ci>q</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <log></log>
       <ci>Q</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q(q-1)/2=O((\log Q)^{2})
  </annotation>
 </semantics>
</math>

 gates.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></li>
</ol>

<p>After all these transformations a measurement will yield an approximation to the period <em>r</em>. For simplicity assume that there is a <em>y</em> such that <em>yr/Q</em> is an integer. Then the probability to measure <em>y</em> is 1. To see that we notice that then</p>

<p>

<math display="block" id="Shor's_algorithm:80">
 <semantics>
  <mrow>
   <msup>
    <mi>e</mi>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
       <mi>i</mi>
       <mi>b</mi>
       <mi>y</mi>
       <mi>r</mi>
      </mrow>
      <mo>/</mo>
      <mi>Q</mi>
     </mrow>
    </mrow>
   </msup>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>1</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
        <ci>i</ci>
        <ci>b</ci>
        <ci>y</ci>
        <ci>r</ci>
       </apply>
       <ci>Q</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e^{-2\pi ibyr/Q}=1\,
  </annotation>
 </semantics>
</math>

 for all integers <em>b</em>. Therefore the sum whose square gives us the probability to measure <em>y</em> will be <em>Q/r</em> since <em>b</em> takes roughly <em>Q/r</em> values and thus the probability is 

<math display="inline" id="Shor's_algorithm:81">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <msup>
    <mi>r</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>r</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/r^{2}
  </annotation>
 </semantics>
</math>

. There are <em>r</em> <em>y</em> such that <em>yr/Q</em> is an integer and also <em>r</em> possibilities for 

<math display="inline" id="Shor's_algorithm:82">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{0})
  </annotation>
 </semantics>
</math>

, so the probabilities sum to 1.</p>

<p>Note: another way to explain Shor's algorithm is by noting that it is just the <a href="quantum_phase_estimation_algorithm" title="wikilink">quantum phase estimation algorithm</a> in disguise.</p>
<h3 id="the-bottleneck">The bottleneck</h3>

<p>The runtime bottleneck of Shor's algorithm is quantum <a href="modular_exponentiation" title="wikilink">modular exponentiation</a>, which is by far slower than the <a href="quantum_Fourier_transform" title="wikilink">quantum Fourier transform</a> and classical pre-/post-processing. There are several approaches to constructing and optimizing circuits for modular exponentiation. The simplest and (currently) most practical approach is to mimic conventional arithmetic circuits with <a href="reversible_computing" title="wikilink">reversible gates</a>, starting with ripple-carry adders. Knowing the base and the modulus of exponentiation facilitates further optimizations.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Reversible circuits typically use on the order of 

<math display="inline" id="Shor's_algorithm:83">
 <semantics>
  <msup>
   <mi>n</mi>
   <mn>3</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{3}
  </annotation>
 </semantics>
</math>

 gates for 

<math display="inline" id="Shor's_algorithm:84">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 qubits. Alternative techniques asymptotically improve gate counts by using <a href="quantum_Fourier_transform" title="wikilink">quantum Fourier transforms</a>, but are not competitive with less than 600 qubits due to high constants.</p>
<h2 id="discrete-logarithms">Discrete logarithms</h2>

<p>Given prime 

<math display="inline" id="Shor's_algorithm:85">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 with generator 

<math display="inline" id="Shor's_algorithm:86">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 where 

<math display="block" id="Shor's_algorithm:87">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>log</mi>
      <mi>g</mi>
     </msub>
     <mi>x</mi>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>r</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <ci>g</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=\log_{g}x\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

, for some <em>r</em>, and we wish to compute <em>r</em>, which is the <a href="discrete_logarithm" title="wikilink">discrete logarithm</a>

<math display="inline" id="Shor's_algorithm:88">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo>(</mo>
     <msub>
      <mi>ℤ</mi>
      <mi>p</mi>
     </msub>
     <mo>)</mo>
    </mrow>
    <mo>×</mo>
   </msup>
   <mo>×</mo>
   <msup>
    <mrow>
     <mo>(</mo>
     <msub>
      <mi>ℤ</mi>
      <mi>p</mi>
     </msub>
     <mo>)</mo>
    </mrow>
    <mo>×</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℤ</ci>
      <ci>p</ci>
     </apply>
     <times></times>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℤ</ci>
      <ci>p</ci>
     </apply>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\mathbb{Z}_{p}\right)^{\times}\times\left(\mathbb{Z}_{p}\right)^{\times}
  </annotation>
 </semantics>
</math>

. Consider the Abelian group 

<math display="block" id="Shor's_algorithm:89">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>g</mi>
       <mi>a</mi>
      </msup>
      <msup>
       <mi>x</mi>
       <mrow>
        <mo>-</mo>
        <mi>b</mi>
       </mrow>
      </msup>
     </mrow>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mi>p</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>a</ci>
      <ci>b</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>b</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(a,b)=g^{a}x^{-b}\;\;(\mathop{{\rm mod}}p).
  </annotation>
 </semantics>
</math>

 where each factor corresponds to modular multiplication of nonzero values, assuming p is prime. Now, consider the function</p>

<p><span class="LaTeX">$$f(a,b) = g^a x^{-b} \pmod{p}.$$</span></p>

<p>This gives us an Abelian <a href="hidden_subgroup_problem" title="wikilink">hidden subgroup problem</a>, as <em>f</em> corresponds to a <a href="group_homomorphism" title="wikilink">group homomorphism</a>. The kernel corresponds to modular multiples of (<em>r</em>,1). So, if we can find the kernel, we can find <em>r</em>.</p>
<h2 id="in-popular-culture">In popular culture</h2>

<p>On the television show <em><a href="Stargate_Universe" title="wikilink">Stargate Universe</a></em>, the lead scientist, Dr. <a href="Nicholas_Rush" title="wikilink">Nicholas Rush</a>, hoped to use Shor's algorithm to crack <em>Destiny</em>'s master code. He taught a <a href="quantum_cryptography" title="wikilink">quantum cryptography</a> class at the <a href="University_of_California,_Berkeley" title="wikilink">University of California, Berkeley</a>, in which Shor's algorithm was studied.</p>

<p>Shor's algorithm was also a correct answer to a question in a Physics Bowl competition in the episode "<a href="The_Bat_Jar_Conjecture" title="wikilink">The Bat Jar Conjecture</a>" of the TV series <em><a href="The_Big_Bang_Theory" title="wikilink">The Big Bang Theory</a></em>.</p>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>

<p>.</p></li>
<li>Phillip Kaye, Raymond Laflamme, Michele Mosca, <em>An introduction to quantum computing</em>, Oxford University Press, 2007, ISBN 0-19-857049-X</li>
<li><a href="http://scottaaronson.com/blog/?p=208">"Explanation for the man in the street"</a> by <a href="Scott_Aaronson" title="wikilink">Scott Aaronson</a>, "<a href="http://scottaaronson.com/blog/?p=208#comment-9958">approved</a>" by Peter Shor. (Shor wrote "Great article, Scott! That’s the best job of explaining quantum computing to the man on the street that I’ve seen."). An alternate metaphor for the QFT was presented in <a href="http://www.scottaaronson.com/blog/?p=208#comment-5187">one of the comments</a>. Scott Aaronson suggests the following 12 references as further reading (out of "the 10<sup>10<sup>5000</sup></sup> quantum algorithm tutorials that are already on the web."):</li>
<li>

<p>. Revised version of the original paper by Peter Shor ("28 pages, LaTeX. This is an expanded version of a paper that appeared in the Proceedings of the 35th Annual Symposium on Foundations of Computer Science, Santa Fe, NM, Nov. 20--22, 1994. Minor revisions made January, 1996").</p></li>
<li><a href="https://quantum-algorithms.herokuapp.com/299/paper/index.html">Quantum Computing and Shor's Algorithm</a>, Matthew Hayward's <a href="https://quantum-algorithms.herokuapp.com/">Quantum Algorithms Page</a>, 2005-02-17, imsa.edu, LaTeX2HTML version of the original <a href="https://quantum-algorithms.herokuapp.com/299/paper.tex">LaTeX document</a>, also available as <a href="https://quantum-algorithms.herokuapp.com/299/paper.pdf">PDF</a> or <a href="https://quantum-algorithms.herokuapp.com/299/paper.ps">postscript</a> document.</li>
<li><a href="http://homepages.cwi.nl/~rdewolf/publ/qc/survey.ps">Quantum Computation and Shor's Factoring Algorithm</a>, Ronald de Wolf, CWI and University of Amsterdam, January 12, 1999, 9 page postscript document.</li>
<li><a href="http://www.cs.berkeley.edu/~vazirani/f04quantum/notes/lec9.ps">Shor's Factoring Algorithm</a>, Notes from Lecture 9 of Berkeley CS 294-2, dated 4 Oct 2004, 7 page postscript document.</li>
<li><a href="http://www.theory.caltech.edu/people/preskill/ph229/notes/chap6.ps">Chapter 6 Quantum Computation</a>, 91 page postscript document, Caltech, Preskill, PH229.</li>
<li><a href="http://www-users.cs.york.ac.uk/~schmuel/comp/comp.html">Quantum computation: a tutorial</a> by <a href="http://www.cs.york.ac.uk/~schmuel/">Samuel L. Braunstein</a>.</li>
<li><a href="http://www.cs.ucr.edu/~neal/1996/cosc185-S96/shor/high-level.html">The Quantum States of Shor's Algorithm</a>, by Neal Young, Last modified: Tue May 21 11:47:38 1996.</li>
<li><a href="http://web.archive.org/web/20121115112940/http://people.ccmr.cornell.edu/~mermin/qcomp/chap3.pdf">III. Breaking RSA Encryption with a Quantum Computer: Shor's Factoring Algorithm</a>, Lecture notes on Quantum computation, Cornell University, Physics 481-681, CS 483; Spring, 2006 by N. David Mermin. Last revised 2006-03-28, 30 page PDF document.</li>
<li><a href="http://www.arxiv.org/abs/quant-ph/0303175">arXiv quant-ph/0303175 Shor's Algorithm for Factoring Large Integers. C. Lavor, L.R.U. Manssur, R. Portugal</a>. Submitted on 29 Mar 2003. This work is a tutorial on Shor's factoring algorithm by means of a worked out example. Some basic concepts of Quantum Mechanics and quantum circuits are reviewed. It is intended for non-specialists which have basic knowledge on undergraduate Linear Algebra. 25 pages, 14 figures, introductory review.</li>
<li><a href="http://www.arxiv.org/abs/quant-ph/0010034">arXiv quant-ph/0010034 Shor's Quantum Factoring Algorithm, Samuel J. Lomonaco, Jr</a>, Submitted October 9, 2000, This paper is a written version of a one hour lecture given on Peter Shor's quantum factoring algorithm. 22 pages.</li>
<li><a href="http://www.cs.princeton.edu/theory/complexity/quantumchap.pdf">Chapter 20 Quantum Computation</a>, from <em>Computational Complexity: A Modern Approach</em>, Draft of a book: Dated January 2007, Comments welcome!, Sanjeev Arora and Boaz Barak, Princeton University.</li>
<li><a href="http://blogs.discovermagazine.com/80beats/2011/01/19/a-step-towards-quantum-computing-entangling-10-billion-particles/">A Step Toward Quantum Computing: Entangling 10 Billion Particles</a>, from "Discover Magazine", Dated January 19, 2011.</li>
<li><a href="http://www.fi.muni.cz/usr/gruska/survey1.ps">Josef Gruska - <em>Quantum Computing Challenges</em></a> also in <a href="http://www.amazon.com/Mathematics-Unlimited-Bj%C3%B6rn-Engquist/dp/3540669132">Mathematics unlimited: 2001 and beyond</a>, Editors Björn Engquist, Wilfried Schmid, Springer, 2001, ISBN 978-3-540-66913-5</li>
</ul>

<p>"</p>

<p><a href="Category:Quantum_algorithms" title="wikilink">Category:Quantum algorithms</a> <a href="Category:Integer_factorization_algorithms" title="wikilink">Category:Integer factorization algorithms</a> <a href="Category:Quantum_information_science" title="wikilink">Category:Quantum information science</a> <a href="Category:Articles_containing_proofs" title="wikilink">Category:Articles containing proofs</a> <a href="Category:Post-quantum_cryptography" title="wikilink">Category:Post-quantum cryptography</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">See also <a href="Pseudo-polynomial_time" title="wikilink">Pseudo-polynomial time</a>.<a href="#fnref1">↩</a></li>
<li id="fn2"><a class="uri" href="http://arxiv.org/abs/quant-ph/9602016">http://arxiv.org/abs/quant-ph/9602016</a> - Efficient Networks for Quantum Factoring<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="http://mathworld.wolfram.com/NumberFieldSieve.html">MathWorld: Number Field Sieve</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a class="uri" href="http://arxiv.org/pdf/1202.5707v1.pdf">http://arxiv.org/pdf/1202.5707v1.pdf</a> - Computing prime factors with a Josephson phase qubit quantum processor<a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12">.<a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
</ol>
</section>
</body>
</html>
