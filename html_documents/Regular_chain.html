<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="985">Regular chain</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Regular chain</h1>
<hr/>

<p>In <a href="computer_algebra" title="wikilink">computer algebra</a>, a <strong>regular chain</strong> is a particular kind of triangular set in a multivariate polynomial ring over a field. It enhances the notion of <a href="Wu's_method_of_characteristic_set" title="wikilink">characteristic set</a>.</p>
<h2 id="introduction">Introduction</h2>

<p>Given a <a href="System_of_linear_equations" title="wikilink">linear system</a>, one can convert it to a <a href="Triangular_matrix" title="wikilink">triangular system</a> via <a href="Gaussian_elimination" title="wikilink">Gaussian elimination</a>. For the non-linear case, given a <a href="System_of_polynomial_equations" title="wikilink">polynomial system</a> F over a field, one can convert (decompose or triangularize) it to a finite set of triangular sets, in the sense that the <a href="algebraic_variety" title="wikilink">algebraic variety</a> <em>V</em>(F) is described by these triangular sets.</p>

<p>A triangular set may merely describe the empty set. To fix this degenerated case, the notion of regular chain was introduced, independently by Kalkbrener (1993), Yang and Zhang (1994). Regular chains also appear in Chou and Gao (1992). Regular chains are special triangular sets which are used in different algorithms for computing unmixed-dimensional decompositions of algebraic varieties. Without using factorization, these decompositions have better properties that the ones produced by <a href="Wu's_method" title="wikilink">Wu's algorithm</a>. Kalkbrener's original definition was based on the following observation: every irreducible variety is uniquely determined by one of its <a href="generic_point" title="wikilink">generic points</a> and varieties can be represented by describing the generic points of their irreducible components. These generic points are given by regular chains.</p>
<h2 id="examples">Examples</h2>

<p>Denote <strong>Q</strong> the rational number field. In <strong>Q</strong>[x<sub>1</sub>, x<sub>2</sub>, x<sub>3</sub>] with variable ordering x<sub>1</sub> 2 3,</p>

<p>

<math display="block" id="Regular_chain:0">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <msubsup>
      <mi>x</mi>
      <mn>2</mn>
      <mn>2</mn>
     </msubsup>
     <mo>-</mo>
     <msubsup>
      <mi>x</mi>
      <mn>1</mn>
      <mn>2</mn>
     </msubsup>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mn>3</mn>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <set>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=\{x_{2}^{2}-x_{1}^{2},x_{2}(x_{3}-x_{1})\}
  </annotation>
 </semantics>
</math>

 is a triangular set and also a regular chain. Two generic points given by <em>T</em> are (a, a, a) and (a, -a, a) where <em>a</em> is transcendental over <strong>Q</strong>. Thus there are two irreducible components, given by { x<sub>2</sub> - x<sub>1</sub>, x<sub>3</sub> - x<sub>1</sub> } and { x<sub>2</sub> + x<sub>1</sub>, x<sub>3</sub> - x<sub>1</sub> }, respectively. Note that: (1) the <a href="content_(algebra)" title="wikilink">content</a> of the second polynomial is x<sub>2</sub>, which does not contribute to the generic points represented and thus can be removed; (2) the <a class="uri" href="dimension" title="wikilink">dimension</a> of each component is 1, the number of free variables in the regular chain.</p>
<h2 id="formal-definitions">Formal definitions</h2>

<p>The variables in the polynomial ring</p>

<p>

<math display="block" id="Regular_chain:1">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <apply>
     <times></times>
     <ci>k</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=k[x_{1},\ldots,x_{n}]
  </annotation>
 </semantics>
</math>

 are always sorted as x<sub>1</sub> n. A non-constant polynomial <em>f</em> in 

<math display="inline" id="Regular_chain:2">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 can be seen as a univariate polynomial in its greatest variable. The greatest variable in <em>f</em> is called its main variable, denoted by <em>mvar</em>(f). Let <em>u</em> be the main variable of <em>f</em> and write it as</p>

<p>

<math display="block" id="Regular_chain:3">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>e</mi>
     </msub>
     <msup>
      <mi>u</mi>
      <mi>e</mi>
     </msup>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <msub>
     <mi>a</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>f</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>e</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>u</ci>
       <ci>e</ci>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f=a_{e}u^{e}+\cdots+a_{0}
  </annotation>
 </semantics>
</math>

, where <em>e</em> is the degree of <em>f</em> w.r.t. <em>u</em> and 

<math display="inline" id="Regular_chain:4">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>e</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{e}
  </annotation>
 </semantics>
</math>

 is the leading coefficient of <em>f</em> w.r.t. <em>u</em>. Then the initial of <em>f</em> is 

<math display="inline" id="Regular_chain:5">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>e</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{e}
  </annotation>
 </semantics>
</math>

 and <em>e</em> is its main degree.</p>
<ul>
<li>Triangular set</li>
</ul>

<p>A non-empty subset <em>T</em> of 

<math display="inline" id="Regular_chain:6">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is a triangular set, if the polynomials in <em>T</em> are non-constant and have distinct main variables. Hence, a triangular set is finite, and has cardinality at most <em>n</em>.</p>
<ul>
<li>Regular chain</li>
</ul>

<p>Let T = {t<sub>1</sub>, ..., t<sub>s</sub>} be a triangular set such that <em>mvar</em>(t<sub>1</sub>) s), 

<math display="inline" id="Regular_chain:7">
 <semantics>
  <msub>
   <mi>h</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{i}
  </annotation>
 </semantics>
</math>

 be the initial of <em>t</em><sub>i</sub> and <em>h</em> be the product of h<sub>i</sub>'s. Then <em>T</em> is a <em>regular chain</em> if</p>

<p>

<math display="block" id="Regular_chain:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>resultant</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>h</mi>
     <mo>,</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>resultant</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">⋯</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>resultant</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>h</mi>
         <mo>,</mo>
         <msub>
          <mi>t</mi>
          <mi>s</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>t</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi mathvariant="normal">⋯</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>resultant</ci>
      <interval closure="open">
       <ci>h</ci>
       <ci>T</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>resultant</ci>
      <apply>
       <times></times>
       <ci>normal-⋯</ci>
       <vector>
        <apply>
         <times></times>
         <ci>resultant</ci>
         <interval closure="open">
          <ci>h</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>t</ci>
           <ci>s</ci>
          </apply>
         </interval>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <ci>i</ci>
        </apply>
       </vector>
       <ci>normal-⋯</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <neq></neq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{resultant}(h,T)=\mathrm{resultant}(\cdots(\mathrm{resultant}(h,t_{s}),%
\ldots,t_{i})\cdots)\neq 0
  </annotation>
 </semantics>
</math>

, where each <a class="uri" href="resultant" title="wikilink">resultant</a> is computed with respect to the main variable of <em>t</em><sub>i</sub>, respectively. This definition is from Yang and Zhang, which is of much algorithmic flavor.</p>
<ul>
<li>Quasi-component and saturated ideal of a regular chain</li>
</ul>

<p>The <em>quasi-component</em> <em>W</em>(<em>T</em>) described by the regular chain <em>T</em> is</p>

<p>

<math display="block" id="Regular_chain:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>W</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∖</mo>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>h</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>W</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <setdiff></setdiff>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>T</ci>
     </apply>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>h</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W(T)=V(T)\setminus V(h)
  </annotation>
 </semantics>
</math>

, that is, the set difference of the varieties <em>V</em>(<em>T</em>) and <em>V</em>(<em>h</em>). The attached algebraic object of a regular chain is its <em>saturated ideal</em></p>

<p>

<math display="block" id="Regular_chain:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>sat</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <msup>
    <mi>h</mi>
    <mi mathvariant="normal">∞</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>sat</ci>
      <ci>T</ci>
     </apply>
     <ci>T</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>h</ci>
     <infinity></infinity>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{sat}(T)=(T):h^{\infty}
  </annotation>
 </semantics>
</math>

. A classic result is that the <a href="Zariski_closure" title="wikilink">Zariski closure</a> of <em>W</em>(<em>T</em>) equals the variety defined by sat(<em>T</em>), that is,</p>

<p>

<math display="block" id="Regular_chain:11">
 <semantics>
  <mrow>
   <mover accent="true">
    <mrow>
     <mi>W</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>¯</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>sat</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>T</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <times></times>
      <ci>W</ci>
      <ci>T</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>V</ci>
     <apply>
      <times></times>
      <ci>sat</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{W(T)}=V(\mathrm{sat}(T))
  </annotation>
 </semantics>
</math>

, and its dimension is n - |T|, the difference of the number of variables and the number of polynomials in <em>T</em>.</p>
<ul>
<li>Triangular decompositions</li>
</ul>

<p>In general, there are two ways to decompose a polynomial system <em>F</em>. The first one is to decompose lazily, that is, only to represent its <a href="generic_point" title="wikilink">generic points</a> in the (Kalkbrener) sense,</p>

<p>

<math display="block" id="Regular_chain:12">
 <semantics>
  <mrow>
   <msqrt>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>F</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msqrt>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo>∩</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>e</mi>
    </msubsup>
    <msqrt>
     <mrow>
      <mi>sat</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>T</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <root></root>
     <ci>F</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <intersect></intersect>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>e</ci>
     </apply>
     <apply>
      <root></root>
      <apply>
       <times></times>
       <ci>sat</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{(F)}=\cap_{i=1}^{e}\sqrt{\mathrm{sat}(T_{i})}
  </annotation>
 </semantics>
</math>

. The second is to describe all zeroes in the <a href="Daniel_Lazard" title="wikilink">Lazard</a> sense,</p>

<p>

<math display="block" id="Regular_chain:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>F</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo>∪</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>e</mi>
    </msubsup>
    <mrow>
     <mi>W</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>T</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>F</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <union></union>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>e</ci>
     </apply>
     <apply>
      <times></times>
      <ci>W</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(F)=\cup_{i=1}^{e}W(T_{i})
  </annotation>
 </semantics>
</math>

. There are various algorithms available for triangular decompositions in either sense.</p>
<h2 id="properties">Properties</h2>

<p>Let <em>T</em> be a regular chain in the polynomial ring <em>R</em>.</p>
<ul>
<li>The saturated ideal sat(<em>T</em>) is an <em>unmixed ideal</em> with dimension n − |<em>T</em>|.</li>
</ul>
<ul>
<li>A regular chain holds a strong elimination property in the sense that:</li>
</ul>

<p>

<math display="block" id="Regular_chain:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>sat</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>T</mi>
      <mo>∩</mo>
      <mrow>
       <mi>k</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>sat</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∩</mo>
    <mrow>
     <mi>k</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>sat</ci>
     <apply>
      <intersect></intersect>
      <ci>T</ci>
      <apply>
       <times></times>
       <ci>k</ci>
       <list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </list>
      </apply>
     </apply>
    </apply>
    <apply>
     <intersect></intersect>
     <apply>
      <times></times>
      <ci>sat</ci>
      <ci>T</ci>
     </apply>
     <apply>
      <times></times>
      <ci>k</ci>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{sat}(T\cap k[x_{1},\ldots,x_{i}])=\mathrm{sat}(T)\cap k[x_{1},\ldots,x%
_{i}]
  </annotation>
 </semantics>
</math>

.</p>
<ul>
<li>A polynomial <em>p</em> is in sat(<em>T</em>) if and only if p is pseudo-reduced to zero by <em>T</em>, that is,</li>
</ul>

<p>

<math display="block" id="Regular_chain:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mo>∈</mo>
    <mrow>
     <mi>sat</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mrow>
     <mi>prem</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>p</mi>
      <mo>,</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <apply>
     <in></in>
     <ci>p</ci>
     <apply>
      <times></times>
      <ci>sat</ci>
      <ci>T</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>prem</ci>
      <interval closure="open">
       <ci>p</ci>
       <ci>T</ci>
      </interval>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\in\mathrm{sat}(T)\iff\mathrm{prem}(p,T)=0
  </annotation>
 </semantics>
</math>

.</p>
<dl>
<dd>Hence the membership test for sat(<em>T</em>) is algorithmic.
</dd>
</dl>
<ul>
<li>A polynomial p is a <strong><a class="uri" href="zero-divisor" title="wikilink">zero-divisor</a></strong> modulo sat(<em>T</em>) if and only if 

<math display="inline" id="Regular_chain:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>prem</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo>,</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <ci>prem</ci>
     <interval closure="open">
      <ci>p</ci>
      <ci>T</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{prem}(p,T)\neq 0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Regular_chain:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>resultant</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo>,</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>resultant</ci>
     <interval closure="open">
      <ci>p</ci>
      <ci>T</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{resultant}(p,T)=0
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<dl>
<dd>Hence the regularity test for sat(<em>T</em>) is algorithmic.
</dd>
</dl>
<ul>
<li>Given a prime ideal <em>P</em>, there exists a regular chain <em>C</em> such that <em>P</em> = sat(<em>C</em>).</li>
</ul>
<ul>
<li>If the first element of a regular chain <em>C</em> is an irreducible polynomial and the others are linear in their main variable, then sat(<em>C</em>) is a prime ideal.</li>
</ul>
<ul>
<li>Conversely, if <em>P</em> is a prime ideal, then, after almost all linear changes of variables, there exists a regular chain <em>C</em> of the preceding shape such that <em>P</em> = sat(<em>C</em>).</li>
</ul>
<ul>
<li>A triangular set is a regular chain if and only if it is a <a href="Wu's_method_of_characteristic_set#Ritt_characteristic_set" title="wikilink">Ritt characteristic set</a> of its saturated ideal.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Wu's_method_of_characteristic_set" title="wikilink">Wu's method of characteristic set</a></li>
<li><a href="Gröbner_basis" title="wikilink">Gröbner basis</a></li>
<li><a class="uri" href="RegularChains" title="wikilink">RegularChains</a>, a software to compute with regular chains</li>
<li><a href="Regular_semi-algebraic_system" title="wikilink">Regular semi-algebraic system</a></li>
<li><a href="Triangular_decomposition" title="wikilink">Triangular decomposition</a></li>
</ul>
<h2 id="further-references">Further references</h2>
<ul>
<li>P. Aubry, D. Lazard, M. Moreno Maza. On the theories of triangular sets. Journal of Symbolic Computation, 28(1–2):105–124, 1999.</li>
<li>F. Boulier and F. Lemaire and M. Moreno Maza. Well known theorems on triangular systems and the D5 principle. Transgressive Computing 2006, Granada, Spain.</li>
<li>E. Hubert. Notes on triangular sets and triangulation-decomposition algorithms I: Polynomial systems. LNCS, volume 2630, Springer-Verlag Heidelberg.</li>
<li>F. Lemaire and M. Moreno Maza and Y. Xie. The RegularChains library. Maple Conference 2005.</li>
<li>M. Kalkbrener: Algorithmic Properties of Polynomial Rings. J. Symb. Comput. 26(5): 525–581 (1998).</li>
<li>M. Kalkbrener: A Generalized Euclidean Algorithm for Computing Triangular Representations of Algebraic Varieties. J. Symb. Comput. 15(2): 143–167 (1993).</li>
<li>D. Wang. Computing Triangular Systems and Regular Systems. Journal of Symbolic Computation 30(2) (2000) 221–236.</li>
<li>Yang, L., Zhang, J. (1994). Searching dependency between algebraic equations: an algorithm applied to automated reasoning. Artificial Intel ligence in Mathematics, pp. 14715, Oxford University Press.</li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Equations" title="wikilink">Category:Equations</a> <a class="uri" href="Category:Algebra" title="wikilink">Category:Algebra</a> <a class="uri" href="Category:Polynomials" title="wikilink">Category:Polynomials</a> <a href="Category:Algebraic_geometry" title="wikilink">Category:Algebraic geometry</a> <a href="Category:Computer_algebra" title="wikilink">Category:Computer algebra</a></p>
</body>
</html>
