<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1135">Robotics conventions</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Robotics conventions</h1>
<hr/>

<p>There are many conventions used in the <strong>robotics</strong> research field. This article summarises these conventions.</p>
<h2 id="line-representations">Line representations</h2>

<p>Lines are very important in robotics because:</p>
<ul>
<li>They model joint axes: a <a href="revolute_joint" title="wikilink">revolute joint</a> makes any connected rigid body rotate about the line of its axis; a <a href="prismatic_joint" title="wikilink">prismatic joint</a> makes the connected rigid body translate along its axis line.</li>
<li>They model edges of the polyhedral objects used in many task planners or sensor processing modules.</li>
<li>They are needed for shortest distance calculation between robots and obstacles</li>
</ul>
<h2 id="non-minimal-vector-coordinates">Non-minimal vector coordinates</h2>

<p>A line 

<math display="inline" id="Robotics_conventions:0">
<semantics>
<mrow>
<mi>L</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>p</mi>
<mo>,</mo>
<mi>d</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>L</ci>
<interval closure="open">
<ci>p</ci>
<ci>d</ci>
</interval>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   L(p,d)
  </annotation>
</semantics>
</math>

 is completely defined by the ordered set of two vectors:</p>
<ul>
<li>a point vector 

<math display="inline" id="Robotics_conventions:1">
<semantics>
<mi>p</mi>
<annotation-xml encoding="MathML-Content">
<ci>p</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   p
  </annotation>
</semantics>
</math>

, indicating the position of an arbitrary point on 

<math display="inline" id="Robotics_conventions:2">
<semantics>
<mi>L</mi>
<annotation-xml encoding="MathML-Content">
<ci>L</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   L
  </annotation>
</semantics>
</math>
</li>
<li>one free direction vector 

<math display="inline" id="Robotics_conventions:3">
<semantics>
<mi>d</mi>
<annotation-xml encoding="MathML-Content">
<ci>d</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   d
  </annotation>
</semantics>
</math>


, giving the line a direction as well as a sense.</li>
</ul>

<p>Each point 

<math display="inline" id="Robotics_conventions:4">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

 on the line is given a parameter value 

<math display="inline" id="Robotics_conventions:5">
<semantics>
<mi>t</mi>
<annotation-xml encoding="MathML-Content">
<ci>t</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   t
  </annotation>
</semantics>
</math>

 that satisfies: 

<math display="inline" id="Robotics_conventions:6">
<semantics>
<mrow>
<mi>x</mi>
<mo>=</mo>
<mrow>
<mi>p</mi>
<mo>+</mo>
<mrow>
<mi>t</mi>
<mi>d</mi>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>x</ci>
<apply>
<plus></plus>
<ci>p</ci>
<apply>
<times></times>
<ci>t</ci>
<ci>d</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x=p+td
  </annotation>
</semantics>
</math>

. The parameter t is unique once 

<math display="inline" id="Robotics_conventions:7">
<semantics>
<mi>p</mi>
<annotation-xml encoding="MathML-Content">
<ci>p</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   p
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Robotics_conventions:8">
<semantics>
<mi>d</mi>
<annotation-xml encoding="MathML-Content">
<ci>d</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   d
  </annotation>
</semantics>
</math>


 are chosen.<br/>
 The representation 

<math display="inline" id="Robotics_conventions:9">
<semantics>
<mrow>
<mi>L</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>p</mi>
<mo>,</mo>
<mi>d</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>L</ci>
<interval closure="open">
<ci>p</ci>
<ci>d</ci>
</interval>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   L(p,d)
  </annotation>
</semantics>
</math>

 is not minimal, because it uses six parameters for only four degrees of freedom.<br/>
 The following two constraints apply:</p>
<ul>
<li>The direction vector 

<math display="inline" id="Robotics_conventions:10">
<semantics>
<mi>d</mi>
<annotation-xml encoding="MathML-Content">
<ci>d</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   d
  </annotation>
</semantics>
</math>

 can be chosen to be a unit vector</li>
<li>the point vector 

<math display="inline" id="Robotics_conventions:11">
<semantics>
<mi>p</mi>
<annotation-xml encoding="MathML-Content">
<ci>p</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   p
  </annotation>
</semantics>
</math>

 can be chosen to be the point on the line that is nearest the origin. So 

<math display="inline" id="Robotics_conventions:12">
<semantics>
<mi>p</mi>
<annotation-xml encoding="MathML-Content">
<ci>p</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   p
  </annotation>
</semantics>
</math>

 is orthogonal to 

<math display="inline" id="Robotics_conventions:13">
<semantics>
<mi>d</mi>
<annotation-xml encoding="MathML-Content">
<ci>d</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   d
  </annotation>
</semantics>
</math>
</li>
</ul>
<h3 id="plücker-coordinates">Plücker coordinates</h3>

<p>Arthur Cayley and Julius Plücker introduced an alternative representation using two free vectors. This representation was finally named after Plücker.<br/>
 The Plücker representation is denoted by 

<math display="inline" id="Robotics_conventions:14">
<semantics>
<mrow>
<msub>
<mi>L</mi>
<mrow>
<mi>p</mi>
<mi>l</mi>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>d</mi>
<mo>,</mo>
<mi>m</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<apply>
<times></times>
<ci>p</ci>
<ci>l</ci>
</apply>
</apply>
<interval closure="open">
<ci>d</ci>
<ci>m</ci>
</interval>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   L_{pl}(d,m)
  </annotation>
</semantics>
</math>

. Both 

<math display="inline" id="Robotics_conventions:15">
<semantics>
<mi>d</mi>
<annotation-xml encoding="MathML-Content">
<ci>d</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   d
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Robotics_conventions:16">
<semantics>
<mi>m</mi>
<annotation-xml encoding="MathML-Content">
<ci>m</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   m
  </annotation>
</semantics>
</math>

 are free vectors

<math display="block" id="Robotics_conventions:17">
<semantics>
<mi>d</mi>
<annotation-xml encoding="MathML-Content">
<ci>d</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   d
  </annotation>
</semantics>
</math>

 represents the direction of the line and 

<math display="inline" id="Robotics_conventions:18">
<semantics>
<mi>m</mi>
<annotation-xml encoding="MathML-Content">
<ci>m</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   m
  </annotation>
</semantics>
</math>


 is the moment of 

<math display="inline" id="Robotics_conventions:19">
<semantics>
<mi>d</mi>
<annotation-xml encoding="MathML-Content">
<ci>d</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   d
  </annotation>
</semantics>
</math>

 about the chosen reference origin.

<math display="inline" id="Robotics_conventions:20">
<semantics>
<mrow>
<mi>m</mi>
<mo>=</mo>
<mrow>
<mi>p</mi>
<mo>×</mo>
<mi>d</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>m</ci>
<apply>
<times></times>
<ci>p</ci>
<ci>d</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   m=p\times d
  </annotation>
</semantics>
</math>

 (

<math display="inline" id="Robotics_conventions:21">
<semantics>
<mi>m</mi>
<annotation-xml encoding="MathML-Content">
<ci>m</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   m
  </annotation>
</semantics>
</math>

 is independent of which point 

<math display="inline" id="Robotics_conventions:22">
<semantics>
<mi>p</mi>
<annotation-xml encoding="MathML-Content">
<ci>p</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   p
  </annotation>
</semantics>
</math>

 on the line is chosen!)<br/>
 The advantage of the <a href="Plücker_coordinates" title="wikilink">Plücker coordinates</a> is that they are homogeneous.<br/>
 A line in Plücker coordinates has still four out of six independent parameters, so it is not a minimal representation. The two constraints on the six Plücker coordinates are</p>
<ul>
<li>the homogeneity constraint</li>
<li>the orthogonality constraint</li>
</ul>
<h2 id="minimal-line-representation">Minimal line representation</h2>

<p>A line representation is minimal if it uses four parameters, which is the minimum needed to represent all possible lines in the Euclidean Space (E³).</p>
<h3 id="denavithartenberg-line-coordinates">Denavit–Hartenberg line coordinates</h3>

<p>Jaques Denavit and Richard S. Hartenberg presented the first minimal representation for a line which is now widely used. The <a href="Common_normal_(robotics)" title="wikilink">common normal</a> between two lines was the main geometric concept that allowed Denavit and Hartenberg to find a minimal representation. Engineers use the Denavit–Hartenberg convention(D–H) to help them describe the positions of links and joints unambiguously. Every link gets its own <a href="coordinate_system" title="wikilink">coordinate system</a>. There are a few rules to consider in choosing the coordinate system:</p>
<ol>
<li>the 

<math display="inline" id="Robotics_conventions:23">
<semantics>
<mi>z</mi>
<annotation-xml encoding="MathML-Content">
<ci>z</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   z
  </annotation>
</semantics>
</math>


-axis is in the direction of the joint axis</li>
<li>the 

<math display="inline" id="Robotics_conventions:24">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

-axis is parallel to the <a href="Common_normal_(robotics)" title="wikilink">common normal</a>
<math display="block" id="Robotics_conventions:25">
<semantics>
<mrow>
<msub>
<mi>x</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<mrow>
<msub>
<mi>z</mi>
<mi>n</mi>
</msub>
<mo>×</mo>
<msub>
<mi>z</mi>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>n</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>z</ci>
<apply>
<minus></minus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{n}=z_{n}\times z_{n-1}
  </annotation>
</semantics>
</math>
<br/>
If there is no unique common normal (parallel 

<math display="inline" id="Robotics_conventions:26">
<semantics>
<mi>z</mi>
<annotation-xml encoding="MathML-Content">
<ci>z</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   z
  </annotation>
</semantics>
</math>

 axes), then 

<math display="inline" id="Robotics_conventions:27">
<semantics>
<mi>d</mi>
<annotation-xml encoding="MathML-Content">
<ci>d</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   d
  </annotation>
</semantics>
</math>

 (below) is a free parameter.</li>
<li>the 

<math display="inline" id="Robotics_conventions:28">
<semantics>
<mi>y</mi>
<annotation-xml encoding="MathML-Content">
<ci>y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   y
  </annotation>
</semantics>
</math>


-axis follows from the 

<math display="inline" id="Robotics_conventions:29">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

- and 

<math display="inline" id="Robotics_conventions:30">
<semantics>
<mi>z</mi>
<annotation-xml encoding="MathML-Content">
<ci>z</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   z
  </annotation>
</semantics>
</math>

-axis by choosing it to be a <a href="Cartesian_coordinate_system#In_three_dimensions" title="wikilink">right-handed coordinate system</a>.</li>
</ol>

<p>Once the coordinate frames are determined, inter-link transformations are uniquely described by the following four parameters:</p>
<ul>
<li>
<math display="inline" id="Robotics_conventions:31">
<semantics>
<mpadded width="+1.7pt">
<mi>θ</mi>
</mpadded>
<annotation-xml encoding="MathML-Content">
<ci>θ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \theta\,
  </annotation>
</semantics>
</math>

: angle about previous 

<math display="inline" id="Robotics_conventions:32">
<semantics>
<mi>z</mi>
<annotation-xml encoding="MathML-Content">
<ci>z</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   z
  </annotation>
</semantics>
</math>

, from old 

<math display="inline" id="Robotics_conventions:33">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>


 to new 

<math display="inline" id="Robotics_conventions:34">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>
</li>
<li>
<math display="inline" id="Robotics_conventions:35">
<semantics>
<mpadded width="+1.7pt">
<mi>d</mi>
</mpadded>
<annotation-xml encoding="MathML-Content">
<ci>d</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   d\,
  </annotation>
</semantics>
</math>

: offset along previous 

<math display="inline" id="Robotics_conventions:36">
<semantics>
<mi>z</mi>
<annotation-xml encoding="MathML-Content">
<ci>z</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   z
  </annotation>
</semantics>
</math>

 to the common normal</li>
<li>
<math display="inline" id="Robotics_conventions:37">
<semantics>
<mpadded width="+1.7pt">
<mi>r</mi>
</mpadded>
<annotation-xml encoding="MathML-Content">
<ci>r</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   r\,
  </annotation>
</semantics>
</math>

: length of the common normal (aka 

<math display="inline" id="Robotics_conventions:38">
<semantics>
<mi>a</mi>
<annotation-xml encoding="MathML-Content">
<ci>a</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   a
  </annotation>
</semantics>
</math>


, but if using this notation, do not confuse with 

<math display="inline" id="Robotics_conventions:39">
<semantics>
<mi>α</mi>
<annotation-xml encoding="MathML-Content">
<ci>α</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \alpha
  </annotation>
</semantics>
</math>

). Assuming a revolute joint, this is the radius about previous 

<math display="inline" id="Robotics_conventions:40">
<semantics>
<mi>z</mi>
<annotation-xml encoding="MathML-Content">
<ci>z</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   z
  </annotation>
</semantics>
</math>

.</li>
<li>
<math display="inline" id="Robotics_conventions:41">
<semantics>
<mpadded width="+1.7pt">
<mi>α</mi>
</mpadded>
<annotation-xml encoding="MathML-Content">
<ci>α</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \alpha\,
  </annotation>
</semantics>
</math>

: angle about common normal, from old 

<math display="inline" id="Robotics_conventions:42">
<semantics>
<mi>z</mi>
<annotation-xml encoding="MathML-Content">
<ci>z</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   z
  </annotation>
</semantics>
</math>

 axis to new 

<math display="inline" id="Robotics_conventions:43">
<semantics>
<mi>z</mi>
<annotation-xml encoding="MathML-Content">
<ci>z</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   z
  </annotation>
</semantics>
</math>


 axis</li>
</ul>
<h3 id="hayatiroberts-line-coordinates">Hayati–Roberts line coordinates</h3>

<p>The Hayati–Roberts line representation, denoted 

<math display="inline" id="Robotics_conventions:44">
<semantics>
<mrow>
<msub>
<mi>L</mi>
<mrow>
<mi>h</mi>
<mi>r</mi>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>e</mi>
<mi>x</mi>
</msub>
<mo>,</mo>
<msub>
<mi>e</mi>
<mi>y</mi>
</msub>
<mo>,</mo>
<msub>
<mi>l</mi>
<mi>x</mi>
</msub>
<mo>,</mo>
<msub>
<mi>l</mi>
<mi>y</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>L</ci>
<apply>
<times></times>
<ci>h</ci>
<ci>r</ci>
</apply>
</apply>
<vector>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>e</ci>
<ci>x</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>e</ci>
<ci>y</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>l</ci>
<ci>x</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>l</ci>
<ci>y</ci>
</apply>
</vector>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   L_{hr}(e_{x},e_{y},l_{x},l_{y})
  </annotation>
</semantics>
</math>

, is another minimal line representation, with parameters:</p>
<ul>
<li>
<math display="inline" id="Robotics_conventions:45">
<semantics>
<msub>
<mi>e</mi>
<mi>x</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>e</ci>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   e_{x}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Robotics_conventions:46">
<semantics>
<msub>
<mi>e</mi>
<mi>y</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>e</ci>
<ci>y</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   e_{y}
  </annotation>
</semantics>
</math>

 are the 

<math display="inline" id="Robotics_conventions:47">
<semantics>
<mi>X</mi>
<annotation-xml encoding="MathML-Content">
<ci>X</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   X
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Robotics_conventions:48">
<semantics>
<mi>Y</mi>
<annotation-xml encoding="MathML-Content">
<ci>Y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y
  </annotation>
</semantics>
</math>


 components of a unit direction vector 

<math display="inline" id="Robotics_conventions:49">
<semantics>
<mi>e</mi>
<annotation-xml encoding="MathML-Content">
<ci>e</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   e
  </annotation>
</semantics>
</math>

 on the line. This requirement eliminates the need for a 

<math display="inline" id="Robotics_conventions:50">
<semantics>
<mi>Z</mi>
<annotation-xml encoding="MathML-Content">
<ci>Z</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   Z
  </annotation>
</semantics>
</math>

 component, since 

<math display="inline" id="Robotics_conventions:51">
<semantics>
<mrow>
<msub>
<mi>e</mi>
<mi>z</mi>
</msub>
<mo>=</mo>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<msubsup>
<mi>e</mi>
<mi>x</mi>
<mn>2</mn>
</msubsup>
<mo>-</mo>
<msubsup>
<mi>e</mi>
<mi>y</mi>
<mn>2</mn>
</msubsup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>e</ci>
<ci>z</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>e</ci>
<ci>x</ci>
</apply>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>e</ci>
<ci>y</ci>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   e_{z}=(1-e_{x}^{2}-e_{y}^{2})^{\frac{1}{2}}
  </annotation>
</semantics>
</math>
</li>
<li>
<math display="inline" id="Robotics_conventions:52">
<semantics>
<msub>
<mi>l</mi>
<mi>x</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>l</ci>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   l_{x}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Robotics_conventions:53">
<semantics>
<msub>
<mi>l</mi>
<mi>y</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>l</ci>
<ci>y</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   l_{y}
  </annotation>
</semantics>
</math>


 are the coordinates of the intersection point of the line with the plane through the origin of the world reference frame, and normal to the line. The reference frame on this normal plane has the same origin as the world reference frame, and its 

<math display="inline" id="Robotics_conventions:54">
<semantics>
<mi>X</mi>
<annotation-xml encoding="MathML-Content">
<ci>X</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   X
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Robotics_conventions:55">
<semantics>
<mi>Y</mi>
<annotation-xml encoding="MathML-Content">
<ci>Y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y
  </annotation>
</semantics>
</math>

 frame axes are images of the world frame's 

<math display="inline" id="Robotics_conventions:56">
<semantics>
<mi>X</mi>
<annotation-xml encoding="MathML-Content">
<ci>X</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   X
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Robotics_conventions:57">
<semantics>
<mi>Y</mi>
<annotation-xml encoding="MathML-Content">
<ci>Y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y
  </annotation>
</semantics>
</math>

 axes through parallel projection along the line.</li>
</ul>

<p>This representation is unique for a directed line. The coordinate singularities are different from the DH singularities: it has singularities if the line becomes parallel to either the 

<math display="inline" id="Robotics_conventions:58">
<semantics>
<mi>X</mi>
<annotation-xml encoding="MathML-Content">
<ci>X</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   X
  </annotation>
</semantics>
</math>


 or 

<math display="inline" id="Robotics_conventions:59">
<semantics>
<mi>Y</mi>
<annotation-xml encoding="MathML-Content">
<ci>Y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   Y
  </annotation>
</semantics>
</math>

 axis of the world frame.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="List_of_basic_robotics_topics" title="wikilink">List of basic robotics topics</a></li>
<li><a href="Denavit–Hartenberg_parameters" title="wikilink">Denavit–Hartenberg parameters</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Giovanni Legnani, Federico Casolo, Paolo Righettini and Bruno Zappa <em>A homogeneous matrix approach to 3D kinematics and dynamics — I. Theory</em> Mechanism and Machine Theory, Volume 31, Issue 5, July 1996, Pages 573–587</li>
<li>Giovanni Legnani, Federico Casalo, Paolo Righettini and Bruno Zappa <em>A homogeneous matrix approach to 3D kinematics and dynamics—II. Applications to chains of rigid bodies and serial manipulators</em> Mechanism and Machine Theory, Volume 31, Issue 5, July 1996, Pages 589–605</li>
<li>A. Bottema and B. Roth. <em>Theoretical Kinematics.</em> Dover Books on Engineering. Dover Publications, Inc. Mineola, NY, 1990</li>
<li><a href="Arthur_Cayley" title="wikilink">A. Cayley</a>. On a new analytical representation of curves in space. <em>Quarterly Journal of Pure and Applied Mathematics</em>,3:225–236,1860</li>
<li><a href="Kenneth_H._Hunt" title="wikilink">K.H. Hunt</a>. <em>Kinematic Geometry of Mechanisms</em>. Oxford Science Publications, Oxford, England, 2n edition, 1990</li>
<li><a href="Julius_Plücker" title="wikilink">J. Plücker</a>. On a new geometry of space. <em>Philosophical Transactions of the Royal Society of London</em>, 155:725–791, 1865</li>
<li><a href="Julius_Plücker" title="wikilink">J. Plücker</a>. Fundamental views regarding mechanics. <em>Philosophical Transactions of the Royal Society of London</em>, 156:361–380, 1866</li>
<li>J. Denavit and R.S. Hartenberg. A kinematic notation for lower-pair mechanisms based on matrices. Trans ASME J. Appl. Mech, 23:215–221,1955</li>
<li><a href="http://kmoddl.library.cornell.edu/bib.php?m=23">R.S. HartenBerg and J. Denavit <em>Kinematic synthesis of linkages</em> McGraw–Hill, New York, NY, 1964</a></li>
<li>R. Bernhardt and S.L. Albright. <em>Robot Calibration</em>, Chapman &amp; Hall, 1993</li>
<li>S.A. Hayati and M. Mirmirani. Improving the absolute positioning accuracy of robot manipulators. <em>J. Robotic Systems</em>, 2(4):397–441, 1985</li>
<li>K.S. Roberts. A new representation for a line. In <em>Proceedings of the Conference on Computer Vision and Pattern Recognition</em>, pages 635–640, Ann Arbor, MI, 1988</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://library.wolfram.com/infocenter/MathSource/4733/">Denavit Hartenburg Convention Computational Software, Wolfram.com 'Math Source' Author: Jason Desjardins 2002</a></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Robotics" title="wikilink">Category:Robotics</a></p>
</body>
</html>
