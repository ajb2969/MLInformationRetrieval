<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1579">Non-interactive zero-knowledge proof</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Non-interactive zero-knowledge proof</h1>
<hr>'''Non-interactive zero-knowledge proofs''' are a variant of [[zero-knowledge proof]]s in which no interaction is necessary between prover and verifier. [[Manuel Blum|Blum]], Feldman, and [[Silvio Micali|Micali]] <ref name="bfm">Manuel Blum, Paul Feldman, and Silvio Micali. Non-Interactive Zero-Knowledge and Its Applications. Proceedings of the twentieth annual ACM symposium on Theory of computing (STOC 1988). 103–112. 1988</ref> showed that a common reference string shared between the prover and the verifier is enough to achieve computational zero-knowledge without requiring interaction. [[Oded Goldreich|Goldreich]] and Oren<ref>Oded Goldreich and Yai
<p>r Oren. Definitions and Properties of Zero-Knowledge Proof Systems. Journal of Cryptology. Vol 7(1). 1–32. 1994 <a href="http://www.wisdom.weizmann.ac.il/~oded/PS/oren.ps">(PS)</a> gave impossibility results for one shot zero-knowledge protocols in the <a href="Standard_Model_(cryptography)" title="wikilink">standard model</a>. In 2003, Goldwasser and Kalai published an instance of identification scheme for which any hash function will yield an insecure digital signature scheme.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> These results are not contradictory, as the impossibility result of Goldreich and Oren does not hold in the <a href="common_reference_string_model" title="wikilink">common reference string model</a> or the <a href="random_oracle_model" title="wikilink">random oracle model</a>. Non-interactive zero-knowledge proofs however show a separation between the cryptographic tasks that can be achieved in the standard model and those that can be achieved in 'more powerful' extended models.</p>

<p>The model influences the properties that can be obtained from a zero-knowledge protocol. Pass<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> showed that in the common reference string model non-interactive zero-knowledge protocols do not preserve all of the properties of interactive zero-knowledge protocols, e.g. they do not preserve deniability.</p>

<p>Non-interactive zero-knowledge proofs can also be obtained in the <a href="random_oracle_model" title="wikilink">random oracle model</a> using the <a href="Fiat–Shamir_heuristic" title="wikilink">Fiat–Shamir heuristic</a>.</p>
<h2 id="definition">Definition</h2>

<p>Originally,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> non-interactive zero-knowledge was only defined as a single theorem proof system. In such a system each proof requires its own fresh common reference string. A common reference string in general is not a random string. It may, for instance, consist of randomly chosen group elements that all protocol parties use. Although the group elements are random, the reference string is not as it contains a certain structure (e.g., group elements) that is distinguishable from randomness. Subsequently, Feige, Lapidot, and <a href="Adi_Shamir" title="wikilink">Shamir</a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> introduced multi-theorem zero-knowledge proofs as a more versatile notion for non-interactive zero knowledge proofs.</p>

<p>In this model the prover and the verifier are in possession of a reference string sampled from a distribution <em>D</em> by a trusted setup 

<math display="inline" id="Non-interactive_zero-knowledge_proof:0">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>←</mo>
   <mrow>
    <mi>Setup</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mn>1</mn>
      <mi>k</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>σ</ci>
    <apply>
     <times></times>
     <ci>Setup</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">1</cn>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\leftarrow\mathrm{Setup}(1^{k})
  </annotation>
 </semantics>
</math>

. To prove statement 

<math display="inline" id="Non-interactive_zero-knowledge_proof:1">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>∈</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>y</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\in L
  </annotation>
 </semantics>
</math>

 with witness <em>w</em>, the prover runs 

<math display="inline" id="Non-interactive_zero-knowledge_proof:2">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mo>←</mo>
   <mrow>
    <mi>Prove</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>σ</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>π</ci>
    <apply>
     <times></times>
     <ci>Prove</ci>
     <vector>
      <ci>σ</ci>
      <ci>y</ci>
      <ci>w</ci>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi\leftarrow\mathrm{Prove}(\sigma,y,w)
  </annotation>
 </semantics>
</math>

 and sends the proof 

<math display="inline" id="Non-interactive_zero-knowledge_proof:3">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 to the verifier. The verifier accepts if 

<math display="inline" id="Non-interactive_zero-knowledge_proof:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>Verify</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>σ</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>π</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>accept</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Verify</ci>
     <vector>
      <ci>σ</ci>
      <ci>y</ci>
      <ci>π</ci>
     </vector>
    </apply>
    <ci>accept</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Verify}(\sigma,y,\pi)=\mathrm{accept}
  </annotation>
 </semantics>
</math>

, and rejects otherwise. To account for the fact that 

<math display="inline" id="Non-interactive_zero-knowledge_proof:5">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 may influence the statements that are being proven, the witness relation can be generalized to 

<math display="inline" id="Non-interactive_zero-knowledge_proof:6">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msub>
    <mi>R</mi>
    <mi>σ</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>y</ci>
     <ci>w</ci>
    </interval>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (y,w)\in R_{\sigma}
  </annotation>
 </semantics>
</math>

 parameterized by 

<math display="inline" id="Non-interactive_zero-knowledge_proof:7">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="completeness">Completeness</h3>

<p>Verification succeeds for all 

<math display="inline" id="Non-interactive_zero-knowledge_proof:8">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>∈</mo>
   <mrow>
    <mi>Setup</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mn>1</mn>
      <mi>k</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>σ</ci>
    <apply>
     <times></times>
     <ci>Setup</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">1</cn>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\in\mathrm{Setup}(1^{k})
  </annotation>
 </semantics>
</math>

 and every 

<math display="inline" id="Non-interactive_zero-knowledge_proof:9">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msub>
    <mi>R</mi>
    <mi>σ</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>y</ci>
     <ci>w</ci>
    </interval>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (y,w)\in R_{\sigma}
  </annotation>
 </semantics>
</math>

.</p>

<p>More formally, for all <em>k</em>, all 

<math display="inline" id="Non-interactive_zero-knowledge_proof:10">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>∈</mo>
   <mrow>
    <mi>Setup</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mn>1</mn>
      <mi>k</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>σ</ci>
    <apply>
     <times></times>
     <ci>Setup</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">1</cn>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma\in\mathrm{Setup}(1^{k})
  </annotation>
 </semantics>
</math>

, and all 

<math display="inline" id="Non-interactive_zero-knowledge_proof:11">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msub>
    <mi>R</mi>
    <mi>σ</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>y</ci>
     <ci>w</ci>
    </interval>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (y,w)\in R_{\sigma}
  </annotation>
 </semantics>
</math>

:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Non-interactive_zero-knowledge_proof:12">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>π</mi>
    <mo>←</mo>
    <mi>Prove</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>σ</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>:</mo>
    <mi>Verify</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>σ</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>π</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mi>accept</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">π</csymbol>
     <ci>normal-←</ci>
     <csymbol cd="unknown">Prove</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">σ</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">w</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-:</ci>
     <csymbol cd="unknown">Verify</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">σ</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">π</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <csymbol cd="unknown">accept</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">1</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Pr[\pi\leftarrow\mathrm{Prove}(\sigma,y,w):\mathrm{Verify}(\sigma,y,\pi)=%
\mathrm{accept}]=1
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<h3 id="soundness">Soundness</h3>

<p>Soundness requires that no prover can make the verifier accept for a wrong statement 

<math display="inline" id="Non-interactive_zero-knowledge_proof:13">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>∉</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>y</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\not\in L
  </annotation>
 </semantics>
</math>

 except with some small probability. The upper bound of this probability is referred to as the soundness error of a proof system.</p>

<p>More formally, for every malicious prover 

<math display="inline" id="Non-interactive_zero-knowledge_proof:14">
 <semantics>
  <mover accent="true">
   <mi>P</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{P}
  </annotation>
 </semantics>
</math>

, there exists a <a href="negligible_function" title="wikilink">negligible function</a> 

<math display="inline" id="Non-interactive_zero-knowledge_proof:15">
 <semantics>
  <mi>ν</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ν</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu
  </annotation>
 </semantics>
</math>

 such that</p>
<dl>
<dd><dl>
<dd><math>Pr[\sigma \gets \mathrm{Setup}(1^k), (y,\pi) \gets \tilde{P}(\sigma):
</math></dd>
</dl>
</dd>
</dl>

<p>y\not\in L \land \mathrm{Verify}(\sigma, y, \pi)=\mathrm{accept}] =\nu(k)\;.</p>

<p>The above definition requires the soundness error to be negligible in the security parameter <em>k</em>. By increasing <em>k</em> the soundness error can be made arbitrary small. If the soundness error is <em>0</em> for all <em>k</em>, we speak of <em>perfect soundness</em>.</p>
<h3 id="multi-theorem-zero-knowledge">Multi-theorem zero-knowledge</h3>

<p>A non-interactive proof system 

<math display="inline" id="Non-interactive_zero-knowledge_proof:16">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>Setup</mi>
   <mo>,</mo>
   <mi>Prove</mi>
   <mo>,</mo>
   <mi>Verify</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>Setup</ci>
    <ci>Prove</ci>
    <ci>Verify</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathrm{Setup},\mathrm{Prove},\mathrm{Verify})
  </annotation>
 </semantics>
</math>

 is multi-theorem zero-knowledge, if there exists a simulator 

<math display="inline" id="Non-interactive_zero-knowledge_proof:17">
 <semantics>
  <mrow>
   <mi>Sim</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>Sim</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>Sim</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Sim</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Sim</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Sim</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Sim}=(\mathrm{Sim}_{1},\mathrm{Sim}_{2})
  </annotation>
 </semantics>
</math>

 such that for all non-uniform polynomial time adversaries 

<math display="inline" id="Non-interactive_zero-knowledge_proof:18">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

,</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Non-interactive_zero-knowledge_proof:19">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>σ</mi>
    <mo>←</mo>
    <mi>Setup</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mn>1</mn>
      <mi>k</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>:</mo>
    <msup>
     <mi class="ltx_font_mathcaligraphic">𝒜</mi>
     <mrow>
      <mi>Prove</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>σ</mi>
       <mo>,</mo>
       <mo>.</mo>
       <mo>,</mo>
       <mo>.</mo>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>σ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≡</mo>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>σ</mi>
     <mo>,</mo>
     <mi>τ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>←</mo>
    <msub>
     <mi>Sim</mi>
     <mn>1</mn>
    </msub>
    <mo>:</mo>
    <msup>
     <mi class="ltx_font_mathcaligraphic">𝒜</mi>
     <mrow>
      <mi>Sim</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>σ</mi>
       <mo>,</mo>
       <mi>τ</mi>
       <mo>,</mo>
       <mo>.</mo>
       <mo>,</mo>
       <mo>.</mo>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>σ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">σ</csymbol>
     <ci>normal-←</ci>
     <csymbol cd="unknown">Setup</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">1</cn>
       <ci>k</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝒜</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">Prove</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">σ</csymbol>
        <ci>normal-,</ci>
        <ci>normal-.</ci>
        <ci>normal-,</ci>
        <ci>normal-.</ci>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">σ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-]</ci>
    </cerror>
    <equivalent></equivalent>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">σ</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">τ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-←</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Sim</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝒜</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">Sim</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">σ</csymbol>
        <ci>normal-,</ci>
        <csymbol cd="unknown">τ</csymbol>
        <ci>normal-,</ci>
        <ci>normal-.</ci>
        <ci>normal-,</ci>
        <ci>normal-.</ci>
        <ci>normal-)</ci>
       </cerror>
      </cerror>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">σ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Pr[\sigma\leftarrow\mathrm{Setup}(1^{k}):\mathcal{A}^{{\mathrm{Prove}}(\sigma,%
.,.)}(\sigma)=1]\equiv Pr[(\sigma,\tau)\leftarrow\mathrm{Sim}_{1}:\mathcal{A}^%
{{\mathrm{Sim}}(\sigma,\tau,.,.)}(\sigma)=1]
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Here 

<math display="inline" id="Non-interactive_zero-knowledge_proof:20">
 <semantics>
  <mrow>
   <mi>Sim</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>σ</mi>
    <mo>,</mo>
    <mi>τ</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Sim</ci>
    <vector>
     <ci>σ</ci>
     <ci>τ</ci>
     <ci>y</ci>
     <ci>w</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Sim}(\sigma,\tau,y,w)
  </annotation>
 </semantics>
</math>

 outputs 

<math display="inline" id="Non-interactive_zero-knowledge_proof:21">
 <semantics>
  <mrow>
   <msub>
    <mi>Sim</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>σ</mi>
    <mo>,</mo>
    <mi>τ</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Sim</ci>
     <cn type="integer">2</cn>
    </apply>
    <vector>
     <ci>σ</ci>
     <ci>τ</ci>
     <ci>y</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Sim_{2}}(\sigma,\tau,y)
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Non-interactive_zero-knowledge_proof:22">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msub>
    <mi>R</mi>
    <mi>σ</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>y</ci>
     <ci>w</ci>
    </interval>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (y,w)\in R_{\sigma}
  </annotation>
 </semantics>
</math>

 and both oracles output <em>failure</em> otherwise.</p>
<h2 id="pairing-based-non-interactive-proofs">Pairing-based non-interactive proofs</h2>

<p><a href="Pairing-based_cryptography" title="wikilink">Pairing-based cryptography</a> has led to several cryptographic advancements. One of these advancements is more powerful and more efficient non-interactive zero-knowledge proofs. The seminal idea was to hide the values for the evaluation of the pairing in a <a href="Commitment_scheme" title="wikilink">commitment</a>. Using different commitment schemes, this idea was used to build zero-knowledge proof systems under the <a href="sub-group_hiding" title="wikilink">sub-group hiding</a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> and under the <a href="decisional_linear_assumption" title="wikilink">decisional linear assumption</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> These proof systems prove <a href="Boolean_satisfiability_problem" title="wikilink">circuit satisfiability</a>, and thus by the <a href="Cook–Levin_theorem" title="wikilink">Cook–Levin theorem</a> allow to prove membership for every language in NP. The size of the common reference string and the proofs is relatively small, however transforming a statement into a boolean circuit causes a considerable overhead.</p>

<p>Proof systems under the <a href="sub-group_hiding" title="wikilink">sub-group hiding</a>, <a href="decisional_linear_assumption" title="wikilink">decisional linear assumption</a>, and <a href="XDH_assumption" title="wikilink">external Diffie–Hellman assumption</a> that allow to directly prove the pairing product equations that are common in <a href="pairing-based_cryptography" title="wikilink">pairing-based cryptography</a> have been proposed.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>Under strong <a href="knowledge_assumption" title="wikilink">knowledge assumptions</a>, it is known how to create sublinear-length computationally sound proof systems for <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> languages. More precisely, the proof in such proof systems consists only of a small number of bilinear group elements.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cs.ucsd.edu/users/daniele/papers/GMR.html">An efficient non-interactive statistical zero-knowledge proof system for quasi-safe prime products</a></li>
</ul>

<p>"</p>

<p><a href="Category:Cryptographic_protocols" title="wikilink">Category:Cryptographic protocols</a> <a href="Category:Theory_of_cryptography" title="wikilink">Category:Theory of cryptography</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Shafi Goldwasser and Yael Kalai. On the (In)security of the Fiat–Shamir Paradigm. Proceedings of the 44th Annual IEEE Symposium on Foundations of Computer Science (FOCS'03). 2003<a href="#fnref1">↩</a></li>
<li id="fn2">Rafael Pass. On Deniability in the Common Reference String and Random Oracle Model. Advances in Cryptology – CRYPTO 2003. 316–337. 2003 <a href="http://www.nada.kth.se/~rafael/papers/denzk.ps">(PS)</a><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4">Uriel Feige, Dror Lapidot, Adi Shamir: Multiple Non-Interactive Zero Knowledge Proofs Under General Assumptions. SIAM J. Comput. 29(1): 1–28 (1999)<a href="#fnref4">↩</a></li>
<li id="fn5">Jens Groth, Rafail Ostrovsky, Amit Sahai: Perfect Non-interactive Zero Knowledge for NP. EUROCRYPT 2006: 339–358<a href="#fnref5">↩</a></li>
<li id="fn6">Jens Groth, Rafail Ostrovsky, Amit Sahai: Non-interactive Zaps and New Techniques for NIZK. CRYPTO 2006: 97–111<a href="#fnref6">↩</a></li>
<li id="fn7">Jens Groth, Amit Sahai: Efficient Non-interactive Proof Systems for Bilinear Groups. EUROCRYPT 2008: 415–432<a href="#fnref7">↩</a></li>
<li id="fn8">Jens Groth. Short Pairing-Based Non-interactive Zero-Knowledge Arguments. ASIACRYPT 2010: 321–340<a href="#fnref8">↩</a></li>
<li id="fn9">Helger Lipmaa. Progression-Free Sets and Sublinear Pairing-Based Non-Interactive Zero-Knowledge Arguments. TCC 2012: 169–189<a href="#fnref9">↩</a></li>
</ol>
</section>
</ref></hr></body>
</html>
