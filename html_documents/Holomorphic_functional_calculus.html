<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1887">Holomorphic functional calculus</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Holomorphic functional calculus</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <strong>holomorphic functional calculus</strong> is <a href="functional_calculus" title="wikilink">functional calculus</a> with <a href="holomorphic_function" title="wikilink">holomorphic functions</a>. That is to say, given a holomorphic function <em>f</em> of a <a href="complex_number" title="wikilink">complex</a> argument <em>z</em> and an <a href="Operator_(mathematics)" title="wikilink">operator</a> <em>T</em>, the aim is to construct an operator, <em>f</em>(<em>T</em>), which in a sense extends the function <em>f</em> from complex argument to operator argument.</p>

<p>This article will discuss the case where <em>T</em> is a <a href="bounded_linear_operator" title="wikilink">bounded linear operator</a> on some <a href="Banach_space" title="wikilink">Banach space</a>. In particular, <em>T</em> can be a <a href="square_matrix" title="wikilink">square matrix</a> with complex entries, a case which will be used to illustrate functional calculus and provide some heuristic insights for the assumptions involved in the general construction.</p>
<h2 id="motivation">Motivation</h2>
<h3 id="need-for-a-general-functional-calculus">Need for a general functional calculus</h3>

<p>In this section <em>T</em> will be assumed to be a <em>n</em> × <em>n</em> matrix with complex entries.</p>

<p>If a given function <em>f</em> is of certain special type, there are natural ways of defining <em>f</em>(<em>T</em>). For instance, if</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>m</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
     <msup>
      <mi>z</mi>
      <mi>i</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(z)=\sum_{i=0}^{m}a_{i}z^{i}
  </annotation>
 </semantics>
</math>

</p>

<p>is a complex <a class="uri" href="polynomial" title="wikilink">polynomial</a>, one can simply substitute <em>T</em> for <em>z</em> and define</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>m</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
     <msup>
      <mi>T</mi>
      <mi>i</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>T</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(T)=\sum_{i=0}^{m}a_{i}T^{i}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>T</em><sup>0</sup> = <em>I</em>, the <a href="identity_matrix" title="wikilink">identity matrix</a>. This is the <strong>polynomial functional calculus</strong>. It is a homomorphism from the ring of polynomials to the ring of <em>n</em> × <em>n</em> matrices.</p>

<p>Extending slightly from the polynomials, if <em>f</em> : <strong>C</strong> → <strong>C</strong> is holomorphic everywhere, i.e. an <a href="entire_function" title="wikilink">entire function</a>, with <a href="MacLaurin_series" title="wikilink">MacLaurin series</a></p>

<p>

<math display="block" id="Holomorphic_functional_calculus:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>i</mi>
      </msub>
      <msup>
       <mi>z</mi>
       <mi>i</mi>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(z)=\sum_{i=0}^{\infty}a_{i}z^{i},
  </annotation>
 </semantics>
</math>

</p>

<p>mimicking the polynomial case suggests we define</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>i</mi>
      </msub>
      <msup>
       <mi>T</mi>
       <mi>i</mi>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>T</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(T)=\sum_{i=0}^{\infty}a_{i}T^{i}.
  </annotation>
 </semantics>
</math>

</p>

<p>Since the MacLaurin series converges everywhere, the above series will converge, in a chosen <a href="operator_norm" title="wikilink">operator norm</a>. An example of this is the <a href="exponential_function" title="wikilink">exponential</a> of a matrix. Replacing <em>z</em> by <em>T</em> in the MacLaurin series of <em>f</em>(<em>z</em>) = <em>e<sup>z</sup></em> gives</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msup>
     <mi>e</mi>
     <mi>T</mi>
    </msup>
    <mo>=</mo>
    <mrow>
     <mi>I</mi>
     <mo>+</mo>
     <mi>T</mi>
     <mo>+</mo>
     <mfrac>
      <msup>
       <mi>T</mi>
       <mn>2</mn>
      </msup>
      <mrow>
       <mn>2</mn>
       <mo lspace="0pt" rspace="3.5pt">!</mo>
      </mrow>
     </mfrac>
     <mo>+</mo>
     <mfrac>
      <msup>
       <mi>T</mi>
       <mn>3</mn>
      </msup>
      <mrow>
       <mn>3</mn>
       <mo lspace="0pt" rspace="3.5pt">!</mo>
      </mrow>
     </mfrac>
     <mo>+</mo>
     <mi mathvariant="normal">⋯</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>T</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <ci>T</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <ci>I</ci>
      <ci>T</ci>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>T</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <factorial></factorial>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>T</ci>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <factorial></factorial>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(T)=e^{T}=I+T+\frac{T^{2}}{2!}+\frac{T^{3}}{3!}+\cdots.
  </annotation>
 </semantics>
</math>

</p>

<p>The requirement that the MacLaurin series of <em>f</em> converges everywhere can be relaxed somewhat. From above it is evident that all that is really needed is the radius of convergence of the MacLaurin series be greater than ǁ<em>T</em>ǁ, the operator norm of <em>T</em>. This enlarges somewhat the family of <em>f</em> for which <em>f</em>(<em>T</em>) can be defined using the above approach. However it is not quite satisfactory. For instance, it is a fact from matrix theory that every non-singular <em>T</em> has a logarithm <em>S</em> in the sense that <em>e<sup>S</sup></em> = <em>T</em>. It is desirable to have a functional calculus that allows one to define, for a non-singular <em>T</em>, ln(<em>T</em>) such that it coincides with <em>S</em>. This can not be done via power series, for example the logarithmic series</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ln</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>z</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>z</mi>
       <mo>-</mo>
       <mfrac>
        <msup>
         <mi>z</mi>
         <mn>2</mn>
        </msup>
        <mn>2</mn>
       </mfrac>
      </mrow>
      <mo>+</mo>
      <mfrac>
       <msup>
        <mi>z</mi>
        <mn>3</mn>
       </msup>
       <mn>3</mn>
      </mfrac>
     </mrow>
     <mo>-</mo>
     <mi mathvariant="normal">⋯</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ln></ln>
     <apply>
      <plus></plus>
      <ci>z</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <ci>z</ci>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <cn type="integer">2</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>z</ci>
        <cn type="integer">3</cn>
       </apply>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ln(z+1)=z-\frac{z^{2}}{2}+\frac{z^{3}}{3}-\cdots,
  </annotation>
 </semantics>
</math>

</p>

<p>converges only on the open unit disk. Substituting <em>T</em> for <em>z</em> in the series fails to give a well-defined expression for ln(<em>T</em> + <em>I</em>) for invertible <em>T + I</em> with ǁ<em>T</em>ǁ ≥ 1. Thus a more general functional calculus is needed.</p>
<h3 id="functional-calculus-and-the-spectrum">Functional calculus and the spectrum</h3>

<p>It is expected that a necessary condition for <em>f</em>(<em>T</em>) to make sense is <em>f</em> be defined on the <a href="spectrum_(functional_analysis)" title="wikilink">spectrum</a> of <em>T</em>. For example, the spectral theorem for normal matrices states every normal matrix is unitarily diagonalizable. There leads to a definition of <em>f</em>(<em>T</em>) when <em>T</em> is normal. One encounters difficulties if <em>f</em>(λ) is not defined for some eigenvalue λ of <em>T</em>.</p>

<p>Other indications also reinforce the idea that <em>f</em>(<em>T</em>) can be defined only if <em>f</em> is defined on the spectrum of <em>T</em>. If <em>T</em> is not invertible, then 0 is an eigenvalue. Since the natural logarithm is undefined at 0, one would expect that ln(<em>T</em>) can not be defined naturally. This is indeed the case. As another example, for</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>z</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>z</mi>
       <mo>-</mo>
       <mn>5</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <ci>z</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <minus></minus>
       <ci>z</ci>
       <cn type="integer">5</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(z)=\frac{1}{(z-2)(z-5)}
  </annotation>
 </semantics>
</math>

</p>

<p>the reasonable way of calculating <em>f</em>(<em>T</em>) would seem to be</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>T</mi>
        <mo>-</mo>
        <mrow>
         <mn>2</mn>
         <mi>I</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>T</mi>
        <mo>-</mo>
        <mrow>
         <mn>5</mn>
         <mi>I</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <ci>T</ci>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>I</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <ci>T</ci>
       <apply>
        <times></times>
        <cn type="integer">5</cn>
        <ci>I</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(T)=(T-2I)^{-1}(T-5I)^{-1}.\,
  </annotation>
 </semantics>
</math>

</p>

<p>However, this expression is not defined if the <a href="matrix_inverse" title="wikilink">inverses</a> on the right-hand side do not exist, that is, if either 2 or 5 are <a href="eigenvalue" title="wikilink">eigenvalues</a> of <em>T</em>.</p>

<p>For a given matrix <em>T</em>, the eigenvalues of <em>T</em> dictate to what extent <em>f</em>(<em>T</em>) can be defined; i.e., <em>f</em>(λ) must be defined for all eigenvalues λ of <em>T</em>. For a general bounded operator this condition translates to "<em>f</em> must be defined on the <a href="spectrum_(functional_analysis)" title="wikilink">spectrum</a> of <em>T</em>". This assumption turns out to be an enabling condition such that the functional calculus map, <em>f</em> → <em>f</em>(<em>T</em>), has certain desirable properties.</p>
<h2 id="functional-calculus-for-a-bounded-operator">Functional calculus for a bounded operator</h2>

<p> </p>

<p>Let <em>X</em> be a complex Banach space, and <em>L</em>(<em>X</em>) denote the family of bounded operators on <em>X</em>.</p>

<p>Recall the <a href="Cauchy_integral_formula" title="wikilink">Cauchy integral formula</a> from classical function theory. Let <em>f</em> : <strong>C</strong> → <strong>C</strong> be holomorphic on some <a href="open_set" title="wikilink">open</a> set <em>D</em> ⊂ <strong>C</strong>, and Γ be a <a href="rectifiable_curve" title="wikilink">rectifiable</a> <a href="Jordan_curve" title="wikilink">Jordan curve</a> in <em>D</em>, that is, a closed curve of finite length without self-intersections. Cauchy's integral formula states</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
      <mi>i</mi>
     </mrow>
    </mfrac>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Γ</mi>
     </msub>
     <mrow>
      <mpadded width="+1.7pt">
       <mfrac>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>ζ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <mi>ζ</mi>
         <mo>-</mo>
         <mi>z</mi>
        </mrow>
       </mfrac>
      </mpadded>
      <mi>d</mi>
      <mi>ζ</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>normal-Γ</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>ζ</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>ζ</ci>
         <ci>z</ci>
        </apply>
       </apply>
       <ci>d</ci>
       <ci>ζ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(z)=\frac{1}{2\pi i}\int\nolimits_{\Gamma}\frac{f(\zeta)}{\zeta-z}\,d\zeta
  </annotation>
 </semantics>
</math>

</p>

<p>for any <em>z</em> lying in the <em>inside</em> of Γ, i.e. the <a href="winding_number" title="wikilink">winding number</a> of Γ about <em>z</em> is 1.</p>

<p>The idea is to extend this formula to functions taking values in the Banach space <em>L</em>(<em>X</em>). Cauchy's integral formula suggests the following definition (purely formal, for now):</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
       <mi>i</mi>
      </mrow>
     </mfrac>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∫</mo>
       <mi mathvariant="normal">Γ</mi>
      </msub>
      <mrow>
       <mpadded width="+1.7pt">
        <mfrac>
         <mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>ζ</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mrow>
          <mi>ζ</mi>
          <mo>-</mo>
          <mi>T</mi>
         </mrow>
        </mfrac>
       </mpadded>
       <mi>d</mi>
       <mi>ζ</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>normal-Γ</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>ζ</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>ζ</ci>
         <ci>T</ci>
        </apply>
       </apply>
       <ci>d</ci>
       <ci>ζ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(T)=\frac{1}{2\pi i}\int_{\Gamma}\frac{f(\zeta)}{\zeta-T}\,d\zeta,
  </annotation>
 </semantics>
</math>

</p>

<p>where (ζ−<em>T</em>)<sup>−1</sup> is the <a href="Resolvent_formalism" title="wikilink">resolvent</a> of <em>T</em> at ζ.</p>

<p>Assuming this Banach space-valued integral is appropriately defined, this proposed functional calculus implies the following necessary conditions:</p>
<ol>
<li>As the scalar version of Cauchy's integral formula applies to holomorphic <em>f</em>, we anticipate that is also the case for the Banach space case, where there should be a suitable notion of holomorphy for functions taking values in the Banach space <em>L</em>(<em>X</em>).</li>
<li>As the resolvent mapping ζ → (ζ−<em>T</em>)<sup>−1</sup> is undefined on the spectrum of <em>T</em>, σ(<em>T</em>), the Jordan curve Γ should not intersect σ(<em>T</em>). Furthermore, the resolvent mapping is holomorphic on the complement of σ(<em>T</em>). So, to obtain a non-trivial functional calculus, Γ must enclose, at least part of, σ(<em>T</em>).</li>
<li>The functional calculus should be well-defined in the sense that <em>f</em>(<em>T</em>) has to be independent of Γ.</li>
</ol>

<p>The full definition of the functional calculus is as follows: For <em>T</em> ∈ <em>L</em>(<em>X</em>), define</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
       <mi>i</mi>
      </mrow>
     </mfrac>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∫</mo>
       <mi mathvariant="normal">Γ</mi>
      </msub>
      <mrow>
       <mpadded width="+1.7pt">
        <mfrac>
         <mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>ζ</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mrow>
          <mi>ζ</mi>
          <mo>-</mo>
          <mi>T</mi>
         </mrow>
        </mfrac>
       </mpadded>
       <mi>d</mi>
       <mi>ζ</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>normal-Γ</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>ζ</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>ζ</ci>
         <ci>T</ci>
        </apply>
       </apply>
       <ci>d</ci>
       <ci>ζ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(T)=\frac{1}{2\pi i}\int\nolimits_{\Gamma}\frac{f(\zeta)}{\zeta-T}\,d\zeta,
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>f</em> is a holomorphic function defined on an <a href="open_set" title="wikilink">open set</a> <em>D</em> ⊂ <strong>C</strong> which contains σ(<em>T</em>), and Γ = {γ<sub>1</sub>, ..., γ<sub><em>m</em></sub>} is a collection of Jordan curves in <em>D</em> such that σ(<em>T</em>) lies in the inside of Γ, and each γ<sub><em>i</em></sub> is oriented in the positive sense.</p>

<p>The open set <em>D</em> may vary with <em>f</em> and need not be connected, as shown by the figures on the right.</p>

<p>The following subsections make precise the notions invoked in the definition and show <em>f</em>(<em>T</em>) is indeed well defined under given assumptions.</p>
<h3 id="banach-space-valued-integral">Banach space-valued integral</h3>
<dl>
<dd><em>Cf. <a href="Bochner_integral" title="wikilink">Bochner integral</a></em>
</dd>
</dl>

<p>For a continuous function <em>g</em> defined in an open neighborhood of Γ and taking values in <em>L</em>(<em>X</em>), the contour integral ∫<sub>Γ</sub><em>g</em> is defined in the same way as for the scalar case. One can parametrize each γ<sub><em>i</em></sub> ∈ Γ by a real interval [<em>a</em>, <em>b</em>], and the integral is the limit of the <a href="Riemann_sums" title="wikilink">Riemann sums</a> obtained from ever-finer partitions of [<em>a</em>, <em>b</em>]. The Riemann sums converge in the <a href="operator_topology" title="wikilink">uniform operator topology</a>. We define</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Γ</mi>
     </msub>
     <mi>g</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mi>i</mi>
     </msub>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∫</mo>
       <msub>
        <mi>γ</mi>
        <mi>i</mi>
       </msub>
      </msub>
      <mi>g</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>normal-Γ</ci>
     </apply>
     <ci>g</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <ci>g</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{\Gamma}g=\sum\nolimits_{i}\int_{\gamma_{i}}g.
  </annotation>
 </semantics>
</math>

</p>

<p>In the definition of the functional calculus, <em>f</em> is assumed to be holomorphic in an open neighborhood of Γ. It will be shown below that the resolvent mapping is holomorphic on the resolvent set. Therefore the integral</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:12">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mn>2</mn>
     <mi>π</mi>
     <mi>i</mi>
    </mrow>
   </mfrac>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∫</mo>
     <mi mathvariant="normal">Γ</mi>
    </msub>
    <mrow>
     <mpadded width="+1.7pt">
      <mfrac>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>ζ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mi>ζ</mi>
        <mo>-</mo>
        <mi>T</mi>
       </mrow>
      </mfrac>
     </mpadded>
     <mi>d</mi>
     <mi>ζ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>π</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>normal-Γ</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>ζ</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>ζ</ci>
        <ci>T</ci>
       </apply>
      </apply>
      <ci>d</ci>
      <ci>ζ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2\pi i}\int_{\Gamma}\frac{f(\zeta)}{\zeta-T}\,d\zeta
  </annotation>
 </semantics>
</math>

</p>

<p>makes sense.</p>
<h3 id="the-resolvent-mapping">The resolvent mapping</h3>

<p>The mapping ζ → (ζ−<em>T</em>)<sup>−1</sup> is called the <strong>resolvent mapping</strong> of <em>T</em>. It is defined on the complement of σ(<em>T</em>), called the <strong>resolvent set</strong> of <em>T</em> and will be denoted by ρ(<em>T</em>).</p>

<p>Much of classical function theory depends on the properties of the integral</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:13">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
      <mi>i</mi>
     </mrow>
    </mfrac>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Γ</mi>
     </msub>
     <mfrac>
      <mrow>
       <mi>d</mi>
       <mi>ζ</mi>
      </mrow>
      <mrow>
       <mi>ζ</mi>
       <mo>-</mo>
       <mi>z</mi>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>π</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>normal-Γ</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>ζ</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>ζ</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2\pi i}\int_{\Gamma}\frac{d\zeta}{\zeta-z}.
  </annotation>
 </semantics>
</math>

</p>

<p>The holomorphic functional calculus is similar in that the resolvent mapping plays a crucial role in obtaining properties one requires from a nice functional calculus. This subsection outlines properties of the resolvent map that are essential in this context.</p>
<h4 id="the-1st-resolvent-formula">The 1st resolvent formula</h4>

<p>Direct calculation shows, for <em>z</em><sub>1</sub>, <em>z<sub>2</sub></em> ∈ ρ(<em>T</em>),</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>z</mi>
         <mn>1</mn>
        </msub>
        <mo>-</mo>
        <mi>T</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mo>-</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>z</mi>
         <mn>2</mn>
        </msub>
        <mo>-</mo>
        <mi>T</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>z</mi>
         <mn>1</mn>
        </msub>
        <mo>-</mo>
        <mi>T</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>z</mi>
        <mn>2</mn>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>z</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>z</mi>
         <mn>2</mn>
        </msub>
        <mo>-</mo>
        <mi>T</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>T</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>T</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>T</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>T</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (z_{1}-T)^{-1}-(z_{2}-T)^{-1}=(z_{1}-T)^{-1}(z_{2}-z_{1})(z_{2}-T)^{-1}.\,
  </annotation>
 </semantics>
</math>

</p>

<p>Therefore</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:15">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>z</mi>
         <mn>1</mn>
        </msub>
        <mo>-</mo>
        <mi>T</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>z</mi>
         <mn>2</mn>
        </msub>
        <mo>-</mo>
        <mi>T</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>z</mi>
          <mn>1</mn>
         </msub>
         <mo>-</mo>
         <mi>T</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo>-</mo>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>z</mi>
          <mn>2</mn>
         </msub>
         <mo>-</mo>
         <mi>T</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>z</mi>
        <mn>2</mn>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>z</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>T</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>T</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>T</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>T</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (z_{1}-T)^{-1}(z_{2}-T)^{-1}=\frac{(z_{1}-T)^{-1}-(z_{2}-T)^{-1}}{(z_{2}-z_{1}%
)}.
  </annotation>
 </semantics>
</math>

</p>

<p>This equation is called the <strong>first resolvent formula</strong>. The formula shows (<em>z</em><sub>1</sub>−<em>T</em>)<sup>−1</sup> and (<em>z</em><sub>2</sub>−<em>T</em>)<sup>−1</sup> commute, which hints at the fact that the image of the functional calculus will be a commutative algebra. Letting <em>z</em><sub>2</sub> → <em>z</em><sub>1</sub> shows the resolvent map is (complex-) differentiable at each <em>z</em><sub>1</sub> ∈ ρ(<em>T</em>); so the integral in the expression of functional calculus converges in <em>L</em>(<em>X</em>).</p>
<h4 id="analyticity">Analyticity</h4>

<p>Stronger statement than differentiability can be made regarding the resolvent map. The resolvent set ρ(<em>T</em>) is actually an open set on which the resolvent map is analytic. This property will be used in subsequent arguments for the functional calculus. To verify this claim, let <em>z</em><sub>1</sub> ∈ ρ(<em>T</em>) and notice the formal expression</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:16">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <msub>
      <mi>z</mi>
      <mn>2</mn>
     </msub>
     <mo>-</mo>
     <mi>T</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <msub>
       <mi>z</mi>
       <mn>1</mn>
      </msub>
      <mo>-</mo>
      <mi>T</mi>
     </mrow>
    </mfrac>
    <mo>⋅</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mfrac>
       <mrow>
        <msub>
         <mi>z</mi>
         <mn>1</mn>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>z</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mrow>
        <msub>
         <mi>z</mi>
         <mn>1</mn>
        </msub>
        <mo>-</mo>
        <mi>T</mi>
       </mrow>
      </mfrac>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>T</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <divide></divide>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>T</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{z_{2}-T}=\frac{1}{z_{1}-T}\cdot\frac{1}{1-\frac{z_{1}-z_{2}}{z_{1}-T}}
  </annotation>
 </semantics>
</math>

</p>

<p>suggests we consider</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:17">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>z</mi>
       <mn>1</mn>
      </msub>
      <mo>-</mo>
      <mi>T</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>n</mi>
      <mo>≥</mo>
      <mn>0</mn>
     </mrow>
    </munder>
    <msup>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>z</mi>
          <mn>1</mn>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>z</mi>
          <mn>2</mn>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msub>
           <mi>z</mi>
           <mn>1</mn>
          </msub>
          <mo>-</mo>
          <mi>T</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>T</ci>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <geq></geq>
       <ci>n</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>T</ci>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (z_{1}-T)^{-1}\sum_{n\geq 0}\left((z_{1}-z_{2})(z_{1}-T)^{-1}\right)^{n}
  </annotation>
 </semantics>
</math>

</p>

<p>for (<em>z</em><sub>2</sub>−<em>T</em>)<sup>−1</sup>. The above series converges in <em>L</em>(<em>X</em>), which implies the existence of (<em>z</em><sub>2</sub>−<em>T</em>)<sup>−1</sup>, if</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <msub>
       <mi>z</mi>
       <mn>1</mn>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>z</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo><</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mo>∥</mo>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>z</mi>
          <mn>1</mn>
         </msub>
         <mo>-</mo>
         <mi>T</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo>∥</mo>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>T</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |z_{1}-z_{2}|<\frac{1}{\left\|(z_{1}-T)^{-1}\right\|}.
  </annotation>
 </semantics>
</math>

</p>

<p>Therefore the resolvent set ρ(<em>T</em>) is open and the power series expression on an open disk centered at <em>z</em><sub>1</sub> ∈ ρ(<em>T</em>) shows the resolvent map is analytic on ρ(<em>T</em>).</p>
<h4 id="neumann-series">Neumann series</h4>

<p>Another expression for (<em>z</em>−<em>T</em>)<sup>−1</sup> will also be useful. The formal expression</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:19">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi>z</mi>
     <mo>-</mo>
     <mi>T</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>z</mi>
    </mfrac>
    <mo>⋅</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mfrac>
       <mi>T</mi>
       <mi>z</mi>
      </mfrac>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <minus></minus>
      <ci>z</ci>
      <ci>T</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>z</ci>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <divide></divide>
        <ci>T</ci>
        <ci>z</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{z-T}=\frac{1}{z}\cdot\frac{1}{1-\frac{T}{z}}
  </annotation>
 </semantics>
</math>

</p>

<p>leads one to consider</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:20">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>z</mi>
    </mfrac>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>≥</mo>
       <mn>0</mn>
      </mrow>
     </munder>
     <msup>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mi>T</mi>
        <mi>z</mi>
       </mfrac>
       <mo>)</mo>
      </mrow>
      <mi>n</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>z</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <geq></geq>
       <ci>n</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <divide></divide>
       <ci>T</ci>
       <ci>z</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{z}\sum_{n\geq 0}\left(\frac{T}{z}\right)^{n}.
  </annotation>
 </semantics>
</math>

</p>

<p>This series, the <em><a href="Neumann_series" title="wikilink">Neumann series</a></em>, converges to (<em>z</em>−<em>T</em>)<sup>−1</sup> if</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>∥</mo>
      <mfrac>
       <mi>T</mi>
       <mi>z</mi>
      </mfrac>
      <mo>∥</mo>
     </mrow>
     <mo><</mo>
     <mn>1</mn>
    </mrow>
    <mo rspace="5.3pt">,</mo>
    <mrow>
     <mrow>
      <mpadded width="+2.8pt">
       <mtext>i.e.</mtext>
      </mpadded>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>z</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
     <mo>></mo>
     <mrow>
      <mo>∥</mo>
      <mi>T</mi>
      <mo>∥</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <lt></lt>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <divide></divide>
       <ci>T</ci>
       <ci>z</ci>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <gt></gt>
     <apply>
      <times></times>
      <mtext>i.e.</mtext>
      <apply>
       <abs></abs>
       <ci>z</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\|\frac{T}{z}\right\|<1,\;\text{i.e.}\;|z|>\|T\|.
  </annotation>
 </semantics>
</math>

</p>
<h4 id="compactness-of-σt">Compactness of σ(<em>T</em>)</h4>

<p>From the last two properties of the resolvent we can deduce that the spectrum σ(<em>T</em>) of a bounded operator <em>T</em> is a compact subset of <strong>C</strong>. Therefore for any open set <em>D</em> such that σ(<em>T</em>) ⊂ <em>D</em>, there exists a positively oriented and smooth system of Jordan curves Γ = {γ<sub>1</sub>, ..., γ<sub><em>m</em></sub>} such that σ(<em>T</em>) is in the inside of <em>Γ</em> and the complement of <em>D</em> is contained in the outside of Γ. Hence, for the definition of the functional calculus, indeed a suitable family of Jordan curves can be found for each <em>f</em> that is holomorphic on some <em>D</em>.</p>
<h3 id="well-definedness">Well-definedness</h3>

<p>The previous discussion has shown that the integral makes sense, i.e. a suitable collection Γ of Jordan curves does exist for each <em>f</em> and the integral does converge in the appropriate sense. What has not been shown is that the definition of the functional calculus is unambiguous, i.e. does not depend on the choice of Γ. This issue we now try to resolve.</p>
<h4 id="a-preliminary-fact">A preliminary fact</h4>

<p>For a collection of Jordan curves Γ = {γ<sub>1</sub>, ..., γ<sub><em>m</em></sub>} and a point <em>a</em> ∈ <strong>C</strong>, the winding number of Γ with respect to <em>a</em> is the sum of the winding numbers of its elements. If we define:</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi mathvariant="normal">Γ</mi>
      <mo>,</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mi>i</mi>
     </msub>
     <mrow>
      <mi>n</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>γ</mi>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>n</ci>
     <interval closure="open">
      <ci>normal-Γ</ci>
      <ci>a</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <ci>i</ci>
       </apply>
       <ci>a</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n(\Gamma,a)=\sum\nolimits_{i}n(\gamma_{i},a),
  </annotation>
 </semantics>
</math>

</p>

<p>the following theorem is by Cauchy:</p>
<blockquote>

<p><strong>Theorem.</strong> Let <em>G</em> ⊂ <strong>C</strong> be an open set and Γ ⊂ <em>G</em>. If <em>g</em> : <strong>C</strong> → <strong>C</strong> be holomorphic on <em>G</em>, and for all <em>a</em> in the complement of <em>G</em>, <em>n</em>(Γ, <em>a</em>) = 0, then the contour integral of <em>g</em> on Γ is zero.</p>
</blockquote>

<p>We will need the vector-valued analog of this result when <em>g</em> takes values in <em>L</em>(<em>X</em>). To this end, let <em>g</em> : <em>G</em> → <em>L</em>(<em>X</em>) be holomorphic, with the same assumptions on Γ. The idea is use the <a href="dual_space" title="wikilink">dual space</a> <em>L</em>(<em>X</em>)* of <em>L</em>(<em>X</em>), and pass to Cauchy's theorem for the scalar case.</p>

<p>Consider the integral</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Γ</mi>
     </msub>
     <mi>g</mi>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>normal-Γ</ci>
     </apply>
     <ci>g</ci>
    </apply>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{\Gamma}g\in L(X),
  </annotation>
 </semantics>
</math>

</p>

<p>if we can show that all φ ∈ <em>L</em>(<em>X</em>)* vanish on this integral then the integral itself has to be zero. Since φ is bounded and the integral converges in norm, we have:</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ϕ</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msub>
        <mo largeop="true" symmetric="true">∫</mo>
        <mi mathvariant="normal">Γ</mi>
       </msub>
       <mi>g</mi>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Γ</mi>
     </msub>
     <mrow>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>g</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>normal-Γ</ci>
      </apply>
      <ci>g</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>normal-Γ</ci>
     </apply>
     <apply>
      <times></times>
      <ci>ϕ</ci>
      <ci>g</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi\left(\int_{\Gamma}g\right)=\int_{\Gamma}\phi(g).
  </annotation>
 </semantics>
</math>

</p>

<p>But <em>g</em> is holomorphic, hence the composition φ(<em>g</em>): <em>G</em> ⊂ <strong>C</strong> → <strong>C</strong> is holomorphic and therefore by Cauchy's theorem</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:25">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∫</mo>
     <mi mathvariant="normal">Γ</mi>
    </msub>
    <mrow>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>g</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>normal-Γ</ci>
     </apply>
     <apply>
      <times></times>
      <ci>ϕ</ci>
      <ci>g</ci>
     </apply>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{\Gamma}\phi(g)=0.
  </annotation>
 </semantics>
</math>

</p>
<h4 id="main-argument">Main argument</h4>

<p>The well-definedness of functional calculus now follows as an easy consequence. Let <em>D</em> be an open set containing σ(<em>T</em>). Suppose Γ = {γ<sub><em>i</em></sub>} and Ω = {ω<sub><em>j</em></sub>} be two (finite) collections of Jordan curves satisfying the assumption given for the functional calculus. We wish to show</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Γ</mi>
     </msub>
     <mrow>
      <mpadded width="+1.7pt">
       <mfrac>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>ζ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <mi>ζ</mi>
         <mo>-</mo>
         <mi>T</mi>
        </mrow>
       </mfrac>
      </mpadded>
      <mi>d</mi>
      <mi>ζ</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Ω</mi>
     </msub>
     <mrow>
      <mpadded width="+1.7pt">
       <mfrac>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>ζ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <mi>ζ</mi>
         <mo>-</mo>
         <mi>T</mi>
        </mrow>
       </mfrac>
      </mpadded>
      <mi>d</mi>
      <mi>ζ</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>normal-Γ</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>ζ</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>ζ</ci>
        <ci>T</ci>
       </apply>
      </apply>
      <ci>d</ci>
      <ci>ζ</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>normal-Ω</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>ζ</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>ζ</ci>
        <ci>T</ci>
       </apply>
      </apply>
      <ci>d</ci>
      <ci>ζ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{\Gamma}\frac{f(\zeta)}{\zeta-T}\,d\zeta=\int_{\Omega}\frac{f(\zeta)}{%
\zeta-T}\,d\zeta.
  </annotation>
 </semantics>
</math>

</p>

<p>Let Ω′ be obtained from Ω by reversing the orientation of each ω<sub><em>j</em></sub>, then</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:27">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Ω</mi>
     </msub>
     <mrow>
      <mpadded width="+1.7pt">
       <mfrac>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>ζ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <mi>ζ</mi>
         <mo>-</mo>
         <mi>T</mi>
        </mrow>
       </mfrac>
      </mpadded>
      <mi>d</mi>
      <mi>ζ</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∫</mo>
       <msup>
        <mi mathvariant="normal">Ω</mi>
        <mo>′</mo>
       </msup>
      </msub>
      <mrow>
       <mpadded width="+1.7pt">
        <mfrac>
         <mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>ζ</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mrow>
          <mi>ζ</mi>
          <mo>-</mo>
          <mi>T</mi>
         </mrow>
        </mfrac>
       </mpadded>
       <mi>d</mi>
       <mi>ζ</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>normal-Ω</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>ζ</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>ζ</ci>
        <ci>T</ci>
       </apply>
      </apply>
      <ci>d</ci>
      <ci>ζ</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-Ω</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>ζ</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>ζ</ci>
         <ci>T</ci>
        </apply>
       </apply>
       <ci>d</ci>
       <ci>ζ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{\Omega}\frac{f(\zeta)}{\zeta-T}\,d\zeta=-\int_{\Omega^{\prime}}\frac{f(%
\zeta)}{\zeta-T}\,d\zeta.
  </annotation>
 </semantics>
</math>

</p>

<p>Consider the union of the two collections Γ ∪ Ω′. Both Γ ∪ Ω′ and σ(<em>T</em>) are compact. So there is some open set <em>U</em> containing Γ ∪ Ω′ such that σ(<em>T</em>) lies in the complement of <em>U</em>. Any <em>a</em> in the complement of <em>U</em> has winding number <em>n</em>(Γ ∪ Ω′, <em>a</em>) = 0 and the function</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:28">
 <semantics>
  <mrow>
   <mi>ζ</mi>
   <mo>→</mo>
   <mfrac>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ζ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>ζ</mi>
     <mo>-</mo>
     <mi>T</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>ζ</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>ζ</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>ζ</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \zeta\rightarrow\frac{f(\zeta)}{\zeta-T}
  </annotation>
 </semantics>
</math>

</p>

<p>is holomorphic on <em>U</em>. So the vector-valued version of Cauchy's theorem gives</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:29">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mi mathvariant="normal">Γ</mi>
      <mo>∪</mo>
      <msup>
       <mi mathvariant="normal">Ω</mi>
       <mo>′</mo>
      </msup>
     </mrow>
    </msub>
    <mrow>
     <mpadded width="+1.7pt">
      <mfrac>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>ζ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mi>ζ</mi>
        <mo>-</mo>
        <mi>T</mi>
       </mrow>
      </mfrac>
     </mpadded>
     <mi>d</mi>
     <mi>ζ</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <union></union>
       <ci>normal-Γ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-Ω</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>ζ</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>ζ</ci>
        <ci>T</ci>
       </apply>
      </apply>
      <ci>d</ci>
      <ci>ζ</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{\Gamma\cup\Omega^{\prime}}\frac{f(\zeta)}{\zeta-T}\,d\zeta=0
  </annotation>
 </semantics>
</math>

</p>

<p>i.e.</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Γ</mi>
     </msub>
     <mrow>
      <mpadded width="+1.7pt">
       <mfrac>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>ζ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <mi>ζ</mi>
         <mo>-</mo>
         <mi>T</mi>
        </mrow>
       </mfrac>
      </mpadded>
      <mi>d</mi>
      <mi>ζ</mi>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <msup>
       <mi mathvariant="normal">Ω</mi>
       <mo>′</mo>
      </msup>
     </msub>
     <mrow>
      <mpadded width="+1.7pt">
       <mfrac>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>ζ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <mi>ζ</mi>
         <mo>-</mo>
         <mi>T</mi>
        </mrow>
       </mfrac>
      </mpadded>
      <mi>d</mi>
      <mi>ζ</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Γ</mi>
     </msub>
     <mrow>
      <mpadded width="+1.7pt">
       <mfrac>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>ζ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <mi>ζ</mi>
         <mo>-</mo>
         <mi>T</mi>
        </mrow>
       </mfrac>
      </mpadded>
      <mi>d</mi>
      <mi>ζ</mi>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Ω</mi>
     </msub>
     <mrow>
      <mpadded width="+1.7pt">
       <mfrac>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>ζ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <mi>ζ</mi>
         <mo>-</mo>
         <mi>T</mi>
        </mrow>
       </mfrac>
      </mpadded>
      <mi>d</mi>
      <mi>ζ</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <ci>normal-Γ</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <ci>f</ci>
          <ci>ζ</ci>
         </apply>
         <apply>
          <minus></minus>
          <ci>ζ</ci>
          <ci>T</ci>
         </apply>
        </apply>
        <ci>d</ci>
        <ci>ζ</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-Ω</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <ci>f</ci>
          <ci>ζ</ci>
         </apply>
         <apply>
          <minus></minus>
          <ci>ζ</ci>
          <ci>T</ci>
         </apply>
        </apply>
        <ci>d</ci>
        <ci>ζ</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <ci>normal-Γ</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <ci>f</ci>
          <ci>ζ</ci>
         </apply>
         <apply>
          <minus></minus>
          <ci>ζ</ci>
          <ci>T</ci>
         </apply>
        </apply>
        <ci>d</ci>
        <ci>ζ</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <ci>normal-Ω</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <ci>f</ci>
          <ci>ζ</ci>
         </apply>
         <apply>
          <minus></minus>
          <ci>ζ</ci>
          <ci>T</ci>
         </apply>
        </apply>
        <ci>d</ci>
        <ci>ζ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{\Gamma}\frac{f(\zeta)}{\zeta-T}\,d\zeta+\int_{\Omega^{\prime}}\frac{f(%
\zeta)}{\zeta-T}\,d\zeta=\int_{\Gamma}\frac{f(\zeta)}{\zeta-T}\,d\zeta-\int_{%
\Omega}\frac{f(\zeta)}{\zeta-T}\,d\zeta=0.
  </annotation>
 </semantics>
</math>

</p>

<p>Hence the functional calculus is well-defined.</p>

<p>Consequently, if <em>f</em><sub>1</sub> and <em>f</em><sub>2</sub> are two holomorphic functions defined on corresponding neighborhoods <em>D</em><sub>1</sub> and <em>D</em><sub>2</sub> of σ(<em>T</em>) and they are equal on an open set containing σ(<em>T</em>), then <em>f</em><sub>1</sub>(<em>T</em>) = <em>f</em><sub>2</sub>(<em>T</em>). Moreover, even though the <em>D</em><sub>1</sub> may not be <em>D</em><sub>2</sub>, the operator (<em>f</em><sub>1</sub> + <em>f</em><sub>2</sub>) (<em>T</em>) is well-defined. Same holds for the definition of (<em>f</em><sub>1</sub>·<em>f</em><sub>2</sub>)(<em>T</em>).</p>
<h3 id="on-the-assumption-that-f-be-holomorphic-over-an-open-neighborhood-of-σt">On the assumption that <em>f</em> be holomorphic over an open neighborhood of σ(<em>T</em>)</h3>

<p>It should perhaps be noted that so far the full strength of this assumption has not been utilized. For convergence of the integral, only continuity was used. For well-definedness, we only needed <em>f</em> be holomorphic on some open set <em>U</em> containing the contours Γ ∪ Ω′ but not σ(<em>T</em>). The assumption will be applied in its entirety for showing the homomorphism property of the functional calculus.</p>
<h2 id="properties">Properties</h2>
<h3 id="polynomial-case">Polynomial case</h3>

<p>The linearity of the map <em>f</em> ↦ <em>f</em>(<em>T</em>) follows from the convergence of the integral and that linear operations on a Banach space are continuous.</p>

<p>We recover the polynomial functional calculus when <em>f</em>(<em>z</em>) = ∑<sub>0 ≤ <em>i</em> ≤ <em>m</em></sub> <em>a<sub>i</sub> z<sup>i</sup></em> is a polynomial. To prove this, it is sufficient to show, for <em>k</em> ≥ 0 and <em>f</em>(<em>z</em>) = <em>z<sup>k</sup></em>, it is true that <em>f</em>(<em>T</em>) = <em>T<sup>k</sup></em>, i.e.</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:31">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
      <mi>i</mi>
     </mrow>
    </mfrac>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Γ</mi>
     </msub>
     <mrow>
      <mfrac>
       <msup>
        <mi>ζ</mi>
        <mi>k</mi>
       </msup>
       <mrow>
        <mi>ζ</mi>
        <mo>-</mo>
        <mi>T</mi>
       </mrow>
      </mfrac>
      <mi>d</mi>
      <mi>ζ</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>T</mi>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>normal-Γ</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ζ</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>ζ</ci>
         <ci>T</ci>
        </apply>
       </apply>
       <ci>d</ci>
       <ci>ζ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>T</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2\pi i}\int_{\Gamma}\frac{\zeta^{k}}{\zeta-T}d\zeta=T^{k}
  </annotation>
 </semantics>
</math>

</p>

<p>for any suitable Γ enclosing σ(<em>T</em>). Choose <em>Γ</em> to be a circle of radius greater than the operator norm of <em>T</em>. As stated above, on such Γ, the resolvent map admits a power series representation</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:32">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>z</mi>
       <mo>-</mo>
       <mi>T</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>z</mi>
     </mfrac>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>n</mi>
        <mo>≥</mo>
        <mn>0</mn>
       </mrow>
      </munder>
      <msup>
       <mrow>
        <mo>(</mo>
        <mfrac>
         <mi>T</mi>
         <mi>z</mi>
        </mfrac>
        <mo>)</mo>
       </mrow>
       <mi>n</mi>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <minus></minus>
      <ci>z</ci>
      <ci>T</ci>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>z</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <geq></geq>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <divide></divide>
        <ci>T</ci>
        <ci>z</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (z-T)^{-1}=\frac{1}{z}\sum_{n\geq 0}\left(\frac{T}{z}\right)^{n}.
  </annotation>
 </semantics>
</math>

</p>

<p>Substituting gives</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:33">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
      <mi>i</mi>
     </mrow>
    </mfrac>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Γ</mi>
     </msub>
     <mrow>
      <mrow>
       <mo>(</mo>
       <mrow>
        <munder>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>n</mi>
          <mo>≥</mo>
          <mn>0</mn>
         </mrow>
        </munder>
        <mfrac>
         <msup>
          <mi>T</mi>
          <mi>n</mi>
         </msup>
         <msup>
          <mi>ζ</mi>
          <mrow>
           <mrow>
            <mi>n</mi>
            <mo>+</mo>
            <mn>1</mn>
           </mrow>
           <mo>-</mo>
           <mi>k</mi>
          </mrow>
         </msup>
        </mfrac>
       </mrow>
       <mo>)</mo>
      </mrow>
      <mi>d</mi>
      <mi>ζ</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>normal-Γ</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <geq></geq>
          <ci>n</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>T</ci>
          <ci>n</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>ζ</ci>
          <apply>
           <minus></minus>
           <apply>
            <plus></plus>
            <ci>n</ci>
            <cn type="integer">1</cn>
           </apply>
           <ci>k</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <ci>d</ci>
       <ci>ζ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(T)=\frac{1}{2\pi i}\int_{\Gamma}\left(\sum_{n\geq 0}\frac{T^{n}}{\zeta^{n+1-%
k}}\right)d\zeta
  </annotation>
 </semantics>
</math>

</p>

<p>which is</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:34">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>≥</mo>
       <mn>0</mn>
      </mrow>
     </munder>
     <mrow>
      <mrow>
       <msup>
        <mi>T</mi>
        <mi>n</mi>
       </msup>
       <mo>⋅</mo>
       <mfrac>
        <mn>1</mn>
        <mrow>
         <mn>2</mn>
         <mi>π</mi>
         <mi>i</mi>
        </mrow>
       </mfrac>
      </mrow>
      <mrow>
       <mo>(</mo>
       <mrow>
        <msub>
         <mo largeop="true" symmetric="true">∫</mo>
         <mi mathvariant="normal">Γ</mi>
        </msub>
        <mfrac>
         <mrow>
          <mi>d</mi>
          <mi>ζ</mi>
         </mrow>
         <msup>
          <mi>ζ</mi>
          <mrow>
           <mrow>
            <mi>n</mi>
            <mo>+</mo>
            <mn>1</mn>
           </mrow>
           <mo>-</mo>
           <mi>k</mi>
          </mrow>
         </msup>
        </mfrac>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>n</mi>
       <mo>≥</mo>
       <mn>0</mn>
      </mrow>
     </munder>
     <mrow>
      <msup>
       <mi>T</mi>
       <mi>n</mi>
      </msup>
      <mo>⋅</mo>
      <msub>
       <mi>δ</mi>
       <mrow>
        <mi>n</mi>
        <mi>k</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msup>
     <mi>T</mi>
     <mi>k</mi>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <geq></geq>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>T</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>π</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <int></int>
         <ci>normal-Γ</ci>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <ci>d</ci>
          <ci>ζ</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>ζ</ci>
          <apply>
           <minus></minus>
           <apply>
            <plus></plus>
            <ci>n</ci>
            <cn type="integer">1</cn>
           </apply>
           <ci>k</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <geq></geq>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>T</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>δ</ci>
        <apply>
         <times></times>
         <ci>n</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>T</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{n\geq 0}T^{n}\cdot\frac{1}{2\pi i}\left(\int_{\Gamma}\frac{d\zeta}{\zeta%
^{n+1-k}}\right)=\sum_{n\geq 0}T^{n}\cdot\delta_{nk}=T^{k}.
  </annotation>
 </semantics>
</math>

</p>

<p>The δ is the Kronecker delta symbol.</p>
<h3 id="the-homomorphism-property">The homomorphism property</h3>

<p>For any <em>f</em><sub>1</sub> and <em>f</em><sub>2</sub> satisfying the appropriate assumptions, the homomorphism property states</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:35">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>f</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>f</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>f</mi>
        <mn>1</mn>
       </msub>
       <mo>⋅</mo>
       <msub>
        <mi>f</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>T</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>T</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{1}(T)f_{2}(T)=(f_{1}\cdot f_{2})(T).\,
  </annotation>
 </semantics>
</math>

</p>

<p>We sketch an argument which invokes the first resolvent formula and the assumptions placed on <em>f</em>. First we choose the Jordan curves such that Γ<sub>1</sub> lies in the <em>inside</em> of Γ<sub>2</sub>. The reason for this will become clear below. Start by calculating directly</p>

<p>

<math display="inline" id="Holomorphic_functional_calculus:36">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <msub>
    <mi>f</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>T</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle f_{1}(T)f_{2}(T)
  </annotation>
 </semantics>
</math>


</p>

<p>The last line follows from the fact that ω ∈ Γ<sub>2</sub> lies outside of Γ<sub>1</sub> and <em>f</em><sub>1</sub> is holomorphic on some open neighborhood of σ(<em>T</em>) and therefore the second term vanishes. Therefore we have:</p>

<p>

<math display="inline" id="Holomorphic_functional_calculus:37">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <msub>
    <mi>f</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>T</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle f_{1}(T)f_{2}(T)
  </annotation>
 </semantics>
</math>


</p>
<h3 id="continuity-with-respect-to-compact-convergence">Continuity with respect to compact convergence</h3>

<p>Let <em>G</em> ⊂ <strong>C</strong> be open with σ(<em>T</em>) ⊂ <em>G</em>. Suppose a sequence {<em>f<sub>k</sub></em>} of holomorphic functions on <em>G</em> converges uniformly on compact subsets of <em>G</em> (this is sometimes called <em>compact convergence</em>). Then {<em>f<sub>k</sub></em>(<em>T</em>)} is convergent in <em>L</em>(<em>X</em>):</p>

<p>Assume for simplicity that Γ consists of only one Jordan curve. We estimate</p>

<p>

<math display="inline" id="Holomorphic_functional_calculus:38">
 <semantics>
  <mrow>
   <mo>∥</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>l</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>∥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">norm</csymbol>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>k</ci>
      </apply>
      <ci>T</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>l</ci>
      </apply>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\left\|f_{k}(T)-f_{l}(T)\right\|
  </annotation>
 </semantics>
</math>


</p>

<p>By combining the uniform convergence assumption and various continuity considerations, we see that the above tends to 0 as <em>k</em>, <em>l</em> → ∞. So {<em>f<sub>k</sub></em>(<em>T</em>)} is Cauchy, therefore convergent.</p>
<h3 id="uniqueness">Uniqueness</h3>

<p>To summarize, we have shown the holomorphic functional calculus, <em>f</em> → <em>f</em>(<em>T</em>), has the following properties:</p>
<ol>
<li>It extends the polynomial functional calculus.</li>
<li>It is an algebra homomorphism from the algebra of holomorphic functions defined on a neighborhood of σ(<em>T</em>) to <em>L</em>(<em>X</em>)</li>
<li>It preserves uniform convergence on compact sets.</li>
</ol>

<p>It can be proved that a calculus satisfying the above properties is unique.</p>

<p>We note that, everything discussed so far holds verbatim if the family of bounded operators <em>L</em>(<em>X</em>) is replaced by a <a href="Banach_algebra" title="wikilink">Banach algebra</a> <em>A</em>. The functional calculus can be defined in exactly the same way for an element in <em>A</em>.</p>
<h2 id="spectral-considerations">Spectral considerations</h2>

<p>The above demonstrates the intimate relationship between the holomorphic functional calculus of a given <em>T</em> ∈ <em>L</em>(<em>X</em>) and σ(<em>T</em>). This is true in general. Under more restrictive assumptions, the spectral theorem for bounded normal operators (see below) can be reformulated in terms of a functional calculus. This section sketches some results in this direction.</p>
<h3 id="spectral-mapping-theorem">Spectral mapping theorem</h3>

<p>It is known that the <strong>spectral mapping theorem</strong> holds for the polynomial functional calculus: for any polynomial <em>p</em>, σ(<em>p</em>(<em>T</em>)) = <em>p</em>(σ(<em>T</em>)). This can be extended to the holomorphic calculus. To show <em>f</em>(σ(<em>T</em>)) ⊂ σ(<em>f</em>(<em>T</em>)), let μ be any complex number. By a result from complex analysis, there exists a function <em>g</em> holomorphic on a neighborhood of σ(<em>T</em>) such that</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:39">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>μ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>z</mi>
       <mo>-</mo>
       <mi>μ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>μ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>z</ci>
      <ci>μ</ci>
     </apply>
     <ci>g</ci>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(z)-f(\mu)=(z-\mu)g(z).\,
  </annotation>
 </semantics>
</math>

</p>

<p>According to the homomorphism property, <em>f</em>(<em>T</em>)−<em>f</em>(μ) = (<em>T</em>−μ)<em>g</em>(T). Therefore μ ∈ σ(<em>T</em>) implies <em>f</em>(μ) ∈ σ(<em>f</em>(<em>T</em>)).</p>

<p>For the other inclusion, if μ is not in <em>f</em>(σ(<em>T</em>)), then the functional calculus is applicable to</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:40">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mi>μ</mi>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>z</ci>
      </apply>
      <ci>μ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(z)=\frac{1}{f(z)-\mu}.
  </annotation>
 </semantics>
</math>

</p>

<p>So <em>g</em>(<em>T</em>)(<em>f</em>(<em>T</em>)−μ) = <em>I</em>. Therefore μ does not lie in <em>σ</em>(<em>f</em>(<em>T</em>)).</p>
<h3 id="spectral-projections">Spectral projections</h3>

<p>The underlying idea is as follows. Suppose that <em>K</em> is a subset of σ(<em>T</em>) and <em>U</em>,<em>V</em> are disjoint neighbourhoods of <em>K</em> and σ(<em>T</em>) \ <em>K</em> respectively. Define <em>e</em>(<em>z</em>) = 1 if <em>z</em> ∈ <em>U</em> and <em>e</em>(<em>z</em>) = 0 if <em>z</em> ∈ <em>V</em>. Then <em>e</em> is a holomorphic function with [<em>e</em>(<em>z</em>)]<sup>2</sup> = <em>e</em>(<em>z</em>) and so, for a suitable contour Γ which lies in <em>U</em> ∪ <em>V</em> and which encloses σ(<em>T</em>), the linear operator</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
      <mi>i</mi>
     </mrow>
    </mfrac>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Γ</mi>
     </msub>
     <mrow>
      <mpadded width="+1.7pt">
       <mfrac>
        <mrow>
         <mi>e</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>z</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <mi>z</mi>
         <mo>-</mo>
         <mi>T</mi>
        </mrow>
       </mfrac>
      </mpadded>
      <mi>d</mi>
      <mi>z</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>normal-Γ</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>e</ci>
         <ci>z</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>z</ci>
         <ci>T</ci>
        </apply>
       </apply>
       <ci>d</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e(T)=\frac{1}{2\pi i}\int_{\Gamma}\frac{e(z)}{z-T}\,dz
  </annotation>
 </semantics>
</math>

</p>

<p>will be a bounded projection that commutes with <em>T</em> and provides a great deal of useful information.</p>

<p>It transpires that this scenario is possible if and only if <em>K</em> is both open and closed in the <a href="subspace_topology" title="wikilink">subspace topology</a> on σ(<em>T</em>). Moreover the set <em>V</em> can be safely ignored since <em>e</em> is zero on it and therefore makes no contribution to the integral. The projection <em>e</em>(<em>T</em>) is called the <strong>spectral projection of <em>T</em> at <em>K</em></strong> and is denoted by <em>P</em>(<em>K</em>;<em>T</em>). Thus every subset <em>K</em> of σ(<em>T</em>) that is both open and closed in the subspace topology has an associated spectral projection given by</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:42">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>K</mi>
     <mo>;</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
      <mi>i</mi>
     </mrow>
    </mfrac>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi mathvariant="normal">Γ</mi>
     </msub>
     <mfrac>
      <mrow>
       <mi>d</mi>
       <mi>z</mi>
      </mrow>
      <mrow>
       <mi>z</mi>
       <mo>-</mo>
       <mi>T</mi>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <list>
      <ci>K</ci>
      <ci>T</ci>
     </list>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>normal-Γ</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>z</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>z</ci>
        <ci>T</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(K;T)=\frac{1}{2\pi i}\int\nolimits_{\Gamma}\frac{dz}{z-T}
  </annotation>
 </semantics>
</math>

</p>

<p>where Γ is a contour that encloses <em>K</em> but no other points of σ(<em>T</em>).</p>

<p>Since <em>P</em> = <em>P</em>(<em>K</em>;<em>T</em>) is bounded and commutes with <em>T</em> it enables <em>T</em> to be expressed in the form <em>U</em> ⊕ <em>V</em> where <em>U</em> = <em>T</em>|<sub><em>PX</em></sub> and <em>V</em> = <em>T</em>|<sub>(1−<em>P</em>)<em>X</em></sub>. Both <em>PX</em> and (1−<em>P</em>)<em>X</em> are invariant subspaces of <em>T</em> moreover σ(<em>U</em>) = <em>K</em> and σ(<em>V</em>) = σ(<em>T</em>) \ <em>K</em>. A key property is mutual orthogonality. If <em>L</em> is another open and closed set in the subspace topology on σ(<em>T</em>) then <em>P</em>(<em>K</em>;<em>T</em>)<em>P</em>(<em>L</em>;<em>T</em>) = <em>P</em>(<em>L</em>;<em>T</em>)<em>P</em>(<em>K</em>;<em>T</em>) = <em>P</em>(<em>K</em> ∩ <em>L</em>;<em>T</em>) which is zero whenever <em>K</em> and <em>L</em> are disjoint.</p>

<p>Spectral projections have numerous applications. Any isolated point of σ(<em>T</em>) is both open and closed in the subspace topology and therefore has an associated spectral projection. When <em>X</em> has finite dimension σ(<em>T</em>) consists of isolated points and the resultant spectral projections lead to a variant of <a href="Jordan_normal_form" title="wikilink">Jordan normal form</a> wherein all the Jordan blocks corresponding to the same eigenvalue are consolidated. In other words there is precisely one block per distinct eigenvalue. The next section considers this decomposition in more detail.</p>

<p>Sometimes spectral projections inherit properties from their parent operators. For example if <em>T</em> is a positive matrix with spectral radius <em>r</em> then the <a href="Perron–Frobenius_theorem" title="wikilink">Perron–Frobenius theorem</a> asserts that <em>r</em> ∈ σ(<em>T</em>). The associated spectral projection <em>P</em> = <em>P</em>(<em>r</em>;<em>T</em>) is also positive and by mutual orthogonality no other spectral projection can have a positive row or column. In fact <em>TP</em> = <em>rP</em> and (<em>T</em>/<em>r</em>)<sup><em>n</em></sup> → <em>P</em> as <em>n</em> → ∞ so this projection <em>P</em> (which is called the Perron projection) approximates (<em>T</em>/<em>r</em>)<sup><em>n</em></sup> as <em>n</em> increases, and each of its columns is an eigenvector of <em>T</em>.</p>

<p>More generally if <em>T</em> is a compact operator then all non-zero points in σ(<em>T</em>) are isolated and so any finite subset of them can be used to decompose <em>T</em>. The associated spectral projection always has finite rank. Those operators in <em>L</em>(<em>X</em>) with similar spectral characteristics are known as <a href="Frigyes_Riesz" title="wikilink">Riesz operators</a>. Many classes of Riesz operators (including the compact operators) are ideals in <em>L</em>(<em>X</em>) and provide a rich field for research. However if <em>X</em> is a <a href="Hilbert_space" title="wikilink">Hilbert space</a> there is exactly one closed ideal sandwiched between the Riesz operators and those of finite rank.</p>

<p>Much of the foregoing discussion can be set in the more general context of a complex <a href="Banach_algebra" title="wikilink">Banach algebra</a>. Here spectral projections are referred to as <strong>spectral idempotents</strong> since there may no longer be a space for them to project onto.</p>
<h3 id="invariant-subspace-decomposition">Invariant subspace decomposition</h3>

<p><em>If</em> the spectrum σ(<em>T</em>) is not connected, <em>X</em> can be decomposed into invariant subspaces of <em>T</em> using the functional calculus. Let σ(<em>T</em>) be a disjoint union</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:43">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>σ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋃</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>m</mi>
     </munderover>
     <msub>
      <mi>F</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <union></union>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(T)=\bigcup_{i=1}^{m}F_{i}.
  </annotation>
 </semantics>
</math>

</p>

<p>Define <em>e<sub>i</sub></em> to be 1 on some neighborhood that contains only the component <em>F<sub>i</sub></em> and 0 elsewhere. By the homomorphism property, <em>e<sub>i</sub></em>(<em>T</em>) is a projection for all <em>i</em>. In fact it is just the spectral projection <em>P</em>(<em>F<sub>i</sub></em>;<em>T</em>) described above. The relation <em>e<sub>i</sub></em>(<em>T</em>) <em>T</em> = <em>T e<sub>i</sub></em>(<em>T</em>) means the range of each <em>e<sub>i</sub></em>(<em>T</em>), denoted by <em>X<sub>i</sub></em>, is an invariant subspace of <em>T</em>. Since</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:44">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>i</mi>
     </munder>
     <mrow>
      <msub>
       <mi>e</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>T</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>I</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>i</ci>
      </apply>
      <ci>T</ci>
     </apply>
    </apply>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i}e_{i}(T)=I,\,
  </annotation>
 </semantics>
</math>

</p>

<p><em>X</em> can be expressed in terms of these complementary subspaces:</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:45">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>i</mi>
     </munder>
     <msub>
      <mi>X</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>X</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=\sum_{i}X_{i}.\,
  </annotation>
 </semantics>
</math>

</p>

<p>Similarly, if <em>T<sub>i</sub></em> is <em>T</em> restricted to <em>X<sub>i</sub></em>, then</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:46">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>i</mi>
     </munder>
     <msub>
      <mi>T</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=\sum_{i}T_{i}.\,
  </annotation>
 </semantics>
</math>

</p>

<p>Consider the direct sum</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:47">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>X</mi>
     <mo>′</mo>
    </msup>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
      <mi>i</mi>
     </munder>
     <msub>
      <mi>X</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">direct-sum</csymbol>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{\prime}=\bigoplus_{i}X_{i}.
  </annotation>
 </semantics>
</math>

</p>

<p>With the norm</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:48">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <munder>
       <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
       <mi>i</mi>
      </munder>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>i</mi>
     </munder>
     <mrow>
      <mo>∥</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo>∥</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">direct-sum</csymbol>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left\|\bigoplus_{i}x_{i}\right\|=\sum_{i}\|x_{i}\|,
  </annotation>
 </semantics>
</math>

</p>

<p>''X' '' is a Banach space. The mapping <em>R</em>: ''X' '' → <em>X</em> defined by</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:49">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <munder>
       <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
       <mi>i</mi>
      </munder>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">direct-sum</csymbol>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\left(\bigoplus_{i}x_{i}\right)=\sum_{i}x_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>is a Banach space isomorphism, and we see that</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:50">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>R</mi>
     <mi>T</mi>
     <msup>
      <mi>R</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
      <mi>i</mi>
     </munder>
     <msub>
      <mi>T</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>T</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>R</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">direct-sum</csymbol>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   RTR^{-1}=\bigoplus_{i}T_{i}.
  </annotation>
 </semantics>
</math>

</p>

<p>This can be viewed as a block diagonalization of <em>T</em>.</p>

<p>When X is finite-dimensional, σ(<em>T</em>) = {λ<sub><em>i</em></sub>} is a finite set of points in the complex plane. Choose <em>e<sub>i</sub></em> to be 1 on an open disc containing only λ<sub><em>i</em></sub> from the spectrum. The corresponding block-diagonal matrix</p>

<p>

<math display="block" id="Holomorphic_functional_calculus:51">
 <semantics>
  <mrow>
   <munder>
    <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⊕</mo>
    <mi>i</mi>
   </munder>
   <msub>
    <mi>T</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">direct-sum</csymbol>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigoplus_{i}T_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>is the <a href="Jordan_canonical_form" title="wikilink">Jordan canonical form</a> of <em>T</em>.</p>
<h2 id="related-results">Related results</h2>

<p>With stronger assumptions, when <em>T</em> is a <a href="normal_operator" title="wikilink">normal operator</a> acting on a <a href="Hilbert_space" title="wikilink">Hilbert space</a>, the domain of the functional calculus can be broadened. When comparing the two results, a rough analogy can be made with the relationship between the spectral theorem for normal matrices and the Jordan canonical form. When <em>T</em> is a normal operator, a <a href="continuous_functional_calculus" title="wikilink">continuous functional calculus</a> can be obtained, that is, one can evaluate <em>f</em>(<em>T</em>) with <em>f</em> being a <a href="continuous_function" title="wikilink">continuous function</a> defined on <em>σ</em>(<em>T</em>). Using the machinery of measure theory, this can be extended to functions which are only <a href="measurable_function" title="wikilink">measurable</a> (see <a href="Borel_functional_calculus" title="wikilink">Borel functional calculus</a>). In that context, if <em>E</em> ⊂ σ(<em>T</em>) is a Borel set and <em>E</em>(<em>x</em>) is the characteristic function of <em>E</em>, the projection operator <em>E</em>(<em>T</em>) is a refinement of <em>e<sub>i</sub></em>(<em>T</em>) discussed above.</p>

<p>The Borel functional calculus extends to unbounded self-adjoint operators on a Hilbert space.</p>

<p>In slightly more abstract language, the holomorphic functional calculus can be extended to any element of a <a href="Banach_algebra" title="wikilink">Banach algebra</a>, using essentially the same arguments as above. Similarly, the continuous functional calculus holds for normal elements in any <a class="uri" href="C*-algebra" title="wikilink">C*-algebra</a> and the measurable functional calculus for normal elements in any <a href="von_Neumann_algebra" title="wikilink">von Neumann algebra</a>.</p>
<h3 id="unbounded-operators">Unbounded operators</h3>

<p>A holomorphic functional calculus can be defined in a similar fashion for unbounded <a href="closed_operator" title="wikilink">closed operators</a> with non-empty resolvent set.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Resolvent_formalism" title="wikilink">Resolvent formalism</a></li>
</ul>
<ul>
<li><a href="Jordan_canonical_form#Compact_operators" title="wikilink">Jordan canonical form</a>, where the finite-dimensional case is discussed in some detail.</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>N. Dunford and J.T. Schwartz, <em>Linear Operators, Part I: General Theory</em>, Interscience, 1958.</li>
<li>Steven G Krantz. <em>Dictionary of Algebra, Arithmetic, and Trigonometry</em>. CRC Press, 2000. ISBN 1-58488-052-X.</li>
<li>Israel Gohberg, Seymour Goldberg and Marinus A. Kaashoek, <em>Classes of Linear Operators: Volume 1</em>. Birkhauser, 1991. ISBN 978-0817625313.</li>
</ul>

<p>"</p>

<p><a href="Category:Functional_calculus" title="wikilink">*</a> <a href="Category:Analytic_functions" title="wikilink">holomorphic functions</a></p>
</body>
</html>
