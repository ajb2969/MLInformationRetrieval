<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1823">QR algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>QR algorithm</h1>
<hr/>

<p>In <a href="numerical_linear_algebra" title="wikilink">numerical linear algebra</a>, the <strong>QR algorithm</strong> is an <a href="eigenvalue_algorithm" title="wikilink">eigenvalue algorithm</a>: that is, a procedure to calculate the <a href="eigenvalues_and_eigenvectors" title="wikilink">eigenvalues and eigenvectors</a> of a <a href="Matrix_(mathematics)" title="wikilink">matrix</a>. The QR transformation was developed in the late 1950s by <a href="John_G.F._Francis" title="wikilink">John G.F. Francis</a> (England) and by <a href="Vera_N._Kublanovskaya" title="wikilink">Vera N. Kublanovskaya</a> (USSR), working independently.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The basic idea is to perform a <a href="QR_decomposition" title="wikilink">QR decomposition</a>, writing the matrix as a product of an <a href="orthogonal_matrix" title="wikilink">orthogonal matrix</a> and an upper <a href="triangular_matrix" title="wikilink">triangular matrix</a>, multiply the factors in the reverse order, and iterate.</p>
<h2 id="the-practical-qr-algorithm">The practical QR algorithm</h2>

<p>Formally, let <em>A</em> be a real matrix of which we want to compute the eigenvalues, and let <em>A</em><sub>0</sub>:=<em>A</em>. At the <em>k</em>-th step (starting with <em>k</em> = 0), we compute the <a href="QR_decomposition" title="wikilink">QR decomposition</a> <em>A</em><sub><em>k</em></sub>=<em>Q</em><sub><em>k</em></sub><em>R</em><sub><em>k</em></sub> where <em>Q</em><sub><em>k</em></sub> is an <a href="orthogonal_matrix" title="wikilink">orthogonal matrix</a> (i.e., <em>Q</em><sup><em>T</em></sup> = <em>Q</em><sup>âˆ’1</sup>) and <em>R</em><sub><em>k</em></sub> is an upper triangular matrix. We then form <em>A</em><sub><em>k</em>+1</sub> = <em>R</em><sub><em>k</em></sub><em>Q</em><sub><em>k</em></sub>. Note that</p>

<p>

<math display="block" id="QR_algorithm:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>A</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>R</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>Q</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mi>Q</mi>
      <mi>k</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <msub>
      <mi>Q</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>R</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>Q</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mi>Q</mi>
      <mi>k</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <msub>
      <mi>A</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>Q</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mi>Q</mi>
      <mi>k</mi>
      <mi>T</mi>
     </msubsup>
     <msub>
      <mi>A</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>Q</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Q</ci>
        <ci>k</ci>
       </apply>
       <ci>T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{k+1}=R_{k}Q_{k}=Q_{k}^{-1}Q_{k}R_{k}Q_{k}=Q_{k}^{-1}A_{k}Q_{k}=Q_{k}^{T}A_{%
k}Q_{k},
  </annotation>
 </semantics>
</math>

 so all the <em>A</em><sub><em>k</em></sub> are <a href="Similar_matrix" title="wikilink">similar</a> and hence they have the same eigenvalues. The algorithm is <a href="numerical_stability" title="wikilink">numerically stable</a> because it proceeds by <em>orthogonal</em> similarity transforms.</p>

<p>Under certain conditions,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> the matrices <em>A</em><sub><em>k</em></sub> converge to a triangular matrix, the <a href="Schur_form" title="wikilink">Schur form</a> of <em>A</em>. The eigenvalues of a triangular matrix are listed on the diagonal, and the eigenvalue problem is solved. In testing for convergence it is impractical to require exact zeros, but the <a href="Gershgorin_circle_theorem" title="wikilink">Gershgorin circle theorem</a> provides a bound on the error.</p>

<p>In this crude form the iterations are relatively expensive. This can be mitigated by first bringing the matrix <em>A</em> to upper <a href="Hessenberg_form" title="wikilink">Hessenberg form</a> (which costs 

<math display="inline" id="QR_algorithm:1">
 <semantics>
  <mrow>
   <mrow>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mfrac>
        <mn>10</mn>
        <mn>3</mn>
       </mfrac>
      </mtd>
     </mtr>
    </mtable>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>n</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <matrix>
      <matrixrow>
       <apply>
        <divide></divide>
        <cn type="integer">10</cn>
        <cn type="integer">3</cn>
       </apply>
      </matrixrow>
     </matrix>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{matrix}\frac{10}{3}\end{matrix}n^{3}+O(n^{2})
  </annotation>
 </semantics>
</math>

 arithmetic operations using a technique based on <a href="Householder_transformation" title="wikilink">Householder reduction</a>), with a finite sequence of orthogonal similarity transforms, somewhat like a two-sided QR decomposition.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> (For QR decomposition, the Householder reflectors are multiplied only on the left, but for the Hessenberg case they are multiplied on both left and right.) Determining the QR decomposition of an upper Hessenberg matrix costs 

<math display="inline" id="QR_algorithm:2">
 <semantics>
  <mrow>
   <mrow>
    <mn>6</mn>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <cn type="integer">6</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   6n^{2}+O(n)
  </annotation>
 </semantics>
</math>

 arithmetic operations. Moreover, because the Hessenberg form is already nearly upper-triangular (it has just one nonzero entry below each diagonal), using it as a starting point reduces the number of steps required for convergence of the QR algorithm.</p>

<p>If the original matrix is <a href="symmetric_matrix" title="wikilink">symmetric</a>, then the upper Hessenberg matrix is also symmetric and thus <a href="tridiagonal_matrix" title="wikilink">tridiagonal</a>, and so are all the <em>A</em><sub><em>k</em></sub>. This procedure costs 

<math display="inline" id="QR_algorithm:3">
 <semantics>
  <mrow>
   <mrow>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mfrac>
        <mn>4</mn>
        <mn>3</mn>
       </mfrac>
      </mtd>
     </mtr>
    </mtable>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>n</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <matrix>
      <matrixrow>
       <apply>
        <divide></divide>
        <cn type="integer">4</cn>
        <cn type="integer">3</cn>
       </apply>
      </matrixrow>
     </matrix>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{matrix}\frac{4}{3}\end{matrix}n^{3}+O(n^{2})
  </annotation>
 </semantics>
</math>

 arithmetic operations using a technique based on Householder reduction.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Determining the QR decomposition of a symmetric tridiagonal matrix costs 

<math display="inline" id="QR_algorithm:4">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 operations.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>The rate of convergence depends on the separation between eigenvalues, so a practical algorithm will use shifts, either explicit or implicit, to increase separation and accelerate convergence. A typical symmetric QR algorithm isolates each eigenvalue (then reduces the size of the matrix) with only one or two iterations, making it efficient as well as robust.</p>
<h2 id="the-implicit-qr-algorithm">The implicit QR algorithm</h2>

<p>In modern computational practice,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> the QR algorithm is performed in an implicit version which makes the use of multiple shifts easier to introduce. The matrix is first brought to upper Hessenberg form 

<math display="inline" id="QR_algorithm:5">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>Q</mi>
    <mi>A</mi>
    <msup>
     <mi>Q</mi>
     <mi>T</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Q</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{0}=QAQ^{T}
  </annotation>
 </semantics>
</math>

 as in the explicit version; then, at each step, the first column of 

<math display="inline" id="QR_algorithm:6">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{k}
  </annotation>
 </semantics>
</math>

 is transformed via a small-size Householder similarity transformation to the first column of 

<math display="inline" id="QR_algorithm:7">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>A</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(A_{k})
  </annotation>
 </semantics>
</math>

 (or 

<math display="inline" id="QR_algorithm:8">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>A</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <msub>
    <mi>e</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(A_{k})e_{1}
  </annotation>
 </semantics>
</math>

), where 

<math display="inline" id="QR_algorithm:9">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>A</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(A_{k})
  </annotation>
 </semantics>
</math>

, of degree 

<math display="inline" id="QR_algorithm:10">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

, is the polynomial that defines the shifting strategy (often 

<math display="inline" id="QR_algorithm:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <mi>Î»</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <mover accent="true">
       <mi>Î»</mi>
       <mo stretchy="false">Â¯</mo>
      </mover>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <ci>Î»</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <apply>
       <ci>normal-Â¯</ci>
       <ci>Î»</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)=(x-\lambda)(x-\bar{\lambda})
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="QR_algorithm:12">
 <semantics>
  <mi>Î»</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Î»</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="QR_algorithm:13">
 <semantics>
  <mover accent="true">
   <mi>Î»</mi>
   <mo stretchy="false">Â¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-Â¯</ci>
    <ci>Î»</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{\lambda}
  </annotation>
 </semantics>
</math>

 are the two eigenvalues of the trailing 

<math display="inline" id="QR_algorithm:14">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mo>Ã—</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\times 2
  </annotation>
 </semantics>
</math>

 principal submatrix of 

<math display="inline" id="QR_algorithm:15">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{k}
  </annotation>
 </semantics>
</math>

, the so-called <em>implicit double-shift</em>). Then successive Householder transformation of size 

<math display="inline" id="QR_algorithm:16">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>r</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r+1
  </annotation>
 </semantics>
</math>

 are performed in order to return the working matrix 

<math display="inline" id="QR_algorithm:17">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{k}
  </annotation>
 </semantics>
</math>

 to upper Hessenberg form. This operation is known as <em>bulge chasing</em>, due to the peculiar shape of the non-zero entries of the matrix along the steps of the algorithm. As in the first version, deflation is performed as soon as one of the sub-diagonal entries of 

<math display="inline" id="QR_algorithm:18">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{k}
  </annotation>
 </semantics>
</math>

 is sufficiently small.</p>
<h3 id="renaming-proposal">Renaming proposal</h3>

<p>Since in the modern implicit version of the procedure no <a href="QR_decomposition" title="wikilink">QR decompositions</a> are explicitly performed, some authors, for instance Watkins,<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> suggested changing its name to <em>Francis algorithm</em>. <a href="Gene_H._Golub" title="wikilink">Golub</a> and <a href="Charles_F._Van_Loan" title="wikilink">Van Loan</a> use the term <em>Francis QR step</em>.</p>
<h2 id="interpretation-and-convergence">Interpretation and convergence</h2>

<p>The QR algorithm can be seen as a more sophisticated variation of the basic "power" <a href="eigenvalue_algorithm" title="wikilink">eigenvalue algorithm</a>. Recall that the power algorithm repeatedly multiplies <em>A</em> times a single vector, normalizing after each iteration. The vector converges to an eigenvector of the largest eigenvalue. Instead, the QR algorithm works with a complete basis of vectors, using QR decomposition to renormalize (and orthogonalize). For a symmetric matrix <em>A</em>, upon convergence, <em>AQ</em>â€ˆ=â€ˆ<em>QÎ›</em>, where <em>Î›</em> is the diagonal matrix of eigenvalues to which <em>A</em> converged, and where <em>Q</em> is a composite of all the orthogonal similarity transforms required to get there. Thus the columns of <em>Q</em> are the eigenvectors.</p>
<h2 id="history">History</h2>

<p>The QR algorithm was preceded by the <em>LR algorithm</em>, which uses the <a href="LU_decomposition" title="wikilink">LU decomposition</a> instead of the QR decomposition. The QR algorithm is more stable, so the LR algorithm is rarely used nowadays. However, it represents an important step in the development of the QR algorithm.</p>

<p>The LR algorithm was developed in the early 1950s by <a href="Heinz_Rutishauser" title="wikilink">Heinz Rutishauser</a>, who worked at that time as a research assistant of <a href="Eduard_Stiefel" title="wikilink">Eduard Stiefel</a> at <a href="ETH_Zurich" title="wikilink">ETH Zurich</a>. Stiefel suggested that Rutishauer use the sequence of moments <em>y</em><sub>0</sub><sup>T</sup> <em>A</em><sup><em>k</em></sup> <em>x</em><sub>0</sub>, <em>k</em> = 0, 1, â€¦ (where <em>x</em><sub>0</sub> and <em>y</em><sub>0</sub> are arbitrary vectors) to find the eigenvalues of <em>A</em>. Rutishauer took an algorithm of <a href="Alexander_Aitken" title="wikilink">Alexander Aitken</a> for this task and developed it into the <em>quotientâ€“difference algorithm</em> or <em>qd algorithm</em>. After arranging the computation in a suitable shape, he discovered that the qd algorithm is in fact the iteration <em>A</em><sub><em>k</em></sub> = <em>L</em><sub><em>k</em></sub><em>U</em><sub><em>k</em></sub> (LU decomposition), <em>A</em><sub><em>k</em>+1</sub> = <em>U</em><sub><em>k</em></sub><em>L</em><sub><em>k</em></sub>, applied on a tridiagonal matrix, from which the LR algorithm follows.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="other-variants">Other variants</h2>

<p>One variant of the <em>QR algorithm</em>, <em>the Golub-Kahan-Reinsch</em> algorithm starts with reducing a general matrix into a bidiagonal one.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> This variant of the <em>QR algorithm</em> for the computation of eigenvalues, which was first described by . The <a class="uri" href="LAPACK" title="wikilink">LAPACK</a> subroutine <a href="http://www.netlib.org/lapack/double/dbdsqr.f">DBDSQR</a> implements this iterative method, with some modifications to cover the case where the singular values are very small . Together with a first step using Householder reflections and, if appropriate, <a href="QR_decomposition" title="wikilink">QR decomposition</a>, this forms the <a href="http://www.netlib.org/lapack/double/dgesvd.f">DGESVD</a> routine for the computation of the <a href="singular_value_decomposition" title="wikilink">singular value decomposition</a>.</p>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li><a href="http://www.math.umn.edu/~olver/aims_/qr.pdf">Prof. Peter Olver's notes on orthogonal bases and the workings of the QR algorithm</a></li>
<li><a href="http://math.fullerton.edu/mathews/n2003/QRMethodMod.html">Module for the QR Method</a></li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_linear_algebra" title="wikilink">Category:Numerical linear algebra</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">J.G.F. Francis, "The QR Transformation, I", <em>The Computer Journal</em>, vol. 4, no. 3, pages 265-271 (1961, received Oct 1959) <a href="http://comjnl.oxfordjournals.org/cgi/content/abstract/4/3/265">online at oxfordjournals.org</a>;<br/>
J.G.F. Francis, "The QR Transformation, II" <em>The Computer Journal</em>, vol. 4, no. 4, pages 332-345 (1962) <a href="http://comjnl.oxfordjournals.org/cgi/content/abstract/4/4/332">online at oxfordjournals.org</a>.<br/>
Vera N. Kublanovskaya, "On some algorithms for the solution of the complete eigenvalue problem," <em>USSR Computational Mathematics and Mathematical Physics</em>, vol. 1, no. 3, pages 637â€“657 (1963, received Feb 1961). Also published in: <em>Zhurnal Vychislitel'noi Matematiki i Matematicheskoi Fiziki</em>, vol.1, no. 4, pages 555â€“570 (1961).<a href="#fnref1">â†©</a></li>
<li id="fn2">Golub, G. H. and Van Loan, C. F.: Matrix Computations, 3rd ed., Johns Hopkins University Press, Baltimore, 1996, ISBN 0-8018-5414-8.<a href="#fnref2">â†©</a></li>
<li id="fn3"><a href="James_W._Demmel" title="wikilink">James W. Demmel</a>, <em>Applied Numerical Linear Algebra</em> (SIAM, 1997).<a href="#fnref3">â†©</a></li>
<li id="fn4"><a href="Lloyd_N._Trefethen" title="wikilink">Lloyd N. Trefethen</a> and David Bau, <em>Numerical Linear Algebra</em> (SIAM, 1997).<a href="#fnref4">â†©</a></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7">James M. Ortega and Henry F. Kaiser, "The <em>LL<sup>T</sup></em> and <em>QR</em> methods for symmetric tridiagonal matrices," <em>The Computer Journal</em> <strong>6</strong> (1), 99â€“101 (1963).<a href="#fnref7">â†©</a></li>
<li id="fn8">Golub and Van Loan, chapter 7<a href="#fnref8">â†©</a></li>
<li id="fn9">Watkins, David S.: The Matrix Eigenvalue Problem: GR and Krylov Subspace Methods, SIAM, Philadelphia, PA, USA, 2007, ISBN 0-89871-641-1, ISBN 978-0-89871-641-2<a href="#fnref9">â†©</a></li>
<li id="fn10"><a href="#fnref10">â†©</a></li>
<li id="fn11">Bochkanov Sergey Anatolyevich. ALGLIB User Guide - General Matrix operations - Singular value decomposition . ALGLIB Project. 2010-12-11. URL:<a class="uri" href="http://www.alglib.net/matrixops/general/svd.php">http://www.alglib.net/matrixops/general/svd.php</a>. Accessed: 2010-12-11. (Archived by WebCite at <a class="uri" href="http://www.webcitation.org/5utO4iSnR">http://www.webcitation.org/5utO4iSnR</a>)<a href="#fnref11">â†©</a></li>
</ol>
</section>
</body>
</html>
