<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="620">Post's theorem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Post's theorem</h1>
<hr/>

<p>In <a href="recursion_theory" title="wikilink">computability theory</a> <strong>Post's theorem</strong>, named after <a href="Emil_Post" title="wikilink">Emil Post</a>, describes the connection between the <a href="arithmetical_hierarchy" title="wikilink">arithmetical hierarchy</a> and the <a href="Turing_degree" title="wikilink">Turing degrees</a>.</p>
<h2 id="background">Background</h2>

<p>The statement of Post's theorem uses several concepts relating to <a class="uri" href="definability" title="wikilink">definability</a> and <a href="recursion_theory" title="wikilink">recursion theory</a>. This section gives a brief overview of these concepts, which are covered in depth in their respective articles.</p>

<p>The <a href="arithmetical_hierarchy" title="wikilink">arithmetical hierarchy</a> classifies certain sets of natural numbers that are definable in the language of Peano arithmetic. A <a href="formula_(mathematical_logic)" title="wikilink">formula</a> is said to be 

<math display="inline" id="Post's_theorem:0">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mi>m</mi>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0}_{m}
  </annotation>
 </semantics>
</math>

 if it is an existential statement in <a href="prenex_normal_form" title="wikilink">prenex normal form</a> (all quantifiers at the front) with 

<math display="inline" id="Post's_theorem:1">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 alternations between existential and universal quantifiers applied to a quantifier free formula. Formally a formula 

<math display="inline" id="Post's_theorem:2">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(s)
  </annotation>
 </semantics>
</math>

 in the language of Peano arithmetic is a 

<math display="inline" id="Post's_theorem:3">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mi>m</mi>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0}_{m}
  </annotation>
 </semantics>
</math>

 formula if it is of the form</p>

<p>

<math display="block" id="Post's_theorem:4">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <msub>
      <mi>n</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo>∀</mo>
      <mrow>
       <msub>
        <mi>n</mi>
        <mn>2</mn>
       </msub>
       <mrow>
        <mo>∃</mo>
        <mrow>
         <msub>
          <mi>n</mi>
          <mn>3</mn>
         </msub>
         <mrow>
          <mo>∀</mo>
          <mrow>
           <msub>
            <mi>n</mi>
            <mn>4</mn>
           </msub>
           <mi mathvariant="normal">⋯</mi>
           <mi>Q</mi>
           <msub>
            <mi>n</mi>
            <mi>m</mi>
           </msub>
           <mi>ρ</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>n</mi>
             <mn>1</mn>
            </msub>
            <mo>,</mo>
            <mi mathvariant="normal">…</mi>
            <mo>,</mo>
            <msub>
             <mi>n</mi>
             <mi>m</mi>
            </msub>
            <mo>,</mo>
            <msub>
             <mi>x</mi>
             <mn>1</mn>
            </msub>
            <mo>,</mo>
            <mi mathvariant="normal">…</mi>
            <mo>,</mo>
            <msub>
             <mi>x</mi>
             <mi>k</mi>
            </msub>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <exists></exists>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <cn type="integer">3</cn>
         </apply>
         <apply>
          <csymbol cd="latexml">for-all</csymbol>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>n</ci>
            <cn type="integer">4</cn>
           </apply>
           <ci>normal-⋯</ci>
           <ci>Q</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>n</ci>
            <ci>m</ci>
           </apply>
           <ci>ρ</ci>
           <vector>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>n</ci>
             <cn type="integer">1</cn>
            </apply>
            <ci>normal-…</ci>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>n</ci>
             <ci>m</ci>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <cn type="integer">1</cn>
            </apply>
            <ci>normal-…</ci>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <ci>k</ci>
            </apply>
           </vector>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists n_{1}\forall n_{2}\exists n_{3}\forall n_{4}\cdots Qn_{m}\rho(n_{1},%
\ldots,n_{m},x_{1},\ldots,x_{k}),
  </annotation>
 </semantics>
</math>

 where ρ is a quantifier free formula and <em>Q</em> is 

<math display="inline" id="Post's_theorem:5">
 <semantics>
  <mo>∀</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">for-all</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall
  </annotation>
 </semantics>
</math>

 if <em>m</em> is even and 

<math display="inline" id="Post's_theorem:6">
 <semantics>
  <mo>∃</mo>
  <annotation-xml encoding="MathML-Content">
   <exists></exists>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists
  </annotation>
 </semantics>
</math>

 if <em>m</em> is odd. Note that any formula of the form</p>

<p>

<math display="block" id="Post's_theorem:7">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <msubsup>
       <mi>n</mi>
       <mn>1</mn>
       <mn>1</mn>
      </msubsup>
      <mrow>
       <mo>∃</mo>
       <mrow>
        <msubsup>
         <mi>n</mi>
         <mn>2</mn>
         <mn>1</mn>
        </msubsup>
        <mi mathvariant="normal">⋯</mi>
        <mrow>
         <mo>∃</mo>
         <msubsup>
          <mi>n</mi>
          <msub>
           <mi>j</mi>
           <mn>1</mn>
          </msub>
          <mn>1</mn>
         </msubsup>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <msubsup>
       <mi>n</mi>
       <mn>1</mn>
       <mn>2</mn>
      </msubsup>
      <mi mathvariant="normal">⋯</mi>
      <mrow>
       <mo>∀</mo>
       <msubsup>
        <mi>n</mi>
        <msub>
         <mi>j</mi>
         <mn>2</mn>
        </msub>
        <mn>2</mn>
       </msubsup>
      </mrow>
     </mrow>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <msubsup>
       <mi>n</mi>
       <mn>1</mn>
       <mn>3</mn>
      </msubsup>
      <mi mathvariant="normal">⋯</mi>
     </mrow>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mi mathvariant="normal">⋯</mi>
   <mrow>
    <mo>(</mo>
    <mrow>
     <msub>
      <mi>Q</mi>
      <mn>1</mn>
     </msub>
     <msubsup>
      <mi>n</mi>
      <mn>1</mn>
      <mi>m</mi>
     </msubsup>
     <mi mathvariant="normal">⋯</mi>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mi>ρ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>n</mi>
     <mn>1</mn>
     <mn>1</mn>
    </msubsup>
    <mo>,</mo>
    <mrow>
     <mi mathvariant="normal">…</mi>
     <msubsup>
      <mi>n</mi>
      <msub>
       <mi>j</mi>
       <mi>m</mi>
      </msub>
      <mi>m</mi>
     </msubsup>
    </mrow>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <exists></exists>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <ci>normal-⋯</ci>
        <apply>
         <exists></exists>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>j</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>j</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <cn type="integer">3</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-⋯</ci>
     </apply>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <ci>m</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋯</ci>
    </apply>
    <ci>ρ</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <ci>m</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>j</ci>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\exists n^{1}_{1}\exists n^{1}_{2}\cdots\exists n^{1}_{j_{1}}\right)%
\left(\forall n^{2}_{1}\cdots\forall n^{2}_{j_{2}}\right)\left(\exists n^{3}_{%
1}\cdots\right)\cdots\left(Q_{1}n^{m}_{1}\cdots\right)\rho(n^{1}_{1},\ldots n^%
{m}_{j_{m}},x_{1},\ldots,x_{k})
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Post's_theorem:8">
 <semantics>
  <mi>ρ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ρ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

 contains only <a href="bounded_quantifier" title="wikilink">bounded quantifiers</a> is provably equivalent to a formula of the above form from the axioms of <a href="Peano_arithmetic" title="wikilink">Peano arithmetic</a>. Thus it isn't uncommon to see 

<math display="inline" id="Post's_theorem:9">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mi>m</mi>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0}_{m}
  </annotation>
 </semantics>
</math>

 formulas defined in this alternative and technically nonequivalent manner since in practice the distinction is rarely important.</p>

<p>A set of natural numbers <em>A</em> is said to be 

<math display="inline" id="Post's_theorem:10">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mi>m</mi>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0}_{m}
  </annotation>
 </semantics>
</math>

 if it is definable by a 

<math display="inline" id="Post's_theorem:11">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mi>m</mi>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0}_{m}
  </annotation>
 </semantics>
</math>

 formula, that is, if there is a 

<math display="inline" id="Post's_theorem:12">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mi>m</mi>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0}_{m}
  </annotation>
 </semantics>
</math>

 formula 

<math display="inline" id="Post's_theorem:13">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(s)
  </annotation>
 </semantics>
</math>

 such that each number <em>n</em> is in <em>A</em> if and only if 

<math display="inline" id="Post's_theorem:14">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(n)
  </annotation>
 </semantics>
</math>

 holds. It is known that if a set is 

<math display="inline" id="Post's_theorem:15">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mi>m</mi>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0}_{m}
  </annotation>
 </semantics>
</math>

 then it is 

<math display="inline" id="Post's_theorem:16">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mi>n</mi>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0}_{n}
  </annotation>
 </semantics>
</math>

 for any 

<math display="inline" id="Post's_theorem:17">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>></mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>n</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n>m
  </annotation>
 </semantics>
</math>

, but for each <em>m</em> there is a 

<math display="inline" id="Post's_theorem:18">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mrow>
    <mi>m</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <plus></plus>
     <ci>m</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0}_{m+1}
  </annotation>
 </semantics>
</math>

 set that is not 

<math display="inline" id="Post's_theorem:19">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mi>m</mi>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0}_{m}
  </annotation>
 </semantics>
</math>

. Thus the number of quantifier alternations required to define a set gives a measure of the complexity of the set.</p>

<p>Post's theorem uses the relativized arithmetical hierarchy as well as the unrelativized hierarchy just defined. A set <em>A</em> of natural numbers is said to be 

<math display="inline" id="Post's_theorem:20">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mi>m</mi>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0}_{m}
  </annotation>
 </semantics>
</math>

 relative to a set <em>B</em>, written 

<math display="inline" id="Post's_theorem:21">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mi>m</mi>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mi>B</mi>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <list>
      <cn type="integer">0</cn>
      <ci>B</ci>
     </list>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0,B}_{m}
  </annotation>
 </semantics>
</math>

, if <em>A</em> is definable by a 

<math display="inline" id="Post's_theorem:22">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mi>m</mi>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0}_{m}
  </annotation>
 </semantics>
</math>

 formula in an extended language that includes a predicate for membership in <em>B</em>.</p>

<p>While the arithmetical hierarchy measures definability of sets of natural numbers, <a href="Turing_degrees" title="wikilink">Turing degrees</a> measure the level of uncomputability of sets of natural numbers. A set <em>A</em> is said to be <a href="Turing_reduction" title="wikilink">Turing reducible</a> to a set <em>B</em>, written 

<math display="inline" id="Post's_theorem:23">
 <semantics>
  <mrow>
   <mi>A</mi>
   <msub>
    <mo>≤</mo>
    <mi>T</mi>
   </msub>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <ci>T</ci>
    </apply>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\leq_{T}B
  </annotation>
 </semantics>
</math>

, if there is an <a href="oracle_Turing_machine" title="wikilink">oracle Turing machine</a> that, given an oracle for <em>B</em>, computes the <a href="Indicator_function" title="wikilink">characteristic function</a> of <em>A</em>. The <a href="Turing_jump" title="wikilink">Turing jump</a> of a set <em>A</em> is a form of the <a href="Halting_problem" title="wikilink">Halting problem</a> relative to <em>A</em>. Given a set <em>A</em>, the Turing jump 

<math display="inline" id="Post's_theorem:24">
 <semantics>
  <msup>
   <mi>A</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>A</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{\prime}
  </annotation>
 </semantics>
</math>

 is the set of indices of oracle Turing machines that halt on input <em>0</em> when run with oracle <em>A</em>. It is known that every set <em>A</em> is Turing reducible to its Turing jump, but the Turing jump of a set is never Turing reducible to the original set.</p>

<p>Post's theorem uses finitely iterated Turing jumps. For any set <em>A</em> of natural numbers, the notation 

<math display="inline" id="Post's_theorem:25">
 <semantics>
  <msup>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>A</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{(n)}
  </annotation>
 </semantics>
</math>

 indicates the <em>n</em>-fold iterated Turing jump of <em>A</em>. Thus 

<math display="inline" id="Post's_theorem:26">
 <semantics>
  <msup>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>A</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{(0)}
  </annotation>
 </semantics>
</math>

 is just <em>A</em>, and 

<math display="inline" id="Post's_theorem:27">
 <semantics>
  <msup>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>A</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{(n+1)}
  </annotation>
 </semantics>
</math>

 is the Turing jump of 

<math display="inline" id="Post's_theorem:28">
 <semantics>
  <msup>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>A</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{(n)}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="posts-theorem-and-corollaries">Post's theorem and corollaries</h2>

<p>Post's theorem establishes a close connection between the arithmetical hierarchy and the Turing degrees of the form 

<math display="inline" id="Post's_theorem:29">
 <semantics>
  <msup>
   <mi mathvariant="normal">∅</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <emptyset></emptyset>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \emptyset^{(n)}
  </annotation>
 </semantics>
</math>

, that is, finitely iterated Turing jumps of the empty set. (The empty set could be replaced with any other computable set without changing the truth of the theorem.)</p>

<p>Post's theorem states:</p>
<ol>
<li>A set <em>B</em> is 

<math display="inline" id="Post's_theorem:30">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0}_{n+1}
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Post's_theorem:31">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is <a href="recursively_enumerable" title="wikilink">recursively enumerable</a> by an oracle Turing machine with an oracle for 

<math display="inline" id="Post's_theorem:32">
 <semantics>
  <msup>
   <mi mathvariant="normal">∅</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <emptyset></emptyset>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \emptyset^{(n)}
  </annotation>
 </semantics>
</math>

, that is, if and only if <em>B</em> is 

<math display="inline" id="Post's_theorem:33">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mn>1</mn>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <msup>
     <mi mathvariant="normal">∅</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <list>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <emptyset></emptyset>
       <ci>n</ci>
      </apply>
     </list>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0,\emptyset^{(n)}}_{1}
  </annotation>
 </semantics>
</math>

.</li>
<li>The set 

<math display="inline" id="Post's_theorem:34">
 <semantics>
  <msup>
   <mi mathvariant="normal">∅</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <emptyset></emptyset>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \emptyset^{(n)}
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Post's_theorem:35">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mi>n</mi>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0}_{n}
  </annotation>
 </semantics>
</math>

 complete for every 

<math display="inline" id="Post's_theorem:36">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>n</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n>0
  </annotation>
 </semantics>
</math>

. This means that every 

<math display="inline" id="Post's_theorem:37">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mi>n</mi>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0}_{n}
  </annotation>
 </semantics>
</math>

 set is <a href="many-one_reduction" title="wikilink">many-one reducible</a> to 

<math display="inline" id="Post's_theorem:38">
 <semantics>
  <msup>
   <mi mathvariant="normal">∅</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <emptyset></emptyset>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \emptyset^{(n)}
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>Post's theorem has many corollaries that expose additional relationships between the arithmetical hierarchy and the Turing degrees. These include:</p>
<ol>
<li>Fix a set <em>C</em>. A set <em>B</em> is 

<math display="inline" id="Post's_theorem:39">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mi>C</mi>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <list>
      <cn type="integer">0</cn>
      <ci>C</ci>
     </list>
    </apply>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0,C}_{n+1}
  </annotation>
 </semantics>
</math>

 if and only if <em>B</em> is 

<math display="inline" id="Post's_theorem:40">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mn>1</mn>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <msup>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <list>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>C</ci>
       <ci>n</ci>
      </apply>
     </list>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0,C^{(n)}}_{1}
  </annotation>
 </semantics>
</math>

. This is the relativization of the first part of Post's theorem to the oracle <em>C</em>.</li>
<li>A set <em>B</em> is 

<math display="inline" id="Post's_theorem:41">
 <semantics>
  <msub>
   <mi mathvariant="normal">Δ</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Δ</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta_{n+1}
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Post's_theorem:42">
 <semantics>
  <mrow>
   <mi>B</mi>
   <msub>
    <mo>≤</mo>
    <mi>T</mi>
   </msub>
   <msup>
    <mi mathvariant="normal">∅</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <ci>T</ci>
    </apply>
    <ci>B</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <emptyset></emptyset>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\leq_{T}\emptyset^{(n)}
  </annotation>
 </semantics>
</math>

. More generally, <em>B</em> is 

<math display="inline" id="Post's_theorem:43">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Δ</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mi>C</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Δ</ci>
     <ci>C</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta^{C}_{n+1}
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Post's_theorem:44">
 <semantics>
  <mrow>
   <mi>B</mi>
   <msub>
    <mo>≤</mo>
    <mi>T</mi>
   </msub>
   <msup>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <ci>T</ci>
    </apply>
    <ci>B</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>C</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\leq_{T}C^{(n)}
  </annotation>
 </semantics>
</math>

.</li>
<li>A set is defined to be arithmetical if it is 

<math display="inline" id="Post's_theorem:45">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mi>n</mi>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0}_{n}
  </annotation>
 </semantics>
</math>

 for some <em>n</em>. Post's theorem shows that, equivalently, a set is arithmetical if and only if it is Turing reducible to 

<math display="inline" id="Post's_theorem:46">
 <semantics>
  <msup>
   <mi mathvariant="normal">∅</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <emptyset></emptyset>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \emptyset^{(m)}
  </annotation>
 </semantics>
</math>

 for some <em>m</em>.</li>
</ol>
<h2 id="references">References</h2>

<p>Rogers, H. <em>The Theory of Recursive Functions and Effective Computability</em>, MIT Press. ISBN 0-262-68052-1; ISBN 0-07-053522-1</p>

<p>Soare, R. <em>Recursively enumerable sets and degrees.</em> Perspectives in Mathematical Logic. Springer-Verlag, Berlin, 1987. ISBN 3-540-15299-7</p>

<p>"</p>

<p><a href="Category:Theorems_in_the_foundations_of_mathematics" title="wikilink">Category:Theorems in the foundations of mathematics</a> <a href="Category:Computability_theory" title="wikilink">Category:Computability theory</a> <a href="Category:Mathematical_logic_hierarchies" title="wikilink">Category:Mathematical logic hierarchies</a></p>
</body>
</html>
