<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="504">Horner's method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Horner's method</h1>
<hr>In [[mathematics]], '''Horner's method''' (also known as '<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</hr></body></html>
<body>

<p><em>Horner scheme</em>' in the UK or <strong>Horner's rule</strong> in the U.S.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a>) is either of two things: (i) an <a class="uri" href="algorithm" title="wikilink">algorithm</a> for calculating <a href="polynomial" title="wikilink">polynomials</a>, which consists of transforming the <a href="Monomial_basis" title="wikilink">monomial form</a> into a computationally efficient form;<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> or (ii) a method for approximating the roots of a polynomial.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The latter is also known as <strong>Ruffini–Horner's method</strong>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>These methods are named after the British mathematician <a href="William_George_Horner" title="wikilink">William George Horner</a>, although they were known before him by <a href="Paolo_Ruffini" title="wikilink">Paolo Ruffini</a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> and, six hundred years earlier, by the Chinese mathematician <a href="Qin_Jiushao" title="wikilink">Qin Jiushao</a>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="description-of-the-algorithm">Description of the algorithm</h2>

<p>Given the polynomial</p>

<p>

<math display="block" id="Horner's_method:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>i</mi>
      </msub>
      <msup>
       <mi>x</mi>
       <mi>i</mi>
      </msup>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>0</mn>
     </msub>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>a</mi>
       <mn>1</mn>
      </msub>
      <mi>x</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>a</mi>
       <mn>2</mn>
      </msub>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>a</mi>
       <mn>3</mn>
      </msub>
      <msup>
       <mi>x</mi>
       <mn>3</mn>
      </msup>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>n</mi>
      </msub>
      <msup>
       <mi>x</mi>
       <mi>n</mi>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)=\sum_{i=0}^{n}a_{i}x^{i}=a_{0}+a_{1}x+a_{2}x^{2}+a_{3}x^{3}+\cdots+a_{n}x%
^{n},
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Horner's_method:1">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{0},\ldots,a_{n}
  </annotation>
 </semantics>
</math>

 are real numbers, we wish to evaluate the polynomial at a specific value of 

<math display="inline" id="Horner's_method:2">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, say 

<math display="inline" id="Horner's_method:3">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

.</p>

<p>To accomplish this, we define a new sequence of constants as follows:</p>

<p>

<math display="inline" id="Horner's_method:4">
 <semantics>
  <msub>
   <mi>b</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>b</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle b_{n}
  </annotation>
 </semantics>
</math>


</p>

<p>Then 

<math display="inline" id="Horner's_method:5">
 <semantics>
  <msub>
   <mi>b</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>b</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{0}
  </annotation>
 </semantics>
</math>

 is the value of 

<math display="inline" id="Horner's_method:6">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x_{0})
  </annotation>
 </semantics>
</math>

.</p>

<p>To see why this works, note that the polynomial can be written in the form</p>

<p>

<math display="block" id="Horner's_method:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>0</mn>
     </msub>
     <mo>+</mo>
     <mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>a</mi>
         <mn>1</mn>
        </msub>
        <mo>+</mo>
        <mrow>
         <mi>x</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msub>
            <mi>a</mi>
            <mn>2</mn>
           </msub>
           <mo>+</mo>
           <mi mathvariant="normal">⋯</mi>
           <mo>+</mo>
           <mrow>
            <mi>x</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <msub>
               <mi>a</mi>
               <mrow>
                <mi>n</mi>
                <mo>-</mo>
                <mn>1</mn>
               </mrow>
              </msub>
              <mo>+</mo>
              <mrow>
               <msub>
                <mi>a</mi>
                <mi>n</mi>
               </msub>
               <mi>x</mi>
              </mrow>
             </mrow>
             <mo stretchy="false">)</mo>
            </mrow>
            <mi mathvariant="normal">⋯</mi>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <times></times>
        <ci>x</ci>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <cn type="integer">2</cn>
         </apply>
         <ci>normal-⋯</ci>
         <apply>
          <times></times>
          <ci>x</ci>
          <apply>
           <plus></plus>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>a</ci>
            <apply>
             <minus></minus>
             <ci>n</ci>
             <cn type="integer">1</cn>
            </apply>
           </apply>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>a</ci>
             <ci>n</ci>
            </apply>
            <ci>x</ci>
           </apply>
          </apply>
          <ci>normal-⋯</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)=a_{0}+x(a_{1}+x(a_{2}+\cdots+x(a_{n-1}+a_{n}x)\cdots)).\,
  </annotation>
 </semantics>
</math>

</p>

<p>Thus, by iteratively substituting the 

<math display="inline" id="Horner's_method:8">
 <semantics>
  <msub>
   <mi>b</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>b</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{i}
  </annotation>
 </semantics>
</math>

 into the expression,</p>

<p>

<math display="inline" id="Horner's_method:9">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle p(x_{0})
  </annotation>
 </semantics>
</math>


</p>
<h2 id="examples">Examples</h2>

<p>Evaluate</p>

<p>

<math display="block" id="Horner's_method:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mn>2</mn>
       <msup>
        <mi>x</mi>
        <mn>3</mn>
       </msup>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mn>6</mn>
       <msup>
        <mi>x</mi>
        <mn>2</mn>
       </msup>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mn>2</mn>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mpadded width="+1.7pt">
     <mn>1</mn>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">3</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">6</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>x</ci>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=2x^{3}-6x^{2}+2x-1\,
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Horner's_method:11">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mpadded width="+2.8pt">
    <mn>3.</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <cn type="float">3.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=3.\;
  </annotation>
 </semantics>
</math>

</p>

<p>We use <a href="synthetic_division" title="wikilink">synthetic division</a> as follows:</p>

<p><code> x₀│   x³    x²    x¹    x⁰</code><br/>
<code> 3 │   2    −6     2    −1</code><br/>
<code>   │         6     0     6    </code><br/>
<code>   └────────────────────────</code><br/>
<code>       2     0     2     5</code></p>

<p>The entries in the third row are the sum of those in the first two. Each entry in the second row is the product of the <em>x</em>-value (3 in this example) with the third-row entry immediately to the left. The entries in the first row are the coefficients of the polynomial to be evaluated. Then the remainder of 

<math display="inline" id="Horner's_method:12">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 on division by 

<math display="inline" id="Horner's_method:13">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>-</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>x</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x-3
  </annotation>
 </semantics>
</math>

 is 5.</p>

<p>But by the polynomial remainder theorem, we know that the remainder is 

<math display="inline" id="Horner's_method:14">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>3</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(3)
  </annotation>
 </semantics>
</math>

. Thus 

<math display="inline" id="Horner's_method:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>3</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <cn type="integer">3</cn>
    </apply>
    <cn type="integer">5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(3)=5
  </annotation>
 </semantics>
</math>

</p>

<p>In this example, if 

<math display="inline" id="Horner's_method:16">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>3</mn>
    </msub>
    <mo>=</mo>
    <mn>2</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>2</mn>
     </msub>
     <mo>=</mo>
     <mrow>
      <mo>-</mo>
      <mn>6</mn>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>a</mi>
       <mn>1</mn>
      </msub>
      <mo>=</mo>
      <mn>2</mn>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>a</mi>
       <mn>0</mn>
      </msub>
      <mo>=</mo>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">3</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">6</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{3}=2,a_{2}=-6,a_{1}=2,a_{0}=-1
  </annotation>
 </semantics>
</math>

 we can see that 

<math display="inline" id="Horner's_method:17">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>b</mi>
     <mn>3</mn>
    </msub>
    <mo>=</mo>
    <mn>2</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>b</mi>
      <mn>2</mn>
     </msub>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>b</mi>
       <mn>1</mn>
      </msub>
      <mo>=</mo>
      <mn>2</mn>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>b</mi>
       <mn>0</mn>
      </msub>
      <mo>=</mo>
      <mn>5</mn>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <cn type="integer">3</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <eq></eq>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">0</cn>
       </apply>
       <cn type="integer">5</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{3}=2,b_{2}=0,b_{1}=2,b_{0}=5
  </annotation>
 </semantics>
</math>

, the entries in the third row. So, synthetic division is based on Horner's method.</p>

<p>As a consequence of the <a href="polynomial_remainder_theorem" title="wikilink">polynomial remainder theorem</a>, the entries in the third row are the coefficients of the second-degree polynomial, the quotient of 

<math display="inline" id="Horner's_method:18">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 on division by 

<math display="inline" id="Horner's_method:19">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>-</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>x</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x-3
  </annotation>
 </semantics>
</math>

. The remainder is 5. This makes Horner's method useful for <a href="polynomial_long_division" title="wikilink">polynomial long division</a>.</p>

<p>Divide 

<math display="inline" id="Horner's_method:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>x</mi>
      <mn>3</mn>
     </msup>
     <mo>-</mo>
     <mrow>
      <mn>6</mn>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>11</mn>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mpadded width="+1.7pt">
    <mn>6</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">6</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">11</cn>
      <ci>x</ci>
     </apply>
    </apply>
    <cn type="integer">6</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{3}-6x^{2}+11x-6\,
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Horner's_method:21">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>-</mo>
   <mpadded width="+1.7pt">
    <mn>2</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x-2\,
  </annotation>
 </semantics>
</math>

:</p>

<p><code> 2 │   1    -6    11    -6</code><br/>
<code>   │         2    -8     6    </code><br/>
<code>   └────────────────────────</code><br/>
<code>       1    -4     3     0</code></p>

<p>The quotient is 

<math display="inline" id="Horner's_method:22">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mo>-</mo>
    <mrow>
     <mn>4</mn>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mpadded width="+1.7pt">
    <mn>3</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">4</cn>
      <ci>x</ci>
     </apply>
    </apply>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}-4x+3\,
  </annotation>
 </semantics>
</math>

.</p>

<p>Let 

<math display="inline" id="Horner's_method:23">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <mn>4</mn>
       <msup>
        <mi>x</mi>
        <mn>4</mn>
       </msup>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mn>6</mn>
       <msup>
        <mi>x</mi>
        <mn>3</mn>
       </msup>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mn>3</mn>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mpadded width="+1.7pt">
     <mn>5</mn>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <cn type="integer">4</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">4</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">6</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">3</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <ci>x</ci>
      </apply>
     </apply>
     <cn type="integer">5</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{1}(x)=4x^{4}-6x^{3}+3x-5\,
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Horner's_method:24">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>x</mi>
    </mrow>
    <mo>-</mo>
    <mpadded width="+1.7pt">
     <mn>1</mn>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>x</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{2}(x)=2x-1\,
  </annotation>
 </semantics>
</math>

. Divide 

<math display="inline" id="Horner's_method:25">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{1}(x)\,
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Horner's_method:26">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <msub>
     <mi>f</mi>
     <mn>2</mn>
    </msub>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{2}\,(x)
  </annotation>
 </semantics>
</math>

 using Horner's method.</p>

<p><code>  2 │  4    -6    0    3   │   -5</code><br/>
<code>────┼──────────────────────┼───────</code><br/>
<code>  1 │        2   -2   -1   │    1</code><br/>
<code>    │                      │  </code><br/>
<code>    └──────────────────────┼───────</code><br/>
<code>       2    -2    -1   1   │   -4</code></p>

<p>The third row is the sum of the first two rows, divided by 2. Each entry in the second row is the product of 1 with the third-row entry to the left. The answer is</p>

<p>

<math display="block" id="Horner's_method:27">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <msub>
       <mi>f</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <msub>
       <mi>f</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mrow>
        <mn>2</mn>
        <msup>
         <mi>x</mi>
         <mn>3</mn>
        </msup>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mn>2</mn>
        <msup>
         <mi>x</mi>
         <mn>2</mn>
        </msup>
       </mrow>
       <mo>-</mo>
       <mi>x</mi>
      </mrow>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo>-</mo>
     <mfrac>
      <mn>4</mn>
      <mrow>
       <mrow>
        <mn>2</mn>
        <mi>x</mi>
       </mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">3</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>x</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">4</cn>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>x</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{f_{1}(x)}{f_{2}(x)}=2x^{3}-2x^{2}-x+1-\frac{4}{2x-1}.
  </annotation>
 </semantics>
</math>

</p>
<h3 id="floating-point-multiplication-and-division">Floating point multiplication and division</h3>

<p>Horner's method is a fast, code-efficient method for multiplication and division of binary numbers on a <a class="uri" href="microcontroller" title="wikilink">microcontroller</a> with no <a href="binary_multiplier" title="wikilink">hardware multiplier</a>. One of the binary numbers to be multiplied is represented as a trivial polynomial, where, (using the above notation): a<sub>i</sub> = 1, and x = 2. Then, x (or x to some power) is repeatedly factored out. In this <a href="binary_numeral_system" title="wikilink">binary numeral system</a> (base 2), x = 2, so powers of 2 are repeatedly factored out.</p>
<h4 id="example">Example</h4>

<p>For example, to find the product of two numbers, (0.15625) and <em>m</em>:</p>

<p>

<math display="inline" id="Horner's_method:28">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0.15625</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="float">0.15625</cn>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle(0.15625)m
  </annotation>
 </semantics>
</math>


</p>
<h4 id="method">Method</h4>

<p>To find the product of two binary numbers, d and m:</p>
<ul>
<li>1. A register holding the intermediate result is initialized to d.</li>
<li>2. Begin with the least significant (rightmost) non-zero bit in m.
<ul>
<li>2b. Count (to the left) the number of bit positions to the next most significant non-zero bit. If there are no more-significant bits, then take the value of the current bit position.</li>
<li>2c. Using that value, perform a right-shift operation by that number of bits on the register holding the intermediate result</li>
</ul></li>
<li>3. If all the non-zero bits were counted, then the intermediate result register now holds the final result. Otherwise, add d to the intermediate result, and continue in step #2 with the next most significant bit in m.</li>
</ul>
<h4 id="derivation">Derivation</h4>

<p>In general, for a binary number with bit values: (

<math display="inline" id="Horner's_method:29">
 <semantics>
  <mrow>
   <msub>
    <mi>d</mi>
    <mn>3</mn>
   </msub>
   <msub>
    <mi>d</mi>
    <mn>2</mn>
   </msub>
   <msub>
    <mi>d</mi>
    <mn>1</mn>
   </msub>
   <msub>
    <mi>d</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{3}d_{2}d_{1}d_{0}
  </annotation>
 </semantics>
</math>

) the product is:</p>

<p>

<math display="block" id="Horner's_method:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>d</mi>
        <mn>3</mn>
       </msub>
       <msup>
        <mn>2</mn>
        <mn>3</mn>
       </msup>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>d</mi>
        <mn>2</mn>
       </msub>
       <msup>
        <mn>2</mn>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>d</mi>
        <mn>1</mn>
       </msub>
       <msup>
        <mn>2</mn>
        <mn>1</mn>
       </msup>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>d</mi>
        <mn>0</mn>
       </msub>
       <msup>
        <mn>2</mn>
        <mn>0</mn>
       </msup>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>m</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>d</mi>
      <mn>3</mn>
     </msub>
     <msup>
      <mn>2</mn>
      <mn>3</mn>
     </msup>
     <mi>m</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>d</mi>
      <mn>2</mn>
     </msub>
     <msup>
      <mn>2</mn>
      <mn>2</mn>
     </msup>
     <mi>m</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>d</mi>
      <mn>1</mn>
     </msub>
     <msup>
      <mn>2</mn>
      <mn>1</mn>
     </msup>
     <mi>m</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>d</mi>
      <mn>0</mn>
     </msub>
     <msup>
      <mn>2</mn>
      <mn>0</mn>
     </msup>
     <mi>m</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>d</ci>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>d</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>d</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>d</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </apply>
     <ci>m</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <cn type="integer">3</cn>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <cn type="integer">2</cn>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <cn type="integer">1</cn>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <cn type="integer">0</cn>
      </apply>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (d_{3}2^{3}+d_{2}2^{2}+d_{1}2^{1}+d_{0}2^{0})m=d_{3}2^{3}m+d_{2}2^{2}m+d_{1}2^%
{1}m+d_{0}2^{0}m
  </annotation>
 </semantics>
</math>

 At this stage in the algorithm, it is required that terms with zero-valued coefficients are dropped, so that only binary coefficients equal to one are counted, thus the problem of multiplication or <a href="division_by_zero" title="wikilink">division by zero</a> is not an issue, despite this implication in the factored equation:</p>

<p>

<math display="block" id="Horner's_method:31">
 <semantics>
  <mrow>
   <mrow>
    <mi></mi>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>d</mi>
      <mn>0</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>m</mi>
       <mo>+</mo>
       <mrow>
        <mn>2</mn>
        <mfrac>
         <msub>
          <mi>d</mi>
          <mn>1</mn>
         </msub>
         <msub>
          <mi>d</mi>
          <mn>0</mn>
         </msub>
        </mfrac>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>m</mi>
          <mo>+</mo>
          <mrow>
           <mn>2</mn>
           <mfrac>
            <msub>
             <mi>d</mi>
             <mn>2</mn>
            </msub>
            <msub>
             <mi>d</mi>
             <mn>1</mn>
            </msub>
           </mfrac>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>m</mi>
             <mo>+</mo>
             <mrow>
              <mn>2</mn>
              <mfrac>
               <msub>
                <mi>d</mi>
                <mn>3</mn>
               </msub>
               <msub>
                <mi>d</mi>
                <mn>2</mn>
               </msub>
              </mfrac>
              <mrow>
               <mo stretchy="false">(</mo>
               <mi>m</mi>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <plus></plus>
      <ci>m</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>d</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>d</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <plus></plus>
        <ci>m</ci>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <divide></divide>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>d</ci>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>d</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <plus></plus>
          <ci>m</ci>
          <apply>
           <times></times>
           <cn type="integer">2</cn>
           <apply>
            <divide></divide>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>d</ci>
             <cn type="integer">3</cn>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>d</ci>
             <cn type="integer">2</cn>
            </apply>
           </apply>
           <ci>m</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =d_{0}(m+2\frac{d_{1}}{d_{0}}(m+2\frac{d_{2}}{d_{1}}(m+2\frac{d_{3}}{d_{2}}(m)%
))).
  </annotation>
 </semantics>
</math>

</p>

<p>The denominators all equal one (or the term is absent), so this reduces to:</p>

<p>

<math display="block" id="Horner's_method:32">
 <semantics>
  <mrow>
   <mrow>
    <mi></mi>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>d</mi>
      <mn>0</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>m</mi>
       <mo>+</mo>
       <mrow>
        <mn>2</mn>
        <msub>
         <mi>d</mi>
         <mn>1</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>m</mi>
          <mo>+</mo>
          <mrow>
           <mn>2</mn>
           <msub>
            <mi>d</mi>
            <mn>2</mn>
           </msub>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>m</mi>
             <mo>+</mo>
             <mrow>
              <mn>2</mn>
              <msub>
               <mi>d</mi>
               <mn>3</mn>
              </msub>
              <mrow>
               <mo stretchy="false">(</mo>
               <mi>m</mi>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <plus></plus>
      <ci>m</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>d</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <plus></plus>
        <ci>m</ci>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>d</ci>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <plus></plus>
          <ci>m</ci>
          <apply>
           <times></times>
           <cn type="integer">2</cn>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>d</ci>
            <cn type="integer">3</cn>
           </apply>
           <ci>m</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =d_{0}(m+2{d_{1}}(m+2{d_{2}}(m+2{d_{3}}(m)))),
  </annotation>
 </semantics>
</math>

 or equivalently (as consistent with the "method" described above):</p>

<p>

<math display="block" id="Horner's_method:33">
 <semantics>
  <mrow>
   <mrow>
    <mi></mi>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>d</mi>
      <mn>3</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>m</mi>
       <mo>+</mo>
       <mrow>
        <msup>
         <mn>2</mn>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msup>
        <msub>
         <mi>d</mi>
         <mn>2</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>m</mi>
          <mo>+</mo>
          <mrow>
           <msup>
            <mn>2</mn>
            <mrow>
             <mo>-</mo>
             <mn>1</mn>
            </mrow>
           </msup>
           <msub>
            <mi>d</mi>
            <mn>1</mn>
           </msub>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>m</mi>
             <mo>+</mo>
             <mrow>
              <msub>
               <mi>d</mi>
               <mn>0</mn>
              </msub>
              <mrow>
               <mo stretchy="false">(</mo>
               <mi>m</mi>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <plus></plus>
      <ci>m</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>d</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <plus></plus>
        <ci>m</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <cn type="integer">2</cn>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>d</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <plus></plus>
          <ci>m</ci>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>d</ci>
            <cn type="integer">0</cn>
           </apply>
           <ci>m</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =d_{3}(m+2^{-1}{d_{2}}(m+2^{-1}{d_{1}}(m+{d_{0}}(m)))).
  </annotation>
 </semantics>
</math>

</p>

<p>In binary (base 2) math, multiplication by a power of 2 is merely a <a href="arithmetic_shift" title="wikilink">register shift</a> operation. Thus, multiplying by 2 is calculated in base-2 by an <a href="arithmetic_shift" title="wikilink">arithmetic shift</a>. The factor (2<sup>−1</sup>) is a right <a href="arithmetic_shift" title="wikilink">arithmetic shift</a>, a (0) results in no operation (since 2<sup>0</sup> = 1, is the multiplicative <a href="identity_element" title="wikilink">identity element</a>), and a (2<sup>1</sup>) results in a left arithmetic shift. The multiplication product can now be quickly calculated using only arithmetic shift operations, addition and subtraction.</p>

<p>The method is particularly fast on processors supporting a single-instruction shift-and-addition-accumulate. Compared to a C floating-point library, Horner's method sacrifices some accuracy, however it is nominally 13 times faster (16 times faster when the "<a href="canonical_signed_digit" title="wikilink">canonical signed digit</a>" (CSD) form is used), and uses only 20% of the code space.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h3 id="polynomial-root-finding">Polynomial root finding</h3>

<p>Using Horner's method in combination with <a href="Newton's_method" title="wikilink">Newton's method</a>, it is possible to approximate the real roots of a polynomial. The algorithm works as follows. Given a polynomial 

<math display="inline" id="Horner's_method:34">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>n</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{n}(x)
  </annotation>
 </semantics>
</math>

 of degree 

<math display="inline" id="Horner's_method:35">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 with zeros 

<math display="inline" id="Horner's_method:36">
 <semantics>
  <mrow>
   <msub>
    <mi>z</mi>
    <mi>n</mi>
   </msub>
   <mo><</mo>
   <msub>
    <mi>z</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo><</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo><</mo>
   <msub>
    <mi>z</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{n}<z_{n-1}<\cdots<z_{1}
  </annotation>
 </semantics>
</math>

, make some initial guess 

<math display="inline" id="Horner's_method:37">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Horner's_method:38">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mo>></mo>
   <msub>
    <mi>z</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}>z_{1}
  </annotation>
 </semantics>
</math>

. Now iterate the following two steps:</p>

<p>1. Using <a href="Newton's_method" title="wikilink">Newton's method</a>, find the largest zero 

<math display="inline" id="Horner's_method:39">
 <semantics>
  <msub>
   <mi>z</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>z</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{1}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Horner's_method:40">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>n</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{n}(x)
  </annotation>
 </semantics>
</math>

 using the guess 

<math display="inline" id="Horner's_method:41">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

.</p>

<p>2. Using Horner's method, divide out 

<math display="inline" id="Horner's_method:42">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>x</mi>
    <mo>-</mo>
    <msub>
     <mi>z</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x-z_{1})
  </annotation>
 </semantics>
</math>

 to obtain 

<math display="inline" id="Horner's_method:43">
 <semantics>
  <msub>
   <mi>p</mi>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{n-1}
  </annotation>
 </semantics>
</math>

. Return to step 1 but use the polynomial 

<math display="inline" id="Horner's_method:44">
 <semantics>
  <msub>
   <mi>p</mi>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{n-1}
  </annotation>
 </semantics>
</math>

 and the initial guess 

<math display="inline" id="Horner's_method:45">
 <semantics>
  <msub>
   <mi>z</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>z</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{1}
  </annotation>
 </semantics>
</math>

.</p>

<p>These two steps are repeated until all real zeros are found for the polynomial. If the approximated zeros are not precise enough, the obtained values can be used as initial guesses for Newton's method but using the full polynomial rather than the reduced polynomials.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h4 id="example-1">Example</h4>
<figure><b>(Figure)</b>
<figcaption>Polynomial root finding using Horner's method</figcaption>
</figure>

<p>Consider the polynomial,</p>

<p>

<math display="block" id="Horner's_method:46">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mn>6</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <mn>3</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>+</mo>
      <mn>3</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>+</mo>
      <mn>5</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>+</mo>
      <mn>8</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <mn>7</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">6</cn>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <cn type="integer">5</cn>
     </apply>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <cn type="integer">8</cn>
     </apply>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <cn type="integer">7</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{6}(x)=(x-3)(x+3)(x+5)(x+8)(x-2)(x-7)
  </annotation>
 </semantics>
</math>

</p>

<p>which can be expanded to</p>

<p>

<math display="block" id="Horner's_method:47">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mn>6</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mrow>
       <msup>
        <mi>x</mi>
        <mn>6</mn>
       </msup>
       <mo>+</mo>
       <mrow>
        <mn>4</mn>
        <msup>
         <mi>x</mi>
         <mn>5</mn>
        </msup>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mn>72</mn>
       <msup>
        <mi>x</mi>
        <mn>4</mn>
       </msup>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mn>214</mn>
       <msup>
        <mi>x</mi>
        <mn>3</mn>
       </msup>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mn>1127</mn>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mn>1602</mn>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mn>5040.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">6</cn>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">6</cn>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">4</cn>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <cn type="integer">5</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">72</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">4</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">214</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">3</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">1127</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">1602</cn>
       <ci>x</ci>
      </apply>
     </apply>
     <cn type="float">5040.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{6}(x)=x^{6}+4x^{5}-72x^{4}-214x^{3}+1127x^{2}+1602x-5040.
  </annotation>
 </semantics>
</math>

</p>

<p>From the above we know that the largest root of this polynomial is 7 so we are able to make an initial guess of 8. Using Newton's method the first zero of 7 is found as shown in black in the figure to the right. Next 

<math display="inline" id="Horner's_method:48">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)
  </annotation>
 </semantics>
</math>

 is divided by 

<math display="inline" id="Horner's_method:49">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>x</mi>
    <mo>-</mo>
    <mn>7</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>x</ci>
    <cn type="integer">7</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x-7)
  </annotation>
 </semantics>
</math>

 to obtain</p>

<p>

<math display="block" id="Horner's_method:50">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mn>5</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <msup>
       <mi>x</mi>
       <mn>5</mn>
      </msup>
      <mo>+</mo>
      <mrow>
       <mn>11</mn>
       <msup>
        <mi>x</mi>
        <mn>4</mn>
       </msup>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mn>5</mn>
       <msup>
        <mi>x</mi>
        <mn>3</mn>
       </msup>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mn>179</mn>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mn>126</mn>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mpadded width="+1.7pt">
     <mn>720</mn>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">5</cn>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">5</cn>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">11</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">4</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">5</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">3</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">179</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">126</cn>
       <ci>x</ci>
      </apply>
     </apply>
     <cn type="integer">720</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{5}(x)=x^{5}+11x^{4}+5x^{3}-179x^{2}-126x+720\,
  </annotation>
 </semantics>
</math>

</p>

<p>which is drawn in red in the figure to the right. Newton's method is used to find the largest zero of this polynomial with an initial guess of 7. The largest zero of this polynomial which corresponds to the second largest zero of the original polynomial is found at 3 and is circled in red. The degree 5 polynomial is now divided by 

<math display="inline" id="Horner's_method:51">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>x</mi>
    <mo>-</mo>
    <mn>3</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>x</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x-3)
  </annotation>
 </semantics>
</math>

 to obtain</p>

<p>

<math display="block" id="Horner's_method:52">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mn>4</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>x</mi>
      <mn>4</mn>
     </msup>
     <mo>+</mo>
     <mrow>
      <mn>14</mn>
      <msup>
       <mi>x</mi>
       <mn>3</mn>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mn>47</mn>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mn>38</mn>
     <mi>x</mi>
    </mrow>
    <mo>-</mo>
    <mpadded width="+1.7pt">
     <mn>240</mn>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">4</cn>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">4</cn>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">14</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">47</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">38</cn>
      <ci>x</ci>
     </apply>
     <cn type="integer">240</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{4}(x)=x^{4}+14x^{3}+47x^{2}-38x-240\,
  </annotation>
 </semantics>
</math>

</p>

<p>which is shown in yellow. The zero for this polynomial is found at 2 again using Newton's method and is circled in yellow. Horner's method is now used to obtain</p>

<p>

<math display="block" id="Horner's_method:53">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mn>3</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>3</mn>
    </msup>
    <mo>+</mo>
    <mrow>
     <mn>16</mn>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>79</mn>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mpadded width="+1.7pt">
     <mn>120</mn>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">16</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">79</cn>
      <ci>x</ci>
     </apply>
     <cn type="integer">120</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{3}(x)=x^{3}+16x^{2}+79x+120\,
  </annotation>
 </semantics>
</math>

</p>

<p>which is shown in green and found to have a zero at −3. This polynomial is further reduced to</p>

<p>

<math display="block" id="Horner's_method:54">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <mrow>
     <mn>13</mn>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mpadded width="+1.7pt">
     <mn>40</mn>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">13</cn>
      <ci>x</ci>
     </apply>
     <cn type="integer">40</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{2}(x)=x^{2}+13x+40\,
  </annotation>
 </semantics>
</math>

</p>

<p>which is shown in blue and yields a zero of −5. The final root of the original polynomial may be found by either using the final zero as an initial guess for Newton's method, or by reducing 

<math display="inline" id="Horner's_method:55">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{2}(x)
  </annotation>
 </semantics>
</math>

 and solving the linear equation. As can be seen, the expected roots of −8, −5, −3, 2, 3, and 7 were found.</p>
<h4 id="octave-implementation">Octave implementation</h4>

<p>The following <a href="GNU_Octave" title="wikilink">Octave</a> code was used in the example above to implement Horner's method.</p>
<div class="sourceCode"><pre class="sourceCode octave"><code class="sourceCode octave">function [y b] = horner(a,x)
  <span class="co">% Input a is the polynomial coefficient vector, x the value to be evaluated at.</span>
  <span class="co">% The output y is the evaluated polynomial and b the divided coefficient vector.</span>
  b(<span class="fl">1</span>) = a(<span class="fl">1</span>);
  for <span class="bn">i</span> = <span class="fl">2</span>:<span class="fu">length</span>(a)
    b(<span class="bn">i</span>) = a(<span class="bn">i</span>)+x*b(<span class="bn">i</span>-<span class="fl">1</span>);
  end
  y = b(<span class="fu">length</span>(a));
  b = b(<span class="fl">1</span>:<span class="fu">length</span>(b)-<span class="fl">1</span>);
end</code></pre></div>
<h4 id="python-implementation">Python implementation</h4>

<p>The following <a href="Python_(programming_language)" title="wikilink">Python</a> code implements Horner's method.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> horner(x, <span class="op">*</span>polynomial):
    <span class="co">"""A function that implements the Horner Scheme for evaluating a</span>
<span class="co">    polynomial of coefficients *polynomial in x."""</span>
    result <span class="op">=</span> <span class="dv">0</span>
    <span class="cf">for</span> coefficient <span class="op">in</span> polynomial:
        result <span class="op">=</span> result <span class="op">*</span> x <span class="op">+</span> coefficient
    <span class="cf">return</span> result</code></pre></div>
<h4 id="c-implementation">C implementation</h4>

<p>The following <a href="C_(programming_language)" title="wikilink">C</a> code implements Horner's method.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">double</span> HornerEvaluate (<span class="dt">double</span> x, <span class="dt">double</span> * CoefficientsOfPolynomial, <span class="dt">unsigned</span> <span class="dt">int</span> DegreeOfPolynomial)
{
    <span class="co">/*</span>
<span class="co">        We want to evaluate the polynomial in x, of coefficients CoefficientsOfPolynomial, using Horner's method.</span>
<span class="co">        The result is stored in dbResult.</span>
<span class="co">    */</span>
    <span class="dt">double</span> dbResult = <span class="dv">0</span>.;
    <span class="dt">int</span> i;
    <span class="kw">for</span>(i = DegreeOfPolynomial; i &gt;= <span class="dv">0</span>; i--)
    {
        dbResult = dbResult * x + CoefficientsOfPolynomial[i];
    }
    <span class="kw">return</span> dbResult;
}</code></pre></div>
<h2 id="application">Application</h2>

<p>Horner's method can be used to convert between different positional <a href="numeral_system" title="wikilink">numeral systems</a> – in which case <em>x</em> is the base of the number system, and the <em>a</em><sub><em>i</em></sub> coefficients are the digits of the base-<em>x</em> representation of a given number – and can also be used if <em>x</em> is a <a href="matrix_(math)" title="wikilink">matrix</a>, in which case the gain in computational efficiency is even greater. In fact, when <em>x</em> is a matrix, further acceleration is possible which exploits the structure of <a href="matrix_multiplication" title="wikilink">matrix multiplication</a>, and only 

<math display="inline" id="Horner's_method:56">
 <semantics>
  <msqrt>
   <mi>n</mi>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{n}
  </annotation>
 </semantics>
</math>

 instead of <em>n</em> multiplies are needed (at the expense of requiring more storage) using the 1973 method of Paterson and Stockmeyer.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="efficiency">Efficiency</h2>

<p>Evaluation using the monomial form of a degree-<em>n</em> polynomial requires at most <em>n</em> additions and (<em>n</em><sup>2</sup> + <em>n</em>)/2 multiplications, if powers are calculated by repeated multiplication and each monomial is evaluated individually. (This can be reduced to <em>n</em> additions and 2<em>n</em> − 1 multiplications by evaluating the powers of <em>x</em> iteratively.) If numerical data are represented in terms of digits (or bits), then the naive algorithm also entails storing approximately 2<em>n</em> times the number of bits of <em>x</em> (the evaluated polynomial has approximate magnitude <em>x</em><sup><em>n</em></sup>, and one must also store <em>x</em><sup><em>n</em></sup> itself). By contrast, Horner's method requires only <em>n</em> additions and <em>n</em> multiplications, and its storage requirements are only <em>n</em> times the number of bits of <em>x</em>. Alternatively, Horner's method can be computed with <em>n</em> <a href="fused_multiply–add" title="wikilink">fused multiply–adds</a>. Horner's method can also be extended to evaluate the first <em>k</em> derivatives of the polynomial with <em>kn</em> additions and multiplications.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>Horner's method is optimal, in the sense that any algorithm to evaluate an arbitrary polynomial must use at least as many operations. <a href="Alexander_Ostrowski" title="wikilink">Alexander Ostrowski</a> proved in 1954 that the number of additions required is minimal.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> <a href="Victor_Pan" title="wikilink">Victor Pan</a> proved in 1966 that the number of multiplications is minimal.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> However, when <em>x</em> is a matrix, Horner's method is not optimal.</p>

<p>This assumes that the polynomial is evaluated in monomial form and no <a class="uri" href="preconditioning" title="wikilink">preconditioning</a> of the representation is allowed, which makes sense if the polynomial is evaluated only once. However, if preconditioning is allowed and the polynomial is to be evaluated many times, then faster algorithms are possible. They involve a transformation of the representation of the polynomial. In general, a degree-<em>n</em> polynomial can be evaluated using only 

<math display="inline" id="Horner's_method:57">
 <semantics>
  <mrow>
   <mrow>
    <mo>⌊</mo>
    <mrow>
     <mi>n</mi>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
    <mo>⌋</mo>
   </mrow>
   <mo>+</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <floor></floor>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\scriptstyle{\left\lfloor n/2\right\rfloor+2}}
  </annotation>
 </semantics>
</math>

 multiplications and <em>n</em> additions (see <a href="Donald_Knuth" title="wikilink">Knuth</a>: <em><a href="The_Art_of_Computer_Programming" title="wikilink">The Art of Computer Programming</a></em>, Vol.2).</p>
<h2 id="history">History</h2>

<p> Horner's paper entitled "<a href="http://turing.une.edu.au/~ernie/Horner/Horner1819PhilTransRoySocLon.pdf">A new method of solving numerical equations of all orders, by continuous approximation</a>", was read before the Royal Society of London, at its meeting on July 1, 1819, with <a href="Davies_Gilbert" title="wikilink">Davies Gilbert</a>, Vice-President and Treasurer, in the chair; this was the final <a href="http://hdl.handle.net/2027/mdp.39015014105277?urlappend=%3Bseq=158">meeting</a> of the session before the Society adjorned for its Summer recess. When a sequel was read before the Society in 1823, it was again at the final meeting of the session. On both occasions, papers by <a href="James_Ivory_(mathematician)" title="wikilink">James Ivory</a>, FRS, were also read. In 1819, it was Horner's paper that got through to publication in the "Philosophical Transactions".<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> later in the year, Ivory's paper falling by the way, despite Ivory being a Fellow; in 1823, when a total of ten papers were read, fortunes as regards publication, were reversed. But Gilbert, who had strong connections with the West of England and may have had social contact with Horner, resident as Horner was in Bristol and Bath, published his own <a href="http://turing.une.edu.au/~ernie/Horner/Gilbert1823QJSLA.pdf">survey</a> of Horner-type methods earlier in 1823.</p>

<p>Horner's paper in Part II of <em>Philosophical Transactions of the Royal Society of London</em> for 1819 was warmly and expansively welcomed by a <a href="http://turing.une.edu.au/~ernie/Horner/Horner1820MonthlyRev91-4.pdf">reviewer</a> in the issue of <em>The Monthly Review: or, Literary Journal</em> for April, 1820; in comparison, a technical paper by <a href="Charles_Babbage" title="wikilink">Charles Babbage</a> is dismissed curtly in this review. However, the reviewer noted that another, similar method had also recently been published by the architect and mathematical expositor, Peter Nicholson. This theme is developed in a further <a href="http://turing.une.edu.au/~ernie/Horner/Horner1820MonthlyRev93-12.pdf">review</a> of some of Nicholson's books in the issue of <em>The Monthly Review</em> for December, 1820, which in turn ends with notice of the appearance of a booklet by Theophilus Holdred, from whom Nicholson acknowledges he obtained the gist of his approach in the first place, although claiming to have improved upon it. The sequence of reviews is concluded in the issue of <em>The Monthly Review</em> for September, 1821, with the <a href="http://turing.une.edu.au/~ernie/Horner/Horner1821MonthlyRev96-9.pdf">reviewer</a> concluding that whereas Holdred was the first person to discover a direct and general practical solution of numerical equations, he had not reduced it to its simplest form by the time of Horner's publication, and saying that had Holdred published forty years earlier when he first discovered his method, his contribution could be more easily recognized. The reviewer is exceptionally well-informed, even having sighted Horner's preparatory correspondence with <a href="Peter_Barlow_(mathematician)" title="wikilink">Peter Barlow</a> in 1818, seeking work of <a href="François_Budan_de_Boislaurent" title="wikilink">Budan</a>. The Bodlean Library, Oxford has the Editor's annotated copy of <em>The Monthly Review</em> from which it is clear that the most active reviewer in mathematics in 1814 and 1815 (the last years for which this information has been published) was none other than Peter Barlow,one of the foremost specialists on approximation theory of the period, suggesting that it was Barlow, who wrote this sequence of reviews. As it also happened, Henry Atkinson, of Newcastle, devised a similar approximation scheme in 1809; he had consulted his fellow <a class="uri" href="Geordie" title="wikilink">Geordie</a>, <a href="Charles_Hutton" title="wikilink">Charles Hutton</a>, another specialist and a senior colleague of Barlow at the Royal Military Academy, Woolwich, only to be advised that, while his work was publishable, it was unlikely to have much impact. J. R. Young, writing in the mid-1830s, concluded that Holdred's first method replicated Atkinson's while his improved method was only added to Holdred's booklet some months after its first appearance in 1820, when Horner's paper was already in circulation.</p>

<p>The feature of Horner's writing that most distinguishes it from his English contemporaries is the way he draws on the Continental literature, notably the work of <a href="Louis_François_Antoine_Arbogast" title="wikilink">Arbogast</a>. The advocacy, as well as the detraction, of Horner's Method has this as an unspoken subtext. Quite how he gained that familiarity has not been determined. Horner is known to have made a close reading of John Bonneycastle's book on algebra. Bonneycastle recognizes that Arbogast has the general, combinatorial expression for the reversion of series, a project going back at least to Newton. But Bonneycastle's main purpose in mentioning Arbogast is not to praise him, but to observe that Arbogast's notation is incompatible with the approach he adopts. The gap in Horner's reading was the work of <a href="Paolo_Ruffini" title="wikilink">Paolo Ruffini</a>, except that, as far as awareness of Ruffini goes, citations of Ruffini's work by authors, including medical authors, in <em>Philosophical Transactions</em> speak volumes: there are none - Ruffini's <a href="http://hdl.handle.net/2027/njp.32101013501372?urlappend=%3Bseq=695">name</a> only appears in 1814, recording a work he donated to the Royal Society. Ruffini might have done better if his work had appeared in French, as had <a href="Malfatti's_problem" title="wikilink">Malfatti's Problem</a> in the reformulation of <a href="Gergonne" title="wikilink">Joseph Diaz Gergonne</a>, or had he written in French, as had <a href=":it:Antonio_Cagnoli" title="wikilink">Antonio Cagnoli</a>, a source quoted by Bonneycastle on series reversion (today, Cagnoli is in the Italian Wikipedia, as shown, but has yet to make it into either French or English).</p>

<p>Fuller<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> showed that the method in Horner's 1819 paper differs from what afterwards became known as 'Horner's method' and that in consequence the priority for this method should go to Holdred (1920). This view may be compared with the remarks concerning the works of Horner and Holdred in the previous paragraph. Fuller also takes aim at <a href="Augustus_De_Morgan" title="wikilink">Augustus De Morgan</a>. Precocious though Augustus de Morgan was, he was not the reviewer for <em>The Monthly Review</em>, while several others - <a href="Thomas_Stephens_Davies" title="wikilink">Thomas Stephens Davies</a>, J. R. Young, Stephen Fenwick, T. T. Wilkinson - wrote Horner firmly into their records, not least Horner himself, as he published extensively up until the year of his death in 1837. His paper in 1819 was one that would have been difficult to miss. In contrast, the only other mathematical sighting of Holdred is a single named contribution to <em>The Gentleman's Mathematical Companion</em>, an answer to a problem.</p>

<p>It is questionable to what extent it was De Morgan's advocacy of Horner's priority in discovery<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> that led to "Horner's method" being so called in textbooks, but it is true that those suggesting this tend themselves to know of Horner largely through intermediaries, of whom De Morgan made himself a prime example. However, this method <em>qua</em> method was known long before Horner. In reverse chronological order, Horner's method was already known to:</p>
<ul>
<li><a href="Paolo_Ruffini" title="wikilink">Paolo Ruffini</a> in 1809 (see <a href="Ruffini's_rule" title="wikilink">Ruffini's rule</a>)<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></li>
<li><a href="Isaac_Newton" title="wikilink">Isaac Newton</a> in 1669 (but precise reference needed)</li>
<li>the <a href="Chinese_mathematics" title="wikilink">Chinese mathematician</a> <a href="Zhu_Shijie" title="wikilink">Zhu Shijie</a> in the 14th century<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></li>
<li>the <a href="Chinese_mathematics" title="wikilink">Chinese mathematician</a> <a href="Qin_Jiushao" title="wikilink">Qin Jiushao</a> in his <em><a href="Mathematical_Treatise_in_Nine_Sections" title="wikilink">Mathematical Treatise in Nine Sections</a></em> in the 13th century</li>
<li>the <a href="Persian_people" title="wikilink">Persian</a> <a href="Islamic_mathematics" title="wikilink">mathematician</a> <a href="Sharaf_al-Dīn_al-Tūsī" title="wikilink">Sharaf al-Dīn al-Tūsī</a> in the 12th century<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></li>
<li>the Chinese mathematician <a href="Jia_Xian" title="wikilink">Jia Xian</a> in the 11th century (<a href="Song_dynasty" title="wikilink">Song dynasty</a>)</li>
<li><em><a href="The_Nine_Chapters_on_the_Mathematical_Art" title="wikilink">The Nine Chapters on the Mathematical Art</a></em>, a Chinese work of the <a href="Han_Dynasty" title="wikilink">Han Dynasty</a> (202 BC – 220 AD) edited by <a href="Liu_Hui" title="wikilink">Liu Hui</a> (fl. 3rd century).<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></li>
</ul>

<p>However, this observation on its own masks significant differences in conception and also, as noted with Ruffini's work, issues of accessibility.</p>

<p><a href="Qin_Jiushao" title="wikilink">Qin Jiushao</a>, in his <em>Shu Shu Jiu Zhang</em> (<em><a href="Mathematical_Treatise_in_Nine_Sections" title="wikilink">Mathematical Treatise in Nine Sections</a></em>; 1247), presents a portfolio of methods of Horner-type for solving polynomial equations, which was based on earlier works of the 11th century Song dynasty mathematician <a href="Jia_Xian" title="wikilink">Jia Xian</a>; for example, one method is specifically suited to bi-qintics, of which Qin gives an instance, in keeping with the then Chinese custom of case studies. The first person writing in English to note the connection with Horner's method was <a href="Alexander_Wylie_(missionary)" title="wikilink">Alexander Wylie</a>, writing in <em>The North China Herald</em> in 1852; perhaps conflating and misconstruing different Chinese phrases, Wylie calls the method <em>Harmoniously Alternating Evolution</em> (which does not agree with his Chinese, <em>linglong kaifang</em>, not that at that date he uses <a class="uri" href="pinyin" title="wikilink">pinyin</a>), working the case of one of Qin's quartics and giving, for comparison, the working with Horner's method. <a href="Yoshio_Mikami" title="wikilink">Yoshio Mikami</a> in <em>Development of Mathematics in China and Japan</em> published in Leipzig in 1913, gave a detailed description of Qin's method, using the quartic illustrated to the above right in a worked example; he wrote: "who can deny the fact of Horner's illustrious process being used in China at least nearly six long centuries earlier than in Europe ... We of course don't intend in any way to ascribe Horner's invention to a Chinese origin, but the lapse of time sufficiently makes it not altogether impossible that the Europeans could have known of the Chinese method in a direct or indirect way.".<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> However, as Mikami is also aware, it was <em>not altogether impossible</em> that a related work, <em>Si Yuan Yu Jian</em> (<em>Jade Mirror of the Four Unknowns; 1303)</em> by <a href="Zhu_Shijie" title="wikilink">Zhu Shijie</a> might make the shorter journey across to Japan, but seemingly it never did, although another work of Zhu, <em>Suan Xue Qi Meng</em>, had a seminal influence on the development of traditional mathematics in the Edo period, starting in the mid-1600s. <a href="Ulrich_Libbrecht" title="wikilink">Ulrich Libbrecht</a> (at the time teaching in school, but subsequently a professor of comparative philosophy) gave a detailed description in his doctoral thesis of Qin's method, he concluded: <em>It is obvious that this procedure is a Chinese invention....the method was not known in India</em>. He said, Fibonacci probably learned of it from Arabs, who perhaps borrowed from the Chinese.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> Here, the problems is that there is no more evidence for this speculation than there is of the method being known in India. Of course, the extraction of square and cube roots along similar lines is already discussed by <a href="Liu_Hui" title="wikilink">Liu Hui</a> in connection with Problems IV.16 and 22 in <em>Jiu Zhang Suan Shu</em>, while <a href="Wang_Xiaotong" title="wikilink">Wang Xiaotong</a> in the 7th century supposes his readers can solve cubics by an approximation method he does not specify.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Clenshaw_algorithm" title="wikilink">Clenshaw algorithm</a> to evaluate polynomials in <a href="Chebyshev_form" title="wikilink">Chebyshev form</a></li>
<li><a href="De_Boor's_algorithm" title="wikilink">De Boor's algorithm</a> to evaluate <a href="spline_curve" title="wikilink">splines</a> in <a class="uri" href="B-spline" title="wikilink">B-spline</a> form</li>
<li><a href="De_Casteljau's_algorithm" title="wikilink">De Casteljau's algorithm</a> to evaluate polynomials in <a href="Bézier_form" title="wikilink">Bézier form</a></li>
<li><a href="Estrin's_scheme" title="wikilink">Estrin's scheme</a> to facilitate parallelization on modern computer architectures</li>
<li><a href="Lill's_method" title="wikilink">Lill's method</a> to approximate roots graphically</li>
<li><a href="Ruffini's_rule" title="wikilink">Ruffini's rule</a> to divide a polynomial by a binomial of the form x − r</li>
</ul>
<h2 id="references">References</h2>
<h3 id="citations">Citations</h3>
<h3 id="bibliography">Bibliography</h3>
<ul>
<li>

<p>Directly available online via the link, but also reprinted with appraisal in D.E.Smith: <em>A Source Book in Mathematics</em>, McGraw-Hill, 1929; Dover reprint, 2 vols 1959</p></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li>Whittaker E.T. &amp; Robinson G:<a href="https://archive.org/stream/calculusofobserv031400mbp#page/n119/mode/2up/search/100">The Calculus of Observations</a>, London 1924 (Blackie)</li>
</ul>
<ul>
<li></li>
<li></li>
<li>

<p>Yes, really! It looks as though the link is taking you to a completely different work, but you end up at Mikami's book, as you find on checking the specified pages.</p></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li>

<p>, <em><a href="http://archive.org/stream/chineseresearche00wyliuoft#page/158/mode/2up">Jottings on the Science of Chinese Arithmetic</a></em> (reprinted from issues of <em>The North China Herald</em> (1852).</p></li>
<li>T. Holdred (1820), <a href="http://turing.une.edu.au/~ernie/Horner/Holdred1820.pdf">A New Method of Solving Equations with Ease and Expedition; by which the True Value of the Unknown Quantity is Found Without Previous Reduction. With a Supplement, Containing Two Other Methods of Solving Equations, Derived from the Same Principle</a> Richard Watts. Sold by Davis and Dickson, mathematical and philosophical booksellers, 17, St. Martin's-le-Grand; and by the author, 2, Denzel Street, Clare-Market, 56pp. Holdred's method is in the supplement following page numbered 45 (which is the 52nd page of the pdf version).</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li></li>
<li><a href="http://math.fullerton.edu/mathews/n2003/HornerMod.html">Module for Horner's Method by John H. Mathews</a></li>
<li>Qiu Jin-Shao, <a href="http://turing.une.edu.au/~ernie/Chinese/SSJZ.pdf">Shu Shu Jiu Zhang</a> (Cong Shu Ji Cheng ed.)</li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Algebra" title="wikilink">Category:Algebra</a> <a class="uri" href="Category:Polynomials" title="wikilink">Category:Polynomials</a> <a href="Category:Numerical_analysis" title="wikilink">Category:Numerical analysis</a> <a href="Category:Articles_with_example_Python_code" title="wikilink">Category:Articles with example Python code</a> <a href="Category:Articles_with_example_MATLAB/Octave_code" title="wikilink">Category:Articles with example MATLAB/Octave code</a> <a href="Category:Articles_with_example_C_code" title="wikilink">Category:Articles with example C code</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="Florian_Cajori" title="wikilink">Florian Cajori</a>, [<a class="uri" href="http://projecteuclid.org/DPubS/Repository/1.0/Disseminate?view=body&amp;id">http://projecteuclid.org/DPubS/Repository/1.0/Disseminate?view=body&amp;id;</a>;=pdf_1&amp;handle;=euclid.bams/1183421253 Horner's method of approximation anticipated by Ruffini], Bulletin of the American Mathematical Society, Vol. 17, No. 9, pp. 409–414, 1911 (read before the Southwestern Section of the American Mathematical Society on November 26, 1910).<a href="#fnref6">↩</a></li>
<li id="fn7"><em>It is obvious that this procedure is a Chinese invention</em>, Ulrich Librecht, Chinese Mathematics in the Thirteenth Century, Chapter 13, '' Equations of Higher Degree'', p178 Dover, ISBN 0-486-44619-0<a href="#fnref7">↩</a></li>
<li id="fn8">Kripasagar, March 2008, "Efficient Micro Mathematics", Circuit Cellar, issue 212, p. 62.<a href="#fnref8">↩</a></li>
<li id="fn9">Kress, Rainer, "Numerical Analysis", Springer, 1991, p.112.<a href="#fnref9">↩</a></li>
<li id="fn10">Higham, Nicholas. (2002). <em>Accuracy and Stability of Numerical Algorithms</em>. Philadelphia: SIAM. ISBN 0-89871-521-0. Section 5.4.<a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12">Ostrowski, A. M. (1954). "On two problems in abstract algebra connected with Horner's rule", Studies in Math. Mech., pp. 40-48. New York: Academic Press.<a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16">Fuller A. T. :Horner versus Holdred: An Episode in the History of Root Computation, Historia Mathematica 26 (1999), 29–51<a href="#fnref16">↩</a></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23">Temple, Robert. (1986). <em>The Genius of China: 3,000 Years of Science, Discovery, and Invention</em>. With a forward by Joseph Needham. New York: Simon and Schuster, Inc. ISBN 0-671-62028-2. Page 142.<a href="#fnref23">↩</a></li>
<li id="fn24">Yoshio Mikami, Chinese Mathematics in the Thirteenth Century, Chapter 11, Chin Chiu Shao, p77 Chelsea Publishing Co<a href="#fnref24">↩</a></li>
<li id="fn25">Ulrich Libbrecht, Chinese Mathematics in the Thirteenth Century, Chapter 13, Numerial Equations of Higher Degree, p208 Dover, ISBN 0-486-44619-0<a href="#fnref25">↩</a></li>
</ol>
</section>
</body>

