<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="266">Language identification in the limit</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Language identification in the limit</h1>
<hr/>

<p><strong>Language identification in the limit</strong> is a formal model for <a href="inductive_inference" title="wikilink">inductive inference</a>. It was introduced by <a href="E._Mark_Gold" title="wikilink">E. Mark Gold</a> in his paper with the same title <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> In this model, a <a class="uri" href="learner" title="wikilink">learner</a> is provided with presentation (i.e. strings) of some <a href="formal_language" title="wikilink">formal language</a>. The learning is seen as an infinite process. Each time an element of the presentation is read the learner should provide a representation (e.g. a <a href="formal_grammar" title="wikilink">formal grammar</a>) for the language. It is said that a learner can identify in the limit a class of languages if given any presentation of any language in the class the learner will produce only a finite number of wrong representations, and therefore converge on the correct representation in a finite number of steps, without however necessarily being able to announce its correctness since a counterexample to that representation could appear as an element arbitrarily long after.</p>

<p>Gold defined two types of presentations:</p>
<ul>
<li>Text (positive information): an enumeration of all strings the language consists of.</li>
<li>Complete presentation (positive and negative information): an enumeration of all possible strings, each with a label indicating if the string belongs to the language or not.</li>
</ul>
<h2 id="learnability">Learnability</h2>

<p>This model is an early attempt to formally capture the notion of <a class="uri" href="learnability" title="wikilink">learnability</a>. Gold's paper<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> introduces for contrast the stronger models</p>
<ul>
<li><em>Finite identification</em> (where the learner has to announce correctness after a finite number of steps), and</li>
<li><em>Fixed-time identification</em> (where correctness has to be reached after an apriori-specified number of steps).</li>
</ul>

<p>A weaker formal model of learnability is the <em><a href="Probably_approximately_correct_learning" title="wikilink">Probably approximately correct learning</a> (PAC)</em> model, introduced by <a href="Leslie_Valiant" title="wikilink">Leslie Valiant</a> in 1984.</p>
<h2 id="examples">Examples</h2>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Example 4</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>2.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>3.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>4.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>5.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Example 3</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>2.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>3.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>4.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>5.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>6.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>7.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Example 2</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>2.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>3.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>4.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>5.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>6.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>7.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Example 1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>2.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>3.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>4.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>5.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>6.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>7.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>

<p>It is instructive to look at concrete examples of learning sessions the definition of identification in the limit speaks about.</p>
<ul>
<li><strong>Example 1</strong>: fictitious session to learn a <a href="regular_language" title="wikilink">regular language</a> <em>L</em> over the <a href="Formal_language#Words_over_an_alphabet" title="wikilink">alphabet</a> {<em>a</em>,<em>b</em>} from text presentation. In each step, the teacher gives a string belonging to <em>L</em>, and the learner answers a guess for <em>L</em>, encoded as a <a href="regular_expression" title="wikilink">regular expression</a>. In step <strong>3</strong>, the learner's guess is not consistent with the strings seen so far; in step <strong>4</strong>, the teacher gives a string repeatedly. After step <strong>6</strong>, the learner sticks to the regular expression (<em>ab</em>+<em>ba</em>)<sup>*</sup>. If this happens to be a description of the language <em>L</em> the teacher has in mind, it is said that the learner has learned that language. If a computer program for the learner's role would exist that was able to successfully learn each regular language, that class of languages would be <em>identifiable in the limit</em>. Gold has shown that this is not the case.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></li>
<li><strong>Example 2:</strong> a particular learning algorithm always guessing <em>L</em> to be just the union of all strings seen so far. If <em>L</em> is a finite language, the learner will eventually guess it correctly, however, without being able to tell when. Although the guess didn't change during step <strong>3</strong> to <strong>6</strong>, the learner couldn't be sure to be correct. Gold has shown that the class of finite languages is identifibale in the limit.;<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> however, this class is neither finitely nor fixed-time identifiable.</li>
<li><strong>Example 3</strong>: learning from complete presentation by telling. In each step, the teacher gives a string and tells whether it belongs to <em>L</em> () or not (<mtpl></mtpl>). Each possible string is eventually classified in this way by the teacher.</li>
<li><strong>Example 4</strong>: learning from complete presentation by request. The learner gives a query string, the teacher tell whether it belongs to <em>L</em> () or not (); the learner then gives a guess for <em>L</em>, followed by the next query string. In this example, the learner happens to query in each step just the same string as given by the teacher in example 3. In general, Gold has shown that each language class identifiable in the request-presentation setting is also identifiable in the telling-presentation setting,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> since the learner, instead of querying a string, just needs to wait until it is eventually given by the teacher.</li>
</ul>
<h2 id="learnability-characterization">Learnability characterization</h2>

<p><a href="Dana_Angluin" title="wikilink">Dana Angluin</a> gave the characterizations of learnability from text (positive information) in a 1980 paper. <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> If a learner is required to be <a class="uri" href="effective" title="wikilink">effective</a>, then an indexed class of <a href="recursive_language" title="wikilink">recursive languages</a> is learnable in the limit if there is an effective procedure that uniformly enumerates <a href="tell-tale#Formal_language_theory" title="wikilink">tell-tales</a> for each language in the class (Condition 1).<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> It is not hard to see that if we allow an ideal learner (i.e., an arbitrary function), then an indexed class of languages is learnable in the limit if each language in the class has a tell-tale (Condition 2).<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="language-classes-learnable-in-the-limit">Language classes learnable in the limit</h2>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Dividing lines between identifiable and nonidentifiable language classes<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Learnability model</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Anomalous text presentation<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Complete presentation</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Normal text presentation<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>

<p>The table shows which language classes are identifiable in the limit in which learning model. On the right-hand side, each language class is a superclass of all lower classes. Each learning model (i.e. type of presentation) can identify in the limit all classes below it. In particular, the class of finite languages is identifiable in the limit by text presentation (cf. Example 2 <a href="#Examples" title="wikilink">above</a>), while the class of regular languages is not.</p>

<p><em><a href="Pattern_language_(formal_languages)" title="wikilink">Pattern Languages</a></em>, introduced by Dana Angluin in another 1980 paper,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> are also identifiable by normal text presentation; they are omitted in the table, since they are above the singleton and below the primitive recursive language class, but incomparable to the classes in between.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h2 id="sufficient-conditions-for-learnability">Sufficient conditions for learnability</h2>

<p>Condition 1 in Angluin's paper<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> is not always easy to verify. Therefore, people come up with various sufficient conditions for the learnability of a language class. See also <em><a href="Induction_of_regular_languages" title="wikilink">Induction of regular languages</a></em> for learnable subclasses of regular languages.</p>
<h3 id="finite-thickness">Finite thickness</h3>

<p>A class of languages has <strong>finite thickness</strong> if every non-empty set of strings is contained in at most finitely many languages of the class. This is exactly Condition 3 in Angluin's paper.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> Angluin showed that if a class of <a href="recursive_language" title="wikilink">recursive languages</a> has finite thickness, then it is learnable in the limit.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>A class with finite thickness certainly satisfies <a class="uri" href="MEF-condition" title="wikilink">MEF-condition</a> and <a class="uri" href="MFF-condition" title="wikilink">MFF-condition</a>; in other words, finite thickness implies <a href="M-finite_thickness" title="wikilink">M-finite thickness</a>.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<h3 id="finite-elasticity">Finite elasticity</h3>

<p>A class of languages is said to have <strong>finite elasticity</strong> if for every infinite sequence of strings 

<math display="inline" id="Language_identification_in_the_limit:0">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>s</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{0},s_{1},...
  </annotation>
 </semantics>
</math>

 and every infinite sequence of languages in the class 

<math display="inline" id="Language_identification_in_the_limit:1">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>L</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{1},L_{2},...
  </annotation>
 </semantics>
</math>

, there exists a finite number n such that 

<math display="inline" id="Language_identification_in_the_limit:2">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>n</mi>
   </msub>
   <mo>∉</mo>
   <msub>
    <mi>L</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{n}\not\in L_{n}
  </annotation>
 </semantics>
</math>

 implies 

<math display="inline" id="Language_identification_in_the_limit:3">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{n}
  </annotation>
 </semantics>
</math>

 is inconsistent with 

<math display="inline" id="Language_identification_in_the_limit:4">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>s</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>s</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{s_{1},...,s_{n-1}\}
  </annotation>
 </semantics>
</math>

. <a href="http://www.acm.org/pubs/citations/proceedings/colt/114836/p375-motoki/">1</a></p>

<p>It is shown that a class of <a href="recursively_enumerable" title="wikilink">recursively enumerable</a> languages is learnable in the limit if it has finite elasticity.</p>
<h2 id="mind-change-bound">Mind change bound</h2>

<p>A bound over the number of hypothesis changes that occur before convergence.</p>
<h2 id="other-concepts">Other concepts</h2>
<h3 id="infinite-cross-property">Infinite cross property</h3>

<p>A language L has <strong>infinite cross property</strong> within a class of languages 

<math display="inline" id="Language_identification_in_the_limit:5">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℒ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℒ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{L}
  </annotation>
 </semantics>
</math>

 if there is an infinite sequence 

<math display="inline" id="Language_identification_in_the_limit:6">
 <semantics>
  <msub>
   <mi>L</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{i}
  </annotation>
 </semantics>
</math>

 of distinct languages in 

<math display="inline" id="Language_identification_in_the_limit:7">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℒ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℒ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{L}
  </annotation>
 </semantics>
</math>

 and a sequence of finite subset 

<math display="inline" id="Language_identification_in_the_limit:8">
 <semantics>
  <msub>
   <mi>T</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{i}
  </annotation>
 </semantics>
</math>

 such that:</p>
<ul>
<li>

<math display="inline" id="Language_identification_in_the_limit:9">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mn>1</mn>
   </msub>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\sub</mtext>
   </merror>
   <msub>
    <mi>T</mi>
    <mn>2</mn>
   </msub>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\sub</mtext>
   </merror>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">1</cn>
    </apply>
    <mtext>\sub</mtext>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">2</cn>
    </apply>
    <mtext>\sub</mtext>
    <ci>normal-…</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{1}\sub T_{2}\sub...
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Language_identification_in_the_limit:10">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mi>i</mi>
   </msub>
   <mo>∈</mo>
   <msub>
    <mi>L</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{i}\in L_{i}
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Language_identification_in_the_limit:11">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>∉</mo>
   <msub>
    <mi>L</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{i+1}\not\in L_{i}
  </annotation>
 </semantics>
</math>

, and</li>
<li>

<math display="inline" id="Language_identification_in_the_limit:12">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>lim</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msub>
    <msub>
     <mi>T</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lim_{n=\infty}T_{i}=L
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>Note that L is not necessarily a member of the class of language.</p>

<p>It is not hard to see that if there is a language with infinite cross property within a class of languages, then that class of languages has infinite elasticity.</p>
<h2 id="relations-between-concepts">Relations between concepts</h2>
<ul>
<li>Finite thickness implies finite elasticity;<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> the converse is not true.</li>
<li>Finite elasticity and <a href="conservatively_learnable" title="wikilink">conservatively learnable</a> implies the existence of a mind change bound. <a href="http://citeseer.ist.psu.edu/context/1042497/0">2</a></li>
<li>Finite elasticity and <a href="M-finite_thickness" title="wikilink">M-finite thickness</a> implies the existence of a mind change bound. However, <a href="M-finite_thickness" title="wikilink">M-finite thickness</a> alone does not imply the existence of a mind change bound; neither does the existence of a mind change bound imply <a href="M-finite_thickness" title="wikilink">M-finite thickness</a>. <a href="http://citeseer.ist.psu.edu/context/1042497/0">3</a></li>
<li>Existence of a mind change bound implies learnability; the converse is not true.</li>
<li>If we allow for noncomputable learners, then finite elasticity implies the existence of a mind change bound; the converse is not true.</li>
<li>If there is no <a href="accumulation_order" title="wikilink">accumulation order</a> for a class of languages, then there is a language (not necessarily in the class) that has infinite cross property within the class, which in turn implies infinite elasticity of the class.</li>
</ul>
<h2 id="open-questions">Open questions</h2>
<ul>
<li>If a countable class of recursive languages has a mind change bound for noncomputable learners, does the class also have a mind change bound for computable learners, or is the class unlearnable by a computable learner?</li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Formal_languages" title="wikilink">Category:Formal languages</a> <a href="Category:Computational_learning_theory" title="wikilink">Category:Computational learning theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">p.457<a href="#fnref2">↩</a></li>
<li id="fn3">Theorem I.8,I.9, p.470-471<a href="#fnref3">↩</a></li>
<li id="fn4">Theorem I.6, p.469<a href="#fnref4">↩</a></li>
<li id="fn5">Theorem I.3, p.467<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7">p.121 top<a href="#fnref7">↩</a></li>
<li id="fn8">p.123 top<a href="#fnref8">↩</a></li>
<li id="fn9">Table 1, p.452, in (Gold 1967)<a href="#fnref9">↩</a></li>
<li id="fn10">i.e. text presentation, where the string given by the teacher is a <a href="primitive_recursive_function" title="wikilink">primitive recursive function</a> of the current step number, and the learner encodes a language guess as a <a href="Recursively_enumerable" title="wikilink">program that enumerates the language</a><a href="#fnref10">↩</a></li>
<li id="fn11">i.e. text presentation, except for the anomalous text presentation setting<a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13">incomparable to regular and to context-free language class: Theorem 3.10, p.53<a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15">p.123 mid<a href="#fnref15">↩</a></li>
<li id="fn16">p.123 bot, Corollary 2<a href="#fnref16">↩</a></li>
<li id="fn17">; here: Proof of Corollary 29<a href="#fnref17">↩</a></li>
<li id="fn18"></li>
<li id="fn19">Wright, Keith (1989) "Identification of Unions of Languages Drawn from an Identifiable Class". Proc. 2nd Workwhop on Computational Learning Theory, 328-333; with correction in: Motoki, Shinohara, and Wright (1991) "The correct definition of finite elasiticity: corrigendum to identification of unions", Proc. 4th Workshop on Computational Learing Theory, 375-375<a href="#fnref19">↩</a></li>
</ol>
</section>
</body>
</html>
