<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1371">Cyclomatic complexity</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Cyclomatic complexity</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p><strong>Cyclomatic complexity</strong> is a <a href="software_metric" title="wikilink">software metric</a> (measurement), used to indicate the complexity of a program. It is a quantitative measure of the number of linearly independent paths through a program's <a href="source_code" title="wikilink">source code</a>. It was developed by <a href="Thomas_J._McCabe,_Sr." title="wikilink">Thomas J. McCabe, Sr.</a> in 1976.</p>

<p>Cyclomatic complexity is computed using the <a href="control_flow_graph" title="wikilink">control flow graph</a> of the program: the nodes of the <a href="Graph_(mathematics)" title="wikilink">graph</a> correspond to indivisible groups of commands of a program, and a <a href="Directed_graph" title="wikilink">directed</a> edge connects two nodes if the second command might be executed immediately after the first command. Cyclomatic complexity may also be applied to individual <a href="function_(computer_science)" title="wikilink">functions</a>, <a href="modular_programming" title="wikilink">modules</a>, <a href="method_(computer_science)" title="wikilink">methods</a> or <a href="class_(computer_science)" title="wikilink">classes</a> within a program.</p>

<p>One <a href="software_testing" title="wikilink">testing</a> strategy, called <a href="basis_path_testing" title="wikilink">basis path testing</a> by McCabe who first proposed it, is to test each linearly independent path through the program; in this case, the number of test cases will equal the cyclomatic complexity of the program.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="description">Description</h2>
<h3 id="definition">Definition</h3>

<p> The cyclomatic complexity of a section of <a href="source_code" title="wikilink">source code</a> is the number of linearly independent <a href="control_flow" title="wikilink">paths</a> within it. For instance, if the source code contained no <a href="Control_flow" title="wikilink">control flow statements</a> (conditionals or decision points), such as IF statements, the complexity would be 1, since there is only a single path through the code. If the code had one single-condition IF statement, there would be two paths through the code: one where the IF statement evaluates to TRUE and another one where it evaluates to FALSE, so complexity will be 2 for single IF statement with single condition. Two nested single-condition IFs, or one IF with two conditions, would produce a complexity of 4, 2 for each branch within the outer conditional.</p>

<p>Mathematically, the cyclomatic complexity of a <a href="Structured_programming" title="wikilink">structured program</a> is defined with reference to the <a href="control_flow_graph" title="wikilink">control flow graph</a> of the program, a <a href="directed_graph" title="wikilink">directed graph</a> containing the <a href="basic_block" title="wikilink">basic blocks</a> of the program, with an edge between two basic blocks if control may pass from the first to the second. The complexity <strong>M</strong> is then defined as<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<dl>
<dd><em>M</em> = <em>E</em> − <em>N</em> + 2<em>P</em>,
</dd>
</dl>

<p>where</p>
<dl>
<dd><em>E</em> = the number of edges of the graph.
</dd>
<dd><em>N</em> = the number of nodes of the graph.
</dd>
<dd><em>P</em> = the number of <a href="connected_component_(graph_theory)" title="wikilink">connected components</a>.
</dd>
</dl>

<p> An alternative formulation is to use a graph in which each exit point is connected back to the entry point. In this case, the graph is <a href="strongly_connected" title="wikilink">strongly connected</a>, and the cyclomatic complexity of the program is equal to the <a href="cyclomatic_number" title="wikilink">cyclomatic number</a> of its graph (also known as the <a href="Betti_number#Example:_the_first_Betti_number_in_graph_theory" title="wikilink">first Betti number</a>), which is defined as<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<dl>
<dd><em>M</em> = <em>E</em> − <em>N</em> + <em>P</em>.
</dd>
</dl>

<p>This may be seen as calculating the number of <a href="linearly_independent_cycle" title="wikilink">linearly independent cycles</a> that exist in the graph, i.e. those cycles that do not contain other cycles within themselves. Note that because each exit point loops back to the entry point, there is at least one such cycle for each exit point.</p>

<p>For a single program (or subroutine or method), <em>P</em> is always equal to 1. So a simpler formula for a single subroutine is</p>
<dl>
<dd><em>M</em> = <em>E</em> − <em>N</em> + 2.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a>
</dd>
</dl>

<p>Cyclomatic complexity may, however, be applied to several such programs or subprograms at the same time (e.g., to all of the methods in a class), and in these cases <em>P</em> will be equal to the number of programs in question, as each subprogram will appear as a disconnected subset of the graph.</p>

<p>McCabe showed that the cyclomatic complexity of any structured program with only one entrance point and one exit point is equal to the number of decision points (i.e., "if" statements or conditional loops) contained in that program plus one. However, this is true only for decision points counted at the lowest, machine-level instructions. Decisions involving compound predicates like those found in high-level languages like <code>IF cond1 AND cond2 THEN ...</code> should be counted in terms of predicate variables involved, i.e. in this examples one should count two decision points, because at machine level it is equivalent to <code>IF cond1 THEN IF cond2 THEN ...</code>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>Cyclomatic complexity may be extended to a program with multiple exit points; in this case it is equal to:</p>
<dl>
<dd>π − <em>s</em> + 2,
</dd>
</dl>

<p>where π is the number of decision points in the program, and <em>s</em> is the number of exit points.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h3 id="explanation-in-terms-of-algebraic-topology">Explanation in terms of algebraic topology</h3>

<p>An <em>even subgraph</em> of a graph (also known as an <a href="Eulerian_path" title="wikilink">Eulerian subgraph</a>) is one where every vertex is incident with an even number of edges; such subgraphs are unions of cycles and isolated vertices. In the following, even subgraphs will be identified with their edge sets, which is equivalent to only considering those even subgraphs which contain all vertices of the full graph.</p>

<p>The set of all even subgraphs of a graph is closed under <a href="symmetric_difference" title="wikilink">symmetric difference</a>, and may thus be viewed as a vector space over <a class="uri" href="GF(2)" title="wikilink">GF(2)</a>; this vector space is called the <em>cycle space</em> of the graph. The <a href="cyclomatic_number" title="wikilink">cyclomatic number</a> of the graph is defined as the dimension of this space. Since GF(2) has two elements and the cycle space is necessarily finite, the cyclomatic number is also equal to the 2-logarithm of the number of elements in the cycle space.</p>

<p>A basis for the cycle space is easily constructed by first fixing a <a href="Glossary_of_graph_theory#Trees" title="wikilink">maximal spanning forest</a> of the graph, and then considering the cycles formed by one edge not in the forest and the path in the forest connecting the endpoints of that edge; these cycles constitute a basis for the cycle space. Hence, the cyclomatic number also equals the number of edges not in a maximal spanning forest of a graph. Since the number of edges in a maximal spanning forest of a graph is equal to the number of vertices minus the number of components, the formula 

<math display="inline" id="Cyclomatic_complexity:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mo>-</mo>
    <mi>N</mi>
   </mrow>
   <mo>+</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <minus></minus>
     <ci>E</ci>
     <ci>N</ci>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E-N+P
  </annotation>
 </semantics>
</math>

 above for the cyclomatic number follows.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>For the more topologically inclined, cyclomatic complexity can alternatively be defined as a relative <a href="Betti_number" title="wikilink">Betti number</a>, the size of a <a href="relative_homology" title="wikilink">relative homology</a> group:</p>

<p>

<math display="block" id="Cyclomatic_complexity:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mo>:=</mo>
    <mrow>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>G</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>:=</mo>
    <mrow>
     <mrow>
      <mo>rank</mo>
      <msub>
       <mi>H</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>G</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <ci>M</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <interval closure="open">
       <ci>G</ci>
       <ci>t</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <ci>rank</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>H</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <interval closure="open">
       <ci>G</ci>
       <ci>t</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M:=b_{1}(G,t):=\operatorname{rank}H_{1}(G,t),
  </annotation>
 </semantics>
</math>

 which is read as "the first homology of the graph <em>G</em>, relative to the terminal nodes <em>t</em>". This is a technical way of saying "the number of linearly independent paths through the flow graph from an entry to an exit", where:</p>
<ul>
<li>"linearly independent" corresponds to homology, and means one does not double-count backtracking;</li>
<li>"paths" corresponds to <em>first</em> homology: a path is a 1-dimensional object;</li>
<li>"relative" means the path must begin and end at an entry or exit point.</li>
</ul>

<p>This corresponds to the intuitive notion of cyclomatic complexity, and can be calculated as above.</p>

<p>Alternatively, one can compute this via absolute Betti number (absolute homology – not relative) by identifying (gluing together) all the terminal nodes on a given component (or equivalently, draw paths connecting the exits to the entrance), in which case (calling the new, augmented graph 

<math display="inline" id="Cyclomatic_complexity:2">
 <semantics>
  <mover accent="true">
   <mi>G</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{G}
  </annotation>
 </semantics>
</math>

, which is ), one obtains:</p>

<p>

<math display="block" id="Cyclomatic_complexity:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mover accent="true">
       <mi>G</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>rank</mo>
      <msub>
       <mi>H</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mover accent="true">
       <mi>G</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>M</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <ci>normal-~</ci>
       <ci>G</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <ci>rank</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>H</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <ci>normal-~</ci>
       <ci>G</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=b_{1}(\tilde{G})=\operatorname{rank}H_{1}(\tilde{G}).
  </annotation>
 </semantics>
</math>

</p>

<p>It can also be computed via <a class="uri" href="homotopy" title="wikilink">homotopy</a>. If one considers the control flow graph as a 1-dimensional <a href="CW_complex" title="wikilink">CW complex</a> called 

<math display="inline" id="Cyclomatic_complexity:4">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

, then the <a href="fundamental_group" title="wikilink">fundamental group</a> of 

<math display="inline" id="Cyclomatic_complexity:5">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 will be 

<math display="inline" id="Cyclomatic_complexity:6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>π</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\Z</mtext>
    </merror>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>X</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <mtext>\Z</mtext>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{1}(X)=\Z^{n}
  </annotation>
 </semantics>
</math>

. The value of 

<math display="inline" id="Cyclomatic_complexity:7">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n+1
  </annotation>
 </semantics>
</math>

 is the cyclomatic complexity. The fundamental group counts how many loops there are through the graph, up to homotopy, and hence aligns with what we would intuitively expect.</p>

<p>This corresponds to the characterization of cyclomatic complexity as "number of loops plus number of components".</p>
<h2 id="applications">Applications</h2>
<h3 id="limiting-complexity-during-development">Limiting complexity during development</h3>

<p>One of McCabe's original applications was to limit the complexity of routines during program development; he recommended that programmers should count the complexity of the modules they are developing, and split them into smaller modules whenever the cyclomatic complexity of the module exceeded 10.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> This practice was adopted by the <a class="uri" href="NIST" title="wikilink">NIST</a> Structured Testing methodology, with an observation that since McCabe's original publication, the figure of 10 had received substantial corroborating evidence, but that in some circumstances it may be appropriate to relax the restriction and permit modules with a complexity as high as 15. As the methodology acknowledged that there were occasional reasons for going beyond the agreed-upon limit, it phrased its recommendation as: "For each module, either limit cyclomatic complexity to [the agreed-upon limit] or provide a written explanation of why the limit was exceeded."<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h3 id="measuring-the-structuredness-of-a-program">Measuring the "structuredness" of a program</h3>

<p>Section VI of McCabe's 1976 paper is concerned with determining what the control flow graphs (CFGs) of non-<a href="structured_programming" title="wikilink">structured programs</a> look like in terms of their subgraphs, which McCabe identifies. (For details on that part see <a href="structured_program_theorem" title="wikilink">structured program theorem</a>.) McCabe concludes that section by proposing a numerical measure of how close to the structured programming ideal a given program is, i.e. its "structuredness" using McCabe's neologism. McCabe called the measure he devised for this purpose <a href='Essential_complexity_(numerical_measure_of_"structuredness")' title="wikilink">essential complexity</a>.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>In order to calculate this measure, the original CFG is iteratively reduced by identifying subgraphs that have a single-entry and a single-exit point, which are then replaced by a single node. This reduction corresponds to what a human would do if she extracted a subroutine from the larger piece of code. (Nowadays such a process would fall under the umbrella term of <a class="uri" href="refactoring" title="wikilink">refactoring</a>.) McCabe's reduction method was later called <em>condensation</em> in some textbooks, because it was seen as a generalization of the <a href="condensation_(graph_theory)" title="wikilink">condensation to components used in graph theory</a>.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> If a program is structured, then McCabe's reduction/condensation process reduces it to a single CFG node. In contrast, if the program is not structured, the iterative process will identify the irreducible part. The essential complexity measure defined by McCabe is simply the cyclomatic complexity of this irreducible graph, so it will be precisely 1 for all structured programs, but greater than one for non-structured programs.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h3 id="implications-for-software-testing">Implications for software testing</h3>

<p>Another application of cyclomatic complexity is in determining the number of test cases that are necessary to achieve thorough test coverage of a particular module.</p>

<p>It is useful because of two properties of the cyclomatic complexity, <em>M</em>, for a specific module:</p>
<ul>
<li><em>M</em> is an upper bound for the number of test cases that are necessary to achieve a complete <a href="branch_coverage" title="wikilink">branch coverage</a>.</li>
<li><em>M</em> is a lower bound for the number of paths through the control flow graph (CFG). Assuming each test case takes one path, the number of cases needed to achieve <a href="path_coverage" title="wikilink">path coverage</a> is equal to the number of paths that can actually be taken. But some paths may be impossible, so although the number of paths through the CFG is clearly an upper bound on the number of test cases needed for path coverage, this latter number (of <em>possible</em> paths) is sometimes less than <em>M</em>.</li>
</ul>

<p>All three of the above numbers may be equal: branch coverage 

<math display="inline" id="Cyclomatic_complexity:8">
 <semantics>
  <mo>≤</mo>
  <annotation-xml encoding="MathML-Content">
   <leq></leq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq
  </annotation>
 </semantics>
</math>

 cyclomatic complexity 

<math display="inline" id="Cyclomatic_complexity:9">
 <semantics>
  <mo>≤</mo>
  <annotation-xml encoding="MathML-Content">
   <leq></leq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq
  </annotation>
 </semantics>
</math>

 number of paths.</p>

<p>For example, consider a program that consists of two sequential if-then-else statements.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">if</span>( c1() )
   f1();
<span class="kw">else</span>
   f2();

<span class="kw">if</span>( c2() )
   f3();
<span class="kw">else</span>
   f4();</code></pre></div>

<p> In this example, two test cases are sufficient to achieve a complete branch coverage, while four are necessary for complete path coverage. The cyclomatic complexity of the program is 3 (as the strongly connected graph for the program contains 9 edges, 7 nodes and 1 connected component) (9-7+1).</p>

<p>In general, in order to fully test a module all execution paths through the module should be exercised. This implies a module with a high complexity number requires more testing effort than a module with a lower value since the higher complexity number indicates more pathways through the code. This also implies that a module with higher complexity is more difficult for a programmer to understand since the programmer must understand the different pathways and the results of those pathways.</p>

<p>Unfortunately, it is not always practical to test all possible paths through a program. Considering the example above, each time an additional if-then-else statement is added, the number of possible paths doubles. As the program grew in this fashion, it would quickly reach the point where testing all of the paths was impractical.</p>

<p>One common testing strategy, espoused for example by the NIST Structured Testing methodology, is to use the cyclomatic complexity of a module to determine the number of <a href="white-box_testing" title="wikilink">white-box tests</a> that are required to obtain sufficient coverage of the module. In almost all cases, according to such a methodology, a module should have at least as many tests as its cyclomatic complexity; in most cases, this number of tests is adequate to exercise all the relevant paths of the function.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>As an example of a function that requires more than simply branch coverage to test accurately, consider again the above function, but assume that to avoid a bug occurring, any code that calls either f1() or f3() must also call the other. Assuming that the results of c1() and c2() are independent, that means that the function as presented above contains a bug. Branch coverage would allow us to test the method with just two tests, and one possible set of tests would be to test the following cases:</p>
<ul>
<li>c1() returns true and c2() returns true</li>
<li>c1() returns false and c2() returns false</li>
</ul>

<p>Neither of these cases exposes the bug. If, however, we use cyclomatic complexity to indicate the number of tests we require, the number increases to 3. We must therefore test one of the following paths:</p>
<ul>
<li>c1() returns true and c2() returns false</li>
<li>c1() returns false and c2() returns true</li>
</ul>

<p>Either of these tests will expose the bug.</p>
<h3 id="cohesion">Cohesion</h3>

<p>One would also expect that a module with higher complexity would tend to have lower <a href="cohesion_(computer_science)" title="wikilink">cohesion</a> (less than functional cohesion) than a module with lower complexity. The possible correlation between higher complexity measure with a lower level of cohesion is predicated on a module with more decision points generally implementing more than a single well defined function. A 2005 study showed stronger correlations between complexity metrics and an expert assessment of cohesion in the classes studied than the correlation between the expert's assessment and metrics designed to calculate cohesion.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<h3 id="correlation-to-number-of-defects">Correlation to number of defects</h3>

<p>A number of studies have investigated cyclomatic complexity's correlation to the number of defects contained in a function or method.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> Some studies find a positive correlation between cyclomatic complexity and defects: functions and methods that have the highest complexity tend to also contain the most defects, however the correlation between cyclomatic complexity and program size has been demonstrated many times and since program size is not a controllable feature of commercial software, the usefulness of McCabes's number has been called to question. The essence of this observation is that larger programs (more complex programs as defined by McCabe's metric) tend to have more defects. Although this relation is probably true, it isn't commercially useful.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> As a result the metric has not been accepted by commercial software development organizations.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>Studies that controlled for program size (i.e., comparing modules that have different complexities but similar size, typically measured in <a href="lines_of_code" title="wikilink">lines of code</a>) are generally less conclusive, with many finding no significant correlation, while others do find correlation. Some researchers who have studied the area question the validity of the methods used by the studies finding no correlation.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>

<p><a href="Les_Hatton" title="wikilink">Les Hatton</a> claimed (Keynote at TAIC-PART 2008, Windsor, UK, Sept 2008) that McCabe's Cyclomatic Complexity number has the same predictive ability as lines of code.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Complexity" title="wikilink">Complexity</a></li>
<li><a href="Complexity_trap" title="wikilink">Complexity trap</a></li>
<li><a href="Computer_program" title="wikilink">Computer program</a></li>
<li><a href="Computer_programming" title="wikilink">Computer programming</a></li>
<li><a href="Control_flow" title="wikilink">Control flow</a></li>
<li><a href="Decision-to-decision_path" title="wikilink">Decision-to-decision path</a></li>
<li><a href="Design_predicates" title="wikilink">Design predicates</a></li>
<li><a href='Essential_complexity_(numerical_measure_of_"structuredness")' title="wikilink">Essential complexity (numerical measure of "structuredness")</a></li>
<li><a href="Halstead_complexity_measures" title="wikilink">Halstead complexity measures</a></li>
<li><a href="Software_engineering" title="wikilink">Software engineering</a></li>
<li><a href="Software_testing" title="wikilink">Software testing</a></li>
<li><a href="Static_program_analysis" title="wikilink">Static program analysis</a></li>
<li><a href="Synchronization_complexity" title="wikilink">Synchronization complexity</a></li>
<li><a class="uri" href="Maintainability" title="wikilink">Maintainability</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.mathworks.com/discovery/cyclomatic-complexity.html">Generating cyclomatic complexity metrics with Polyspace</a></li>
<li><a href="http://www.leshatton.org/Documents/TAIC2008-29-08-2008.pdf">The role of empiricism in improving the reliability of future software</a></li>
<li><a href="https://sites.google.com/site/maltapplication/">A small C/C++ source code analyzer using the cyclometric complexity metric</a></li>
<li><a href="https://www.cqse.eu/en/blog/mccabe-cyclomatic-complexity/">McCabe's Cyclomatic Complexity and Why We Don't Use It</a></li>
</ul>

<p>"</p>

<p><a href="Category:Software_metrics" title="wikilink">Category:Software metrics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
</ol>
</section>
</body>

