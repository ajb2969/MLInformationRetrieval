<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="935">Optimal binary search tree</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Optimal binary search tree</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, an <strong>optimal binary search tree (BST)</strong>, sometimes called a <strong>weight-balanced binary tree</strong>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> is a <a href="binary_search_tree" title="wikilink">binary search tree</a> which provides the smallest possible search time (or <a href="Expected_value" title="wikilink">expected search time</a>) for a given sequence of accesses (or access probabilities). Optimal BSTs are generally divided into two types: static and dynamic.</p>

<p>In the <strong>static optimality</strong> problem, the tree cannot be modified after it has been constructed. In this case, there exists some particular layout of the nodes of the tree which provides the smallest expected search time for the given access probabilities. Various algorithms exist to construct or approximate the statically optimal tree given the information on the access probabilities of the elements.</p>

<p>In the <strong>dynamic optimality</strong> problem, the tree can be modified at any time, typically by permitting <a href="tree_rotation" title="wikilink">tree rotations</a>. The tree is considered to have a cursor starting at the root which it can move or use to perform modifications. In this case, there exists some minimal-cost sequence of these operations which causes the cursor to visit every node in the target access sequence in order. The <a href="splay_tree" title="wikilink">splay tree</a> is conjectured to have a constant <a href="competitive_ratio" title="wikilink">competitive ratio</a> compared to the dynamically optimal tree in all cases, though this has not yet been proven.</p>
<h2 id="static-optimality">Static optimality</h2>
<h3 id="definition">Definition</h3>

<p>In the static optimality problem as defined by <a href="Donald_E._Knuth" title="wikilink">Knuth</a>,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> we are given a set of 

<math display="inline" id="Optimal_binary_search_tree:0">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 ordered elements and a set of 

<math display="inline" id="Optimal_binary_search_tree:1">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>n</mi>
   </mrow>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2n+1
  </annotation>
 </semantics>
</math>

 probabilities. We will denote the elements 

<math display="inline" id="Optimal_binary_search_tree:2">
 <semantics>
  <msub>
   <mi>a</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1}
  </annotation>
 </semantics>
</math>

 through 

<math display="inline" id="Optimal_binary_search_tree:3">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{n}
  </annotation>
 </semantics>
</math>

 and the probabilities 

<math display="inline" id="Optimal_binary_search_tree:4">
 <semantics>
  <msub>
   <mi>A</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{1}
  </annotation>
 </semantics>
</math>

 through 

<math display="inline" id="Optimal_binary_search_tree:5">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{n}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Optimal_binary_search_tree:6">
 <semantics>
  <msub>
   <mi>B</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{0}
  </annotation>
 </semantics>
</math>

 through 

<math display="inline" id="Optimal_binary_search_tree:7">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{n}
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Optimal_binary_search_tree:8">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}
  </annotation>
 </semantics>
</math>

 is the probability of a search being done for element 

<math display="inline" id="Optimal_binary_search_tree:9">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}
  </annotation>
 </semantics>
</math>

. For 

<math display="inline" id="Optimal_binary_search_tree:10">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>i</mi>
   <mo><</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq i<n
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Optimal_binary_search_tree:11">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{i}
  </annotation>
 </semantics>
</math>

 is the probability of a search being done for an element between 

<math display="inline" id="Optimal_binary_search_tree:12">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Optimal_binary_search_tree:13">
 <semantics>
  <msub>
   <mi>a</mi>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i+1}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Optimal_binary_search_tree:14">
 <semantics>
  <msub>
   <mi>B</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{0}
  </annotation>
 </semantics>
</math>

 is the probability of a search being done for an element strictly less than 

<math display="inline" id="Optimal_binary_search_tree:15">
 <semantics>
  <msub>
   <mi>a</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{0}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Optimal_binary_search_tree:16">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{n}
  </annotation>
 </semantics>
</math>

 is the probability of a search being done for an element strictly greater than 

<math display="inline" id="Optimal_binary_search_tree:17">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{n}
  </annotation>
 </semantics>
</math>

. These 

<math display="inline" id="Optimal_binary_search_tree:18">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>n</mi>
   </mrow>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2n+1
  </annotation>
 </semantics>
</math>

 probabilities cover all possible searches, and therefore add up to one.</p>

<p>The static optimality problem is the <a href="optimization_problem" title="wikilink">optimization problem</a> of finding the binary search tree that minimizes the expected search time, given the 

<math display="inline" id="Optimal_binary_search_tree:19">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>n</mi>
   </mrow>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2n+1
  </annotation>
 </semantics>
</math>

 probabilities. As the number of possible trees on a set of 

<math display="inline" id="Optimal_binary_search_tree:20">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 elements is 

<math display="inline" id="Optimal_binary_search_tree:21">
 <semantics>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mstyle scriptlevel="+1">
     <mtable columnspacing="0.4em" rowspacing="0.2ex">
      <mtr>
       <mtd>
        <mrow>
         <mn>2</mn>
         <mi>n</mi>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd>
        <mi>n</mi>
       </mtd>
      </mtr>
     </mtable>
    </mstyle>
    <mo>)</mo>
   </mrow>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">binomial</csymbol>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>n</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {2n\choose n}\frac{1}{n+1}
  </annotation>
 </semantics>
</math>

,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> which is exponential in 

<math display="inline" id="Optimal_binary_search_tree:22">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, <a href="brute-force_search" title="wikilink">brute-force search</a> is not usually a feasible solution.</p>
<h3 id="knuths-dynamic-programming-algorithm">Knuth's dynamic programming algorithm</h3>

<p>In 1971, Knuth published a relatively straightforward <a href="dynamic_programming" title="wikilink">dynamic programming</a> algorithm capable of constructing the statically optimal tree in only O(n<sup>2</sup>) time.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Knuth's primary insight was that the static optimality problem exhibits <a href="optimal_substructure" title="wikilink">optimal substructure</a>; that is, if a certain tree is statically optimal for a given probability distribution, then its left and right subtrees must also be statically optimal for their appropriate subsets of the distribution.</p>

<p>To see this, consider what Knuth calls the "weighted path length" of a tree. The weighted path length of a tree on n elements is the sum of the lengths of all 2n+1 possible search paths, weighted by their respective probabilities. The tree with the minimal weighted path length is, by definition, statically optimal.</p>

<p>But weighted path lengths have an interesting property. Let P be the weighted path length of a binary tree, P<sub>L</sub> be the weighted path length of its left subtree, and P<sub>R</sub> be the weighted path length of its right subtree. Also let W be the sum of all the probabilities in the tree. Observe that when either subtree is attached to the root, the depth of each of its elements (and thus each of its search paths) is increased by one. Also observe that the root itself has a depth of one. This means that the difference in weighted path length between a tree and its two subtrees is exactly the sum of every single probability in the tree, leading to the following recurrence:</p>

<p>

<math display="inline" id="Optimal_binary_search_tree:23">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>P</mi>
     <mi>L</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>P</mi>
     <mi>R</mi>
    </msub>
    <mo>+</mo>
    <mi>W</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>L</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>R</ci>
     </apply>
     <ci>W</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=P_{L}+P_{R}+W
  </annotation>
 </semantics>
</math>

</p>

<p>This recurrence leads to a natural dynamic programming solution. Let 

<math display="inline" id="Optimal_binary_search_tree:24">
 <semantics>
  <msub>
   <mi>P</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{ij}
  </annotation>
 </semantics>
</math>

 be the weighted path length of the statically optimal search tree for all values between a<sub>i</sub> and a<sub>j+1</sub>, let 

<math display="inline" id="Optimal_binary_search_tree:25">
 <semantics>
  <msub>
   <mi>W</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>W</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{ij}
  </annotation>
 </semantics>
</math>

 be the total weight of that tree, and let 

<math display="inline" id="Optimal_binary_search_tree:26">
 <semantics>
  <msub>
   <mi>R</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{ij}
  </annotation>
 </semantics>
</math>

 be the index of its root. The algorithm can be built using the following formulas:</p>

<p>

<math display="inline" id="Optimal_binary_search_tree:27">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mrow>
      <mi>log</mi>
      <mn>3</mn>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <log></log>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1/\log 3)H
  </annotation>
 </semantics>
</math>

</p>

<p>where H is the <a href="entropy_(information_theory)" title="wikilink">entropy</a> of the probability distribution. Since no optimal binary search tree can ever do better than a weighted path length of</p>

<p>

<math display="inline" id="Optimal_binary_search_tree:28">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mi>log</mi>
       <mi>n</mi>
      </mrow>
     </mrow>
     <mrow>
      <mo>OPT</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>X</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <log></log>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <ci>OPT</ci>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log\log n\operatorname{OPT}(X))
  </annotation>
 </semantics>
</math>

</p>

<p>this approximation is very close.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="dynamic-optimality">Dynamic optimality</h2>
<h3 id="definition-1">Definition</h3>

<p>There are several different definitions of dynamic optimality, all of which are effectively equivalent to within a constant factor in terms of running-time.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> The problem was first introduced implicitly by <a href="Daniel_Sleator" title="wikilink">Sleator</a> and <a href="Robert_Tarjan" title="wikilink">Tarjan</a> in their paper on <a href="splay_tree" title="wikilink">splay trees</a>,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> but <a href="Erik_Demaine" title="wikilink">Demaine</a> et al. give a very good formal statement of it.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>In the dynamic optimality problem, we are given a sequence of accesses x<sub>1</sub>, ..., x<sub>m</sub> on the keys 1, ..., n. For each access, we are given a <a href="Pointer_(computer_programming)" title="wikilink">pointer</a> to the root of our BST and can use the pointer to perform any of the following operations:</p>
<ol>
<li>Move the pointer to the left child of the current node.</li>
<li>Move the pointer to the right child of the current node.</li>
<li>Move the pointer to the parent of the current node.</li>
<li>Perform a single <a href="tree_rotation" title="wikilink">rotation</a> on the current node and its parent.</li>
</ol>

<p>Our BST algorithm can perform any sequence of the above operations as long as the pointer eventually ends up on the node containing the target value x<sub>i</sub>. The time it takes a given dynamic BST algorithm to perform a sequence of accesses is equivalent to the total number of such operations performed during that sequence. Given any sequence of accesses on any set of elements, there is some BST algorithm which performs all accesses using the fewest total operations.</p>

<p>This model defines the fastest possible tree for a given sequence of accesses, but calculating the optimal tree in this sense therefore requires foreknowledge of exactly what the access sequence will be. If we let OPT(X) be the number of operations performed by the strictly optimal tree for an access sequence X, we can say that a tree is dynamically optimal as long as, for any X, it performs X in time O(OPT(X)) (that is, it has a constant <a href="competitive_ratio" title="wikilink">competitive ratio</a>).<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>There are several data structures conjectured to have this property, but none proven. It is an <a href="open_problem" title="wikilink">open problem</a> whether there exists a dynamically optimal data structure in this model.</p>
<h3 id="splay-trees">Splay trees</h3>

<p>The <a href="splay_tree" title="wikilink">splay tree</a> is a data structure invented in 1985 by Daniel Sleator and Robert Tarjan which is conjectured to be dynamically optimal in the required sense. That is, a splay tree is believed to perform any sufficiently long access sequence X in time O(OPT(X)).<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h3 id="tango-trees">Tango trees</h3>

<p>The <a href="tango_tree" title="wikilink">tango tree</a> is a data structure proposed in 2004 by Demaine et al. which has been proven to perform any sufficiently-long access sequence X in time 

<math display="inline" id="Optimal_binary_search_tree:29">
 <semantics>
  <mrow>
   <mi>log</mi>
   <mrow>
    <mi>log</mi>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log\log n
  </annotation>
 </semantics>
</math>

. While this is not dynamically optimal, the competitive ratio of <span class="LaTeX">$\log\log n$</span> is still very small for reasonable values of n.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h3 id="other-results">Other results</h3>

<p>In 2013, <a href="John_Iacono" title="wikilink">John Iacono</a> published a paper which uses the <a href="geometry_of_binary_search_trees" title="wikilink">geometry of binary search trees</a> to provide an algorithm which is dynamically optimal if any binary search tree algorithm is dynamically optimal.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="tree_data_structure" title="wikilink">Trees</a></li>
<li><a href="Splay_tree" title="wikilink">Splay tree</a></li>
<li><a href="Tango_tree" title="wikilink">Tango tree</a></li>
<li><a href="Geometry_of_binary_search_trees" title="wikilink">Geometry of binary search trees</a></li>
<li><a href="List_of_data_structures" title="wikilink">List of data structures</a></li>
</ul>
<h2 id="notes">Notes</h2>

<p>"</p>

<p><a href="Category:Binary_trees" title="wikilink">Category:Binary trees</a> <a href="Category:Search_trees" title="wikilink">Category:Search trees</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
</ol>
</section>
</body>
</html>
