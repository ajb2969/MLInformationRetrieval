<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1364">Minimum spanning tree</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Minimum spanning tree</h1>
<hr/>

<p> Given a <a href="connected_graph" title="wikilink">connected</a>, <a href="undirected_graph" title="wikilink">undirected graph</a>, a <a href="spanning_tree_(mathematics)" title="wikilink">spanning tree</a> of that graph is a <a href="Glossary_of_graph_theory#Subgraphs" title="wikilink">subgraph</a> that is a <a href="tree_graph" title="wikilink">tree</a> and connects all the <a href="Vertex_(graph_theory)" title="wikilink">vertices</a> together. A single graph can have many different spanning trees. We can also assign a <em>weight</em> to each edge, which is a number representing how unfavorable it is, and use this to assign a weight to a spanning tree by computing the sum of the weights of the edges in that spanning tree. A <strong>minimum spanning tree</strong> (<strong>MST</strong>) or <strong>minimum weight spanning tree</strong> is then a spanning tree with weight less than or equal to the weight of every other spanning tree. More generally, any undirected graph (not necessarily connected) has a <strong>minimum spanning forest</strong>, which is a union of minimum spanning trees for its <a href="connected_component_(graph_theory)" title="wikilink">connected components</a>.</p>

<p>One example would be a telecommunications company laying cable to a new neighborhood. If it is constrained to bury the cable only along certain paths (e.g. along roads), then there would be a graph representing which points are connected by those paths. Some of those paths might be more expensive, because they are longer, or require the cable to be buried deeper; these paths would be represented by edges with larger weights. Currency is an acceptable unit for edge weight — there is no requirement for edge lengths to obey normal rules of geometry such as the <a href="triangle_inequality" title="wikilink">triangle inequality</a>. A <em>spanning tree</em> for that graph would be a subset of those paths that has no cycles but still connects to every house; there might be several spanning trees possible. A <em>minimum spanning tree</em> would be one with the lowest total cost, thus would represent the least expensive path for laying the cable.</p>
<h2 id="properties">Properties</h2>
<h3 id="possible-multiplicity">Possible multiplicity</h3>

<p> <em>There may be several minimum spanning trees of the same weight having a minimum number of edges</em>; in particular, if all the edge weights of a given graph are the same, then every spanning tree of that graph is minimum.</p>

<p>If there are <em>n</em> vertices in the graph, then each spanning tree has <em>n</em>-1 edges.</p>
<h3 id="uniqueness">Uniqueness</h3>

<p><em>If each edge has a distinct weight then there will be only one, unique minimum spanning tree</em>. This is true in many realistic situations, such as the telecommunications company example above, where it's unlikely any two paths have <em>exactly</em> the same cost. This generalizes to spanning forests as well.</p>

<p>If the edge weights are not unique, only the (multi-)set of weights in minimum spanning trees is unique, that is the same for all minimum spanning trees.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Proof:</p>
<ol>
<li><a href="Proof_by_contradiction" title="wikilink">Assume the contrary</a>, that there are two different MSTs <em>A</em> and <em>B</em>.</li>
<li>Let <em>e</em><sub>1</sub> be the edge of least weight that is in one of the MSTs and not the other. Without loss of generality, assume <em>e</em><sub>1</sub> is in <em>A</em> but not in <em>B</em>.</li>
<li>As <em>B</em> is a MST, {<em>e</em><sub>1</sub>} 

<math display="inline" id="Minimum_spanning_tree:0">
<semantics>
<mo>∪</mo>
<annotation-xml encoding="MathML-Content">
<union></union>
</annotation-xml>
<annotation encoding="application/x-tex">
   \cup
  </annotation>
</semantics>
</math>
<em>B</em> must contain a cycle <em>C</em>.</li>
<li>Then <em>C</em> has an edge <em>e</em><sub>2</sub> whose weight is greater than the weight of <em>e</em><sub>1</sub>, since all edges in <em>B</em> with less weight are in <em>A</em> by the choice of <em>e</em><sub>1</sub>, and <em>C</em> must have at least one edge that is not in <em>A</em> because otherwise <em>A</em> would contain a cycle in contradiction with its being an MST.</li>
<li>Replacing <em>e</em><sub>2</sub> with <em>e</em><sub>1</sub> in <em>B</em> yields a spanning tree with a smaller weight.</li>
<li>This contradicts the assumption that <em>B</em> is a MST.</li>
</ol>
<h3 id="minimum-cost-subgraph">Minimum-cost subgraph</h3>

<p>If the weights are <em>positive</em>, then a minimum spanning tree is in fact a minimum-cost <a href="Glossary_of_graph_theory#Subgraphs" title="wikilink">subgraph</a> connecting all vertices, since subgraphs containing <a href="Path_(graph_theory)" title="wikilink">cycles</a> necessarily have more total weight.</p>
<h3 id="cycle-property">Cycle property</h3>

<p>''For any cycle <em>C</em> in the graph, if the weight of an edge <em>e</em> of <em>C</em> is larger than the individual weights of all other edges of <em>C</em>, then this edge cannot belong to a MST.''</p>

<p>Proof: <a href="Proof_by_contradiction" title="wikilink">Assume the contrary</a>, i.e. that <em>e</em> belongs to an MST T1. Then deleting <em>e</em> will break T1 into two subtrees with the two ends of <em>e</em> in different subtrees. The remainder of <em>C</em> reconnects the subtrees, hence there is an edge <em>f</em> of <em>C</em> with ends in different subtrees, i.e., it reconnects the subtrees into a tree T2 with weight less than that of T1, because the weight of <em>f</em> is less than the weight of <em>e</em>.</p>
<h3 id="cut-property">Cut property</h3>

<p> ''For any <a href="cut_(graph_theory)" title="wikilink">cut</a> <em>C</em> in the graph, if the weight of an edge <em>e</em> of <em>C</em> is strictly smaller than the weights of all other edges of <em>C</em>, then this edge belongs to all MSTs of the graph.''</p>

<p>Proof: <a href="Reductio_ad_absurdum" title="wikilink">assume the contrary</a>, i.e., in the figure at right, make edge BC (weight 6) part of the MST T instead of edge e (weight 4). Adding e to T will produce a cycle, while replacing BC with e would produce MST of smaller weight. Thus, a tree containing BC is not a MST, a contradiction that violates our assumption. By a similar argument, if more than one edge is of minimum weight across a cut, then each such edge is contained in some minimum spanning tree.</p>
<h3 id="minimum-cost-edge">Minimum-cost edge</h3>

<p>''If the edge of a graph with the minimum cost <em>e</em> is unique, then this edge is included in any MST.''</p>

<p>Proof: if <em>e</em> was not included in the MST, removing any of the (larger cost) edges in the cycle formed after adding <em>e</em> to the MST, would yield a spanning tree of smaller weight.</p>
<h3 id="contraction">Contraction</h3>

<p>''If T is a tree of MST edges, then we can <em>contract</em> T into a single vertex while maintaining the invariant that the MST of the contracted graph plus T gives the MST for the graph before contraction.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="algorithms">Algorithms</h2>

<p>In all of the algorithms below, "m" is the number of edges in the graph and "n" is the number of vertices.</p>
<h3 id="classic-algorithms">Classic algorithms</h3>

<p>The first algorithm for finding a minimum spanning tree was developed by Czech scientist <a href="Otakar_Borůvka" title="wikilink">Otakar Borůvka</a> in 1926 (see <a href="Borůvka's_algorithm" title="wikilink">Borůvka's algorithm</a>). Its purpose was an efficient electrical coverage of <a class="uri" href="Moravia" title="wikilink">Moravia</a>. The algorithm proceeds in a sequence of stages. In each stage, called <em>Boruvka step</em>, it identifies a forest <em>F</em> consisting of the minimum-weight edge incident to each vertex in the graph <em>G</em>, then forms the graph G1=G\F as the input to the next step. Here G\F denotes the graph derived from G by contracting edges in F (by the <a href="#Cut_property" title="wikilink">Cut property</a>, these edges belong to the MST). Each Boruvka step takes linear time. Since the number of vertices is reduced by at least half in each step, Boruvka's algorithm takes O(<em>m</em> log <em>n</em>) time.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>A second algorithm is <a href="Prim's_algorithm" title="wikilink">Prim's algorithm</a>, which was invented by Jarnik in 1930 and rediscovered by Prim in 1957 and Dijkstra in 1959. Basically, it grows the MST (T) one edge at a time. Initially, T contains an arbitrary vertex. In each step, T is augmented with the least-weight edge (x,y) such that x is in T and y is not yet in T. By the <a href="#Cut_property" title="wikilink">Cut property</a>, all edges added to T are in the MST. Its run-time is either O(<em>m</em> log <em>n</em>) or O(<em>m</em> + <em>n</em> log <em>n</em>), depending on the data-structures used.</p>

<p>A third algorithm commonly in use is the <a href="Kruskal's_algorithm" title="wikilink">Kruskal's algorithm</a>, which also takes O(<em>m</em> log <em>n</em>) time.</p>

<p>A fourth algorithm, not as commonly used, is the <a href="reverse-delete_algorithm" title="wikilink">reverse-delete algorithm</a>, which is the reverse of Kruskal's algorithm. Its runtime is O(<em>m</em> log <em>n</em> (log log <em>n</em>)<sup>3</sup>).</p>

<p>All these four are <a href="greedy_algorithm" title="wikilink">greedy algorithms</a>. Since they run in polynomial time, the problem of finding such trees is in <strong><a href="FP_(complexity)" title="wikilink">FP</a></strong>, and related <a href="decision_problem" title="wikilink">decision problems</a> such as determining whether a particular edge is in the MST or determining if the minimum total weight exceeds a certain value are in <strong><a href="P_(complexity)" title="wikilink">P</a></strong>.</p>
<h3 id="faster-algorithms">Faster algorithms</h3>

<p>Several researchers have tried to find more computationally-efficient algorithms.</p>

<p>In a comparison model, in which the only allowed operations on edge weights are pairwise comparisons,  found a <a href="Expected_linear_time_MST_algorithm" title="wikilink">linear time randomized algorithm</a> based on a combination of Borůvka's algorithm and the reverse-delete algorithm.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>The fastest non-randomized comparison-based algorithm with known complexity, by <a href="Bernard_Chazelle" title="wikilink">Bernard Chazelle</a>, is based on the <a href="soft_heap" title="wikilink">soft heap</a>, an approximate priority queue.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Its running time is <em><a href="Big_O_notation" title="wikilink">O</a></em>(<em>m</em> α(<em>m</em>,<em>n</em>)), where α is the classical functional <a href="Ackermann_function#Inverse" title="wikilink">inverse of the Ackermann function</a>. The function α grows extremely slowly, so that for all practical purposes it may be considered a constant no greater than 4; thus Chazelle's algorithm takes very close to linear time.</p>
<h3 id="linear-time-algorithms-in-special-cases">Linear-time algorithms in special cases</h3>
<h4 id="dense-graphs">Dense graphs</h4>

<p>If the graph is dense (i.e. <em>m</em>/<em>n</em> ≥ log log log <em>n</em>), then a deterministic algorithm by Fredman and Tarjan finds the MST in time O(<em>m</em>).<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> The algorithm executes a number of phases. Each phase executes <a href="Prim's_algorithm" title="wikilink">Prim's algorithm</a> many times, each for a limited number of steps. The run-time of each phase is O(<em>m</em>+<em>n</em>). If the number of vertices before a phase is 

<math display="inline" id="Minimum_spanning_tree:1">
<semantics>
<msup>
<mi>n</mi>
<mo>′</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>n</ci>
<ci>normal-′</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n^{\prime}
  </annotation>
</semantics>
</math>

, the number of vertices remaining after a phase is at most 

<math display="inline" id="Minimum_spanning_tree:2">
<semantics>
<mrow>
<msup>
<mi>n</mi>
<mo>′</mo>
</msup>
<mo>/</mo>
<msup>
<mn>2</mn>
<mrow>
<mi>m</mi>
<mo>/</mo>
<msup>
<mi>n</mi>
<mo>′</mo>
</msup>
</mrow>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>n</ci>
<ci>normal-′</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<apply>
<divide></divide>
<ci>m</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>n</ci>
<ci>normal-′</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   n^{\prime}/2^{m/n^{\prime}}
  </annotation>
</semantics>
</math>

. Hence, at most 

<math display="inline" id="Minimum_spanning_tree:3">
<semantics>
<mrow>
<mi>log</mi>
<mo>*</mo>
<mi>n</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<log></log>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \log*{n}
  </annotation>
</semantics>
</math>

 phases are needed, which gives a linear run-time for dense graphs.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>There are other algorithms that work in linear time on dense graphs.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h4 id="integer-weights">Integer weights</h4>

<p>If the edge weights are integers represented in binary, then deterministic algorithms are known that solve the problem in <em>O</em>(<em>m</em> + <em>n</em>) integer operations.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> Whether the problem can be solved <em>deterministically</em> for a <em>general graph</em> in <em>linear time</em> by a comparison-based algorithm remains an open question.</p>
<h3 id="decision-trees">Decision trees</h3>

<p>Given graph <em>G</em> where the nodes and edges are fixed but the weights are unknown, it is possible to construct a binary <a href="decision_tree" title="wikilink">decision tree</a> (DT) for calculating the MST for any permutation of weights. Each internal node of the DT contains a comparison between two edges, e.g. "Is the weight of the edge between <em>x</em> and <em>y</em> larger than the weight of the edge between <em>w</em> and <em>z</em>?". The two children of the node correspond to the two possible answers "yes" or "no". In each leaf of the DT, there is a list of edges from <em>G</em> that correspond to an MST. The runtime complexity of a DT is the largest number of queries required to find the MST, which is just the depth of the DT. A DT for a graph <em>G</em> is called <em>optimal</em> if it has the smallest depth of all correct DTs for <em>G</em>.</p>

<p>For every integer <em>r</em>, it is possible to find optimal decision trees for all graphs on <em>r</em> vertices by <a href="brute-force_search" title="wikilink">brute-force search</a>. This search proceeds in two steps.</p>

<p><strong>A. Generating all potential DTs</strong></p>
<ul>
<li>There are 

<math display="inline" id="Minimum_spanning_tree:4">
<semantics>
<msup>
<mn>2</mn>
<mrow>
<mo>(</mo>
<mstyle scriptlevel="+1">
<mtable columnspacing="0.4em" rowspacing="0.2ex">
<mtr>
<mtd>
<mi>r</mi>
</mtd>
</mtr>
<mtr>
<mtd>
<mn>2</mn>
</mtd>
</mtr>
</mtable>
</mstyle>
<mo>)</mo>
</mrow>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<apply>
<csymbol cd="latexml">binomial</csymbol>
<ci>r</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   2^{r\choose 2}
  </annotation>
</semantics>
</math>

 different graphs on <em>r</em> vertices.</li>
<li>For each graph, an MST can always be found using <em>r</em>(<em>r</em>-1) comparisons, e.g. by <a href="Prim's_algorithm" title="wikilink">Prim's algorithm</a>.</li>
<li>Hence, the depth of an optimal DT is less than 

<math display="inline" id="Minimum_spanning_tree:5">
<semantics>
<msup>
<mi>r</mi>
<mn>2</mn>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>r</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   r^{2}
  </annotation>
</semantics>
</math>

.</li>
<li>Hence, the number of internal nodes in an optimal DT is less than 

<math display="inline" id="Minimum_spanning_tree:6">
<semantics>
<msup>
<mn>2</mn>
<msup>
<mi>r</mi>
<mn>2</mn>
</msup>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>r</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   2^{r^{2}}
  </annotation>
</semantics>
</math>

.</li>
<li>Every internal node compares two edges. The number of edges is at most 

<math display="inline" id="Minimum_spanning_tree:7">
<semantics>
<msup>
<mi>r</mi>
<mn>2</mn>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>r</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   r^{2}
  </annotation>
</semantics>
</math>

 so the different number of comparisons is at most 

<math display="inline" id="Minimum_spanning_tree:8">
<semantics>
<msup>
<mi>r</mi>
<mn>4</mn>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>r</ci>
<cn type="integer">4</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   r^{4}
  </annotation>
</semantics>
</math>

.</li>
<li>Hence, the number of potential DTs is less than

<math display="block" id="Minimum_spanning_tree:9">
<semantics>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>r</mi>
<mn>4</mn>
</msup>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mn>2</mn>
<msup>
<mi>r</mi>
<mn>2</mn>
</msup>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</msup>
<mo>=</mo>
<msup>
<mi>r</mi>
<msup>
<mn>2</mn>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msup>
<mi>r</mi>
<mn>2</mn>
</msup>
<mo>+</mo>
<mn>2</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</msup>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>r</ci>
<cn type="integer">4</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>r</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>r</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>r</ci>
<cn type="integer">2</cn>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   {(r^{4})}^{(2^{r^{2}})}=r^{2^{(r^{2}+2)}}
  </annotation>
</semantics>
</math>

.</li>
</ul>

<p><strong>B. Identifying the correct DTs</strong> To check if a DT is correct, it should be checked on all possible permutations of the edge weights.</p>
<ul>
<li>The number of such permutations is at most 

<math display="inline" id="Minimum_spanning_tree:10">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>r</mi>
<mn>2</mn>
</msup>
<mo stretchy="false">)</mo>
</mrow>
<mo lspace="0pt" rspace="3.5pt">!</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<factorial></factorial>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>r</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (r^{2})!
  </annotation>
</semantics>
</math>

.</li>
<li>For each permutation, solve the MST problem on the given graph using any existing algorithm, and compare the result to the answer given by the DT.</li>
<li>The running time of any MST algorithm is at most 

<math display="inline" id="Minimum_spanning_tree:11">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>r</mi>
<mn>2</mn>
</msup>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>r</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (r^{2})
  </annotation>
</semantics>
</math>

, so the total time required to check all permutations is at most 

<math display="inline" id="Minimum_spanning_tree:12">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msup>
<mi>r</mi>
<mn>2</mn>
</msup>
<mo>+</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo lspace="0pt" rspace="3.5pt">!</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<factorial></factorial>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>r</ci>
<cn type="integer">2</cn>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (r^{2}+1)!
  </annotation>
</semantics>
</math>

.</li>
</ul>

<p>Hence, the total time required for finding an optimal DT for <em>all</em> graphs with <em>r</em> vertices is

<math display="block" id="Minimum_spanning_tree:13">
<semantics>
<mrow>
<msup>
<mn>2</mn>
<mrow>
<mo>(</mo>
<mstyle scriptlevel="+1">
<mtable columnspacing="0.4em" rowspacing="0.2ex">
<mtr>
<mtd>
<mi>r</mi>
</mtd>
</mtr>
<mtr>
<mtd>
<mn>2</mn>
</mtd>
</mtr>
</mtable>
</mstyle>
<mo>)</mo>
</mrow>
</msup>
<mo>⋅</mo>
<msup>
<mi>r</mi>
<msup>
<mn>2</mn>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msup>
<mi>r</mi>
<mn>2</mn>
</msup>
<mo>+</mo>
<mn>2</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</msup>
</msup>
<mo>⋅</mo>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msup>
<mi>r</mi>
<mn>2</mn>
</msup>
<mo>+</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo lspace="0pt" rspace="3.5pt">!</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-⋅</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<apply>
<csymbol cd="latexml">binomial</csymbol>
<ci>r</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>r</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>r</ci>
<cn type="integer">2</cn>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<apply>
<factorial></factorial>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>r</ci>
<cn type="integer">2</cn>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   2^{r\choose 2}\cdot r^{2^{(r^{2}+2)}}\cdot(r^{2}+1)!
  </annotation>
</semantics>
</math>

, which is less than

<math display="block" id="Minimum_spanning_tree:14">
<semantics>
<msup>
<mn>2</mn>
<msup>
<mn>2</mn>
<mrow>
<msup>
<mi>r</mi>
<mn>2</mn>
</msup>
<mo>+</mo>
<mrow>
<mi>o</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>r</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</msup>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>r</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<times></times>
<ci>o</ci>
<ci>r</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   2^{2^{r^{2}+o(r)}}
  </annotation>
</semantics>
</math>

.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> </p>
<h3 id="optimal-algorithm">Optimal algorithm</h3>

<p>Seth Pettie and Vijaya Ramachandran have found a provably optimal deterministic comparison-based minimum spanning tree algorithm.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> The following is a simplified description of the algorithm.</p>
<ol>
<li>Let 

<math display="inline" id="Minimum_spanning_tree:15">
<semantics>
<mrow>
<mi>r</mi>
<mo>=</mo>
<mrow>
<mi>log</mi>
<mrow>
<mi>log</mi>
<mrow>
<mi>log</mi>
<mi>n</mi>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>r</ci>
<apply>
<log></log>
<apply>
<log></log>
<apply>
<log></log>
<ci>n</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   r=\log\log\log n
  </annotation>
</semantics>
</math>

, where <em>n</em> is the number of vertices. Find all optimal decision trees on <em>r</em> vertices. This can be done in time O(<em>n</em>) (see <a href="#Decision_trees" title="wikilink">Decision trees</a> above).</li>
<li>Partition the graph to components with at most <em>r</em> vertices in each component. This partition can be done in time O(<em>m</em>).</li>
<li>Use the optimal decision trees to find an MST for each component.</li>
<li>Contract each connected component spanned by the MSTs to a single vertex.</li>
<li>It is possible to prove that the resulting graph has at most <em>n</em>/<em>r</em> vertices. Hence, the graph is dense and we can use any algorithm which works on <a href="#Dense_graphs" title="wikilink">Dense graphs</a> in time O(<em>m</em>).</li>
</ol>

<p>The runtime of all steps in the algorithm is O(<em>m</em>), <em>except for the step of using the decision trees</em>. We don't know the runtime of this step, but we know that it is optimal - no algorithm can do better than the optimal decision tree.</p>

<p>Thus, this algorithm has the peculiar property that it is <em>provably optimal</em> although its runtime complexity is <em>unknown</em>.</p>
<h3 id="parallel-and-distributed-algorithms">Parallel and distributed algorithms</h3>

<p>Research has also considered <a href="parallel_algorithm" title="wikilink">parallel algorithms</a> for the minimum spanning tree problem. With a linear number of processors it is possible to solve the problem in 

<math display="inline" id="Minimum_spanning_tree:16">
<semantics>
<mrow>
<mi>O</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>log</mi>
<mi>n</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>O</ci>
<apply>
<log></log>
<ci>n</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   O(\log n)
  </annotation>
</semantics>
</math>

 time.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a>  demonstrate an algorithm that can compute MSTs 5 times faster on 8 processors than an optimized sequential algorithm.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>

<p>Other specialized algorithms have been designed for computing minimum spanning trees of a graph so large that most of it must be stored on disk at all times. These <em>external storage</em> algorithms, for example as described in "Engineering an External Memory Minimum Spanning Tree Algorithm" by Roman, Dementiev et al.,<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> can operate, by authors' claims, as little as 2 to 5 times slower than a traditional in-memory algorithm. They rely on efficient <a href="external_sorting" title="wikilink">external storage sorting algorithms</a> and on <a href="graph_contraction" title="wikilink">graph contraction</a> techniques for reducing the graph's size efficiently.</p>

<p>The problem can also be approached in a <a href="distributed_computing" title="wikilink">distributed manner</a>. If each node is considered a computer and no node knows anything except its own connected links, one can still calculate the <a href="distributed_minimum_spanning_tree" title="wikilink">distributed minimum spanning tree</a>.</p>
<h2 id="mst-on-complete-graphs">MST on complete graphs</h2>

<p><a href="Alan_M._Frieze" title="wikilink">Alan M. Frieze</a> showed that given a <a href="complete_graph" title="wikilink">complete graph</a> on <em>n</em> vertices, with edge weights that are independent identically distributed random variables with distribution function 

<math display="inline" id="Minimum_spanning_tree:17">
<semantics>
<mi>F</mi>
<annotation-xml encoding="MathML-Content">
<ci>F</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   F
  </annotation>
</semantics>
</math>

 satisfying 

<math display="inline" id="Minimum_spanning_tree:18">
<semantics>
<mrow>
<mrow>
<msup>
<mi>F</mi>
<mo>′</mo>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>&gt;</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<gt></gt>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>F</ci>
<ci>normal-′</ci>
</apply>
<cn type="integer">0</cn>
</apply>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   F^{\prime}(0)&gt;0
  </annotation>
</semantics>
</math>

, then as <em>n</em> approaches <a href="Extended_real_number_line" title="wikilink">+∞</a> the expected weight of the MST approaches 

<math display="inline" id="Minimum_spanning_tree:19">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>ζ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mn>3</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>/</mo>
<msup>
<mi>F</mi>
<mo>′</mo>
</msup>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>ζ</ci>
<cn type="integer">3</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>F</ci>
<ci>normal-′</ci>
</apply>
</apply>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \zeta(3)/F^{\prime}(0)
  </annotation>
</semantics>
</math>

, where 

<math display="inline" id="Minimum_spanning_tree:20">
<semantics>
<mi>ζ</mi>
<annotation-xml encoding="MathML-Content">
<ci>ζ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \zeta
  </annotation>
</semantics>
</math>

 is the <a href="Riemann_zeta_function" title="wikilink">Riemann zeta function</a>. Frieze and <a href="J._Michael_Steele" title="wikilink">Steele</a> also proved convergence in probability. <a href="Svante_Janson" title="wikilink">Svante Janson</a> proved a <a href="central_limit_theorem" title="wikilink">central limit theorem</a> for weight of the MST.</p>

<p>For uniform random weights in 

<math display="inline" id="Minimum_spanning_tree:21">
<semantics>
<mrow>
<mo stretchy="false">[</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo stretchy="false">]</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<interval closure="closed">
<cn type="integer">0</cn>
<cn type="integer">1</cn>
</interval>
</annotation-xml>
<annotation encoding="application/x-tex">
   [0,1]
  </annotation>
</semantics>
</math>

, the exact expected size of the minimum spanning tree has been computed for small complete graphs.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">

<p>Vertices</p></th>
<th style="text-align: left;">

<p>Expected size</p></th>
<th style="text-align: left;">

<p>Approximative expected size</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p>2</p></td>
<td style="text-align: left;">

<p>1 / 2</p></td>
<td style="text-align: left;">

<p>0.5</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>3</p></td>
<td style="text-align: left;">

<p>3 / 4</p></td>
<td style="text-align: left;">

<p>0.75</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>4</p></td>
<td style="text-align: left;">

<p>31 / 35</p></td>
<td style="text-align: left;">

<p>0.8857143</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>5</p></td>
<td style="text-align: left;">

<p>893 / 924</p></td>
<td style="text-align: left;">

<p>0.9664502</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>6</p></td>
<td style="text-align: left;">

<p>278 / 273</p></td>
<td style="text-align: left;">

<p>1.0183151</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>7</p></td>
<td style="text-align: left;">

<p>30739 / 29172</p></td>
<td style="text-align: left;">

<p>1.053716</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>8</p></td>
<td style="text-align: left;">

<p>199462271 / 184848378</p></td>
<td style="text-align: left;">

<p>1.0790588</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>9</p></td>
<td style="text-align: left;">

<p>126510063932 / 115228853025</p></td>
<td style="text-align: left;">

<p>1.0979027</p></td>
</tr>
</tbody>
</table>
<h2 id="applications">Applications</h2>

<p>Minimum spanning trees have direct applications in the design of networks, including <a href="computer_network" title="wikilink">computer networks</a>, <a href="telecommunications_network" title="wikilink">telecommunications networks</a>, <a href="transport_network" title="wikilink">transportation networks</a>, <a href="water_supply_network" title="wikilink">water supply networks</a>, and <a href="electrical_grid" title="wikilink">electrical grids</a> (which they were first invented for, as mentioned above).<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> They are invoked as subroutines in algorithms for other problems, including the <a href="Christofides_algorithm" title="wikilink">Christofides algorithm</a> for approximating the <a href="traveling_salesman_problem" title="wikilink">traveling salesman problem</a>,<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> approximating the multi-terminal minimum cut problem (which is equivalent in the single-terminal case to the <a href="maximum_flow_problem" title="wikilink">maximum flow problem</a>),<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> and approximating the minimum-cost weighted perfect <a href="matching_(graph_theory)" title="wikilink">matching</a>.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>

<p>Other practical applications based on minimal spanning trees include:</p>
<ul>
<li><a href="Taxonomy_(general)" title="wikilink">Taxonomy</a>.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></li>
<li><a href="Cluster_analysis" title="wikilink">Cluster analysis</a>: clustering points in the plane,<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> <a href="single-linkage_clustering" title="wikilink">single-linkage clustering</a> (a method of <a href="hierarchical_clustering" title="wikilink">hierarchical clustering</a>),<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> graph-theoretic clustering,<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> and clustering <a href="gene_expression" title="wikilink">gene expression</a> data.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></li>
<li>Constructing trees for <a href="broadcasting_(networking)" title="wikilink">broadcasting</a> in computer networks.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> On Ethernet networks this is accomplished by means of the <a href="Spanning_tree_protocol" title="wikilink">Spanning tree protocol</a>.</li>
<li><a href="Image_registration" title="wikilink">Image registration</a><a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> and <a href="Image_segmentation" title="wikilink">segmentation</a><a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> — see <a href="minimum_spanning_tree-based_segmentation" title="wikilink">minimum spanning tree-based segmentation</a>.</li>
<li>Curvilinear <a href="feature_extraction" title="wikilink">feature extraction</a> in <a href="computer_vision" title="wikilink">computer vision</a>.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a></li>
<li><a href="Handwriting_recognition" title="wikilink">Handwriting recognition</a> of mathematical expressions.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></li>
<li><a href="Circuit_design" title="wikilink">Circuit design</a>: implementing efficient multiple constant multiplications, as used in <a href="finite_impulse_response" title="wikilink">finite impulse response</a> filters.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a></li>
<li><a class="uri" href="Regionalisation" title="wikilink">Regionalisation</a> of socio-geographic areas, the grouping of areas into homogeneous, contiguous regions.<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a></li>
<li>Comparing <a class="uri" href="ecotoxicology" title="wikilink">ecotoxicology</a> data.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a></li>
<li>Topological <a class="uri" href="observability" title="wikilink">observability</a> in power systems.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a></li>
<li>Measuring homogeneity of two-dimensional materials.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a></li>
<li>Minimax <a href="process_control" title="wikilink">process control</a>.<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a></li>
<li>Minimum spanning trees can also be used to describe financial markets.<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a> A correlation matrix can be created by calculating a coefficient of correlation between any two stocks.This matrix can be represented topologically as a complex network and a minimum spanning tree can be constructed to visualize relationships.</li>
</ul>
<h2 id="related-problems">Related problems</h2>

<p>The problem of finding the <a href="Steiner_tree" title="wikilink">Steiner tree</a> of a subset of the vertices, that is, minimum tree that spans the given subset, is known to be <a class="uri" href="NP-Complete" title="wikilink">NP-Complete</a>.<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a></p>

<p>A related problem is the <a href="k-minimum_spanning_tree" title="wikilink"><em>k</em>-minimum spanning tree</a> (<em>k</em>-MST), which is the tree that spans some subset of <em>k</em> vertices in the graph with minimum weight.</p>

<p>A set of <em>k-smallest spanning trees</em> is a subset of <em>k</em> spanning trees (out of all possible spanning trees) such that no spanning tree outside the subset has smaller weight.<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a><a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a><a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a> (Note that this problem is unrelated to the <em>k</em>-minimum spanning tree.)</p>

<p>The <a href="Euclidean_minimum_spanning_tree" title="wikilink">Euclidean minimum spanning tree</a> is a spanning tree of a graph with edge weights corresponding to the Euclidean distance between vertices which are points in the plane (or space).</p>

<p>The <a href="rectilinear_minimum_spanning_tree" title="wikilink">rectilinear minimum spanning tree</a> is a spanning tree of a graph with edge weights corresponding to the <a href="rectilinear_distance" title="wikilink">rectilinear distance</a> between vertices which are points in the plane (or space).</p>

<p>In the <a href="distributed_computing" title="wikilink">distributed model</a>, where each node is considered a computer and no node knows anything except its own connected links, one can consider <a href="distributed_minimum_spanning_tree" title="wikilink">distributed minimum spanning tree</a>. The mathematical definition of the problem is the same but there are different approaches for a solution.</p>

<p>The <a href="capacitated_minimum_spanning_tree" title="wikilink">capacitated minimum spanning tree</a> is a tree that has a marked node (origin, or root) and each of the subtrees attached to the node contains no more than a <em>c</em> nodes. <em>c</em> is called a tree capacity. Solving CMST optimally is <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>,<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a> but good heuristics such as Esau-Williams and Sharma produce solutions close to optimal in polynomial time.</p>

<p>The <a href="degree-constrained_spanning_tree" title="wikilink">degree constrained minimum spanning tree</a> is a minimum spanning tree in with each vertex is connected to no more than <em>d</em> other vertices, for some given number <em>d</em>. The case <em>d</em> = 2 is a special case of the <a href="traveling_salesman_problem" title="wikilink">traveling salesman problem</a>, so the degree constrained minimum spanning tree is <a class="uri" href="NP-hard" title="wikilink">NP-hard</a> in general.</p>

<p>For <a href="directed_graph" title="wikilink">directed graphs</a>, the minimum spanning tree problem is called the <a href="Arborescence_(graph_theory)" title="wikilink">Arborescence</a> problem and can be solved in quadratic time using the <a href="Chu–Liu/Edmonds_algorithm" title="wikilink">Chu–Liu/Edmonds algorithm</a>.</p>

<p>A <strong>maximum spanning tree</strong> is a spanning tree with weight greater than or equal to the weight of every other spanning tree. Such a tree can be found with algorithms such as Prim's or Kruskal's after multiplying the edge weights by -1 and solving the MST problem on the new graph. A path in the maximum spanning tree is the <a href="widest_path_problem" title="wikilink">widest path</a> in the graph between its two endpoints: among all possible paths, it maximizes the weight of the minimum-weight edge.<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a> Maximum spanning trees find applications in <a class="uri" href="parsing" title="wikilink">parsing</a> algorithms for <a href="Natural_language_processing" title="wikilink">natural languages</a><a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a> and in training algorithms for <a href="conditional_random_field" title="wikilink">conditional random fields</a>.</p>

<p>The <strong>dynamic MST</strong> problem concerns the update of a previously computed MST after an edge weight change in the original graph or the insertion/deletion of a vertex.<a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a><a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a><a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a></p>

<p>The minimum labeling spanning tree problem is to find a spanning tree with least types of labels if each edge in a graph is associated with a label from a finite label set instead of a weight.<a class="footnoteRef" href="#fn51" id="fnref51"><sup>51</sup></a></p>

<p>A bottleneck edge is the highest weighted edge in a spanning tree. A spanning tree is a <strong><a href="minimum_bottleneck_spanning_tree" title="wikilink">minimum bottleneck spanning tree</a></strong> (or <strong>MBST</strong>) if the graph does not contain a spanning tree with a smaller bottleneck edge weight. A MST is necessarily a MBST (provable by the <a href="#Cut_property" title="wikilink">cut property</a>), but a MBST is not necessarily a MST.<a class="footnoteRef" href="#fn52" id="fnref52"><sup>52</sup></a><a class="footnoteRef" href="#fn53" id="fnref53"><sup>53</sup></a></p>
<h2 id="references">References</h2>
<h2 id="additional-reading">Additional reading</h2>
<ul>
<li><a href="http://citeseer.ist.psu.edu/nesetril00otakar.html">Otakar Boruvka on Minimum Spanning Tree Problem (translation of the both 1926 papers, comments, history) (2000)</a> Jaroslav Nesetril, Eva Milková, Helena Nesetrilová. (Section 7 gives his algorithm, which looks like a cross between Prim's and Kruskal's.)</li>
<li><a href="Thomas_H._Cormen" title="wikilink">Thomas H. Cormen</a>, <a href="Charles_E._Leiserson" title="wikilink">Charles E. Leiserson</a>, <a href="Ronald_L._Rivest" title="wikilink">Ronald L. Rivest</a>, and <a href="Clifford_Stein" title="wikilink">Clifford Stein</a>. <em><a href="Introduction_to_Algorithms" title="wikilink">Introduction to Algorithms</a></em>, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Chapter 23: Minimum Spanning Trees, pp. 561–579.</li>
<li>Eisner, Jason (1997). <a href="http://www.cs.jhu.edu/~jason/papers/eisner.mst-tutorial.pdf">State-of-the-art algorithms for minimum spanning trees: A tutorial discussion</a>. Manuscript, University of Pennsylvania, April. 78 pp.</li>
<li>Kromkowski, John David. "Still Unmelted after All These Years", in Annual Editions, Race and Ethnic Relations, 17/e (2009 McGraw Hill) (Using minimum spanning tree as method of demographic analysis of ethnic diversity across the United States).</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.boost.org/libs/graph/doc/table_of_contents.html">Implemented in BGL, the Boost Graph Library</a></li>
<li><a href="http://www.cs.sunysb.edu/~algorith/files/minimum-spanning-tree.shtml">The Stony Brook Algorithm Repository - Minimum Spanning Tree codes</a></li>
<li><a href="http://www.codeplex.com/quickgraph">Implemented in QuickGraph for .Net</a></li>
</ul>

<p>"</p>

<p><a href="Category:Spanning_tree" title="wikilink">Category:Spanning tree</a> <a href="Category:Polynomial-time_problems" title="wikilink">Category:Polynomial-time problems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://cs.stackexchange.com/questions/2204/do-the-minimum-spanning-trees-of-a-weighted-graph-have-the-same-number-of-edges">Do the minimum spanning trees of a weighted graph have the same number of edges with a given weight?</a><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">.<a href="#fnref5">↩</a></li>
<li id="fn6">.<a href="#fnref6">↩</a></li>
<li id="fn7">.<a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12">.<a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14">.<a href="#fnref14">↩</a></li>
<li id="fn15">.<a href="#fnref15">↩</a></li>
<li id="fn16">.<a href="#fnref16">↩</a></li>
<li id="fn17">.<a href="#fnref17">↩</a></li>
<li id="fn18">.<a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21">Nicos Christofides, Worst-case analysis of a new heuristic for the travelling salesman problem, Report 388, Graduate School of Industrial Administration, CMU, 1976.<a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="#fnref27">↩</a></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
<li id="fn31">P. Felzenszwalb, D. Huttenlocher: Efficient Graph-Based Image Segmentation. IJCV 59(2) (September 2004)<a href="#fnref31">↩</a></li>
<li id="fn32"><a href="#fnref32">↩</a></li>
<li id="fn33"><a href="#fnref33">↩</a></li>
<li id="fn34"><a href="#fnref34">↩</a></li>
<li id="fn35"><a href="#fnref35">↩</a></li>
<li id="fn36"><a href="#fnref36">↩</a></li>
<li id="fn37"><a href="#fnref37">↩</a></li>
<li id="fn38"><a href="#fnref38">↩</a></li>
<li id="fn39"><a href="#fnref39">↩</a></li>
<li id="fn40">Djauhari, M., &amp; Gan, S. (2015). Optimality problem of network topology in stocks market analysis. Physica A: Statistical Mechanics and Its Applications, 419, 108-114.<a href="#fnref40">↩</a></li>
<li id="fn41">. ND12<a href="#fnref41">↩</a></li>
<li id="fn42">.<a href="#fnref42">↩</a></li>
<li id="fn43">.<a href="#fnref43">↩</a></li>
<li id="fn44">.<a href="#fnref44">↩</a></li>
<li id="fn45"><a href="#fnref45">↩</a></li>
<li id="fn46">.<a href="#fnref46">↩</a></li>
<li id="fn47"><a href="#fnref47">↩</a></li>
<li id="fn48">.<a href="#fnref48">↩</a></li>
<li id="fn49">.<a href="#fnref49">↩</a></li>
<li id="fn50">.<a href="#fnref50">↩</a></li>
<li id="fn51">.<a href="#fnref51">↩</a></li>
<li id="fn52"><a class="uri" href="http://flashing-thoughts.blogspot.ru/2010/06/everything-about-bottleneck-spanning.html">http://flashing-thoughts.blogspot.ru/2010/06/everything-about-bottleneck-spanning.html</a><a href="#fnref52">↩</a></li>
<li id="fn53"><a class="uri" href="http://pages.cpsc.ucalgary.ca/~dcatalin/413/t4.pdf">http://pages.cpsc.ucalgary.ca/~dcatalin/413/t4.pdf</a><a href="#fnref53">↩</a></li>
</ol>
</section>
</body>
</html>
