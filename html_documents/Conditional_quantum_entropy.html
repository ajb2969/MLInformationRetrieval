<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1046">Conditional quantum entropy</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Conditional quantum entropy</h1>
<hr>The '''conditional quantum entropy''' is an [[entropy measure]] used in [[quantum information theory]].  It is a generalization of the [[conditional entropy]] of 
<p><a href="classical_information_theory" title="wikilink">classical information theory</a>. For a bipartite state 

<math display="inline" id="Conditional_quantum_entropy:0">
 <semantics>
  <msup>
   <mi>ρ</mi>
   <mrow>
    <mi>A</mi>
    <mi>B</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ρ</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho^{AB}
  </annotation>
 </semantics>
</math>

, the conditional entropy is written 

<math display="inline" id="Conditional_quantum_entropy:1">
 <semantics>
  <mrow>
   <mi>S</mi>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">|</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ρ</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>ρ</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(A|B)_{\rho}
  </annotation>
 </semantics>
</math>

, or 

<math display="inline" id="Conditional_quantum_entropy:2">
 <semantics>
  <mrow>
   <mi>H</mi>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">|</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ρ</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">H</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>ρ</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(A|B)_{\rho}
  </annotation>
 </semantics>
</math>

, depending on the notation being used for the <a href="von_Neumann_entropy" title="wikilink">von Neumann entropy</a>. The quantum conditional entropy was defined in terms of a conditional density operator 

<math display="inline" id="Conditional_quantum_entropy:3">
 <semantics>
  <msub>
   <mi>ρ</mi>
   <mrow>
    <mi>A</mi>
    <mo stretchy="false">|</mo>
    <mi>B</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ρ</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">B</csymbol>
    </cerror>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{A|B}
  </annotation>
 </semantics>
</math>

 by <a href="Nicolas_Cerf" title="wikilink">Nicolas Cerf</a> and <a href="Chris_Adami" title="wikilink">Chris Adami</a>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> who showed that quantum conditional entropies can be negative, something that is forbidden in classical physics. The negativity of quantum conditional entropy is a sufficient criterion for quantum <a href="Separable_state" title="wikilink">non-separability</a>.</p>

<p>In what follows, we use the notation 

<math display="inline" id="Conditional_quantum_entropy:4">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>⋅</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>normal-⋅</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\cdot)
  </annotation>
 </semantics>
</math>

 for the <a href="von_Neumann_entropy" title="wikilink">von Neumann entropy</a>, which will simply be called "entropy".</p>
<h2 id="definition">Definition</h2>

<p>Given a bipartite quantum state 

<math display="inline" id="Conditional_quantum_entropy:5">
 <semantics>
  <msup>
   <mi>ρ</mi>
   <mrow>
    <mi>A</mi>
    <mi>B</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ρ</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho^{AB}
  </annotation>
 </semantics>
</math>

, the entropy of the joint system AB is 

<math display="inline" id="Conditional_quantum_entropy:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mpadded width="+5pt">
     <msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>A</mi>
        <mi>B</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>ρ</mi>
     </msub>
    </mpadded>
   </mrow>
   <mpadded width="+5pt">
    <mover>
     <mo movablelimits="false">=</mo>
     <mi>def</mi>
    </mover>
   </mpadded>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>ρ</mi>
      <mrow>
       <mi>A</mi>
       <mi>B</mi>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <ci>def</ci>
    </apply>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
      <ci>ρ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ρ</ci>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(AB)_{\rho}\ \stackrel{\mathrm{def}}{=}\ S(\rho^{AB})
  </annotation>
 </semantics>
</math>

, and the entropies of the subsystems are 

<math display="inline" id="Conditional_quantum_entropy:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mpadded width="+5pt">
     <msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>ρ</mi>
     </msub>
    </mpadded>
   </mrow>
   <mpadded width="+5pt">
    <mover>
     <mo movablelimits="false">=</mo>
     <mi>def</mi>
    </mover>
   </mpadded>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>ρ</mi>
      <mi>A</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>tr</mi>
       <mi>B</mi>
      </msub>
      <msup>
       <mi>ρ</mi>
       <mrow>
        <mi>A</mi>
        <mi>B</mi>
       </mrow>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <eq></eq>
      <ci>def</ci>
     </apply>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>ρ</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ρ</ci>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>tr</ci>
        <ci>B</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ρ</ci>
        <apply>
         <times></times>
         <ci>A</ci>
         <ci>B</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(A)_{\rho}\ \stackrel{\mathrm{def}}{=}\ S(\rho^{A})=S(\mathrm{tr}_{B}\rho^{AB})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Conditional_quantum_entropy:8">
 <semantics>
  <mrow>
   <mi>S</mi>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ρ</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>ρ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(B)_{\rho}
  </annotation>
 </semantics>
</math>

. The von Neumann entropy measures an observer's uncertainty about the value of the state, that is, how much the state is a <a href="mixed_state_(physics)" title="wikilink">mixed state</a>.</p>

<p>By analogy with the classical conditional entropy, one defines the conditional quantum entropy as 

<math display="inline" id="Conditional_quantum_entropy:9">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mpadded width="+5pt">
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">|</mo>
      <mi>B</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>ρ</mi>
    </msub>
   </mpadded>
   <mpadded width="+5pt">
    <mover>
     <mo movablelimits="false">=</mo>
     <mi>def</mi>
    </mover>
   </mpadded>
   <mi>S</mi>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ρ</mi>
   </msub>
   <mo>-</mo>
   <mi>S</mi>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ρ</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-|</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>ρ</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <ci>def</ci>
    </apply>
    <csymbol cd="unknown">S</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>ρ</ci>
    </apply>
    <minus></minus>
    <csymbol cd="unknown">S</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>ρ</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(A|B)_{\rho}\ \stackrel{\mathrm{def}}{=}\ S(AB)_{\rho}-S(B)_{\rho}
  </annotation>
 </semantics>
</math>

.</p>

<p>An equivalent (and more intuitive) operational definition of the quantum conditional entropy (as a measure of the <a href="quantum_communication" title="wikilink">quantum communication</a> cost or surplus when performing <a href="quantum_state" title="wikilink">quantum state</a> merging) was given by <a href="Michał_Horodecki" title="wikilink">Michał Horodecki</a>, <a href="Jonathan_Oppenheim" title="wikilink">Jonathan Oppenheim</a>, and <a href="Andreas_Winter" title="wikilink">Andreas Winter</a> in their paper "Quantum Information can be negative" <a href="http://arxiv.org/abs/quant-ph/0505062">1</a>.</p>
<h2 id="properties">Properties</h2>

<p>Unlike the classical <a href="conditional_entropy" title="wikilink">conditional entropy</a>, the conditional quantum entropy can be negative. This is true even though the (quantum) von Neumann entropy of single variable is never negative. The negative conditional entropy is also known as the <a href="coherent_information" title="wikilink">coherent information</a>, and gives the additional number of bits above the classical limit that can be transmitted in a quantum dense coding protocol. Positive conditional entropy of a state thus means the state cannot reach even the classical limit, while the negative conditional entropy provides for additional information.</p>
<h2 id="references">References</h2>

<p>Nielsen, Michael A. and <a href="Isaac_L._Chuang" title="wikilink">Isaac L. Chuang</a> (2000). <em>Quantum Computation and Quantum Information</em>. Cambridge University Press, ISBN 0-521-63503-9.</p>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Quantum_mechanical_entropy" title="wikilink">Category:Quantum mechanical entropy</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
</ol>
</section>
</hr></body>
</html>
