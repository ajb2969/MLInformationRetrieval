<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title offset="211">Extended Euclidean algorithm</title>
   <script type="text/javascript"
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js">
    </script>
</head>
<body>
<h1>Extended Euclidean algorithm</h1>
<hr/>
<p>In <a class="uri" href="arithmetic" title="wikilink">arithmetic</a> and <a href="computer_programming" title="wikilink">computer programming</a>, the <strong>extended Euclidean algorithm</strong> is an extension to the <a href="Euclidean_algorithm" title="wikilink">Euclidean algorithm</a>, which computes, besides the <a href="greatest_common_divisor" title="wikilink">greatest common divisor</a> of integers <em>a</em> and <em>b</em>, the coefficients of <a href="Bézout's_identity" title="wikilink">Bézout's identity</a>, that is integers <em>x</em> and <em>y</em> such that</p>
<p><span class="LaTeX">$$ax + by = \gcd(a, b).$$</span> It allows one to compute also, with almost no extra cost, the quotients of <em>a</em> and <em>b</em> by their greatest common divisor.</p>
<p><strong><a href="Polynomial_greatest_common_divisor#Bézout's_identity_and_extended_GCD_algorithm" title="wikilink">Extended Euclidean algorithm</a></strong> also refers to a very similar algorithm for computing the <a href="polynomial_greatest_common_divisor" title="wikilink">polynomial greatest common divisor</a> and the coefficients of Bézout's identity of two <a href="univariate_polynomial" title="wikilink">univariate polynomials</a>.</p>
<p>The extended Euclidean algorithm is particularly useful when <em>a</em> and <em>b</em> are <a class="uri" href="coprime" title="wikilink">coprime</a>, since <em>x</em> is the <a href="modular_multiplicative_inverse" title="wikilink">modular multiplicative inverse</a> of <em>a</em> <a href="modular_arithmetic" title="wikilink">modulo</a> <em>b</em>, and <em>y</em> is the modular multiplicative inverse of <em>b</em> modulo <em>a</em>. Similarly, the polynomial extended Euclidean algorithm allows one to compute the <a href="multiplicative_inverse" title="wikilink">multiplicative inverse</a> in <a href="algebraic_field_extension" title="wikilink">algebraic field extensions</a> and, in particular in <a href="finite_field" title="wikilink">finite fields</a> of non prime order. It follows that both extended Euclidean algorithms are widely used in <a class="uri" href="cryptography" title="wikilink">cryptography</a>. In particular, the computation of the modular multiplicative inverse is an essential step in <a href="RSA_(algorithm)" title="wikilink">RSA</a> public-key encryption method.</p>
<h2 id="description">Description</h2>
<p>The standard Euclidean algorithm proceeds by a succession of <a href="Euclidean_division" title="wikilink">Euclidean divisions</a> whose quotients are not used, only the <em>remainders</em> are kept. For the extended algorithm, the successive quotients are used. More precisely, the standard Euclidean algorithm with <em>a</em> and <em>b</em> as input, consists of computing a sequence <span class="LaTeX">$q_1,\ldots, q_k$</span> of quotients and a sequence <span class="LaTeX">$r_0,\ldots, r_{k+1}$</span> of remainders such that</p>
<p><span class="LaTeX">$$\begin{array}{l}
r_0=a\\
r_1=b\\
\ldots\\
r_{i+1}=r_{i-1}-q_i r_i \quad \text {and} \quad 0\le r_{i+1} < |r_i|\\
\ldots
\end{array}$$</span> It is the main property of <a href="Euclidean_division" title="wikilink">Euclidean division</a> that the inequalities on the right define uniquely <span class="LaTeX">$r_{i+1}$</span> from <span class="LaTeX">$r_{i-1}$</span> and <span class="LaTeX">$r_{i}.$</span></p>
<p>The computation stops when one reaches a remainder <span class="LaTeX">$r_{k+1}$</span> which is zero; the greatest common divisor is then the last non zero remainder <span class="LaTeX">$r_{k}.$</span></p>
<p>The extended Euclidean algorithm proceeds similarly, but adds two other sequences, as follows</p>
<p><span class="LaTeX">$$\begin{array}{l}
r_0=a\qquad r_1=b\\
s_0=1\qquad s_1=0\\
t_0=0\qquad t_1=1\\
\ldots\\
r_{i+1}=r_{i-1}-q_i r_i \quad \text {and} \quad 0\le r_{i+1} < |r_i|\qquad \text{(this defines } q_i \text{)}\\
s_{i+1}=s_{i-1}-q_i s_i\\
t_{i+1}=t_{i-1}-q_i t_i\\
\ldots
\end{array}$$</span></p>
<p>The computation also stops when <span class="LaTeX">$r_{k+1}=0$</span> and gives</p>
<ul>
<li><span class="LaTeX">$r_{k}$</span> is the greatest common divisor of the input <span class="LaTeX">$a=r_{0}$</span> and <span class="LaTeX">$b=r_{1}.$</span></li>
<li>The Bézout coefficients are <span class="LaTeX">$s_{k}$</span> and <span class="LaTeX">$t_{k},$</span> that is <span class="LaTeX">$\gcd(a,b)=r_{k}=as_k+bt_k$</span></li>
<li>The quotients of <em>a</em> and <em>b</em> by their greatest common divisor are given by <span class="LaTeX">$s_{k+1}=\pm\frac{b}{\gcd(a,b)}$</span> and <span class="LaTeX">$t_{k+1}=\pm\frac{a}{\gcd(a,b)}$</span></li>
</ul>
<p>Moreover, if <em>a</em> and <em>b</em> are both positive, we have</p>
<p><span class="LaTeX">$$|s_k|<\frac{b}{\gcd(a,b)}\quad \text{and} \quad |t_k|<\frac{a}{\gcd(a,b)}.$$</span> This means that the pair of Bézout's coefficients provided by the extended Euclidean algorithm is one of the two minimal pairs of Bézout coefficients.</p>
<h3 id="example">Example</h3>
<p>The following table shows how the extended Euclidean algorithm proceeds with input <span class="LaTeX">$$</span> and <span class="LaTeX">$$</span>. The greatest common divisor is the last non zero entry, <span class="LaTeX">$$</span> in the column "remainder". The computation stops at row 6, because the remainder in it is <span class="LaTeX">$$</span>. Bézout coefficients appear in the last two entries of the second-to-last row. In fact, it is easy to verify that <span class="LaTeX">$  ×  +  ×  = $</span>. Finally the last two entries <span class="LaTeX">$$</span> and <span class="LaTeX">$$</span> of the last row are, up to the sign, the quotients of the input <span class="LaTeX">$$</span> and <span class="LaTeX">$$</span> by the greatest common divisor <span class="LaTeX">$$</span>.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><p>index <em>i</em></p></th>
<th style="text-align: left;"><p><mtpl></mtpl></p></th>
<th style="text-align: left;"><p><mtpl></mtpl></p></th>
<th style="text-align: left;"><p><mtpl></mtpl></p></th>
<th style="text-align: left;"><p><em>t</em><sub><em>i</em></sub></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>0</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>1</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>2</p></td>
<td style="text-align: left;">
<p>÷  = </p></td>
<td style="text-align: left;"><p>| −  ×  = </p></td>
<td style="text-align: left;"><p>| −  ×  = </p></td>
<td style="text-align: left;"><p>| 0 −  × 1 = −5</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>3</p></td>
<td style="text-align: left;">
<p>÷  = </p></td>
<td style="text-align: left;"><p>| −  ×  = </p></td>
<td style="text-align: left;"><p>| −  ×  = </p></td>
<td style="text-align: left;"><p>| 1 −  × −5 = 21</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>4</p></td>
<td style="text-align: left;">
<p>÷  = </p></td>
<td style="text-align: left;"><p>| −  ×  = </p></td>
<td style="text-align: left;"><p>| −  ×  = </p></td>
<td style="text-align: left;"><p>| −5 −  × 21 = −26</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>5</p></td>
<td style="text-align: left;">
<p>÷  = </p></td>
<td style="text-align: left;"><p>| −  ×  = </p></td>
<td style="text-align: left;"><p>| −  ×  = </p></td>
<td style="text-align: left;"><p>| 21 −  × −26 = </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>6</p></td>
<td style="text-align: left;">
<p>÷  = </p></td>
<td style="text-align: left;"><p>| −  ×  = </p></td>
<td style="text-align: left;"><p>| −  ×  = </p></td>
<td style="text-align: left;"><p>| −26 −  × 47 = </p></td>
</tr>
</tbody>
</table>
<h3 id="proof">Proof</h3>
<p>As <span class="LaTeX">$0\le r_{i+1}<|r_i|,$</span> the sequence of the <span class="LaTeX">$r_i$</span> is a decreasing sequence nonnegative integers (from <em>i</em> = 2 on). Thus it must stop with some <span class="LaTeX">$r_{k+1}=0.$</span> This proves that the algorithm stops eventually.</p>
<p>As <span class="LaTeX">$r_{i+1}= r_{i-1} - r_i q_i,$</span> the greatest common divisors are the same for <span class="LaTeX">$(r_{i-1}, r_i)$</span> and <span class="LaTeX">$(r_{i}, r_{i+1}).$</span> This shows that the greatest common divisor of the input <span class="LaTeX">$a=r_0, b=r_1$</span> is the same as that of <span class="LaTeX">$r_k, r_{k+1}=0.$</span> This proves that <span class="LaTeX">$r_k$</span> is the greatest common divisor of <em>a</em> and <em>b</em>. (Until this point, the proof is the same as that of the classical Euclidean algorithm.)</p>
<p>As <span class="LaTeX">$a=r_0$</span> and <span class="LaTeX">$b=r_1,$</span> we have <span class="LaTeX">$as_i+bt_i=r_i$</span> for <em>i</em> = 0 and 1. The relation follows by induction for all <span class="LaTeX">$i>1$</span><span class="LaTeX">$$r_{i+1} = r_{i-1} - r_i q_i = (as_{i-1}+bt_{i-1}) - (as_i+bt_i)q_i = (as_{i-1}-as_iq_i) + (bt_{i-1}-bt_iq_i) = as_{i+1}+bt_{i+1}.$$</span> Thus <span class="LaTeX">$s_k$</span> and <span class="LaTeX">$t_k$</span> are Bézout coefficients.</p>
<p>Let us consider the matrix</p>
<p><span class="LaTeX">$$A_i=\begin{pmatrix}
s_{i-1} & s_i\\
t_{i-1} & t_i
\end{pmatrix} \,.$$</span> The recurrence relation may be rewritten in matrix form</p>
<p><span class="LaTeX">$$A_{i+1} = A_i
\,.\,
\begin{pmatrix}
0 & 1\\
1 & -q_i
\end{pmatrix} \,.$$</span> The matrix <span class="LaTeX">$A_1$</span> is the identity matrix and its determinant is one. The determinant of the rightmost matrix in the preceding formula is -1. It follows that the determinant of <span class="LaTeX">$A_i$</span> is <span class="LaTeX">$(-1)^{i-1}.$</span> In particular, for <em>i</em> = <em>k</em> + 1, we have <span class="LaTeX">$s_k t_{k+1}-t_k s_{k+1} = (-1)^k.$</span> Viewing this as a Bézout's identity, this shows that <span class="LaTeX">$s_{k+1}$</span> and <span class="LaTeX">$t_{k+1}$</span> are <a class="uri" href="coprime" title="wikilink">coprime</a>. The relation <span class="LaTeX">$as_{k+1}+bt_{k+1}=0$</span> that has been proved above and <a href="Euclid's_lemma" title="wikilink">Euclid's lemma</a> shows that <span class="LaTeX">$s_{k+1}$</span> divides <em>b</em> and <span class="LaTeX">$t_{k+1}$</span> divides <em>a</em>. As they are coprime, they are, up to their sign the quotients of <em>b</em> and <em>a</em> by their greatest common divisor.</p>
<h2 id="polynomial-extended-euclidean-algorithm">Polynomial extended Euclidean algorithm</h2>
<p>For <a href="univariate_polynomial" title="wikilink">univariate polynomials</a> with coefficients in a <a href="field_(mathematics)" title="wikilink">field</a>, everything works in a similar way, Euclidean division, Bézout's identity and extended Euclidean algorithm. The first difference is that, in the Euclidean division and the algorithm, the inequality <span class="LaTeX">$0\le r_{i+1}<|r_i|$</span> has to be replaced by an inequality on the degrees <span class="LaTeX">$\deg r_{i+1}<\deg r_i.$</span> Otherwise, everything which precedes in this article remains the same, simply by replacing integers by polynomials.</p>
<p>A second difference lies in the bound on the size of the Bézout coefficients provided by the extended Euclidean algorithm, which is more accurate in the polynomial case, leading to the following theorem.</p>
<p><em>If a and b are two nonzero polynomials, then the extended Euclidean algorithm produces the unique pair of polynomials</em> (<em>s</em>, <em>t</em>) <em>such that</em></p>
<p><span class="LaTeX">$$as+bt=\gcd(a,b)$$</span> <em>and</em></p>
<p><span class="LaTeX">$$\deg s < \deg b - \deg (\gcd(a,b)), \quad \deg t < \deg a - \deg (\gcd(a,b)).$$</span></p>
<p>A third difference is that, in the polynomial case, the greatest common divisor is defined only up to the multiplication by a non zero constant. There are several ways to define the greatest common divisor unambiguously.</p>
<p>In mathematics, it is common to require that the greatest common divisor be a <a href="monic_polynomial" title="wikilink">monic polynomial</a>. To get this, it suffices to divide every element of the output by the <a href="leading_coefficient" title="wikilink">leading coefficient</a> of <span class="LaTeX">$r_{k}.$</span> This allows that, if <em>a</em> and <em>b</em> are coprime, one gets 1 in the right-hand side of Bézout's inequality. Otherwise, one may get any non-zero constant. In <a href="computer_algebra" title="wikilink">computer algebra</a>, the polynomials have commonly integers coefficients, and this way of normalizing the greatest common divisor introduces too many fractions to be convenient.</p>
<p>The second way to normalize the greatest common divisor in the case of polynomials with integers coefficients is to divide every output by the <a href="content_(algebra)" title="wikilink">content</a> of <span class="LaTeX">$r_{k},$</span> to get a <a href="primitive_polynomial_(ring_theory)" title="wikilink">primitive</a> greatest common divisor. If the input polynomials are coprime, this normalization provides also a greatest common divisor equal to 1. The drawback of this approach is that a lot of fractions should be computed and simplified during the computation.</p>
<p>A third approach consists in extending the algorithm of <a href="Polynomial_greatest_common_divisor#Subresultant_pseudo-remainder_sequence" title="wikilink">subresultant pseudo-remainder sequences</a> in a way that is similar to the extension of the Euclidean algorithm to the extended Euclidean algorithm. This allows that, when starting with polynomials with integer coefficients, all polynomials that are computed have integer coefficients. Moreover, every computed remainder <span class="LaTeX">$r_i$</span> is a <a href="subresultant" title="wikilink">subresultant polynomial</a>. In particular, if the input polynomials are coprime, then the Bézout's identity becomes</p>
<p><span class="LaTeX">$$as+bt=\operatorname{Res}(a,b),$$</span> where <span class="LaTeX">$\operatorname{Res}(a,b)$</span> denotes the <a class="uri" href="resultant" title="wikilink">resultant</a> of <em>a</em> and <em>b</em>. In this form of Bézout's identity there is no denominator in the formula. If one divides everything by the resultant one gets the classical Bézout's identity, with an explicit common denominator for the rational numbers that appear in it.</p>
<h2 id="pseudocode">Pseudocode</h2>
<p>To implement the algorithm that is described above, one should first remark that only the two last values of the indexed variables are needed at each step. Thus, for saving memory, each indexed variable must be replaced by only two variables.</p>
<p>For simplicity, the following algorithm (and the other algorithms in this article) uses <a href="parallel_assignment" title="wikilink">parallel assignments</a>. In a programming language which does not have this feature, the parallel assignments need to be simulated with an auxiliary variable. For example, the first one,</p>
<p><code>(old_r, r) := (r, old_r - quotient *r)</code></p>
<p>is equivalent to</p>
<p><code>prov := r;</code><br/>
<code>r := old_r - quotient * prov;</code><br/>
<code>old_r := prov;</code></p>
<p>and similarly for the other parallel assignments. This leads to the following code:</p>
<p><strong><code>function</code></strong><code> extended_gcd(a, b)</code><br/>
<code>    s := 0;    old_s := 1</code><br/>
<code>    t := 1;    old_t := 0</code><br/>
<code>    r := b;    old_r := a</code><br/>
<code>    </code><strong><code>while</code></strong><code> r ≠ 0</code><br/>
<code>        quotient := old_r </code><strong><code>div</code></strong><code> r</code><br/>
<code>        (old_r, r) := (r, old_r - quotient * r)</code><br/>
<code>        (old_s, s) := (s, old_s - quotient * s)</code><br/>
<code>        (old_t, t) := (t, old_t - quotient * t)</code><br/>
<code>    </code><strong><code>output</code></strong><code> "Bézout coefficients:", (old_s, old_t)</code><br/>
<code>    </code><strong><code>output</code></strong><code> "greatest common divisor:", old_r</code><br/>
<code>    </code><strong><code>output</code></strong><code> "quotients by the gcd:", (t, s)</code></p>
<p>The quotients of <em>a</em> and <em>b</em> by their greatest common divisor, which are output, may have an incorrect sign. This is easy to correct at the end of the computation, but has not been done here for simplifying the code. Similarly, if either <em>a</em> or <em>b</em> is zero and the other is negative, the greatest common divisor that is output is negative, and all the signs of the output must be changed.</p>
<h2 id="simplification-of-fractions">Simplification of fractions</h2>
<p>A fraction <span class="LaTeX">$\frac{a}{b}$</span> is in canonical simplified form if <span class="LaTeX">$a$</span> and <span class="LaTeX">$b$</span> are <a class="uri" href="coprime" title="wikilink">coprime</a> and <span class="LaTeX">$b$</span> is positive. This canonical simplified form can be obtained by replacing the three <strong>output</strong> lines of the preceding pseudo code by</p>
<p><strong><code>if</code></strong><code> s = 0 </code><strong><code>then</code> <code>output</code></strong><code> "Division by zero"</code><br/>
<strong><code>if</code></strong><code> s = 1 </code><strong><code>then</code> <code>output</code></strong><code> </code><span class="LaTeX">$-t$</span><code>     (''Optional line, for avoiding output like </code><span class="LaTeX">$\frac{-t}{1}$</span><br/>
<strong><code>else</code> <code>if</code></strong><code> s > 0 </code><strong><code>then</code> <code>output</code></strong><code> </code><span class="LaTeX">$\frac{-t}{s}$</span><br/>
<strong><code>else</code> <code>return</code></strong><code>  </code><span class="LaTeX">$\frac{t}{-s}$</span></p>
<p>The proof of this algorithm relies on the fact that <em>s</em> and <em>t</em> are two coprime integers such that <em>as</em> + <em>bt</em> = 0, and thus <span class="LaTeX">$\frac{a}{b} = -\frac{t}{s}$</span>. To get the canonical simplified form, it suffices to move the minus sign for having a positive denominator.</p>
<p>If <em>b</em> divides <em>a</em> evenly, the algorithm executes only one iteration, and we have <em>s</em> = 1 at the end of the algorithm. It the only case where the output is an integer.</p>
<h2 id="computing-multiplicative-inverses-in-modular-structures">Computing multiplicative inverses in modular structures</h2>
<p>The extended Euclidean algorithm is the basic tool for computing <a href="multiplicative_inverse" title="wikilink">multiplicative inverses</a> in modular structures, typically the <a href="modular_arithmetic" title="wikilink">modular integers</a> and the <a href="algebraic_field_extension" title="wikilink">algebraic field extensions</a>. An important instance of the latter case are the finite fields of non-prime order.</p>
<h3 id="modular-integers">Modular integers</h3>
<p>If <span class="LaTeX">$n$</span> is a positive integer, the ring <a href="Z/nZ" title="wikilink"><span class="LaTeX">$\mathbf{ Z } / n \mathbf{ Z } $</span></a> may be identified with the set  of the remainders of <a href="Euclidean_division" title="wikilink">Euclidean division</a> by <span class="LaTeX">$n$</span>, the addition and the multiplication consisting in taking the remainder by <span class="LaTeX">$n$</span> of the result of the addition and the multiplication of integers. An element <span class="LaTeX">$a$</span> of <span class="LaTeX">$\mathbf{ Z } / n \mathbf{ Z } $</span> has a multiplicative inverse (that is, it is a <a href="unit_(ring_theory)" title="wikilink">unit</a>) if it is <a class="uri" href="coprime" title="wikilink">coprime</a> to <span class="LaTeX">$n$</span>. In particular, if <span class="LaTeX">$n$</span> is <a href="prime_number" title="wikilink">prime</a>, <span class="LaTeX">$a$</span> has a multiplicative inverse if it is not zero (modulo <span class="LaTeX">$n$</span>). Thus <span class="LaTeX">$\mathbf{ Z } / n \mathbf{ Z } $</span> is a field if and only if <span class="LaTeX">$n$</span> is prime.</p>
<p>Bézout's identity asserts that <span class="LaTeX">$a$</span> and <span class="LaTeX">$n$</span> are coprime if and only if there exist integers <span class="LaTeX">$s$</span> and <span class="LaTeX">$t$</span> such that</p>
<p><span class="LaTeX">$$ns+at=1$$</span> Reducing this identity modulo <span class="LaTeX">$n$</span> gives</p>
<p><span class="LaTeX">$$at=1 \mod n.$$</span> Thus <span class="LaTeX">$t$</span>, or, more exactly, the remainder of the division of <span class="LaTeX">$t$</span> by <span class="LaTeX">$n$</span>, is the multiplicative inverse of <span class="LaTeX">$a$</span> modulo <span class="LaTeX">$n$</span>.</p>
<p>To adapt the extended Euclidean algorithm to this problem, one should remark that the Bézout coefficient of <span class="LaTeX">$n$</span> is not needed, and thus does not need to be computed. Also, for getting a result which is positive and lower than <em>n</em>, one may use the fact that the integer <span class="LaTeX">$t$</span> provided by the algorithm satisfies <span class="LaTeX">$| t | . That is, if <span class="LaTeX">$t , one must add <span class="LaTeX">$n$</span> to it at the end. This results in the pseudocode, in which the input <em>n</em> is an integer larger than 1.</span></span></p>
<p><strong><code>function</code></strong><code> inverse(a, n)</code><br/>
<code>    t := 0;     newt := 1;    </code><br/>
<code>    r := n;     newr := a;    </code><br/>
<code>    </code><strong><code>while</code></strong><code> newr ≠ 0</code><br/>
<code>        quotient := r </code><strong><code>div</code></strong><code> newr</code><br/>
<code>        (t, newt) := (newt, t - quotient * newt) </code><br/>
<code>        (r, newr) := (newr, r - quotient * newr)</code><br/>
<code>    </code><strong><code>if</code></strong><code> r > 1 then </code><strong><code>return</code></strong><code> "a is not invertible"</code><br/>
<code>    </code><strong><code>if</code></strong><code> t </code><code>$p$</code><code> is a prime number, and </code><mtpl></mtpl><code>, the field of order </code><span class="LaTeX"><code>$q$</code></span><code> is a simple algebraic extension of the </code><a href="prime_field" title="wikilink"><code>prime</code> <code>field</code></a><code> of </code><span class="LaTeX"><code>$p$</code></span><code> elements, generated by a root of an </code><a href="irreducible_polynomial" title="wikilink"><code>irreducible</code> <code>polynomial</code></a><code> of degree </code><span class="LaTeX"><code>$d$</code></span><code>.</code></p>
<p>A simple algebraic extension <span class="LaTeX">$L$</span> of a field <span class="LaTeX">$K$</span>, generated by the root of an irreducible polynomial <span class="LaTeX">$p$</span> of degree <span class="LaTeX">$d$</span> may be identified to the <a href="quotient_ring" title="wikilink">quotient ring</a> <span class="LaTeX">$K[X]/\langle p\rangle,$</span>, and its elements are in <a href="bijective" title="wikilink">bijective correspondence</a> with the polynomials of degree less than <span class="LaTeX">$d$</span>. The addition in <span class="LaTeX">$L$</span> is the addition of polynomials. The multiplication in <span class="LaTeX">$L$</span> is the remainder of the <a href="Euclidean_division_of_polynomials" title="wikilink">Euclidean division</a> by <span class="LaTeX">$p$</span> of the product of polynomials. Thus, to complete the arithmetic in <span class="LaTeX">$L$</span>, it remains only to define how to compute multiplicative inverses. This is done by the extended Euclidean algorithm.</p>
<p>The algorithm is very similar to that provided above for computing the modular multiplicative inverse. There are two main differences: firstly the last but one line is not needed, because the Bézout coefficient that is provided has always a degree less than <span class="LaTeX">$d$</span>. Secondly, the greatest common divisor which is provided, when the input polynomials are coprime, may be any non zero element of <span class="LaTeX">$K$</span>; this Bézout coefficient (a polynomial generally of positive degree) has thus to be multiplied by the inverse of this element of <span class="LaTeX">$K$</span>. In the pseudocode which follows, <span class="LaTeX">$p$</span> is a polynomial of degree greater than one, and <span class="LaTeX">$a$</span> is a polynomial. Moreover, <strong>div</strong> is an auxiliary function that computes the quotient of the Euclidean division.</p>
<p><strong><code>function</code></strong><code> inverse(a, p)</code><br/>
<code>    t := 0;     newt := 1;    </code><br/>
<code>    r := p;     newr := a;    </code><br/>
<code>    </code><strong><code>while</code></strong><code> newr ≠ 0</code><br/>
<code>        quotient := r </code><strong><code>div</code></strong><code> newr</code><br/>
<code>        (r, newr) := (newr, r - quotient * newr)</code><br/>
<code>        (t, newt) := (newt, t - quotient * newt) </code><br/>
<code>    </code><strong><code>if</code></strong><code> degree(r) > 0 then </code><br/>
<code>        </code><strong><code>return</code></strong><code> "Either p is not irreducible or a is a multiple of p"</code><br/>
<code>    </code><strong><code>return</code></strong><code> (1/r) * t</code></p>
<h4 id="example-1">Example</h4>
<p>For example, if the polynomial used to define the finite field GF(2<sup>8</sup>) is <em>p</em> = <em>x</em><sup>8</sup> + <em>x</em><sup>4</sup> + <em>x</em><sup>3</sup> + <em>x</em> + 1, and <em>a</em> = <em>x</em><sup>6</sup> + <em>x</em><sup>4</sup> + <em>x</em> + 1 is the element whose inverse is desired, then performing the algorithm results in the computation described in the following table. Let us recall that in fields of order 2<sup><em>n</em></sup>, one has -<em>z</em> = <em>z</em> and <em>z</em> + <em>z</em> = 0 for every element <em>z</em> in the field). Note also that 1 being the only nonzero element of GF(2), the adjustment in the last line of the pseudocode is not needed.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><p>step</p></th>
<th style="text-align: left;"><p> quotient </p></th>
<th style="text-align: left;"><p>r, newr</p></th>
<th style="text-align: left;"><p>t, newt</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"><p> </p></td>
<td style="text-align: left;"><p> <em>p</em> = <em>x</em><sup>8</sup> + <em>x</em><sup>4</sup> + <em>x</em><sup>3</sup> + <em>x</em> + 1 </p></td>
<td style="text-align: left;"><p> 0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"><p> </p></td>
<td style="text-align: left;"><p> <em>a</em> = <em>x</em><sup>6</sup> + <em>x</em><sup>4</sup> + <em>x</em> + 1</p></td>
<td style="text-align: left;"><p> 1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>1</p></td>
<td style="text-align: left;"><p> <em>x</em><sup>2</sup> + 1</p></td>
<td style="text-align: left;"><p> <em>x</em><sup>2</sup> = <em>p</em> - <em>a</em> (<em>x</em><sup>2</sup> + 1)</p></td>
<td style="text-align: left;"><p> <em>x</em><sup>2</sup> + 1 = 0 - 1 × (<em>x</em><sup>2</sup> + 1)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>2</p></td>
<td style="text-align: left;"><p> <em>x</em><sup>4</sup> + <em>x</em><sup>2</sup></p></td>
<td style="text-align: left;"><p> <em>x</em> + 1 = <em>a</em> - <em>x</em><sup>2</sup> (<em>x</em><sup>4</sup> + <em>x</em><sup>2</sup>)</p></td>
<td style="text-align: left;"><p> <em>x</em><sup>6</sup> + <em>x</em><sup>2</sup> + 1 = 1 - (<em>x</em><sup>4</sup> + <em>x</em><sup>2</sup>) (<em>x</em><sup>2</sup> + 1)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><p>3</p></td>
<td style="text-align: left;"><p> <em>x</em> + 1</p></td>
<td style="text-align: left;"><p> 1 = <em>x</em><sup>2</sup> - (<em>x</em> + 1) (<em>x</em> + 1)</p></td>
<td style="text-align: left;"><p> <em>x</em><sup>7</sup> + <em>x</em><sup>6</sup> + <em>x</em><sup>3</sup> + <em>x</em> = (<em>x</em><sup>2</sup> + 1) - (<em>x</em> + 1) (<em>x</em><sup>6</sup> + <em>x</em><sup>2</sup> + 1)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>4</p></td>
<td style="text-align: left;"><p> <em>x</em> + 1</p></td>
<td style="text-align: left;"><p> 0 = (<em>x</em> + 1) - 1 × (<em>x</em> + 1)</p></td>
<td style="text-align: left;"><p> </p></td>
</tr>
</tbody>
</table>
<p>Thus, the inverse is <em>x</em><sup>7</sup> + <em>x</em><sup>6</sup> + <em>x</em><sup>3</sup> + <em>x</em>, as can be confirmed by <a href="finite_field_arithmetic" title="wikilink">multiplying the two elements together</a>, and taking the remainder by <span class="LaTeX">$p$</span> of the result.</p>
<h2 id="the-case-of-more-than-two-numbers">The case of more than two numbers</h2>
<p>One can handle the case of more than two numbers iteratively. First we show that <span class="LaTeX">$\gcd(a,b,c) = \gcd(\gcd(a,b),c)$</span>. To prove this let <span class="LaTeX">$d=\gcd(a,b,c)$</span>. By definition of gcd <span class="LaTeX">$d$</span> is a divisor of <span class="LaTeX">$a$</span> and <span class="LaTeX">$b$</span>. Thus <span class="LaTeX">$\gcd(a,b)=k d$</span> for some <span class="LaTeX">$k$</span>. Similarly <span class="LaTeX">$d$</span> is a divisor of <span class="LaTeX">$c$</span> so <span class="LaTeX">$c=jd$</span> for some <span class="LaTeX">$j$</span>. Let <span class="LaTeX">$u=\gcd(k,j)$</span>. By our construction of <span class="LaTeX">$u$</span>, <span class="LaTeX">$ud | a,b,c$</span> but since <span class="LaTeX">$d$</span> is the greatest divisor <span class="LaTeX">$u$</span> is a <a href="Unit_(ring_theory)" title="wikilink">unit</a>. And since <span class="LaTeX">$ud=\gcd(gcd(a,b),c)$</span> the result is proven.</p>
<p>So if <span class="LaTeX">$na + mb = \gcd(a,b)$</span> then there are <span class="LaTeX">$x$</span> and <span class="LaTeX">$y$</span> such that <span class="LaTeX">$x\gcd(a,b) + yc = \gcd(a,b,c)$</span> so the final equation will be</p>
<p><span class="LaTeX">$$x(na + mb) + yc = (xn)a + (xm)b + yc =  \gcd(a,b,c).\,$$</span></p>
<p>So then to apply to n numbers we use induction</p>
<p><span class="LaTeX">$$\gcd(a_1,a_2,\dots,a_n) =\gcd(a_1,\, \gcd(a_2,\, \gcd(a_3,\dots, \gcd(a_{n-1}\,,a_n)))\dots),$$</span></p>
<p>with the equations following directly.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Euclidean_domain" title="wikilink">Euclidean domain</a></li>
<li><a href="Linear_congruence_theorem" title="wikilink">Linear congruence theorem</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>
<p>Volume 2, Chapter 4.</p></li>
<li><a href="Thomas_H._Cormen" title="wikilink">Thomas H. Cormen</a>, <a href="Charles_E._Leiserson" title="wikilink">Charles E. Leiserson</a>, <a href="Ronald_L._Rivest" title="wikilink">Ronald L. Rivest</a>, and <a href="Clifford_Stein" title="wikilink">Clifford Stein</a>. <em><a href="Introduction_to_Algorithms" title="wikilink">Introduction to Algorithms</a></em>, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Pages 859–861 of section 31.2: Greatest common divisor.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://mathforum.org/library/drmath/view/51675.html">Source for the form of the algorithm used to determine the multiplicative inverse in GF(2^8)</a></li>
</ul>
<p>"</p>
<p><a href="Category:Number_theoretic_algorithms" title="wikilink">Category:Number theoretic algorithms</a> <a href="Category:Articles_with_example_pseudocode" title="wikilink">Category:Articles with example pseudocode</a> <a class="uri" href="Category:Euclid" title="wikilink">Category:Euclid</a></p>
</body>
</html>
