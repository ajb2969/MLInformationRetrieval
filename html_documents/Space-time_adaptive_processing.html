<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="384">Space-time adaptive processing</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Space-time adaptive processing</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Doppler-Bearing response of a 2-dimensional beam-former</figcaption>
</figure>

<p><strong>Space-time adaptive processing</strong> (STAP) is a <a href="digital_signal_processing" title="wikilink">signal processing</a> technique most commonly used in <a class="uri" href="radar" title="wikilink">radar</a> systems. It involves adaptive array processing <a class="uri" href="algorithms" title="wikilink">algorithms</a> to aid in target detection. Radar signal processing benefits from STAP in areas where interference is a problem (i.e. ground <a href="clutter_(radar)" title="wikilink">clutter</a>, <a href="radar_jamming" title="wikilink">jamming</a>, etc.). Through careful application of STAP, it is possible to achieve order-of-magnitude sensitivity improvements in target detection.</p>

<p>STAP involves a two-dimensional <a href="digital_filter" title="wikilink">filtering</a> technique using a <a class="uri" href="phased-array" title="wikilink">phased-array</a> antenna with multiple spatial channels. Coupling multiple spatial channels with <a href="Pulse-doppler_radar" title="wikilink">pulse-Doppler</a> waveforms lends to the name "space-time." Applying the <a class="uri" href="statistics" title="wikilink">statistics</a> of the interference environment, an adaptive STAP weight vector is formed. This weight vector is applied to the <a href="Coherence_(physics)" title="wikilink">coherent</a> samples received by the radar.</p>
<h2 id="history">History</h2>

<p>The theory of STAP was first published by Lawrence E. Brennan and Irving S. Reed in the early 1970s. At the time of publication, both Brennan and Reed were at <a href="Technology_Service_Corporation" title="wikilink">Technology Service Corporation</a> (TSC). While it was formally introduced in 1973,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> it has theoretical roots dating back to 1959.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="motivation-and-applications">Motivation and Applications</h2>

<p>For ground-based radar, cluttered returns tend to be at DC, making them easily discriminated by <a href="Moving_target_indication" title="wikilink">Moving Target Indication (MTI)</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Thus, a notch filter at the zero-Doppler bin can be used.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Airborne platforms with ownship motion experience relative ground clutter motion dependent on the angle, resulting in angle-Doppler coupling at the input.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> In this case, 1D filtering is not sufficient, since clutter can overlap the desired target's Doppler from multiple directions.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> The resulting interference is typically called a "clutter ridge," since it forms a line in the angle-Doppler domain.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Narrowband jamming signals are also a source of interference, and exhibit significant spatial correlation.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Thus receiver noise and interference must be considered, and detection processors must attempt to maximize the <a href="Signal-to-interference-plus-noise_ratio" title="wikilink">signal-to-interference and noise ratio (SINR)</a>.</p>

<p>While primarily developed for radar, STAP techniques have applications for communications systems.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="basic-theory">Basic theory</h2>

<p> STAP is essentially filtering in the space-time domain.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> This means that we are filtering over multiple dimensions, and multi-dimensional signal processing techniques must be employed.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> The goal is to find the optimal space-time weights in 

<math display="inline" id="Space-time_adaptive_processing:0">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   NM
  </annotation>
 </semantics>
</math>

-dimensional space, where 

<math display="inline" id="Space-time_adaptive_processing:1">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 is the number of antenna elements (our spatial degrees of freedom) and 

<math display="inline" id="Space-time_adaptive_processing:2">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is the number of <a href="Pulse_repetition_frequency" title="wikilink">pulse-repetition interval (PRI)</a> taps (our time degrees of freedom), to maximize the <a href="Signal-to-interference-plus-noise_ratio" title="wikilink">signal-to-interference and noise ratio (SINR)</a>.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> Thus, the goal is to suppress noise, clutter, jammers, etc., while keeping the desired radar return. It can be thought of as a <a href="2D_Filters" title="wikilink">2-D</a> <a href="Finite_impulse_response" title="wikilink">finite-impulse response (FIR)</a> filter, with a standard 1-D FIR filter for each channel (steered spatial channels from an electronically steered array or individual elements), and the taps of these 1-D FIR filters corresponding to multiple returns (spaced at PRI time).<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> Having degrees of freedom in both the spatial domain and time domain is crucial, as clutter can be correlated in time and space, while jammers tend to be correlated spatially (along a specific bearing).<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>A simple, trivial example of STAP is shown in the first figure, for 

<math display="inline" id="Space-time_adaptive_processing:3">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mi>M</mi>
   <mo>=</mo>
   <mn>10</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>N</ci>
     <ci>M</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">10</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=M=10
  </annotation>
 </semantics>
</math>

. This is an idealized example of a steering pattern, where the response of the array has been steered to the ideal target response, 

<math display="inline" id="Space-time_adaptive_processing:4">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> Unfortunately, in practice, this is oversimplified, as the interference to be overcome by steering the nulls shown is not deterministic, but statistical in nature.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> This is what requires STAP to be an adaptive technique. Note that even in this idealized example, in general, we must steer over the 2-D angle-Doppler plane at discrete points to detect potential targets (moving the location of the 2-D sinc main lobe shown in the figure), and do so for each of the range bins in our system.</p>

<p>The basic functional diagram is shown to the right. For each antenna, a down conversion and analog-to-digital conversion step is typically completed. Then, a 1-D FIR filter with PRI length delay elements is used for each steered antenna channel. The lexicographically ordered weights 

<math display="inline" id="Space-time_adaptive_processing:5">
 <semantics>
  <msub>
   <mi>W</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>W</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{1}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Space-time_adaptive_processing:6">
 <semantics>
  <msub>
   <mi>W</mi>
   <mrow>
    <mi>N</mi>
    <mi>M</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>W</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{NM}
  </annotation>
 </semantics>
</math>

 are the degrees of freedom to be solved in the STAP problem. That is, STAP aims to find the optimal weights for the antenna array. It can be shown, that for a given 

<math display="inline" id="Space-time_adaptive_processing:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>M</mi>
     <mi>N</mi>
    </mrow>
    <mo>×</mo>
    <mi>M</mi>
   </mrow>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>M</ci>
      <ci>N</ci>
     </apply>
     <ci>M</ci>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   MN\times MN
  </annotation>
 </semantics>
</math>

 interference covariance matrix, 

<math display="inline" id="Space-time_adaptive_processing:8">
 <semantics>
  <mi>𝐑</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐑</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{R}
  </annotation>
 </semantics>
</math>

, the optimal weights maximizing the SINR are calculated as</p>

<p>

<math display="inline" id="Space-time_adaptive_processing:9">
 <semantics>
  <mrow>
   <mi>𝐖</mi>
   <mo>=</mo>
   <mrow>
    <mi>κ</mi>
    <msup>
     <mi>𝐑</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>s</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐖</ci>
    <apply>
     <times></times>
     <ci>κ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐑</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{W}=\kappa\mathbf{R}^{-1}s
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Space-time_adaptive_processing:10">
 <semantics>
  <mi>κ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>κ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa
  </annotation>
 </semantics>
</math>

 is a scalar that does not affect the SINR.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> The optimal detector input is given by:</p>

<p>

<math display="inline" id="Space-time_adaptive_processing:11">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mi>𝐖</mi>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <times></times>
     <ci>𝐖</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=\mathbf{W}x
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Space-time_adaptive_processing:12">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is a space-time snap-shot of the input data. The main difficulty of STAP is solving for and inverting the typically unknown interference covariance matrix, 

<math display="inline" id="Space-time_adaptive_processing:13">
 <semantics>
  <mi>𝐑</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐑</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{R}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> Other difficulties arise when the interference covariance matrix is ill-conditioned, making the inversion numerically unstable.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> In general, this adaptive filtering must be performed for each of the unambiguous range bins in the system, for each target of interest (angle-Doppler coordinates), making for a massive computational burden.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> Steering losses can occur when true target returns do not fall exactly on one of the points in our 2-D angle-Doppler plane that we've sampled with our steering vector 

<math display="inline" id="Space-time_adaptive_processing:14">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>
<h2 id="approaches">Approaches</h2>

<p>The various approaches can be broken down by processing taxonomy,<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> or by simplifying the data space / data sources.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>
<h3 id="direct-methods">Direct Methods</h3>

<p>The optimum solution is using all degrees of freedom by processing the adaptive filter on the antenna elements. For adaptive direct methods, <a href="Sample_matrix_inversion" title="wikilink">Sample Matrix Inversion (SMI)</a> uses the estimated (sample) interference covariance matrix in place of the actual interference covariance matrix.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> This is because the actual interference covariance matrix is not known in practice.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> If it is known by some means, then it need not be estimated, and the optimal weights are fixed. This is sometimes called the data-independent variation. The data-dependent variation estimates the interference covariance matrix from the data. In MIMO communications systems, this can be done via a training sequence.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> The clairvoyant detector is given when the covariance matrix is known perfectly and defined as:</p>

<p>

<math display="inline" id="Space-time_adaptive_processing:15">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐑</mi>
    <mi>𝐤</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mrow>
     <mrow>
      <mtext>E</mtext>
      <mrow>
       <mo>[</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mi>k</mi>
        </msub>
        <msubsup>
         <mi>x</mi>
         <mi>k</mi>
         <mi>H</mi>
        </msubsup>
       </mrow>
       <mo>]</mo>
      </mrow>
     </mrow>
     <mo fence="true">|</mo>
    </mrow>
    <msub>
     <mi>H</mi>
     <mn>0</mn>
    </msub>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐑</ci>
     <ci>𝐤</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">evaluated-at</csymbol>
     <apply>
      <times></times>
      <mtext>E</mtext>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>x</ci>
          <ci>H</ci>
         </apply>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{R_{k}}=\mbox{E}\left[x_{k}x^{H}_{k}\right]\Bigr|_{H_{0}}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Space-time_adaptive_processing:16">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}
  </annotation>
 </semantics>
</math>

 is the space-time snapshot statistic for the 

<math display="inline" id="Space-time_adaptive_processing:17">
 <semantics>
  <msup>
   <mi>k</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{th}
  </annotation>
 </semantics>
</math>

 range cell under the interference only hypothesis, 

<math display="inline" id="Space-time_adaptive_processing:18">
 <semantics>
  <msub>
   <mi>H</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{0}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> For SMI, the interference covariance matrix for the 

<math display="inline" id="Space-time_adaptive_processing:19">
 <semantics>
  <msup>
   <mi>k</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{th}
  </annotation>
 </semantics>
</math>

 range cell consisting of the statistics from interfering noise, clutter, and jammers is estimated as follows:<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> 

<math display="inline" id="Space-time_adaptive_processing:20">
 <semantics>
  <mrow>
   <mover accent="true">
    <msub>
     <mi>𝐑</mi>
     <mi>𝐤</mi>
    </msub>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>P</mi>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>m</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <mi>P</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>m</mi>
      </msub>
      <msubsup>
       <mi>x</mi>
       <mi>m</mi>
       <mi>H</mi>
      </msubsup>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-^</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐑</ci>
      <ci>𝐤</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>P</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>m</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>P</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>m</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <ci>H</ci>
        </apply>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\hat{R_{k}}}=\frac{1}{P}\sum_{m=0}^{P-1}x_{m}x^{H}_{m}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Space-time_adaptive_processing:21">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{m}
  </annotation>
 </semantics>
</math>

 is the training data obtained from the input processor for the 

<math display="inline" id="Space-time_adaptive_processing:22">
 <semantics>
  <msup>
   <mi>m</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>m</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m^{th}
  </annotation>
 </semantics>
</math>

 range cell. Therefore, space-time snapshots surrounding the desired range cell are averaged. Note that the desired range cell space-time snapshot is typically excluded (as well as a number of additional cells, or "guard cells") to prevent whitening of the statistics.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>

<p>The main problem with direct methods is the great computational complexity associated with the estimation and inversion of matrices formed from many degrees of freedom (large number of elements and or pulses).<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> In addition, for methods where 

<math display="inline" id="Space-time_adaptive_processing:23">
 <semantics>
  <mi>𝐑</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐑</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{R}
  </annotation>
 </semantics>
</math>

 must be estimated using data samples, the number of samples required to achieve a particular error is heavily dependent on the dimensionality of the interference covariance matrix.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> As a result, for high dimensional systems, this may require an unachievable number of unambiguous range cells.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> Further, these adjacent data cells must contain stationary statistics as a function of range which is rarely a good assumption for the large number of cells required (

<math display="inline" id="Space-time_adaptive_processing:24">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>N</mi>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>N</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2NM
  </annotation>
 </semantics>
</math>

 for 3 dB SINR degradation from optimal, clairvoyant STAP).<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a><a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a></p>
<h3 id="reduced-rank-methods">Reduced Rank Methods</h3>

<p>Reduced rank methods aim to overcome the computational burdens of the direct method by reducing the dimensionality of the data or the rank of the interference covariance matrix.<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> This can be accomplished by forming beams and performing STAP on the beamspace.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> Both pre and post Doppler methods can be used in the beamspace. Post Doppler methods may also be used on the full antenna element input as well to reduce the data in this dimension only. A popular example is displaced phase center antenna (DPCA), which is a form of data-independent STAP in the beamspace, pre-Doppler.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> The goal is to perform beamforming such that the beam appears stationary as the airborne radar is in motion over discrete time periods so the clutter appears without Doppler.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> However, phase errors can cause significant degradation since the algorithm is not adaptive to the returned data.<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a> Many other methods may be used to reduce the rank of the interference covariance matrix, and so all methods in the reduced rank category can be thought of as simplifying the covariance matrix to be inverted:</p>

<p>

<math display="inline" id="Space-time_adaptive_processing:25">
 <semantics>
  <mrow>
   <mi>𝐑</mi>
   <mo>⇒</mo>
   <mover accent="true">
    <mi>𝐑</mi>
    <mo>~</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇒</ci>
    <ci>𝐑</ci>
    <apply>
     <ci>normal-~</ci>
     <ci>𝐑</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{R}\Rightarrow\mathbf{\widetilde{R}}
  </annotation>
 </semantics>
</math>

</p>

<p>Post-Doppler methods decompose the STAP problem from an 

<math display="inline" id="Space-time_adaptive_processing:26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>M</mi>
     <mi>N</mi>
    </mrow>
    <mo>×</mo>
    <mi>M</mi>
   </mrow>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>M</ci>
      <ci>N</ci>
     </apply>
     <ci>M</ci>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   MN\times MN
  </annotation>
 </semantics>
</math>

 adaptive filtering problem to 

<math display="inline" id="Space-time_adaptive_processing:27">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 individual adaptive filters of length 

<math display="inline" id="Space-time_adaptive_processing:28">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 (an 

<math display="inline" id="Space-time_adaptive_processing:29">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>×</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\times N
  </annotation>
 </semantics>
</math>

 adaptive filter problem).<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a> By performing fixed Doppler processing, the adaptive filters become spatial only.<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> Since the target response is already steered to a specified angle-Doppler location, the dimensionality can be reduced by pre-processing multiple Doppler bins and angles surrounding this point.<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a> In addition to reducing the dimensionality of the adaptive processor, this in turn reduces the number of required training data frames when estimating the interference covariance matrix since this quantity is dimension dependent.<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a></p>

<p>Since these methods reduce the data dimensionality, they are inherently sub-optimal.<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a> There are a number of techniques to compare the performance of reduced-rank methods and estimated direct methods to clairvoyant STAP (direct with perfect knowledge of interference covariance matrix and target steering vector), mostly based around SINR loss.<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a> One such example is</p>

<p>

<math display="inline" id="Space-time_adaptive_processing:30">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mrow>
     <mi>s</mi>
     <mo>,</mo>
     <mn>2</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mfrac>
    <msub>
     <mrow>
      <mtext>SINR</mtext>
      <mo fence="true">|</mo>
     </mrow>
     <mrow>
      <mi>W</mi>
      <mo>=</mo>
      <mover accent="true">
       <mi>W</mi>
       <mo stretchy="false">^</mo>
      </mover>
     </mrow>
    </msub>
    <msub>
     <mrow>
      <mtext>SINR</mtext>
      <mo fence="true">|</mo>
     </mrow>
     <mrow>
      <mi>W</mi>
      <mo>=</mo>
      <msub>
       <mi>W</mi>
       <mrow>
        <mi>o</mi>
        <mi>p</mi>
        <mi>t</mi>
       </mrow>
      </msub>
     </mrow>
    </msub>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <list>
      <ci>s</ci>
      <cn type="integer">2</cn>
     </list>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="latexml">evaluated-at</csymbol>
      <mtext>SINR</mtext>
      <apply>
       <eq></eq>
       <ci>W</ci>
       <apply>
        <ci>normal-^</ci>
        <ci>W</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">evaluated-at</csymbol>
      <mtext>SINR</mtext>
      <apply>
       <eq></eq>
       <ci>W</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>W</ci>
        <apply>
         <times></times>
         <ci>o</ci>
         <ci>p</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{s,2}=\frac{\mbox{SINR}\Bigr|_{W=\hat{W}}}{\mbox{SINR}\Bigr|_{W=W_{opt}}}
  </annotation>
 </semantics>
</math>

</p>

<p>where we've taken the ratio of the SINR evaluated with the sub-optimal weights 

<math display="inline" id="Space-time_adaptive_processing:31">
 <semantics>
  <mover accent="true">
   <mi>W</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{W}
  </annotation>
 </semantics>
</math>

 and the SINR evaluated with the optimal weights 

<math display="inline" id="Space-time_adaptive_processing:32">
 <semantics>
  <msub>
   <mi>W</mi>
   <mrow>
    <mi>o</mi>
    <mi>p</mi>
    <mi>t</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>W</ci>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>p</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{opt}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a> Note in general this quantity is statistical and the expectation must be taken to find the average SINR loss. The clairvoyant SINR loss may also be calculated by taking the ratio of the optimal SINR to the system SNR, indicating the loss due to interference.<a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a></p>
<h3 id="model-based-methods">Model Based Methods</h3>

<p>There are also model based methods that attempt to force or exploit the structure of the covariance interference matrix. The more generally applicable of these methods is the covariance taper matrix structure.<a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a> The goal is to compactly model the interference, at which point it can then be processed using principal component techniques or diagonal-loading SMI (where a small magnitude, random diagonal matrix is added to attempt to stabilize the matrix prior to inverting).<a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a> This modeling has an added benefit of decorrelating interference subspace leakage (ISL), and is resistant to internal clutter motion (ICM).<a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a> The principal component method firsts applies <a href="principal_component_analysis" title="wikilink">principal component analysis</a> to estimate the dominate eigenvalues and eigenvectors, and then applies a covariance taper and adds an estimated noise floor:</p>

<p>

<math display="inline" id="Space-time_adaptive_processing:33">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>𝐑</mi>
     <mo>~</mo>
    </mover>
    <mrow>
     <mi>𝐏𝐂</mi>
     <mo>-</mo>
     <mi>𝐂𝐌𝐓</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msubsup>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mi>m</mi>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mrow>
         <mi>P</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msubsup>
       <mrow>
        <msub>
         <mi>λ</mi>
         <mi>m</mi>
        </msub>
        <msub>
         <mi>v</mi>
         <mi>m</mi>
        </msub>
        <msubsup>
         <mi>v</mi>
         <mi>m</mi>
         <mi>H</mi>
        </msubsup>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mo>∘</mo>
     <mi>T</mi>
    </mrow>
    <mo>+</mo>
    <msubsup>
     <mi>σ</mi>
     <mi>n</mi>
     <mn>2</mn>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>𝐑</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>𝐏𝐂</ci>
      <ci>𝐂𝐌𝐓</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <compose></compose>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>m</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>P</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <ci>m</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>v</ci>
         <ci>m</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>v</ci>
          <ci>H</ci>
         </apply>
         <ci>m</ci>
        </apply>
       </apply>
      </apply>
      <ci>T</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>σ</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\widetilde{R}_{PC-CMT}}=\left(\sum_{m=0}^{P-1}\lambda_{m}v_{m}v^{H}_{m%
}\right)\circ T+\sigma^{2}_{n}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Space-time_adaptive_processing:34">
 <semantics>
  <msub>
   <mi>λ</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>λ</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{m}
  </annotation>
 </semantics>
</math>

 is the 

<math display="inline" id="Space-time_adaptive_processing:35">
 <semantics>
  <msup>
   <mi>m</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>m</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m^{th}
  </annotation>
 </semantics>
</math>

 eigenvalue estimated using PCA, 

<math display="inline" id="Space-time_adaptive_processing:36">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{m}
  </annotation>
 </semantics>
</math>

 is the associated 

<math display="inline" id="Space-time_adaptive_processing:37">
 <semantics>
  <msup>
   <mi>m</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>m</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m^{th}
  </annotation>
 </semantics>
</math>

 eigenvector estimated using PCA, 

<math display="inline" id="Space-time_adaptive_processing:38">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∘</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <compose></compose>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\circ B
  </annotation>
 </semantics>
</math>

 implies element-by-element multiplication of matrices 

<math display="inline" id="Space-time_adaptive_processing:39">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Space-time_adaptive_processing:40">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Space-time_adaptive_processing:41">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is the estimated covariance matrix taper, and 

<math display="inline" id="Space-time_adaptive_processing:42">
 <semantics>
  <msubsup>
   <mi>σ</mi>
   <mi>n</mi>
   <mn>2</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>σ</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}_{n}
  </annotation>
 </semantics>
</math>

 is the estimated noise floor.<a class="footnoteRef" href="#fn51" id="fnref51"><sup>51</sup></a> The estimation of the covariance taper 

<math display="inline" id="Space-time_adaptive_processing:43">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 can be complicated, depending on the complexity of the underlying model attempting to emulate the interference environment. The reader is encouraged to see <a class="footnoteRef" href="#fn52" id="fnref52"><sup>52</sup></a> for more information on this particular subject. Once this taper is sufficiently modeled, it may also be applied to the more simple SMI adaptation of CMT as follows:</p>

<p>

<math display="inline" id="Space-time_adaptive_processing:44">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>𝐑</mi>
     <mo>~</mo>
    </mover>
    <mrow>
     <mi>𝐒𝐌𝐈</mi>
     <mo>-</mo>
     <mi>𝐂𝐌𝐓</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mover accent="true">
       <mi>𝐑</mi>
       <mo>~</mo>
      </mover>
      <mi>𝐒𝐌𝐈</mi>
     </msub>
     <mo>∘</mo>
     <mi>T</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>δ</mi>
     <mi>I</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>𝐑</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>𝐒𝐌𝐈</ci>
      <ci>𝐂𝐌𝐓</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <compose></compose>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>𝐑</ci>
       </apply>
       <ci>𝐒𝐌𝐈</ci>
      </apply>
      <ci>T</ci>
     </apply>
     <apply>
      <times></times>
      <ci>δ</ci>
      <ci>I</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\widetilde{R}_{SMI-CMT}}=\mathbf{\widetilde{R}_{SMI}}\circ T+\delta I
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Space-time_adaptive_processing:45">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>𝐑</mi>
    <mo>~</mo>
   </mover>
   <mi>𝐒𝐌𝐈</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-~</ci>
     <ci>𝐑</ci>
    </apply>
    <ci>𝐒𝐌𝐈</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\widetilde{R}_{SMI}}
  </annotation>
 </semantics>
</math>

 is the typical SMI estimated matrix seen in the approximate direct method, 

<math display="inline" id="Space-time_adaptive_processing:46">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

 is the diagonal loading factor, and 

<math display="inline" id="Space-time_adaptive_processing:47">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 is the identity matrix of the appropriate size. It should be seen that this is meant to improve the standard SMI method where SMI uses a smaller number of range bins in its average than the standard SMI technique. Since fewer samples are used in the training data, the matrix often requires stabilization in the form of diagonal loading.<a class="footnoteRef" href="#fn53" id="fnref53"><sup>53</sup></a></p>

<p>More restrictive examples involve modeling the interference to force Toeplitz structures, and can greatly reduce the computational complexity associated with the processing by exploiting this structure.<a class="footnoteRef" href="#fn54" id="fnref54"><sup>54</sup></a> However, these methods can suffer due to model-mismatch, or the computational savings may be undone by the problem of model fitting (such as the nonlinear problem of fitting to a Toeplitz or block-Toeplitz matrix) and order estimation.<a class="footnoteRef" href="#fn55" id="fnref55"><sup>55</sup></a></p>
<h2 id="modern-applications">Modern applications</h2>

<p>Despite nearly 40 years of existence, STAP has modern applications.</p>
<h3 id="mimo-communications">MIMO Communications</h3>

<p>For dispersive channels, <a href="multiple-input_multiple-output_communications" title="wikilink">multiple-input multiple-output communications</a> can formulate STAP solutions. Frequency-selective channel compensation can be used to extend traditional <a href="Equalization_(communications)" title="wikilink">equalization</a> techniques for <a href="Single-Input_and_Single-Output" title="wikilink">SISO</a> systems using STAP.<a class="footnoteRef" href="#fn56" id="fnref56"><sup>56</sup></a> To estimate the transmitted signal 

<math display="inline" id="Space-time_adaptive_processing:48">
 <semantics>
  <mover accent="true">
   <mi>𝐒</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>𝐒</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\hat{S}}
  </annotation>
 </semantics>
</math>

 at a MIMO receiver, we can linearly weight our space-time input 

<math display="inline" id="Space-time_adaptive_processing:49">
 <semantics>
  <mover accent="true">
   <mi>𝐙</mi>
   <mo>~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>𝐙</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\widetilde{Z}}
  </annotation>
 </semantics>
</math>

 with weighting matrix 

<math display="inline" id="Space-time_adaptive_processing:50">
 <semantics>
  <mover accent="true">
   <mi>𝐖</mi>
   <mo>~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>𝐖</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\widetilde{W}}
  </annotation>
 </semantics>
</math>

 as follows</p>

<p>

<math display="inline" id="Space-time_adaptive_processing:51">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>𝐒</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <msup>
     <mover accent="true">
      <mi>𝐖</mi>
      <mo>~</mo>
     </mover>
     <mi mathvariant="normal">T</mi>
    </msup>
    <mover accent="true">
     <mi>𝐙</mi>
     <mo>~</mo>
    </mover>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-^</ci>
     <ci>𝐒</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-~</ci>
       <ci>𝐖</ci>
      </apply>
      <ci>normal-T</ci>
     </apply>
     <apply>
      <ci>normal-~</ci>
      <ci>𝐙</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\hat{S}}=\mathbf{\widetilde{W}}^{\mathrm{T}}\mathbf{\widetilde{Z}}
  </annotation>
 </semantics>
</math>

</p>

<p>to minimize the <a href="Mean_squared_error" title="wikilink">mean squared error (MSE)</a>.<a class="footnoteRef" href="#fn57" id="fnref57"><sup>57</sup></a> Using STAP with a training sequence 

<math display="inline" id="Space-time_adaptive_processing:52">
 <semantics>
  <mover accent="true">
   <mi>𝐒</mi>
   <mo>~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>𝐒</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\widetilde{S}}
  </annotation>
 </semantics>
</math>

, the estimated optimal weighting matrix (STAP coefficients) is given by:<a class="footnoteRef" href="#fn58" id="fnref58"><sup>58</sup></a> 

<math display="inline" id="Space-time_adaptive_processing:53">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>𝐖</mi>
    <mo>~</mo>
   </mover>
   <mo>≈</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mover accent="true">
       <mi>𝐙</mi>
       <mo>~</mo>
      </mover>
      <msup>
       <mover accent="true">
        <mi>𝐙</mi>
        <mo>~</mo>
       </mover>
       <mi mathvariant="normal">T</mi>
      </msup>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mover accent="true">
     <mi>𝐙</mi>
     <mo>~</mo>
    </mover>
    <msup>
     <mover accent="true">
      <mi>𝐒</mi>
      <mo>~</mo>
     </mover>
     <mi mathvariant="normal">T</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <ci>normal-~</ci>
     <ci>𝐖</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <ci>normal-~</ci>
       <ci>𝐙</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>𝐙</ci>
       </apply>
       <ci>normal-T</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-~</ci>
      <ci>𝐙</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>normal-~</ci>
       <ci>𝐒</ci>
      </apply>
      <ci>normal-T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\widetilde{W}}\approx\left(\mathbf{\widetilde{Z}}\mathbf{\widetilde{Z}%
}^{\mathrm{T}}\right)\mathbf{\widetilde{Z}}\mathbf{\widetilde{S}}^{\mathrm{T}}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="mimo-radar">MIMO Radar</h3>

<p>STAP has been extended for <a href="MIMO_radar" title="wikilink">MIMO radar</a> to improve spatial resolution for clutter, using modified <a href="Single-Input_and_Single-Output" title="wikilink">SIMO</a> radar STAP techniques.<a class="footnoteRef" href="#fn59" id="fnref59"><sup>59</sup></a> New algorithms and formulations are required that depart from the standard technique due to the large rank of the jammer-clutter subspace created by MIMO radar virtual arrays,<a class="footnoteRef" href="#fn60" id="fnref60"><sup>60</sup></a> which typically involving exploiting the block diagonal structure of the MIMO interference covariance matrix to break the large matrix inversion problem into smaller ones. In comparison with SIMO radar systems, which will have 

<math display="inline" id="Space-time_adaptive_processing:54">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 transmit degrees of freedom, and 

<math display="inline" id="Space-time_adaptive_processing:55">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   NL
  </annotation>
 </semantics>
</math>

 receive degrees of freedom, for a total of 

<math display="inline" id="Space-time_adaptive_processing:56">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>+</mo>
   <mrow>
    <mi>N</mi>
    <mi>L</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>M</ci>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M+NL
  </annotation>
 </semantics>
</math>

, MIMO radar systems have 

<math display="inline" id="Space-time_adaptive_processing:57">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mi>N</mi>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <ci>N</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   MNL
  </annotation>
 </semantics>
</math>

 degrees of freedom, allowing for much greater adaptive spatial resolution for clutter mitigation.<a class="footnoteRef" href="#fn61" id="fnref61"><sup>61</sup></a></p>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Brennan, L.E. and I.S. Reed, <em>Theory of Adaptive Radar</em>, IEEE AES-9, pp. 237–252, 1973</li>
<li>Guerci, J.R., <em>Space-Time Adaptive Processing for Radar</em>, Artech House Publishers, 2003. ISBN 1-58053-377-9.</li>
<li>Klemm, Richard, <em>Principles of Space-Time Adaptive Processing</em>, IEE Publishing, 2002. ISBN 0-85296-172-3.</li>
<li>Klemm, Richard, <em>Applications of Space-Time Adaptive Processing</em>, IEE Publishing, 2004. ISBN 0-85296-924-4.</li>
<li>Melvin, W.L., <em>A STAP Overview,</em> IEEE AES Systems Magazine – Special Tutorials Issue, Vol. 19, No. 1, January 2004, pp. 19–35.</li>
<li>Michael Parker, <a href="http://www.eetimes.com/document.asp?doc_id=1278878">Radar Basics – Part 4: Space-time adaptive processing</a>, EETimes, 6/28/2011</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Array_processing" title="wikilink">Array processing</a></li>
<li><a class="uri" href="Beamforming" title="wikilink">Beamforming</a></li>
<li><a href="Multiple-input_multiple-output_communications" title="wikilink">MIMO</a></li>
<li><a href="Multistatic_radar" title="wikilink">Multistatic radar</a></li>
<li><a href="Phased_array" title="wikilink">Phased array</a></li>
<li><a href="Synthetic_aperture_radar" title="wikilink">Synthetic aperture radar</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Radar_signal_processing" title="wikilink">Category:Radar signal processing</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"></li>
<li id="fn3">Richards, M.A., Scheer, J.A., and Holm, W.A., <em>Principles of Modern Radar</em>, SciTech Publishing, 2010. ISBN 1-89112-152-9.<a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10">Guerci, J.R., <em>Space-Time Adaptive Processing for Radar</em>, Artech House Publishers, 2003. ISBN 1-58053-377-9.<a href="#fnref10">↩</a></li>
<li id="fn11">Dudgeon, D.E. and Mersereau, R.M., <em>Multidimensional Digital Signal Processing</em>, Prentice-Hall Signal Processing Series, 1984. ISBN 0-13604-959-1.<a href="#fnref11">↩</a></li>
<li id="fn12"></li>
<li id="fn13">Melvin, W.L., <em>A STAP Overview,</em> IEEE AES Systems Magazine – Special Tutorials Issue, Vol. 19, No. 1, January 2004, pp. 19–35.<a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20">Richards, M.A., <em>Fundamentals of Radar Signal Processing</em>, McGraw-Hill Education, 2014. ISBN 0-07179-832-3.<a href="#fnref20">↩</a></li>
<li id="fn21"></li>
<li id="fn22">Ward, J., <em>Space-Time Adaptive Processing for Airborne Radar,</em> IEE Colloquium on Space-Time Adaptive Processing (Ref. No. 1998/241), April 1998, pp. 2/1–2/6.<a href="#fnref22">↩</a></li>
<li id="fn23"></li>
<li id="fn24">Van Trees, H. L., Optimum Array Processing, Wiley, NY, 2002.<a href="#fnref24">↩</a></li>
<li id="fn25"></li>
<li id="fn26"></li>
<li id="fn27"></li>
<li id="fn28"></li>
<li id="fn29"></li>
<li id="fn30"></li>
<li id="fn31"></li>
<li id="fn32"></li>
<li id="fn33"></li>
<li id="fn34"></li>
<li id="fn35"></li>
<li id="fn36"></li>
<li id="fn37"></li>
<li id="fn38"></li>
<li id="fn39"></li>
<li id="fn40"></li>
<li id="fn41"></li>
<li id="fn42"></li>
<li id="fn43"></li>
<li id="fn44"></li>
<li id="fn45"></li>
<li id="fn46"></li>
<li id="fn47"></li>
<li id="fn48"></li>
<li id="fn49"></li>
<li id="fn50"></li>
<li id="fn51"></li>
<li id="fn52"></li>
<li id="fn53"></li>
<li id="fn54"></li>
<li id="fn55"></li>
<li id="fn56">Bliss, D.W. and Govindasamy, S., <em>Adaptive Wireless Communications: MIMO Channels and Networks</em>, Cambridge University Press, 2013. ISBN 1-10703-320-9.<a href="#fnref56">↩</a></li>
<li id="fn57"></li>
<li id="fn58"></li>
<li id="fn59">Li, J. and Stoica, P., <em>MIMO Radar Signal Processing</em>, John Wiley &amp; Sons, 2009. ISBN 0-47017-898-1.<a href="#fnref59">↩</a></li>
<li id="fn60"></li>
<li id="fn61"></li>
</ol>
</section>
</body>
</html>
