<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="49">Chord (peer-to-peer)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Chord (peer-to-peer)</h1>
<hr/>

<p>In <a class="uri" href="computing" title="wikilink">computing</a>, <strong>Chord</strong> is a protocol and <a class="uri" href="algorithm" title="wikilink">algorithm</a> for a <a class="uri" href="peer-to-peer" title="wikilink">peer-to-peer</a> <a href="distributed_hash_table" title="wikilink">distributed hash table</a>. A distributed hash table stores <a href="associative_array" title="wikilink">key-value pairs</a> by assigning keys to different computers (known as "nodes"); a node will store the values for all the keys for which it is responsible. Chord specifies how keys are assigned to nodes, and how a node can discover the value for a given key by first locating the node responsible for that key.</p>

<p>Chord is one of the four original <a href="distributed_hash_table" title="wikilink">distributed hash table</a> protocols, along with <a href="Content_addressable_network" title="wikilink">CAN</a>, <a href="Tapestry_(DHT)" title="wikilink">Tapestry</a>, and <a href="Pastry_(DHT)" title="wikilink">Pastry</a>. It was introduced in 2001 by <a href="Ion_Stoica" title="wikilink">Ion Stoica</a>, <a href="Robert_Tappan_Morris" title="wikilink">Robert Morris</a>, <a href="David_Karger" title="wikilink">David Karger</a>, <a href="Frans_Kaashoek" title="wikilink">Frans Kaashoek</a>, and <a href="Hari_Balakrishnan" title="wikilink">Hari Balakrishnan</a>, and was developed at <a class="uri" href="MIT" title="wikilink">MIT</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="overview">Overview</h2>
<figure><b>(Figure)</b>
<figcaption>Chord project.svg</figcaption>
</figure>

<p>Nodes and keys are assigned an 

<math display="inline" id="Chord_(peer-to-peer):0">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

-bit <em>identifier</em> using <em><a href="consistent_hashing" title="wikilink">consistent hashing</a></em>. The <a class="uri" href="SHA-1" title="wikilink">SHA-1</a> algorithm is the base <a href="Hash_function" title="wikilink">hashing function</a> for consistent hashing. Consistent hashing is integral to the robustness and performance of Chord because both keys and nodes (in fact, their <a href="IP_address" title="wikilink">IP addresses</a>) are uniformly distributed in the same identifier space with a negligible possibility of collision. Thus, it also allows nodes to join and leave the network without disruption. In the protocol, the term <em>node</em> is used to refer to both a node itself and its identifier (ID) without ambiguity. So is the term <em>key</em>.</p>

<p>Using the Chord lookup protocol, nodes and keys are arranged in an identifier circle that has at most 

<math display="inline" id="Chord_(peer-to-peer):1">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>m</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{m}
  </annotation>
 </semantics>
</math>

 nodes, ranging from 

<math display="inline" id="Chord_(peer-to-peer):2">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 to 

<math display="inline" id="Chord_(peer-to-peer):3">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mi>m</mi>
   </msup>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>m</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{m}-1
  </annotation>
 </semantics>
</math>


. (

<math display="inline" id="Chord_(peer-to-peer):4">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 should be large enough to avoid collision.)</p>

<p>Each node has a <em>successor</em> and a <em>predecessor</em>. The successor to a node is the next node in the identifier circle in a clockwise direction. The predecessor is counter-clockwise. If there is a node for each possible ID, the successor of node 0 is node 1, and the predecessor of node 0 is node 

<math display="inline" id="Chord_(peer-to-peer):5">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mi>m</mi>
   </msup>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>m</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{m}-1
  </annotation>
 </semantics>
</math>

; however, normally there are "holes" in the sequence. For example, the successor of node 153 may be node 167 (and nodes from 154 to 166 do not exist); in this case, the predecessor of node 167 will be node 153.</p>

<p>The concept of successor can be used for keys as well. The <em>successor node</em> of a key 

<math display="inline" id="Chord_(peer-to-peer):6">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is the first node whose ID equals to 

<math display="inline" id="Chord_(peer-to-peer):7">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 or follows 

<math display="inline" id="Chord_(peer-to-peer):8">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>


 in the identifier circle, denoted by 

<math display="inline" id="Chord_(peer-to-peer):9">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mi>u</mi>
   <mi>c</mi>
   <mi>c</mi>
   <mi>e</mi>
   <mi>s</mi>
   <mi>s</mi>
   <mi>o</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>u</ci>
    <ci>c</ci>
    <ci>c</ci>
    <ci>e</ci>
    <ci>s</ci>
    <ci>s</ci>
    <ci>o</ci>
    <ci>r</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   successor(k)
  </annotation>
 </semantics>
</math>

. Every key is assigned to (stored at) its successor node, so looking up a key 

<math display="inline" id="Chord_(peer-to-peer):10">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is to query 

<math display="inline" id="Chord_(peer-to-peer):11">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mi>u</mi>
   <mi>c</mi>
   <mi>c</mi>
   <mi>e</mi>
   <mi>s</mi>
   <mi>s</mi>
   <mi>o</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>u</ci>
    <ci>c</ci>
    <ci>c</ci>
    <ci>e</ci>
    <ci>s</ci>
    <ci>s</ci>
    <ci>o</ci>
    <ci>r</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   successor(k)
  </annotation>
 </semantics>
</math>

.</p>

<p>Since the successor (or predecessor) of a node may disappear from the network (because of failure or departure), each node records a whole segment of the circle adjacent to it, i.e., the 

<math display="inline" id="Chord_(peer-to-peer):12">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 nodes preceding it and the 

<math display="inline" id="Chord_(peer-to-peer):13">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>


 nodes following it. This list results in a high probability that a node is able to correctly locate its successor or predecessor, even if the network in question suffers from a high failure rate.</p>
<h2 id="protocol-details">Protocol details</h2>
<figure><b>(Figure)</b>
<figcaption>A 16-node Chord network. The "fingers" for one of the nodes are highlighted.</figcaption>
</figure>
<h3 id="basic-query">Basic query</h3>

<p>The core usage of the Chord protocol is to query a key from a client (generally a node as well), i.e. to find 

<math display="inline" id="Chord_(peer-to-peer):14">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mi>u</mi>
   <mi>c</mi>
   <mi>c</mi>
   <mi>e</mi>
   <mi>s</mi>
   <mi>s</mi>
   <mi>o</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>u</ci>
    <ci>c</ci>
    <ci>c</ci>
    <ci>e</ci>
    <ci>s</ci>
    <ci>s</ci>
    <ci>o</ci>
    <ci>r</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   successor(k)
  </annotation>
 </semantics>
</math>

. The basic approach is to pass the query to a node's successor, if it cannot find the key locally. This will lead to a 

<math display="inline" id="Chord_(peer-to-peer):15">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(N)
  </annotation>
 </semantics>
</math>

 query time.</p>
<h3 id="finger-table">Finger table</h3>

<p>To avoid the linear search above, Chord implements a faster search method by requiring each node to keep a <em>finger table</em> containing up to 

<math display="inline" id="Chord_(peer-to-peer):16">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 entries. The 

<math display="inline" id="Chord_(peer-to-peer):17">
 <semantics>
  <msup>
   <mi>i</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>i</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i^{th}
  </annotation>
 </semantics>
</math>

 entry of node 

<math display="inline" id="Chord_(peer-to-peer):18">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


 will contain 

<math display="inline" id="Chord_(peer-to-peer):19">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mi>u</mi>
   <mi>c</mi>
   <mi>c</mi>
   <mi>e</mi>
   <mi>s</mi>
   <mi>s</mi>
   <mi>o</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <msup>
        <mn>2</mn>
        <mrow>
         <mi>i</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
     <msup>
      <mn>2</mn>
      <mi>m</mi>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>u</ci>
    <ci>c</ci>
    <ci>c</ci>
    <ci>e</ci>
    <ci>s</ci>
    <ci>s</ci>
    <ci>o</ci>
    <ci>r</ci>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="float">2</cn>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   successor((n+2^{i-1})\,\bmod\,2^{m})
  </annotation>
 </semantics>
</math>

. The first entry of finger table is actually the node's immediate successor (and therefore an extra successor field is not needed). Every time a node wants to look up a key 

<math display="inline" id="Chord_(peer-to-peer):20">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, it will pass the query to the closest successor of 

<math display="inline" id="Chord_(peer-to-peer):21">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 in its finger table (the "largest" one on the circle whose ID is smaller than 

<math display="inline" id="Chord_(peer-to-peer):22">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

), until a node finds out the key is stored in its immediate successor.</p>

<p>With such a finger table, the number of nodes that must be contacted to find a successor in an <em>N</em>-node network is 

<math display="inline" id="Chord_(peer-to-peer):23">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>N</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log N)
  </annotation>
 </semantics>
</math>


. (See proof below.)</p>
<h3 id="node-join">Node join</h3>

<p>Whenever a new node joins, three invariants should be kept (the first two ensure correctness and the last one keeps querying fast):</p>
<ol>
<li>Each node's successor points to its immediate successor correctly.</li>
<li>Each key is stored in 

<math display="inline" id="Chord_(peer-to-peer):24">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mi>u</mi>
   <mi>c</mi>
   <mi>c</mi>
   <mi>e</mi>
   <mi>s</mi>
   <mi>s</mi>
   <mi>o</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>u</ci>
    <ci>c</ci>
    <ci>c</ci>
    <ci>e</ci>
    <ci>s</ci>
    <ci>s</ci>
    <ci>o</ci>
    <ci>r</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   successor(k)
  </annotation>
 </semantics>
</math>

.</li>
<li>Each node's finger table should be correct.</li>
</ol>

<p>To satisfy these invariants, a <em>predecessor</em> field is maintained for each node. As the successor is the first entry of the finger table, we do not need to maintain this field any more. The following tasks should be done for a newly joined node 

<math display="inline" id="Chord_(peer-to-peer):25">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

:</p>
<ol>
<li>Initialize node 

<math display="inline" id="Chord_(peer-to-peer):26">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 (the predecessor and the finger table).</li>
<li>Notify other nodes to update their predecessors and finger tables.</li>
<li>The new node takes over its responsible keys from its successor.</li>
</ol>

<p>The predecessor of 

<math display="inline" id="Chord_(peer-to-peer):27">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 can be easily obtained from the predecessor of 

<math display="inline" id="Chord_(peer-to-peer):28">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mi>u</mi>
   <mi>c</mi>
   <mi>c</mi>
   <mi>e</mi>
   <mi>s</mi>
   <mi>s</mi>
   <mi>o</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>u</ci>
    <ci>c</ci>
    <ci>c</ci>
    <ci>e</ci>
    <ci>s</ci>
    <ci>s</ci>
    <ci>o</ci>
    <ci>r</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   successor(n)
  </annotation>
 </semantics>
</math>


 (in the previous circle). As for its finger table, there are various initialization methods. The simplest one is to execute find successor queries for all 

<math display="inline" id="Chord_(peer-to-peer):29">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 entries, resulting in 

<math display="inline" id="Chord_(peer-to-peer):30">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>M</mi>
     <mrow>
      <mi>log</mi>
      <mi>N</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>M</ci>
     <apply>
      <log></log>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(M\log N)
  </annotation>
 </semantics>
</math>

 initialization time. A better method is to check whether 

<math display="inline" id="Chord_(peer-to-peer):31">
 <semantics>
  <msup>
   <mi>i</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>i</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i^{th}
  </annotation>
 </semantics>
</math>

 entry in the finger table is still correct for the 

<math display="inline" id="Chord_(peer-to-peer):32">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (i+1)^{th}
  </annotation>
 </semantics>
</math>

 entry. This will lead to 

<math display="inline" id="Chord_(peer-to-peer):33">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>log</mi>
      <mn>2</mn>
     </msup>
     <mi>N</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log^{2}N)
  </annotation>
 </semantics>
</math>


. The best method is to initialize the finger table from its immediate neighbours and make some updates, which is 

<math display="inline" id="Chord_(peer-to-peer):34">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>N</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log N)
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="stabilization">Stabilization</h3>
<h3 id="failures-and-replication">Failures and replication</h3>
<h2 id="potential-uses">Potential uses</h2>
<ul>
<li>Cooperative Mirroring: A <a href="Load_balancing_(computing)" title="wikilink">load balancing</a> mechanism by a local network hosting information available to computers outside of the local network. This scheme could allow developers to balance the load between many computers instead of a central server to ensure availability of their product.</li>
</ul>
<ul>
<li>Time-shared storage: In a network, once a computer joins the network its available data is distributed throughout the network for retrieval when that computer disconnects from the network. As well as other computers' data is sent to the computer in question for offline retrieval when they are no longer connected to the network. Mainly for nodes without the ability to connect full-time to the network.</li>
</ul>
<ul>
<li>Distributed Indices: Retrieval of files over the network within a searchable database. e.g. P2P file transfer clients.</li>
</ul>
<ul>
<li>Large scale combinatorial searches: Keys being candidate solutions to a problem and each key mapping to the node, or computer, that is responsible for evaluating them as a solution or not. e.g. Code Breaking</li>
</ul>
<h2 id="proof-sketches">Proof sketches</h2>

<p> <strong>With high probability, Chord contacts 

<math display="inline" id="Chord_(peer-to-peer):35">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>N</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log N)
  </annotation>
 </semantics>
</math>

 nodes to find a successor in an 

<math display="inline" id="Chord_(peer-to-peer):36">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

-node network.</strong></p>

<p>Suppose node 

<math display="inline" id="Chord_(peer-to-peer):37">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 wishes to find the successor of key 

<math display="inline" id="Chord_(peer-to-peer):38">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>


. Let 

<math display="inline" id="Chord_(peer-to-peer):39">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 be the predecessor of 

<math display="inline" id="Chord_(peer-to-peer):40">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

. We wish to find an upper bound for the number of steps it takes for a message to be routed from 

<math display="inline" id="Chord_(peer-to-peer):41">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Chord_(peer-to-peer):42">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

. Node 

<math display="inline" id="Chord_(peer-to-peer):43">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


 will examine its finger table and route the request to the closest predecessor of 

<math display="inline" id="Chord_(peer-to-peer):44">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 that it has. Call this node 

<math display="inline" id="Chord_(peer-to-peer):45">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Chord_(peer-to-peer):46">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is the 

<math display="inline" id="Chord_(peer-to-peer):47">
 <semantics>
  <msup>
   <mi>i</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>i</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i^{th}
  </annotation>
 </semantics>
</math>

 entry 

<math display="inline" id="Chord_(peer-to-peer):48">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


's finger table, then both 

<math display="inline" id="Chord_(peer-to-peer):49">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Chord_(peer-to-peer):50">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 are at distances between 

<math display="inline" id="Chord_(peer-to-peer):51">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi>i</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <minus></minus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{i-1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Chord_(peer-to-peer):52">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>i</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{i}
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Chord_(peer-to-peer):53">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


 along the identifier circle. Hence, the distance between 

<math display="inline" id="Chord_(peer-to-peer):54">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Chord_(peer-to-peer):55">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 along this circle is at most 

<math display="inline" id="Chord_(peer-to-peer):56">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi>i</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <minus></minus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{i-1}
  </annotation>
 </semantics>
</math>

. Thus the distance from 

<math display="inline" id="Chord_(peer-to-peer):57">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Chord_(peer-to-peer):58">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>


 is less than the distance from 

<math display="inline" id="Chord_(peer-to-peer):59">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Chord_(peer-to-peer):60">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

: the new distance to 

<math display="inline" id="Chord_(peer-to-peer):61">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is at most half the initial distance.</p>

<p>This process of halving the remaining distance repeats itself, so after 

<math display="inline" id="Chord_(peer-to-peer):62">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 steps, the distance remaining to 

<math display="inline" id="Chord_(peer-to-peer):63">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>


 is at most 

<math display="inline" id="Chord_(peer-to-peer):64">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mi>m</mi>
   </msup>
   <mo>/</mo>
   <msup>
    <mn>2</mn>
    <mi>t</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>m</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{m}/2^{t}
  </annotation>
 </semantics>
</math>

; in particular, after 

<math display="inline" id="Chord_(peer-to-peer):65">
 <semantics>
  <mrow>
   <mi>log</mi>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log N
  </annotation>
 </semantics>
</math>

 steps, the remaining distance is at most 

<math display="inline" id="Chord_(peer-to-peer):66">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mi>m</mi>
   </msup>
   <mo>/</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>m</ci>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{m}/N
  </annotation>
 </semantics>
</math>

. Because nodes are distributed uniformly at random along the identifier circle, the expected number of nodes falling within an interval of this length is 1, and with high probability, there are fewer than 

<math display="inline" id="Chord_(peer-to-peer):67">
 <semantics>
  <mrow>
   <mi>log</mi>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log N
  </annotation>
 </semantics>
</math>

 such nodes. Because the message always advances by at least one node, it takes at most 

<math display="inline" id="Chord_(peer-to-peer):68">
 <semantics>
  <mrow>
   <mi>log</mi>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log N
  </annotation>
 </semantics>
</math>


 steps for a message to traverse this remaining distance. The total expected routing time is thus 

<math display="inline" id="Chord_(peer-to-peer):69">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>N</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log N)
  </annotation>
 </semantics>
</math>

.</p>

<p>If Chord keeps track of 

<math display="inline" id="Chord_(peer-to-peer):70">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>log</mi>
      <mi>N</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>r</ci>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <log></log>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=O(\log N)
  </annotation>
 </semantics>
</math>

 predecessors/successors, then with high probability, if each node has probability of 1/4 of failing, find_successor (see below) and find_predecessor (see below) will return the correct nodes</p>

<p>Simply, the probability that all 

<math display="inline" id="Chord_(peer-to-peer):71">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 nodes fail is 

<math display="inline" id="Chord_(peer-to-peer):72">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mn>1</mn>
      <mn>4</mn>
     </mfrac>
     <mo>)</mo>
    </mrow>
    <mi>r</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mn>1</mn>
      <mi>N</mi>
     </mfrac>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">4</cn>
     </apply>
     <ci>r</ci>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left({{1}\over{4}}\right)^{r}=O\left({{1}\over{N}}\right)
  </annotation>
 </semantics>
</math>

, which is a low probability; so with high probability at least one of them is alive and the node will have the correct pointer.</p>
<h2 id="pseudocode">Pseudocode</h2>

<p><strong>Definitions for pseudocode:</strong></p>
<ul>
<li>finger[k]: first node that succeeds 

<math display="inline" id="Chord_(peer-to-peer):73">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <msup>
        <mn>2</mn>
        <mrow>
         <mi>k</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mtext>mod</mtext>
     <msup>
      <mn>2</mn>
      <mi>m</mi>
     </msup>
    </mrow>
    <mo>,</mo>
    <mn>1</mn>
   </mrow>
   <mo>≤</mo>
   <mi>k</mi>
   <mo>≤</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <list>
      <apply>
       <times></times>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">2</cn>
         <apply>
          <minus></minus>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <mtext>mod</mtext>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <ci>m</ci>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </list>
     <ci>k</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n+2^{k-1})\mbox{ mod }2^{m},1\leq k\leq m
  </annotation>
 </semantics>
</math>


</li>
<li>successor: the next node from the node in question on the identifier ring</li>
<li>predecessor: the previous node from the node in question on the identifier ring</li>
</ul>

<p>The pseudocode to find the <em>successor</em> node of an id is given below:</p>

<p><code> // ask node n to find the successor of id</code><br/>
<code> n.find_successor(id)</code><br/>
<code>   //Yes, that should be a closing square bracket to match the opening parenthesis.</code><br/>
<code>   //It is a half closed interval.</code><br/>
<code>   if (id </code>

<math display="inline" id="Chord_(peer-to-peer):74">
 <semantics>
  <mo>∈</mo>
  <annotation-xml encoding="MathML-Content">
   <in></in>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \in
  </annotation>
 </semantics>
</math>

<code> (n, successor] ) </code><br/>
<code>     return successor;</code><br/>
<code>   else</code><br/>
<code>     // forward the query around the circle</code><br/>
<code>     n0 = closest_preceding_node(id);</code><br/>
<code>     return n0.find_successor(id);</code></p>

<p><code> // search the local table for the highest predecessor of id</code><br/>
<code> n.closest_preceding_node(id)</code><br/>
<code>   for i = m downto 1</code><br/>
<code>     if (finger[i]</code>

<math display="inline" id="Chord_(peer-to-peer):75">
 <semantics>
  <mo>∈</mo>
  <annotation-xml encoding="MathML-Content">
   <in></in>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \in
  </annotation>
 </semantics>
</math>

<code>(n,id))</code><br/>
<code>       return finger[i];</code><br/>
<code>   return n;</code></p>

<p>The pseudocode to stabilize the chord ring/circle after node joins and departures is as follows:</p>

<p><code> // create a new Chord ring.</code><br/>
<code> n.create()</code><br/>
<code>   predecessor = nil;</code><br/>
<code>   successor = n;</code></p>

<p><code> // join a Chord ring containing node n'.</code><br/>
<code> n.join(n')</code><br/>
<code>   predecessor = nil;</code><br/>
<code>   successor = n'.find_successor(n);</code></p>

<p><code> // called periodically. n asks the successor</code><br/>
<code> // about its predecessor, verifies if n's immediate</code><br/>
<code> // successor is consistent, and tells the successor about n</code><br/>
<code> n.stabilize()</code><br/>
<code>   x = successor.predecessor;</code><br/>
<code>   if (x</code>

<math display="inline" id="Chord_(peer-to-peer):76">
 <semantics>
  <mo>∈</mo>
  <annotation-xml encoding="MathML-Content">
   <in></in>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \in
  </annotation>
 </semantics>
</math>

<code>(n, successor))</code><br/>
<code>     successor = x;</code><br/>
<code>   successor.notify(n);</code></p>

<p><code> // n' thinks it might be our predecessor.</code><br/>
<code> n.notify(n')</code><br/>
<code>   if (predecessor is nil or n'</code>

<math display="inline" id="Chord_(peer-to-peer):77">
 <semantics>
  <mo>∈</mo>
  <annotation-xml encoding="MathML-Content">
   <in></in>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \in
  </annotation>
 </semantics>
</math>

<code>(predecessor, n))</code><br/>
<code>     predecessor = n';</code></p>

<p><code> // called periodically. refreshes finger table entries.</code><br/>
<code> // next stores the index of the finger to fix</code><br/>
<code> n.fix_fingers()</code><br/>
<code>   next = next + 1;</code><br/>
<code>   if (next &gt; m)</code><br/>
<code>     next = 1;</code><br/>
<code>   finger[next] = find_successor(n+</code>

<math display="inline" id="Chord_(peer-to-peer):78">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mrow>
     <mi>n</mi>
     <mi>e</mi>
     <mi>x</mi>
     <mi>t</mi>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>e</ci>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{next-1}
  </annotation>
 </semantics>
</math>


<code>);</code></p>

<p><code> // called periodically. checks whether predecessor has failed.</code><br/>
<code> n.check_predecessor()</code><br/>
<code>   if (predecessor has failed)</code><br/>
<code>     predecessor = nil;</code></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Kademlia" title="wikilink">Kademlia</a></li>
<li><a class="uri" href="Koorde" title="wikilink">Koorde</a></li>
<li><a class="uri" href="OverSim" title="wikilink">OverSim</a> - the overlay simulation framework</li>
<li><a class="uri" href="SimGrid" title="wikilink">SimGrid</a> - a toolkit for the simulation of distributed applications -</li>
</ul>
<h2 id="references">References</h2>

<p>Stoica, I.; Morris, R.; Liben-Nowell, D.; Karger, D.; Kaashoek, M. F.; Dabek, F.; and Balakrishnan, H.. "Chord: A scalable peer-to-peer lookup service for internet applications" IEEE Transactions on Networking 11, February 2003. <a class="uri" href="http://pdos.csail.mit.edu/papers/ton:chord/paper-ton.pdf">http://pdos.csail.mit.edu/papers/ton:chord/paper-ton.pdf</a></p>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.pdos.lcs.mit.edu/chord">The Chord Project</a></li>
<li><a href="http://open-chord.sourceforge.net/">Open Chord - An Open Source Java Implementation</a></li>
<li><a href="http://chordless.wiki.sourceforge.net/">Chordless - Another Open Source Java Implementation</a></li>
<li><a href="http://sourceforge.net/projects/jdhtuq//">jDHTUQ- An open source java implementation. API to generalize the implementation of peer-to-peer DHT systems. Contains GUI in mode data structure</a></li>
</ul>

<p>"</p>

<p><a href="Category:Articles_with_example_pseudocode" title="wikilink">Category:Articles with example pseudocode</a> <a href="Category:Distributed_data_storage" title="wikilink">Category:Distributed data storage</a> <a href="Category:Software_using_the_MIT_license" title="wikilink">Category:Software using the MIT license</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
