<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title offset="1833">RE (complexity)</title>
   <script type="text/javascript"
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js">
    </script>
</head>
<body>
<h1>RE (complexity)</h1>
<hr>In [[computability theory]] and [[computational complexity theory]], '''RE''' ([[Recursively enumerable set|recursively enumerable]]) is the [[complexity class|class]] of [[decision problem]]s for which a 'yes' answer can be verified by a [[Turing machine]] in a finite amount of time.<ref>{{CZoo|Class RE|R#re}}</ref> Informally, it means that if the answer to a problem instance is 'yes<p>', then there is some procedure which takes finite time to determine this, and this procedure never falsely reports 'yes' when the true answer is 'no'. However, when the true answer is 'no', the procedure is not required to halt; it may go into an "<a href="infinite_loop" title="wikilink">infinite loop</a>" for some 'no' cases. Such a procedure is sometimes called a <strong>semi-algorithm</strong>, to distinguish it from an <a class="uri" href="algorithm" title="wikilink">algorithm</a>, defined as a complete solution to a decision problem.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<p>Equivalently, <strong>RE</strong> is the class of decision problems for which a Turing machine can list all the 'yes' instances, one by one (this is what 'enumerable' means). Each member of <strong>RE</strong> is a <a href="recursively_enumerable_set" title="wikilink">recursively enumerable set</a> and therefore a <a href="Diophantine_set" title="wikilink">Diophantine set</a>.</p>
<p>Similarly, <strong>co-RE</strong> is the set of all languages that are complements of a language in <strong>RE</strong>. In a sense, <strong>co-RE</strong> contains languages of which membership can be disproved in a finite amount of time, but proving membership might take forever.</p>
<h2 id="relations-to-other-classes">Relations to other classes</h2>
<p>The set of <a href="recursive_language" title="wikilink">recursive languages</a> (<strong><a href="R_(complexity)" title="wikilink">R</a></strong>) is a subset of both <strong>RE</strong> and <strong>co-RE</strong>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> In fact, it is the intersection of those two classes, because we can decide any problem for which there exists a recogniser and also a co-recogniser by simply interleaving them until one obtains a result. Therefore:</p>
<p><span class="LaTeX">$$\mbox{R} = \mbox{RE}\cap\mbox{co-RE}.$$</span></p>
<h2 id="re-complete">RE-complete</h2>
<p><strong>RE-complete</strong> is the set of decision problems that are complete for <strong>RE</strong>. In a sense, these are the "hardest" recursively enumerable problems. All such problems are non<a href="recursive_language" title="wikilink">recursive</a>. Generally, no constraint is placed on the reductions used except that they must be <a href="many-one_reduction" title="wikilink">many-one reductions</a>.</p>
<p>Examples of RE-complete problems:</p>
<ol>
<li><a href="Halting_problem" title="wikilink">Halting problem</a>: Whether a program given a finite input finishes running or will run forever.</li>
<li>By <a href="Rice's_Theorem" title="wikilink">Rice's Theorem</a>, deciding membership in any nontrivial subset of the set of <a href="Computable_function" title="wikilink">recursive functions</a> is <strong>RE</strong>-hard. It will be complete whenever the set is recursively enumerable.</li>
<li>
<p><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> has proven that all <a href="creative_set" title="wikilink">creative sets</a> are <strong>RE</strong>-complete.</p></li>
<li>The uniform <a href="word_problem_(mathematics)" title="wikilink">word problem</a> for <a href="group_(mathematics)" title="wikilink">groups</a> or <a href="semigroup" title="wikilink">semigroups</a>. [Indeed, the <a href="word_problem_for_groups" title="wikilink">word problem for some individual groups</a> is <strong>RE</strong>-complete.]</li>
<li>Deciding membership in a general <a href="unrestricted_grammar" title="wikilink">unrestricted</a> <a href="formal_grammar" title="wikilink">formal grammar</a>. [Again, certain individual grammars have <strong>RE</strong>-complete membership problem.]</li>
<li>The <a class="uri" href="validity" title="wikilink">validity</a> problem for <a href="first-order_logic" title="wikilink">first-order logic</a>.</li>
<li><a href="Post_correspondence_problem" title="wikilink">Post correspondence problem</a>: Given a finite set of strings, determine if there is a string that can be factored into a composition of the strings (allowing repeats) in two different ways.</li>
<li>Determining if a <a href="Diophantine_equation" title="wikilink">Diophantine equation</a> has any integer solutions.</li>
</ol>
<h2 id="co-re-complete">co-RE-complete</h2>
<p><strong>co-RE-complete</strong> is the set of decision problems that are complete for <strong>co-RE</strong>. In a sense, these are the complements of the hardest recursively enumerable problems.</p>
<p>Examples of co-RE-complete problems:</p>
<ol>
<li>The <a href="Domino_Problem" title="wikilink">Domino Problem</a> for <a href="Wang_tile" title="wikilink">Wang tiles</a>.</li>
<li>The <a class="uri" href="satisfiability" title="wikilink">satisfiability</a> problem for <a href="first-order_logic" title="wikilink">first-order logic</a></li>
</ol>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="List_of_undecidable_problems" title="wikilink">List of undecidable problems</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<p>"</p>
<p><a href="Category:Complexity_classes" title="wikilink">Category:Complexity classes</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">.<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
