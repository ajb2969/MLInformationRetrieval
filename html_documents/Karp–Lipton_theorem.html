<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1378">Karp–Lipton theorem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Karp–Lipton theorem</h1>
<hr/>

<p>In <a href="computational_complexity_theory" title="wikilink">complexity theory</a>, the <strong>Karp–Lipton theorem</strong> states that if the <a href="boolean_satisfiability_problem" title="wikilink">boolean satisfiability problem</a> (SAT) can be solved by <a href="Boolean_circuit" title="wikilink">Boolean circuits</a> with a <a class="uri" href="polynomial" title="wikilink">polynomial</a> number of logic gates, then</p>

<p>

<math display="block" id="Karp–Lipton_theorem:0">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Π</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mn>2</mn>
    </msub>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Π</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi_{2}=\Sigma_{2}\,
  </annotation>
 </semantics>
</math>

 and therefore 

<math display="inline" id="Karp–Lipton_theorem:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>PH</mi>
    <mo>=</mo>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>PH</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{PH}=\Sigma_{2}.\,
  </annotation>
 </semantics>
</math>

</p>

<p>That is, if we assume that <a href="NP_(complexity)" title="wikilink">NP</a>, the class of nondeterministic polynomial time problems, can be contained in the non-uniform polynomial time complexity class <a class="uri" href="P/poly" title="wikilink">P/poly</a>, then this assumption implies the collapse of the <a href="polynomial_hierarchy" title="wikilink">polynomial hierarchy</a> at its second level. Such a collapse is believed unlikely, so the theorem is generally viewed by complexity theorists as evidence for the nonexistence of polynomial size circuits for SAT or for other <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> problems. A proof that such circuits do not exist would imply that <a href="P_=_NP_problem" title="wikilink">P ≠ NP</a>. As P/poly contains all problems solvable in randomized polynomial time (<a href="P/poly#Adleman's_theorem" title="wikilink">Adleman's theorem</a>), the Karp–Lipton theorem is also evidence that the use of randomization does not lead to polynomial time algorithms for NP-complete problems.</p>

<p>The Karp–Lipton theorem is named after <a href="Richard_M._Karp" title="wikilink">Richard M. Karp</a> and <a href="Richard_J._Lipton" title="wikilink">Richard J. Lipton</a>, who first proved it in 1980. (Their original proof collapsed PH to 

<math display="inline" id="Karp–Lipton_theorem:2">
 <semantics>
  <msub>
   <mi mathvariant="normal">Σ</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Σ</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{3}
  </annotation>
 </semantics>
</math>

, but <a href="Michael_Sipser" title="wikilink">Michael Sipser</a> improved it to 

<math display="inline" id="Karp–Lipton_theorem:3">
 <semantics>
  <msub>
   <mi mathvariant="normal">Σ</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Σ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{2}
  </annotation>
 </semantics>
</math>

.)</p>

<p>Variants of the theorem state that, under the same assumption, <strong><a href="MA_(complexity)" title="wikilink">MA</a></strong> = <strong><a href="AM_(complexity)" title="wikilink">AM</a></strong>, and <strong>PH</strong> collapses to <strong><a href="S2P_(complexity)" title="wikilink"></a></strong> complexity class. There are stronger conclusions possible if <a class="uri" href="PSPACE" title="wikilink">PSPACE</a>, or some other complexity classes are assumed to have polynomial-sized circuits; see <a class="uri" href="P/poly" title="wikilink">P/poly</a>. If NP is assumed to be a subset of BPP (which is a subset of P/poly), then the polynomial hierarchy collapses to <a href="BPP_(complexity)" title="wikilink">BPP</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> If coNP is assumed to be subset of NP/poly, then the polynomial hierarchy collapses to its third level.</p>
<h2 id="intuition">Intuition</h2>

<p>Suppose that polynomial sized circuits for SAT not only exist, but also that they could be constructed by a polynomial time algorithm. Then this supposition implies that SAT itself could be solved by a polynomial time algorithm that constructs the circuit and then applies it. That is, efficiently constructible circuits for SAT would lead to a stronger collapse, P = NP.</p>

<p>The assumption of the Karp–Lipton theorem, that these circuits exist, is weaker. But it is still possible for an algorithm in the complexity class 

<math display="inline" id="Karp–Lipton_theorem:4">
 <semantics>
  <msub>
   <mi mathvariant="normal">Σ</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Σ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{2}
  </annotation>
 </semantics>
</math>

 to <em>guess</em> a correct circuit for SAT. The complexity class 

<math display="inline" id="Karp–Lipton_theorem:5">
 <semantics>
  <msub>
   <mi mathvariant="normal">Σ</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Σ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{2}
  </annotation>
 </semantics>
</math>

 describes problems of the form</p>

<p>

<math display="block" id="Karp–Lipton_theorem:6">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <mpadded width="+2.8pt">
       <mi>y</mi>
      </mpadded>
      <mi>ψ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <apply>
     <times></times>
     <ci>x</ci>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <ci>y</ci>
       <ci>ψ</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists x\forall y\;\psi(x,y)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Karp–Lipton_theorem:7">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

 is any polynomial-time computable predicate. The existential power of the first quantifier in this predicate can be used to guess a correct circuit for SAT, and the universal power of the second quantifier can be used to verify that the circuit is correct. Once this circuit is guessed and verified, the algorithm in class 

<math display="inline" id="Karp–Lipton_theorem:8">
 <semantics>
  <msub>
   <mi mathvariant="normal">Σ</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Σ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{2}
  </annotation>
 </semantics>
</math>

 can use it as a subroutine for solving other problems.</p>
<h2 id="self-reducibility">Self-reducibility</h2>

<p>To understand the Karp–Lipton proof in more detail, we consider the problem of testing whether a circuit <em>c</em> is a correct circuit for solving SAT instances of a given size, and show that this circuit testing problem belongs to 

<math display="inline" id="Karp–Lipton_theorem:9">
 <semantics>
  <msub>
   <mi mathvariant="normal">Π</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Π</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi_{1}
  </annotation>
 </semantics>
</math>

. That is, there exists a polynomial time computable predicate <em>V</em> such that <em>c</em> is a correct circuit if and only if, for all polynomially-bounded <em>z</em>, <em>V</em>(<em>c</em>,<em>z</em>) is true.</p>

<p>The circuit <em>c</em> is a correct circuit for SAT if it satisfies two properties:</p>
<ul>
<li>For every pair (<em>s</em>,<em>x</em>) where <em>s</em> is an instance of SAT and <em>x</em> is a solution to the instance, <em>c</em>(<em>s</em>) must be true</li>
<li>For every instance <em>s</em> of SAT for which <em>c</em>(<em>s</em>) is true, <em>s</em> must be solvable.</li>
</ul>

<p>The first of these two properties is already in the form of problems in class 

<math display="inline" id="Karp–Lipton_theorem:10">
 <semantics>
  <msub>
   <mi mathvariant="normal">Π</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Π</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi_{1}
  </annotation>
 </semantics>
</math>

. To verify the second property, we use the <em>self-reducibility</em> property of SAT.</p>

<p>Self-reducibility describes the phenomenon that, if we can quickly test whether a SAT instance is solvable, we can almost as quickly find an explicit solution to the instance. To find a solution to an instance <em>s</em>, choose one of the Boolean variables <em>x</em> that is input to <em>s</em>, and make two smaller instances <em>s</em><sub>0</sub> and <em>s</em><sub>1</sub> where <em>s</em><sub><em>i</em></sub> denotes the formula formed by replacing <em>x</em> with the constant <em>i</em>. Once these two smaller instances have been constructed, apply the test for solvability to each of them. If one of these two tests returns that the smaller instance is satisfiable, continue solving that instance until a complete solution has been derived.</p>

<p>To use self-reducibility to check the second property of a correct circuit for SAT, we rewrite it as follows:</p>
<ul>
<li>For every instance <em>s</em> of SAT for which <em>c</em>(<em>s</em>) is true, the self-reduction procedure described above finds a valid solution to <em>s</em>.</li>
</ul>

<p>Thus, we can test in 

<math display="inline" id="Karp–Lipton_theorem:11">
 <semantics>
  <msub>
   <mi mathvariant="normal">Π</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Π</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi_{1}
  </annotation>
 </semantics>
</math>

 whether <em>c</em> is a valid circuit for solving SAT.</p>

<p>see <a href="Random_self-reducibility" title="wikilink">Random self-reducibility</a> for more information</p>
<h2 id="proof-of-karplipton-theorem">Proof of Karp–Lipton theorem</h2>

<p>The Karp–Lipton theorem can be restated as a result about Boolean formulas with polynomially-bounded quantifiers. Problems in 

<math display="inline" id="Karp–Lipton_theorem:12">
 <semantics>
  <msub>
   <mi mathvariant="normal">Π</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Π</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi_{2}
  </annotation>
 </semantics>
</math>

 are described by formulas of this type, with the syntax</p>

<p>

<math display="block" id="Karp–Lipton_theorem:13">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>=</mo>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <mpadded width="+2.8pt">
        <mi>y</mi>
       </mpadded>
       <mi>ψ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ϕ</ci>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <exists></exists>
       <apply>
        <times></times>
        <ci>y</ci>
        <ci>ψ</ci>
        <interval closure="open">
         <ci>x</ci>
         <ci>y</ci>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi=\forall x\exists y\;\psi(x,y)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Karp–Lipton_theorem:14">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

 is a polynomial-time computable predicate. The Karp–Lipton theorem states that this type of formula can be transformed in polynomial time into an equivalent formula in which the quantifiers appear in the opposite order; such a formula belongs to 

<math display="inline" id="Karp–Lipton_theorem:15">
 <semantics>
  <msub>
   <mi mathvariant="normal">Σ</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Σ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{2}
  </annotation>
 </semantics>
</math>

. Note that the subformula</p>

<p>

<math display="block" id="Karp–Lipton_theorem:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mpadded width="+2.8pt">
      <mi>y</mi>
     </mpadded>
     <mi>ψ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>ψ</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s(x)=\exists y\;\psi(x,y)
  </annotation>
 </semantics>
</math>

 is an instance of SAT. That is, if <em>c</em> is a valid circuit for SAT, then this subformula is equivalent to the unquantified formula <em>c</em>(<em>s</em>(<em>x</em>)). Therefore, the full formula for 

<math display="inline" id="Karp–Lipton_theorem:17">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 is equivalent (under the assumption that a valid circuit <em>c</em> exists) to the formula</p>

<p>

<math display="block" id="Karp–Lipton_theorem:18">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mi>c</mi>
     <mrow>
      <mo>∀</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>z</mi>
        <mo rspace="5.3pt" stretchy="false">)</mo>
       </mrow>
       <mi>V</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>c</mi>
        <mo>,</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>s</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>c</ci>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <times></times>
        <interval closure="open">
         <ci>x</ci>
         <ci>z</ci>
        </interval>
        <ci>V</ci>
        <interval closure="open">
         <ci>c</ci>
         <ci>z</ci>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists c\forall(x,z)\;V(c,z)\wedge c(s(x))\,
  </annotation>
 </semantics>
</math>

 where <em>V</em> is the formula used to verify that <em>c</em> really is a valid circuit using self-reducibility, as described above. This equivalent formula has its quantifiers in the opposite order, as desired. Therefore, the Karp–Lipton assumption allows us to transpose the order of existential and universal quantifiers in formulas of this type, showing that 

<math display="inline" id="Karp–Lipton_theorem:19">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mn>2</mn>
    </msub>
    <mo>=</mo>
    <msub>
     <mi mathvariant="normal">Π</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Π</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{2}=\Pi_{2}.
  </annotation>
 </semantics>
</math>

 Repeating the transposition allows formulas with deeper nesting to be simplified to a form in which they have a single existential quantifier followed by a single universal quantifier, showing that 

<math display="inline" id="Karp–Lipton_theorem:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mi>H</mi>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>H</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   PH=\Sigma_{2}.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="another-proof-and-s2p">Another proof and S<sub>2</sub><sup>P</sup></h2>

<p>Assume 

<math display="inline" id="Karp–Lipton_theorem:21">
 <semantics>
  <mrow>
   <mi>𝖭𝖯</mi>
   <mo>⊆</mo>
   <mrow>
    <mi>𝖯</mi>
    <mo>/</mo>
    <mi>𝗉𝗈𝗅𝗒</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>𝖭𝖯</ci>
    <apply>
     <divide></divide>
     <ci>𝖯</ci>
     <ci>𝗉𝗈𝗅𝗒</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathsf{NP}\subseteq\mathsf{P/poly}
  </annotation>
 </semantics>
</math>

. Thefore, there exists a family of circuits 

<math display="inline" id="Karp–Lipton_theorem:22">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{n}
  </annotation>
 </semantics>
</math>

 that solves satisfability on input of length <em>n</em>. Using self-reducibility, there exists a family of circuits 

<math display="inline" id="Karp–Lipton_theorem:23">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{n}
  </annotation>
 </semantics>
</math>

 which outputs a satisfying assignment on true instances.</p>

<p>Suppose <em>L</em> is a 

<math display="inline" id="Karp–Lipton_theorem:24">
 <semantics>
  <msub>
   <mi mathvariant="normal">Π</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Π</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi_{2}
  </annotation>
 </semantics>
</math>

 set</p>

<p>

<math display="block" id="Karp–Lipton_theorem:25">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>z</mi>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mo>∀</mo>
      <mi>x</mi>
     </mrow>
     <mo>.</mo>
     <mrow>
      <mo>∃</mo>
      <mi>y</mi>
     </mrow>
     <mo>.</mo>
     <mrow>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo>,</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="4.2pt" stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>z</ci>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>x</ci>
      </apply>
      <apply>
       <exists></exists>
       <ci>y</ci>
      </apply>
      <apply>
       <times></times>
       <ci>ϕ</ci>
       <vector>
        <ci>x</ci>
        <ci>y</ci>
        <ci>z</ci>
       </vector>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=\{z:\forall x.\exists y.\phi(x,y,z)\}\,
  </annotation>
 </semantics>
</math>

</p>

<p>Since 

<math display="inline" id="Karp–Lipton_theorem:26">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mi>y</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <exists></exists>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>z</ci>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists y.\phi(x,y,z)
  </annotation>
 </semantics>
</math>

 can be considered an instance of SAT (by <a href="Cook-Levin_theorem" title="wikilink">Cook-Levin theorem</a>), there exists a circuit 

<math display="inline" id="Karp–Lipton_theorem:27">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{n}
  </annotation>
 </semantics>
</math>

, depending on 

<math display="inline" id="Karp–Lipton_theorem:28">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>z</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <abs></abs>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=|z|
  </annotation>
 </semantics>
</math>

, such that the formula defining <em>L</em> is equivalent to</p>

<p><mtpl></mtpl></p>

<p>Furthermore, the circuit can be guessed with existential quantification:</p>

<p><mtpl></mtpl></p>

<p>Obviously () implies (). If (1) is false, then 

<math display="inline" id="Karp–Lipton_theorem:29">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo>∃</mo>
     <mi>y</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <not></not>
     <apply>
      <exists></exists>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>z</ci>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\exists y.\phi(x,y,z)
  </annotation>
 </semantics>
</math>

. In this case, no circuit <em>D</em> can output an assignment making 

<math display="inline" id="Karp–Lipton_theorem:30">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mrow>
     <mi>D</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi>z</mi>
    <mo rspace="5.3pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <vector>
     <ci>x</ci>
     <apply>
      <times></times>
      <ci>D</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>z</ci>
      </interval>
     </apply>
     <ci>z</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(x,D(x,z),z)\;
  </annotation>
 </semantics>
</math>

 true.</p>

<p>The proof has shown that a 

<math display="inline" id="Karp–Lipton_theorem:31">
 <semantics>
  <msub>
   <mi mathvariant="normal">Π</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Π</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi_{2}
  </annotation>
 </semantics>
</math>

 set 

<math display="inline" id="Karp–Lipton_theorem:32">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is in 

<math display="inline" id="Karp–Lipton_theorem:33">
 <semantics>
  <msub>
   <mi mathvariant="normal">Σ</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Σ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{2}
  </annotation>
 </semantics>
</math>

.</p>

<p>What more, if the 

<math display="inline" id="Karp–Lipton_theorem:34">
 <semantics>
  <msub>
   <mi mathvariant="normal">Π</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Π</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi_{2}
  </annotation>
 </semantics>
</math>

 formula is true, then the circuit <em>D</em> will work against any <em>x</em>. If the 

<math display="inline" id="Karp–Lipton_theorem:35">
 <semantics>
  <msub>
   <mi mathvariant="normal">Π</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Π</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi_{2}
  </annotation>
 </semantics>
</math>

 formula is false, then <em>x</em> making the formula (1) false will work against any circuit. This property means a stronger collapse, namely to <strong><a href="S2P_(complexity)" title="wikilink">S</a></strong> complexity class (i.e. 

<math display="inline" id="Karp–Lipton_theorem:36">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Π</mi>
    <mn>2</mn>
   </msub>
   <mo>⊆</mo>
   <msubsup>
    <mi>𝖲</mi>
    <mn>2</mn>
    <mi>P</mi>
   </msubsup>
   <mo>⊆</mo>
   <msub>
    <mi mathvariant="normal">Σ</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <subset></subset>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Π</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝖲</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>P</ci>
     </apply>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi_{2}\subseteq\mathsf{S}_{2}^{P}\subseteq\Sigma_{2}
  </annotation>
 </semantics>
</math>

). It was observed by Sengupta.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>=== AM = MA === A modification<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> of the above proof yields</p>

<p>

<math display="block" id="Karp–Lipton_theorem:37">
 <semantics>
  <mrow>
   <mi>𝖭𝖯</mi>
   <mo>⊆</mo>
   <mrow>
    <mi>𝖯</mi>
    <mo>/</mo>
    <mi>𝗉𝗈𝗅𝗒</mi>
   </mrow>
   <mo>⟹</mo>
   <mi>𝖠𝖬</mi>
   <mo>=</mo>
   <mi>𝖬𝖠</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <subset></subset>
     <ci>𝖭𝖯</ci>
     <apply>
      <divide></divide>
      <ci>𝖯</ci>
      <ci>𝗉𝗈𝗅𝗒</ci>
     </apply>
    </apply>
    <apply>
     <implies></implies>
     <share href="#.cmml">
     </share>
     <ci>𝖠𝖬</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>𝖬𝖠</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathsf{NP}\subseteq\mathsf{P/poly}\implies\mathsf{AM}=\mathsf{MA}
  </annotation>
 </semantics>
</math>

</p>

<p>(see <a href="Arthur–Merlin_protocol" title="wikilink">Arthur–Merlin protocol</a>).</p>

<p>Suppose that <em>L</em> is in <strong>AM</strong>, i.e.:</p>

<p>

<math display="block" id="Karp–Lipton_theorem:38">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>∈</mo>
   <mi>L</mi>
   <mo>⟹</mo>
   <msub>
    <mi>Pr</mi>
    <mi>x</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mo>∃</mo>
    <mi>y</mi>
    <mo>.</mo>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≥</mo>
   <mstyle displaystyle="false">
    <mfrac>
     <mn>2</mn>
     <mn>3</mn>
    </mfrac>
   </mstyle>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">z</csymbol>
    <in></in>
    <csymbol cd="unknown">L</csymbol>
    <implies></implies>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Pr</ci>
     <ci>x</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <exists></exists>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">z</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <geq></geq>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z\in L\implies\Pr\nolimits_{x}[\exists y.\phi(x,y,z)]\geq\tfrac{2}{3}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Karp–Lipton_theorem:39">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>∉</mo>
   <mi>L</mi>
   <mo>⟹</mo>
   <msub>
    <mi>Pr</mi>
    <mi>x</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mo>∃</mo>
    <mi>y</mi>
    <mo>.</mo>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≤</mo>
   <mstyle displaystyle="false">
    <mfrac>
     <mn>1</mn>
     <mn>3</mn>
    </mfrac>
   </mstyle>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">z</csymbol>
    <notin></notin>
    <csymbol cd="unknown">L</csymbol>
    <implies></implies>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Pr</ci>
     <ci>x</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <exists></exists>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">z</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <leq></leq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">3</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z\notin L\implies\Pr\nolimits_{x}[\exists y.\phi(x,y,z)]\leq\tfrac{1}{3}
  </annotation>
 </semantics>
</math>

</p>

<p>and as previously rewrite 

<math display="inline" id="Karp–Lipton_theorem:40">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mi>y</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <exists></exists>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>z</ci>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists y.\phi(x,y,z)
  </annotation>
 </semantics>
</math>

 using the circuit 

<math display="inline" id="Karp–Lipton_theorem:41">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{n}
  </annotation>
 </semantics>
</math>

 that outputs a satisfying assignment if it exists:</p>

<p>

<math display="block" id="Karp–Lipton_theorem:42">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>∈</mo>
   <mi>L</mi>
   <mo>⟹</mo>
   <mrow>
    <msub>
     <mi>Pr</mi>
     <mi>x</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mrow>
        <msub>
         <mi>D</mi>
         <mi>n</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>z</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mstyle displaystyle="false">
    <mfrac>
     <mn>2</mn>
     <mn>3</mn>
    </mfrac>
   </mstyle>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <ci>z</ci>
     <ci>L</ci>
    </apply>
    <apply>
     <implies></implies>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Pr</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>ϕ</ci>
       <vector>
        <ci>x</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>D</ci>
          <ci>n</ci>
         </apply>
         <interval closure="open">
          <ci>x</ci>
          <ci>z</ci>
         </interval>
        </apply>
        <ci>z</ci>
       </vector>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z\in L\implies\Pr\nolimits_{x}[\phi(x,D_{n}(x,z),z)]\geq\tfrac{2}{3}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Karp–Lipton_theorem:43">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>∉</mo>
   <mi>L</mi>
   <mo>⟹</mo>
   <mrow>
    <msub>
     <mi>Pr</mi>
     <mi>x</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>ϕ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mrow>
        <msub>
         <mi>D</mi>
         <mi>n</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo>,</mo>
         <mi>z</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mstyle displaystyle="false">
    <mfrac>
     <mn>1</mn>
     <mn>3</mn>
    </mfrac>
   </mstyle>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <notin></notin>
     <ci>z</ci>
     <ci>L</ci>
    </apply>
    <apply>
     <implies></implies>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Pr</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>ϕ</ci>
       <vector>
        <ci>x</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>D</ci>
          <ci>n</ci>
         </apply>
         <interval closure="open">
          <ci>x</ci>
          <ci>z</ci>
         </interval>
        </apply>
        <ci>z</ci>
       </vector>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z\notin L\implies\Pr\nolimits_{x}[\phi(x,D_{n}(x,z),z)]\leq\tfrac{1}{3}
  </annotation>
 </semantics>
</math>

</p>

<p>Since 

<math display="inline" id="Karp–Lipton_theorem:44">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{n}
  </annotation>
 </semantics>
</math>

 can be guessed:</p>

<p>

<math display="block" id="Karp–Lipton_theorem:45">
 <semantics>
  <mrow>
   <mrow>
    <mi>z</mi>
    <mo>∈</mo>
    <mi>L</mi>
    <mo>⟹</mo>
    <mrow>
     <mo>∃</mo>
     <mi>D</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>Pr</mi>
      <mi>x</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>ϕ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mrow>
         <mi>D</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo>,</mo>
          <mi>z</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>,</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mstyle displaystyle="false">
     <mfrac>
      <mn>2</mn>
      <mn>3</mn>
     </mfrac>
    </mstyle>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <in></in>
      <ci>z</ci>
      <ci>L</ci>
     </apply>
     <apply>
      <implies></implies>
      <share href="#.cmml">
      </share>
      <apply>
       <exists></exists>
       <ci>D</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Pr</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>ϕ</ci>
       <vector>
        <ci>x</ci>
        <apply>
         <times></times>
         <ci>D</ci>
         <interval closure="open">
          <ci>x</ci>
          <ci>z</ci>
         </interval>
        </apply>
        <ci>z</ci>
       </vector>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z\in L\implies\exists D.\Pr\nolimits_{x}[\phi(x,D(x,z),z)]\geq\tfrac{2}{3}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Karp–Lipton_theorem:46">
 <semantics>
  <mrow>
   <mrow>
    <mi>z</mi>
    <mo>∉</mo>
    <mi>L</mi>
    <mo>⟹</mo>
    <mrow>
     <mo>∀</mo>
     <mi>D</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>Pr</mi>
      <mi>x</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>ϕ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mrow>
         <mi>D</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo>,</mo>
          <mi>z</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>,</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mstyle displaystyle="false">
     <mfrac>
      <mn>1</mn>
      <mn>3</mn>
     </mfrac>
    </mstyle>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <notin></notin>
      <ci>z</ci>
      <ci>L</ci>
     </apply>
     <apply>
      <implies></implies>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>D</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Pr</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>ϕ</ci>
       <vector>
        <ci>x</ci>
        <apply>
         <times></times>
         <ci>D</ci>
         <interval closure="open">
          <ci>x</ci>
          <ci>z</ci>
         </interval>
        </apply>
        <ci>z</ci>
       </vector>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z\notin L\implies\forall D.\Pr\nolimits_{x}[\phi(x,D(x,z),z)]\leq\tfrac{1}{3}
  </annotation>
 </semantics>
</math>

</p>

<p>which proves 

<math display="inline" id="Karp–Lipton_theorem:47">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is in the smaller class <strong>MA</strong>.</p>
<h2 id="application-to-circuit-lower-bounds-kannans-theorem">Application to circuit lower bounds – Kannan's theorem</h2>

<p>Kannan's theorem<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> states that for any fixed <em>k</em> there exists a language 

<math display="inline" id="Karp–Lipton_theorem:48">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Karp–Lipton_theorem:49">
 <semantics>
  <msub>
   <mi mathvariant="normal">Σ</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Σ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{2}
  </annotation>
 </semantics>
</math>

, which is not in <strong>SIZE</strong>(n<sup>k</sup>) (This is a different statement than 

<math display="inline" id="Karp–Lipton_theorem:50">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Σ</mi>
    <mn>2</mn>
   </msub>
   <mo>⊈</mo>
   <mrow>
    <mi>𝖯</mi>
    <mo>/</mo>
    <mi>𝗉𝗈𝗅𝗒</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">not-subset-of-or-equals</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <divide></divide>
     <ci>𝖯</ci>
     <ci>𝗉𝗈𝗅𝗒</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{2}\not\subseteq\mathsf{P/poly}
  </annotation>
 </semantics>
</math>

, which is currently open and states that there exists a single language that is not in <strong>SIZE</strong>(n<sup>k</sup>) for any <em>k</em>). It is a simple <a href="circuit_lower_bounds" title="wikilink">circuit lower bound</a>.</p>

<p>Proof outline:</p>

<p>There exists a language 

<math display="inline" id="Karp–Lipton_theorem:51">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>∈</mo>
   <mrow>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mn>4</mn>
    </msub>
    <mo>-</mo>
    <mrow>
     <mi>𝖲𝖨𝖹𝖤</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>n</mi>
       <mi>k</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>L</ci>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <cn type="integer">4</cn>
     </apply>
     <apply>
      <times></times>
      <ci>𝖲𝖨𝖹𝖤</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\in\Sigma_{4}-\mathsf{SIZE}(n^{k})
  </annotation>
 </semantics>
</math>

 (the proof uses <a href="Cantor's_diagonal_argument" title="wikilink">diagonalization</a> technique). Consider two cases:</p>
<ul>
<li>If 

<math display="inline" id="Karp–Lipton_theorem:52">
 <semantics>
  <mrow>
   <mi>𝖲𝖠𝖳</mi>
   <mo>∉</mo>
   <mrow>
    <mi>𝖯</mi>
    <mo>/</mo>
    <mi>𝗉𝗈𝗅𝗒</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>𝖲𝖠𝖳</ci>
    <apply>
     <divide></divide>
     <ci>𝖯</ci>
     <ci>𝗉𝗈𝗅𝗒</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathsf{SAT}\notin\mathsf{P/poly}
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Karp–Lipton_theorem:53">
 <semantics>
  <mrow>
   <mi>𝖲𝖠𝖳</mi>
   <mo>∉</mo>
   <mrow>
    <mi>𝖲𝖨𝖹𝖤</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>n</mi>
      <mi>k</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <notin></notin>
    <ci>𝖲𝖠𝖳</ci>
    <apply>
     <times></times>
     <ci>𝖲𝖨𝖹𝖤</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathsf{SAT}\notin\mathsf{SIZE}(n^{k})
  </annotation>
 </semantics>
</math>

 and theorem is proved.</li>
<li>If 

<math display="inline" id="Karp–Lipton_theorem:54">
 <semantics>
  <mrow>
   <mi>𝖲𝖠𝖳</mi>
   <mo>∈</mo>
   <mrow>
    <mi>𝖯</mi>
    <mo>/</mo>
    <mi>𝗉𝗈𝗅𝗒</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>𝖲𝖠𝖳</ci>
    <apply>
     <divide></divide>
     <ci>𝖯</ci>
     <ci>𝗉𝗈𝗅𝗒</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathsf{SAT}\in\mathsf{P/poly}
  </annotation>
 </semantics>
</math>

, then by Karp–Lipton theorem, 

<math display="inline" id="Karp–Lipton_theorem:55">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Σ</mi>
    <mn>4</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi mathvariant="normal">Σ</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">4</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{4}=\Sigma_{2}
  </annotation>
 </semantics>
</math>

 and therefore 

<math display="inline" id="Karp–Lipton_theorem:56">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>∈</mo>
   <mrow>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mn>2</mn>
    </msub>
    <mo>-</mo>
    <mrow>
     <mi>𝖲𝖨𝖹𝖤</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>n</mi>
       <mi>k</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>L</ci>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <ci>𝖲𝖨𝖹𝖤</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\in\Sigma_{2}-\mathsf{SIZE}(n^{k})
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>A stronger version of Karp–Lipton theorem strengthens Kannan's theorem to: for any <em>k</em>, there exists a language 

<math display="inline" id="Karp–Lipton_theorem:57">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>∈</mo>
   <mrow>
    <msubsup>
     <mi>𝖲</mi>
     <mn>2</mn>
     <mi>P</mi>
    </msubsup>
    <mo>-</mo>
    <mrow>
     <mi>𝖲𝖨𝖹𝖤</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>n</mi>
       <mi>k</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>L</ci>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝖲</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>P</ci>
     </apply>
     <apply>
      <times></times>
      <ci>𝖲𝖨𝖹𝖤</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\in\mathsf{S}_{2}^{P}-\mathsf{SIZE}(n^{k})
  </annotation>
 </semantics>
</math>

.</p>

<p>It is also known that <strong><a href="PP_(complexity)" title="wikilink">PP</a></strong> is not contained in 

<math display="inline" id="Karp–Lipton_theorem:58">
 <semantics>
  <mrow>
   <mi>𝖲𝖨𝖹𝖤</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mi>k</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝖲𝖨𝖹𝖤</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathsf{SIZE}(n^{k})
  </annotation>
 </semantics>
</math>

, which was proved by Vinodchandran.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Proof:<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<ul>
<li>If 

<math display="inline" id="Karp–Lipton_theorem:59">
 <semantics>
  <mrow>
   <mi>𝖯𝖯</mi>
   <mo>⊈</mo>
   <mrow>
    <mi>𝖯</mi>
    <mo>/</mo>
    <mi>𝗉𝗈𝗅𝗒</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">not-subset-of-or-equals</csymbol>
    <ci>𝖯𝖯</ci>
    <apply>
     <divide></divide>
     <ci>𝖯</ci>
     <ci>𝗉𝗈𝗅𝗒</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathsf{PP}\not\subseteq\mathsf{P/poly}
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Karp–Lipton_theorem:60">
 <semantics>
  <mrow>
   <mi>𝖯𝖯</mi>
   <mo>⊈</mo>
   <mrow>
    <mi>𝖲𝖨𝖹𝖤</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>n</mi>
      <mi>k</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">not-subset-of-or-equals</csymbol>
    <ci>𝖯𝖯</ci>
    <apply>
     <times></times>
     <ci>𝖲𝖨𝖹𝖤</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathsf{PP}\not\subseteq\mathsf{SIZE}(n^{k})
  </annotation>
 </semantics>
</math>

.</li>
<li>Otherwise, 

<math display="inline" id="Karp–Lipton_theorem:61">
 <semantics>
  <mrow>
   <msup>
    <mi>𝖯</mi>
    <mrow>
     <mi mathvariant="normal">♯</mi>
     <mi>𝖯</mi>
    </mrow>
   </msup>
   <mo>⊆</mo>
   <mrow>
    <mi>𝖯</mi>
    <mo>/</mo>
    <mi>𝗉𝗈𝗅𝗒</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝖯</ci>
     <apply>
      <times></times>
      <ci>normal-♯</ci>
      <ci>𝖯</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <ci>𝖯</ci>
     <ci>𝗉𝗈𝗅𝗒</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathsf{P^{\sharp P}}\subseteq\mathsf{P/poly}
  </annotation>
 </semantics>
</math>

. Since</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Karp–Lipton_theorem:62">
 <semantics>
  <mrow>
   <msup>
    <mi>𝖯</mi>
    <mrow>
     <mi mathvariant="normal">♯</mi>
     <mi>𝖯</mi>
    </mrow>
   </msup>
   <mo>⊇</mo>
   <mi>𝖯𝖯</mi>
   <mo>⊇</mo>
   <mi>𝖬𝖠</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">superset-of-or-equals</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝖯</ci>
      <apply>
       <times></times>
       <ci>normal-♯</ci>
       <ci>𝖯</ci>
      </apply>
     </apply>
     <ci>𝖯𝖯</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">superset-of-or-equals</csymbol>
     <share href="#.cmml">
     </share>
     <ci>𝖬𝖠</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathsf{P^{\sharp P}}\supseteq\mathsf{PP}\supseteq\mathsf{MA}
  </annotation>
 </semantics>
</math>

 (by property of <a href="MA_(complexity)" title="wikilink">MA</a>)
</dd>
<dd>

<math display="inline" id="Karp–Lipton_theorem:63">
 <semantics>
  <mrow>
   <msup>
    <mi>𝖯</mi>
    <mrow>
     <mi mathvariant="normal">♯</mi>
     <mi>𝖯</mi>
    </mrow>
   </msup>
   <mo>⊇</mo>
   <mi>𝖯𝖧</mi>
   <mo>⊇</mo>
   <msub>
    <mi mathvariant="normal">Σ</mi>
    <mn>2</mn>
   </msub>
   <mo>⊇</mo>
   <mi>𝖬𝖠</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">superset-of-or-equals</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝖯</ci>
      <apply>
       <times></times>
       <ci>normal-♯</ci>
       <ci>𝖯</ci>
      </apply>
     </apply>
     <ci>𝖯𝖧</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">superset-of-or-equals</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">superset-of-or-equals</csymbol>
     <share href="#.cmml">
     </share>
     <ci>𝖬𝖠</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathsf{P^{\sharp P}}\supseteq\mathsf{PH}\supseteq\Sigma_{2}\supseteq\mathsf{MA}
  </annotation>
 </semantics>
</math>

 (by <a href="Toda's_theorem" title="wikilink">Toda's theorem</a> and property of MA)
</dd>
<dd>

<math display="inline" id="Karp–Lipton_theorem:64">
 <semantics>
  <mrow>
   <msup>
    <mi>𝖯</mi>
    <mrow>
     <mi mathvariant="normal">♯</mi>
     <mi>𝖯</mi>
    </mrow>
   </msup>
   <mo>=</mo>
   <mi>𝖬𝖠</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝖯</ci>
     <apply>
      <times></times>
      <ci>normal-♯</ci>
      <ci>𝖯</ci>
     </apply>
    </apply>
    <ci>𝖬𝖠</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathsf{P^{\sharp P}}=\mathsf{MA}
  </annotation>
 </semantics>
</math>

 (follows from assumption using interactive protocol for permanent, see <a class="uri" href="P/poly" title="wikilink">P/poly</a>)
</dd>
</dl>
</dd>
</dl>
<dl>
<dd>the containments are equalities and we get 

<math display="inline" id="Karp–Lipton_theorem:65">
 <semantics>
  <mrow>
   <mi>𝖯𝖯</mi>
   <mo>=</mo>
   <msub>
    <mi mathvariant="normal">Σ</mi>
    <mn>2</mn>
   </msub>
   <mo>⊈</mo>
   <mrow>
    <mi>𝖲𝖨𝖹𝖤</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>n</mi>
      <mi>k</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>𝖯𝖯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">not-subset-of-or-equals</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>𝖲𝖨𝖹𝖤</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathsf{PP}=\Sigma_{2}\not\subseteq\mathsf{SIZE}(n^{k})
  </annotation>
 </semantics>
</math>

 by Kannan's theorem.
</dd>
</dl>
<h2 id="references">References</h2>
<references>
</references>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Theorems_in_computational_complexity_theory" title="wikilink">Category:Theorems in computational complexity theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="Stathis_Zachos" title="wikilink">S. Zachos</a>, Probabilistic quantifiers and games, 1988<a href="#fnref1">↩</a></li>
<li id="fn2">Jin Yi-Cai. 

<math display="inline" id="Karp–Lipton_theorem:66">
 <semantics>
  <mrow>
   <msubsup>
    <mi>S</mi>
    <mn>2</mn>
    <mi>P</mi>
   </msubsup>
   <mo>⊆</mo>
   <msup>
    <mi>𝖹𝖯𝖯</mi>
    <mi>𝖭𝖯</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>P</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝖹𝖯𝖯</ci>
     <ci>𝖭𝖯</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{2}^{P}\subseteq\mathsf{ZPP}^{\mathsf{NP}}
  </annotation>
 </semantics>
</math>

 <a href="http://pages.cs.wisc.edu/~jyc/papers/S2-j.pdf">1</a>, section 6<a href="#fnref2">↩</a></li>
<li id="fn3">V. Arvind, J. Köbler, <a href="Uwe_Schöning" title="wikilink">U. Schöning</a>, R. Schuler, <a href="http://www.informatik.hu-berlin.de/forschung/gebiete/algorithmenII/Publikationen/Papers/ma-am.ps.gz">If NP has Polynomial-Size Circuits, then MA = AM</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">N. V. Vinodchandran, <a href="http://www.cse.unl.edu/~vinod/papers/pp.ps">A note on the circuit complexity of PP</a><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="Scott_Aaronson" title="wikilink">S. Aaronson</a>, <a href="http://www.scottaaronson.com/papers/subtle.pdf">Oracles Are Subtle But Not Malicious</a><a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
