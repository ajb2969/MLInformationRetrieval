<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="705">Reduction (recursion theory)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Reduction (recursion theory)</h1>
<hr/>

<p>In <a href="computability_theory" title="wikilink">computability theory</a>, many <strong>reducibility relations</strong> (also called <strong>reductions</strong>, <strong>reducibilities</strong>, and <strong>notions of reducibility</strong>) are studied. They are motivated by the question: given sets <em>A</em> and <em>B</em> of natural numbers, is it possible to effectively convert a method for deciding membership in <em>B</em> into a method for deciding membership in <em>A</em>? If the answer to this question is affirmative then <em>A</em> is said to be <strong>reducible to</strong> <em>B</em>.</p>

<p>The study of reducibility notions is motivated by the study of <a href="decision_problems" title="wikilink">decision problems</a>. For many notions of reducibility, if any <a href="computable_set" title="wikilink">noncomputable</a> set is reducible to a set <em>A</em> then <em>A</em> must also be noncomputable. This gives a powerful technique for proving that many sets are noncomputable.</p>
<h2 id="reducibility-relations">Reducibility relations</h2>

<p>A <strong>reducibility relation</strong> is a binary relation on sets of natural numbers that is</p>
<ul>
<li><a href="Reflexive_relation" title="wikilink">Reflexive</a>: Every set is reducible to itself.</li>
<li><a href="transitive_relation" title="wikilink">Transitive</a>: If a set <em>A</em> is reducible to a set <em>B</em> and <em>B</em> is reducible to a set <em>C</em> then <em>A</em> is reducible to <em>C</em>.</li>
</ul>

<p>These two properties imply that a reducibility is a <a class="uri" href="preorder" title="wikilink">preorder</a> on the powerset of the natural numbers. Not all preorders are studied as reducibility notions, however. The notions studied in computability theory have the informal property that <em>A</em> is reducible to <em>B</em> if and only if any (possibly noneffective) decision procedure for <em>B</em> can be effectively converted to a decision procedure for <em>A</em>. The different reducibility relations vary in the methods they permit such a conversion process to use.</p>
<h3 id="degrees-of-a-reducibility-relation">Degrees of a reducibility relation</h3>

<p>Every reducibility relation (in fact, every preorder) induces an equivalence relation on the powerset of the natural numbers in which two sets are equivalent if and only if each one is reducible to the other. In recursion theory, these equivalence classes are called the <strong>degrees</strong> of the reducibility relation. For example, the Turing degrees are the equivalence classes of sets of naturals induced by Turing reducibility.</p>

<p>The degrees of any reducibility relation are <a href="partial_order" title="wikilink">partially ordered</a> by the relation in the following manner. Let ≤ be a reducibility relation and let <strong>A</strong> and <strong>B</strong> be two of its degrees. Then <strong>A</strong> ≤ <strong>B</strong> if and only if there is a set <em>A</em> in <strong>A</strong> and a set <em>B</em> in <strong>B</strong> such that <em>A</em> ≤ <em>B</em>. This is equivalent to the property that for every set <em>A</em> in <strong>A</strong> and every set <em>B</em> in <strong>B</strong>, <em>A</em> ≤ <em>B</em>, because any two sets in <em>A</em> are equivalent and any two sets in <em>B</em> are equivalent. It is common, as shown here, to use boldface notation to denote degrees.</p>
<h2 id="turing-reducibility">Turing reducibility</h2>

<p>The most fundamental reducibility notion is <a href="Turing_reducibility" title="wikilink">Turing reducibility</a>. A set <em>A</em> of natural numbers is <strong>Turing reducible</strong> to a set <em>B</em> if and only if there is an <a href="oracle_Turing_machine" title="wikilink">oracle Turing machine</a> that, when run with <em>B</em> as its oracle set, will compute the <a href="indicator_function" title="wikilink">indicator function</a> (characteristic function) of <em>A</em>. Equivalently, <em>A</em> is Turing reducible to <em>B</em> if and only if there is an algorithm for computing the indicator function for <em>A</em> provided that the algorithm is provided with a means to correctly answer questions of the form "Is <em>n</em> in <em>B</em>?".</p>

<p>Turing reducibility serves as a dividing line for other reducibility notions because, according to the <a href="Church-Turing_thesis" title="wikilink">Church-Turing thesis</a>, it is the most general reducibility relation that is effective. Reducibility relations that imply Turing reducibility have come to be known as <strong>strong reducibilities</strong>, while those that are implied by Turing reducibility are <strong>weak reducibilities.</strong> Equivalently, a strong reducibility relation is one whose degrees form a finer equivalence relation than the Turing degrees, while a weak reducibility relation is one whose degrees form a coarser equivalence relation than Turing equivalence.</p>
<h2 id="reductions-stronger-than-turing-reducibility">Reductions stronger than Turing reducibility</h2>

<p>The strong reducibilities include</p>
<ul>
<li><a href="many-one_reduction" title="wikilink">One-one reducibility</a>: <em>A</em> is one-one reducible to <em>B</em> if there is a computable <a href="Injective_function" title="wikilink">one-to-one function</a> <em>f</em> with <em>A</em>(<em>x</em>) = <em>B</em>(<em>f</em>(<em>x</em>)) for all <em>x</em>.</li>
<li><a href="many-one_reduction" title="wikilink">Many-one reducibility</a>: <em>A</em> is many-one reducible to <em>B</em> if there is a computable function <em>f</em> with <em>A</em>(<em>x</em>) = <em>B</em>(<em>f</em>(<em>x</em>)) for all <em>x</em>.</li>
<li><a href="Truth_table_reduction" title="wikilink">Truth-table reducible</a>: <em>A</em> is truth-table reducible to <em>B</em> if <em>A</em> is Turing reducible to <em>B</em> via a single (oracle) Turing machine which produces a total function relative to every oracle.</li>
<li><a href="Truth_table_reduction" title="wikilink">Weak truth-table reducible</a>: <em>A</em> is weak truth-table reducible to <em>B</em> if there is a Turing reduction from <em>B</em> to <em>A</em> and a recursive function <em>f</em> which bounds the <a href="Turing_reduction#The_use_of_a_reduction" title="wikilink">use</a>. Whenever <em>A</em> is truth-table reducible to <em>B</em>, <em>A</em> is also weak truth-table reducible to <em>B</em>, since one can construct a recursive bound on the use by considering the maximum use over the tree of all oracles, which will exist if the reduction is total on all oracles.</li>
<li>Positive reducible: <em>A</em> is positive reducible to <em>B</em> if and only if <em>A</em> is truth-table reducible to <em>B</em> in a way that one can compute for every <em>x</em> a formula consisting of atoms of the form <em>B</em>(0), <em>B</em>(1), ... such that these atoms are combined by and's and or's, where the and of <em>a</em> and <em>b</em> is 1 if <em>a</em> = 1 and <em>b</em> = 1 and so on.</li>
<li>Disjunctive reducible: Similar to positive reducible with the additional constraint that only or's are permitted.</li>
<li>Conjunctive reducibility: Similar to positive reducibility with the additional constraint that only and's are permitted.</li>
<li>Linear reducibility: Similar to positive reducibility but with the constraint that all atoms of the form <em>B</em>(<em>n</em>) are combined by exclusive or's. In other words, <em>A</em> is linear reducible to <em>B</em> if and only if a computable function computes for each <em>x</em> a finite set <em>F</em>(<em>x</em>) given as an explicit list of numbers such that <em>x</em> ∈ <em>A</em> if and only if <em>F</em>(<em>x</em>) contains an odd number of elements of <em>B</em>.</li>
</ul>

<p>Many of these were introduced by Post (1944). Post was searching for a non-<a href="recursive_set" title="wikilink">recursive</a>, <a href="recursively_enumerable" title="wikilink">recursively enumerable</a> set which the <a href="halting_problem" title="wikilink">halting problem</a> could not be Turing reduced to. As he could not construct such a set in 1944, he instead worked on the analogous problems for the various reducibilities that he introduced. These reducibilities have since been the subject of much research, and many relationships between them are known.</p>
<h3 id="bounded-reducibilities">Bounded reducibilities</h3>

<p>A <strong>bounded</strong> form of each of the above strong reducibilities can be defined. The most famous of these is bounded truth-table reduction, but there are also bounded Turing, bounded weak truth-table and others. These first three are the most common ones and they are based on the number of queries. For example, a set <em>A</em> is bounded truth-table reducible to <em>B</em> if and only if the Turing machine <em>M</em> computing <em>A</em> relative to <em>B</em> computes a list of up to <em>n</em> numbers, queries <em>B</em> on these numbers and then terminates for all possible oracle answers; the value <em>n</em> is a constant independent of <em>x</em>. The difference between bounded weak truth-table and bounded Turing reduction is that in the first case, the up to <em>n</em> queries have to be made at the same time while in the second case, the queries can be made one after the other. For that reason, there are cases where <em>A</em> is bounded Turing reducible to <em>B</em> but not weak truth-table reducible to <em>B</em>.</p>
<h3 id="strong-reductions-in-computational-complexity">Strong reductions in computational complexity</h3>

<p>The strong reductions listed above restrict the manner in which oracle information can be accessed by a decision procedure but do not otherwise limit the computational resources available. Thus if a set <em>A</em> is <a href="computable_set" title="wikilink">decidable</a> then <em>A</em> is reducible to any set <em>B</em> under any of the strong reducibility relations listed above, even if <em>A</em> is not polynomial-time or exponential-time decidable. This is acceptable in the study of recursion theory, which is interested in theoretical computability, but it is not reasonable for <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, which studies which sets can be decided under certain asymptotical resource bounds.</p>

<p>The most common reducibility in computational complexity theory is <a href="Polynomial-time_reduction" title="wikilink">polynomial-time reducibility</a>; a set <em>A</em> is polynomial-time reducible to a set <em>B</em> if there is a polynomial-time function <em>f</em> such that for every <em>n</em>, <em>n</em> is in <em>A</em> if and only if <em>f</em>(<em>n</em>) is in <em>B</em>. This reducibility is, essentially, a resource-bounded version of many-one reducibility. Other resource-bounded reducibilities are used in other contexts of computational complexity theory where other resource bounds are of interest.</p>
<h2 id="reductions-weaker-than-turing-reducibility">Reductions weaker than Turing reducibility</h2>

<p>Although Turing reducibility is the most general reducibility that is effective, weaker reducibility relations are commonly studied. These reducibilities are related to relative definability of sets over arithmetic or set theory. They include:</p>
<ul>
<li><a href="Arithmetical_reducibility" title="wikilink">Arithmetical reducibility</a>: A set <em>A</em> is arithmetical in a set <em>B</em> if <em>A</em> is definable over the standard model of Peano arithmetic with an extra predicate for <em>B</em>. Equivalently, according to <a href="Post's_theorem" title="wikilink">Post's theorem</a>, <em>A</em> is arithmetical in <em>B</em> if and only if <em>A</em> is Turing reducible to 

<math display="inline" id="Reduction_(recursion_theory):0">
 <semantics>
  <msup>
   <mi>B</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>B</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{(n)}
  </annotation>
 </semantics>
</math>

, the <em>n</em>th <a href="Turing_jump" title="wikilink">Turing jump</a> of <em>B</em>, for some natural number <em>n</em>. The <a href="arithmetical_hierarchy" title="wikilink">arithmetical hierarchy</a> gives a finer classification of arithmetical reducibility.</li>
<li><a href="Hyperarithmetical_reducibility" title="wikilink">Hyperarithmetical reducibility</a>: A set <em>A</em> is hyperarithmetical in a set <em>B</em> if <em>A</em> is 

<math display="inline" id="Reduction_(recursion_theory):1">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Δ</mi>
   <mn>1</mn>
   <mn>1</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Δ</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta^{1}_{1}
  </annotation>
 </semantics>
</math>

 definable (see <a href="analytical_hierarchy" title="wikilink">analytical hierarchy</a>) over the standard model of Peano arithmetic with a predicate for <em>B</em>. Equivalently, <em>A</em> is hyperarithmetical in <em>B</em> if and only if <em>A</em> is Turing reducible to 

<math display="inline" id="Reduction_(recursion_theory):2">
 <semantics>
  <msup>
   <mi>B</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>B</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{(\alpha)}
  </annotation>
 </semantics>
</math>

, the <em>α</em>th <a href="Turing_jump" title="wikilink">Turing jump</a> of <em>B</em>, for some <em>B</em>-<a href="recursive_ordinal" title="wikilink">recursive ordinal</a> α.</li>
<li><a href="Constructible_universe#Relative_constructibility" title="wikilink">Relative constructibility</a>: A set <em>A</em> is relatively constructible from a set <em>B</em> if <em>A</em> is in <em>L</em>(<em>B</em>), the smallest transitive model of <a href="ZFC_set_theory" title="wikilink">ZFC set theory</a> containing <em>B</em> and all the ordinals.</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>K. Ambos-Spies and P. Fejer, 2006. "<a href="http://www.cs.umb.edu/~fejer/articles/History_of_Degrees.pdf">Degrees of Unsolvability</a>." Unpublished preprint.</li>
<li>P. Odifreddi, 1989. <em>Classical Recursion Theory</em>, North-Holland. ISBN 0-444-87295-7</li>
<li>P. Odifreddi, 1999. <em>Classical Recursion Theory, Volume II</em>, Elsevier. ISBN 0-444-50205-X</li>
<li>E. Post, 1944, "Recursively enumerable sets of positive integers and their decision problems", <em>Bulletin of the American Mathematical Society</em>, volume 50, pages 284–316.</li>
<li>H. Rogers, Jr., 1967. <em>The Theory of Recursive Functions and Effective Computability</em>, second edition 1987, MIT Press. ISBN 0-262-68052-1 (paperback), ISBN 0-07-053522-1</li>
<li>G Sacks, 1990. <em>Higher Recursion Theory</em>, Springer-Verlag. ISBN 3-540-19305-7</li>
</ul>

<p>"</p>

<p><a href="Category:Computability_theory" title="wikilink">Category:Computability theory</a></p>
</body>
</html>
