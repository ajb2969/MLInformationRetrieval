<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1333">Append</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Append</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In general, to <strong>append</strong> is to join or add on to the end of something. For example, an <a href="addendum#Books" title="wikilink">appendix</a> is a section appended (added to the end) of a document.</p>

<p>In <a href="computer_programming" title="wikilink">computer programming</a>, <strong><code>append</code></strong> is the name of a <a href="Procedure_(computer_science)" title="wikilink">procedure</a> for concatenating (<a href="linked_list" title="wikilink">linked</a>) lists or <a href="Array_data_type" title="wikilink">arrays</a> in some <a href="high-level_programming_language" title="wikilink">high-level programming languages</a>.</p>
<h2 id="lisp">Lisp</h2>

<p><code>Append</code> originates in the <a href="Lisp_programming_language" title="wikilink">Lisp programming language</a>. The <code>append</code> procedure takes zero or more <a href="linked_list" title="wikilink">(linked) lists</a> as arguments, and returns the concatenation of these lists.</p>
<pre class="lisp"><code>(append '(1 2 3) '(a b) '() '(6))
;Output: (1 2 3 a b 6)</code></pre>

<p>Since the <code>append</code> procedure must completely copy all of its arguments except the last, both its <a href="Computational_complexity_theory" title="wikilink">time and space complexity</a> are <a href="Big_O_notation" title="wikilink">O(<em>n</em>)</a> for a list of 

<math display="inline" id="Append:0">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 elements. It may thus be a source of inefficiency if used injudiciously in code.</p>

<p>The <code>nconc</code> procedure (called <code>append!</code> in <a href="Scheme_(programming_language)" title="wikilink">Scheme</a>) performs the same function as <code>append</code>, but <a href="in-place_algorithm" title="wikilink">destructively</a>: it alters the <a href="Car_and_cdr" title="wikilink">cdr</a> of each argument (save the last), pointing it to the next list.</p>
<h3 id="implementation">Implementation</h3>

<p><code>Append</code> can easily be defined <a href="recursion" title="wikilink">recursively</a> in terms of <code>[[cons]]</code>. The following is a simple implementation in Scheme, for two arguments only:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> append</span>
  (<span class="kw">lambda</span> (ls1 ls2)
    (<span class="kw">if</span> (<span class="kw">null?</span> ls1)
      ls2
      (<span class="kw">cons</span> (<span class="kw">car</span> ls1) (<span class="kw">append</span> (<span class="kw">cdr</span> ls1) ls2)))))</code></pre></div>

<p>Append can also be implemented using fold-right:</p>
<div class="sourceCode"><pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> append</span>
   (<span class="kw">lambda</span> (a b)
      (fold-right <span class="kw">cons</span> b a)))</code></pre></div>
<h2 id="other-languages">Other languages</h2>

<p>Following Lisp, other <a href="high-level_language" title="wikilink">high-level languages</a> which feature <a href="linked_list" title="wikilink">linked lists</a> as primitive <a href="data_structure" title="wikilink">data structures</a> have adopted an <code>append</code>. <a href="Haskell_(programming_language)" title="wikilink">Haskell</a> uses the <code>++</code> operator to append lists. <a class="uri" href="OCaml" title="wikilink">OCaml</a> uses the <code>@</code> operator to append lists.</p>

<p>Other languages use the <code>+</code> or <code>++</code> symbols for nondestructive <a href="string_(computer_science)" title="wikilink">string</a>/list/array concatenation.</p>
<h3 id="prolog">Prolog</h3>

<p>The <a href="logic_programming_language" title="wikilink">logic programming language</a> <a href="Prolog_programming_language" title="wikilink">Prolog</a> features a built-in <code>append</code> predicate, which can be implemented as follows:</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog">append([]<span class="kw">,</span><span class="dt">Ys</span><span class="kw">,</span><span class="dt">Ys</span>)<span class="kw">.</span>
append([<span class="dt">X</span><span class="fu">|</span><span class="dt">Xs</span>]<span class="kw">,</span><span class="dt">Ys</span><span class="kw">,</span>[<span class="dt">X</span><span class="fu">|</span><span class="dt">Zs</span>]) <span class="kw">:-</span>
    append(<span class="dt">Xs</span><span class="kw">,</span><span class="dt">Ys</span><span class="kw">,</span><span class="dt">Zs</span>)<span class="kw">.</span></code></pre></div>

<p>This predicate can be used for appending, but also for picking lists apart. Calling</p>
<div class="sourceCode"><pre class="sourceCode prolog"><code class="sourceCode prolog"> <span class="fu">?-</span> append(<span class="dt">L</span><span class="kw">,</span><span class="dt">R</span><span class="kw">,</span>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>])<span class="kw">.</span></code></pre></div>

<p>yields the solutions:</p>

<p><code>L = [], R = [1, 2, 3] ;</code><br/>
<code>L = [1], R = [2, 3] ;</code><br/>
<code>L = [1, 2], R = [3] ;</code><br/>
<code>L = [1, 2, 3], R = []</code></p>
<h3 id="miranda">Miranda</h3>

<p>This right-<a href="Fold_(higher-order_function)" title="wikilink">fold</a>, from Hughes (1989:5-6), has the same semantics (by example) as the Scheme implementation above, for two arguments.</p>

<p><code>append a b = reduce cons b a</code></p>

<p>Where reduce is Miranda's name for <a href="Fold_(higher-order_function)" title="wikilink">fold</a>, and <a class="uri" href="cons" title="wikilink">cons</a> constructs a list from two values or lists.</p>

<p>For example,</p>

<p><code>append [1,2] [3,4] = reduce cons [3,4] [1,2]</code><br/>
<code>    = (reduce cons [3,4]) (cons 1 (cons 2 nil))</code><br/>
<code>    = cons 1 (cons 2 [3,4]))</code><br/>
<code>        (replacing cons by cons and nil by [3,4])</code><br/>
<code>    = [1,2,3,4]</code></p>
<h3 id="haskell">Haskell</h3>

<p>This right-<a href="Fold_(higher-order_function)" title="wikilink">fold</a> has the same effect as the Scheme implementation above:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">append ::</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
append xs ys <span class="fu">=</span> foldr (<span class="fu">:</span>) ys xs</code></pre></div>

<p>This is essentially a reimplementation of Haskell's <code>++</code> operator.</p>
<h3 id="perl">Perl</h3>

<p>In <a href="Perl_(programming_language)" title="wikilink">Perl</a>, the push function is equivalent to the append method, and can be used in the following way.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl"><span class="kw">my</span> <span class="dt">@list</span>;
<span class="fu">push</span> <span class="dt">@list</span>, <span class="dv">1</span>;
<span class="fu">push</span> <span class="dt">@list</span>, <span class="dv">2</span>, <span class="dv">3</span>;</code></pre></div>

<p>The end result is a list containing [1, 2, 3]</p>

<p>The unshift function appends to the front of a list, rather than the end</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl"><span class="kw">my</span> <span class="dt">@list</span>;
<span class="fu">unshift</span> <span class="dt">@list</span>, <span class="dv">1</span>;
<span class="fu">unshift</span> <span class="dt">@list</span>, <span class="dv">2</span>, <span class="dv">3</span>;</code></pre></div>

<p>The end result is a list containing [2, 3, 1]</p>

<p>When opening a file, use the "&gt;&gt;" mode to append rather than over write.</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl"><span class="fu">open</span>(<span class="kw">my</span> <span class="dt">$fh</span>, <span class="kw">'</span><span class="st">&gt;&gt;</span><span class="kw">'</span>, <span class="kw">"</span><span class="st">/some/file.txt</span><span class="kw">"</span>);
<span class="fu">print</span> <span class="dt">$fh</span> <span class="kw">"</span><span class="st">Some new text</span><span class="ch">\n</span><span class="kw">"</span>;
<span class="fu">close</span> <span class="dt">$fh</span>;</code></pre></div>

<p>Note that when opening and closing file handles, one should always check the return value.</p>
<h3 id="python">Python</h3>

<p>In <a href="Python_(programming_language)" title="wikilink">Python</a>, use the list method "extend" or the infix operators + and += to append lists.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">l <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>]
l.extend([<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>])
<span class="bu">print</span> l <span class="op">+</span> [<span class="dv">6</span>, <span class="dv">7</span>]</code></pre></div>

<p>After executing this code, l is a list containing [1, 2, 3, 4, 5], while the output generated is the list [1, 2, 3, 4, 5, 6, 7].</p>

<p>Do not confuse with the list method "append", which adds a <strong>single</strong> element to a list:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">l <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>]
l.append(<span class="dv">3</span>)</code></pre></div>

<p>Here, the result is a list containing [1, 2, 3].</p>
<h3 id="bash">Bash</h3>

<p>In <a href="Bash_(Unix_shell)" title="wikilink">Bash</a> the append redirect is the usage of "&gt;&gt;" for adding a stream to something, like in the following series of shell commands:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">echo</span> Hello world! <span class="kw">&gt;</span>text<span class="kw">;</span> <span class="kw">echo</span> Goodbye world! <span class="kw">&gt;&gt;</span>text<span class="kw">;</span> <span class="kw">cat</span> text</code></pre></div>

<p>The stream "Goodbye world!" is added to the text file written in the first command. The ";" implies the execution of the given commands in order not simultaneously. So, the final content of the text file is:</p>

<p>Hello world!</p>

<p>Goodbye world!</p>
<h2 id="dos-command">DOS command</h2>

<p><strong>append</strong> is a <a class="uri" href="DOS" title="wikilink">DOS</a> command that allows programs to open data files in specified directories as if they were in the current directory. It appends the directories to the search path list.</p>
<h2 id="references">References</h2>
<ul>
<li>Hughes, John. 1989. Why functional programming matters. <em>Computer Journal 32</em>, 2, 98-107. <a class="uri" href="http://www.math.chalmers.se/~rjmh/Papers/whyfp.pdf">http://www.math.chalmers.se/~rjmh/Papers/whyfp.pdf</a></li>
<li>Steele, Guy L. Jr. <em><a href="Common_Lisp" title="wikilink">Common Lisp</a>: The Language, Second Edition</em>. 1990. pg. 418, description of <code>append</code>.</li>
</ul>

<p>"</p>

<p><a href="Category:Functional_programming" title="wikilink">Category:Functional programming</a> <a href="Category:Lisp_(programming_language)" title="wikilink">Category:Lisp (programming language)</a> <a href="Category:Programming_constructs" title="wikilink">Category:Programming constructs</a> <a href="Category:Articles_with_example_code" title="wikilink">Category:Articles with example code</a> <a href="Category:DOS_on_IBM_PC_compatibles" title="wikilink">Category:DOS on IBM PC compatibles</a></p>
</body>

