<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="830">Super-resolution optical fluctuation imaging</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Super-resolution optical fluctuation imaging</h1>
<hr/>

<p><strong>Super-resolution optical fluctuation imaging (SOFI)</strong> is a post-processing method for the calculation of super-resolved images from recorded image time series that is based on the temporal correlations of independently fluctuating fluorescent emitters.</p>

<p>SOFI has been developed for super-resolution of biological specimen that are labelled with independently fluctuating fluorescent emitters (organic dyes, <a href="Green_fluorescent_protein" title="wikilink">fluorescent proteins</a>). In comparison to other <a href="super-resolution_microscopy" title="wikilink">super-resolution microscopy</a> techniques such as <a href="Super-resolution_microscopy#Stochastic_optical_reconstruction_microscopy_(STORM),_photo_activated_localization_microscopy_(PALM)_and_fluorescence_photo-activation_localization_microscopy_(fPALM)" title="wikilink">STORM</a> or <a href="Photoactivated_localization_microscopy" title="wikilink">PALM</a> that rely on single-molecule localization and hence only allow one active molecule per <a href="Diffraction_limit" title="wikilink">diffraction-limited area (DLA)</a> and timepoint,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> SOFI does not necessitate a controlled <a href="photoswitch" title="wikilink">photoswitching</a> and/ or photoactivation as well as long imaging times.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Nevertheless it still requires fluorophores that are cycling through two distinguishable states, either real on-/off-states or states with different fluorescence intensities. In mathematical terms SOFI-imaging relies on the calculation of <a href="cumulant" title="wikilink">cumulants</a>, for what two distinguishable ways exist. For one thing an image can be calculated via auto-cumulants<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> that by definition only rely on the information of each pixel itself, and for another thing an improved method utilizes the information of different pixels via the calculation of cross-cumulants.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Both methods can increase the final image resolution significantly although the cumulant calculation has its limitations. Actually SOFI is able to increase the resolution in all three dimensions.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="principle">Principle</h2>

<p><embed src="SuperresolutionOFI1.pdf" title="fig:Principle of the SOFI auto-cumulant calculation (A) Schematic depiction of a CCD-pixel grid containing several emitter-signals (B) Cut-out of two fluorophores with their signals convolved with the system's PSF, recorded in an image stack (C) The signals on every pixel are evaluated by cumulant calculation (a process that can be understood in terms of a correlation and integration)"></embed> Likewise to other super-resolution methods SOFI is based on recording an image time series on a CCD- or CMOS camera. In contrary to other methods the recorded time series can be substantially shorter, since a precise localization of emitters is not required and therefore a larger quantity of activated fluorophores per diffraction-limited area is allowed. The pixel values of a SOFI-image of the <em>n</em>-th order are calculated from the values of the pixel time series in the form of a <em>n</em>-th order cumulant, whereas the final value assigned to a pixel can be imagined as the integral over a correlation function. The finally assigned pixel value intensities are a measure of the brightness and correlation of the fluorescence signal. Mathematical the <em>n</em>-th order cumulant is related to the <em>n</em>-th order correlation function, but exhibits some advantages concerning the resulting resolution of the image. Since in SOFI several emitters per DLA are allowed, the photon count at each pixel results from the superposition of the signals of all activated nearby emitters. The cumulant calculation now filters the signal and leaves only highly correlated fluctuations. This provides a contrast enhancement and therefore a background reduction for good measure. As it is implied in the figure on the left the fluorescence source distribution:</p>

<p>

<math display="block" id="Super-resolution_optical_fluctuation_imaging:0">
 <semantics>
  <mrow>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>k</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>N</mi>
   </munderover>
   <mrow>
    <mrow>
     <mrow>
      <mi>δ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mover accent="true">
         <mi>r</mi>
         <mo stretchy="false">→</mo>
        </mover>
        <mo>-</mo>
        <msub>
         <mover accent="true">
          <mi>r</mi>
          <mo stretchy="false">→</mo>
         </mover>
         <mi>k</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⋅</mo>
     <msub>
      <mi>ε</mi>
      <mi>k</mi>
     </msub>
     <mo>⋅</mo>
     <msub>
      <mi>s</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <ci>δ</ci>
       <apply>
        <minus></minus>
        <apply>
         <ci>normal-→</ci>
         <ci>r</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <ci>normal-→</ci>
          <ci>r</ci>
         </apply>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ε</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{k=1}^{N}\delta(\vec{r}-\vec{r}_{k})\cdot\varepsilon_{k}\cdot s_{k}(t)
  </annotation>
 </semantics>
</math>

</p>

<p>is convolved with the system's point spread function (PSF) <em>U</em>(<em>r</em>). Hence the fluorescence signal at time t and position 

<math display="inline" id="Super-resolution_optical_fluctuation_imaging:1">
 <semantics>
  <mover accent="true">
   <mi>r</mi>
   <mo stretchy="false">→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{r}
  </annotation>
 </semantics>
</math>

 is given by</p>

<p>

<math display="block" id="Super-resolution_optical_fluctuation_imaging:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mover accent="true">
       <mi>r</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </munderover>
     <mrow>
      <mrow>
       <mrow>
        <mi>U</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mover accent="true">
           <mi>r</mi>
           <mo stretchy="false">→</mo>
          </mover>
          <mo>-</mo>
          <msub>
           <mover accent="true">
            <mi>r</mi>
            <mo stretchy="false">→</mo>
           </mover>
           <mi>k</mi>
          </msub>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>⋅</mo>
       <msub>
        <mi>ε</mi>
        <mi>k</mi>
       </msub>
       <mo>⋅</mo>
       <msub>
        <mi>s</mi>
        <mi>k</mi>
       </msub>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <interval closure="open">
      <apply>
       <ci>normal-→</ci>
       <ci>r</ci>
      </apply>
      <ci>t</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>N</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <ci>U</ci>
        <apply>
         <minus></minus>
         <apply>
          <ci>normal-→</ci>
          <ci>r</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <ci>normal-→</ci>
           <ci>r</ci>
          </apply>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ε</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>s</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\vec{r},t)=\sum_{k=1}^{N}U(\vec{r}-\vec{r}_{k})\cdot\varepsilon_{k}\cdot s_{%
k}(t).
  </annotation>
 </semantics>
</math>

</p>

<p>Within the above equations <em>N</em> is the amount of emitters, located at the positions 

<math display="inline" id="Super-resolution_optical_fluctuation_imaging:3">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>r</mi>
    <mo stretchy="false">→</mo>
   </mover>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-→</ci>
     <ci>r</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vec{r}_{k}
  </annotation>
 </semantics>
</math>

 with a time-dependent molecular brightness 

<math display="inline" id="Super-resolution_optical_fluctuation_imaging:4">
 <semantics>
  <mrow>
   <msub>
    <mi>ε</mi>
    <mi>k</mi>
   </msub>
   <mo>⋅</mo>
   <msub>
    <mi>s</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ε</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon_{k}\cdot s_{k}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Super-resolution_optical_fluctuation_imaging:5">
 <semantics>
  <msub>
   <mi>ε</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ε</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon_{k}
  </annotation>
 </semantics>
</math>

 is a variable for the constant molecular brightness and 

<math display="inline" id="Super-resolution_optical_fluctuation_imaging:6">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>k</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{k}(t)
  </annotation>
 </semantics>
</math>

 is a time-dependent fluctuation function. The molecular brightness is just the average fluorescence count-rate divided by the number of molecules within a specific region. For simplification it has to be assumed that the sample is in a stationary equilibrium and therefore the fluorescence signal can be expressed as a zero-mean fluctuation:</p>

<p>

<math display="block" id="Super-resolution_optical_fluctuation_imaging:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>δ</mi>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>r</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mover accent="true">
       <mi>r</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <msub>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mrow>
       <mi>F</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mover accent="true">
         <mi>r</mi>
         <mo stretchy="false">→</mo>
        </mover>
        <mo>,</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mi>t</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>δ</ci>
     <ci>F</ci>
     <interval closure="open">
      <apply>
       <ci>normal-→</ci>
       <ci>r</ci>
      </apply>
      <ci>t</ci>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>F</ci>
      <interval closure="open">
       <apply>
        <ci>normal-→</ci>
        <ci>r</ci>
       </apply>
       <ci>t</ci>
      </interval>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">delimited-⟨⟩</csymbol>
       <apply>
        <times></times>
        <ci>F</ci>
        <interval closure="open">
         <apply>
          <ci>normal-→</ci>
          <ci>r</ci>
         </apply>
         <ci>t</ci>
        </interval>
       </apply>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta F(\vec{r},t)=F(\vec{r},t)-\langle F(\vec{r},t)\rangle_{t}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Super-resolution_optical_fluctuation_imaging:8">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">delimited-⟨⟩</csymbol>
     <ci>normal-⋯</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\cdots\rangle_{t}
  </annotation>
 </semantics>
</math>

 denotes time-averaging. The auto-correlation here e.g. the second-order can then be described deductively as follows for a certain time-lag 

<math display="inline" id="Super-resolution_optical_fluctuation_imaging:9">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Super-resolution_optical_fluctuation_imaging:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>δ</mi>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>r</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mrow>
       <mrow>
        <mi>δ</mi>
        <mi>F</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mover accent="true">
          <mi>r</mi>
          <mo stretchy="false">→</mo>
         </mover>
         <mo>,</mo>
         <mrow>
          <mi>t</mi>
          <mo>+</mo>
          <mi>τ</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>⋅</mo>
       <mi>δ</mi>
      </mrow>
      <mi>F</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mover accent="true">
        <mi>r</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mo>,</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>t</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>δ</ci>
     <ci>F</ci>
     <interval closure="open">
      <apply>
       <ci>normal-→</ci>
       <ci>r</ci>
      </apply>
      <ci>t</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <times></times>
         <ci>δ</ci>
         <ci>F</ci>
         <interval closure="open">
          <apply>
           <ci>normal-→</ci>
           <ci>r</ci>
          </apply>
          <apply>
           <plus></plus>
           <ci>t</ci>
           <ci>τ</ci>
          </apply>
         </interval>
        </apply>
        <ci>δ</ci>
       </apply>
       <ci>F</ci>
       <interval closure="open">
        <apply>
         <ci>normal-→</ci>
         <ci>r</ci>
        </apply>
        <ci>t</ci>
       </interval>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta F(\vec{r},t)=\langle\delta F(\vec{r},t+\tau)\cdot\delta F(\vec{r},t)%
\rangle_{t}
  </annotation>
 </semantics>
</math>

</p>

<p>From these equations it follows that the PSF of the optical system has to be taken to the power of the order of the correlation. Thus in a second-order correlation the PSF would be reduced along all dimensions by a factor of 

<math display="inline" id="Super-resolution_optical_fluctuation_imaging:11">
 <semantics>
  <msqrt>
   <mn>2</mn>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{2}
  </annotation>
 </semantics>
</math>

. As a result the resolution of the SOFI-images increases according to this factor.</p>
<h3 id="cumulants-versus-correlations">Cumulants versus correlations</h3>

<p>Using only the simple correlation function for a reassignment of pixel values, would ascribe to the independency of fluctuations of the emitters in time in a way that no cross-correlation terms would contribute to the new pixel value. Calculations of higher-order correlation functions would suffer from lower-order correlations for what reason it is superior to calculate cumulants, since all lower-order correlation terms vanish.</p>
<h2 id="cumulant-calculation">Cumulant-calculation</h2>
<h3 id="auto-cumulants">Auto-cumulants</h3>

<p>For computational reasons it is convenient to set all time-lags in higher-order cumulants to zero so that a general expression for the <em>n</em>-th order auto-cumulant can be found:<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>

<math display="block" id="Super-resolution_optical_fluctuation_imaging:12">
 <semantics>
  <mrow>
   <mi>A</mi>
   <msub>
    <mi>C</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>r</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo>,</mo>
    <msub>
     <mi>τ</mi>
     <mrow>
      <mrow>
       <mn>1</mn>
       <mi mathvariant="normal">…</mi>
       <mi>n</mi>
      </mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>k</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>N</mi>
   </munderover>
   <msup>
    <mi>U</mi>
    <mi>n</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>r</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo>-</mo>
    <msub>
     <mover accent="true">
      <mi>r</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <msubsup>
    <mi>ε</mi>
    <mi>k</mi>
    <mi>n</mi>
   </msubsup>
   <msub>
    <mi>w</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>n</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>r</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <cn type="integer">1</cn>
        <ci>normal-…</ci>
        <ci>n</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <eq></eq>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>U</ci>
     <ci>n</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>r</ci>
     </apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-→</ci>
       <ci>r</ci>
      </apply>
      <ci>k</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ε</ci>
      <ci>n</ci>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>k</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   AC_{n}(\vec{r},\tau_{1\ldots n-1}=0)=\sum_{k=1}^{N}U^{n}(\vec{r}-\vec{r}_{k})%
\varepsilon^{n}_{k}w_{k}(0)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Super-resolution_optical_fluctuation_imaging:13">
 <semantics>
  <msub>
   <mi>w</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{k}
  </annotation>
 </semantics>
</math>

 is a specific correlation based weighting function influenced by the order of the cumulant and mainly depending on the fluctuation properties of the emitters.</p>

<p>Albeit there is no fundamental limitation in calculating very high orders of cumulants and thereby shrinking the FWHM of the PSF there are practical limitations according to the weighting of the values assigned to the final image. Emitters with a higher molecular brightness will show a strong increase in terms of the pixel cumulant value assigned at higher-orders as well as this performance can be expected from a diverse appearance of fluctuations of different emitters. A wide intensity range of the resulting image can therefore be expected and as a result dim emitters can get masked by bright emitters in higher-order images:.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> The calculation of auto-cumulants can be realized in a very attractive way in a mathematical sense. The <em>n</em>-th order cumulant can be calculated with a basic recursion from moments<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>

<math display="block" id="Super-resolution_optical_fluctuation_imaging:14">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>K</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>r</mi>
      <mo stretchy="false">→</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>μ</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mover accent="true">
       <mi>r</mi>
       <mo stretchy="false">→</mo>
      </mover>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </munderover>
     <mrow>
      <mrow>
       <mo>(</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mi>i</mi>
         </mtd>
        </mtr>
       </mtable>
       <mo>)</mo>
      </mrow>
      <msub>
       <mi>K</mi>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mi>i</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mover accent="true">
        <mi>r</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>μ</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mover accent="true">
        <mi>r</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <ci>r</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <ci>normal-→</ci>
       <ci>r</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <matrix>
        <matrixrow>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </matrixrow>
        <matrixrow>
         <ci>i</ci>
        </matrixrow>
       </matrix>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <ci>normal-→</ci>
        <ci>r</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <ci>normal-→</ci>
        <ci>r</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{n}(\vec{r})=\mu_{n}(\vec{r})-\sum_{i=1}^{n-1}\begin{pmatrix}n-1\\
i\end{pmatrix}K_{n-i}(\vec{r})\mu_{i}(\vec{r})
  </annotation>
 </semantics>
</math>

</p>

<p>where K is a cumulant of the index's order, likewise 

<math display="inline" id="Super-resolution_optical_fluctuation_imaging:15">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 represents the moments. The term within the brackets indicates a binomial coefficient. This way of computation is straightforward in comparison with calculating cumulants with standard formulas. It allows for the calculation of cumulants with only little time of computing and is, as it is well implemented, even suitable for the calculation of high-order cumulants on large images.</p>
<h3 id="cross-cumulants">Cross-cumulants</h3>
<figure><b>(Figure)</b>
<embed src="Sofi2cc.pdf" title='Principles of SOFI Cross-cumulant Calculation and Distance-factor: (A) 4th-order cross-cumulant calculation with "combinations with repetitions". (B) Distance-factor decay along the arrows.'></embed><figcaption><em>Principles of SOFI Cross-cumulant Calculation and Distance-factor:</em> <strong>(A)</strong> 4th-order cross-cumulant calculation with "combinations with repetitions". <strong>(B)</strong> Distance-factor decay along the arrows.</figcaption>
</figure>

<p>In a more advanced approach cross-cumulants are calculated by taking the information of several pixels into account. Cross-cumulants can be described as follows:<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>

<math display="block" id="Super-resolution_optical_fluctuation_imaging:16">
 <semantics>
  <mrow>
   <msub>
    <mi>K</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo maxsize="260%" minsize="260%">(</mo>
    <mover accent="true">
     <mi>r</mi>
     <mo stretchy="false">→</mo>
    </mover>
    <mo>=</mo>
    <mfrac>
     <mn>1</mn>
     <mi>n</mi>
    </mfrac>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </munderover>
    <mover accent="true">
     <msub>
      <mi>r</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">→</mo>
    </mover>
    <mo maxsize="260%" minsize="260%">)</mo>
   </mrow>
   <mo>=</mo>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mi>P</mi>
   </munder>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>-</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>P</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo stretchy="false">|</mo>
    <mi>P</mi>
    <mo stretchy="false">|</mo>
    <mo>-</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
   <munder>
    <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
    <mrow>
     <mi>p</mi>
     <mo>∈</mo>
     <mi>P</mi>
    </mrow>
   </munder>
   <msub>
    <mrow>
     <mo maxsize="160%" minsize="160%">⟨</mo>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
      <mrow>
       <mi>i</mi>
       <mo>∈</mo>
       <mi>p</mi>
      </mrow>
     </munder>
     <mi>F</mi>
     <msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mover accent="true">
        <mi>r</mi>
        <mo stretchy="false">→</mo>
       </mover>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>i</mi>
     </msub>
     <mo maxsize="160%" minsize="160%">⟩</mo>
    </mrow>
    <mi>t</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <ci>n</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <ci>normal-→</ci>
      <ci>r</ci>
     </apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <ci>P</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>normal-)</ci>
     </cerror>
     <apply>
      <minus></minus>
      <apply>
       <abs></abs>
       <ci>P</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <ci>normal-|</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-|</ci>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <factorial></factorial>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">product</csymbol>
     <apply>
      <in></in>
      <ci>p</ci>
      <ci>P</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-⟨</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <in></in>
        <ci>i</ci>
        <ci>p</ci>
       </apply>
      </apply>
      <csymbol cd="unknown">F</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <ci>normal-→</ci>
         <ci>r</ci>
        </apply>
        <ci>normal-)</ci>
       </cerror>
       <ci>i</ci>
      </apply>
      <ci>normal-⟩</ci>
     </cerror>
     <ci>t</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{n}\Bigg(\vec{r}=\frac{1}{n}\sum_{i=1}^{n}\vec{r_{i}}\Bigg)=\sum_{P}(-1)^{|P%
|-1}(|P|-1)!\prod_{p\in P}\Big\langle\prod_{i\in p}F(\vec{r})_{i}\Big\rangle_{t}
  </annotation>
 </semantics>
</math>

. This weighting-factor (also termed distance-factor) is PSF-shaped and depends on the distance of the cross-correlated pixels in a sense that the contribution of each pixels decays along the distance in a PSF-shaped manner. In principle this means that the distance-factor is smaller for pixels that are further apart. The cross-cumulant approach can be used to create new, virtual pixels revealing true information about the labelled specimen by reducing the effective pixel size. These pixels carry more information than pixels that arise from simple interpolation.</p>

<p>In addition the cross-cumulant approach can be used to estimate the PSF of the optical system by making use of the intensity differences of the virtual pixels that is due to the "loss" in cross-correlation as aforementioned.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Each virtual pixel can be re-weighted with the inverse of the distance-factor of the pixel leading to a restoration of the true cumulant value. At last the PSF can be used to create a resolution dependency of <em>n</em> for the <em>n</em>th-order cumulant by re-weighting the "optical transfer function" (OTF).<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> This step can also be replaced by using the PSF for a deconvolution that is associated with less computational cost.</p>

<p>Cross-cumulant calculation requires the usage of a computational much more expensive formula that comprises the calculation of sums over partitions. This is of course owed to the combination of different pixels to assign a new value. Hence no fast recursive approach is usable at this point. For the calculation of cross-cumulants the following equation can be used:<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p><span class="LaTeX">$$K_n \Bigg(\vec{r}=\frac{1}{n} \sum_{i=1}^n \vec{r_{i}}\Bigg)=\sum_P(-1)^{|P|-1}(|P|-1)!\prod_{p\in P}\Big\langle \prod_{i\in p} F(\vec{r})_{i}\Big\rangle_{t}$$</span></p>

<p>In this equation <em>P</em> denotes the amount of possible partitions, <em>p</em> denotes the different parts of each partition. In addition <em>i</em> is the index for the different pixel positions taken into account during the calculation what for <em>F</em> is just the image stack of the different contributing pixels. The cross-cumulant approach facilitates the generation of virtual pixels depending on the order of the cumulant as previously mentioned. These virtual pixels can be calculated in a particular pattern from the original pixels for a 4th-order cross-cumulant image, as it is depicted in the lower image, part A. The pattern itself arises simple from the calculation of all possible combinations of the original image pixels A, B, C and D. Here this was done by a scheme of "combinations with repetitions". Virtual pixels exhibit a loss in intensity that is due to the correlation itself. Part B of the second image depicts this general dependency of the virtual pixels on the cross-correlation. To restore meaningful pixel values the image is smoothed by a routine that defines a distance-factor for each pixel of the virtual pixel grid in a PSF-shaped manner and applies the inverse on all image pixels that are related to the same distance-factor.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a class="uri" href="Category:Microscopy" title="wikilink">Category:Microscopy</a> <a href="Category:Image_processing" title="wikilink">Category:Image processing</a> <a href="Category:Covariance_and_correlation" title="wikilink">Category:Covariance and correlation</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
</ol>
</section>
</body>
</html>
