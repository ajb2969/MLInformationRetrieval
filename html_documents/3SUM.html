<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1353">3SUM</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>3SUM</h1>
<hr/>

<p>In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, the <strong>3SUM</strong> problem asks if a given set of 

<math display="inline" id="3SUM:0">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 real numbers contains three elements that sum to zero. A generalized version, rSUM, asks the same question of <em>r</em> numbers. 3SUM can be easily solved in 

<math display="inline" id="3SUM:1">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2})
  </annotation>
 </semantics>
</math>

 time, and matching 

<math display="inline" id="3SUM:2">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">⌈</mo>
      <mrow>
       <mi>r</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">⌉</mo>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <ceiling></ceiling>
      <apply>
       <divide></divide>
       <ci>r</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(n^{\lceil r/2\rceil})
  </annotation>
 </semantics>
</math>

 lower bounds are known in some specialized <a href="models_of_computation" title="wikilink">models of computation</a> .</p>

<p>It was widely conjectured that any deterministic algorithm for the 3SUM requires 

<math display="inline" id="3SUM:3">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(n^{2})
  </annotation>
 </semantics>
</math>

 time. In 2014, the original 3SUM conjecture was refuted by Allan Grønlund and Seth Pettie who gave a deterministic algorithm that solves 3SUM in time 

<math display="inline" id="3SUM:4">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>n</mi>
      <mn>2</mn>
     </msup>
     <mo>/</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>log</mi>
        <mrow>
         <mi>n</mi>
         <mo>/</mo>
         <mrow>
          <mi>log</mi>
          <mrow>
           <mi>log</mi>
           <mi>n</mi>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mn>2</mn>
       <mo>/</mo>
       <mn>3</mn>
      </mrow>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <log></log>
       <apply>
        <divide></divide>
        <ci>n</ci>
        <apply>
         <log></log>
         <apply>
          <log></log>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">2</cn>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2}/({\log n}/{\log\log n})^{2/3})
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> It is still conjectured that 3SUM is unsolvable in 

<math display="inline" id="3SUM:5">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mrow>
      <mn>2</mn>
      <mo>-</mo>
      <mrow>
       <mi mathvariant="normal">Ω</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>1</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <minus></minus>
      <cn type="integer">2</cn>
      <apply>
       <times></times>
       <ci>normal-Ω</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2-\Omega(1)})
  </annotation>
 </semantics>
</math>

 expected time.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>When the elements are integers in the range 

<math display="inline" id="3SUM:6">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <mo>-</mo>
    <mi>N</mi>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mi>N</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <minus></minus>
     <ci>N</ci>
    </apply>
    <ci>normal-…</ci>
    <ci>N</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [-N,\dots,N]
  </annotation>
 </semantics>
</math>

, 3SUM can be solved in 

<math display="inline" id="3SUM:7">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mrow>
      <mi>N</mi>
      <mrow>
       <mi>log</mi>
       <mi>N</mi>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <apply>
      <times></times>
      <ci>N</ci>
      <apply>
       <log></log>
       <ci>N</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n+N\log N)
  </annotation>
 </semantics>
</math>

 time by representing the input set 

<math display="inline" id="3SUM:8">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 as a bit vector, computing the set 

<math display="inline" id="3SUM:9">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>+</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>S</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S+S
  </annotation>
 </semantics>
</math>

 of all pairwise sums as a <a href="Convolution#Discrete_convolution" title="wikilink">discrete convolution</a> using the <a href="Fast_Fourier_transform" title="wikilink">Fast Fourier transform</a>, and finally comparing this set to 

<math display="inline" id="3SUM:10">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -S
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="quadratic-algorithm">Quadratic algorithm</h2>

<p>Suppose the input array is 

<math display="inline" id="3SUM:11">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mrow>
      <mn>0..</mn>
      <mi>n</mi>
     </mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="float">0..</cn>
       <ci>n</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S[0..n-1]
  </annotation>
 </semantics>
</math>

. 3SUM can be solved in 

<math display="inline" id="3SUM:12">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2})
  </annotation>
 </semantics>
</math>

 time on average by inserting each number 

<math display="inline" id="3SUM:13">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>i</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S[i]
  </annotation>
 </semantics>
</math>

 into a <a href="hash_table" title="wikilink">hash table</a>, and then for each index 

<math display="inline" id="3SUM:14">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="3SUM:15">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

, checking whether the hash table contains the integer 

<math display="inline" id="3SUM:16">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>i</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>j</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -(S[i]+S[j])
  </annotation>
 </semantics>
</math>

.</p>

<p>Alternatively, the algorithm below first sorts the input array and then tests all possible pairs in a careful order that avoids the need to <a href="binary_search" title="wikilink">binary search</a> for the pairs in the sorted list, achieving worst-case 

<math display="inline" id="3SUM:17">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2})
  </annotation>
 </semantics>
</math>

 time, as follows.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p><code> sort(S);</code><br/>
<code> </code><strong><code>for</code></strong><code> i=0 </code><strong><code>to</code></strong><code> n-3 </code><strong><code>do</code></strong><br/>
<code>    a = S[i];</code><br/>
<code>    start = i+1;</code><br/>
<code>    end = n-1;</code><br/>
<code>    </code><strong><code>while</code></strong><code> (start </code><code> 0) </code><strong><code>then</code></strong><br/>
<code>          end = end - 1;</code><br/>
<code>       </code><strong><code>else</code></strong><br/>
<code>          start = start + 1;</code><br/>
<code>       </code><strong><code>end</code></strong><br/>
<code>    </code><strong><code>end</code></strong><br/>
<code> </code><strong><code>end</code></strong></p>

<p>The following example shows this algorithm's execution on a small sorted array. Current values of <strong>a</strong> are shown in green, values of <strong>b</strong> and <strong>c</strong> are shown in red.</p>

<p><code> </code><span style="color:green"><code>-25</code></span><code> </code><span style="color:red"><code>-10</code></span><code> -7 -3 2 4 8 </code><span style="color:red"><code>10</code></span><code>  (a+b+c==-25)</code><br/>
<code> </code><span style="color:green"><code>-25</code></span><code> -10 </code><span style="color:red"><code>-7</code></span><code> -3 2 4 8 </code><span style="color:red"><code>10</code></span><code>  (a+b+c==-22)</code><br/>
<code> . . .</code><br/>
<code> </code><span style="color:green"><code>-25</code></span><code> -10 -7 -3 2 4 </code><span style="color:red"><code>8</code></span><code> </code><span style="color:red"><code>10</code></span><code>  (a+b+c==-7)</code><br/>
<code> -25 </code><span style="color:green"><code>-10</code></span><code> </code><span style="color:red"><code>-7</code></span><code> -3 2 4 8 </code><span style="color:red"><code>10</code></span><code>  (a+b+c==-7)</code><br/>
<code> -25 </code><span style="color:green"><code>-10</code></span><code> -7 </code><span style="color:red"><code>-3</code></span><code> 2 4 8 </code><span style="color:red"><code>10</code></span><code>  (a+b+c==-3)</code><br/>
<code> -25 </code><span style="color:green"><code>-10</code></span><code> -7 -3 </code><span style="color:red"><code>2</code></span><code> 4 8 </code><span style="color:red"><code>10</code></span><code>  (a+b+c==2)</code><br/>
<code> -25 </code><span style="color:green"><code>-10</code></span><code> -7 -3 </code><span style="color:red"><code>2</code></span><code> 4 </code><span style="color:red"><code>8</code></span><code> 10  (a+b+c==0)</code></p>

<p>The correctness of the algorithm can be seen as follows. Suppose we have a solution a + b + c = 0. Since the pointers only move in one direction, we can run the algorithm until the leftmost pointer points to a. Run the algorithm until either one of the remaining pointers points to b or c, whichever occurs first. Then the algorithm will run until the last pointer points to the remaining term, giving the affirmative solution.</p>
<h2 id="variants">Variants</h2>
<h3 id="non-zero-sum">Non-zero sum</h3>

<p>Instead of looking for numbers whose sum is 0, it is possible to look for numbers whose sum is any constant <em>C</em> in the following way:</p>
<ul>
<li>Subtract <em>C</em>/3 from all elements of the input array.</li>
<li>In the modified array, find 3 elements whose sum is 0.</li>
</ul>

<p>=== a+b=c === Instead of requiring <em>a+b+c=0</em>, we can find numbers that satisfy <em>a+b=c</em> in the following way (assuming all elements are integers):</p>
<ul>
<li>Create a copy of the original array where each element <em>x</em> becomes 10<em>x</em>+1.</li>
<li>Create a copy of the original array where each <em>x</em> becomes -10<em>x</em>-2.</li>
<li>In the concatenation of these two arrays, find 3 elements whose sum is 0.</li>
</ul>

<p>Correctness proof:</p>
<ul>
<li>If in the original array there are elements for which <em>a+b=c</em>, then the algorithm will find (10<em>a</em>+1), (10<em>b</em>+1) and (-10<em>c</em>-2), whose sum is 0.</li>
<li>Conversely, any triple found by the algorithm must have exactly two elements from the first copy (10<em>a</em>+1), (10<em>b</em>+1), and a single element from the second copy (-10<em>c</em>-2), since other combinations cannot have a sum of 0. Hence, any triple found will necessarily match an <em>a+b=c</em> triple in the original array</li>
</ul>

<p>In a very similar way, a solver for <em>a+b=c</em> can be used to solve <em>a+b+c=0</em>.</p>
<h3 id="different-arrays">3 different arrays</h3>

<p>Instead of searching for the 3 numbers in a single array, we can search for them in 3 different arrays. I.e., given three arrays X, Y and Z, find three numbers 

<math display="inline" id="3SUM:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mi mathvariant="normal">∈</mi>
    <mi>X</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>b</mi>
    <mi mathvariant="normal">∈</mi>
    <mi>Y</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>c</mi>
    <mi mathvariant="normal">∈</mi>
    <mi>Z</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>normal-∈</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <ci>b</ci>
     <ci>normal-∈</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>normal-∈</ci>
     <ci>Z</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a∈X,b∈Y,c∈Z
  </annotation>
 </semantics>
</math>

, such that 

<math display="inline" id="3SUM:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>+</mo>
    <mi>b</mi>
    <mo>+</mo>
    <mi>c</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <ci>a</ci>
     <ci>b</ci>
     <ci>c</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a+b+c=0
  </annotation>
 </semantics>
</math>

. Call the 1-array variant 3SUMx1 and the 3-array variant 3SUMx3.</p>

<p>Given a solver for 3SUMx1, the 3SUMx3 problem can be solved in the following way (assuming all elements are integers):</p>
<ul>
<li>For every element in X, set: 

<math display="inline" id="3SUM:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>X</mi>
     <mi>i</mi>
     <mi>i</mi>
     <mi mathvariant="normal">←</mi>
     <mi>X</mi>
     <mi>X</mi>
     <mi>i</mi>
     <mi>i</mi>
    </mrow>
    <mo>*</mo>
    <mn>10</mn>
   </mrow>
   <mo>+</mo>
   <mn>11</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>i</ci>
      <ci>i</ci>
      <ci>normal-←</ci>
      <ci>X</ci>
      <ci>X</ci>
      <ci>i</ci>
      <ci>i</ci>
     </apply>
     <cn type="integer">10</cn>
    </apply>
    <cn type="integer">11</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Xii←XXii*10+11
  </annotation>
 </semantics>
</math>

.</li>
<li>For every element in Y, set: 

<math display="inline" id="3SUM:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Y</mi>
     <mi>i</mi>
     <mi>i</mi>
     <mi mathvariant="normal">←</mi>
     <mi>Y</mi>
     <mi>Y</mi>
     <mi>i</mi>
     <mi>i</mi>
    </mrow>
    <mo>*</mo>
    <mn>10</mn>
   </mrow>
   <mo>+</mo>
   <mn>22</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>Y</ci>
      <ci>i</ci>
      <ci>i</ci>
      <ci>normal-←</ci>
      <ci>Y</ci>
      <ci>Y</ci>
      <ci>i</ci>
      <ci>i</ci>
     </apply>
     <cn type="integer">10</cn>
    </apply>
    <cn type="integer">22</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Yii←YYii*10+22
  </annotation>
 </semantics>
</math>

.</li>
<li>For every element in Z, set: 

<math display="inline" id="3SUM:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Z</mi>
     <mi>i</mi>
     <mi>i</mi>
     <mi mathvariant="normal">←</mi>
     <mi>Z</mi>
     <mi>Z</mi>
     <mi>i</mi>
     <mi>i</mi>
    </mrow>
    <mo>*</mo>
    <mn>10</mn>
   </mrow>
   <mo>-</mo>
   <mn>33</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>Z</ci>
      <ci>i</ci>
      <ci>i</ci>
      <ci>normal-←</ci>
      <ci>Z</ci>
      <ci>Z</ci>
      <ci>i</ci>
      <ci>i</ci>
     </apply>
     <cn type="integer">10</cn>
    </apply>
    <cn type="integer">33</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Zii←ZZii*10-33
  </annotation>
 </semantics>
</math>

.</li>
<li>Let S be a concatenation of the arrays X, Y and Z.</li>
<li>Use the 3SUMx1 oracle to find three elements 

<math display="inline" id="3SUM:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mi mathvariant="normal">∈</mi>
    <mi>S</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>b</mi>
    <mi>b</mi>
    <mi mathvariant="normal">∈</mi>
    <mi>S</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>c</mi>
    <mi>c</mi>
    <mi mathvariant="normal">∈</mi>
    <mi>S</mi>
    <mi>S</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>normal-∈</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <times></times>
     <ci>b</ci>
     <ci>b</ci>
     <ci>normal-∈</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>c</ci>
     <ci>normal-∈</ci>
     <ci>S</ci>
     <ci>S</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a∈S,bb∈S,cc∈SS
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="3SUM:24">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>+</mo>
   <mi>b</mi>
   <mi>b</mi>
   <mo>+</mo>
   <mi>c</mi>
   <mi>c</mi>
   <mo>=</mo>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <plus></plus>
    <csymbol cd="unknown">b</csymbol>
    <csymbol cd="unknown">b</csymbol>
    <plus></plus>
    <csymbol cd="unknown">c</csymbol>
    <csymbol cd="unknown">c</csymbol>
    <eq></eq>
    <eq></eq>
    <cn type="integer">0</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a+bb+cc==0
  </annotation>
 </semantics>
</math>

.</li>
<li>Because the LSD (least significant digit) of the sum is 0, the LSDs of a', b' and c' must be 1, 2 and 7 (in any order). Suppose wlog that the LSD of a' is 1, b' is 2 and c' is 7.</li>
<li>Return 

<math display="inline" id="3SUM:25">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mi mathvariant="normal">←</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>a</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mn>10</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>b</mi>
     <mi mathvariant="normal">←</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>b</mi>
        <mi>b</mi>
       </mrow>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mn>10</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>c</mi>
     <mi mathvariant="normal">←</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>c</mi>
        <mi>c</mi>
       </mrow>
       <mo>+</mo>
       <mn>3</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mn>100</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>normal-←</ci>
      <apply>
       <minus></minus>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cn type="integer">10</cn>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>b</ci>
      <ci>normal-←</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>b</ci>
        <ci>b</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <cn type="integer">10</cn>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>normal-←</ci>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>c</ci>
        <ci>c</ci>
       </apply>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <cn type="integer">100</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a←(a-1)/10,b←(bb-2)/10,c←(cc+3)/100
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>By the way we transformed the arrays, it is guaranteed that 

<math display="inline" id="3SUM:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mi mathvariant="normal">∈</mi>
    <mi>X</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>b</mi>
    <mi mathvariant="normal">∈</mi>
    <mi>Y</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>c</mi>
    <mi mathvariant="normal">∈</mi>
    <mi>Z</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>normal-∈</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <ci>b</ci>
     <ci>normal-∈</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>normal-∈</ci>
     <ci>Z</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a∈X,b∈Y,c∈Z
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h3 id="convolution-sum">Convolution sum</h3>

<p>Instead of looking for arbitrary elements of the array such that:</p>

<p>

<math display="block" id="3SUM:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>k</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>i</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>j</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S[k]=S[i]+S[j]
  </annotation>
 </semantics>
</math>

 the <em>convolution 3sum</em> problem (Conv3SUM) looks for elements in specific locations:<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>

<math display="block" id="3SUM:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mi>j</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>i</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>j</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S[i+j]=S[i]+S[j]
  </annotation>
 </semantics>
</math>

</p>
<h4 id="reduction-from-conv3sum-to-3sum">Reduction from Conv3SUM to 3SUM</h4>

<p>Given a solver for 3SUM, the Conv3SUM problem can be solved in the following way.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<ul>
<li>Define a new array <em>T</em>, such that for every index <em>i</em>

<math display="block" id="3SUM:29">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>i</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>n</mi>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>i</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi>i</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>n</ci>
      <ci>S</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>i</ci>
      </apply>
     </apply>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T[i]=2nS[i]+i
  </annotation>
 </semantics>
</math>

 (where <em>n</em> is the number of elements in the array, and the indices run from 0 to <em>n</em>-1).</li>
<li>Solve 3SUM on the array <em>T</em>.</li>
</ul>

<p>Correctness proof:</p>
<ul>
<li>If in the original array there is a triple with 

<math display="inline" id="3SUM:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mi>j</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>i</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>j</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S[i+j]=S[i]+S[j]
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="3SUM:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mi>j</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>n</mi>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mi>j</mi>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi>i</mi>
    <mo>+</mo>
    <mi>j</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mn>2</mn>
       <mi>n</mi>
       <mi>S</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>i</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mi>i</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mn>2</mn>
       <mi>n</mi>
       <mi>S</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>j</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mi>j</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>i</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>j</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>T</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>n</ci>
       <ci>S</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <plus></plus>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>n</ci>
        <ci>S</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>i</ci>
        </apply>
       </apply>
       <ci>i</ci>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>n</ci>
        <ci>S</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>T</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>T</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T[i+j]=2nS[i+j]+i+j=(2nS[i]+i)+(2nS[j]+j)=T[i]+T[j]
  </annotation>
 </semantics>
</math>

, so this solution will be found by 3SUM on <em>T</em>.</li>
<li>Conversely, if in the new array there is a triple with 

<math display="inline" id="3SUM:32">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>k</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>i</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>j</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>T</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>T</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T[k]=T[i]+T[j]
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="3SUM:33">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>n</mi>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>k</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi>k</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>S</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <mi>i</mi>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>S</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <mi>j</mi>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mi>j</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>n</ci>
      <ci>S</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>k</ci>
      </apply>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>n</ci>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>S</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>S</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2nS[k]+k=2n(S[i]+S[j])+(i+j)
  </annotation>
 </semantics>
</math>

. Because 

<math display="inline" id="3SUM:34">
 <semantics>
  <mrow>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
    <mi>j</mi>
   </mrow>
   <mo><</mo>
   <mrow>
    <mn>2</mn>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i+j<2n
  </annotation>
 </semantics>
</math>

, necessarily 

<math display="inline" id="3SUM:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>k</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>i</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>j</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S[k]=S[i]+S[j]
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="3SUM:36">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
    <mi>j</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=i+j
  </annotation>
 </semantics>
</math>

, so this is a valid solution for Conv3SUM on <em>S</em>.</li>
</ul>
<h4 id="reduction-from-3sum-to-conv3sum">Reduction from 3SUM to Conv3SUM</h4>

<p>Given a solver for Conv3SUM, the 3SUM problem can be solved in the following way.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>The reduction uses a <a href="hash_function" title="wikilink">hash function</a>. As a first approximation, assume that he have a linear hash function, i.e. a function <em>h</em> such that:</p>

<p>

<math display="block" id="3SUM:37">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>+</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x+y)=h(x)+h(y)
  </annotation>
 </semantics>
</math>

 Suppose that all elements are integers in the range: 0...<em>N</em>-1, and that the function <em>h</em> maps each element to an element in the smaller range of indices: 0...<em>n</em>-1. Create a new array <em>T</em> and send each element of <em>S</em> to its hash value in <em>T</em>, i.e., for every <em>x</em> in <em>S</em>:</p>

<p>

<math display="block" id="3SUM:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T[h(x)]=x
  </annotation>
 </semantics>
</math>

 Initially, suppose that the mappings are unique (i.e. each cell in <em>T</em> accepts only a single element from <em>S</em>). Solve Conv3SUM on <em>T</em>. Now:</p>
<ul>
<li>If there is a solution for 3SUM

<math display="block" id="3SUM:39">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mo>+</mo>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>z</ci>
    <apply>
     <plus></plus>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z=x+y
  </annotation>
 </semantics>
</math>

, then

<math display="block" id="3SUM:40">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>h</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>h</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>T</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>h</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>T</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>h</ci>
        <ci>y</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T[h(z)]=T[h(x)]+T[h(y)]
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="3SUM:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(z)=h(x)+h(y)
  </annotation>
 </semantics>
</math>

, so this solution will be found by the Conv3SUM solver on <em>T</em>.</li>
<li>Conversely, if a Conv3SUM is found on <em>T</em>, then obviously it corresponds to a 3SUM solution on <em>S</em> since <em>T</em> is just a permutation of <em>S</em>.</li>
</ul>

<p>This idealized solution doesn't work, because any hash function might map several distinct elements of <em>S</em> to the same cell of <em>T</em>. The trick is to create an array <em>T*</em> by selecting a single random element from each cell of <em>T</em>, and run Conv3SUM on <em>T*</em>. If a solution is found, then it is a correct solution for 3SUM on <em>S</em>. If no solution is found, then create a different random <em>T*</em> and try again. Suppose there are at most <em>R</em> elements in each cell of <em>T</em>. Then the probability of finding a solution (if a solution exists) is the probability that the random selection will select the correct element from each cell, which is 

<math display="inline" id="3SUM:42">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mi>R</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mn>3</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>R</ci>
    </apply>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1/R)^{3}
  </annotation>
 </semantics>
</math>

. By running Conv3SUM 

<math display="inline" id="3SUM:43">
 <semantics>
  <msup>
   <mi>R</mi>
   <mn>3</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>R</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{3}
  </annotation>
 </semantics>
</math>

 times, the solution will be found with a high probability.</p>

<p>Unfortunately, we do not have linear perfect hashing, so we have to use an <a href="almost_linear_hash_function" title="wikilink">almost linear hash function</a>, i.e. a function <em>h</em> such that:</p>

<p>

<math display="block" id="3SUM:44">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>+</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x+y)=h(x)+h(y)
  </annotation>
 </semantics>
</math>

 or</p>

<p>

<math display="block" id="3SUM:45">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>+</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>y</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x+y)=h(x)+h(y)+1
  </annotation>
 </semantics>
</math>

 This requires to duplicate the elements of <em>S</em> when copying them into <em>T</em>, i.e., put every element 

<math display="inline" id="3SUM:46">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in S
  </annotation>
 </semantics>
</math>

 both in 

<math display="inline" id="3SUM:47">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T[h(x)]
  </annotation>
 </semantics>
</math>

 (as before) and in 

<math display="inline" id="3SUM:48">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>T</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T[h(x)]-1
  </annotation>
 </semantics>
</math>

. So each cell will have 2<em>R</em> elements, and we will have to run Conv3SUM 

<math display="inline" id="3SUM:49">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>2</mn>
     <mi>R</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mn>3</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>R</ci>
    </apply>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (2R)^{3}
  </annotation>
 </semantics>
</math>

 times.</p>
<h2 id="sum-hardness">3SUM-hardness</h2>

<p>While 3SUM can easily be solved in quadratic time, 

<math display="inline" id="3SUM:50">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(n^{2})
  </annotation>
 </semantics>
</math>

, it was conjectured to be unsolvable in subquadratic expected time. This was known as the <em>3SUM Conjecture</em>.</p>

<p>A problem is called <strong>3SUM-hard</strong> if solving it in <a href="subquadratic_time" title="wikilink">subquadratic time</a> implies a subquadratic-time <a class="uri" href="algorithm" title="wikilink">algorithm</a> for 3SUM. The concept of 3SUM-hardness was introduced by  in <a href="analysis_of_algorithms" title="wikilink">analysis of algorithms</a> in <a href="computational_geometry" title="wikilink">computational geometry</a>, including problems like: Given a set of lines in the plane, are there three that meet in a point?; or: Given a set of triangles in the plane, does their union have a hole? Also certain visibility and motion planning problems were shown to be in the class.</p>

<p>By now there are a multitude of problems that fall into this category. An example is the decision version of <a href="X_+_Y_sorting" title="wikilink">X + Y sorting</a>: given sets of numbers 

<math display="inline" id="3SUM:51">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="3SUM:52">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="3SUM:53">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 elements each, are there 

<math display="inline" id="3SUM:54">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 distinct 

<math display="inline" id="3SUM:55">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>+</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x+y
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="3SUM:56">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mi mathvariant="normal">∈</mi>
    <mi>X</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>y</mi>
    <mi mathvariant="normal">∈</mi>
    <mi>Y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>normal-∈</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>normal-∈</ci>
     <ci>Y</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x∈X,y∈Y
  </annotation>
 </semantics>
</math>

?<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Subset_sum_problem" title="wikilink">Subset sum problem</a></li>
</ul>

<p>"</p>

<p><a href="Category:Computational_geometry" title="wikilink">Category:Computational geometry</a> <a href="Category:Polynomial-time_problems" title="wikilink">Category:Polynomial-time problems</a> <a href="Category:Unsolved_problems_in_computer_science" title="wikilink">Category:Unsolved problems in computer science</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"><a href="http://www.ti.inf.ethz.ch/ew/courses/CG09/materials/v12.pdf">Visibility Graphs and 3-Sum</a> by Michael Hoffmann<a href="#fnref3">↩</a></li>
<li id="fn4">For a reduction in the other direction, see <a href="http://cs.stackexchange.com/questions/37888/variants-of-the-3-sum-problem">Variants of the 3-sum problem</a>.<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
</ol>
</section>
</body>
</html>
