<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="696">Canonical normal form</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Canonical normal form</h1>
<hr/>

<p>In <a href="Boolean_algebra_(logic)" title="wikilink">Boolean algebra</a>, any <a href="Boolean_function" title="wikilink">Boolean function</a> can be put into the <strong>canonical disjunctive normal form</strong> (<strong>CDNF</strong>) or <strong>minterm canonical form</strong> and its dual <strong>canonical conjunctive normal form</strong> (<strong>CCNF</strong>) or <strong>maxterm canonical form</strong>. Other canonical forms include the complete sum of prime implicants or <a href="Blake_canonical_form" title="wikilink">Blake canonical form</a> (and its dual), and the <a href="algebraic_normal_form" title="wikilink">algebraic normal form</a> (also called Zhegalkin or Reed–Muller).</p>

<p><em>Minterms</em> are called products because they are the <a href="logical_AND" title="wikilink">logical AND</a> of a set of variables, and <em>maxterms</em> are called sums because they are the <a href="logical_OR" title="wikilink">logical OR</a> of a set of variables. These concepts are dual because of their complementary-symmetry relationship as expressed by <a href="De_Morgan's_laws" title="wikilink">De Morgan's laws</a>.</p>

<p>Two dual canonical forms of <em>any</em> Boolean function are a "sum of minterms" and a "product of maxterms." The term "<strong>Sum of Products</strong>" or "<strong>SoP</strong>" is widely used for the canonical form that is a disjunction (OR) of minterms. Its <a href="De_Morgan_dual" title="wikilink">De Morgan dual</a> is a "<strong>Product of Sums</strong>" or "<strong>PoS</strong>" for the canonical form that is a conjunction (AND) of maxterms. These forms can be useful for the simplification of these functions, which is of great importance in the minimization or other optimization of Boolean formulas in general and digital circuits in particular.</p>
<h2 id="summary">Summary</h2>

<p>One application of Boolean algebra is digital circuit design. The goal may be to minimize the number of gates, to minimize the settling time, etc.</p>

<p>There are sixteen possible functions of two variables, but in digital logic hardware, the simplest gate circuits implement only four of them: <em><a href="logical_conjunction" title="wikilink">conjunction</a></em> (AND), <em><a href="logical_disjunction" title="wikilink">disjunction</a></em> (inclusive OR), and the complements of those (NAND and NOR).</p>

<p>Most gate circuits accept more than 2 input variables; for example, the spaceborne <a href="Apollo_Guidance_Computer" title="wikilink">Apollo Guidance Computer</a>, which pioneered the application of integrated circuits in the 1960s, was built with only one type of gate, a 3-input NOR, whose output is true only when all 3 inputs are false.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="minterms">Minterms</h2>

<p>For a <a href="boolean_function" title="wikilink">boolean function</a> of 

<math display="inline" id="Canonical_normal_form:0">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 variables 

<math display="inline" id="Canonical_normal_form:1">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x_{1},\dots,x_{n}}
  </annotation>
 </semantics>
</math>

, a <a href="product_term" title="wikilink">product term</a> in which each of the 

<math display="inline" id="Canonical_normal_form:2">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 variables appears <strong>once</strong> (in either its complemented or uncomplemented form) is called a <em>minterm</em>. Thus, a <em>minterm</em> is a logical expression of <em>n</em> variables that employs only the <em>complement</em> operator and the <em>conjunction</em> operator.</p>

<p>For example, 

<math display="inline" id="Canonical_normal_form:3">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi>b</mi>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>b</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   abc
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Canonical_normal_form:4">
 <semantics>
  <mrow>
   <mi>a</mi>
   <msup>
    <mi>b</mi>
    <mo>′</mo>
   </msup>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>b</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ab^{\prime}c
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Canonical_normal_form:5">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi>b</mi>
   <msup>
    <mi>c</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>b</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>c</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   abc^{\prime}
  </annotation>
 </semantics>
</math>

 are 3 examples of the 8 minterms for a Boolean function of the three variables 

<math display="inline" id="Canonical_normal_form:6">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Canonical_normal_form:7">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Canonical_normal_form:8">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

. The customary reading of the last of these is <em>a AND b AND NOT-c</em>.</p>

<p>There are 2<sup><em>n</em></sup> minterms of <em>n</em> variables, since a variable in the minterm expression can be in either its direct or its complemented form—two choices per <em>n</em> variables.</p>
<h3 id="indexing-minterms">Indexing minterms</h3>

<p>Minterms are often numbered by a binary encoding of the complementation pattern of the variables, where the variables are written in a standard order, usually alphabetical. This convention assigns the value 1 to the direct form (

<math display="inline" id="Canonical_normal_form:9">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

) and 0 to the complemented form (

<math display="inline" id="Canonical_normal_form:10">
 <semantics>
  <msubsup>
   <mi>x</mi>
   <mi>i</mi>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{\prime}_{i}
  </annotation>
 </semantics>
</math>

); the minterm is then the sum of 

<math display="inline" id="Canonical_normal_form:11">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mi>i</mi>
   </msup>
   <mrow>
    <mo>value</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <ci>value</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{i}\operatorname{value}(x_{i})
  </annotation>
 </semantics>
</math>

. For example, minterm 

<math display="inline" id="Canonical_normal_form:12">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi>b</mi>
   <msup>
    <mi>c</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>b</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>c</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   abc^{\prime}
  </annotation>
 </semantics>
</math>

 is numbered 110<sub>2</sub> = 6<sub>10</sub> and denoted 

<math display="inline" id="Canonical_normal_form:13">
 <semantics>
  <msub>
   <mi>m</mi>
   <mn>6</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <cn type="integer">6</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{6}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="functional-equivalence">Functional equivalence</h3>

<p>A given minterm <em>n</em> gives a true value (i.e., 1) for just one combination of the input variables. For example, minterm 5, <em>a</em> <em>b</em>' <em>c</em>, is true only when <em>a</em> and <em>c</em> both are true and <em>b</em> is false—the input arrangement where <em>a</em> = 1, <em>b</em> = 0, <em>c</em> = 1 results in 1.</p>

<p>Given the <a href="truth_table" title="wikilink">truth table</a> of a logical function, it is possible to write the function as a "sum of products". This is a special form of <a href="disjunctive_normal_form" title="wikilink">disjunctive normal form</a>. For example, if given the truth table for the arithmetic sum bit <em>u</em> of one bit position's logic of an adder circuit, as a function of <em>x</em> and <em>y</em> from the addends and the carry in, <em>ci</em>:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>ci</p></th>
<th style="text-align: left;">
<p>x</p></th>
<th style="text-align: left;">
<p>y</p></th>
<th style="text-align: left;">
<p>u(ci,x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
</tbody>
</table>

<p>Observing that the rows that have an output of 1 are the 2nd, 3rd, 5th, and 8th, we can write <em>u</em> as a sum of minterms 

<math display="inline" id="Canonical_normal_form:14">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>m</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>m</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>m</mi>
     <mn>4</mn>
    </msub>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">4</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{1},m_{2},m_{4},
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Canonical_normal_form:15">
 <semantics>
  <msub>
   <mi>m</mi>
   <mn>7</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <cn type="integer">7</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{7}
  </annotation>
 </semantics>
</math>

. If we wish to verify this

<math display="block" id="Canonical_normal_form:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>c</mi>
      <mi>i</mi>
     </mrow>
     <mo>,</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>m</mi>
     <mn>1</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>m</mi>
     <mn>2</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>m</mi>
     <mn>4</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>m</mi>
     <mn>7</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>c</mi>
      <msup>
       <mi>i</mi>
       <mo>′</mo>
      </msup>
     </mrow>
     <mo>,</mo>
     <msup>
      <mi>x</mi>
      <mo>′</mo>
     </msup>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>c</mi>
      <msup>
       <mi>i</mi>
       <mo>′</mo>
      </msup>
     </mrow>
     <mo>,</mo>
     <mi>x</mi>
     <mo>,</mo>
     <msup>
      <mi>y</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>c</mi>
      <mi>i</mi>
     </mrow>
     <mo>,</mo>
     <msup>
      <mi>x</mi>
      <mo>′</mo>
     </msup>
     <mo>,</mo>
     <msup>
      <mi>y</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>c</mi>
      <mi>i</mi>
     </mrow>
     <mo>,</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>u</ci>
      <vector>
       <apply>
        <times></times>
        <ci>c</ci>
        <ci>i</ci>
       </apply>
       <ci>x</ci>
       <ci>y</ci>
      </vector>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">4</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">7</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <vector>
       <apply>
        <times></times>
        <ci>c</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>i</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>y</ci>
      </vector>
      <vector>
       <apply>
        <times></times>
        <ci>c</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>i</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <ci>normal-′</ci>
       </apply>
      </vector>
      <vector>
       <apply>
        <times></times>
        <ci>c</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <ci>normal-′</ci>
       </apply>
      </vector>
      <vector>
       <apply>
        <times></times>
        <ci>c</ci>
        <ci>i</ci>
       </apply>
       <ci>x</ci>
       <ci>y</ci>
      </vector>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(ci,x,y)=m_{1}+m_{2}+m_{4}+m_{7}=(ci^{\prime},x^{\prime},y)+(ci^{\prime},x,y^%
{\prime})+(ci,x^{\prime},y^{\prime})+(ci,x,y)
  </annotation>
 </semantics>
</math>

 evaluated for all 8 combinations of the three variables will match the table.</p>
<h2 id="maxterms">Maxterms</h2>

<p>For a <a href="boolean_function" title="wikilink">boolean function</a> of 

<math display="inline" id="Canonical_normal_form:17">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 variables 

<math display="inline" id="Canonical_normal_form:18">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x_{1},\dots,x_{n}}
  </annotation>
 </semantics>
</math>

, a sum term in which each of the 

<math display="inline" id="Canonical_normal_form:19">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 variables appears <strong>once</strong> (in either its complemented or uncomplemented form) is called a <em>maxterm</em>. Thus, a <em>maxterm</em> is a logical expression of <em>n</em> variables that employs only the <em>complement</em> operator and the <em>disjunction</em> operator. Maxterms are a dual of the minterm idea (i.e., exhibiting a complementary symmetry in all respects). Instead of using ANDs and complements, we use ORs and complements and proceed similarly.</p>

<p>For example, the following are two of the eight maxterms of three variables:</p>
<dl>
<dd><em>a</em> + <em>b</em>' + <em>c</em>
</dd>
<dd><em>a</em>' + <em>b</em> + <em>c</em>
</dd>
</dl>

<p>There are again 2<sup><em>n</em></sup> maxterms of <em>n</em> variables, since a variable in the maxterm expression can also be in either its direct or its complemented form—two choices per <em>n</em> variables.</p>
<h3 id="indexing-maxterms">Indexing maxterms</h3>

<p>Each maxterm is assigned an index based on the opposite conventional binary encoding used for minterms. The maxterm convention assigns the value 0 to the direct form 

<math display="inline" id="Canonical_normal_form:20">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{i})
  </annotation>
 </semantics>
</math>

 and 1 to the complemented form 

<math display="inline" id="Canonical_normal_form:21">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msubsup>
    <mi>x</mi>
    <mi>i</mi>
    <mo>′</mo>
   </msubsup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x^{\prime}_{i})
  </annotation>
 </semantics>
</math>

. For example, we assign the index 6 to the maxterm 

<math display="inline" id="Canonical_normal_form:22">
 <semantics>
  <mrow>
   <msup>
    <mi>a</mi>
    <mo>′</mo>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>b</mi>
    <mo>′</mo>
   </msup>
   <mo>+</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>b</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{\prime}+b^{\prime}+c
  </annotation>
 </semantics>
</math>

 (110) and denote that maxterm as <em>M</em><sub>6</sub>. Similarly <em>M</em><sub>0</sub> of these three variables is 

<math display="inline" id="Canonical_normal_form:23">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>+</mo>
   <mi>b</mi>
   <mo>+</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>a</ci>
    <ci>b</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a+b+c
  </annotation>
 </semantics>
</math>

 (000) and <em>M</em><sub>7</sub> is 

<math display="inline" id="Canonical_normal_form:24">
 <semantics>
  <mrow>
   <msup>
    <mi>a</mi>
    <mo>′</mo>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>b</mi>
    <mo>′</mo>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>c</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>b</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>c</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{\prime}+b^{\prime}+c^{\prime}
  </annotation>
 </semantics>
</math>

 (111).</p>
<h3 id="functional-equivalence-1">Functional equivalence</h3>

<p>It is apparent that maxterm <em>n</em> gives a <em>false</em> value (i.e., 0) for just one combination of the input variables. For example, maxterm 5, <em>a</em>' + <em>b</em> + <em>c</em>', is false only when <em>a</em> and <em>c</em> both are true and <em>b</em> is false—the input arrangement where a = 1, b = 0, c = 1 results in 0.</p>

<p>If one is given a <a href="truth_table" title="wikilink">truth table</a> of a logical function, it is possible to write the function as a "product of sums". This is a special form of <a href="conjunctive_normal_form" title="wikilink">conjunctive normal form</a>. For example, if given the truth table for the carry-out bit <em>co</em> of one bit position's logic of an adder circuit, as a function of <em>x</em> and <em>y</em> from the addends and the carry in, <em>ci</em>:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>ci</p></th>
<th style="text-align: left;">
<p>x</p></th>
<th style="text-align: left;">
<p>y</p></th>
<th style="text-align: left;">
<p>co(ci,x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
</tbody>
</table>

<p>Observing that the rows that have an output of 0 are the 1st, 2nd, 3rd, and 5th, we can write <em>co</em> as a product of maxterms 

<math display="inline" id="Canonical_normal_form:25">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>M</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>M</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>M</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{0},M_{1},M_{2},
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Canonical_normal_form:26">
 <semantics>
  <msub>
   <mi>M</mi>
   <mn>4</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{4}
  </annotation>
 </semantics>
</math>

. If we wish to verify this: <em>co</em>(<em>ci, x, y</em>) = 

<math display="inline" id="Canonical_normal_form:27">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mn>0</mn>
   </msub>
   <msub>
    <mi>M</mi>
    <mn>1</mn>
   </msub>
   <msub>
    <mi>M</mi>
    <mn>2</mn>
   </msub>
   <msub>
    <mi>M</mi>
    <mn>4</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{0}M_{1}M_{2}M_{4}
  </annotation>
 </semantics>
</math>

 = (<em>ci + x + y</em>) (<em>ci + x + y</em>') (<em>ci + x' + y</em>) (<em>ci' + x + y</em>) evaluated for all 8 combinations of the three variables will match the table.</p>
<h2 id="dualization">Dualization</h2>

<p>The complement of a minterm is the respective maxterm. This can be easily verified by using <a href="de_Morgan's_law" title="wikilink">de Morgan's law</a>. For example: 

<math display="inline" id="Canonical_normal_form:28">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mn>5</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>a</mi>
     <mo>′</mo>
    </msup>
    <mo>+</mo>
    <mi>b</mi>
    <mo>+</mo>
    <msup>
     <mi>c</mi>
     <mo>′</mo>
    </msup>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <msup>
       <mi>b</mi>
       <mo>′</mo>
      </msup>
      <mi>c</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <msubsup>
    <mi>m</mi>
    <mn>5</mn>
    <mo>′</mo>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">5</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>b</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>c</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <ci>a</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>b</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>c</ci>
      </apply>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">5</cn>
      </apply>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{5}=a^{\prime}+b+c^{\prime}=(ab^{\prime}c)^{\prime}=m_{5}^{\prime}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="non-canonical-pos-and-sop-forms">Non-canonical PoS and SoP forms</h2>

<p>It is often the case that the canonical minterm form can be simplified to an equivalent SoP form. This simplified form would still consist of a sum of product terms. However, in the simplified form, it is possible to have fewer product terms and/or product terms that contain fewer variables. For example, the following 3-variable function:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>a</p></th>
<th style="text-align: left;">
<p>b</p></th>
<th style="text-align: left;">
<p>c</p></th>
<th style="text-align: left;">
<p>f(a,b,c)</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
</tbody>
</table>

<p>has the canonical minterm representation: 

<math display="inline" id="Canonical_normal_form:29">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>a</mi>
      <mo>′</mo>
     </msup>
     <mi>b</mi>
     <mi>c</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
     <mi>c</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>f</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>b</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f=a^{\prime}bc+abc
  </annotation>
 </semantics>
</math>

, but it has an equivalent simplified form: 

<math display="inline" id="Canonical_normal_form:30">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>=</mo>
   <mrow>
    <mi>b</mi>
    <mi>c</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>f</ci>
    <apply>
     <times></times>
     <ci>b</ci>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f=bc
  </annotation>
 </semantics>
</math>

. In this trivial example, it is obvious that 

<math display="inline" id="Canonical_normal_form:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>b</mi>
    <mi>c</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>a</mi>
      <mo>′</mo>
     </msup>
     <mi>b</mi>
     <mi>c</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
     <mi>c</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>b</ci>
     <ci>c</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>b</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   bc=a^{\prime}bc+abc
  </annotation>
 </semantics>
</math>

, but the simplified form has both fewer product terms, and the term has fewer variables. The most simplified SoP representation of a function is referred to as a <em>minimal SoP form</em>.</p>

<p>In a similar manner, a canonical maxterm form can have a simplified PoS form.</p>

<p>While this example was easily simplified by applying normal algebraic methods [

<math display="inline" id="Canonical_normal_form:32">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>a</mi>
       <mo>′</mo>
      </msup>
      <mo>+</mo>
      <mi>a</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>b</mi>
    <mi>c</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>f</ci>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>a</ci>
     </apply>
     <ci>b</ci>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f=(a^{\prime}+a)bc
  </annotation>
 </semantics>
</math>

], in less obvious cases a convenient method for finding the minimal PoS/SoP form of a function with up to four variables is using a <a href="Karnaugh_map" title="wikilink">Karnaugh map</a>.</p>

<p>The minimal PoS and SoP forms are very important for finding optimal implementations of boolean functions and minimizing logic circuits.</p>
<h2 id="application-example">Application example</h2>

<p>The sample truth tables for minterms and maxterms above are sufficient to establish the canonical form for a single bit position in the addition of binary numbers, but are not sufficient to design the digital logic unless your inventory of gates includes AND and OR. Where performance is an issue (as in the Apollo Guidance Computer), the available parts are more likely to be NAND and NOR because of the complementing action inherent in transistor logic. The values are defined as voltage states, one near ground and one near the DC supply voltage V<sub>cc</sub>, e.g. +5 VDC. If the higher voltage is defined as the 1 "true" value, a NOR gate is the simplest possible useful logical element.</p>

<p>Specifically, a 3-input NOR gate may consist of 3 bipolar junction transistors with their emitters all grounded, their collectors tied together and linked to V<sub>cc</sub> through a load impedance. Each base is connected to an input signal, and the common collector point presents the output signal. Any input that is a 1 (high voltage) to its base shorts its transistor's emitter to its collector, causing current to flow through the load impedance, which brings the collector voltage (the output) very near to ground. That result is independent of the other inputs. Only when all 3 input signals are 0 (low voltage) do the emitter-collector impedances of all 3 transistors remain very high. Then very little current flows, and the voltage-divider effect with the load impedance imposes on the collector point a high voltage very near to V<sub>cc</sub>.</p>

<p>The complementing property of these gate circuits may seem like a drawback when trying to implement a function in canonical form, but there is a compensating bonus: such a gate with only one input implements the complementing function, which is required frequently in digital logic.</p>

<p>This example assumes the Apollo parts inventory: 3-input NOR gates only, but the discussion is simplified by supposing that 4-input NOR gates are also available (in Apollo, those were compounded out of pairs of 3-input NORs).</p>
<h3 id="canonical-and-non-canonical-consequences-of-nor-gates">Canonical and non-canonical consequences of NOR gates</h3>

<p>Fact #1: a set of 8 NOR gates, if their inputs are all combinations of the direct and complement forms of the 3 input variables <em>ci, x,</em> and <em>y</em>, always produce minterms, never maxterms—that is, of the 8 gates required to process all combinations of 3 input variables, only one has the output value 1. That's because a NOR gate, despite its name, could better be viewed (using De Morgan's law) as the AND of the complements of its input signals.</p>

<p>Fact #2: the reason Fact #1 is not a problem is the duality of minterms and maxterms, i.e. each maxterm is the complement of the like-indexed minterm, and vice versa.</p>

<p>In the minterm example above, we wrote 

<math display="inline" id="Canonical_normal_form:33">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>c</mi>
      <mi>i</mi>
     </mrow>
     <mo>,</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>m</mi>
     <mn>1</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>m</mi>
     <mn>2</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>m</mi>
     <mn>4</mn>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>m</mi>
     <mn>7</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>u</ci>
     <vector>
      <apply>
       <times></times>
       <ci>c</ci>
       <ci>i</ci>
      </apply>
      <ci>x</ci>
      <ci>y</ci>
     </vector>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <cn type="integer">4</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <cn type="integer">7</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(ci,x,y)=m_{1}+m_{2}+m_{4}+m_{7}
  </annotation>
 </semantics>
</math>

 but to perform this with a 4-input NOR gate we need to restate it as a product of sums (PoS), where the sums are the opposite maxterms. That is,</p>

<p>

<math display="inline" id="Canonical_normal_form:34">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>c</mi>
     <mi>i</mi>
    </mrow>
    <mo>,</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>u</ci>
    <vector>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>i</ci>
     </apply>
     <ci>x</ci>
     <ci>y</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u(ci,x,y)
  </annotation>
 </semantics>
</math>

 = AND(

<math display="inline" id="Canonical_normal_form:35">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>M</mi>
    <mn>3</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>M</mi>
    <mn>5</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>M</mi>
    <mn>6</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">5</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">6</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{0},M_{3},M_{5},M_{6}
  </annotation>
 </semantics>
</math>

) = NOR(

<math display="inline" id="Canonical_normal_form:36">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>m</mi>
    <mn>3</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>m</mi>
    <mn>5</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>m</mi>
    <mn>6</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">5</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">6</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{0},m_{3},m_{5},m_{6}
  </annotation>
 </semantics>
</math>

). Truth tables:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>ci</p></th>
<th style="text-align: left;">
<p>x</p></th>
<th style="text-align: left;">
<p>y</p></th>
<th style="text-align: left;">
<p>M<sub>0</sub></p></th>
<th style="text-align: left;">
<p>M<sub>3</sub></p></th>
<th style="text-align: left;">
<p>M<sub>5</sub></p></th>
<th style="text-align: left;">
<p>M<sub>6</sub></p></th>
<th style="text-align: left;">
<p>AND</p></th>
<th style="text-align: left;">
<p>u(ci,x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
</tbody>
</table>

<p> </p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>ci</p></th>
<th style="text-align: left;">
<p>x</p></th>
<th style="text-align: left;">
<p>y</p></th>
<th style="text-align: left;">
<p>m<sub>0</sub></p></th>
<th style="text-align: left;">
<p>m<sub>3</sub></p></th>
<th style="text-align: left;">
<p>m<sub>5</sub></p></th>
<th style="text-align: left;">
<p>m<sub>6</sub></p></th>
<th style="text-align: left;">
<p>NOR</p></th>
<th style="text-align: left;">
<p>u(ci,x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
</tbody>
</table>

<p>In the maxterm example above, we wrote 

<math display="inline" id="Canonical_normal_form:37">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mi>o</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>c</mi>
      <mi>i</mi>
     </mrow>
     <mo>,</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>M</mi>
     <mn>0</mn>
    </msub>
    <msub>
     <mi>M</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>M</mi>
     <mn>2</mn>
    </msub>
    <msub>
     <mi>M</mi>
     <mn>4</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>o</ci>
     <vector>
      <apply>
       <times></times>
       <ci>c</ci>
       <ci>i</ci>
      </apply>
      <ci>x</ci>
      <ci>y</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   co(ci,x,y)=M_{0}M_{1}M_{2}M_{4}
  </annotation>
 </semantics>
</math>

 but to perform this with a 4-input NOR gate we need to notice the equality to the NOR of the same minterms. That is,</p>

<p>

<math display="inline" id="Canonical_normal_form:38">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>c</mi>
     <mi>i</mi>
    </mrow>
    <mo>,</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>c</ci>
    <ci>o</ci>
    <vector>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>i</ci>
     </apply>
     <ci>x</ci>
     <ci>y</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   co(ci,x,y)
  </annotation>
 </semantics>
</math>

 = AND(

<math display="inline" id="Canonical_normal_form:39">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>M</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>M</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>M</mi>
    <mn>4</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">4</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{0},M_{1},M_{2},M_{4}
  </annotation>
 </semantics>
</math>

) = NOR(

<math display="inline" id="Canonical_normal_form:40">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>m</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>m</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>m</mi>
    <mn>4</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">4</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{0},m_{1},m_{2},m_{4}
  </annotation>
 </semantics>
</math>

). Truth tables:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>ci</p></th>
<th style="text-align: left;">
<p>x</p></th>
<th style="text-align: left;">
<p>y</p></th>
<th style="text-align: left;">
<p>M<sub>0</sub></p></th>
<th style="text-align: left;">
<p>M<sub>1</sub></p></th>
<th style="text-align: left;">
<p>M<sub>2</sub></p></th>
<th style="text-align: left;">
<p>M<sub>4</sub></p></th>
<th style="text-align: left;">
<p>AND</p></th>
<th style="text-align: left;">
<p>co(ci,x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
</tbody>
</table>

<p> </p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>ci</p></th>
<th style="text-align: left;">
<p>x</p></th>
<th style="text-align: left;">
<p>y</p></th>
<th style="text-align: left;">
<p>m<sub>0</sub></p></th>
<th style="text-align: left;">
<p>m<sub>1</sub></p></th>
<th style="text-align: left;">
<p>m<sub>2</sub></p></th>
<th style="text-align: left;">
<p>m<sub>4</sub></p></th>
<th style="text-align: left;">
<p>NOR</p></th>
<th style="text-align: left;">
<p>co(ci,x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
</tbody>
</table>
<h3 id="design-trade-offs-considered-in-addition-to-canonical-forms">Design trade-offs considered in addition to canonical forms</h3>

<p>One might suppose that the work of designing an adder stage is now complete, but we haven't addressed the fact that all 3 of the input variables have to appear in both their direct and complement forms. There's no difficulty about the addends <em>x</em> and <em>y</em> in this respect, because they are static throughout the addition and thus are normally held in latch circuits that routinely have both direct and complement outputs. (The simplest latch circuit made of NOR gates is a pair of gates cross-coupled to make a flip-flop: the output of each is wired as one of the inputs to the other.) There is also no need to create the complement form of the sum <em>u</em>. However, the carry out of one bit position must be passed as the carry into the next bit position in both direct and complement forms. The most straightforward way to do this is to pass <em>co</em> through a 1-input NOR gate and label the output <em>co</em>', but that would add a gate delay in the worst possible place, slowing down the rippling of carries from right to left. An additional 4-input NOR gate building the canonical form of <em>co</em>' (out of the opposite minterms as <em>co</em>) solves this problem.</p>

<p>

<math display="block" id="Canonical_normal_form:41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>c</mi>
     <msup>
      <mi>o</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>c</mi>
       <mi>i</mi>
      </mrow>
      <mo>,</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>AND</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>M</mi>
       <mn>3</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>M</mi>
       <mn>5</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>M</mi>
       <mn>6</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>M</mi>
       <mn>7</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>NOR</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>m</mi>
       <mn>3</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>m</mi>
       <mn>5</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>m</mi>
       <mn>6</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>m</mi>
       <mn>7</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>c</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>o</ci>
       <ci>normal-′</ci>
      </apply>
      <vector>
       <apply>
        <times></times>
        <ci>c</ci>
        <ci>i</ci>
       </apply>
       <ci>x</ci>
       <ci>y</ci>
      </vector>
     </apply>
     <apply>
      <times></times>
      <ci>AND</ci>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <cn type="integer">5</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <cn type="integer">6</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <cn type="integer">7</cn>
       </apply>
      </vector>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>NOR</ci>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <cn type="integer">5</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <cn type="integer">6</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <cn type="integer">7</cn>
       </apply>
      </vector>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   co^{\prime}(ci,x,y)=\mathrm{AND}(M_{3},M_{5},M_{6},M_{7})=\mathrm{NOR}(m_{3},m%
_{5},m_{6},m_{7}).
  </annotation>
 </semantics>
</math>

</p>

<p>Truth tables:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>ci</p></th>
<th style="text-align: left;">
<p>x</p></th>
<th style="text-align: left;">
<p>y</p></th>
<th style="text-align: left;">
<p>M<sub>3</sub></p></th>
<th style="text-align: left;">
<p>M<sub>5</sub></p></th>
<th style="text-align: left;">
<p>M<sub>6</sub></p></th>
<th style="text-align: left;">
<p>M<sub>7</sub></p></th>
<th style="text-align: left;">
<p>AND</p></th>
<th style="text-align: left;">
<p>co'(ci,x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
</tbody>
</table>

<p> </p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>ci</p></th>
<th style="text-align: left;">
<p>x</p></th>
<th style="text-align: left;">
<p>y</p></th>
<th style="text-align: left;">
<p>m<sub>3</sub></p></th>
<th style="text-align: left;">
<p>m<sub>5</sub></p></th>
<th style="text-align: left;">
<p>m<sub>6</sub></p></th>
<th style="text-align: left;">
<p>m<sub>7</sub></p></th>
<th style="text-align: left;">
<p>NOR</p></th>
<th style="text-align: left;">
<p>co'(ci,x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
</tbody>
</table>

<p>The trade-off to maintain full speed in this way includes an unexpected cost (in addition to having to use a bigger gate). If we'd just used that 1-input gate to complement <em>co</em>, there would have been no use for the minterm 

<math display="inline" id="Canonical_normal_form:42">
 <semantics>
  <msub>
   <mi>m</mi>
   <mn>7</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <cn type="integer">7</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{7}
  </annotation>
 </semantics>
</math>

, and the gate that generated it could have been eliminated. Nevertheless, it's still a good trade.</p>

<p>Now we could have implemented those functions exactly according to their SoP and PoS canonical forms, by turning NOR gates into the functions specified. A NOR gate is made into an OR gate by passing its output through a 1-input NOR gate; and it is made into an AND gate by passing each of its inputs through a 1-input NOR gate. However, this approach not only increases the number of gates used, but also doubles the number of gate delays processing the signals, cutting the processing speed in half. Consequently, whenever performance is vital, going beyond canonical forms and doing the Boolean algebra to make the unenhanced NOR gates do the job is well worthwhile.</p>
<h3 id="top-down-vs.-bottom-up-design">Top-down vs. bottom-up design</h3>

<p>We have now seen how the minterm/maxterm tools can be used to design an adder stage in canonical form with the addition of some Boolean algebra, costing just 2 gate delays for each of the outputs. That's the "top-down" way to design the digital circuit for this function, but is it the best way? The discussion has focused on identifying "fastest" as "best," and the augmented canonical form meets that criterion flawlessly, but sometimes other factors predominate. The designer may have a primary goal of minimizing the number of gates, and/or of minimizing the fanouts of signals to other gates since big fanouts reduce resilience to a degraded power supply or other environmental factors. In such a case, a designer may develop the canonical-form design as a baseline, then try a bottom-up development, and finally compare the results.</p>

<p>The bottom-up development involves noticing that <em>u = ci</em> XOR (<em>x</em> XOR <em>y</em>), where XOR means eXclusive OR [true when either input is true but not when both are true], and that <em>co = ci x + x y + y ci</em>. One such development takes twelve NOR gates in all: six 2-input gates and two 1-input gates to produce <em>u</em> in 5 gate delays, plus three 2-input gates and one 3-input gate to produce <em>co</em>' in 2 gate delays. The canonical baseline took eight 3-input NOR gates plus three 4-input NOR gates to produce <em>u, co</em> and <em>co</em>' in 2 gate delays. If the circuit inventory actually includes 4-input NOR gates, the top-down canonical design looks like a winner in both gate count and speed. But if (contrary to our convenient supposition) the circuits are actually 3-input NOR gates, of which two are required for each 4-input NOR function, then the canonical design takes 14 gates compared to 12 for the bottom-up approach, but still produces the sum digit <em>u</em> considerably faster. The fanout comparison is tabulated as:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Variables</p></th>
<th style="text-align: left;">
<p>Top-down</p></th>
<th style="text-align: left;">
<p>Bottom-up</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>x</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>x'</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>3</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>y</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>y'</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>3</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>ci</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>ci'</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>3</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>M or m</p></td>
<td style="text-align: left;">
<p>4@1,4@2</p></td>
<td style="text-align: left;">
<p>N/A</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>x XOR y</p></td>
<td style="text-align: left;">
<p>N/A</p></td>
<td style="text-align: left;">
<p>2</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Misc</p></td>
<td style="text-align: left;">
<p>N/A</p></td>
<td style="text-align: left;">
<p>5@1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Max</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>3</p></td>
</tr>
</tbody>
</table>

<p>What's a decision-maker to do? An observant one will have noticed that the description of the bottom-up development mentions <em>co</em>' as an output but not <em>co</em>. Does that design simply never need the direct form of the carry out? Well, yes and no. At each stage, the calculation of <em>co</em>' depends only on <em>ci</em>', <em>x</em>' and <em>y</em>', which means that the carry propagation ripples along the bit positions just as fast as in the canonical design without ever developing <em>co</em>. The calculation of <em>u</em>, which does require <em>ci</em> to be made from <em>ci</em>' by a 1-input NOR, is slower but for any word length the design only pays that penalty once (when the leftmost sum digit is developed). That's because those calculations overlap, each in what amounts to its own little pipeline without affecting when the next bit position's sum bit can be calculated. And, to be sure, the <em>co</em>' out of the leftmost bit position will probably have to be complemented as part of the logic determining whether the addition overflowed. But using 3-input NOR gates, the bottom-up design is very nearly as fast for doing parallel addition on a non-trivial word length, cuts down on the gate count, and uses lower fanouts ... so it wins if gate count and/or fanout are paramount!</p>

<p>We'll leave the exact circuitry of the bottom-up design of which all these statements are true as an exercise for the interested reader, assisted by one more algebraic formula: <em>u = ci(x</em> XOR <em>y) + ci</em>'<em>(x</em> XOR <em>y)</em>'<em>]</em>'. Decoupling the carry propagation from the sum formation in this way is what elevates the performance of a <em>carry-lookahead adder</em> over that of a <em>ripple carry adder</em>.</p>

<p>To see how NOR gate logic was used in the Apollo Guidance Computer's ALU, visit <a class="uri" href="http://klabs.org/history/ech/agc_schematics/index.htm">http://klabs.org/history/ech/agc_schematics/index.htm</a>, select any of the 4-BIT MODULE entries in the Index to Drawings, and expand images as desired.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Algebraic_normal_form" title="wikilink">Algebraic normal form</a></li>
<li><a href="Canonical_form" title="wikilink">Canonical form</a></li>
<li><a href="Blake_canonical_form" title="wikilink">Blake canonical form</a></li>
<li><a href="List_of_Boolean_algebra_topics" title="wikilink">List of Boolean algebra topics</a></li>
</ul>
<h2 id="footnotes">Footnotes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li>Edward A. Bender, S. Gill Williamson, 2005, <em>A Short Course in Discrete Mathematics</em>, Dover Publications, Inc., Mineola, NY, ISBN 0-486-43946-1. The authors demonstrate a proof that any Boolean (logic) function can be expressed in either disjunctive or conjunctive normal form (cf pages 5–6); the proof simply proceeds by creating all 2<sup><em>N</em></sup> rows of <em>N</em> Boolean variables and demonstrates that each row ("minterm" or "maxterm") has a unique Boolean expression. Any Boolean function of the <em>N</em> variables can be derived from a composite of the rows whose minterm or maxterm are logical 1s ("trues").</li>
</ul>
<ul>
<li>E. J. McCluskey, 1965, <em>Introduction to the Theory of Switching Circuits</em>, McGraw–Hill Book Company, NY, Library of Congress Catalog Card Number 65-17394. Canonical expressions are defined and described on pages 78ff.</li>
</ul>
<ul>
<li>Fredrick J. Hill, and Gerald R. Peterson, 1974, <em>Introduction to Switching Theory and Logical Design, Second Edition</em>, John Wiley &amp; Sons, NY, ISBN 0-471-39882-9. Minterm and maxterm designation of functions appears on page 101ff.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="George_Boole" title="wikilink">George Boole</a>, 1848, "<a href="http://www.maths.tcd.ie/pub/HistMath/People/Boole/CalcLogic/CalcLogic.html">The Calculus of Logic,</a>" ''Cambridge and Dublin Mathematical Journal III: 183–98.</li>
</ul>

<p>"</p>

<p><a href="Category:Boolean_algebra" title="wikilink"> </a> <a class="uri" href="Category:Logic" title="wikilink">Category:Logic</a> <a href="Category:Algebraic_logic" title="wikilink">Category:Algebraic logic</a> <a href="Category:Articles_with_example_code" title="wikilink">Category:Articles with example code</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Eldon C. Hall, Journey to the Moon: The History of the Apollo Guidance Computer, AIAA 1996. ISBN 1-56347-185-X<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
