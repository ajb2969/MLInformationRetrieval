<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1615">Weak Hopf algebra</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Weak Hopf algebra</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <strong>weak bialgebras</strong> are a generalization of <a href="bialgebra" title="wikilink">bialgebras</a> that are both algebras and coalgebras but for which the compatibility conditions between the two structures have been "weakened". In the same spirit, <strong>weak Hopf algebras</strong> are weak bialgebras together with a linear map S satisfying specific conditions; they are generalizations of <a href="Hopf_algebras" title="wikilink">Hopf algebras</a>.</p>

<p>These objects were introduced by Böhm, Nill and Szlachányi. The first motivations for studying them came from <a href="quantum_field_theory" title="wikilink">quantum field theory</a> and <a href="operator_algebras" title="wikilink">operator algebras</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Weak Hopf algebras have quite interesting representation theory; in particular modules over a semisimple finite weak Hopf algebra is a <a href="fusion_category" title="wikilink">fusion category</a> (which is a <a href="monoidal_category" title="wikilink">monoidal category</a> with extra properties). It was also shown by Etingof, Nikshych and Ostrik that any fusion category is equivalent to a category of modules over a weak Hopf algebra.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="definition">Definition</h2>

<p>A <strong>weak bialgebra</strong> 

<math display="inline" id="Weak_Hopf_algebra:0">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>H</mi>
   <mo>,</mo>
   <mi>μ</mi>
   <mo>,</mo>
   <mi>η</mi>
   <mo>,</mo>
   <mi mathvariant="normal">Δ</mi>
   <mo>,</mo>
   <mi>ε</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>H</ci>
    <ci>μ</ci>
    <ci>η</ci>
    <ci>normal-Δ</ci>
    <ci>ε</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (H,\mu,\eta,\Delta,\varepsilon)
  </annotation>
 </semantics>
</math>

 over a field 

<math display="inline" id="Weak_Hopf_algebra:1">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is a <a href="vector_space" title="wikilink">vector space</a> 

<math display="inline" id="Weak_Hopf_algebra:2">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 such that</p>
<ul>
<li>

<math display="inline" id="Weak_Hopf_algebra:3">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>H</mi>
   <mo>,</mo>
   <mi>μ</mi>
   <mo>,</mo>
   <mi>η</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>H</ci>
    <ci>μ</ci>
    <ci>η</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (H,\mu,\eta)
  </annotation>
 </semantics>
</math>


 forms an associative <a class="uri" href="algebra" title="wikilink">algebra</a> with multiplication 

<math display="inline" id="Weak_Hopf_algebra:4">
 <semantics>
  <mrow>
   <mi>μ</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>H</mi>
     <mo>⊗</mo>
     <mi>H</mi>
    </mrow>
    <mo>→</mo>
    <mi>H</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>μ</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>H</ci>
      <ci>H</ci>
     </apply>
     <ci>H</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu:H\otimes H\rightarrow H
  </annotation>
 </semantics>
</math>

 and unit 

<math display="inline" id="Weak_Hopf_algebra:5">
 <semantics>
  <mrow>
   <mi>η</mi>
   <mo>:</mo>
   <mrow>
    <mi>k</mi>
    <mo>→</mo>
    <mi>H</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>η</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>k</ci>
     <ci>H</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta:k\rightarrow H
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Weak_Hopf_algebra:6">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>H</mi>
   <mo>,</mo>
   <mi mathvariant="normal">Δ</mi>
   <mo>,</mo>
   <mi>ε</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>H</ci>
    <ci>normal-Δ</ci>
    <ci>ε</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (H,\Delta,\varepsilon)
  </annotation>
 </semantics>
</math>

 forms a coassociative <a class="uri" href="coalgebra" title="wikilink">coalgebra</a> with comultiplication 

<math display="inline" id="Weak_Hopf_algebra:7">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mo>:</mo>
   <mrow>
    <mi>H</mi>
    <mo>→</mo>
    <mrow>
     <mi>H</mi>
     <mo>⊗</mo>
     <mi>H</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>normal-Δ</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>H</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>H</ci>
      <ci>H</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta:H\rightarrow H\otimes H
  </annotation>
 </semantics>
</math>

 and counit 

<math display="inline" id="Weak_Hopf_algebra:8">
 <semantics>
  <mrow>
   <mi>ε</mi>
   <mo>:</mo>
   <mrow>
    <mi>H</mi>
    <mo>→</mo>
    <mi>k</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>ε</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>H</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon:H\rightarrow k
  </annotation>
 </semantics>
</math>


,</li>
</ul>

<p>for which the following compatibility conditions hold :</p>
<ol>
<li>Multiplicativity of the Comultiplication :

<p>

<math display="block" id="Weak_Hopf_algebra:9">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mo>∘</mo>
    <mi>μ</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>μ</mi>
      <mo>⊗</mo>
      <mi>μ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>id</mi>
       <mi>H</mi>
      </msub>
      <mo>⊗</mo>
      <msub>
       <mi>σ</mi>
       <mrow>
        <mi>H</mi>
        <mo>,</mo>
        <mi>H</mi>
       </mrow>
      </msub>
      <mo>⊗</mo>
      <msub>
       <mi>id</mi>
       <mi>H</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mo>⊗</mo>
      <mi mathvariant="normal">Δ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <ci>normal-Δ</ci>
     <ci>μ</ci>
    </apply>
    <apply>
     <compose></compose>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>μ</ci>
      <ci>μ</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>id</ci>
       <ci>H</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <list>
        <ci>H</ci>
        <ci>H</ci>
       </list>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>id</ci>
       <ci>H</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>normal-Δ</ci>
      <ci>normal-Δ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta\circ\mu=(\mu\otimes\mu)\circ(\mathrm{id}_{H}\otimes\sigma_{H,H}\otimes%
\mathrm{id}_{H})\circ(\Delta\otimes\Delta)
  </annotation>
 </semantics>
</math>

,</p></li>
<li>Weak Multiplicativity of the Counit :

<p>

<math display="block" id="Weak_Hopf_algebra:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>ε</mi>
    <mo>∘</mo>
    <mi>μ</mi>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>μ</mi>
      <mo>⊗</mo>
      <msub>
       <mi>id</mi>
       <mi>H</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ε</mi>
      <mo>⊗</mo>
      <mi>ε</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>μ</mi>
      <mo>⊗</mo>
      <mi>μ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>id</mi>
       <mi>H</mi>
      </msub>
      <mo>⊗</mo>
      <mi mathvariant="normal">Δ</mi>
      <mo>⊗</mo>
      <msub>
       <mi>id</mi>
       <mi>H</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ε</mi>
      <mo>⊗</mo>
      <mi>ε</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>μ</mi>
      <mo>⊗</mo>
      <mi>μ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>id</mi>
       <mi>H</mi>
      </msub>
      <mo>⊗</mo>
      <msup>
       <mi mathvariant="normal">Δ</mi>
       <mrow>
        <mi>o</mi>
        <mi>p</mi>
       </mrow>
      </msup>
      <mo>⊗</mo>
      <msub>
       <mi>id</mi>
       <mi>H</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <compose></compose>
      <ci>ε</ci>
      <ci>μ</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>μ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>id</ci>
        <ci>H</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <compose></compose>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>ε</ci>
       <ci>ε</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>μ</ci>
       <ci>μ</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>id</ci>
        <ci>H</ci>
       </apply>
       <ci>normal-Δ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>id</ci>
        <ci>H</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <compose></compose>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>ε</ci>
       <ci>ε</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>μ</ci>
       <ci>μ</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>id</ci>
        <ci>H</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>normal-Δ</ci>
        <apply>
         <times></times>
         <ci>o</ci>
         <ci>p</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>id</ci>
        <ci>H</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon\circ\mu\circ(\mu\otimes\mathrm{id}_{H})=(\varepsilon\otimes%
\varepsilon)\circ(\mu\otimes\mu)\circ(\mathrm{id}_{H}\otimes\Delta\otimes%
\mathrm{id}_{H})=(\varepsilon\otimes\varepsilon)\circ(\mu\otimes\mu)\circ(%
\mathrm{id}_{H}\otimes\Delta^{op}\otimes\mathrm{id}_{H})
  </annotation>
 </semantics>
</math>

,</p></li>
<li>Weak Comultiplicativity of the Unit :

<p>

<math display="block" id="Weak_Hopf_algebra:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mo>⊗</mo>
      <msub>
       <mi>id</mi>
       <mi>H</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mi mathvariant="normal">Δ</mi>
    <mo>∘</mo>
    <mi>η</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>id</mi>
       <mi>H</mi>
      </msub>
      <mo>⊗</mo>
      <mi>μ</mi>
      <mo>⊗</mo>
      <msub>
       <mi>id</mi>
       <mi>H</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mo>⊗</mo>
      <mi mathvariant="normal">Δ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>η</mi>
      <mo>⊗</mo>
      <mi>η</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>id</mi>
       <mi>H</mi>
      </msub>
      <mo>⊗</mo>
      <msup>
       <mi>μ</mi>
       <mrow>
        <mi>o</mi>
        <mi>p</mi>
       </mrow>
      </msup>
      <mo>⊗</mo>
      <msub>
       <mi>id</mi>
       <mi>H</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mo>⊗</mo>
      <mi mathvariant="normal">Δ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>η</mi>
      <mo>⊗</mo>
      <mi>η</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <compose></compose>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>normal-Δ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>id</ci>
        <ci>H</ci>
       </apply>
      </apply>
      <ci>normal-Δ</ci>
      <ci>η</ci>
     </apply>
     <apply>
      <compose></compose>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>id</ci>
        <ci>H</ci>
       </apply>
       <ci>μ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>id</ci>
        <ci>H</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>normal-Δ</ci>
       <ci>normal-Δ</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>η</ci>
       <ci>η</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <compose></compose>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>id</ci>
        <ci>H</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>μ</ci>
        <apply>
         <times></times>
         <ci>o</ci>
         <ci>p</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>id</ci>
        <ci>H</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>normal-Δ</ci>
       <ci>normal-Δ</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>η</ci>
       <ci>η</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Delta\otimes\mathrm{id}_{H})\circ\Delta\circ\eta=(\mathrm{id}_{H}\otimes\mu%
\otimes\mathrm{id}_{H})\circ(\Delta\otimes\Delta)\circ(\eta\otimes\eta)=(%
\mathrm{id}_{H}\otimes\mu^{op}\otimes\mathrm{id}_{H})\circ(\Delta\otimes\Delta%
)\circ(\eta\otimes\eta)
  </annotation>
 </semantics>
</math>

,</p></li>
</ol>

<p>where 

<math display="inline" id="Weak_Hopf_algebra:12">
 <semantics>
  <mrow>
   <msub>
    <mi>σ</mi>
    <mrow>
     <mi>V</mi>
     <mo>,</mo>
     <mi>W</mi>
    </mrow>
   </msub>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>V</mi>
     <mo>⊗</mo>
     <mi>W</mi>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi>W</mi>
     <mo>⊗</mo>
     <mi>V</mi>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>v</mi>
     <mo>⊗</mo>
     <mi>w</mi>
    </mrow>
    <mo>↦</mo>
    <mrow>
     <mi>w</mi>
     <mo>⊗</mo>
     <mi>v</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <list>
       <ci>V</ci>
       <ci>W</ci>
      </list>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>V</ci>
       <ci>W</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>W</ci>
       <ci>V</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-:</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>v</ci>
       <ci>w</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>w</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{V,W}:V\otimes W\rightarrow W\otimes V:v\otimes w\mapsto w\otimes v
  </annotation>
 </semantics>
</math>

 flips the two tensor factors. Moreover 

<math display="inline" id="Weak_Hopf_algebra:13">
 <semantics>
  <mrow>
   <msup>
    <mi>μ</mi>
    <mrow>
     <mi>o</mi>
     <mi>p</mi>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>μ</mi>
    <mo>∘</mo>
    <msub>
     <mi>σ</mi>
     <mrow>
      <mi>H</mi>
      <mo>,</mo>
      <mi>H</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>μ</ci>
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>p</ci>
     </apply>
    </apply>
    <apply>
     <compose></compose>
     <ci>μ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <list>
       <ci>H</ci>
       <ci>H</ci>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu^{op}=\mu\circ\sigma_{H,H}
  </annotation>
 </semantics>
</math>


 is the opposite multiplication and 

<math display="inline" id="Weak_Hopf_algebra:14">
 <semantics>
  <mrow>
   <msup>
    <mi mathvariant="normal">Δ</mi>
    <mrow>
     <mi>o</mi>
     <mi>p</mi>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>σ</mi>
     <mrow>
      <mi>H</mi>
      <mo>,</mo>
      <mi>H</mi>
     </mrow>
    </msub>
    <mo>∘</mo>
    <mi mathvariant="normal">Δ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Δ</ci>
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>p</ci>
     </apply>
    </apply>
    <apply>
     <compose></compose>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <list>
       <ci>H</ci>
       <ci>H</ci>
      </list>
     </apply>
     <ci>normal-Δ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta^{op}=\sigma_{H,H}\circ\Delta
  </annotation>
 </semantics>
</math>

 is the opposite comultiplication. Note that we also implicitly use <a href="Mac_Lane" title="wikilink">Mac Lane</a>'s coherence theorem for the monoidal category of vector spaces, identifying 

<math display="inline" id="Weak_Hopf_algebra:15">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>U</mi>
      <mo>⊗</mo>
      <mi>V</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⊗</mo>
    <mi>W</mi>
   </mrow>
   <mo>≅</mo>
   <mrow>
    <mi>U</mi>
    <mo>⊗</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>V</mi>
      <mo>⊗</mo>
      <mi>W</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>U</ci>
      <ci>V</ci>
     </apply>
     <ci>W</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>U</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>V</ci>
      <ci>W</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (U\otimes V)\otimes W\cong U\otimes(V\otimes W)
  </annotation>
 </semantics>
</math>

 as well as 

<math display="inline" id="Weak_Hopf_algebra:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mo>⊗</mo>
    <mi>k</mi>
   </mrow>
   <mo>≅</mo>
   <mi>V</mi>
   <mo>≅</mo>
   <mrow>
    <mi>k</mi>
    <mo>⊗</mo>
    <mi>V</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <approx></approx>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>V</ci>
      <ci>k</ci>
     </apply>
     <ci>V</ci>
    </apply>
    <apply>
     <approx></approx>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>k</ci>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V\otimes k\cong V\cong k\otimes V
  </annotation>
 </semantics>
</math>

.</p>

<p>The definition is fairly self-explanatory, one sees that it is the compatibility between the algebra and coalgebra structures that is weaken.</p>

<p>A <strong>weak Hopf algebra</strong> 

<math display="inline" id="Weak_Hopf_algebra:17">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>H</mi>
   <mo>,</mo>
   <mi>μ</mi>
   <mo>,</mo>
   <mi>η</mi>
   <mo>,</mo>
   <mi mathvariant="normal">Δ</mi>
   <mo>,</mo>
   <mi>ε</mi>
   <mo>,</mo>
   <mi>S</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>H</ci>
    <ci>μ</ci>
    <ci>η</ci>
    <ci>normal-Δ</ci>
    <ci>ε</ci>
    <ci>S</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (H,\mu,\eta,\Delta,\varepsilon,S)
  </annotation>
 </semantics>
</math>

 is a weak bialgebra 

<math display="inline" id="Weak_Hopf_algebra:18">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>H</mi>
   <mo>,</mo>
   <mi>μ</mi>
   <mo>,</mo>
   <mi>η</mi>
   <mo>,</mo>
   <mi mathvariant="normal">Δ</mi>
   <mo>,</mo>
   <mi>ε</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>H</ci>
    <ci>μ</ci>
    <ci>η</ci>
    <ci>normal-Δ</ci>
    <ci>ε</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (H,\mu,\eta,\Delta,\varepsilon)
  </annotation>
 </semantics>
</math>


 with a linear map 

<math display="inline" id="Weak_Hopf_algebra:19">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>:</mo>
   <mrow>
    <mi>H</mi>
    <mo>→</mo>
    <mi>H</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>S</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>H</ci>
     <ci>H</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S:H\to H
  </annotation>
 </semantics>
</math>

, called the <strong>antipode</strong>, that satisfies:</p>
<ul>
<li>

<math display="inline" id="Weak_Hopf_algebra:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>μ</mi>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>id</mi>
       <mi>H</mi>
      </msub>
      <mo>⊗</mo>
      <mi>S</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mi mathvariant="normal">Δ</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>ε</mi>
      <mo>⊗</mo>
      <msub>
       <mi>id</mi>
       <mi>H</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>μ</mi>
      <mo>⊗</mo>
      <msub>
       <mi>id</mi>
       <mi>H</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>id</mi>
       <mi>H</mi>
      </msub>
      <mo>⊗</mo>
      <msub>
       <mi>σ</mi>
       <mrow>
        <mi>H</mi>
        <mo>,</mo>
        <mi>H</mi>
       </mrow>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mo>⊗</mo>
      <msub>
       <mi>id</mi>
       <mi>H</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>η</mi>
      <mo>⊗</mo>
      <msub>
       <mi>id</mi>
       <mi>H</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <ci>μ</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>id</ci>
       <ci>H</ci>
      </apply>
      <ci>S</ci>
     </apply>
     <ci>normal-Δ</ci>
    </apply>
    <apply>
     <compose></compose>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>ε</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>id</ci>
       <ci>H</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>μ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>id</ci>
       <ci>H</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>id</ci>
       <ci>H</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <list>
        <ci>H</ci>
        <ci>H</ci>
       </list>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>normal-Δ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>id</ci>
       <ci>H</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>η</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>id</ci>
       <ci>H</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu\circ(\mathrm{id}_{H}\otimes S)\circ\Delta=(\varepsilon\otimes\mathrm{id}_{%
H})\circ(\mu\otimes\mathrm{id}_{H})\circ(\mathrm{id}_{H}\otimes\sigma_{H,H})%
\circ(\Delta\otimes\mathrm{id}_{H})\circ(\eta\otimes\mathrm{id}_{H})
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Weak_Hopf_algebra:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>μ</mi>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>S</mi>
      <mo>⊗</mo>
      <msub>
       <mi>id</mi>
       <mi>H</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mi mathvariant="normal">Δ</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>id</mi>
       <mi>H</mi>
      </msub>
      <mo>⊗</mo>
      <mi>ε</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>id</mi>
       <mi>H</mi>
      </msub>
      <mo>⊗</mo>
      <mi>μ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>σ</mi>
       <mrow>
        <mi>H</mi>
        <mo>,</mo>
        <mi>H</mi>
       </mrow>
      </msub>
      <mo>⊗</mo>
      <msub>
       <mi>id</mi>
       <mi>H</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>id</mi>
       <mi>H</mi>
      </msub>
      <mo>⊗</mo>
      <mi mathvariant="normal">Δ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>id</mi>
       <mi>H</mi>
      </msub>
      <mo>⊗</mo>
      <mi>η</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <compose></compose>
     <ci>μ</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>S</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>id</ci>
       <ci>H</ci>
      </apply>
     </apply>
     <ci>normal-Δ</ci>
    </apply>
    <apply>
     <compose></compose>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>id</ci>
       <ci>H</ci>
      </apply>
      <ci>ε</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>id</ci>
       <ci>H</ci>
      </apply>
      <ci>μ</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <list>
        <ci>H</ci>
        <ci>H</ci>
       </list>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>id</ci>
       <ci>H</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>id</ci>
       <ci>H</ci>
      </apply>
      <ci>normal-Δ</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>id</ci>
       <ci>H</ci>
      </apply>
      <ci>η</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu\circ(S\otimes\mathrm{id}_{H})\circ\Delta=(\mathrm{id}_{H}\otimes%
\varepsilon)\circ(\mathrm{id}_{H}\otimes\mu)\circ(\sigma_{H,H}\otimes\mathrm{%
id}_{H})\circ(\mathrm{id}_{H}\otimes\Delta)\circ(\mathrm{id}_{H}\otimes\eta)
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Weak_Hopf_algebra:22">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mi>μ</mi>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>μ</mi>
      <mo>⊗</mo>
      <msub>
       <mi>id</mi>
       <mi>H</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>S</mi>
      <mo>⊗</mo>
      <msub>
       <mi>id</mi>
       <mi>H</mi>
      </msub>
      <mo>⊗</mo>
      <mi>S</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mo>⊗</mo>
      <msub>
       <mi>id</mi>
       <mi>H</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∘</mo>
    <mi mathvariant="normal">Δ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <compose></compose>
     <ci>μ</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>μ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>id</ci>
       <ci>H</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>S</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>id</ci>
       <ci>H</ci>
      </apply>
      <ci>S</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>normal-Δ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>id</ci>
       <ci>H</ci>
      </apply>
     </apply>
     <ci>normal-Δ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\mu\circ(\mu\otimes\mathrm{id}_{H})\circ(S\otimes\mathrm{id}_{H}\otimes S)%
\circ(\Delta\otimes\mathrm{id}_{H})\circ\Delta
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<h2 id="examples">Examples</h2>
<ol>
<li><strong>Hopf algebra.</strong> Of course any <a href="Hopf_algebra" title="wikilink">Hopf algebra</a> is a weak Hopf algebra.</li>
<li><strong>Groupoid algebra.</strong> Suppose 

<math display="inline" id="Weak_Hopf_algebra:23">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>G</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>G</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(G_{0},G_{1})
  </annotation>
 </semantics>
</math>


 is a <a class="uri" href="groupoid" title="wikilink">groupoid</a> and let 

<math display="inline" id="Weak_Hopf_algebra:24">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>G</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K[G]
  </annotation>
 </semantics>
</math>

 be the groupoid algebra, in other words, the algebra generated by the morphisms 

<math display="inline" id="Weak_Hopf_algebra:25">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>∈</mo>
   <msub>
    <mi>G</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>g</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\in G_{1}
  </annotation>
 </semantics>
</math>

. This becomes a weak Hopf algebra if we define
<ul>
<li><math> \mu : K[G] \otimes K[G] \to K[G] ~\text{by}~ \mu(g \otimes h)= \left\{ \begin{array}{cl}</math></li>
</ul></li>
</ol>

<p>g \circ h &amp; \text{if target(h) = source(g)} \\ 0 &amp; \text{otherwise} \end{array} \right. </p>

<p>#* 

<math display="inline" id="Weak_Hopf_algebra:26">
 <semantics>
  <mrow>
   <mi>η</mi>
   <mo>:</mo>
   <mrow>
    <mi>k</mi>
    <mo>→</mo>
    <mrow>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>G</mi>
      <mo rspace="5.8pt" stretchy="false">]</mo>
     </mrow>
     <mpadded width="+3.3pt">
      <mtext>by</mtext>
     </mpadded>
     <mi>η</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>X</mi>
       <mo>∈</mo>
       <msub>
        <mi>G</mi>
        <mn>0</mn>
       </msub>
      </mrow>
     </msub>
     <msub>
      <mi>id</mi>
      <mi>X</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>η</ci>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <ci>k</ci>
      <apply>
       <times></times>
       <ci>K</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>G</ci>
       </apply>
       <mtext>by</mtext>
       <ci>η</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <in></in>
         <ci>X</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>G</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>id</ci>
        <ci>X</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta:k\to K[G]~{}\text{by}~{}\eta(1)=\sum_{X\in G_{0}}\mathrm{id}_{X}
  </annotation>
 </semantics>
</math>

</p>

<p>#* 

<math display="inline" id="Weak_Hopf_algebra:27">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>G</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>K</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>G</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo>⊗</mo>
      <mi>K</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>G</mi>
      <mo rspace="5.8pt" stretchy="false">]</mo>
     </mrow>
     <mpadded width="+3.3pt">
      <mtext>by</mtext>
     </mpadded>
     <mi mathvariant="normal">Δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>g</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>g</mi>
      <mo>⊗</mo>
      <mpadded width="+3.3pt">
       <mi>g</mi>
      </mpadded>
     </mrow>
     <mpadded width="+3.3pt">
      <mtext>for all</mtext>
     </mpadded>
     <mi>g</mi>
    </mrow>
    <mo>∈</mo>
    <msub>
     <mi>G</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>normal-Δ</ci>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <times></times>
       <ci>K</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>G</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <apply>
         <times></times>
         <ci>K</ci>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <ci>G</ci>
         </apply>
        </apply>
        <ci>K</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>G</ci>
       </apply>
       <mtext>by</mtext>
       <ci>normal-Δ</ci>
       <ci>g</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">tensor-product</csymbol>
        <ci>g</ci>
        <ci>g</ci>
       </apply>
       <mtext>for all</mtext>
       <ci>g</ci>
      </apply>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>G</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta:K[G]\to K[G]\otimes K[G]~{}\text{by}~{}\Delta(g)=g\otimes g~{}\text{for%
 all}~{}g\in G_{1}
  </annotation>
 </semantics>
</math>

</p>

<p>#* 

<math display="inline" id="Weak_Hopf_algebra:28">
 <semantics>
  <mrow>
   <mi>ε</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>G</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mpadded width="+3.3pt">
      <mi>k</mi>
     </mpadded>
     <mpadded width="+3.3pt">
      <mtext>by</mtext>
     </mpadded>
     <mi>ε</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>g</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mpadded width="+3.3pt">
      <mn>1</mn>
     </mpadded>
     <mpadded width="+3.3pt">
      <mtext>for all</mtext>
     </mpadded>
     <mi>g</mi>
    </mrow>
    <mo>∈</mo>
    <msub>
     <mi>G</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>ε</ci>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <times></times>
       <ci>K</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>G</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>k</ci>
       <mtext>by</mtext>
       <ci>ε</ci>
       <ci>g</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <cn type="integer">1</cn>
       <mtext>for all</mtext>
       <ci>g</ci>
      </apply>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>G</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon:K[G]\to k~{}\text{by}~{}\varepsilon(g)=1~{}\text{for all}~{}g\in G%
_{1}
  </annotation>
 </semantics>
</math>


</p>

<p>#* 

<math display="inline" id="Weak_Hopf_algebra:29">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>G</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>G</mi>
      <mo rspace="5.8pt" stretchy="false">]</mo>
     </mrow>
     <mpadded width="+3.3pt">
      <mtext>by</mtext>
     </mpadded>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>g</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mpadded width="+3.3pt">
      <msup>
       <mi>g</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mpadded>
     <mpadded width="+3.3pt">
      <mtext>for all</mtext>
     </mpadded>
     <mi>g</mi>
    </mrow>
    <mo>∈</mo>
    <msub>
     <mi>G</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>S</ci>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <times></times>
       <ci>K</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>G</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>K</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>G</ci>
       </apply>
       <mtext>by</mtext>
       <ci>S</ci>
       <ci>g</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>g</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <mtext>for all</mtext>
       <ci>g</ci>
      </apply>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>G</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S:K[G]\to K[G]~{}\text{by}~{}S(g)=g^{-1}~{}\text{for all}~{}g\in G_{1}
  </annotation>
 </semantics>
</math>

. Note that this second example is a weak Hopf algebra but <strong>not</strong> a <a href="Hopf_algebra" title="wikilink">Hopf algebra</a>.</p>
<h2 id="representation-theory">Representation theory</h2>

<p>Let H be a semisimple finite weak Hopf algebra, then modules over H form a semisimple rigid monoidal category with finitely many simple objects. Moreover the homomorphisms spaces are finite-dimensional vector spaces and the endomorphisms space of simple objects are one-dimensional. Finally, the monoidal unit is a simple object. Such a category is called a <a href="fusion_category" title="wikilink">fusion category</a>.</p>

<p>It can be shown that some monoidal category are not modules over a Hopf algebra. In the case of fusion categories (which are just monoidal categories with extra conditions), it was proved by Etingof, Nikshych and Ostrik that any fusion category is equivalent to a category of modules over a weak Hopf algebra.</p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Hopf_algebras" title="wikilink">Category:Hopf algebras</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Böhm, Nill, Szlachányi. p. 387<a href="#fnref1">↩</a></li>
<li id="fn2">Etingof, Nikshych and Ostrik, Cor. 2.22<a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
