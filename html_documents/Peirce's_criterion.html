<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1000">Peirce's criterion</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Peirce's criterion</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In <a href="robust_statistics" title="wikilink">robust statistics</a>, <strong>Peirce's criterion</strong> is a rule for eliminating <a href="outlier" title="wikilink">outliers</a> from data sets, which was devised by <a href="Benjamin_Peirce" title="wikilink">Benjamin Peirce</a>.</p>
<h2 id="outliers-removed-by-peirces-criterion">Outliers removed by Peirce's criterion</h2>
<h3 id="the-problem-of-outliers">The problem of outliers</h3>

<p>In <a href="data_set" title="wikilink">data sets</a> containing real-numbered measurements, the suspected <a href="outlier" title="wikilink">outliers</a> are the measured values that appear to lie outside the cluster of most of the other data values. The outliers would greatly change the estimate of location if the arithmetic average were to be used as a summary statistic of location. The problem is that the arithmetic mean is very sensitive to the inclusion of any outliers; in statistical terminology, the arithmetic mean is not <a href="robust_statistic" title="wikilink">robust</a>.</p>

<p>In the presence of outliers, the statistician has two options. First, the statistician may remove the suspected <a href="outlier" title="wikilink">outliers</a> from the data set and then use the arithmetic mean to estimate the location parameter. Second, the statistician may use a robust statistic, such as the <a class="uri" href="median" title="wikilink">median</a> statistic.</p>

<p>Peirce's criterion is a statistical procedure for eliminating outliers.</p>
<h3 id="uses-of-peirces-criterion">Uses of Peirce's criterion</h3>

<p>The statistician and historian of statistics <a href="Stephen_M._Stigler" title="wikilink">Stephen M. Stigler</a> wrote the following about <a href="Benjamin_Peirce" title="wikilink">Benjamin Peirce</a>:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<blockquote>

<p>"In 1852 he published the first <a href="significance_test" title="wikilink">significance test</a> designed to tell an investigator whether an outlier should be rejected (Peirce 1852, 1878). The test, based on a <a href="Likelihood-ratio_test" title="wikilink">likelihood ratio</a> type of argument, had the distinction of producing an international debate on the wisdom of such actions (<a href="Francis_J._Anscombe" title="wikilink">Anscombe</a>, 1960, Rider, 1933, <a href="Stephen_Stigler" title="wikilink">Stigler</a>, 1973a)."</p>
</blockquote>

<p>Peirce's criterion is derived from a statistical analysis of the <a href="Gaussian_distribution" title="wikilink">Gaussian distribution</a>. Unlike some other criteria for removing outliers, Peirce's method can be applied to identify two or more outliers.</p>
<blockquote>

<p>"It is proposed to determine in a series of 

<math display="inline" id="Peirce's_criterion:0">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 observations the limit of error, beyond which all observations involving so great an error may be rejected, provided there are as many as 

<math display="inline" id="Peirce's_criterion:1">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 such observations. The principle upon which it is proposed to solve this problem is, that the proposed observations should be rejected when the probability of the system of errors obtained by retaining them is less than that of the system of errors obtained by their rejection multiplied by the probability of making so many, and no more, abnormal observations."<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
</blockquote>

<p>Hawkins<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> provides a formula for the criterion.</p>

<p>Peirce's criterion was used for decades at the <a href="United_States_Coast_Survey" title="wikilink">United States Coast Survey</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<blockquote>

<p>"From 1852 to 1867 he served as the director of the longitude determinations of the U. S. Coast Survey and from 1867 to 1874 as superintendent of the Survey. During these years his test was consistently employed by all the clerks of this, the most active and mathematically inclined statistical organization of the era."<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> </p>
</blockquote>

<p>Peirce's criterion was discussed in <a href="William_Chauvenet" title="wikilink">William Chauvenet</a>'s book.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="applications">Applications</h2>

<p>An application for Peirce's criterion is removing poor data points from observation pairs in order to perform a regression between the two observations (e.g., a linear regression). Peirce's criteria does not depend on observation data (only characteristics of the observation data), therefore making it a highly repeatable process that can be calculated independently of other processes. This feature makes Peirce's criteria for identifying outliers ideal in computer applications because it can be written as a call function.</p>
<h3 id="previous-attempts">Previous attempts</h3>

<p>In 1855, B.A. Gould attempted to make Peirce's criterion easier to apply by creating tables of values representing values from Peirce's equations.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Unfortunately, there still exists a disconnect between Gould's algorithm and the practical application of Peirce's criterion.</p>

<p>In 2003, S.M. Ross (University of New Haven) re-presents Gould's algorithm (now called "Peirce's method") with a new example data set and work-through of the algorithm. Unfortunately, this methodology still relies on using look-up tables, which have been updated in this work (Peirce's criterion table).<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>In 2008, an attempt to write a pseudo-code was made by a Danish geologist K. Thomsen.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> While this code provided some framework for Gould's algorithm, users were unsuccessful in calculating values reported by either Peirce or Gould.</p>

<p>In 2012, C. Dardis releases the R package "Peirce" with various methodologies (Peirce's criterion and the Chauvenet method) with comparisons of outlier removals. Dardis and fellow contributor Simon Muller, successfully implemented Thomsen's pseudo-code into a function called "findx." The code is presented in the R implementation section below. References for the R package are available online<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> as well as an unpublished review of the R package results.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>In 2013, a re-examination of Gould's algorithm and the utilisation of advanced Python programming modules (i.e., numpy and scipy) has made it possible to calculate the squared-error threshold values for identifying outliers.</p>
<h3 id="python-implementation">Python implementation</h3>

<p>In order to use Peirce's criteria, one must first understand the input and return values. Regression analysis (or the fitting of curves to data) results in residual errors (or the difference between the fitted curve and the observation points). Therefore, each observation point has a residual error associated with a fitted curve. By taking the square (i.e., residual error raised to the power of two), residual errors are expressed as positive values. If the squared error is too large (i.e., due to a poor observation) it can cause problems with the regression parameters (e.g., slope and intercept for a linear curve) retrieved from the curve fitting.</p>

<p>It was Peirce's idea to statistically identify what constituted an error as "too large" and therefore being identified as an "outlier" which could be removed from the observations to improve the fit between the observations and a curve. K. Thomsen identified that three parameters were needed to perform the calculation: the number of observation pairs (N), the number of outliers to be removed (n), and the number of regression parameters (e.g., coefficients) used in the curve-fitting to get the residuals (m). The end result of this process is to calculate a threshold value (of squared error) whereby observations with a squared error smaller than this threshold should be kept and observations with a squared error larger than this value should be removed (i.e., as an outlier).</p>

<p>Because Peirce's criteria does not take observations, fitting parameters, or residual errors as an input, the output must be re-associated with the data. By taking the average of all the squared errors (i.e., the mean-squared error) and multiply it by the threshold squared error (i.e., the output of this function), it will result in the data-specific threshold value used to identify outliers.</p>

<p>The following Python code returns x-squared values for a given N (first column) and n (top row) in Table 1 (m = 1) and Table 2 (m = 2) of Gould 1855,.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> Due to the Newton-method of iteration, look-up tables, such as N versus log Q (Table III in Gould, 1855) and x versus log R (Table III in Peirce, 1852 and Table IV in Gould, 1855) are no longer necessary.</p>
<h4 id="python-code">python code</h4>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">#!/usr/bin/python</span>
<span class="co">#</span>
<span class="co"># peirce_dev.py</span>
<span class="co"># created 16 Jul 2013</span>
<span class="co"># updated 23 Oct 2014</span>
<span class="co">#</span>
<span class="co">#### MODULES ####</span>
<span class="im">import</span> numpy
<span class="im">import</span> scipy.special

<span class="co">#### FUNCTION ####</span>
<span class="kw">def</span> peirce_dev(N, n, m):
   <span class="co">"""</span>
<span class="co">   Name:     peirce_dev</span>
<span class="co">   Input:    - int, total number of observations (N)</span>
<span class="co">             - int, number of outliers to be removed (n)</span>
<span class="co">             - int, number of model unknowns (m)</span>
<span class="co">   Output:   float, squared error threshold (x2)</span>
<span class="co">   Features: Returns the squared threshold error deviation for outlier </span>
<span class="co">             identification using Peirce's criterion based on Gould's</span>
<span class="co">             methodology</span>
<span class="co">   """</span>
   <span class="co"># Assign floats to input variables:</span>
   N <span class="op">=</span> <span class="bu">float</span>(N)
   n <span class="op">=</span> <span class="bu">float</span>(n)
   m <span class="op">=</span> <span class="bu">float</span>(m)
   <span class="co">#</span>
   <span class="co"># Check number of observations:</span>
   <span class="cf">if</span> N <span class="op">&gt;</span> <span class="dv">1</span>:
      <span class="co"># Calculate Q (Nth root of Gould's equation B):</span>
      Q <span class="op">=</span> (n<span class="op">**</span>(n<span class="op">/</span>N)<span class="op">*</span>(N <span class="op">-</span> n)<span class="op">**</span>((N <span class="op">-</span> n)<span class="op">/</span>N))<span class="op">/</span>N
      <span class="co">#</span>
      <span class="co"># Initialize R values (as floats)</span>
      Rnew <span class="op">=</span> <span class="fl">1.0</span>  
      Rold <span class="op">=</span> <span class="fl">0.0</span>  <span class="co"># &lt;- Necessary to prompt while loop</span>
      <span class="co">#</span>
      <span class="co"># Start iteration to converge on R:</span>
      <span class="cf">while</span> ( <span class="bu">abs</span>(Rnew <span class="op">-</span> Rold) <span class="op">&gt;</span> (N<span class="op">*</span><span class="fl">2.0e-16</span>) ):
         <span class="co"># Calculate Lamda </span>
         <span class="co"># (1/(N-n)th root of Gould's equation A'):</span>
         ldiv <span class="op">=</span> Rnew<span class="op">**</span>n
         <span class="cf">if</span> ldiv <span class="op">==</span> <span class="dv">0</span>:
            ldiv <span class="op">=</span> <span class="fl">1.0e-6</span>
         Lamda <span class="op">=</span> ((Q<span class="op">**</span>N)<span class="op">/</span>(ldiv))<span class="op">**</span>(<span class="fl">1.0</span><span class="op">/</span>(N <span class="op">-</span> n))
         <span class="co">#</span>
         <span class="co"># Calculate x-squared (Gould's equation C):</span>
         x2 <span class="op">=</span> <span class="fl">1.0</span> <span class="op">+</span> (N <span class="op">-</span> m <span class="op">-</span> n)<span class="op">/</span>n<span class="op">*</span>(<span class="fl">1.0</span> <span class="op">-</span> Lamda<span class="op">**</span><span class="fl">2.0</span>)
         <span class="co">#</span>
         <span class="co"># If x2 goes negative, return 0:</span>
         <span class="cf">if</span> x2 <span class="op">&lt;</span> <span class="dv">0</span>:
            x2 <span class="op">=</span> <span class="fl">0.0</span>
            Rold <span class="op">=</span> Rnew
         <span class="cf">else</span>:
            <span class="co"># Use x-squared to update R (Gould's equation D):</span>
            Rold <span class="op">=</span> Rnew
            Rnew <span class="op">=</span> (
               numpy.exp((x2 <span class="op">-</span> <span class="dv">1</span>)<span class="op">/</span><span class="fl">2.0</span>)<span class="op">*</span>
               scipy.special.erfc(numpy.sqrt(x2)<span class="op">/</span>numpy.sqrt(<span class="fl">2.0</span>))
               )
         <span class="co">#</span>
   <span class="cf">else</span>:
      x2 <span class="op">=</span> <span class="fl">0.0</span>
   <span class="cf">return</span> x2</code></pre></div>
<h3 id="r-implementation">R implementation</h3>

<p>Thomsen's code has been successfully written into the following function call, "findx" by C. Dardis and S. Muller in 2012 which returns the maximum error deviation, 

<math display="inline" id="Peirce's_criterion:2">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

. To complement the Python code presented in the previous section, the R equivalent of "peirce_dev" is also presented here which returns the squared maximum error deviation, 

<math display="inline" id="Peirce's_criterion:3">
 <semantics>
  <msup>
   <mi>x</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}
  </annotation>
 </semantics>
</math>

. These two functions return equivalent values by either squaring the returned value from the "findx" function or by taking the square-root of the value returned by the "peirce_dev" function. Differences occur with error handling. For example, the "findx" function returns NaNs for invalid data while "peirce_dev" returns 0 (which allows for computations to continue without additional NA value handling). Also, the "findx" function does not support any error handling when the number of potential outliers increases towards the number of observations (throws missing value error and NaN warning).</p>

<p>Just as with the Python version, the squared-error (i.e., 

<math display="inline" id="Peirce's_criterion:4">
 <semantics>
  <msup>
   <mi>x</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}
  </annotation>
 </semantics>
</math>

) returned by the "peirce_dev" function must be multiplied by the mean-squared error of the model fit to get the squared-delta value (i.e., Δ2). Use Δ2 to compare the squared-error values of the model fit. Any observation pairs with a squared-error greater than Δ2 are considered outliers and can be removed from the model. An iterator should be written to test increasing values of n until the number of outliers identified (comparing Δ2 to model-fit squared-errors) is less than those assumed (i.e., Peirce's n).</p>
<h4 id="r-code">r code</h4>
<pre class="rsplus"><code>findx &lt;- function(N,k,m){ 
  # method by K. Thomsen (2008)
  # written by C. Dardis and S. Muller (2012)
  # Available online: https://r-forge.r-project.org/R/?group_id=1473
  #
  # Variable definitions:
  # N :: number of observations
  # k :: number of potential outliers to be removed
  # m :: number of unknown quantities
  #
  # Requires the complementary error function, erfc:
  erfc &lt;- function(x) 2 * pnorm(x * sqrt(2), lower.tail = FALSE)
  #
  x &lt;- 1
  if ((N - m - k) &lt;= 0) {
    return(NaN)
    print(NaN)
  }  else {
    x    &lt;- min(x, sqrt((N - m)/k) - 1e-10)
    #
    # Log of Gould's equation B:
    LnQN &lt;- k * log(k) + (N - k) * log(N - k) - N * log(N)
    #
    # Gould's equation D:
    R1   &lt;- exp((x^2 - 1)/2) * erfc(x/sqrt(2))
    #
    # Gould's equation A' solved for R w/ Lambda substitution:
    R2   &lt;- exp( (LnQN - 0.5 * (N - k) * log((N-m-k*x^2)/(N-m-k)) )/k )
    #
    # Equate the two R equations:
    R1d  &lt;- x * R1 - sqrt(2/pi/exp(1))
    R2d  &lt;- x * (N - k)/(N - m - k * x^2) * R2
    #
    # Update x:
    oldx &lt;- x
    x    &lt;- oldx - (R1 - R2)/(R1d - R2d)
    #
    # Loop until convergence:
    while (abs(x - oldx) &gt;= N * 2e-16){
      R1   &lt;- exp((x^2 - 1)/2) * erfc(x/sqrt(2))
      R2   &lt;- exp( (LnQN - 0.5 * (N - k) * log((N-m-k*x^2)/(N-m-k)) )/k )
      R1d  &lt;- x * R1 - sqrt(2/pi/exp(1))
      R2d  &lt;- x * (N - k)/(N - m - k * x^2) * R2
      oldx &lt;- x
      x    &lt;- oldx - (R1 - R2)/(R1d - R2d)
    }
  }
  return(x)
}</code></pre>
<pre class="rsplus"><code>peirce_dev &lt;- function(N, n, m){
    # N :: total number of observations
    # n :: number of outliers to be removed
    # m :: number of model unknowns (e.g., regression parameters)
    #
    # Check number of observations:
    if (N &gt; 1) {
       # Calculate Q (Nth root of Gould's equation B):
       Q = (n^(n/N) * (N-n)^((N-n)/N))/N
       #
       # Initialize R values:
       Rnew = 1.0
       Rold = 0.0  # &lt;- Necessary to prompt while loop
       #
       while(abs(Rnew-Rold) &gt; (N*2.0e-16)){
           # Calculate Lamda (1/(N-n)th root of Gould's equation A'):
           ldiv = Rnew^n
           if (ldiv == 0){
              ldiv = 1.0e-6
           }
           Lamda = ((Q^N)/(ldiv))^(1.0/(N-n))
           #
           # Calculate x-squared (Gould's equation C):
           x2 = 1.0 + (N-m-n)/n * (1.0-Lamda^2.0)
           #
           # If x2 goes negative, set equal to zero:
           if (x2 &lt; 0){
              x2 = 0
              Rold = Rnew
           } else {
              #
              # Use x-squared to update R (Gould's equation D):
              # NOTE: error function (erfc) is replaced with pnorm (Rbasic):
              # source: 
              # http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Normal.html
              Rold = Rnew
              Rnew = exp((x2-1)/2.0)*(2*pnorm(sqrt(x2)/sqrt(2)*sqrt(2), lower=FALSE))
           }
       }
    } else {
       x2 = 0
    }
    x2
}</code></pre>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li><a href="Benjamin_Peirce" title="wikilink">Peirce, Benjamin</a>, [<a class="uri" href="http://articles.adsabs.harvard.edu/cgi-bin/nph-iarticle_query?1852AJ">http://articles.adsabs.harvard.edu/cgi-bin/nph-iarticle_query?1852AJ</a>......2..161P;data_type=PDF_HIGH "Criterion for the Rejection of Doubtful Observations"], <em>Astronomical Journal</em> II 45 (1852) and [<a class="uri" href="http://articles.adsabs.harvard.edu/cgi-bin/nph-iarticle_query?1852AJ">http://articles.adsabs.harvard.edu/cgi-bin/nph-iarticle_query?1852AJ</a>......2..176P;data_type=PDF_HIGH Errata to the original paper].</li>
<li></li>
<li>

<p>. NOAA <a href="http://docs.lib.noaa.gov/rescue/cgs/001_pdf/CSC-0019.PDF#page=215">PDF Eprint</a> (goes to Report p. 200, PDF's p. 215). U.S. Coast and Geodetic Survey Annual Reports <a href="http://docs.lib.noaa.gov/rescue/cgs/data_rescue_cgs_annual_reports.html">links for years 1837–1965</a>.</p></li>
<li></li>
<li>Ross, Stephen, "Peirce's Criterion for the Elimination of Suspect Experimental Data", <em>J. Engr. Technology</em>, vol. 20 no.2, Fall, 2003. <a href="http://newton.newhaven.edu/sross/piercescriterion.pdf">1</a></li>
<li></li>
<li></li>
<li></li>
<li>Hawkins, D.M. (1980). <em>Identification of outliers</em>. <a href="Chapman_and_Hall" title="wikilink">Chapman and Hall</a>, London. ISBN 0-412-21900-X</li>
<li>Chauvenet, W. (1876) <em>A Manual of Spherical and Practical Astronomy</em>. J.B.Lippincott, Philadelphia. (reprints of various editions: Dover, 1960; Peter Smith Pub, 2000, ISBN 0-8446-1845-4; Adamant Media Corporation (2 Volumes), 2001, ISBN 1-4021-7283-4, ISBN 1-4212-7259-8; BiblioBazaar, 2009, ISBN 1-103-92942-9 )</li>
</ul>

<p>"</p>

<p><a href="Category:Statistical_theory" title="wikilink">Category:Statistical theory</a> <a href="Category:Statistical_outliers" title="wikilink">Category:Statistical outliers</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">S.M. Stigler, "Mathematical statistics in the early states," The Annals of Statistics, vol. 6, no. 2, p. 246, 1978. Available online: <a class="uri" href="http://www.jstor.org/stable/2958876">http://www.jstor.org/stable/2958876</a><a href="#fnref1">↩</a></li>
<li id="fn2">Quoted in the editorial note on page 516 of the <em>Collected Writings</em> of Peirce (1982 edition). The quotation cites <em>A Manual of Astronomy</em> (2:558) by Chauvenet.<a href="#fnref2">↩</a></li>
<li id="fn3">D.M. Hawkins (1980). "Brief early history in outlier rejection," Identification of Outliers (Monographs on Applied Probability and Statistics). Chapman &amp; Hall, page 10.<a href="#fnref3">↩</a></li>
<li id="fn4">Peirce (1878)<a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7">Gould, B.A., "On Peirce's criterion for the rejection of doubtful observations, with tables for facilitating its application," Astronomical Journal, iss. 83, vol. 4, no. 11, pp. 81--87, 1855. DOI: 10.1086/100480. Available online at <a class="uri" href="http://adsabs.harvard.edu/full/1855AJ">http://adsabs.harvard.edu/full/1855AJ</a>......4...81G<a href="#fnref7">↩</a></li>
<li id="fn8">Ross, S.M., "Peirce's criterion for the elimination of suspect experimental data," Journal of Engineering Technology, vol. 2, no. 2, pp. 1-12, 2003. Available online: <a class="uri" href="http://www.eol.ucar.edu/system/files/piercescriterion.pdf">http://www.eol.ucar.edu/system/files/piercescriterion.pdf</a><a href="#fnref8">↩</a></li>
<li id="fn9">Thomsen, K., "Topic: Computing tables for use with Peirce's Criterion - in 1855 and 2008", The Math Forum @ Drexel, posted 5 Oct. 2008. Available online at <a class="uri" href="http://mathforum.org/kb/message.jspa?messageID=6449606">http://mathforum.org/kb/message.jspa?messageID=6449606</a>. Accessed 15 Jul. 2013.<a href="#fnref9">↩</a></li>
<li id="fn10">C. Dardis, "Package: Peirce," R-forge, accessed online: <a class="uri" href="https://r-forge.r-project.org/scm/viewvc.php/*checkout*/pkg/Peirce/Peirce-manual.pdf?root=peirce">https://r-forge.r-project.org/scm/viewvc.php/*checkout*/pkg/Peirce/Peirce-manual.pdf?root=peirce</a><a href="#fnref10">↩</a></li>
<li id="fn11">C. Dardis, "Peirce's criterion for the rejection of non-normal outliers; defining the range of applicability," Journal of Statistical Software (unpublished). Available online: <a class="uri" href="https://r-forge.r-project.org/scm/viewvc.php/*checkout*/pkg/Peirce/PeirceSub.pdf?root=peirce">https://r-forge.r-project.org/scm/viewvc.php/*checkout*/pkg/Peirce/PeirceSub.pdf?root=peirce</a><a href="#fnref11">↩</a></li>
<li id="fn12"></li>
</ol>
</section>
</body>

