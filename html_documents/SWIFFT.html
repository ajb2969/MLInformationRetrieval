<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1454">SWIFFT</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>SWIFFT</h1>
<hr/>

<p>In <a class="uri" href="cryptography" title="wikilink">cryptography</a>, <strong>SWIFFT</strong> is a collection of <a href="Provably_secure_cryptographic_hash_function" title="wikilink">provably secure</a> <a href="cryptographic_hash_function" title="wikilink">hash functions</a>. It is based on the concept of the <a href="Fast_Fourier_Transform" title="wikilink">Fast Fourier Transform</a> (FFT). SWIFFT is not the first hash function based on FFT, but it sets itself apart by providing a mathematical proof of its security. It also uses the <a href="Lenstra-Lenstra-Lovász_lattice_basis_reduction_algorithm" title="wikilink">LLL basis reduction algorithm</a>. It can be shown that finding collisions in SWIFFT is as least as difficult as finding short vectors in cyclic/<a href="Ideal_lattice_cryptography" title="wikilink">ideal lattices</a> in the <em>worst case</em>. By giving a security reduction to the worst-case scenario of a difficult mathematical problem, SWIFFT gives a much stronger security guarantee than most other <a href="provably_secure_cryptographic_hash_function" title="wikilink">cryptographic hash functions</a>.</p>

<p>Unlike many other provably secure hash functions, the algorithm is quite fast, yielding a throughput of 40MB/s on a 3.2 GHz Intel Pentium 4. Although SWIFFT satisfies many desirable cryptographic and statistical properties, it was not designed to be an "all-purpose" cryptographic hash function. For example, it is not a <a href="pseudorandom_function" title="wikilink">pseudorandom function</a>, and would not be a suitable instantiation of a <a href="random_oracle" title="wikilink">random oracle</a>. The algorithm is less efficient than most traditional hash functions that do not give a proof of their collision-resistance. Therefore, its practical use would lie mostly in applications where the proof of collision-resistance is particularly valuable, such as digital signatures that must remain trustworthy for a long time.</p>

<p>A modification of SWIFFT called <a class="uri" href="SWIFFTX" title="wikilink">SWIFFTX</a> was proposed as a candidate for SHA-3 function to the <a href="NIST_hash_function_competition" title="wikilink">NIST hash function competition</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and was rejected in the first round.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="the-algorithm">The Algorithm</h2>

<p>The algorithm is as follows:<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<ol>
<li>Let the <a class="uri" href="polynomial" title="wikilink">polynomial</a> variable be called 

<math display="inline" id="SWIFFT:0">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

</li>
<li><strong>Input</strong>: message 

<math display="inline" id="SWIFFT:1">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 of length 

<math display="inline" id="SWIFFT:2">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   mn
  </annotation>
 </semantics>
</math>

</li>
<li>Convert 

<math display="inline" id="SWIFFT:3">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 to a collection of 

<math display="inline" id="SWIFFT:4">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 polynomials 

<math display="inline" id="SWIFFT:5">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i}
  </annotation>
 </semantics>
</math>

 in a certain <a href="polynomial_ring" title="wikilink">polynomial ring</a> 

<math display="inline" id="SWIFFT:6">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 with binary coefficients.</li>
<li>Compute the Fourier coefficients of each 

<math display="inline" id="SWIFFT:7">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i}
  </annotation>
 </semantics>
</math>

 using SWIFFT.</li>
<li>Define the Fourier coefficients of 

<math display="inline" id="SWIFFT:8">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}
  </annotation>
 </semantics>
</math>

, so that they are fixed and depend on a family of SWIFFT.</li>
<li>Point-wise multiply the Fourier coefficients 

<math display="inline" id="SWIFFT:9">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i}
  </annotation>
 </semantics>
</math>

 with the Fourier coefficients of 

<math display="inline" id="SWIFFT:10">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}
  </annotation>
 </semantics>
</math>

 for each 

<math display="inline" id="SWIFFT:11">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

.</li>
<li>Use inverse FFT to obtain 

<math display="inline" id="SWIFFT:12">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 polynomials 

<math display="inline" id="SWIFFT:13">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}
  </annotation>
 </semantics>
</math>

 of degree <math>.</math></li>
<li>Compute 

<math display="inline" id="SWIFFT:14">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>m</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>f</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>f</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f=\sum_{i=1}^{m}(f_{i})
  </annotation>
 </semantics>
</math>

 modulo 

<math display="inline" id="SWIFFT:15">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="SWIFFT:16">
 <semantics>
  <mrow>
   <msup>
    <mi>α</mi>
    <mi>n</mi>
   </msup>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>α</ci>
     <ci>n</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha^{n}+1
  </annotation>
 </semantics>
</math>

.</li>
<li>Convert 

<math display="inline" id="SWIFFT:17">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="SWIFFT:18">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mrow>
    <mi>log</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <apply>
     <log></log>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\log(p)
  </annotation>
 </semantics>
</math>

 bits and <strong>output</strong> it.</li>
</ol>
<ul>
<li>The <a href="Fast_fourier_transform" title="wikilink">FFT</a> operation in step 4 is easy to invert, and is performed to achieve <a href="Confusion_and_diffusion" title="wikilink">diffusion</a>, that is, to mix the input bits.</li>
<li>The <a href="linear_combination" title="wikilink">linear combination</a> in step 6 achieves <a href="Confusion_and_diffusion" title="wikilink">confusion</a>, since it compresses the input.</li>
<li>This is just a high level description of what the algorithm does, some more advanced optimizations are used to finally yield a high performing algorithm.</li>
</ul>
<h3 id="example">Example</h3>

<p>We choose concrete values for the parameters <em>n</em>, <em>m</em>, and <em>p</em> as follows: <em>n</em> = 64, <em>m</em>= 16, <em>p</em>= 257. For these parameters, any fixed compression function in the family takes a binary input of length <em>mn</em> = 1024 bits (128 bytes), to an output in the range 

<math display="inline" id="SWIFFT:19">
 <semantics>
  <msubsup>
   <mi>ℤ</mi>
   <mi>p</mi>
   <mi>n</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℤ</ci>
     <ci>n</ci>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}^{n}_{p}
  </annotation>
 </semantics>
</math>

, which has size 

<math display="inline" id="SWIFFT:20">
 <semantics>
  <mrow>
   <msup>
    <mi>p</mi>
    <mi>n</mi>
   </msup>
   <mo>=</mo>
   <msup>
    <mn>257</mn>
    <mn>64</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>p</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">257</cn>
     <cn type="integer">64</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{n}=257^{64}
  </annotation>
 </semantics>
</math>

. An output in 

<math display="inline" id="SWIFFT:21">
 <semantics>
  <msubsup>
   <mi>ℤ</mi>
   <mi>p</mi>
   <mi>n</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℤ</ci>
     <ci>n</ci>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}^{n}_{p}
  </annotation>
 </semantics>
</math>

 can easily be represented using 528 bits (66 bytes).</p>
<h2 id="algebraic-description">Algebraic description</h2>

<p>The SWIFFT functions can be described as a simple algebraic expression over some <a href="polynomial_ring" title="wikilink">polynomial ring</a> 

<math display="inline" id="SWIFFT:22">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

. A family of these functions depends on three main parameters: let 

<math display="inline" id="SWIFFT:23">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 be a power of 2, let 

<math display="inline" id="SWIFFT:24">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>m</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m>0
  </annotation>
 </semantics>
</math>

 be a small integer, and let 

<math display="inline" id="SWIFFT:25">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>p</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p>0
  </annotation>
 </semantics>
</math>

 be a modulus (not necessarily <a class="uri" href="prime" title="wikilink">prime</a>, but is convenient to choose it prime). Define 

<math display="inline" id="SWIFFT:26">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 to be the ring 

<math display="inline" id="SWIFFT:27">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>ℤ</mi>
      <mi>p</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>α</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>α</mi>
       <mi>n</mi>
      </msup>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ℤ</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>α</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>α</ci>
       <ci>n</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=\mathbb{Z}_{p}[\alpha]/(\alpha^{n}+1)
  </annotation>
 </semantics>
</math>

, i.e., the ring of polynomials in 

<math display="inline" id="SWIFFT:28">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 having integer coefficients, modulo 

<math display="inline" id="SWIFFT:29">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="SWIFFT:30">
 <semantics>
  <mrow>
   <msup>
    <mi>α</mi>
    <mi>n</mi>
   </msup>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>α</ci>
     <ci>n</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha^{n}+1
  </annotation>
 </semantics>
</math>

. An element of 

<math display="inline" id="SWIFFT:31">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 can be written as a polynomial of degree <math> having coefficients in 

<math display="inline" id="SWIFFT:32">
 <semantics>
  <msub>
   <mi>Z</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Z</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{p}
  </annotation>
 </semantics>
</math>

. A certain function in the SWIFFT family is specified by 

<math display="inline" id="SWIFFT:33">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 fixed elements 

<math display="inline" id="SWIFFT:34">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mi>m</mi>
    </msub>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>m</ci>
     </apply>
    </list>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1},\ldots,a_{m}\in R
  </annotation>
 </semantics>
</math>

 of the ring 

<math display="inline" id="SWIFFT:35">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

, that are called multipliers. The function corresponds to the following equation over the ring <em>R</em>:</math></p>

<p>

<math display="inline" id="SWIFFT:36">
 <semantics>
  <mrow>
   <msubsup>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>m</mi>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
     <mo>⋅</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>m</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{m}(a_{i}\cdot x_{i})
  </annotation>
 </semantics>
</math>

</p>

<p>The 

<math display="inline" id="SWIFFT:37">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>m</mi>
    </msub>
   </mrow>
   <mo>∈</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>m</ci>
     </apply>
    </list>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\ldots,x_{m}\in R
  </annotation>
 </semantics>
</math>

 are polynomials with binary coefficients, and corresponding to the binary input of length 

<math display="inline" id="SWIFFT:38">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   mn
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="computing-the-polynomial-product">Computing the polynomial product</h2>

<p>To compute the above expression, the main problem is to compute the polynomial products 

<math display="inline" id="SWIFFT:39">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mi>i</mi>
   </msub>
   <mo>⋅</mo>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}\cdot x_{i}
  </annotation>
 </semantics>
</math>

. A fast way to compute these products is given by the <a href="convolution_theorem" title="wikilink">convolution theorem</a>. This says that under certain restrictions the following holds:</p>

<p>

<math display="block" id="SWIFFT:40">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℱ</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>f</mi>
      <mo>*</mo>
      <mi>g</mi>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi class="ltx_font_mathcaligraphic">ℱ</mi>
      <mrow>
       <mo stretchy="false">{</mo>
       <mi>f</mi>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
     <mo>⋅</mo>
     <mi class="ltx_font_mathcaligraphic">ℱ</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>g</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ℱ</ci>
     <set>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>g</ci>
      </apply>
     </set>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <ci>ℱ</ci>
       <set>
        <ci>f</ci>
       </set>
      </apply>
      <ci>ℱ</ci>
     </apply>
     <set>
      <ci>g</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}\{f*g\}=\mathcal{F}\{f\}\cdot\mathcal{F}\{g\}
  </annotation>
 </semantics>
</math>

 Here 

<math display="inline" id="SWIFFT:41">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

 denotes the <a href="Fourier_transform" title="wikilink">Fourier transform</a> and 

<math display="inline" id="SWIFFT:42">
 <semantics>
  <mo>⋅</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⋅</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cdot
  </annotation>
 </semantics>
</math>

 denotes the pointwise product. In the general case of the convolution theorem 

<math display="inline" id="SWIFFT:43">
 <semantics>
  <mo>*</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *
  </annotation>
 </semantics>
</math>

 does not denote multiplication but <a class="uri" href="convolution" title="wikilink">convolution</a>. It can however be shown that polynomial multiplication is a convolution.</p>
<h3 id="fast-fourier-transform">Fast Fourier Transform</h3>

<p>For finding the Fourier transform we will use FFT (<a href="Fast_Fourier_Transform" title="wikilink">Fast Fourier Transform</a>) which finds the transform in 

<math display="inline" id="SWIFFT:44">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n\log(n))
  </annotation>
 </semantics>
</math>

time. The multiplication algorithm now goes as follows: We use FFT to compute (all at once) the <a href="Fourier_coefficients" title="wikilink">Fourier coefficients</a> of each polynomial. Then we pointwise multiply the respective Fourier coefficients of the two polynomials, and finally we us an inverse FFT to return a polynomial of degree <math>.</math></p>
<h3 id="number-theoretic-transform">Number-theoretic transform</h3>

<p>Instead of the normal Fourier transform SWIFFT uses the <a href="Number-theoretic_transform" title="wikilink">Number-theoretic transform</a>. Number-theoretic transform uses roots of unity in 

<math display="inline" id="SWIFFT:45">
 <semantics>
  <msub>
   <mi>ℤ</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ℤ</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}_{p}
  </annotation>
 </semantics>
</math>

 instead of complex roots of unity. To make this work, we need to ensure that 

<math display="inline" id="SWIFFT:46">
 <semantics>
  <msub>
   <mi>ℤ</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ℤ</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}_{p}
  </annotation>
 </semantics>
</math>

 is a <a href="finite_field" title="wikilink">finite field</a>, and that primitive 2<em>n</em><sup>th</sup> roots of unity exist in this field. This can be done by taking 

<math display="inline" id="SWIFFT:47">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 prime such that 

<math display="inline" id="SWIFFT:48">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2n
  </annotation>
 </semantics>
</math>

 divides 

<math display="inline" id="SWIFFT:49">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>p</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p-1
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="parameter-choice">Parameter Choice</h2>

<p>The parameters <em>m</em>,<em>p</em>,<em>n</em> are subject to the following restrictions:</p>
<ul>
<li><em>n</em> must be a power of 2</li>
<li><em>p</em> must be prime</li>
<li><em>p</em>-1 must be a multiple of 2<em>n</em></li>
<li>

<math display="inline" id="SWIFFT:50">
 <semantics>
  <mrow>
   <mi>log</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log(p)
  </annotation>
 </semantics>
</math>

 must be greater than <em>m</em> (otherwise the output will not be smaller than the input)</li>
</ul>

<p>A possible choice is <em>n</em>=64, <em>m</em>=16, <em>p</em>=257. We get a throughput of about 40MB/s, security of about 

<math display="inline" id="SWIFFT:51">
 <semantics>
  <msup>
   <mn>2</mn>
   <mn>106</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <cn type="integer">106</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{106}
  </annotation>
 </semantics>
</math>

 operations for finding collisions, and a digest size of 512 bits.</p>
<h2 id="statistical-properties">Statistical Properties</h2>
<ul>
<li><strong>(Universal hashing).</strong> The SWIFFT family of functions is <a href="Universal_hashing" title="wikilink">universal</a>. It means that for any fixed distinct 

<math display="inline" id="SWIFFT:52">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>,</mo>
   <mi>x</mi>
   <mo>*</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">x</csymbol>
    <times></times>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,x*
  </annotation>
 </semantics>
</math>

, the probability (over the random choice of 

<math display="inline" id="SWIFFT:53">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 from the family) that 

<math display="inline" id="SWIFFT:54">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>*</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <times></times>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=f(x*)
  </annotation>
 </semantics>
</math>

 is the inverse of the size of the range.</li>
<li><strong>(Regularity).</strong> SWIFFT family of compression functions is regular. A function 

<math display="inline" id="SWIFFT:55">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is said to be regular if, for an input 

<math display="inline" id="SWIFFT:56">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 chosen uniformly at random from the domain, the output 

<math display="inline" id="SWIFFT:57">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 is distributed uniformly over the range.</li>
</ul>
<ul>
<li><strong>(Randomness extractor).</strong> SWIFFT is a <a href="randomness_extractor" title="wikilink">randomness extractor</a>. For hash tables and related applications, it is usually desirable for the outputs of the hash function to be distributed uniformly (or as close to uniformly as possible), even when the inputs are not uniform. Hash functions that give such guarantees are known as <a href="randomness_extractor" title="wikilink">randomness extractors</a>, because they <em>distill</em> the non-uniform randomness of the input down to an (almost) uniformly distributed output. Formally, randomness extraction is actually a property of a family of functions, from which one function is chosen at random (and obliviously to the input).</li>
</ul>
<h2 id="cryptographic-properties-and-security">Cryptographic Properties and Security</h2>
<ul>
<li>SWIFFT is not <a href="Pseudorandom_function_family" title="wikilink">pseudorandom</a>, due to linearity. For any function 

<math display="inline" id="SWIFFT:58">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 from our family and any two inputs 

<math display="inline" id="SWIFFT:59">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="SWIFFT:60">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{2}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="SWIFFT:61">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>+</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}+x_{2}
  </annotation>
 </semantics>
</math>

 is also a valid input, we have that 

<math display="inline" id="SWIFFT:62">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{1})+f(x_{2})=f(x_{1}+x_{2})
  </annotation>
 </semantics>
</math>

. This relation is very unlikely to hold for a random function, so an adversary can easily distinguish our functions from a random function.</li>
<li>It is not claimed by the authors that SWIFFT functions behave like a <a href="random_oracle" title="wikilink">random oracle</a>. A function is said to behave like a random oracle if it acts like a truly random function. This differs from pseudorandomness in that the function is fixed and public.</li>
<li>SWIFFT family is <a href="Provably_secure_cryptographic_hash_function" title="wikilink">provably</a> collision resistant (in an asymptotic sense), under a relatively mild assumption about the <a href="Worst-case_complexity" title="wikilink">worst-case</a> difficulty of finding short vectors in cyclic/ideal lattices. This implies that the family is also second preimage resistant.</li>
</ul>
<h3 id="theoretical-security">Theoretical Security</h3>

<p>SWIFFT is an example of a <a href="provably_secure_cryptographic_hash_function" title="wikilink">provably secure cryptographic hash function</a>. As with most security proofs, the security proof of SWIFFT relies on a <a href="Polynomial-time_reduction" title="wikilink">reduction</a> to a certain difficult to solve mathematical problem. Note that this means that the security of SWIFFT relies strongly on the difficulty of this mathematical problem.</p>

<p>The reduction in the case of SWIFFT is to the problem of finding short vectors in cyclic/<a href="Ideal_lattice_cryptography" title="wikilink">ideal lattices</a>. It can be proven that the following holds: Suppose we have an algorithm that for a random version of SWIFFT given by 

<math display="inline" id="SWIFFT:63">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 can find collisions in 

<math display="inline" id="SWIFFT:64">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 within some feasible time 

<math display="inline" id="SWIFFT:65">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

, and with probability 

<math display="inline" id="SWIFFT:66">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

. It is allowed that the algorithm only works in a small but noticeable fraction of the family SWIFFT. Then we can find also an algorithm 

<math display="inline" id="SWIFFT:67">
 <semantics>
  <msub>
   <mi>f</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{2}
  </annotation>
 </semantics>
</math>

 which can <em>always</em> find a short vector in <em>any</em> ideal lattice over the ring 

<math display="inline" id="SWIFFT:68">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ℤ</mi>
     <mi>p</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>α</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>/</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>α</mi>
      <mi>n</mi>
     </msup>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℤ</ci>
      <ci>p</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>α</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>α</ci>
      <ci>n</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}_{p}[\alpha]/(\alpha^{n}+1)
  </annotation>
 </semantics>
</math>

 in some feasible time 

<math display="inline" id="SWIFFT:69">
 <semantics>
  <msub>
   <mi>T</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{2}
  </annotation>
 </semantics>
</math>

, depending on 

<math display="inline" id="SWIFFT:70">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="SWIFFT:71">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

. This means that finding collisions in SWIFFT is at least as difficult as the worst-case scenario of finding short vectors in a lattice over 

<math display="inline" id="SWIFFT:72">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ℤ</mi>
     <mi>p</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>α</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>/</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>α</mi>
      <mi>n</mi>
     </msup>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℤ</ci>
      <ci>p</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>α</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>α</ci>
      <ci>n</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}_{p}[\alpha]/(\alpha^{n}+1)
  </annotation>
 </semantics>
</math>

. At the moment the fastest algorithms for finding short vectors are all exponential in 

<math display="inline" id="SWIFFT:73">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

. Note that this ensures that there is no significant set of "weak instances" where the security of SWIFFT is weak. This guarantee is not given by most other provably secure hash functions.</p>
<h3 id="practical-security">Practical Security</h3>

<p>Known working attacks are: Generalized Birthday Attack, which takes 2<sup>106</sup> operations and inversion attacks which takes 2<sup>448</sup> operations for a standard parameter choice. This is usually considered to be enough to render an attack by an adversary infeasible.</p>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li>Vadim Lyubashevsky, Daniele Micciancio, Chris Peikert, Alon Rosen (2008).<a href="http://www.eecs.harvard.edu/~alon/PAPERS/lattices/swifft.pdf">"SWIFFT: A Modest Proposal for FFT Hashing"</a>.</li>
<li>An ECRYPT hash SWIFFT website. <a class="uri" href="http://ehash.iaik.tugraz.at/wiki/SWIFFT">http://ehash.iaik.tugraz.at/wiki/SWIFFT</a></li>
</ul>

<p>"</p>

<p><a href="Category:Cryptographic_hash_functions" title="wikilink">Category:Cryptographic hash functions</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="http://www.eecs.harvard.edu/~alon/PAPERS/lattices/swifft.pdf">"SWIFFT: A Modest Proposal for FFT Hashing"</a><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
