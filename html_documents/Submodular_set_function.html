<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1488">Submodular set function</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Submodular set function</h1>
<hr/>

<p>In mathematics, a <strong>submodular set function</strong> (also known as a <strong>submodular function</strong>) is a <a href="set_function" title="wikilink">set function</a> whose value, informally, has the property that the difference in the incremental value of the function, that a single element makes when added to an input set , decreases as the size of the input set increases. Submodular functions have a natural <a href="diminishing_returns" title="wikilink">diminishing returns</a> property which makes them suitable for many applications, including <a href="approximation_algorithms" title="wikilink">approximation algorithms</a>, <a href="game_theory" title="wikilink">game theory</a> (as functions modeling user preferences), <a href="electrical_network" title="wikilink">electrical networks</a>, <a href="machine_learning" title="wikilink">machine learning</a>, and <a href="artificial_intelligence" title="wikilink">artificial intelligence</a>.</p>
<h2 id="definition">Definition</h2>

<p>If 

<math display="inline" id="Submodular_set_function:0">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

 is a <a href="set_(mathematics)" title="wikilink">set</a>, a submodular function is a set function 

<math display="inline" id="Submodular_set_function:1">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <mi mathvariant="normal">Ω</mi>
    </msup>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>normal-Ω</ci>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:2^{\Omega}\rightarrow\mathbb{R}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Submodular_set_function:2">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi mathvariant="normal">Ω</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{\Omega}
  </annotation>
 </semantics>
</math>

 denotes the <a href="Power_set#Representing_subsets_as_functions" title="wikilink">power set</a> of 

<math display="inline" id="Submodular_set_function:3">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>


, which satisfies one of the following equivalent definitions.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<ol>
<li>For every 

<math display="inline" id="Submodular_set_function:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>X</mi>
    <mo>,</mo>
    <mi>Y</mi>
   </mrow>
   <mo>⊆</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <list>
     <ci>X</ci>
     <ci>Y</ci>
    </list>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X,Y\subseteq\Omega
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Submodular_set_function:5">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>⊆</mo>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>X</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\subseteq Y
  </annotation>
 </semantics>
</math>

 and every 

<math display="inline" id="Submodular_set_function:6">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mrow>
    <mi mathvariant="normal">Ω</mi>
    <mo>\</mo>
    <mi>Y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <ci>normal-\</ci>
     <ci>normal-Ω</ci>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\Omega\backslash Y
  </annotation>
 </semantics>
</math>

 we have that 

<math display="inline" id="Submodular_set_function:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>X</mi>
       <mo>∪</mo>
       <mrow>
        <mo stretchy="false">{</mo>
        <mi>x</mi>
        <mo stretchy="false">}</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>Y</mi>
       <mo>∪</mo>
       <mrow>
        <mo stretchy="false">{</mo>
        <mi>x</mi>
        <mo stretchy="false">}</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <union></union>
       <ci>X</ci>
       <set>
        <ci>x</ci>
       </set>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>X</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <union></union>
       <ci>Y</ci>
       <set>
        <ci>x</ci>
       </set>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>Y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(X\cup\{x\})-f(X)\geq f(Y\cup\{x\})-f(Y)
  </annotation>
 </semantics>
</math>

.</li>
<li>For every 

<math display="inline" id="Submodular_set_function:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mo>,</mo>
    <mi>T</mi>
   </mrow>
   <mo>⊆</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <list>
     <ci>S</ci>
     <ci>T</ci>
    </list>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S,T\subseteq\Omega
  </annotation>
 </semantics>
</math>


 we have that 

<math display="inline" id="Submodular_set_function:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>S</mi>
       <mo>∪</mo>
       <mi>T</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>S</mi>
       <mo>∩</mo>
       <mi>T</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>S</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>T</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <union></union>
       <ci>S</ci>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <intersect></intersect>
       <ci>S</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(S)+f(T)\geq f(S\cup T)+f(S\cap T)
  </annotation>
 </semantics>
</math>

.</li>
<li>For every 

<math display="inline" id="Submodular_set_function:10">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>⊆</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>X</ci>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\subseteq\Omega
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Submodular_set_function:11">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi mathvariant="normal">Ω</mi>
    <mo>\</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </list>
    <apply>
     <ci>normal-\</ci>
     <ci>normal-Ω</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},x_{2}\in\Omega\backslash X
  </annotation>
 </semantics>
</math>

 we have that 

<math display="inline" id="Submodular_set_function:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>X</mi>
       <mo>∪</mo>
       <mrow>
        <mo stretchy="false">{</mo>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mo stretchy="false">}</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>X</mi>
       <mo>∪</mo>
       <mrow>
        <mo stretchy="false">{</mo>
        <msub>
         <mi>x</mi>
         <mn>2</mn>
        </msub>
        <mo stretchy="false">}</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>X</mi>
       <mo>∪</mo>
       <mrow>
        <mo stretchy="false">{</mo>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>x</mi>
         <mn>2</mn>
        </msub>
        <mo stretchy="false">}</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <union></union>
       <ci>X</ci>
       <set>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
       </set>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <union></union>
       <ci>X</ci>
       <set>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </set>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <union></union>
       <ci>X</ci>
       <set>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </set>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(X\cup\{x_{1}\})+f(X\cup\{x_{2}\})\geq f(X\cup\{x_{1},x_{2}\})+f(X)
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>A nonnegative submodular function is also a <a href="Subadditive_set_function" title="wikilink">subadditive</a> function, but a subadditive function need not be submodular.</p>
<h2 id="types-of-submodular-functions">Types of submodular functions</h2>
<h3 id="monotone">Monotone</h3>

<p>A submodular function 

<math display="inline" id="Submodular_set_function:13">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>


 is <em>monotone</em> if for every 

<math display="inline" id="Submodular_set_function:14">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>⊆</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>T</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\subseteq S
  </annotation>
 </semantics>
</math>

 we have that 

<math display="inline" id="Submodular_set_function:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>T</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(T)\leq f(S)
  </annotation>
 </semantics>
</math>

. Examples of monotone submodular functions include:</p>
<dl>
<dt>Linear functions : Any function of the form 

<math display="inline" id="Submodular_set_function:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>∈</mo>
      <mi>S</mi>
     </mrow>
    </msub>
    <msub>
     <mi>w</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>i</ci>
       <ci>S</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(S)=\sum_{i\in S}w_{i}
  </annotation>
 </semantics>
</math>

 is called a linear function. Additionally if 

<math display="inline" id="Submodular_set_function:17">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>i</mi>
    </mrow>
    <mo>,</mo>
    <msub>
     <mi>w</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <list>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>i</ci>
     </apply>
    </list>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall i,w_{i}\geq 0
  </annotation>
 </semantics>
</math>

 then f is monotone.<br/>
Budget-additive functions : Any function of the form 

<math display="inline" id="Submodular_set_function:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>∈</mo>
        <mi>S</mi>
       </mrow>
      </msub>
      <msub>
       <mi>w</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <min></min>
     <ci>B</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>i</ci>
        <ci>S</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(S)=\min(B,\sum_{i\in S}w_{i})
  </annotation>
 </semantics>
</math>


 for each 

<math display="inline" id="Submodular_set_function:19">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mi>i</mi>
   </msub>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{i}\geq 0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Submodular_set_function:20">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>B</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B\geq 0
  </annotation>
 </semantics>
</math>

 is called budget additive.<br/>
Coverage functions : Let 

<math display="inline" id="Submodular_set_function:21">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>E</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>E</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>E</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Ω</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>n</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega=\{E_{1},E_{2},\ldots,E_{n}\}
  </annotation>
 </semantics>
</math>

 be a collection of subsets of some ground set 

<math display="inline" id="Submodular_set_function:22">
 <semantics>
  <msup>
   <mi mathvariant="normal">Ω</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Ω</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega^{\prime}
  </annotation>
 </semantics>
</math>

. The function 

<math display="inline" id="Submodular_set_function:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msub>
      <mo>∪</mo>
      <mrow>
       <msub>
        <mi>E</mi>
        <mi>i</mi>
       </msub>
       <mo>∈</mo>
       <mi>S</mi>
      </mrow>
     </msub>
     <msub>
      <mi>E</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <union></union>
       <apply>
        <in></in>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>E</ci>
         <ci>i</ci>
        </apply>
        <ci>S</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(S)=|\cup_{E_{i}\in S}E_{i}|
  </annotation>
 </semantics>
</math>


 for 

<math display="inline" id="Submodular_set_function:24">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⊆</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subseteq\Omega
  </annotation>
 </semantics>
</math>

 is called a coverage function. This can be generalized by adding non-negative weights to the elements.<br/>
<a href="Entropy_(information_theory)" title="wikilink">Entropy</a> : Let 

<math display="inline" id="Submodular_set_function:25">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Ω</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>n</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega=\{X_{1},X_{2},\ldots,X_{n}\}
  </annotation>
 </semantics>
</math>

 be a set of <a href="random_variables" title="wikilink">random variables</a>. Then for any 

<math display="inline" id="Submodular_set_function:26">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⊆</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subseteq\Omega
  </annotation>
 </semantics>
</math>

 we have that 

<math display="inline" id="Submodular_set_function:27">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(S)
  </annotation>
 </semantics>
</math>

 is a submodular function, where 

<math display="inline" id="Submodular_set_function:28">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(S)
  </annotation>
 </semantics>
</math>


 is the entropy of the set of random variables 

<math display="inline" id="Submodular_set_function:29">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

<br/>
<a class="uri" href="Matroid" title="wikilink">Matroid</a> <a href="matroid_rank" title="wikilink">rank functions</a> : Let 

<math display="inline" id="Submodular_set_function:30">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>e</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>e</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>e</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Ω</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>e</ci>
      <ci>n</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega=\{e_{1},e_{2},\dots,e_{n}\}
  </annotation>
 </semantics>
</math>

 be the ground set on which a matroid is defined. Then the rank function of the matroid is a submodular function.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></dt>
</dl>
<h3 id="non-monotone">Non-monotone</h3>

<p>A submodular function which is not monotone is called <em>non-monotone</em>.</p>
<h4 id="symmetric">Symmetric</h4>

<p>A non-monotone submodular function 

<math display="inline" id="Submodular_set_function:31">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is called <em>symmetric</em> if for every 

<math display="inline" id="Submodular_set_function:32">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⊆</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subseteq\Omega
  </annotation>
 </semantics>
</math>

 we have that 

<math display="inline" id="Submodular_set_function:33">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">Ω</mi>
      <mo>-</mo>
      <mi>S</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <minus></minus>
      <ci>normal-Ω</ci>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(S)=f(\Omega-S)
  </annotation>
 </semantics>
</math>


. Examples of symmetric non-monotone submodular functions include:</p>
<dl>
<dt>Graph cuts : Let 

<math display="inline" id="Submodular_set_function:34">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>v</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Ω</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>n</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega=\{v_{1},v_{2},\dots,v_{n}\}
  </annotation>
 </semantics>
</math>

 be the vertices of a <a href="graph_(mathematics)" title="wikilink">graph</a>. For any set of vertices 

<math display="inline" id="Submodular_set_function:35">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⊆</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subseteq\Omega
  </annotation>
 </semantics>
</math>

 let 

<math display="inline" id="Submodular_set_function:36">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(S)
  </annotation>
 </semantics>
</math>

 denote the number of edges 

<math display="inline" id="Submodular_set_function:37">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>e</ci>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e=(u,v)
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Submodular_set_function:38">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>u</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\in S
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Submodular_set_function:39">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mrow>
    <mi mathvariant="normal">Ω</mi>
    <mo>-</mo>
    <mi>S</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <apply>
     <minus></minus>
     <ci>normal-Ω</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in\Omega-S
  </annotation>
 </semantics>
</math>

. This can be generalized by adding non-negative weights to the edges.<br/>
<a href="Mutual_information" title="wikilink">Mutual information</a> : Let 

<math display="inline" id="Submodular_set_function:40">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Ω</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>n</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega=\{X_{1},X_{2},\ldots,X_{n}\}
  </annotation>
 </semantics>
</math>

 be a set of <a href="random_variable" title="wikilink">random variables</a>. Then for any 

<math display="inline" id="Submodular_set_function:41">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⊆</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subseteq\Omega
  </annotation>
 </semantics>
</math>

 we have that 

<math display="inline" id="Submodular_set_function:42">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>I</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo>;</mo>
     <mrow>
      <mi mathvariant="normal">Ω</mi>
      <mo>-</mo>
      <mi>S</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <times></times>
     <ci>I</ci>
     <list>
      <ci>S</ci>
      <apply>
       <minus></minus>
       <ci>normal-Ω</ci>
       <ci>S</ci>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(S)=I(S;\Omega-S)
  </annotation>
 </semantics>
</math>

 is a submodular function, where 

<math display="inline" id="Submodular_set_function:43">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>;</mo>
    <mrow>
     <mi mathvariant="normal">Ω</mi>
     <mo>-</mo>
     <mi>S</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <list>
     <ci>S</ci>
     <apply>
      <minus></minus>
      <ci>normal-Ω</ci>
      <ci>S</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(S;\Omega-S)
  </annotation>
 </semantics>
</math>


 is the mutual information.</dt>
</dl>
<h4 id="asymmetric">Asymmetric</h4>

<p>A non-monotone submodular function which is not symmetric is called asymmetric.</p>
<dl>
<dt>Directed cuts : Let 

<math display="inline" id="Submodular_set_function:44">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>v</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Ω</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>n</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega=\{v_{1},v_{2},\dots,v_{n}\}
  </annotation>
 </semantics>
</math>

 be the vertices of a <a href="directed_graph" title="wikilink">directed graph</a>. For any set of vertices 

<math display="inline" id="Submodular_set_function:45">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⊆</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subseteq\Omega
  </annotation>
 </semantics>
</math>

 let 

<math display="inline" id="Submodular_set_function:46">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(S)
  </annotation>
 </semantics>
</math>

 denote the number of edges 

<math display="inline" id="Submodular_set_function:47">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>e</ci>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e=(u,v)
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Submodular_set_function:48">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>u</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\in S
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Submodular_set_function:49">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>∈</mo>
   <mrow>
    <mi mathvariant="normal">Ω</mi>
    <mo>-</mo>
    <mi>S</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>v</ci>
    <apply>
     <minus></minus>
     <ci>normal-Ω</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\in\Omega-S
  </annotation>
 </semantics>
</math>

. This can be generalized by adding non-negative weights to the directed edges.</dt>
</dl>
<h2 id="continuous-extensions">Continuous extensions</h2>
<h3 id="lovász-extension">Lovász extension</h3>

<p>This extension is named after mathematician <a href="László_Lovász" title="wikilink">László Lovász</a>. Consider any vector 

<math display="inline" id="Submodular_set_function:50">
 <semantics>
  <mrow>
   <mi>𝕩</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝕩</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{x}=\{x_{1},x_{2},\dots,x_{n}\}
  </annotation>
 </semantics>
</math>

 such that each 

<math display="inline" id="Submodular_set_function:51">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>≤</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq x_{i}\leq 1
  </annotation>
 </semantics>
</math>

. Then the Lovász extension is defined as 

<math display="inline" id="Submodular_set_function:52">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mi>L</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝕩</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>𝔼</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo stretchy="false">{</mo>
        <mi>i</mi>
        <mo stretchy="false">|</mo>
        <mrow>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo>≥</mo>
         <mi>λ</mi>
        </mrow>
        <mo stretchy="false">}</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>L</ci>
     </apply>
     <ci>𝕩</ci>
    </apply>
    <apply>
     <times></times>
     <ci>𝔼</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="latexml">conditional-set</csymbol>
       <ci>i</ci>
       <apply>
        <geq></geq>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <ci>λ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{L}(\mathbb{x})=\mathbb{E}(f(\{i|x_{i}\geq\lambda\}))
  </annotation>
 </semantics>
</math>

 where the expectation is over 

<math display="inline" id="Submodular_set_function:53">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>


 chosen from the <a href="uniform_distribution_(continuous)" title="wikilink">uniform distribution</a> on the interval 

<math display="inline" id="Submodular_set_function:54">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [0,1]
  </annotation>
 </semantics>
</math>

. The Lovász extension is a convex function.</p>
<h3 id="multilinear-extension">Multilinear extension</h3>

<p>Consider any vector 

<math display="inline" id="Submodular_set_function:55">
 <semantics>
  <mrow>
   <mi>𝕩</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝕩</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{x}=\{x_{1},x_{2},\ldots,x_{n}\}
  </annotation>
 </semantics>
</math>

 such that each 

<math display="inline" id="Submodular_set_function:56">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>≤</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq x_{i}\leq 1
  </annotation>
 </semantics>
</math>

. Then the multilinear extension is defined as 

<math display="inline" id="Submodular_set_function:57">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝕩</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>S</mi>
      <mo>⊆</mo>
      <mi mathvariant="normal">Ω</mi>
     </mrow>
    </msub>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∏</mo>
       <mrow>
        <mi>i</mi>
        <mo>∈</mo>
        <mi>S</mi>
       </mrow>
      </msub>
      <mrow>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <msub>
         <mo largeop="true" symmetric="true">∏</mo>
         <mrow>
          <mi>i</mi>
          <mo>∉</mo>
          <mi>S</mi>
         </mrow>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <msub>
           <mi>x</mi>
           <mi>i</mi>
          </msub>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>𝕩</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <subset></subset>
       <ci>S</ci>
       <ci>normal-Ω</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>S</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <in></in>
         <ci>i</ci>
         <ci>S</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <csymbol cd="latexml">product</csymbol>
          <apply>
           <notin></notin>
           <ci>i</ci>
           <ci>S</ci>
          </apply>
         </apply>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\mathbb{x})=\sum_{S\subseteq\Omega}f(S)\prod_{i\in S}x_{i}\prod_{i\notin S}(%
1-x_{i})
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="convex-closure">Convex closure</h3>

<p>Consider any vector 

<math display="inline" id="Submodular_set_function:58">
 <semantics>
  <mrow>
   <mi>𝕩</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝕩</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{x}=\{x_{1},x_{2},\dots,x_{n}\}
  </annotation>
 </semantics>
</math>


 such that each 

<math display="inline" id="Submodular_set_function:59">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>≤</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq x_{i}\leq 1
  </annotation>
 </semantics>
</math>

. Then the convex closure is defined as 

<math display="inline" id="Submodular_set_function:60">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>-</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝕩</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mo largeop="true" symmetric="true">∑</mo>
        <mi>S</mi>
       </msub>
       <mrow>
        <msub>
         <mi>α</mi>
         <mi>S</mi>
        </msub>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>S</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mrow>
        <mrow>
         <msub>
          <mo largeop="true" symmetric="true">∑</mo>
          <mi>S</mi>
         </msub>
         <mrow>
          <msub>
           <mi>α</mi>
           <mi>S</mi>
          </msub>
          <msub>
           <mn>1</mn>
           <mi>S</mi>
          </msub>
         </mrow>
        </mrow>
        <mo>=</mo>
        <mi>𝕩</mi>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mrow>
         <mrow>
          <msub>
           <mo largeop="true" symmetric="true">∑</mo>
           <mi>S</mi>
          </msub>
          <msub>
           <mi>α</mi>
           <mi>S</mi>
          </msub>
         </mrow>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mo>,</mo>
        <mrow>
         <msub>
          <mi>α</mi>
          <mi>S</mi>
         </msub>
         <mo>≥</mo>
         <mn>0</mn>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <minus></minus>
     </apply>
     <ci>𝕩</ci>
    </apply>
    <apply>
     <min></min>
     <apply>
      <ci>normal-:</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>S</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>α</ci>
         <ci>S</ci>
        </apply>
        <ci>f</ci>
        <ci>S</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <eq></eq>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <ci>S</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>α</ci>
           <ci>S</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <cn type="integer">1</cn>
           <ci>S</ci>
          </apply>
         </apply>
        </apply>
        <ci>𝕩</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">formulae-sequence</csymbol>
        <apply>
         <eq></eq>
         <apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <ci>S</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>α</ci>
           <ci>S</ci>
          </apply>
         </apply>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <geq></geq>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>α</ci>
          <ci>S</ci>
         </apply>
         <cn type="integer">0</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{-}(\mathbb{x})=\min(\sum_{S}\alpha_{S}f(S):\sum_{S}\alpha_{S}1_{S}=\mathbb{%
x},\sum_{S}\alpha_{S}=1,\alpha_{S}\geq 0)
  </annotation>
 </semantics>
</math>

. It can be shown that 

<math display="inline" id="Submodular_set_function:61">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mi>L</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝕩</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>-</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝕩</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>L</ci>
     </apply>
     <ci>𝕩</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <minus></minus>
     </apply>
     <ci>𝕩</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{L}(\mathbb{x})=f^{-}(\mathbb{x})
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="concave-closure">Concave closure</h3>

<p>Consider any vector 

<math display="inline" id="Submodular_set_function:62">
 <semantics>
  <mrow>
   <mi>𝕩</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝕩</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{x}=\{x_{1},x_{2},\dots,x_{n}\}
  </annotation>
 </semantics>
</math>

 such that each 

<math display="inline" id="Submodular_set_function:63">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>≤</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq x_{i}\leq 1
  </annotation>
 </semantics>
</math>


. Then the concave closure is defined as 

<math display="inline" id="Submodular_set_function:64">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>+</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝕩</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>max</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mo largeop="true" symmetric="true">∑</mo>
        <mi>S</mi>
       </msub>
       <mrow>
        <msub>
         <mi>α</mi>
         <mi>S</mi>
        </msub>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>S</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mrow>
        <mrow>
         <msub>
          <mo largeop="true" symmetric="true">∑</mo>
          <mi>S</mi>
         </msub>
         <mrow>
          <msub>
           <mi>α</mi>
           <mi>S</mi>
          </msub>
          <msub>
           <mn>1</mn>
           <mi>S</mi>
          </msub>
         </mrow>
        </mrow>
        <mo>=</mo>
        <mi>𝕩</mi>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mrow>
         <mrow>
          <msub>
           <mo largeop="true" symmetric="true">∑</mo>
           <mi>S</mi>
          </msub>
          <msub>
           <mi>α</mi>
           <mi>S</mi>
          </msub>
         </mrow>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mo>,</mo>
        <mrow>
         <msub>
          <mi>α</mi>
          <mi>S</mi>
         </msub>
         <mo>≥</mo>
         <mn>0</mn>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <plus></plus>
     </apply>
     <ci>𝕩</ci>
    </apply>
    <apply>
     <max></max>
     <apply>
      <ci>normal-:</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>S</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>α</ci>
         <ci>S</ci>
        </apply>
        <ci>f</ci>
        <ci>S</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <eq></eq>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <ci>S</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>α</ci>
           <ci>S</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <cn type="integer">1</cn>
           <ci>S</ci>
          </apply>
         </apply>
        </apply>
        <ci>𝕩</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">formulae-sequence</csymbol>
        <apply>
         <eq></eq>
         <apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <ci>S</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>α</ci>
           <ci>S</ci>
          </apply>
         </apply>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <geq></geq>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>α</ci>
          <ci>S</ci>
         </apply>
         <cn type="integer">0</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{+}(\mathbb{x})=\max(\sum_{S}\alpha_{S}f(S):\sum_{S}\alpha_{S}1_{S}=\mathbb{%
x},\sum_{S}\alpha_{S}=1,\alpha_{S}\geq 0)
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="properties">Properties</h2>
<ol>
<li>The class of submodular functions is <a href="closure_(mathematics)" title="wikilink">closed</a> under non-negative <a href="linear_combination" title="wikilink">linear combinations</a>. Consider any submodular function 

<math display="inline" id="Submodular_set_function:65">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>f</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>f</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{1},f_{2},\ldots,f_{k}
  </annotation>
 </semantics>
</math>

 and non-negative numbers 

<math display="inline" id="Submodular_set_function:66">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>α</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>α</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{1},\alpha_{2},\ldots,\alpha_{k}
  </annotation>
 </semantics>
</math>

. Then the function 

<math display="inline" id="Submodular_set_function:67">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 defined by 

<math display="inline" id="Submodular_set_function:68">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>k</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>f</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>i</ci>
      </apply>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(S)=\sum_{i=1}^{k}\alpha_{i}f_{i}(S)
  </annotation>
 </semantics>
</math>


 is submodular. Furthermore, for any submodular function 

<math display="inline" id="Submodular_set_function:69">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

, the function defined by 

<math display="inline" id="Submodular_set_function:70">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">Ω</mi>
      <mo>∖</mo>
      <mi>S</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <setdiff></setdiff>
      <ci>normal-Ω</ci>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(S)=f(\Omega\setminus S)
  </annotation>
 </semantics>
</math>

 is submodular. The function 

<math display="inline" id="Submodular_set_function:71">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>S</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <min></min>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>S</ci>
     </apply>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(S)=\min(f(S),c)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Submodular_set_function:72">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 is a real number, is submodular whenever 

<math display="inline" id="Submodular_set_function:73">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>


 is monotonic.</li>
<li>If 

<math display="inline" id="Submodular_set_function:74">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <mi mathvariant="normal">Ω</mi>
    </msup>
    <mo>→</mo>
    <msub>
     <mi>ℝ</mi>
     <mo>+</mo>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>normal-Ω</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℝ</ci>
      <plus></plus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:2^{\Omega}\rightarrow\mathbb{R}_{+}
  </annotation>
 </semantics>
</math>

 is a submodular function then 

<math display="inline" id="Submodular_set_function:75">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <mi mathvariant="normal">Ω</mi>
    </msup>
    <mo>→</mo>
    <msub>
     <mi>ℝ</mi>
     <mo>+</mo>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>g</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>normal-Ω</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ℝ</ci>
      <plus></plus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g:2^{\Omega}\rightarrow\mathbb{R}_{+}
  </annotation>
 </semantics>
</math>

 defined as 

<math display="inline" id="Submodular_set_function:76">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>S</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(S)=\phi(f(S))
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Submodular_set_function:77">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 is a <a href="concave_function" title="wikilink">concave</a> function, is also a submodular function.</li>
<li>Consider a random process where a set 

<math display="inline" id="Submodular_set_function:78">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>


 is chosen with each element in 

<math display="inline" id="Submodular_set_function:79">
 <semantics>
  <mi mathvariant="normal">Ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

 being included in 

<math display="inline" id="Submodular_set_function:80">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 independently with probability 

<math display="inline" id="Submodular_set_function:81">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

. Then the following inequality is true 

<math display="inline" id="Submodular_set_function:82">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝔼</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>T</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi mathvariant="normal">Ω</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>p</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi mathvariant="normal">∅</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>𝔼</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>f</ci>
      <ci>normal-Ω</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>p</ci>
      </apply>
      <ci>f</ci>
      <emptyset></emptyset>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}[f(T)]\geq pf(\Omega)+(1-p)f(\varnothing)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Submodular_set_function:83">
 <semantics>
  <mi mathvariant="normal">∅</mi>
  <annotation-xml encoding="MathML-Content">
   <emptyset></emptyset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varnothing
  </annotation>
 </semantics>
</math>


 is the empty set. More generally consider the following random process where a set 

<math display="inline" id="Submodular_set_function:84">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is constructed as follows. For each of 

<math display="inline" id="Submodular_set_function:85">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>≤</mo>
    <mi>i</mi>
    <mo>≤</mo>
    <mi>l</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>A</mi>
     <mi>i</mi>
    </msub>
    <mo>⊆</mo>
    <mi mathvariant="normal">Ω</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <leq></leq>
      <cn type="integer">1</cn>
      <ci>i</ci>
     </apply>
     <apply>
      <leq></leq>
      <share href="#.cmml">
      </share>
      <ci>l</ci>
     </apply>
    </apply>
    <apply>
     <subset></subset>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-Ω</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq i\leq l,A_{i}\subseteq\Omega
  </annotation>
 </semantics>
</math>

 construct 

<math display="inline" id="Submodular_set_function:86">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{i}
  </annotation>
 </semantics>
</math>

 by including each element in 

<math display="inline" id="Submodular_set_function:87">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{i}
  </annotation>
 </semantics>
</math>

 independently into 

<math display="inline" id="Submodular_set_function:88">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{i}
  </annotation>
 </semantics>
</math>


 with probability 

<math display="inline" id="Submodular_set_function:89">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i}
  </annotation>
 </semantics>
</math>

. Furthermore let 

<math display="inline" id="Submodular_set_function:90">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo>∪</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>l</mi>
    </msubsup>
    <msub>
     <mi>S</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <union></union>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>l</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\cup_{i=1}^{l}S_{i}
  </annotation>
 </semantics>
</math>

. Then the following inequality is true 

<math display="inline" id="Submodular_set_function:91">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝔼</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>S</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>R</mi>
      <mo>⊆</mo>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>l</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </msub>
    <mrow>
     <msub>
      <mi mathvariant="normal">Π</mi>
      <mrow>
       <mi>i</mi>
       <mo>∈</mo>
       <mi>R</mi>
      </mrow>
     </msub>
     <msub>
      <mi>p</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi mathvariant="normal">Π</mi>
      <mrow>
       <mi>i</mi>
       <mo>∉</mo>
       <mi>R</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <msub>
        <mi>p</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mo>∪</mo>
        <mrow>
         <mi>i</mi>
         <mo>∈</mo>
         <mi>R</mi>
        </mrow>
       </msub>
       <msub>
        <mi>A</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>𝔼</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <subset></subset>
       <ci>R</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>l</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Π</ci>
       <apply>
        <in></in>
        <ci>i</ci>
        <ci>R</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Π</ci>
       <apply>
        <notin></notin>
        <ci>i</ci>
        <ci>R</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <ci>f</ci>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <union></union>
        <apply>
         <in></in>
         <ci>i</ci>
         <ci>R</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}[f(S)]\geq\sum_{R\subseteq[l]}\Pi_{i\in R}p_{i}\Pi_{i\notin R}(1-p_{%
i})f(\cup_{i\in R}A_{i})
  </annotation>
 </semantics>
</math>

.</li>
</ol>
<h2 id="optimization-problems">Optimization problems</h2>

<p>Submodular functions have properties which are very similar to <a href="convex_function" title="wikilink">convex</a> and <a href="concave_function" title="wikilink">concave functions</a>. For this reason, an <a href="optimization_problem" title="wikilink">optimization problem</a> which concerns optimizing a convex or concave function can also be described as the problem of maximizing or minimizing a submodular function subject to some constraints.</p>
<h3 id="submodular-minimization">Submodular Minimization</h3>

<p>The simplest minimization problem is to find a set 

<math display="inline" id="Submodular_set_function:92">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⊆</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subseteq\Omega
  </annotation>
 </semantics>
</math>

 which minimizes a submodular function subject to no constraints. This problem is computable in (strongly)<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> <a href="polynomial_time" title="wikilink">polynomial time</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Computing the <a href="minimum_cut" title="wikilink">minimum cut</a> in a graph is a special case of this general minimization problem. Unfortunately, however, even simple constraints like cardinality lower bound constraints make this problem <a href="NP_hard" title="wikilink">NP hard</a>, with polynomial lower bound approximation factors.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h3 id="submodular-maximization">Submodular Maximization</h3>

<p>Unlike minimization, maximization of submodular functions is usually <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>. Many problems, such as <a href="max_cut" title="wikilink">max cut</a> and the <a href="maximum_coverage_problem" title="wikilink">maximum coverage problem</a>, can be cast as special cases of this general maximization problem under suitable constraints. Typically, the approximation algorithms for these problems are based on either <a href="greedy_algorithm" title="wikilink">greedy algorithms</a> or <a href="local_search_(optimization)" title="wikilink">local search algorithms</a>. The problem of maximizing a symmetric non-monotone submodular function subject to no constraints admits a 1/2 approximation algorithm.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Computing the <a href="maximum_cut" title="wikilink">maximum cut</a> of a graph is a special case of this problem. The more general problem of maximizing an arbitrary non-monotone submodular function subject to no constraints also admits a 1/2 approximation algorithm.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> The problem of maximizing a monotone submodular function subject to a cardinality constraint admits a 

<math display="inline" id="Submodular_set_function:93">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mi>e</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-1/e
  </annotation>
 </semantics>
</math>


 approximation algorithm.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> The <a href="maximum_coverage_problem" title="wikilink">maximum coverage problem</a> is a special case of this problem. The more general problem of maximizing a monotone submodular function subject to a <a class="uri" href="matroid" title="wikilink">matroid</a> constraint also admits a 

<math display="inline" id="Submodular_set_function:94">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mi>e</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-1/e
  </annotation>
 </semantics>
</math>

 approximation algorithm.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> Many of these algorithms can be unified within a semi-differential based framework of algorithms.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h3 id="related-optimization-problems">Related Optimization Problems</h3>

<p>Apart from submodular minimization and maximization, another natural problem is Difference of Submodular Optimization.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> Unfortunately, this problem is not only NP hard, but also inapproximable.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> A related optimization problem is minimize or maximize a submodular function, subject to a submodular level set constraint (also called submodular optimization subject to submodular cover or submodular knapsack constraint). This problem admits bounded approximation guarantees.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> Another optimization problem involves partitioning data based on a submodular function, so as to maximize the average welfare. This problem is called the submodular welfare problem.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>
<h2 id="applications">Applications</h2>

<p>Submodular functions naturally occur in several real world applications, in <a class="uri" href="economics" title="wikilink">economics</a>, <a href="game_theory" title="wikilink">game theory</a>, <a href="machine_learning" title="wikilink">machine learning</a> and <a href="computer_vision" title="wikilink">computer vision</a>. Owing the diminishing returns property, submodular functions naturally model costs of items, since there is often a larger discount, with an increase in the items one buys. Submodular functions model notions of complexity, similarity and cooperation when they appear in minimization problems. In maximization problems, on the other hand, they model notions of diversity, information and coverage. For more information on applications of submodularity, particularly in machine learning, see <a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a><a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a><a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Supermodular_function" title="wikilink">Supermodular function</a></li>
<li><a class="uri" href="Matroid" title="wikilink">Matroid</a>, <a class="uri" href="Polymatroid" title="wikilink">Polymatroid</a></li>
<li><a href="Utility_functions_on_indivisible_goods" title="wikilink">Utility functions on indivisible goods</a></li>
</ul>
<h2 id="citations">Citations</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a class="uri" href="http://www.cs.berkeley.edu/~stefje/references.html">http://www.cs.berkeley.edu/~stefje/references.html</a> has a longer bibliography</li>
</ul>

<p>"</p>

<p><a href="Category:Combinatorial_optimization" title="wikilink"> </a> <a href="Category:Approximation_algorithms" title="wikilink"> </a> <a href="Category:Matroid_theory" title="wikilink">Matroid theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">Fujishige (2005) p.22<a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
</ol>
</section>
</body>
</html>
