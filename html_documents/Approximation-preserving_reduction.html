<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1477">Approximation-preserving reduction</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Approximation-preserving reduction</h1>
<hr/>

<p>In <a href="computability_theory" title="wikilink">computability theory</a> and <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, especially the study of <a href="Approximation_algorithm" title="wikilink">approximation algorithms</a>, an <strong>approximation-preserving reduction</strong> is an <a class="uri" href="algorithm" title="wikilink">algorithm</a> for transforming one <a href="computational_problem" title="wikilink">optimization problem</a> into another problem, such that the distance of solutions from optimal is preserved to some degree. Approximation-preserving reductions are a subset of more general <a href="Reduction_(complexity)" title="wikilink">reductions</a> in complexity theory; the difference is that approximation-preserving reductions usually make statements on <a href="Approximation_algorithm" title="wikilink">approximation problems</a> or <a href="Optimization_problem" title="wikilink">optimization problems</a>, as opposed to <a href="Decision_problem" title="wikilink">decision problems</a>.</p>

<p>Intuitively, problem A is reducible to problem B via an approximation-preserving reduction if, given an instance of problem A and a (possibly approximate) solver for problem B, one can convert the instance of problem A into an instance of problem B, apply the solver for problem B, and recover a solution for problem A that also has some guarantee of approximation.</p>
<h2 id="definition">Definition</h2>

<p>Unlike reductions on decision problems, an approximation-preserving reduction must preserve more than the truth of the problem instances when reducing from one problem to another. It must also maintain some guarantee on the relationship between the cost of the solution to the cost of the optimum in both problems. To formalize:</p>

<p>Let 

<math display="inline" id="Approximation-preserving_reduction:0">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Approximation-preserving_reduction:1">
<semantics>
<mi>B</mi>
<annotation-xml encoding="MathML-Content">
<ci>B</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   B
  </annotation>
</semantics>
</math>

 be optimization problems.</p>

<p>Let 

<math display="inline" id="Approximation-preserving_reduction:2">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

 be an instance of problem 

<math display="inline" id="Approximation-preserving_reduction:3">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>


, with optimal solution 

<math display="inline" id="Approximation-preserving_reduction:4">
<semantics>
<mrow>
<mi>O</mi>
<mi>P</mi>
<mi>T</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>O</ci>
<ci>P</ci>
<ci>T</ci>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   OPT(x)
  </annotation>
</semantics>
</math>

. Let 

<math display="inline" id="Approximation-preserving_reduction:5">
<semantics>
<mrow>
<msub>
<mi>c</mi>
<mi>A</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>c</ci>
<ci>A</ci>
</apply>
<interval closure="open">
<ci>x</ci>
<ci>y</ci>
</interval>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   c_{A}(x,y)
  </annotation>
</semantics>
</math>

 denote the cost of a solution 

<math display="inline" id="Approximation-preserving_reduction:6">
<semantics>
<mi>y</mi>
<annotation-xml encoding="MathML-Content">
<ci>y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   y
  </annotation>
</semantics>
</math>

 to an instance 

<math display="inline" id="Approximation-preserving_reduction:7">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

 of problem 

<math display="inline" id="Approximation-preserving_reduction:8">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>


. This is also the metric used to determine which solution is considered optimal.</p>

<p>An <strong>approximation-preserving reduction</strong> is a pair of functions 

<math display="inline" id="Approximation-preserving_reduction:9">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<mi>f</mi>
<mo>,</mo>
<mi>g</mi>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<interval closure="open">
<ci>f</ci>
<ci>g</ci>
</interval>
</annotation-xml>
<annotation encoding="application/x-tex">
   (f,g)
  </annotation>
</semantics>
</math>

 (which often must be computable in polynomial time), such that:</p>
<ul>
<li>
<math display="inline" id="Approximation-preserving_reduction:10">
<semantics>
<mi>f</mi>
<annotation-xml encoding="MathML-Content">
<ci>f</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   f
  </annotation>
</semantics>
</math>

 maps an <em>instance</em>
<math display="inline" id="Approximation-preserving_reduction:11">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

 of 

<math display="inline" id="Approximation-preserving_reduction:12">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

 to an <em>instance</em>
<math display="inline" id="Approximation-preserving_reduction:13">
<semantics>
<msup>
<mi>x</mi>
<mo>′</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<ci>normal-′</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x^{\prime}
  </annotation>
</semantics>
</math>


 of 

<math display="inline" id="Approximation-preserving_reduction:14">
<semantics>
<mi>B</mi>
<annotation-xml encoding="MathML-Content">
<ci>B</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   B
  </annotation>
</semantics>
</math>

.</li>
<li>
<math display="inline" id="Approximation-preserving_reduction:15">
<semantics>
<mi>g</mi>
<annotation-xml encoding="MathML-Content">
<ci>g</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   g
  </annotation>
</semantics>
</math>

 maps a <em>solution</em>
<math display="inline" id="Approximation-preserving_reduction:16">
<semantics>
<msup>
<mi>y</mi>
<mo>′</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>y</ci>
<ci>normal-′</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   y^{\prime}
  </annotation>
</semantics>
</math>

 of 

<math display="inline" id="Approximation-preserving_reduction:17">
<semantics>
<mi>B</mi>
<annotation-xml encoding="MathML-Content">
<ci>B</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   B
  </annotation>
</semantics>
</math>

 to a <em>solution</em>
<math display="inline" id="Approximation-preserving_reduction:18">
<semantics>
<mi>y</mi>
<annotation-xml encoding="MathML-Content">
<ci>y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   y
  </annotation>
</semantics>
</math>


 of 

<math display="inline" id="Approximation-preserving_reduction:19">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

.</li>
<li>
<math display="inline" id="Approximation-preserving_reduction:20">
<semantics>
<mi>g</mi>
<annotation-xml encoding="MathML-Content">
<ci>g</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   g
  </annotation>
</semantics>
</math>

 preserves some guarantee of the solution's <em><a href="Approximation_algorithm#Performance_guarantees" title="wikilink">performance</a>,</em> or <em>approximation ratio</em>, defined as 

<math display="inline" id="Approximation-preserving_reduction:21">
<semantics>
<mrow>
<mrow>
<msub>
<mi>R</mi>
<mi>A</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>max</mi>
<mrow>
<mo>(</mo>
<mfrac>
<mrow>
<msub>
<mi>c</mi>
<mi>A</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mrow>
<mi>O</mi>
<mi>P</mi>
<mi>T</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mrow>
<msub>
<mi>c</mi>
<mi>A</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
<mo>,</mo>
<mfrac>
<mrow>
<msub>
<mi>c</mi>
<mi>A</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mrow>
<msub>
<mi>c</mi>
<mi>A</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mrow>
<mi>O</mi>
<mi>P</mi>
<mi>T</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
<mo>)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>A</ci>
</apply>
<interval closure="open">
<ci>x</ci>
<ci>y</ci>
</interval>
</apply>
<apply>
<max></max>
<apply>
<divide></divide>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>c</ci>
<ci>A</ci>
</apply>
<interval closure="open">
<ci>x</ci>
<apply>
<times></times>
<ci>O</ci>
<ci>P</ci>
<ci>T</ci>
<ci>x</ci>
</apply>
</interval>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>c</ci>
<ci>A</ci>
</apply>
<interval closure="open">
<ci>x</ci>
<ci>y</ci>
</interval>
</apply>
</apply>
<apply>
<divide></divide>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>c</ci>
<ci>A</ci>
</apply>
<interval closure="open">
<ci>x</ci>
<ci>y</ci>
</interval>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>c</ci>
<ci>A</ci>
</apply>
<interval closure="open">
<ci>x</ci>
<apply>
<times></times>
<ci>O</ci>
<ci>P</ci>
<ci>T</ci>
<ci>x</ci>
</apply>
</interval>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   R_{A}(x,y)=\max\left(\frac{c_{A}(x,OPT(x))}{c_{A}(x,y)},\frac{c_{A}(x,y)}{c_{A%
}(x,OPT(x))}\right)
  </annotation>
</semantics>
</math>

.</li>
</ul>
<h2 id="types-of-approximation-preserving-reductions">Types of approximation-preserving reductions</h2>

<p>There are many different types of approximation-preserving reductions, all of which have a different guarantee (the third point in the definition above). However, unlike with other reductions, approximation-preserving reductions often overlap in what properties they demonstrate on optimization problems (e.g. complexity class membership or completeness, or inapproximability). The different types of reductions are used instead as varying reduction techniques, in that the applicable reduction which is most easily adapted to the problem is used.</p>

<p>Not all types of approximation-preserving reductions can be used to show membership in all approximability complexity classes, the most notable of which are <a class="uri" href="PTAS" title="wikilink">PTAS</a> and <a class="uri" href="APX" title="wikilink">APX</a>. A reduction below <strong>preserves membership</strong> in a complexity class C if, given a problem A that reduces to problem B via the reduction scheme, and B is in C, then A is in C as well. Some reductions shown below only preserve membership in APX or PTAS, but not the other. Because of this, careful choice must be made when selecting an approximation-preserving reductions, especially for the purpose of proving <a href="Complete_(complexity)" title="wikilink">completeness</a> of a problem within a complexity class.</p>

<p>Crescenzi suggests that the three most ideal styles of reduction, for both ease of use and proving power, are PTAS reduction, AP reduction, and L-reduction. <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The reduction descriptions that follow are from Crescenzi's survey of approximation-preserving reductions.</p>
<h3 id="strict-reduction">Strict reduction</h3>

<p><strong>Strict reduction</strong> is the simplest type of approximation-preserving reduction. In a strict reduction, the approximation ratio of a solution y' to an instance x' of a problem B must be at most as good as the approximation ratio of the corresponding solution y to instance x of problem A. In other words:</p>

<p>
<math display="block" id="Approximation-preserving_reduction:22">
<semantics>
<mrow>
<mrow>
<msub>
<mi>R</mi>
<mi>A</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>≤</mo>
<mrow>
<msub>
<mi>R</mi>
<mi>B</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>x</mi>
<mo>′</mo>
</msup>
<mo>,</mo>
<msup>
<mi>y</mi>
<mo>′</mo>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<leq></leq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>A</ci>
</apply>
<interval closure="open">
<ci>x</ci>
<ci>y</ci>
</interval>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>B</ci>
</apply>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<ci>normal-′</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>y</ci>
<ci>normal-′</ci>
</apply>
</interval>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   R_{A}(x,y)\leq R_{B}(x^{\prime},y^{\prime})
  </annotation>
</semantics>
</math>

 for 

<math display="inline" id="Approximation-preserving_reduction:23">
<semantics>
<mrow>
<mrow>
<msup>
<mi>x</mi>
<mo>′</mo>
</msup>
<mo>=</mo>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
<mrow>
<mi>y</mi>
<mo>=</mo>
<mrow>
<mi>g</mi>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>y</mi>
<mo>′</mo>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<ci>normal-′</ci>
</apply>
<apply>
<times></times>
<ci>f</ci>
<ci>x</ci>
</apply>
</apply>
<apply>
<eq></eq>
<ci>y</ci>
<apply>
<times></times>
<ci>g</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>y</ci>
<ci>normal-′</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x^{\prime}=f(x),y=g(y^{\prime})
  </annotation>
</semantics>
</math>


.</p>

<p>Strict reduction is the most straightforward: if a strict reduction from problem A to problem B exists, then problem A can always be approximated to at least as good a ratio as problem B. Strict reduction preserves membership in both PTAS and APX.</p>

<p>There exists a similar concept of a <strong>S-reduction,</strong> for which 

<math display="inline" id="Approximation-preserving_reduction:24">
<semantics>
<mrow>
<mrow>
<msub>
<mi>c</mi>
<mi>A</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msub>
<mi>c</mi>
<mi>B</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>x</mi>
<mo>′</mo>
</msup>
<mo>,</mo>
<msup>
<mi>y</mi>
<mo>′</mo>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>c</ci>
<ci>A</ci>
</apply>
<interval closure="open">
<ci>x</ci>
<ci>y</ci>
</interval>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>c</ci>
<ci>B</ci>
</apply>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<ci>normal-′</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>y</ci>
<ci>normal-′</ci>
</apply>
</interval>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   c_{A}(x,y)=c_{B}(x^{\prime},y^{\prime})
  </annotation>
</semantics>
</math>

, and the optima of the two corresponding instances must have the same cost as well. S-reduction is a very special case of strict reduction, and is even more constraining. In effect, the two problems A and B must be in near perfect correspondence with each other. The existence of an S-reduction implies not only the existence of a strict reduction but every other reduction listed here.</p>
<h3 id="l-reduction">L-reduction</h3>

<p>L-reductions preserve membership in PTAS as well as APX (but <em>only for minimization problems in the case of the latter</em>). As a result, they cannot be used in general to prove completeness results about APX, Log-APX, or Poly-APX, but nevertheless they are valued for their natural formulation and ease of use in proofs.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h3 id="ptas-reduction">PTAS-reduction</h3>

<p>PTAS-reduction is another commonly used reduction scheme. Though it preserves membership in PTAS, it does not do so for APX. Nevertheless, APX-completeness is defined in terms of PTAS reductions.</p>

<p>PTAS-reductions are a generalization of P-reductions, shown below, with the only difference being that the function 

<math display="inline" id="Approximation-preserving_reduction:25">
<semantics>
<mi>g</mi>
<annotation-xml encoding="MathML-Content">
<ci>g</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   g
  </annotation>
</semantics>
</math>

 is allowed to depend on the approximation ratio 

<math display="inline" id="Approximation-preserving_reduction:26">
<semantics>
<mi>r</mi>
<annotation-xml encoding="MathML-Content">
<ci>r</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   r
  </annotation>
</semantics>
</math>

.</p>
<h3 id="a-reduction-and-p-reduction">A-reduction and P-reduction</h3>

<p>A-reduction and P-reduction are similar reduction schemes that can be used to show membership in APX and PTAS respectively. Both introduce a new function 

<math display="inline" id="Approximation-preserving_reduction:27">
<semantics>
<mi>c</mi>
<annotation-xml encoding="MathML-Content">
<ci>c</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   c
  </annotation>
</semantics>
</math>

, defined on numbers greater than 1, which must be computable.</p>

<p>In an A-reduction, we have that</p>

<p>
<math display="block" id="Approximation-preserving_reduction:28">
<semantics>
<mrow>
<mrow>
<msub>
<mi>R</mi>
<mi>B</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>x</mi>
<mo>′</mo>
</msup>
<mo>,</mo>
<msup>
<mi>y</mi>
<mo>′</mo>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>≤</mo>
<mi>r</mi>
<mo>→</mo>
<mrow>
<msub>
<mi>R</mi>
<mi>A</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>≤</mo>
<mrow>
<mi>c</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>r</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<leq></leq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>B</ci>
</apply>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<ci>normal-′</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>y</ci>
<ci>normal-′</ci>
</apply>
</interval>
</apply>
<ci>r</ci>
</apply>
<apply>
<ci>normal-→</ci>
<share href="#.cmml">
</share>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>A</ci>
</apply>
<interval closure="open">
<ci>x</ci>
<ci>y</ci>
</interval>
</apply>
</apply>
<apply>
<leq></leq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<ci>c</ci>
<ci>r</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   R_{B}(x^{\prime},y^{\prime})\leq r\rightarrow R_{A}(x,y)\leq c(r)
  </annotation>
</semantics>
</math>

.</p>

<p>In a P-reduction, we have that</p>

<p>
<math display="block" id="Approximation-preserving_reduction:29">
<semantics>
<mrow>
<mrow>
<msub>
<mi>R</mi>
<mi>B</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>x</mi>
<mo>′</mo>
</msup>
<mo>,</mo>
<msup>
<mi>y</mi>
<mo>′</mo>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>≤</mo>
<mrow>
<mi>c</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>r</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>→</mo>
<mrow>
<msub>
<mi>R</mi>
<mi>A</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>≤</mo>
<mi>r</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<leq></leq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>B</ci>
</apply>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<ci>normal-′</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>y</ci>
<ci>normal-′</ci>
</apply>
</interval>
</apply>
<apply>
<times></times>
<ci>c</ci>
<ci>r</ci>
</apply>
</apply>
<apply>
<ci>normal-→</ci>
<share href="#.cmml">
</share>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>A</ci>
</apply>
<interval closure="open">
<ci>x</ci>
<ci>y</ci>
</interval>
</apply>
</apply>
<apply>
<leq></leq>
<share href="#.cmml">
</share>
<ci>r</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   R_{B}(x^{\prime},y^{\prime})\leq c(r)\rightarrow R_{A}(x,y)\leq r
  </annotation>
</semantics>
</math>

.</p>

<p>The existence of a P-reduction implies the existence of a PTAS-reduction.</p>
<h3 id="e-reduction">E-reduction</h3>

<p>E-reduction, which is a generalization of strict reduction but implies both A-reduction and P-reduction, is an example of a less restrictive reduction style that preserves membership not only in PTAS and APX, but also the larger classes <a class="uri" href="Log-APX" title="wikilink">Log-APX</a> and <a class="uri" href="Poly-APX" title="wikilink">Poly-APX</a>. E-reduction introduces two new parameters, a polynomial 

<math display="inline" id="Approximation-preserving_reduction:30">
<semantics>
<mi>p</mi>
<annotation-xml encoding="MathML-Content">
<ci>p</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   p
  </annotation>
</semantics>
</math>

 and a constant 

<math display="inline" id="Approximation-preserving_reduction:31">
<semantics>
<mi>β</mi>
<annotation-xml encoding="MathML-Content">
<ci>β</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \beta
  </annotation>
</semantics>
</math>

. Its definition is as follows.</p>

<p>In an E-reduction, we have that for some polynomial 

<math display="inline" id="Approximation-preserving_reduction:32">
<semantics>
<mi>p</mi>
<annotation-xml encoding="MathML-Content">
<ci>p</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   p
  </annotation>
</semantics>
</math>

 and constant 

<math display="inline" id="Approximation-preserving_reduction:33">
<semantics>
<mi>β</mi>
<annotation-xml encoding="MathML-Content">
<ci>β</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \beta
  </annotation>
</semantics>
</math>


,</p>
<ul>
<li>
<math display="inline" id="Approximation-preserving_reduction:34">
<semantics>
<mrow>
<mrow>
<msub>
<mi>c</mi>
<mi>B</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>O</mi>
<mi>P</mi>
<msub>
<mi>T</mi>
<mi>B</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>x</mi>
<mo>′</mo>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>≤</mo>
<mrow>
<mi>p</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo stretchy="false">|</mo>
<mi>x</mi>
<mo stretchy="false">|</mo>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<msub>
<mi>c</mi>
<mi>A</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>O</mi>
<mi>P</mi>
<msub>
<mi>T</mi>
<mi>A</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<leq></leq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>c</ci>
<ci>B</ci>
</apply>
<apply>
<times></times>
<ci>O</ci>
<ci>P</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>T</ci>
<ci>B</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<ci>normal-′</ci>
</apply>
</apply>
</apply>
<apply>
<times></times>
<ci>p</ci>
<apply>
<abs></abs>
<ci>x</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>c</ci>
<ci>A</ci>
</apply>
<apply>
<times></times>
<ci>O</ci>
<ci>P</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>T</ci>
<ci>A</ci>
</apply>
<ci>x</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   c_{B}(OPT_{B}(x^{\prime}))\leq p(|x|)c_{A}(OPT_{A}(x))
  </annotation>
</semantics>
</math>

, where 

<math display="inline" id="Approximation-preserving_reduction:35">
<semantics>
<mrow>
<mo stretchy="false">|</mo>
<mi>x</mi>
<mo stretchy="false">|</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<abs></abs>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   |x|
  </annotation>
</semantics>
</math>

 denotes the size of the problem instance's description.</li>
<li>For any solution 

<math display="inline" id="Approximation-preserving_reduction:36">
<semantics>
<msup>
<mi>y</mi>
<mo>′</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>y</ci>
<ci>normal-′</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   y^{\prime}
  </annotation>
</semantics>
</math>

 to 

<math display="inline" id="Approximation-preserving_reduction:37">
<semantics>
<mi>B</mi>
<annotation-xml encoding="MathML-Content">
<ci>B</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   B
  </annotation>
</semantics>
</math>

, we have 

<math display="inline" id="Approximation-preserving_reduction:38">
<semantics>
<mrow>
<mrow>
<msub>
<mi>R</mi>
<mi>A</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>≤</mo>
<mrow>
<mn>1</mn>
<mo>+</mo>
<mrow>
<mi>β</mi>
<mo>⋅</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<msub>
<mi>R</mi>
<mi>B</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>x</mi>
<mo>′</mo>
</msup>
<mo>,</mo>
<msup>
<mi>y</mi>
<mo>′</mo>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<leq></leq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>A</ci>
</apply>
<interval closure="open">
<ci>x</ci>
<ci>y</ci>
</interval>
</apply>
<apply>
<plus></plus>
<cn type="integer">1</cn>
<apply>
<ci>normal-⋅</ci>
<ci>β</ci>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>B</ci>
</apply>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<ci>normal-′</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>y</ci>
<ci>normal-′</ci>
</apply>
</interval>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   R_{A}(x,y)\leq 1+\beta\cdot(R_{B}(x^{\prime},y^{\prime})-1)
  </annotation>
</semantics>
</math>


.</li>
</ul>

<p>To obtain an A-reduction from an E-reduction, let 

<math display="inline" id="Approximation-preserving_reduction:39">
<semantics>
<mrow>
<mrow>
<mi>c</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>r</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mn>1</mn>
<mo>+</mo>
<mrow>
<mi>β</mi>
<mo>⋅</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>r</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>c</ci>
<ci>r</ci>
</apply>
<apply>
<plus></plus>
<cn type="integer">1</cn>
<apply>
<ci>normal-⋅</ci>
<ci>β</ci>
<apply>
<minus></minus>
<ci>r</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   c(r)=1+\beta\cdot(r-1)
  </annotation>
</semantics>
</math>

, and to obtain a P-reduction from an E-reduction, let 

<math display="inline" id="Approximation-preserving_reduction:40">
<semantics>
<mrow>
<mrow>
<mi>c</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>r</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mn>1</mn>
<mo>+</mo>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>r</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>/</mo>
<mi>β</mi>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>c</ci>
<ci>r</ci>
</apply>
<apply>
<plus></plus>
<cn type="integer">1</cn>
<apply>
<divide></divide>
<apply>
<minus></minus>
<ci>r</ci>
<cn type="integer">1</cn>
</apply>
<ci>β</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   c(r)=1+(r-1)/\beta
  </annotation>
</semantics>
</math>

.</p>
<h3 id="ap-reduction">AP-reduction</h3>

<p>AP-reductions are used to define completeness in the classes <a class="uri" href="Log-APX" title="wikilink">Log-APX</a> and <a class="uri" href="Poly-APX" title="wikilink">Poly-APX</a>. They are a special case of PTAS reduction, meeting the following restrictions.</p>

<p>In an AP-reduction, we have that for some constant 

<math display="inline" id="Approximation-preserving_reduction:41">
<semantics>
<mi>α</mi>
<annotation-xml encoding="MathML-Content">
<ci>α</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \alpha
  </annotation>
</semantics>
</math>

,</p>

<p>
<math display="block" id="Approximation-preserving_reduction:42">
<semantics>
<mrow>
<mrow>
<msub>
<mi>R</mi>
<mi>B</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>x</mi>
<mo>′</mo>
</msup>
<mo>,</mo>
<msup>
<mi>y</mi>
<mo>′</mo>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>≤</mo>
<mi>r</mi>
<mo>→</mo>
<mrow>
<msub>
<mi>R</mi>
<mi>A</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>≤</mo>
<mrow>
<mn>1</mn>
<mo>+</mo>
<mrow>
<mi>α</mi>
<mo>⋅</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>r</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<leq></leq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>B</ci>
</apply>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<ci>normal-′</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>y</ci>
<ci>normal-′</ci>
</apply>
</interval>
</apply>
<ci>r</ci>
</apply>
<apply>
<ci>normal-→</ci>
<share href="#.cmml">
</share>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>R</ci>
<ci>A</ci>
</apply>
<interval closure="open">
<ci>x</ci>
<ci>y</ci>
</interval>
</apply>
</apply>
<apply>
<leq></leq>
<share href="#.cmml">
</share>
<apply>
<plus></plus>
<cn type="integer">1</cn>
<apply>
<ci>normal-⋅</ci>
<ci>α</ci>
<apply>
<minus></minus>
<ci>r</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   R_{B}(x^{\prime},y^{\prime})\leq r\rightarrow R_{A}(x,y)\leq 1+\alpha\cdot(r-1)
  </annotation>
</semantics>
</math>

 with the additional generalization that the function 

<math display="inline" id="Approximation-preserving_reduction:43">
<semantics>
<mi>g</mi>
<annotation-xml encoding="MathML-Content">
<ci>g</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   g
  </annotation>
</semantics>
</math>


 is allowed to depend on the approximation ratio 

<math display="inline" id="Approximation-preserving_reduction:44">
<semantics>
<mi>r</mi>
<annotation-xml encoding="MathML-Content">
<ci>r</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   r
  </annotation>
</semantics>
</math>

, as in PTAS-reduction.</p>

<p>AP-reduction is also a generalization of E-reduction. An additional restriction actually needs to be imposed for AP-reduction to preserve Log-APX and Poly-APX membership, as E-reduction does: for fixed problem size, the computation time of 

<math display="inline" id="Approximation-preserving_reduction:45">
<semantics>
<mrow>
<mi>f</mi>
<mo>,</mo>
<mi>g</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<ci>f</ci>
<ci>g</ci>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   f,g
  </annotation>
</semantics>
</math>

 must be non-increasing as the approximation ratio increases.</p>
<h3 id="gap-reduction">Gap reduction</h3>

<p>A gap reduction is a type of reduction that, while useful in proving some inapproximability results, does not resemble the other reductions shown here. Gap reductions deal with optimization problems within a decision problem container, generated by changing the problem goal to distinguishing between the optimal solution and solutions some multiplicative factor worse than the optimum.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Reduction_(complexity)" title="wikilink">Reduction (complexity)</a></li>
<li><a href="PTAS_reduction" title="wikilink">PTAS reduction</a></li>
<li><a class="uri" href="L-reduction" title="wikilink">L-reduction</a></li>
<li><a href="Approximation_algorithm" title="wikilink">Approximation algorithm</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Approximation_algorithms" title="wikilink">Category:Approximation algorithms</a> <a href="Category:Computational_complexity_theory" title="wikilink">Category:Computational complexity theory</a> <a href="Category:Structural_complexity_theory" title="wikilink">Category:Structural complexity theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
</ol>
</section>
</body>
</html>
