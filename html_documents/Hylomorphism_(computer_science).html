<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1566">Hylomorphism (computer science)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Hylomorphism (computer science)</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, and in particular <a href="functional_programming" title="wikilink">functional programming</a>, a <strong>hylomorphism</strong> is a <a href="Recursion_(computer_science)" title="wikilink">recursive</a> function, corresponding to the <a href="function_composition" title="wikilink">composition</a> of an <a class="uri" href="anamorphism" title="wikilink">anamorphism</a> (which first builds a set of results; also known as 'unfolding') and a <a class="uri" href="catamorphism" title="wikilink">catamorphism</a> (which then <a href="fold_(higher-order_function)" title="wikilink">folds</a> these results into a final <a href="return_value" title="wikilink">return value</a>). Fusion of these two recursive computations into a single recursive pattern then avoids building the intermediate data structure. This is an example of <a href="deforestation_(computer_science)" title="wikilink">deforestation</a>, a program optimization strategy. A related type of function is a <strong>metamorphism</strong>, which is a catamorphism followed by an anamorphism.</p>
<h2 id="formal-definition">Formal definition</h2>

<p>A hylomorphism 

<math display="inline" id="Hylomorphism_(computer_science):0">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>:</mo>
   <mrow>
    <mi>A</mi>
    <mo>→</mo>
    <mi>C</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>h</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>A</ci>
     <ci>C</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h:A\rightarrow C
  </annotation>
 </semantics>
</math>

 can be defined in terms of its separate anamorphic and catamorphic parts.</p>

<p>The anamorphic part can be defined in terms of a <a href="arity" title="wikilink">unary</a> function 

<math display="inline" id="Hylomorphism_(computer_science):1">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>:</mo>
   <mrow>
    <mi>A</mi>
    <mo>→</mo>
    <mrow>
     <mi>B</mi>
     <mo>×</mo>
     <mi>A</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>g</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g:A\rightarrow B\times A
  </annotation>
 </semantics>
</math>

 defining the list of elements in 

<math display="inline" id="Hylomorphism_(computer_science):2">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 by repeated application (<em>"unfolding"</em>), and a <a href="predicate_(mathematics)" title="wikilink">predicate</a> 

<math display="inline" id="Hylomorphism_(computer_science):3">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>:</mo>
   <mrow>
    <mi>A</mi>
    <mo>→</mo>
    <mtext>Boolean</mtext>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>p</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>A</ci>
     <mtext>Boolean</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p:A\rightarrow\text{Boolean}
  </annotation>
 </semantics>
</math>


 providing the terminating condition.</p>

<p>The catamorphic part can be defined as a combination of an initial value 

<math display="inline" id="Hylomorphism_(computer_science):4">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>∈</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>c</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\in C
  </annotation>
 </semantics>
</math>

 for the fold and a binary <a href="Operation_(mathematics)" title="wikilink">operator</a> 

<math display="inline" id="Hylomorphism_(computer_science):5">
 <semantics>
  <mrow>
   <mo>⊕</mo>
   <mo>:</mo>
   <mi>B</mi>
   <mo>×</mo>
   <mi>C</mi>
   <mo>→</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">direct-sum</csymbol>
    <ci>normal-:</ci>
    <csymbol cd="unknown">B</csymbol>
    <times></times>
    <csymbol cd="unknown">C</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">C</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \oplus:B\times C\rightarrow C
  </annotation>
 </semantics>
</math>

 used to perform the fold.</p>

<p>Thus a hylomorphism</p>

<p>

<math display="block" id="Hylomorphism_(computer_science):6">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>h</mi>
    </mpadded>
    <mi>a</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mi>c</mi>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mtext>if</mtext>
        <mpadded width="+1.7pt">
         <mi>p</mi>
        </mpadded>
        <mi>a</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>b</mi>
        <mo>⊕</mo>
        <mrow>
         <mi>h</mi>
         <msup>
          <mi>a</mi>
          <mo>′</mo>
         </msup>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <ci>c</ci>
     <apply>
      <times></times>
      <mtext>if</mtext>
      <ci>p</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <ci>b</ci>
      <apply>
       <times></times>
       <ci>h</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h\,a=\begin{cases}c&\mbox{if }p\,a\\
b\oplus ha^{\prime}&\mbox{otherwise}\end{cases}
  </annotation>
 </semantics>
</math>

 (where 

<math display="inline" id="Hylomorphism_(computer_science):7">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo>,</mo>
    <msup>
     <mi>a</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mi>a</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <ci>b</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (b,a^{\prime})=ga
  </annotation>
 </semantics>
</math>

) may be defined (assuming appropriate definitions of 

<math display="inline" id="Hylomorphism_(computer_science):8">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 &amp; 

<math display="inline" id="Hylomorphism_(computer_science):9">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

).</p>
<h3 id="notation">Notation</h3>

<p>An abbreviated notation for the above hylomorphism is 

<math display="inline" id="Hylomorphism_(computer_science):10">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>=</mo>
   <mrow>
    <mo rspace="0.8pt" stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>c</mi>
      <mo>,</mo>
      <mo>⊕</mo>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>g</mi>
      <mo>,</mo>
      <mi>p</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="0.8pt" stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>h</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <interval closure="closed">
      <interval closure="open">
       <ci>c</ci>
       <csymbol cd="latexml">direct-sum</csymbol>
      </interval>
      <interval closure="open">
       <ci>g</ci>
       <ci>p</ci>
      </interval>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h=[\![(c,\oplus),(g,p)]\!]
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="hylomorphisms-in-practice">Hylomorphisms in practice</h2>
<h3 id="lists">Lists</h3>

<p><a href="List_(computing)" title="wikilink">Lists</a> are common data structures as they naturally reflect linear computational processes. These processes arise in repeated (<a href="Iteration" title="wikilink">iterative</a>) function calls. Therefore it is sometimes necessary to generate a temporary list of intermediate results before reducing this list to a single result.</p>

<p>One example of a commonly encountered hylomorphism is the canonical <a class="uri" href="factorial" title="wikilink">factorial</a> function.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">factorial ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
factorial n
  <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span>
  <span class="fu">|</span> n <span class="fu">&gt;</span> <span class="dv">0</span> <span class="fu">=</span> n <span class="fu">*</span> factorial (n <span class="fu">-</span> <span class="dv">1</span>)</code></pre></div>

<p>In the previous example (written in <a href="Haskell_(programming_language)" title="wikilink">Haskell</a>, a <a href="purely_functional" title="wikilink">purely functional</a> <a href="programming_language" title="wikilink">programming language</a>) it can be seen that this function, applied to any given valid input, will generate a linear call tree <a href="isomorphism" title="wikilink">isomorphic</a> to a list. For example, given <em>n</em> = 5 it will produce the following:</p>

<p><code>factorial 5 = 5 * (factorial 4) = 120</code><br/>
<code>factorial 4 = 4 * (factorial 3) = 24</code><br/>
<code>factorial 3 = 3 * (factorial 2) = 6</code><br/>
<code>factorial 2 = 2 * (factorial 1) = 2</code><br/>
<code>factorial 1 = 1 * (factorial 0) = 1</code><br/>
<code>factorial 0 = 1</code></p>

<p>In this example, the anamorphic part of the process is the generation of the call tree which is isomorphic to the list <code>[1, 1, 2, 3, 4, 5]</code>. The catamorphism, then, is the calculation of the <a href="product_(mathematics)" title="wikilink">product</a> of the <a href="element_(mathematics)" title="wikilink">elements</a> of this list. Thus, in the notation given above, the factorial function may be written 

<math display="inline" id="Hylomorphism_(computer_science):11">
 <semantics>
  <mrow>
   <mtext>factorial</mtext>
   <mo>=</mo>
   <mrow>
    <mo rspace="0.8pt" stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo>,</mo>
      <mo>×</mo>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>g</mi>
      <mo>,</mo>
      <mi>p</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo rspace="0.8pt" stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <mtext>factorial</mtext>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <interval closure="closed">
      <interval closure="open">
       <cn type="integer">1</cn>
       <times></times>
      </interval>
      <interval closure="open">
       <ci>g</ci>
       <ci>p</ci>
      </interval>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{factorial}=[\![(1,\times),(g,p)]\!]
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Hylomorphism_(computer_science):12">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+5pt">
     <mi>g</mi>
    </mpadded>
    <mi>n</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
    <interval closure="open">
     <ci>n</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\ n=(n,n-1)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hylomorphism_(computer_science):13">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>p</mi>
   </mpadded>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>=</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <eq></eq>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\ n=(n=0)
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="trees">Trees</h3>

<p>However, the term 'hylomorphism' does not apply solely to functions acting upon isomorphisms of lists. For example, a hylomorphism may also be defined by generating a non-linear call tree which is then collapsed. An example of such a function is the function to generate the <em>n</em><sup>th</sup> <a href="term_(mathematics)" title="wikilink">term</a> of the <a href="Fibonacci_sequence" title="wikilink">Fibonacci sequence</a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot"> fibonacci ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
 fibonacci n
   <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
   <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span>
   <span class="fu">|</span> n <span class="fu">&gt;</span> <span class="dv">1</span> <span class="fu">=</span> fibonacci (n <span class="fu">-</span> <span class="dv">2</span>) <span class="fu">+</span> fibonacci (n <span class="fu">-</span> <span class="dv">1</span>)</code></pre></div>
<figure><b>(Figure)</b>
<figcaption>Call tree for <code>fibonacci 4</code>.</figcaption>
</figure>

<p>This function, again applied to any valid input, will generate a call tree which is non-linear. In the example on the right, the call tree generated by applying the <code>fibonacci</code> function to the input <code>4</code>.</p>

<p>This time, the anamorphism is the generation of the call tree isomorphic to the tree with <a href="leaf_node" title="wikilink">leaf nodes</a> <code>0, 1, 1, 0, 1</code> and the catamorphism the <a class="uri" href="summation" title="wikilink">summation</a> of these leaf nodes.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Apomorphism" title="wikilink">Apomorphism</a></li>
<li><a class="uri" href="Paramorphism" title="wikilink">Paramorphism</a></li>
<li><a class="uri" href="Morphism" title="wikilink">Morphism</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://ulissesaraujo.wordpress.com/2009/04/09/hylomorphisms-in-haskell/">Hylomorphisms in Haskell</a></li>
<li><a href="http://ulissesaraujo.wordpress.com/2009/04/09/more-hylomorphisms-in-haskell/">More Hylomorphisms in Haskell</a></li>
</ul>

<p>"</p>

<p><a href="Category:Articles_with_example_Haskell_code" title="wikilink">Category:Articles with example Haskell code</a> <a href="Category:Category_theory" title="wikilink">Category:Category theory</a> <a href="Category:Recursion_schemes" title="wikilink">Category:Recursion schemes</a></p>
</body>

