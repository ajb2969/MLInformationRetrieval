<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1548">Refinable function</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Refinable function</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, in the area of <a class="uri" href="wavelet" title="wikilink">wavelet</a> analysis, a <strong>refinable function</strong> is a function which fulfils some kind of <a class="uri" href="self-similarity" title="wikilink">self-similarity</a>. A function 

<math display="inline" id="Refinable_function:0">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 is called refinable with respect to the mask 

<math display="inline" id="Refinable_function:1">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 if</p>

<p>

<math display="block" id="Refinable_function:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mo>⋅</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </munderover>
     <mrow>
      <mrow>
       <msub>
        <mi>h</mi>
        <mi>k</mi>
       </msub>
       <mo>⋅</mo>
       <mi>φ</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mn>2</mn>
         <mo>⋅</mo>
         <mi>x</mi>
        </mrow>
        <mo>-</mo>
        <mi>k</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>φ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <cn type="integer">2</cn>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>N</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <ci>k</ci>
        </apply>
        <ci>φ</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <ci>normal-⋅</ci>
         <cn type="integer">2</cn>
         <ci>x</ci>
        </apply>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi(x)=2\cdot\sum_{k=0}^{N-1}h_{k}\cdot\varphi(2\cdot x-k)
  </annotation>
 </semantics>
</math>

 This condition is called <strong>refinement equation</strong>, <strong>dilation equation</strong> or <strong>two-scale equation</strong>.</p>

<p>Using the <a class="uri" href="convolution" title="wikilink">convolution</a> (denoted by a star, *) of a function with a discrete mask and the dilation operator 

<math display="inline" id="Refinable_function:3">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 one can write more concisely:</p>

<p>

<math display="block" id="Refinable_function:4">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mo>⋅</mo>
     <msub>
      <mi>D</mi>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msub>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>h</mi>
      <mo>*</mo>
      <mi>φ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>φ</ci>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>D</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>φ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi=2\cdot D_{1/2}(h*\varphi)
  </annotation>
 </semantics>
</math>

 It means that one obtains the function, again, if you convolve the function with a discrete mask and then scale it back. There is a similarity to <a href="iterated_function_systems" title="wikilink">iterated function systems</a> and <a href="de_Rham_curve" title="wikilink">de Rham curves</a>.</p>

<p>The operator 

<math display="inline" id="Refinable_function:5">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mo>↦</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mo>⋅</mo>
     <msub>
      <mi>D</mi>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msub>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>h</mi>
      <mo>*</mo>
      <mi>φ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>φ</ci>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>D</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>φ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi\mapsto 2\cdot D_{1/2}(h*\varphi)
  </annotation>
 </semantics>
</math>

 is linear. A refinable function is an <a class="uri" href="eigenfunction" title="wikilink">eigenfunction</a> of that operator. Its absolute value is not uniquely defined. That is, if 

<math display="inline" id="Refinable_function:6">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 is a refinable function, then for every 

<math display="inline" id="Refinable_function:7">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 the function 

<math display="inline" id="Refinable_function:8">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>⋅</mo>
   <mi>φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <ci>c</ci>
    <ci>φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\cdot\varphi
  </annotation>
 </semantics>
</math>

 is refinable, too.</p>

<p>These functions play a fundamental role in <a class="uri" href="wavelet" title="wikilink">wavelet</a> theory as <a href="Wavelet#Scaling_function" title="wikilink">scaling functions</a>.</p>
<h2 id="properties">Properties</h2>
<h3 id="values-at-integral-points">Values at integral points</h3>

<p>A refinable function is defined only implicitly. It may also be that there are several functions which are refinable with respect to the same mask. If 

<math display="inline" id="Refinable_function:9">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 shall have finite support and the function values at integer arguments are wanted, then the two scale equation becomes a system of <a href="simultaneous_linear_equations" title="wikilink">simultaneous linear equations</a>.</p>

<p>Let 

<math display="inline" id="Refinable_function:10">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 be the minimum index and 

<math display="inline" id="Refinable_function:11">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 be the maximum index of non-zero elements of 

<math display="inline" id="Refinable_function:12">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

, then one obtains</p>

<p>

<math display="block" id="Refinable_function:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mi>φ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>a</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mi>φ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>a</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi mathvariant="normal">⋮</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mi>φ</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>b</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>h</mi>
          <mi>a</mi>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <mi></mi>
        </mtd>
        <mtd columnalign="center">
         <mi></mi>
        </mtd>
        <mtd columnalign="center">
         <mi></mi>
        </mtd>
        <mtd columnalign="center">
         <mi></mi>
        </mtd>
        <mtd columnalign="center">
         <mi></mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>h</mi>
          <mrow>
           <mi>a</mi>
           <mo>+</mo>
           <mn>2</mn>
          </mrow>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>h</mi>
          <mrow>
           <mi>a</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>h</mi>
          <mi>a</mi>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <mi></mi>
        </mtd>
        <mtd columnalign="center">
         <mi></mi>
        </mtd>
        <mtd columnalign="center">
         <mi></mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>h</mi>
          <mrow>
           <mi>a</mi>
           <mo>+</mo>
           <mn>4</mn>
          </mrow>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>h</mi>
          <mrow>
           <mi>a</mi>
           <mo>+</mo>
           <mn>3</mn>
          </mrow>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>h</mi>
          <mrow>
           <mi>a</mi>
           <mo>+</mo>
           <mn>2</mn>
          </mrow>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>h</mi>
          <mrow>
           <mi>a</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>h</mi>
          <mi>a</mi>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <mi></mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mi mathvariant="normal">⋱</mi>
        </mtd>
        <mtd columnalign="center">
         <mi mathvariant="normal">⋱</mi>
        </mtd>
        <mtd columnalign="center">
         <mi mathvariant="normal">⋱</mi>
        </mtd>
        <mtd columnalign="center">
         <mi mathvariant="normal">⋱</mi>
        </mtd>
        <mtd columnalign="center">
         <mi mathvariant="normal">⋱</mi>
        </mtd>
        <mtd columnalign="center">
         <mi mathvariant="normal">⋱</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mi></mi>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>h</mi>
          <mi>b</mi>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>h</mi>
          <mrow>
           <mi>b</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>h</mi>
          <mrow>
           <mi>b</mi>
           <mo>-</mo>
           <mn>2</mn>
          </mrow>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>h</mi>
          <mrow>
           <mi>b</mi>
           <mo>-</mo>
           <mn>3</mn>
          </mrow>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>h</mi>
          <mrow>
           <mi>b</mi>
           <mo>-</mo>
           <mn>4</mn>
          </mrow>
         </msub>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mi></mi>
        </mtd>
        <mtd columnalign="center">
         <mi></mi>
        </mtd>
        <mtd columnalign="center">
         <mi></mi>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>h</mi>
          <mi>b</mi>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>h</mi>
          <mrow>
           <mi>b</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>h</mi>
          <mrow>
           <mi>b</mi>
           <mo>-</mo>
           <mn>2</mn>
          </mrow>
         </msub>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mi></mi>
        </mtd>
        <mtd columnalign="center">
         <mi></mi>
        </mtd>
        <mtd columnalign="center">
         <mi></mi>
        </mtd>
        <mtd columnalign="center">
         <mi></mi>
        </mtd>
        <mtd columnalign="center">
         <mi></mi>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>h</mi>
          <mi>b</mi>
         </msub>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
     <mo>⋅</mo>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <mi>φ</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>a</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <mi>φ</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>a</mi>
            <mo>+</mo>
            <mn>1</mn>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mi mathvariant="normal">⋮</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <mi>φ</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>b</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <matrix>
     <matrixrow>
      <apply>
       <times></times>
       <ci>φ</ci>
       <ci>a</ci>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>φ</ci>
       <apply>
        <plus></plus>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <ci>normal-⋮</ci>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>φ</ci>
       <ci>b</ci>
      </apply>
     </matrixrow>
    </matrix>
    <apply>
     <ci>normal-⋅</ci>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>a</ci>
       </apply>
       <csymbol cd="latexml">absent</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <csymbol cd="latexml">absent</csymbol>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <apply>
         <plus></plus>
         <ci>a</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <apply>
         <plus></plus>
         <ci>a</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>a</ci>
       </apply>
       <csymbol cd="latexml">absent</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <csymbol cd="latexml">absent</csymbol>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <apply>
         <plus></plus>
         <ci>a</ci>
         <cn type="integer">4</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <apply>
         <plus></plus>
         <ci>a</ci>
         <cn type="integer">3</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <apply>
         <plus></plus>
         <ci>a</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <apply>
         <plus></plus>
         <ci>a</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>a</ci>
       </apply>
       <csymbol cd="latexml">absent</csymbol>
      </matrixrow>
      <matrixrow>
       <ci>normal-⋱</ci>
       <ci>normal-⋱</ci>
       <ci>normal-⋱</ci>
       <ci>normal-⋱</ci>
       <ci>normal-⋱</ci>
       <ci>normal-⋱</ci>
      </matrixrow>
      <matrixrow>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>b</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <apply>
         <minus></minus>
         <ci>b</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <apply>
         <minus></minus>
         <ci>b</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <apply>
         <minus></minus>
         <ci>b</ci>
         <cn type="integer">3</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <apply>
         <minus></minus>
         <ci>b</ci>
         <cn type="integer">4</cn>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <csymbol cd="latexml">absent</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>b</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <apply>
         <minus></minus>
         <ci>b</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <apply>
         <minus></minus>
         <ci>b</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <csymbol cd="latexml">absent</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>b</ci>
       </apply>
      </matrixrow>
     </matrix>
     <matrix>
      <matrixrow>
       <apply>
        <times></times>
        <ci>φ</ci>
        <ci>a</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <ci>φ</ci>
        <apply>
         <plus></plus>
         <ci>a</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <ci>normal-⋮</ci>
      </matrixrow>
      <matrixrow>
       <apply>
        <times></times>
        <ci>φ</ci>
        <ci>b</ci>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{pmatrix}\varphi(a)\\
\varphi(a+1)\\
\vdots\\
\varphi(b)\end{pmatrix}=\begin{pmatrix}h_{a}&&&&&\\
h_{a+2}&h_{a+1}&h_{a}&&&\\
h_{a+4}&h_{a+3}&h_{a+2}&h_{a+1}&h_{a}&\\
\ddots&\ddots&\ddots&\ddots&\ddots&\ddots\\
&h_{b}&h_{b-1}&h_{b-2}&h_{b-3}&h_{b-4}\\
&&&h_{b}&h_{b-1}&h_{b-2}\\
&&&&&h_{b}\end{pmatrix}\cdot\begin{pmatrix}\varphi(a)\\
\varphi(a+1)\\
\vdots\\
\varphi(b)\end{pmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>Using the <a href="Ideal_sampler" title="wikilink">discretization</a> operator, call it 

<math display="inline" id="Refinable_function:14">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 here, and the <a href="transfer_matrix" title="wikilink">transfer matrix</a> of 

<math display="inline" id="Refinable_function:15">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

, named 

<math display="inline" id="Refinable_function:16">
 <semantics>
  <msub>
   <mi>T</mi>
   <mi>h</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{h}
  </annotation>
 </semantics>
</math>

, this can be written concisely as</p>

<p>

<math display="block" id="Refinable_function:17">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Q</mi>
     <mi>φ</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>T</mi>
       <mi>h</mi>
      </msub>
      <mo>⋅</mo>
      <mi>Q</mi>
     </mrow>
     <mi>φ</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>φ</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <ci>h</ci>
      </apply>
      <ci>Q</ci>
     </apply>
     <ci>φ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q\varphi=T_{h}\cdot Q\varphi.\,
  </annotation>
 </semantics>
</math>

</p>

<p>This is again a <a href="Fixed_point_(mathematics)" title="wikilink">fixed-point equation</a>. But this one can now be considered as an <a class="uri" href="eigenvector" title="wikilink">eigenvector</a>-<a class="uri" href="eigenvalue" title="wikilink">eigenvalue</a> problem. That is, a finitely supported refinable function exists only (but not necessarily), if 

<math display="inline" id="Refinable_function:18">
 <semantics>
  <msub>
   <mi>T</mi>
   <mi>h</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{h}
  </annotation>
 </semantics>
</math>

 has the eigenvalue 1.</p>
<h3 id="values-at-dyadic-points">Values at dyadic points</h3>

<p>From the values at integral points you can derive the values at dyadic points, i.e. points of the form 

<math display="inline" id="Refinable_function:19">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>⋅</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo>-</mo>
     <mi>j</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <ci>k</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\cdot 2^{-j}
  </annotation>
 </semantics>
</math>

, with 

<math display="inline" id="Refinable_function:20">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>∈</mo>
   <mi>ℤ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>k</ci>
    <ci>ℤ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\in\mathbb{Z}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Refinable_function:21">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>∈</mo>
   <mi>ℕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>j</ci>
    <ci>ℕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j\in\mathbb{N}
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Refinable_function:22">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>D</mi>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>2</mn>
      <mo>⋅</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>h</mi>
        <mo>*</mo>
        <mi>φ</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>φ</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <cn type="integer">2</cn>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>φ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi=D_{1/2}(2\cdot(h*\varphi))
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Refinable_function:23">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>D</mi>
     <mn>2</mn>
    </msub>
    <mi>φ</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>h</mi>
      <mo>*</mo>
      <mi>φ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>φ</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <cn type="integer">2</cn>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>φ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{2}\varphi=2\cdot(h*\varphi)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Refinable_function:24">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>D</mi>
       <mn>2</mn>
      </msub>
      <mi>φ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>2</mn>
      <mo>⋅</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>h</mi>
        <mo>*</mo>
        <mi>φ</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>h</mi>
       <mo>*</mo>
       <mi>Q</mi>
      </mrow>
      <mi>φ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>D</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>φ</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>Q</ci>
      <apply>
       <ci>normal-⋅</ci>
       <cn type="integer">2</cn>
       <apply>
        <times></times>
        <ci>h</ci>
        <ci>φ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-⋅</ci>
      <cn type="integer">2</cn>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <ci>h</ci>
        <ci>Q</ci>
       </apply>
       <ci>φ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(D_{2}\varphi)=Q(2\cdot(h*\varphi))=2\cdot(h*Q\varphi)
  </annotation>
 </semantics>
</math>

 The star denotes the <a class="uri" href="convolution" title="wikilink">convolution</a> of a discrete filter with a function. With this step you can compute the values at points of the form 

<math display="inline" id="Refinable_function:25">
 <semantics>
  <mfrac>
   <mi>k</mi>
   <mn>2</mn>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>k</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{k}{2}
  </annotation>
 </semantics>
</math>

. By replacing iteratedly 

<math display="inline" id="Refinable_function:26">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Refinable_function:27">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mn>2</mn>
   </msub>
   <mi>φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{2}\varphi
  </annotation>
 </semantics>
</math>

 you get the values at all finer scales.</p>

<p>

<math display="block" id="Refinable_function:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>D</mi>
       <msup>
        <mn>2</mn>
        <mrow>
         <mi>j</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msup>
      </msub>
      <mi>φ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>h</mi>
       <mo>*</mo>
       <mi>Q</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>D</mi>
         <msup>
          <mn>2</mn>
          <mi>j</mi>
         </msup>
        </msub>
        <mi>φ</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>D</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <apply>
         <plus></plus>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <ci>φ</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <cn type="integer">2</cn>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>Q</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>D</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">2</cn>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>φ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(D_{2^{j+1}}\varphi)=2\cdot(h*Q(D_{2^{j}}\varphi))
  </annotation>
 </semantics>
</math>

</p>
<h3 id="convolution">Convolution</h3>

<p>If 

<math display="inline" id="Refinable_function:29">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 is refinable with respect to 

<math display="inline" id="Refinable_function:30">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Refinable_function:31">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

 is refinable with respect to 

<math display="inline" id="Refinable_function:32">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Refinable_function:33">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mo>*</mo>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>φ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi*\psi
  </annotation>
 </semantics>
</math>

 is refinable with respect to 

<math display="inline" id="Refinable_function:34">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>*</mo>
   <mi>g</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <ci>g</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h*g
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="differentiation">Differentiation</h3>

<p>If 

<math display="inline" id="Refinable_function:35">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 is refinable with respect to 

<math display="inline" id="Refinable_function:36">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

, and the derivative 

<math display="inline" id="Refinable_function:37">
 <semantics>
  <msup>
   <mi>φ</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>φ</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi^{\prime}
  </annotation>
 </semantics>
</math>

 exists, then 

<math display="inline" id="Refinable_function:38">
 <semantics>
  <msup>
   <mi>φ</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>φ</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi^{\prime}
  </annotation>
 </semantics>
</math>

 is refinable with respect to 

<math display="inline" id="Refinable_function:39">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mo>⋅</mo>
   <mi>h</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <cn type="integer">2</cn>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\cdot h
  </annotation>
 </semantics>
</math>

. This can be interpreted as a special case of the convolution property, where one of the convolution operands is a derivative of the <a href="Dirac_delta_function" title="wikilink">Dirac impulse</a>.</p>
<h3 id="integration">Integration</h3>

<p>If 

<math display="inline" id="Refinable_function:40">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 is refinable with respect to 

<math display="inline" id="Refinable_function:41">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

, and there is an antiderivative 

<math display="inline" id="Refinable_function:42">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Refinable_function:43">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mn>0</mn>
     <mi>t</mi>
    </msubsup>
    <mrow>
     <mi>φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>τ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">d</mi>
     <mi>τ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Φ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>φ</ci>
      <ci>τ</ci>
      <ci>normal-d</ci>
      <ci>τ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(t)=\int_{0}^{t}\varphi(\tau)\mathrm{d}\tau
  </annotation>
 </semantics>
</math>

, then the antiderivative 

<math display="inline" id="Refinable_function:44">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>↦</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi>c</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>t</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>normal-Φ</ci>
      <ci>t</ci>
     </apply>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\mapsto\Phi(t)+c
  </annotation>
 </semantics>
</math>

 is refinable with respect to mask 

<math display="inline" id="Refinable_function:45">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
   <mo>⋅</mo>
   <mi>h</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2}\cdot h
  </annotation>
 </semantics>
</math>

 where the constant 

<math display="inline" id="Refinable_function:46">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 must fulfill 

<math display="inline" id="Refinable_function:47">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <msub>
        <mo largeop="true" symmetric="true">∑</mo>
        <mi>j</mi>
       </msub>
       <msub>
        <mi>h</mi>
        <mi>j</mi>
       </msub>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mi>j</mi>
    </msub>
    <mrow>
     <mrow>
      <msub>
       <mi>h</mi>
       <mi>j</mi>
      </msub>
      <mo>⋅</mo>
      <mi mathvariant="normal">Φ</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mi>j</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <ci>c</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>j</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>j</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>j</ci>
       </apply>
       <ci>normal-Φ</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\cdot(1-\sum_{j}h_{j})=\sum_{j}h_{j}\cdot\Phi(-j)
  </annotation>
 </semantics>
</math>

.</p>

<p>If 

<math display="inline" id="Refinable_function:48">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 has <a href="compact_support" title="wikilink">bounded support</a>, then we can interpret integration as convolution with the <a href="Heaviside_function" title="wikilink">Heaviside function</a> and apply the convolution law.</p>
<h3 id="scalar-products">Scalar products</h3>

<p>Computing the scalar products of two refinable functions and their translates can be broken down to the two above properties. Let 

<math display="inline" id="Refinable_function:49">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 be the translation operator. It holds</p>

<p>

<math display="block" id="Refinable_function:50">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>φ</mi>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>T</mi>
      <mi>k</mi>
     </msub>
     <mi>ψ</mi>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mi>φ</mi>
     <mo>*</mo>
     <msup>
      <mi>ψ</mi>
      <mo>*</mo>
     </msup>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>T</mi>
      <mi>k</mi>
     </msub>
     <mi>δ</mi>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>φ</mi>
      <mo>*</mo>
      <msup>
       <mi>ψ</mi>
       <mo>*</mo>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <list>
      <ci>φ</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <ci>k</ci>
       </apply>
       <ci>ψ</ci>
      </apply>
     </list>
     <list>
      <apply>
       <times></times>
       <ci>φ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ψ</ci>
        <times></times>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <ci>k</ci>
       </apply>
       <ci>δ</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>φ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ψ</ci>
        <times></times>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\varphi,T_{k}\psi\rangle=\langle\varphi*\psi^{*},T_{k}\delta\rangle=(%
\varphi*\psi^{*})(k)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Refinable_function:51">
 <semantics>
  <msup>
   <mi>ψ</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ψ</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi^{*}
  </annotation>
 </semantics>
</math>

 is the <a href="adjoint_filter" title="wikilink">adjoint</a> of 

<math display="inline" id="Refinable_function:52">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

 with respect to <a class="uri" href="convolution" title="wikilink">convolution</a>, i.e. 

<math display="inline" id="Refinable_function:53">
 <semantics>
  <msup>
   <mi>ψ</mi>
   <mo>*</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ψ</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi^{*}
  </annotation>
 </semantics>
</math>

 is the flipped and <a href="complex_conjugate" title="wikilink">complex conjugated</a> version of 

<math display="inline" id="Refinable_function:54">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

, i.e. 

<math display="inline" id="Refinable_function:55">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>ψ</mi>
     <mo>*</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mover accent="true">
    <mrow>
     <mi>ψ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mi>t</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>¯</mo>
   </mover>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ψ</ci>
      <times></times>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <ci>normal-¯</ci>
     <apply>
      <times></times>
      <ci>ψ</ci>
      <apply>
       <minus></minus>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi^{*}(t)=\overline{\psi(-t)}
  </annotation>
 </semantics>
</math>

.</p>

<p>Because of the above property, 

<math display="inline" id="Refinable_function:56">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mo>*</mo>
   <msup>
    <mi>ψ</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>φ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ψ</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi*\psi^{*}
  </annotation>
 </semantics>
</math>

 is refinable with respect to 

<math display="inline" id="Refinable_function:57">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>*</mo>
   <msup>
    <mi>g</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>g</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h*g^{*}
  </annotation>
 </semantics>
</math>

, and its values at integral arguments can be computed as eigenvectors of the transfer matrix. This idea can be easily generalized to integrals of products of more than two refinable functions.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h3 id="smoothness">Smoothness</h3>

<p>A refinable function usually has a fractal shape. The design of continuous or smooth refinable functions is not obvious. Before dealing with forcing smoothness it is necessary to measure smoothness of refinable functions. Using the Villemoes machine<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> one can compute the smoothness of refinable functions in terms of <a href="Sobolev_space" title="wikilink">Sobolev exponents</a>.</p>

<p>In a first step the refinement mask 

<math display="inline" id="Refinable_function:58">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 is divided into a filter 

<math display="inline" id="Refinable_function:59">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

, which is a power of the smoothness factor 

<math display="inline" id="Refinable_function:60">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">1</cn>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1,1)
  </annotation>
 </semantics>
</math>

 (this is a binomial mask) and a rest 

<math display="inline" id="Refinable_function:61">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

. Roughly spoken, the binomial mask 

<math display="inline" id="Refinable_function:62">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 makes smoothness and 

<math display="inline" id="Refinable_function:63">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 represents a fractal component, which reduces smoothness again. Now the Sobolev exponent is roughly the order of 

<math display="inline" id="Refinable_function:64">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 minus <a class="uri" href="logarithm" title="wikilink">logarithm</a> of the <a href="spectral_radius" title="wikilink">spectral radius</a> of 

<math display="inline" id="Refinable_function:65">
 <semantics>
  <msub>
   <mi>T</mi>
   <mrow>
    <mi>q</mi>
    <mo>*</mo>
    <msup>
     <mi>q</mi>
     <mo>*</mo>
    </msup>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <apply>
     <times></times>
     <ci>q</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>q</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{q*q^{*}}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="generalization">Generalization</h2>

<p>The concept of refinable functions can be generalized to functions of more than one variable, that is functions from 

<math display="inline" id="Refinable_function:66">
 <semantics>
  <mrow>
   <msup>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\R</mtext>
    </merror>
    <mi>d</mi>
   </msup>
   <mo>→</mo>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\R</mtext>
   </merror>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <mtext>\R</mtext>
     <ci>d</ci>
    </apply>
    <mtext>\R</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \R^{d}\to\R
  </annotation>
 </semantics>
</math>

. The most simple generalization is about <a href="tensor_product" title="wikilink">tensor products</a>. If 

<math display="inline" id="Refinable_function:67">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Refinable_function:68">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

 are refinable with respect to 

<math display="inline" id="Refinable_function:69">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Refinable_function:70">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

, respectively, then 

<math display="inline" id="Refinable_function:71">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mo>⊗</mo>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <ci>φ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi\otimes\psi
  </annotation>
 </semantics>
</math>

 is refinable with respect to 

<math display="inline" id="Refinable_function:72">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>⊗</mo>
   <mi>g</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <ci>h</ci>
    <ci>g</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h\otimes g
  </annotation>
 </semantics>
</math>

.</p>

<p>The scheme can be generalized even more to different scaling factors with respect to different dimensions or even to mixing data between dimensions.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Instead of scaling by scalar factor like 2 the signal the coordinates are transformed by a matrix 

<math display="inline" id="Refinable_function:73">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 of integers. In order to let the scheme work, the absolute values of all eigenvalues of 

<math display="inline" id="Refinable_function:74">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 must be larger than one. (Maybe it also suffices that 

<math display="inline" id="Refinable_function:75">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mo>det</mo>
     <mi>M</mi>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>></mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <abs></abs>
     <apply>
      <determinant></determinant>
      <ci>M</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\det M|>1
  </annotation>
 </semantics>
</math>

.)</p>

<p>Formally the two-scale equation does not change very much:</p>

<p>

<math display="block" id="Refinable_function:76">
 <semantics>
  <mrow>
   <mrow>
    <mi>φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mo movablelimits="false">det</mo>
      <mi>M</mi>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>⋅</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>∈</mo>
       <msup>
        <merror class="ltx_ERROR undefined undefined">
         <mtext>\Z</mtext>
        </merror>
        <mi>d</mi>
       </msup>
      </mrow>
     </munder>
     <mrow>
      <mrow>
       <msub>
        <mi>h</mi>
        <mi>k</mi>
       </msub>
       <mo>⋅</mo>
       <mi>φ</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>M</mi>
         <mo>⋅</mo>
         <mi>x</mi>
        </mrow>
        <mo>-</mo>
        <mi>k</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>φ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <abs></abs>
      <apply>
       <determinant></determinant>
       <ci>M</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>k</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <mtext>\Z</mtext>
         <ci>d</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>h</ci>
         <ci>k</ci>
        </apply>
        <ci>φ</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <ci>normal-⋅</ci>
         <ci>M</ci>
         <ci>x</ci>
        </apply>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi(x)=|\det M|\cdot\sum_{k\in\Z^{d}}h_{k}\cdot\varphi(M\cdot x-k)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Refinable_function:77">
 <semantics>
  <mrow>
   <mi>φ</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mo movablelimits="false">det</mo>
       <mi>M</mi>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mo>⋅</mo>
     <msub>
      <mi>D</mi>
      <msup>
       <mi>M</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </msub>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>h</mi>
      <mo>*</mo>
      <mi>φ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>φ</ci>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <abs></abs>
       <apply>
        <determinant></determinant>
        <ci>M</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>D</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>M</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>φ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi=|\det M|\cdot D_{M^{-1}}(h*\varphi)
  </annotation>
 </semantics>
</math>

</p>
<h2 id="examples">Examples</h2>
<ul>
<li>If the definition is extended to <a href="Distribution_(mathematics)" title="wikilink">distributions</a>, then the <a href="Dirac_delta_function" title="wikilink">Dirac impulse</a> is refinable with respect to the unit vector 

<math display="inline" id="Refinable_function:78">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

, that is known as <a href="Kronecker_delta" title="wikilink">Kronecker delta</a>. The 

<math display="inline" id="Refinable_function:79">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-th derivative of the Dirac distribution is refinable with respect to 

<math display="inline" id="Refinable_function:80">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mi>n</mi>
   </msup>
   <mo>⋅</mo>
   <mi>δ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n}\cdot\delta
  </annotation>
 </semantics>
</math>

.</li>
<li>The <a href="Heaviside_function" title="wikilink">Heaviside function</a> is refinable with respect to 

<math display="inline" id="Refinable_function:81">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
   <mo>⋅</mo>
   <mi>δ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2}\cdot\delta
  </annotation>
 </semantics>
</math>

.</li>
<li>The <a href="truncated_power_function" title="wikilink">truncated power functions</a> with exponent 

<math display="inline" id="Refinable_function:82">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 are refinable with respect to 

<math display="inline" id="Refinable_function:83">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mfrac>
   <mo>⋅</mo>
   <mi>δ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <ci>δ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2^{n+1}}\cdot\delta
  </annotation>
 </semantics>
</math>

.</li>
<li>The <a href="triangular_function" title="wikilink">triangular function</a> is a refinable function.<ref></ref></li>
</ul>

<p> <a class="uri" href="B-spline" title="wikilink">B-spline</a> functions with successive integral nodes are refinable, because of the convolution theorem and the refinability of the <a href="indicator_function" title="wikilink">characteristic function</a> for the interval 

<math display="inline" id="Refinable_function:84">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed-open">
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [0,1)
  </annotation>
 </semantics>
</math>

 (a <a href="boxcar_function" title="wikilink">boxcar function</a>).</p>
<ul>
<li>All <a href="polynomial_function" title="wikilink">polynomial functions</a> are refinable. For every refinement mask there is a polynomial that is uniquely defined up to a constant factor. For every polynomial of degree 

<math display="inline" id="Refinable_function:85">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 there are many refinement masks that all differ by a mask of type 

<math display="inline" id="Refinable_function:86">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>*</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>v</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <interval closure="open">
      <cn type="integer">1</cn>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </interval>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v*(1,-1)^{n+1}
  </annotation>
 </semantics>
</math>

 for any mask 

<math display="inline" id="Refinable_function:87">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 and the convolutional power 

<math display="inline" id="Refinable_function:88">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <interval closure="open">
     <cn type="integer">1</cn>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </interval>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (1,-1)^{n+1}
  </annotation>
 </semantics>
</math>

.<ref></ref></li>
</ul>

<p></p>
<ul>
<li>A <a href="rational_function" title="wikilink">rational function</a> 

<math display="inline" id="Refinable_function:89">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 is refinable if and only if it can be represented using <a href="partial_fraction" title="wikilink">partial fractions</a> as 

<math display="inline" id="Refinable_function:90">
 <semantics>
  <mrow>
   <mrow>
    <mi>φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>∈</mo>
      <mi>ℤ</mi>
     </mrow>
    </msub>
    <mfrac>
     <msub>
      <mi>s</mi>
      <mi>i</mi>
     </msub>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <mi>i</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>k</mi>
     </msup>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>φ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>i</ci>
       <ci>ℤ</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi(x)=\sum_{i\in\mathbb{Z}}\frac{s_{i}}{(x-i)^{k}}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Refinable_function:91">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is a <a href="positive_number" title="wikilink">positive</a> <a href="natural_number" title="wikilink">natural number</a> and 

<math display="inline" id="Refinable_function:92">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 is a real sequence with finitely many non-zero elements (a <a href="Laurent_polynomial" title="wikilink">Laurent polynomial</a>) such that 

<math display="inline" id="Refinable_function:93">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo stretchy="false">|</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>↑</mo>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <ci>normal-|</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-↑</ci>
     <cn type="integer">2</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s|(s\uparrow 2)
  </annotation>
 </semantics>
</math>

 (read

<math display="block" id="Refinable_function:94">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>ℝ</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>z</mi>
       <mo>,</mo>
       <msup>
        <mi>z</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mo rspace="7.5pt" stretchy="false">]</mo>
      </mrow>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⋅</mo>
     <mi>s</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>z</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>z</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <ci>ℝ</ci>
        <interval closure="closed">
         <ci>z</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>z</ci>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </interval>
        <ci>h</ci>
        <ci>z</ci>
       </apply>
       <ci>s</ci>
      </apply>
      <ci>z</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>s</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists h(z)\in\mathbb{R}[z,z^{-1}]\ h(z)\cdot s(z)=s(z^{2})
  </annotation>
 </semantics>
</math>

). The Laurent polynomial 

<math display="inline" id="Refinable_function:95">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>k</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>⋅</mo>
   <mi>h</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{k-1}\cdot h
  </annotation>
 </semantics>
</math>

 is the associated refinement mask.<ref></ref></li>
</ul>

<p></p>
<h2 id="references">References</h2>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Subdivision_surface" title="wikilink">Subdivision scheme</a></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Wavelets" title="wikilink">Category:Wavelets</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
