<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1471">Signed zero</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Signed zero</h1>
<hr/>

<p><strong>Signed zero</strong> is <a class="uri" href="zero" title="wikilink">zero</a> with an associated <a href="Plus_and_minus_signs" title="wikilink">sign</a>. In ordinary arithmetic, the number 0 does not have a sign, so that −0, +0 and 0 are identical. However, in <a class="uri" href="computing" title="wikilink">computing</a>, some number representations allow for the existence of two zeros, often denoted by <strong>−0</strong> (<strong>negative zero</strong>) and <strong>+0</strong> (<strong>positive zero</strong>), regarded as equal by the numerical comparison operations but with possible different behaviors in particular operations. This occurs in the <em>sign and magnitude</em> and <em>ones' complement</em> <a href="signed_number_representation" title="wikilink">signed number representations</a> for integers, and in most <a href="floating-point_number" title="wikilink">floating-point number</a> representations. The number 0 is usually encoded as +0, but can be represented by either +0 or −0.</p>

<p>The <a href="IEEE_754" title="wikilink">IEEE 754</a> standard for floating-point arithmetic (presently used by most computers and programming languages that support floating point numbers) requires both +0 and −0. Real arithmetic with signed zeros can be considered a variant of the <a href="extended_real_number_line" title="wikilink">extended real number line</a> such that 1/−0 = −<a href="infinity" title="wikilink">∞</a> and 1/+0 = +∞; <a href="Division_(mathematics)" title="wikilink">division</a> is only <a href="Indeterminate_form" title="wikilink">undefined</a> for <a href="Plus-minus_sign" title="wikilink">±</a>0/±0 and ±∞/±∞.</p>

<p>Negatively signed zero echoes the <a href="mathematical_analysis" title="wikilink">mathematical analysis</a> concept of approaching 0 from below as a <a href="one-sided_limit" title="wikilink">one-sided limit</a>, which may be denoted by <em>x</em> → 0<sup>−</sup>, <em>x</em> → 0−, or <em>x</em> → ↑0. The notation "−0" may be used informally to denote a small negative number that has been <a href="rounding" title="wikilink">rounded</a> to zero. The concept of negative zero also has some theoretical applications in <a href="statistical_mechanics" title="wikilink">statistical mechanics</a> and other disciplines.</p>

<p>It is claimed that the inclusion of signed zero in IEEE 754 makes it much easier to achieve numerical accuracy in some critical problems,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> in particular when computing with <a href="complex_numbers" title="wikilink">complex</a> elementary functions.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> On the other hand, the concept of signed zero runs contrary to the general assumption made in most mathematical fields (and in most mathematics courses) that negative zero is the same thing as zero. Representations that allow negative zero can be a source of errors in programs, as software developers do not realize (or may forget) that, while the two zero representations behave as equal under numeric comparisons, they yield different results in some operations.</p>
<h2 id="representations">Representations</h2>

<p>The widely used <a href="two's_complement" title="wikilink">two's complement</a> encoding does not allow a negative zero. In a 1+7-bit <a href="signed_magnitude" title="wikilink">sign-and-magnitude</a> representation for integers, negative zero is represented by the bit string 1000 0000. In an 8-bit <a href="one's_complement" title="wikilink">one's complement</a> representation, negative zero is represented by the bit string 1111 1111. In all three encodings, positive zero is represented by .</p>

<p> In <a href="IEEE_floating-point_standard" title="wikilink">IEEE 754</a> binary floating point numbers, zero values are represented by the biased exponent and <a class="uri" href="significand" title="wikilink">significand</a> both being zero. Negative zero has the sign bit set to one. One may obtain negative zero as the result of certain computations, for instance as the result of <a href="arithmetic_underflow" title="wikilink">arithmetic underflow</a> on a negative number, or <code>−1.0*0.0</code>, or simply as <code>−0.0</code>.</p>

<p>In <a href="IEEE_754-2008" title="wikilink">IEEE 754</a> decimal floating point encoding, a negative zero is represented by an exponent being any valid exponent in the range for the encoding, the true significand being zero, and the sign bit being one.</p>
<h2 id="properties-and-handling">Properties and handling</h2>

<p>The IEEE 754 floating point standard specifies the behavior of positive zero and negative zero under various operations. The outcome may depend on the current <a href="floating_point#Rounding_modes" title="wikilink">IEEE rounding mode</a> settings.</p>
<h3 id="notation">Notation</h3>

<p>In systems that include both signed and unsigned zeros, notation 

<math display="inline" id="Signed_zero:0">
<semantics>
<msup>
<mn>0</mn>
<mo>+</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">0</cn>
<plus></plus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   0^{+}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Signed_zero:1">
<semantics>
<msup>
<mn>0</mn>
<mo>-</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">0</cn>
<minus></minus>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   0^{-}
  </annotation>
</semantics>
</math>

 is sometimes used for signed zeros.</p>
<h3 id="arithmetic">Arithmetic</h3>

<p>Multiplication and division follow their usual rules for combining signs:</p>
<ul>
<li>
<math display="inline" id="Signed_zero:2">
<semantics>
<mrow>
<mfrac>
<mrow>
<mo>-</mo>
<mn>0</mn>
</mrow>
<mrow>
<mo>|</mo>
<mi>x</mi>
<mo>|</mo>
</mrow>
</mfrac>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mn>0</mn>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<divide></divide>
<apply>
<minus></minus>
<cn type="integer">0</cn>
</apply>
<apply>
<abs></abs>
<ci>x</ci>
</apply>
</apply>
<apply>
<minus></minus>
<cn type="integer">0</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \frac{-0}{\left|x\right|}=-0\,\!
  </annotation>
</semantics>
</math>

 (for 

<math display="inline" id="Signed_zero:3">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

 different from 0)</li>
</ul>
<ul>
<li>
<math display="inline" id="Signed_zero:4">
<semantics>
<mrow>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mn>0</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>⋅</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mn>0</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mo>+</mo>
<mn>0</mn>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<ci>normal-⋅</ci>
<apply>
<minus></minus>
<cn type="integer">0</cn>
</apply>
<apply>
<minus></minus>
<cn type="integer">0</cn>
</apply>
</apply>
<apply>
<plus></plus>
<cn type="integer">0</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (-0)\cdot(-0)=+0\,\!
  </annotation>
</semantics>
</math>
</li>
</ul>

<p>Addition and subtraction are handled specially if the values could cancel:</p>
<ul>
<li>
<math display="inline" id="Signed_zero:5">
<semantics>
<mrow>
<mrow>
<mi>x</mi>
<mo>+</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>±</mo>
<mn>0</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mi>x</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<plus></plus>
<ci>x</ci>
<apply>
<csymbol cd="latexml">plus-or-minus</csymbol>
<cn type="integer">0</cn>
</apply>
</apply>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x+(\pm 0)=x\,\!
  </annotation>
</semantics>
</math>

 (for 

<math display="inline" id="Signed_zero:6">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

 different from 0)</li>
</ul>
<ul>
<li>
<math display="inline" id="Signed_zero:7">
<semantics>
<mrow>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mn>0</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>+</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mn>0</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mn>0</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>-</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>+</mo>
<mn>0</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mn>0</mn>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<plus></plus>
<apply>
<minus></minus>
<cn type="integer">0</cn>
</apply>
<apply>
<minus></minus>
<cn type="integer">0</cn>
</apply>
</apply>
<apply>
<minus></minus>
<apply>
<minus></minus>
<cn type="integer">0</cn>
</apply>
<apply>
<plus></plus>
<cn type="integer">0</cn>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<minus></minus>
<cn type="integer">0</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (-0)+(-0)=(-0)-(+0)=-0\,\!
  </annotation>
</semantics>
</math>
</li>
</ul>
<ul>
<li>
<math display="inline" id="Signed_zero:8">
<semantics>
<mrow>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>+</mo>
<mn>0</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>+</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>+</mo>
<mn>0</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>+</mo>
<mn>0</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>-</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mn>0</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mo>+</mo>
<mn>0</mn>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<plus></plus>
<apply>
<plus></plus>
<cn type="integer">0</cn>
</apply>
<apply>
<plus></plus>
<cn type="integer">0</cn>
</apply>
</apply>
<apply>
<minus></minus>
<apply>
<plus></plus>
<cn type="integer">0</cn>
</apply>
<apply>
<minus></minus>
<cn type="integer">0</cn>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<plus></plus>
<cn type="integer">0</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (+0)+(+0)=(+0)-(-0)=+0\,\!
  </annotation>
</semantics>
</math>
</li>
</ul>
<ul>
<li>
<math display="inline" id="Signed_zero:9">
<semantics>
<mrow>
<mrow>
<mi>x</mi>
<mo>-</mo>
<mi>x</mi>
</mrow>
<mo>=</mo>
<mrow>
<mi>x</mi>
<mo>+</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mi>x</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mo>+</mo>
<mn>0</mn>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<minus></minus>
<ci>x</ci>
<ci>x</ci>
</apply>
<apply>
<plus></plus>
<ci>x</ci>
<apply>
<minus></minus>
<ci>x</ci>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<plus></plus>
<cn type="integer">0</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x-x=x+(-x)=+0\,\!
  </annotation>
</semantics>
</math>

 (for any finite 

<math display="inline" id="Signed_zero:10">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

, −0 when rounding toward negative)</li>
</ul>

<p>Because of negative zero (and also when the rounding mode is upward or downward), the statements  and , for floating-point variables <em>x</em>, <em>y</em>, and <em>z</em>, cannot be optimized to .</p>

<p>Some other special rules:</p>
<ul>
<li>
<math display="inline" id="Signed_zero:11">
<semantics>
<mrow>
<msqrt>
<mrow>
<mo>-</mo>
<mn>0</mn>
</mrow>
</msqrt>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mn>0</mn>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<root></root>
<apply>
<minus></minus>
<cn type="integer">0</cn>
</apply>
</apply>
<apply>
<minus></minus>
<cn type="integer">0</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \sqrt{-0}=-0\,\!
  </annotation>
</semantics>
</math>
<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></li>
</ul>
<ul>
<li>
<math display="inline" id="Signed_zero:12">
<semantics>
<mrow>
<mfrac>
<mrow>
<mo>-</mo>
<mn>0</mn>
</mrow>
<mrow>
<mo>-</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</mfrac>
<mo>=</mo>
<mrow>
<mo>+</mo>
<mn>0</mn>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<divide></divide>
<apply>
<minus></minus>
<cn type="integer">0</cn>
</apply>
<apply>
<minus></minus>
<infinity></infinity>
</apply>
</apply>
<apply>
<plus></plus>
<cn type="integer">0</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \frac{-0}{-\infty}=+0\,\!
  </annotation>
</semantics>
</math>

 (follows the sign rule for division)</li>
</ul>
<ul>
<li>
<math display="inline" id="Signed_zero:13">
<semantics>
<mrow>
<mfrac>
<mrow>
<mo>|</mo>
<mi>x</mi>
<mo>|</mo>
</mrow>
<mrow>
<mo>-</mo>
<mn>0</mn>
</mrow>
</mfrac>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<divide></divide>
<apply>
<abs></abs>
<ci>x</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">0</cn>
</apply>
</apply>
<apply>
<minus></minus>
<infinity></infinity>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \frac{\left|x\right|}{-0}=-\infty\,\!
  </annotation>
</semantics>
</math>

 (for non-zero 

<math display="inline" id="Signed_zero:14">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

, follows the sign rule for division)</li>
</ul>
<ul>
<li>
<math display="inline" id="Signed_zero:15">
<semantics>
<mrow>
<mo>±</mo>
<mn>0</mn>
<mo>×</mo>
<mo>±</mo>
<mi mathvariant="normal">∞</mi>
<mo>=</mo>
<mtext>NaN</mtext>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="latexml">plus-or-minus</csymbol>
<cn type="integer">0</cn>
<times></times>
<csymbol cd="latexml">plus-or-minus</csymbol>
<infinity></infinity>
<eq></eq>
<mtext>NaN</mtext>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   {\pm 0}\times{\pm\infty}=\mbox{NaN}\,\!
  </annotation>
</semantics>
</math>

 (<a href="Not_a_Number" title="wikilink">Not a Number</a> or interrupt for <a href="indeterminate_form" title="wikilink">indeterminate form</a>)</li>
</ul>
<ul>
<li>
<math display="inline" id="Signed_zero:16">
<semantics>
<mrow>
<mfrac>
<mrow>
<mo>±</mo>
<mn>0</mn>
</mrow>
<mrow>
<mo>±</mo>
<mn>0</mn>
</mrow>
</mfrac>
<mo>=</mo>
<mtext>NaN</mtext>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<divide></divide>
<apply>
<csymbol cd="latexml">plus-or-minus</csymbol>
<cn type="integer">0</cn>
</apply>
<apply>
<csymbol cd="latexml">plus-or-minus</csymbol>
<cn type="integer">0</cn>
</apply>
</apply>
<mtext>NaN</mtext>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \frac{\pm 0}{\pm 0}=\mbox{NaN}\,\!
  </annotation>
</semantics>
</math>
</li>
</ul>

<p>Division of a non-zero number by zero sets the divide by zero <a href="flag_(computing)" title="wikilink">flag</a>, and an operation producing a NaN sets the invalid operation flag. An <a href="exception_handling" title="wikilink">exception handler</a> is called if enabled for the corresponding flag.</p>
<h3 id="comparisons">Comparisons</h3>

<p>According to the IEEE 754 standard, negative zero and positive zero should compare as equal with the usual (numerical) comparison operators, like the <code>==</code> operators of <a href="C_(programming_language)" title="wikilink">C</a> and <a href="Java_programming_language" title="wikilink">Java</a>. In those languages, special programming tricks may be needed to distinguish the two values:</p>
<ul>
<li><a href="Type_punning" title="wikilink">Type punning</a> the number to an integer type, so as to look at the sign bit in the bit pattern;</li>
<li>using the ISO C <code>copysign()</code> function (IEEE 754 copySign operation) to copy the sign of the zero to some non-zero number;</li>
<li>using the ISO C <code>signbit()</code> macro (IEEE 754 isSignMinus operation) that returns whether the sign bit of a number is set;</li>
<li>taking the reciprocal of the zero to obtain either 1/(+0) = +∞ or 1/(−0) = −∞ (if the <a href="division_by_zero" title="wikilink">division by zero</a> exception is not trapped).</li>
</ul>

<p>Note: <a href="Cast_(computer_programming)" title="wikilink">Casting</a> to integral type will not always work, especially on two's complement systems.</p>

<p>However, some programming languages may provide alternative comparison operators that do distinguish the two zeros. This is the case, for example, of the <code>equals</code> method in Java's <code>Double</code> class.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="scientific-uses">Scientific uses</h2>

<p>Informally, one may use the notation "−0" for a negative value that was rounded to zero. This notation may be useful when a negative sign is significant; for example, when tabulating <a class="uri" href="Celsius" title="wikilink">Celsius</a> temperatures, where a negative sign means <em>below freezing</em>.</p>

<p>In statistical mechanics, one sometimes uses <a href="negative_temperature" title="wikilink">negative temperatures</a> to describe systems with <a href="population_inversion" title="wikilink">population inversion</a>, which can be considered to have a temperature greater than positive infinity, because the coefficient of energy in the population distribution function is −1/Temperature. In this context, a temperature of −0 is a (theoretical) temperature larger than any other negative temperature, corresponding to the (theoretical) maximum conceivable extent of population inversion, the opposite extreme to +0.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Line_with_two_origins" title="wikilink">Line with two origins</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li>

<p>— a <em>decimal</em> floating point specification that includes negative zero</p></li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>

<p>— the changes in the <a class="uri" href="Fortran" title="wikilink">Fortran</a> <code>SIGN</code> function in Fortran 95 to accommodate negative zero</p></li>
<li>

<p>— JScript's floating point type has negative zero by definition</p></li>
<li>

<p>— representation of negative zero in the <a href="Java_virtual_machine" title="wikilink">Java virtual machine</a></p></li>
<li>

<p>— how to handle negative zero when comparing floating-point numbers</p></li>
<li>

<p>— One's complement numbers on the <a class="uri" href="UNIVAC" title="wikilink">UNIVAC</a> 1100 family computers.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Computer_arithmetic" title="wikilink">Category:Computer arithmetic</a> <a href="Category:Integers" title="wikilink">-9 (number)</a> <a href="Category:0_(number)" title="wikilink">Category:0 (number)</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="William_Kahan" title="wikilink">William Kahan</a>, "Branch Cuts for Complex Elementary Functions, or Much Ado About Nothing's Sign Bit", in <a href="http://portal.acm.org/citation.cfm?id=59678"><em>The State of the Art in Numerical Analysis</em></a> (eds. Iserles and Powell), Clarendon Press, Oxford, 1987.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="William_Kahan" title="wikilink">William Kahan</a>, <a href="http://www.cs.berkeley.edu/~wkahan/Math185/Derivative.pdf">Derivatives in the Complex z-plane</a>, p 10.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="http://java.sun.com/javase/6/docs/api/java/lang/Double.html#equals%28java.lang.Object%29"></a><a class="uri" href="http://java.sun.com/javase/6/docs/api/java/lang/Double.html#equals(java.lang.Object)">http://java.sun.com/javase/6/docs/api/java/lang/Double.html#equals(java.lang.Object)</a><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
