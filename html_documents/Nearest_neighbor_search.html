<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1435">Nearest neighbor search</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Nearest neighbor search</h1>
<hr/>

<p><strong>Nearest neighbor search</strong> (<strong>NNS</strong>), also known as <strong>proximity search</strong>, <strong>similarity search</strong> or <strong><a href="Closest_pair_of_points_problem" title="wikilink">closest point search</a></strong>, is an <a href="optimization_problem" title="wikilink">optimization problem</a> for finding closest (or most similar) points. Closeness is typically expressed in terms of a dissimilarity function: the less similar the objects, the larger the function values. Formally, the nearest-neighbor (NN) search problem is defined as follows: given a set <em>S</em> of points in a space <em>M</em> and a query point <em>q</em>¬†‚àà¬†<em>M</em>, find the closest point in <em>S</em> to <em>q</em>. <a href="Donald_Knuth" title="wikilink">Donald Knuth</a> in vol. 3 of <em><a href="The_Art_of_Computer_Programming" title="wikilink">The Art of Computer Programming</a></em> (1973) called it the <strong>post-office problem</strong>, referring to an application of assigning to a residence the nearest post office. A direct generalization of this problem is a <em>k</em>-NN search, where we need to find the <em>k</em> closest points.</p>

<p>Most commonly <em>M</em> is a <a href="metric_space" title="wikilink">metric space</a> and dissimilarity is expressed as a <a href="distance_metric" title="wikilink">distance metric</a>, which is symmetric and satisfies the <a href="triangle_inequality" title="wikilink">triangle inequality</a>. Even more common, <em>M</em> is taken to be the <em>d</em>-dimensional <a href="vector_space" title="wikilink">vector space</a> where dissimilarity is measured using the <a href="Euclidean_distance" title="wikilink">Euclidean distance</a>, <a href="Taxicab_geometry" title="wikilink">Manhattan distance</a> or other <a href="Statistical_distance" title="wikilink">distance metric</a>. However, the dissimilarity function can be arbitrary. One example are asymmetric <a href="Bregman_divergence" title="wikilink">Bregman divergences</a>, for which the triangle inequality does not hold.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="applications">Applications</h2>

<p>The nearest neighbor search problem arises in numerous fields of application, including:</p>
<ul>
<li><a href="Pattern_recognition" title="wikilink">Pattern recognition</a> - in particular for <a href="optical_character_recognition" title="wikilink">optical character recognition</a></li>
<li><a href="Statistical_classification" title="wikilink">Statistical classification</a>- see <a href="k-nearest_neighbor_algorithm" title="wikilink">k-nearest neighbor algorithm</a></li>
<li><a href="Computer_vision" title="wikilink">Computer vision</a></li>
<li><a href="Computational_Geometry" title="wikilink">Computational Geometry</a> - see <a href="Closest_pair_of_points_problem" title="wikilink">Closest pair of points problem</a></li>
<li><a href="Database" title="wikilink">Databases</a> - e.g. <a href="content-based_image_retrieval" title="wikilink">content-based image retrieval</a></li>
<li><a href="Coding_theory" title="wikilink">Coding theory</a> - see <a href="Decoding_methods" title="wikilink">maximum likelihood decoding</a></li>
<li><a href="Data_compression" title="wikilink">Data compression</a> - see <a class="uri" href="MPEG-2" title="wikilink">MPEG-2</a> standard</li>
<li><a href="Recommender_system" title="wikilink">Recommendation systems</a>, e.g. see <a href="Collaborative_filtering" title="wikilink">Collaborative filtering</a></li>
<li><a href="Internet_marketing" title="wikilink">Internet marketing</a> - see <a href="contextual_advertising" title="wikilink">contextual advertising</a> and <a href="behavioral_targeting" title="wikilink">behavioral targeting</a></li>
<li><a href="DNA_sequencing" title="wikilink">DNA sequencing</a></li>
<li><a href="Spell_checking" title="wikilink">Spell checking</a> - suggesting correct spelling</li>
<li><a href="Plagiarism_detection" title="wikilink">Plagiarism detection</a></li>
<li><a href="Contact_searching_algorithms_in_FEA" title="wikilink">Contact searching algorithms in FEA</a></li>
<li><a href="Similarity_score" title="wikilink">Similarity scores</a> for predicting career paths of professional athletes.</li>
<li><a href="Cluster_analysis" title="wikilink">Cluster analysis</a> - assignment of a set of observations into subsets (called clusters) so that observations in the same cluster are similar in some sense, usually based on <a href="Euclidean_distance" title="wikilink">Euclidean distance</a></li>
<li><a href="Chemical_similarity" title="wikilink">Chemical similarity</a></li>
<li><a href="Motion_planning#Sampling-Based_Algorithms" title="wikilink">Sampling-Based Motion Planning</a></li>
</ul>
<h2 id="methods">Methods</h2>

<p>Various solutions to the NNS problem have been proposed. The quality and usefulness of the algorithms are determined by the time complexity of queries as well as the space complexity of any search data structures that must be maintained. The informal observation usually referred to as the <a href="curse_of_dimensionality" title="wikilink">curse of dimensionality</a> states that there is no general-purpose exact solution for NNS in high-dimensional Euclidean space using polynomial preprocessing and polylogarithmic search time.</p>
<h3 id="linear-search">Linear search</h3>

<p>The simplest solution to the NNS problem is to compute the distance from the query point to every other point in the database, keeping track of the "best so far". This algorithm, sometimes referred to as the naive approach, has a <a href="running_time" title="wikilink">running time</a> of <em>O</em>(<em>dN</em>) where <em>N</em> is the <a class="uri" href="cardinality" title="wikilink">cardinality</a> of <em>S</em> and <em>d</em> is the dimensionality of <em>M</em>. There are no search data structures to maintain, so linear search has no space complexity beyond the storage of the database. Naive search can, on average, outperform space partitioning approaches on higher dimensional spaces.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h3 id="space-partitioning">Space partitioning</h3>

<p>Since the 1970s, <a href="branch_and_bound" title="wikilink">branch and bound</a> methodology has been applied to the problem. In the case of Euclidean space this approach is known as <a href="spatial_index" title="wikilink">spatial index</a> or spatial access methods. Several <a href="Space_partitioning" title="wikilink">space-partitioning</a> methods have been developed for solving the NNS problem. Perhaps the simplest is the <a href="k-d_tree" title="wikilink">k-d tree</a>, which iteratively bisects the search space into two regions containing half of the points of the parent region. Queries are performed via traversal of the tree from the root to a leaf by evaluating the query point at each split. Depending on the distance specified in the query, neighboring branches that might contain hits may also need to be evaluated. For constant dimension query time, average complexity is <em>O</em>(log¬†<em>N</em>) <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> in the case of randomly distributed points, worst case complexity analyses have been performed.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Alternatively the <a class="uri" href="R-tree" title="wikilink">R-tree</a> data structure was designed to support nearest neighbor search in dynamic context, as it has efficient algorithms for insertions and deletions such as the <a href="R*_tree" title="wikilink">R* tree</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> R-trees can yield nearest neighbors not only for Euclidean distance, but can also be used with other distances.</p>

<p>In case of general metric space branch and bound approach is known under the name of <a href="metric_trees" title="wikilink">metric trees</a>. Particular examples include <a class="uri" href="vp-tree" title="wikilink">vp-tree</a> and <a class="uri" href="BK-tree" title="wikilink">BK-tree</a>.</p>

<p>Using a set of points taken from a 3-dimensional space and put into a <a href="Binary_space_partitioning" title="wikilink">BSP tree</a>, and given a query point taken from the same space, a possible solution to the problem of finding the nearest point-cloud point to the query point is given in the following description of an algorithm. (Strictly speaking, no such point may exist, because it may not be unique. But in practice, usually we only care about finding any one of the subset of all point-cloud points that exist at the shortest distance to a given query point.) The idea is, for each branching of the tree, guess that the closest point in the cloud resides in the half-space containing the query point. This may not be the case, but it is a good heuristic. After having recursively gone through all the trouble of solving the problem for the guessed half-space, now compare the distance returned by this result with the shortest distance from the query point to the partitioning plane. This latter distance is that between the query point and the closest possible point that could exist in the half-space not searched. If this distance is greater than that returned in the earlier result, then clearly there is no need to search the other half-space. If there is such a need, then you must go through the trouble of solving the problem for the other half space, and then compare its result to the former result, and then return the proper result. The performance of this algorithm is nearer to logarithmic time than linear time when the query point is near the cloud, because as the distance between the query point and the closest point-cloud point nears zero, the algorithm needs only perform a look-up using the query point as a key to get the correct result.</p>
<h3 id="locality-sensitive-hashing">Locality sensitive hashing</h3>

<p><a href="Locality_sensitive_hashing" title="wikilink">Locality sensitive hashing</a> (LSH) is a technique for grouping points in space into 'buckets' based on some distance metric operating on the points. Points that are close to each other under the chosen metric are mapped to the same bucket with high probability.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h3 id="nearest-neighbor-search-in-spaces-with-small-intrinsic-dimension">Nearest neighbor search in spaces with small intrinsic dimension</h3>

<p>The <a href="cover_tree" title="wikilink">cover tree</a> has a theoretical bound that is based on the dataset's <a href="doubling_constant" title="wikilink">doubling constant</a>. The bound on search time is <em>O</em>(<em>c</em><sup>12</sup>¬†log¬†<em>n</em>) where <em>c</em> is the <a href="Expansivity_constant" title="wikilink">expansion constant</a> of the dataset.</p>
<h3 id="vector-approximation-files">Vector approximation files</h3>

<p>In high dimensional spaces, tree indexing structures become useless because an increasing percentage of the nodes need to be examined anyway. To speed up linear search, a compressed version of the feature vectors stored in RAM is used to prefilter the datasets in a first run. The final candidates are determined in a second stage using the uncompressed data from the disk for distance calculation.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h3 id="compressionclustering-based-search">Compression/clustering based search</h3>

<p>The VA-file approach is a special case of a compression based search, where each feature component is compressed uniformly and independently. The optimal compression technique in multidimensional spaces is Vector Quantization (VQ), implemented through clustering. The database is clustered and the most "promising" clusters are retrieved. Huge gains over VA-File, tree-based indexes and sequential scan have been observed.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> Also note the parallels between clustering and LSH.</p>
<h3 id="greedy-walks">Greedy walks</h3>

<p>One possible way to solve NNS is to construct a graph 

<math display="inline" id="Nearest_neighbor_search:0">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(V,E)
  </annotation>
 </semantics>
</math>

, where every point 

<math display="inline" id="Nearest_neighbor_search:1">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>‚àà</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}\in S
  </annotation>
 </semantics>
</math>

 is uniquely associated with vertex 

<math display="inline" id="Nearest_neighbor_search:2">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mo>‚àà</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}\in V
  </annotation>
 </semantics>
</math>

. The search of the point in the set <em>S</em> closest to the query <em>q</em> takes the form of the search of vertex in the graph 

<math display="inline" id="Nearest_neighbor_search:3">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(V,E)
  </annotation>
 </semantics>
</math>

. One of the basic vertex search algorithms in graphs with metric objects is the greedy search algorithm. It starts from the random vertex 

<math display="inline" id="Nearest_neighbor_search:4">
 <semantics>
  <mrow>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mo>‚àà</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}\in V
  </annotation>
 </semantics>
</math>

. The algorithm computes a distance value from the query q to each vertex from the neighborhood 

<math display="inline" id="Nearest_neighbor_search:5">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>v</mi>
    <mi>j</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>v</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>v</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>‚àà</mo>
    <mi>E</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <in></in>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>j</ci>
      </apply>
     </interval>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{v_{j}:(v_{i},v_{j})\in E\}
  </annotation>
 </semantics>
</math>

 of the current vertex 

<math display="inline" id="Nearest_neighbor_search:6">
 <semantics>
  <msub>
   <mi>v</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>v</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v_{i}
  </annotation>
 </semantics>
</math>

, and then selects a vertex with the minimal distance value. If the distance value between the query and the selected vertex is smaller than the one between the query and the current element, then the algorithm moves to the selected vertex, and it becomes new current vertex. The algorithm stops when it reaches a local minimum: a vertex whose neighborhood does not contain a vertex that is closer to the query than the vertex itself. This idea was exploited in VoroNet system <a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> for the plane, in RayNet system <a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> for the 

<math display="inline" id="Nearest_neighbor_search:7">
 <semantics>
  <msup>
   <mi>ùîº</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ùîº</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{E}^{n}
  </annotation>
 </semantics>
</math>

 and for the general metric space in Metrized Small World algorithm <a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h2 id="variants">Variants</h2>

<p>There are numerous variants of the NNS problem and the two most well-known are the <a href="K-nearest_neighbor_algorithm" title="wikilink"><em>k</em>-nearest neighbor search</a> and the <a href="Œµ-approximate_nearest_neighbor_search" title="wikilink">Œµ-approximate nearest neighbor search</a>.</p>
<h3 id="k-nearest-neighbor"><span id="K-nearest neighbor"> <em>k</em>-nearest neighbor </span></h3>

<p><a href="K-nearest_neighbor_algorithm" title="wikilink"><em>k</em>-nearest neighbor search</a> identifies the top <em>k</em> nearest neighbors to the query. This technique is commonly used in predictive analytics to estimate or classify a point based on the consensus of its neighbors. <em>k</em>-nearest neighbor graphs are graphs in which every point is connected to its <em>k</em> nearest neighbors.</p>
<h3 id="approximate-nearest-neighbor">Approximate nearest neighbor</h3>

<p>In some applications it may be acceptable to retrieve a "good guess" of the nearest neighbor. In those cases, we can use an algorithm which doesn't guarantee to return the actual nearest neighbor in every case, in return for improved speed or memory savings. Often such an algorithm will find the nearest neighbor in a majority of cases, but this depends strongly on the dataset being queried.</p>

<p>Algorithms that support the approximate nearest neighbor search include <a href="Locality-sensitive_hashing#LSH_algorithm_for_nearest_neighbor_search" title="wikilink">locality-sensitive hashing</a>, <a href="best_bin_first" title="wikilink">best bin first</a> and <a href="balanced_box-decomposition_tree" title="wikilink">balanced box-decomposition tree</a> based search.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h3 id="nearest-neighbor-distance-ratio">Nearest neighbor distance ratio</h3>

<p><a href="Nearest_neighbor_distance_ratio" title="wikilink">Nearest neighbor distance ratio</a> do not apply the threshold on the direct distance from the original point to the challenger neighbor but on a ratio of it depending on the distance to the previous neighbor. It is used in <a href="Content-based_image_retrieval" title="wikilink">CBIR</a> to retrieve pictures through a "query by example" using the similarity between local features. More generally it is involved in several <a href="Pattern_matching" title="wikilink">matching</a> problems.</p>
<h3 id="fixed-radius-near-neighbors">Fixed-radius near neighbors</h3>

<p><a href="Fixed-radius_near_neighbors" title="wikilink">Fixed-radius near neighbors</a> is the problem where one wants to efficiently find all points given in <a href="Euclidean_space" title="wikilink">Euclidean space</a> within a given fixed distance from a specified point. The data structure should work on a distance which is fixed however the query point is arbitrary.</p>
<h3 id="all-nearest-neighbors">All nearest neighbors</h3>

<p>For some applications (e.g. <a href="entropy_estimation" title="wikilink">entropy estimation</a>), we may have <em>N</em> data-points and wish to know which is the nearest neighbor <em>for every one of those N points</em>. This could of course be achieved by running a nearest-neighbor search once for every point, but an improved strategy would be an algorithm that exploits the information redundancy between these <em>N</em> queries to produce a more efficient search. As a simple example: when we find the distance from point <em>X</em> to point <em>Y</em>, that also tells us the distance from point <em>Y</em> to point <em>X</em>, so the same calculation can be reused in two different queries.</p>

<p>Given a fixed dimension, a semi-definite positive norm (thereby including every <a href="lp_space" title="wikilink">L<sup>p</sup> norm</a>), and <em>n</em> points in this space, the nearest neighbour of every point can be found in <em>O</em>(<em>n</em>¬†log¬†<em>n</em>) time and the <em>m</em> nearest neighbours of every point can be found in <em>O</em>(<em>mn</em>¬†log¬†<em>n</em>) time.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Ball_tree" title="wikilink">Ball tree</a></li>
<li><a href="Closest_pair_of_points_problem" title="wikilink">Closest pair of points problem</a></li>
<li><a href="Cluster_analysis" title="wikilink">Cluster analysis</a></li>
<li><a href="Content-based_image_retrieval" title="wikilink">Content-based image retrieval</a></li>
<li><a href="Curse_of_dimensionality" title="wikilink">Curse of dimensionality</a></li>
<li><a href="Digital_signal_processing" title="wikilink">Digital signal processing</a></li>
<li><a href="Dimension_reduction" title="wikilink">Dimension reduction</a></li>
<li><a href="Fixed-radius_near_neighbors" title="wikilink">Fixed-radius near neighbors</a></li>
<li><a href="Fourier_analysis" title="wikilink">Fourier analysis</a></li>
<li><a href="Instance-based_learning" title="wikilink">Instance-based learning</a></li>
<li><a href="k-nearest_neighbor_algorithm" title="wikilink"><em>k</em>-nearest neighbor algorithm</a></li>
<li><a href="Linear_least_squares_(mathematics)" title="wikilink">Linear least squares</a></li>
<li><a href="Locality_sensitive_hashing" title="wikilink">Locality sensitive hashing</a></li>
<li><a class="uri" href="MinHash" title="wikilink">MinHash</a></li>
<li><a href="Multidimensional_analysis" title="wikilink">Multidimensional analysis</a></li>
<li><a href="Nearest-neighbor_interpolation" title="wikilink">Nearest-neighbor interpolation</a></li>
<li><a href="Neighbor_joining" title="wikilink">Neighbor joining</a></li>
<li><a href="Principal_component_analysis" title="wikilink">Principal component analysis</a></li>
<li><a href="Range_search" title="wikilink">Range search</a></li>
<li><a href="Set_cover_problem" title="wikilink">Set cover problem</a></li>
<li><a href="Singular_value_decomposition" title="wikilink">Singular value decomposition</a></li>
<li><a href="Sparse_distributed_memory" title="wikilink">Sparse distributed memory</a></li>
<li><a href="Statistical_distance" title="wikilink">Statistical distance</a></li>
<li><a href="Time_series" title="wikilink">Time series</a></li>
<li><a href="Voronoi_diagram" title="wikilink">Voronoi diagram</a></li>
<li><a class="uri" href="Wavelet" title="wikilink">Wavelet</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li>Andrews, L.. A template for the nearest neighbor problem. <em>C/C++ Users Journal</em>, vol. 19, no 11 (November 2001), 40 - 49, 2001, ISSN:1075-2838, <a href="http://www.ddj.com/architect/184401449">www.ddj.com/architect/184401449</a></li>
<li>Arya, S., D. M. Mount, N. S. Netanyahu, R. Silverman, and A. Y. Wu. An Optimal Algorithm for Approximate Nearest Neighbor Searching in Fixed Dimensions. <em>Journal of the ACM</em>, vol. 45, no. 6, pp.¬†891‚Äì923</li>
<li>Beyer, K., Goldstein, J., Ramakrishnan, R., and Shaft, U. 1999. When is nearest neighbor meaningful? In Proceedings of the 7th ICDT, Jerusalem, Israel.</li>
<li>Chung-Min Chen and Yibei Ling - A Sampling-Based Estimator for Top-k Query. ICDE 2002: 617-627</li>
<li>Samet, H. 2006. Foundations of Multidimensional and Metric Data Structures. Morgan Kaufmann. ISBN 0-12-369446-9</li>
<li>Zezula, P., Amato, G., Dohnal, V., and Batko, M. Similarity Search - The Metric Space Approach. Springer, 2006. ISBN 0-387-29146-6</li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://simsearch.yury.name/tutorial.html">Nearest Neighbors and Similarity Search</a> ‚Äì a website dedicated to educational materials, software, literature, researchers, open problems and events related to NN searching. Maintained by Yury Lifshits</li>
<li><a href="http://sswiki.tierra-aoi.net">Similarity Search Wiki</a> ‚Äì a collection of links, people, ideas, keywords, papers, slides, code and data sets on nearest neighbours</li>
<li><a href="http://www.cgal.org/Pkg/SpatialSearchingD">dD Spatial Searching</a> in <a class="uri" href="CGAL" title="wikilink">CGAL</a> ‚Äì the Computational Geometry Algorithms Library</li>
</ul>

<p>"</p>

<p><a href="Category:Approximation_algorithms" title="wikilink">Category:Approximation algorithms</a> <a href="Category:Classification_algorithms" title="wikilink">Category:Classification algorithms</a> <a href="Category:Data_mining" title="wikilink">Category:Data mining</a> <a href="Category:Discrete_geometry" title="wikilink">Category:Discrete geometry</a> <a href="Category:Geometric_algorithms" title="wikilink">Category:Geometric algorithms</a> <a href="Category:Machine_learning" title="wikilink">Category:Machine learning</a> <a href="Category:Numerical_analysis" title="wikilink">Category:Numerical analysis</a> <a href="Category:Mathematical_optimization" title="wikilink">Category:Mathematical optimization</a> <a href="Category:Search_algorithms" title="wikilink">Category:Search algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">‚Ü©</a></li>
<li id="fn2"><a href="#fnref2">‚Ü©</a></li>
<li id="fn3"><a href="#fnref3">‚Ü©</a></li>
<li id="fn4"><a href="#fnref4">‚Ü©</a></li>
<li id="fn5"><a href="#fnref5">‚Ü©</a></li>
<li id="fn6"><a href="#fnref6">‚Ü©</a></li>
<li id="fn7"><a href="#fnref7">‚Ü©</a></li>
<li id="fn8"><a href="#fnref8">‚Ü©</a></li>
<li id="fn9"><a href="#fnref9">‚Ü©</a></li>
<li id="fn10"><a href="#fnref10">‚Ü©</a></li>
<li id="fn11"><a href="#fnref11">‚Ü©</a></li>
<li id="fn12"><a href="#fnref12">‚Ü©</a></li>
<li id="fn13">S. Arya, <a href="David_Mount" title="wikilink">D. M. Mount</a>, <a href="Nathan_Netanyahu" title="wikilink">N. S. Netanyahu</a>, R. Silverman and A. Wu, An optimal algorithm for approximate nearest neighbor searching, Journal of the ACM, 45(6):891-923, 1998. <a href="http://www.cse.ust.hk/faculty/arya/pub/JACM.pdf">1</a><a href="#fnref13">‚Ü©</a></li>
<li id="fn14">.<a href="#fnref14">‚Ü©</a></li>
<li id="fn15"><a href="#fnref15">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
