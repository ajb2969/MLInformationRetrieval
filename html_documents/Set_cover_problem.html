<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="908">Set cover problem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Set cover problem</h1>
<hr/>

<p>The <strong>set cover problem</strong> is a classical question in <a class="uri" href="combinatorics" title="wikilink">combinatorics</a>, <a href="computer_science" title="wikilink">computer science</a> and <a href="Computational_complexity_theory" title="wikilink">complexity theory</a>. It is one of <a href="Karp's_21_NP-complete_problems" title="wikilink">Karp's 21 NP-complete problems</a> shown to be <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> in 1972.</p>

<p>It is a problem "whose study has led to the development of fundamental techniques for the entire field" of <a href="approximation_algorithms" title="wikilink">approximation algorithms</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Given a set of elements 

<math display="inline" id="Set_cover_problem:0">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mi>m</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
    <ci>normal-…</ci>
    <ci>m</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{1,2,...,m\}
  </annotation>
 </semantics>
</math>

 (called the universe) and a set 

<math display="inline" id="Set_cover_problem:1">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Set_cover_problem:2">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 sets whose union equals the universe, the set cover problem is to identify the smallest subset of 

<math display="inline" id="Set_cover_problem:3">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>


 whose union equals the universe. For example, consider the universe 

<math display="inline" id="Set_cover_problem:4">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mn>3</mn>
    <mo>,</mo>
    <mn>4</mn>
    <mo>,</mo>
    <mn>5</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>U</ci>
    <set>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
     <cn type="integer">4</cn>
     <cn type="integer">5</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U=\{1,2,3,4,5\}
  </annotation>
 </semantics>
</math>

 and the set of sets 

<math display="inline" id="Set_cover_problem:5">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mn>3</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mn>4</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>3</mn>
     <mo>,</mo>
     <mn>4</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>4</mn>
     <mo>,</mo>
     <mn>5</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <set>
     <set>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
     </set>
     <set>
      <cn type="integer">2</cn>
      <cn type="integer">4</cn>
     </set>
     <set>
      <cn type="integer">3</cn>
      <cn type="integer">4</cn>
     </set>
     <set>
      <cn type="integer">4</cn>
      <cn type="integer">5</cn>
     </set>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\{\{1,2,3\},\{2,4\},\{3,4\},\{4,5\}\}
  </annotation>
 </semantics>
</math>

. Clearly the union of 

<math display="inline" id="Set_cover_problem:6">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Set_cover_problem:7">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

. However, we can cover all of the elements with the following, smaller number of sets

<math display="block" id="Set_cover_problem:8">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mn>3</mn>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>4</mn>
    <mo>,</mo>
    <mn>5</mn>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <set>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
    </set>
    <set>
     <cn type="integer">4</cn>
     <cn type="integer">5</cn>
    </set>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\{1,2,3\},\{4,5\}\}
  </annotation>
 </semantics>
</math>

.</p>

<p>More formally, given a universe 

<math display="inline" id="Set_cover_problem:9">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒰</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒰</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{U}
  </annotation>
 </semantics>
</math>

 and a family 

<math display="inline" id="Set_cover_problem:10">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

 of subsets of 

<math display="inline" id="Set_cover_problem:11">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒰</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒰</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{U}
  </annotation>
 </semantics>
</math>

, a <em>cover</em> is a subfamily 

<math display="inline" id="Set_cover_problem:12">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   <mo>⊆</mo>
   <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>𝒞</ci>
    <ci>𝒮</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}\subseteq\mathcal{S}
  </annotation>
 </semantics>
</math>

 of sets whose union is 

<math display="inline" id="Set_cover_problem:13">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒰</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒰</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{U}
  </annotation>
 </semantics>
</math>


. In the set covering <a href="decision_problem" title="wikilink">decision problem</a>, the input is a pair 

<math display="inline" id="Set_cover_problem:14">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi class="ltx_font_mathcaligraphic">𝒰</mi>
   <mo>,</mo>
   <mi class="ltx_font_mathcaligraphic">𝒮</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>𝒰</ci>
    <ci>𝒮</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathcal{U},\mathcal{S})
  </annotation>
 </semantics>
</math>

 and an integer 

<math display="inline" id="Set_cover_problem:15">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

; the question is whether there is a set covering of size 

<math display="inline" id="Set_cover_problem:16">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 or less. In the set covering <a href="optimization_problem" title="wikilink">optimization problem</a>, the input is a pair 

<math display="inline" id="Set_cover_problem:17">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi class="ltx_font_mathcaligraphic">𝒰</mi>
   <mo>,</mo>
   <mi class="ltx_font_mathcaligraphic">𝒮</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>𝒰</ci>
    <ci>𝒮</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathcal{U},\mathcal{S})
  </annotation>
 </semantics>
</math>

, and the task is to find a set covering that uses the fewest sets.</p>

<p>The decision version of set covering is <a class="uri" href="NP-complete" title="wikilink">NP-complete</a>, and the optimization version of set cover is <a class="uri" href="NP-hard" title="wikilink">NP-hard</a> .</p>

<p>If each set is assigned a cost, it becomes a <em>weighted</em> set cover problem.</p>
<h2 id="integer-linear-program-formulation">Integer linear program formulation</h2>

<p>The minimum set cover problem can be formulated as the following <a href="integer_linear_program" title="wikilink">integer linear program</a> (ILP).<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>minimize</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Set_cover_problem:18">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>S</mi>
     <mo>∈</mo>
     <mi class="ltx_font_mathcaligraphic">𝒮</mi>
    </mrow>
   </msub>
   <msub>
    <mi>x</mi>
    <mi>S</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <ci>S</ci>
      <ci>𝒮</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{S\in\mathcal{S}}x_{S}
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>(minimize the number of sets)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>subject to</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Set_cover_problem:19">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>S</mi>
      <mo>:</mo>
      <mrow>
       <mi>e</mi>
       <mo>∈</mo>
       <mi>S</mi>
      </mrow>
     </mrow>
    </msub>
    <msub>
     <mi>x</mi>
     <mi>S</mi>
    </msub>
   </mrow>
   <mo>⩾</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <ci>normal-:</ci>
       <ci>S</ci>
       <apply>
        <in></in>
        <ci>e</ci>
        <ci>S</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>S</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{S\colon e\in S}x_{S}\geqslant 1
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>for all 

<math display="inline" id="Set_cover_problem:20">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒰</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>e</ci>
    <ci>𝒰</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e\in\mathcal{U}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>(cover every element of the universe)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Set_cover_problem:21">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>S</mi>
   </msub>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>S</ci>
    </apply>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{S}\in\{0,1\}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>for all 

<math display="inline" id="Set_cover_problem:22">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>S</ci>
    <ci>𝒮</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\in\mathcal{S}
  </annotation>
 </semantics>
</math>

.</p></td>
<td style="text-align: left;">
<p>(every set is either in the set cover or not)</p></td>
</tr>
</tbody>
</table>

<p>This ILP belongs to the more general class of ILPs for <a href="covering_problem" title="wikilink">covering problems</a>. The <a href="Linear_programming_relaxation#Approximation_and_integrality_gap" title="wikilink">integrality gap</a> of this ILP is at most 

<math display="inline" id="Set_cover_problem:23">
 <semantics>
  <mrow>
   <mi>log</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\log n
  </annotation>
 </semantics>
</math>


, so its <a href="Linear_programming_relaxation" title="wikilink">relaxation</a> gives a factor-

<math display="inline" id="Set_cover_problem:24">
 <semantics>
  <mrow>
   <mi>log</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <log></log>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\log n
  </annotation>
 </semantics>
</math>

 <a href="approximation_algorithm" title="wikilink">approximation algorithm</a> for the minimum set cover problem (where 

<math display="inline" id="Set_cover_problem:25">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle n
  </annotation>
 </semantics>
</math>

 is the size of the universe).<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="hitting-set-formulation">Hitting set formulation</h2>

<p>Set covering is equivalent to the <strong>hitting set problem</strong>. It is easy to see this by observing that an instance of set covering can be viewed as an arbitrary <a href="bipartite_graph" title="wikilink">bipartite graph</a>, with sets represented by vertices on the left, the universe represented by vertices on the right, and edges representing the inclusion of elements in sets. The task is then to find a minimum cardinality subset of left-vertices which covers all of the right-vertices. In the Hitting set problem, the objective is to cover the left-vertices using a minimum subset of the right vertices. Converting from one problem to the other is therefore achieved by interchanging the two sets of vertices.</p>
<h2 id="greedy-algorithm">Greedy algorithm</h2>

<p>There is a <a href="greedy_algorithm" title="wikilink">greedy algorithm</a> for polynomial time approximation of set covering that chooses sets according to one rule: at each stage, choose the set that contains the largest number of uncovered elements. It can be shown<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> that this algorithm achieves an approximation ratio of 

<math display="inline" id="Set_cover_problem:26">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(s)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Set_cover_problem:27">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 is the size of the set to be covered, 

<math display="inline" id="Set_cover_problem:28">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(n)
  </annotation>
 </semantics>
</math>


 is the 

<math display="inline" id="Set_cover_problem:29">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-th <a href="harmonic_number" title="wikilink">harmonic number</a>:</p>

<p>

<math display="block" id="Set_cover_problem:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </munderover>
    <mfrac>
     <mn>1</mn>
     <mi>k</mi>
    </mfrac>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mi>ln</mi>
     <mi>n</mi>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>H</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <ln></ln>
       <ci>n</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(n)=\sum_{k=1}^{n}\frac{1}{k}\leq\ln{n}+1
  </annotation>
 </semantics>
</math>

</p>

<p>This greedy algorithm actually achieves an approximation ratio of 

<math display="inline" id="Set_cover_problem:31">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>s</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(s^{\prime})
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Set_cover_problem:32">
 <semantics>
  <msup>
   <mi>s</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>s</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{\prime}
  </annotation>
 </semantics>
</math>

 is the maximum cardinality set of 

<math display="inline" id="Set_cover_problem:33">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>


. For δ-dense instances, there exists, however, a 

<math display="inline" id="Set_cover_problem:34">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mrow>
    <mi>ln</mi>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>c</ci>
    <apply>
     <ln></ln>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\ln{m}
  </annotation>
 </semantics>
</math>

-approximation algorithm for every 

<math display="inline" id="Set_cover_problem:35">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>c</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c>0
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p> There is a standard example on which the greedy algorithm achieves an approximation ratio of 

<math display="inline" id="Set_cover_problem:36">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log_{2}(n)/2
  </annotation>
 </semantics>
</math>

. The universe consists of 

<math display="inline" id="Set_cover_problem:37">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=2^{(k+1)}-2
  </annotation>
 </semantics>
</math>

 elements. The set system consists of 

<math display="inline" id="Set_cover_problem:38">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>


 pairwise disjoint sets 

<math display="inline" id="Set_cover_problem:39">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>S</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{1},\ldots,S_{k}
  </annotation>
 </semantics>
</math>

 with sizes 

<math display="inline" id="Set_cover_problem:40">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mo>,</mo>
   <mn>4</mn>
   <mo>,</mo>
   <mn>8</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msup>
    <mn>2</mn>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <cn type="integer">2</cn>
    <cn type="integer">4</cn>
    <cn type="integer">8</cn>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2,4,8,\ldots,2^{k}
  </annotation>
 </semantics>
</math>

 respectively, as well as two additional disjoint sets 

<math display="inline" id="Set_cover_problem:41">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>T</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">1</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{0},T_{1}
  </annotation>
 </semantics>
</math>

, each of which contains half of the elements from each 

<math display="inline" id="Set_cover_problem:42">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{i}
  </annotation>
 </semantics>
</math>

. On this input, the greedy algorithm takes the sets 

<math display="inline" id="Set_cover_problem:43">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mi>k</mi>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>S</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>k</ci>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <cn type="integer">1</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{k},\ldots,S_{1}
  </annotation>
 </semantics>
</math>


, in that order, while the optimal solution consists only of 

<math display="inline" id="Set_cover_problem:44">
 <semantics>
  <msub>
   <mi>T</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{0}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Set_cover_problem:45">
 <semantics>
  <msub>
   <mi>T</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{1}
  </annotation>
 </semantics>
</math>

. An example of such an input for 

<math display="inline" id="Set_cover_problem:46">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=3
  </annotation>
 </semantics>
</math>

 is pictured on the right.</p>

<p>Inapproximability results show that the greedy algorithm is essentially the best-possible polynomial time approximation algorithm for set cover (see <a href="Set_cover_problem#Inapproximability_results" title="wikilink">Inapproximability results</a> below), under plausible complexity assumptions.</p>
<h2 id="low-frequency-systems">Low-frequency systems</h2>

<p>If each element occurs in at most <em>f</em> sets, then a solution can be found in polynomial time that approximates the optimum to within a factor of <em>f</em> using <a href="Linear_programming_relaxation" title="wikilink">LP relaxation</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="inapproximability-results">Inapproximability results</h2>

<p>When 

<math display="inline" id="Set_cover_problem:47">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 refers to the size of the universe,  showed that set covering cannot be approximated in polynomial time to within a factor of 

<math display="inline" id="Set_cover_problem:48">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>2</mn>
     </msub>
     <mi>n</mi>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mn>0.72</mn>
    <mrow>
     <mi>ln</mi>
     <mi>n</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <cn type="integer">2</cn>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <cn type="float">0.72</cn>
     <apply>
      <ln></ln>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{1}{2}\log_{2}{n}\approx 0.72\ln{n}
  </annotation>
 </semantics>
</math>


, unless <strong>NP</strong> has <a href="quasi-polynomial_time" title="wikilink">quasi-polynomial time</a> algorithms. <a href="Uriel_Feige" title="wikilink">Feige</a> (1998) improved this lower bound to 

<math display="inline" id="Set_cover_problem:49">
 <semantics>
  <mrow>
   <mrow>
    <mo maxsize="120%" minsize="120%">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mrow>
      <mi>o</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo maxsize="120%" minsize="120%">)</mo>
   </mrow>
   <mo>⋅</mo>
   <mrow>
    <mi>ln</mi>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>o</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <ln></ln>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigl(1-o(1)\bigr)\cdot\ln{n}
  </annotation>
 </semantics>
</math>

 under the same assumptions, which essentially matches the approximation ratio achieved by the greedy algorithm.  established a lower bound of 

<math display="inline" id="Set_cover_problem:50">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>⋅</mo>
   <mrow>
    <mi>ln</mi>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <ci>c</ci>
    <apply>
     <ln></ln>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\cdot\ln{n}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Set_cover_problem:51">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 is a certain constant, under the weaker assumption that <strong>P</strong>

<math display="inline" id="Set_cover_problem:52">
 <semantics>
  <mo>≠</mo>
  <annotation-xml encoding="MathML-Content">
   <neq></neq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not=
  </annotation>
 </semantics>
</math>

<strong>NP</strong>. A similar result with a higher value of 

<math display="inline" id="Set_cover_problem:53">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>


 was recently proved by .  showed optimal inapproximability by proving that it cannot be approximated to 

<math display="inline" id="Set_cover_problem:54">
 <semantics>
  <mrow>
   <mrow>
    <mo maxsize="120%" minsize="120%">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mrow>
      <mi>o</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo maxsize="120%" minsize="120%">)</mo>
   </mrow>
   <mo>⋅</mo>
   <mrow>
    <mi>ln</mi>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>o</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <ln></ln>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigl(1-o(1)\bigr)\cdot\ln{n}
  </annotation>
 </semantics>
</math>

 unless <strong>P</strong>

<math display="inline" id="Set_cover_problem:55">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>

<strong>NP</strong>.</p>
<h2 id="related-problems">Related problems</h2>
<ul>
<li>Hitting set is an equivalent reformulation of Set Cover.</li>
<li><a href="Vertex_cover_problem" title="wikilink">Vertex cover</a> is a special case of Hitting Set.</li>
<li><a href="Edge_cover_problem" title="wikilink">Edge cover</a> is a special case of Set Cover.</li>
<li><a href="Set_packing" title="wikilink">Set packing</a> is the dual problem of Set Cover.</li>
<li><a href="Maximum_coverage_problem" title="wikilink">Maximum coverage problem</a> is to choose at most k sets to cover as many elements as possible.</li>
<li><a href="Dominating_set" title="wikilink">Dominating set</a> is the problem of selecting a set of vertices (the dominating set) in a graph such that all other vertices are adjacent to at least one vertex in the dominating set. The Dominating set problem was shown to be NP complete through a reduction from Set cover.</li>
<li><a href="Exact_cover_problem" title="wikilink">Exact cover problem</a> is to choose a set cover with no element included in more than one covering set.</li>
<li><a href="Closest_pair_of_points_problem" title="wikilink">Closest pair of points problem</a></li>
<li><a href="Nearest_neighbor_search" title="wikilink">Nearest neighbor search</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li></li>
<li>

<p>.</p></li>
<li></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li></li>
<li></li>
</ul>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.nlsde.buaa.edu.cn/~kexu/benchmarks/set-benchmarks.htm">Benchmarks with Hidden Optimum Solutions for Set Covering, Set Packing and Winner Determination</a></li>
<li><a href="http://www.csc.kth.se/~viggo/wwwcompendium/node146.html">A compendium of NP optimization problems - Minimum Set Cover</a></li>
</ul>

<p>"</p>

<p><a href="Category:Set_families" title="wikilink">Category:Set families</a> <a href="Category:NP-complete_problems" title="wikilink">Category:NP-complete problems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4">Chvatal, V. <a href="http://www.jstor.org/stable/3689577">A Greedy Heuristic for the Set-Covering Problem</a>. Mathematics of Operations Research Vol. 4, No. 3 (Aug., 1979), pp. 233-235<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
