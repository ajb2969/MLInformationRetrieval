<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="607">Conjugate gradient method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Conjugate gradient method</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p> In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, the <strong>conjugate gradient method</strong> is an <a class="uri" href="algorithm" title="wikilink">algorithm</a> for the <a href="numerical_solution" title="wikilink">numerical solution</a> of particular <a href="system_of_linear_equations" title="wikilink">systems of linear equations</a>, namely those whose matrix is <a href="symmetric_matrix" title="wikilink">symmetric</a> and <a href="positive-definite_matrix" title="wikilink">positive-definite</a>. The conjugate gradient method is often implemented as an <a href="iterative_method" title="wikilink">iterative algorithm</a>, applicable to <a href="sparse_matrix" title="wikilink">sparse</a> systems that are too large to be handled by a direct implementation or other direct methods such as the <a href="Cholesky_decomposition" title="wikilink">Cholesky decomposition</a>. Large sparse systems often arise when numerically solving <a href="partial_differential_equation" title="wikilink">partial differential equations</a> or optimization problems.</p>

<p>The conjugate gradient method can also be used to solve unconstrained <a href="Mathematical_optimization" title="wikilink">optimization</a> problems such as <a href="energy_minimization" title="wikilink">energy minimization</a>. It was mainly developed by <a href="Magnus_Hestenes" title="wikilink">Magnus Hestenes</a> and <a href="Eduard_Stiefel" title="wikilink">Eduard Stiefel</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The <a href="biconjugate_gradient_method" title="wikilink">biconjugate gradient method</a> provides a generalization to non-symmetric matrices. Various <a href="nonlinear_conjugate_gradient_method" title="wikilink">nonlinear conjugate gradient methods</a> seek minima of nonlinear equations.</p>
<h2 id="description-of-the-method">Description of the method</h2>

<p>Suppose we want to solve the following <a href="system_of_linear_equations" title="wikilink">system of linear equations</a></p>
<dl>
<dd><strong>Ax</strong> = <strong>b</strong>
</dd>
</dl>

<p>for the vector <strong>x</strong> where the known <em>n</em>-by-<em>n</em> matrix <strong>A</strong> is <a href="Symmetric_matrix" title="wikilink">symmetric</a> (i.e., <strong>A</strong><sup>T</sup> = <strong>A</strong>), <a href="positive_definite_matrix" title="wikilink">positive definite</a> (i.e. <strong>x</strong><sup>T</sup><strong>Ax</strong> &gt; 0 for all non-zero vectors <strong>x</strong> in <strong>R</strong><sup><em>n</em></sup>), and <a href="real_number" title="wikilink">real</a>, and <strong>b</strong> is known as well.</p>

<p>We denote the unique solution of this system by 

<math display="inline" id="Conjugate_gradient_method:0">
 <semantics>
  <msub>
   <mi>𝐱</mi>
   <mo>*</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐱</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{*}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="the-conjugate-gradient-method-as-a-direct-method">The conjugate gradient method as a direct method</h2>

<p>We say that two non-zero vectors <em>u</em> and <em>v</em> are <a href="Inner_automorphism" title="wikilink">conjugate</a> (with respect to <em>A</em>) if</p>

<p>

<math display="block" id="Conjugate_gradient_method:1">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>𝐮</mi>
     <mi mathvariant="normal">T</mi>
    </msup>
    <mi>𝐀𝐯</mi>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐮</ci>
      <ci>normal-T</ci>
     </apply>
     <ci>𝐀𝐯</ci>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}^{\mathrm{T}}\mathbf{A}\mathbf{v}=0.
  </annotation>
 </semantics>
</math>

</p>

<p>Since <strong>A</strong> is symmetric and positive definite, the left-hand side defines an <a href="inner_product_space" title="wikilink">inner product</a></p>

<p>

<math display="block" id="Conjugate_gradient_method:2">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>𝐮</mi>
      <mo>,</mo>
      <mi>𝐯</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mi>𝐀</mi>
    </msub>
    <mo>:=</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>𝐀𝐮</mi>
     <mo>,</mo>
     <mi>𝐯</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>𝐮</mi>
     <mo>,</mo>
     <mrow>
      <msup>
       <mi>𝐀</mi>
       <mi mathvariant="normal">T</mi>
      </msup>
      <mi>𝐯</mi>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>𝐮</mi>
     <mo>,</mo>
     <mi>𝐀𝐯</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>𝐮</mi>
      <mi mathvariant="normal">T</mi>
     </msup>
     <mi>𝐀𝐯</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <list>
       <ci>𝐮</ci>
       <ci>𝐯</ci>
      </list>
      <ci>𝐀</ci>
     </apply>
     <list>
      <ci>𝐀𝐮</ci>
      <ci>𝐯</ci>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <list>
      <ci>𝐮</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐀</ci>
        <ci>normal-T</ci>
       </apply>
       <ci>𝐯</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <list>
      <ci>𝐮</ci>
      <ci>𝐀𝐯</ci>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐮</ci>
       <ci>normal-T</ci>
      </apply>
      <ci>𝐀𝐯</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\mathbf{u},\mathbf{v}\rangle_{\mathbf{A}}:=\langle\mathbf{A}\mathbf{u},%
\mathbf{v}\rangle=\langle\mathbf{u},\mathbf{A}^{\mathrm{T}}\mathbf{v}\rangle=%
\langle\mathbf{u},\mathbf{A}\mathbf{v}\rangle=\mathbf{u}^{\mathrm{T}}\mathbf{A%
}\mathbf{v}.
  </annotation>
 </semantics>
</math>

</p>

<p>Two vectors are conjugate if and only if they are orthogonal with respect to this inner product. Being conjugate is a symmetric relation: if <strong>u</strong> is conjugate to <strong>v</strong>, then <strong>v</strong> is conjugate to <strong>u</strong>.</p>

<p>Suppose that 

<math display="inline" id="Conjugate_gradient_method:3">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>𝐩</mi>
     <mi>k</mi>
    </msub>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo>∀</mo>
       <mi>i</mi>
      </mrow>
      <mo>≠</mo>
      <mrow>
       <mi>k</mi>
       <mo>,</mo>
       <mi>i</mi>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mrow>
       <mi>k</mi>
       <mo>∈</mo>
       <mrow>
        <mo stretchy="false">[</mo>
        <mn>1</mn>
        <mo>,</mo>
        <mi>n</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <msub>
        <mrow>
         <mo stretchy="false">⟨</mo>
         <msub>
          <mi>𝐩</mi>
          <mi>i</mi>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>𝐩</mi>
          <mi>k</mi>
         </msub>
         <mo stretchy="false">⟩</mo>
        </mrow>
        <mi>A</mi>
       </msub>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐩</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <neq></neq>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <ci>i</ci>
       </apply>
       <list>
        <ci>k</ci>
        <ci>i</ci>
       </list>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <in></in>
        <ci>k</ci>
        <interval closure="closed">
         <cn type="integer">1</cn>
         <ci>n</ci>
        </interval>
       </apply>
       <apply>
        <eq></eq>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <list>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐩</ci>
           <ci>i</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐩</ci>
           <ci>k</ci>
          </apply>
         </list>
         <ci>A</ci>
        </apply>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=\{\mathbf{p}_{k}:\forall i\neq k,i,k\in[1,n],\langle\mathbf{p}_{i},\mathbf{p%
}_{k}\rangle_{A}=0\}
  </annotation>
 </semantics>
</math>

 is a set of <em>n</em> mutually conjugate directions. Then 

<math display="inline" id="Conjugate_gradient_method:4">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is a <a href="basis_(linear_algebra)" title="wikilink">basis</a> of 

<math display="inline" id="Conjugate_gradient_method:5">
 <semantics>
  <msup>
   <mi>ℝ</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ℝ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{R}^{n}
  </annotation>
 </semantics>
</math>

, so within 

<math display="inline" id="Conjugate_gradient_method:6">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 we can expand the solution 

<math display="inline" id="Conjugate_gradient_method:7">
 <semantics>
  <msub>
   <mi>𝐱</mi>
   <mo>*</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐱</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{*}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Conjugate_gradient_method:8">
 <semantics>
  <mrow>
   <mi>𝐀𝐱</mi>
   <mo>=</mo>
   <mi>𝐛</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐀𝐱</ci>
    <ci>𝐛</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Ax}=\mathbf{b}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Conjugate_gradient_method:9">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐱</mi>
    <mo>*</mo>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>α</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>𝐩</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐱</ci>
     <times></times>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <sum></sum>
       <ci>n</ci>
      </apply>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐩</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{*}=\sum^{n}_{i=1}\alpha_{i}\mathbf{p}_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>and we see that</p>

<p>

<math display="block" id="Conjugate_gradient_method:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐛</mi>
    <mo>=</mo>
    <msub>
     <mi>𝐀𝐱</mi>
     <mo>*</mo>
    </msub>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>α</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>𝐀𝐩</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>𝐛</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐀𝐱</ci>
      <times></times>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <sum></sum>
        <ci>n</ci>
       </apply>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐀𝐩</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{b}=\mathbf{A}\mathbf{x}_{*}=\sum^{n}_{i=1}\alpha_{i}\mathbf{A}\mathbf{%
p}_{i}.
  </annotation>
 </semantics>
</math>

</p>

<p>For any 

<math display="inline" id="Conjugate_gradient_method:11">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐩</mi>
    <mi>k</mi>
   </msub>
   <mo>∈</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐩</ci>
     <ci>k</ci>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{p}_{k}\in P
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="Conjugate_gradient_method:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mi>𝐩</mi>
      <mi>k</mi>
      <mi mathvariant="normal">T</mi>
     </msubsup>
     <mi>𝐛</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mi>𝐩</mi>
      <mi>k</mi>
      <mi mathvariant="normal">T</mi>
     </msubsup>
     <msub>
      <mi>𝐀𝐱</mi>
      <mo>*</mo>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>α</mi>
       <mi>i</mi>
      </msub>
      <msubsup>
       <mi>𝐩</mi>
       <mi>k</mi>
       <mi mathvariant="normal">T</mi>
      </msubsup>
      <msub>
       <mi>𝐀𝐩</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>α</mi>
      <mi>k</mi>
     </msub>
     <msubsup>
      <mi>𝐩</mi>
      <mi>k</mi>
      <mi mathvariant="normal">T</mi>
     </msubsup>
     <msub>
      <mi>𝐀𝐩</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐩</ci>
        <ci>k</ci>
       </apply>
       <ci>normal-T</ci>
      </apply>
      <ci>𝐛</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐩</ci>
        <ci>k</ci>
       </apply>
       <ci>normal-T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐀𝐱</ci>
       <times></times>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <sum></sum>
        <ci>n</ci>
       </apply>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐩</ci>
         <ci>k</ci>
        </apply>
        <ci>normal-T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐀𝐩</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐩</ci>
        <ci>k</ci>
       </apply>
       <ci>normal-T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐀𝐩</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{p}_{k}^{\mathrm{T}}\mathbf{b}=\mathbf{p}_{k}^{\mathrm{T}}\mathbf{A}%
\mathbf{x}_{*}=\sum^{n}_{i=1}\alpha_{i}\mathbf{p}_{k}^{\mathrm{T}}\mathbf{A}%
\mathbf{p}_{i}=\alpha_{k}\mathbf{p}_{k}^{\mathrm{T}}\mathbf{A}\mathbf{p}_{k}.
  </annotation>
 </semantics>
</math>

</p>

<p>(because 

<math display="inline" id="Conjugate_gradient_method:13">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>i</mi>
   </mrow>
   <mo>≠</mo>
   <mrow>
    <mi>k</mi>
    <mo>,</mo>
    <msub>
     <mi>p</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>p</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>i</ci>
    </apply>
    <list>
     <ci>k</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>k</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall i\neq k,p_{i},p_{k}
  </annotation>
 </semantics>
</math>

 are mutually conjugate)</p>

<p>

<math display="block" id="Conjugate_gradient_method:14">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>α</mi>
     <mi>k</mi>
    </msub>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <msubsup>
       <mi>𝐩</mi>
       <mi>k</mi>
       <mi mathvariant="normal">T</mi>
      </msubsup>
      <mi>𝐛</mi>
     </mrow>
     <mrow>
      <msubsup>
       <mi>𝐩</mi>
       <mi>k</mi>
       <mi mathvariant="normal">T</mi>
      </msubsup>
      <msub>
       <mi>𝐀𝐩</mi>
       <mi>k</mi>
      </msub>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <msub>
       <mi>𝐩</mi>
       <mi>k</mi>
      </msub>
      <mo>,</mo>
      <mi>𝐛</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <msub>
      <mrow>
       <mo lspace="7.6pt" stretchy="false">⟨</mo>
       <msub>
        <mi>𝐩</mi>
        <mi>k</mi>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>𝐩</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mi>𝐀</mi>
     </msub>
    </mfrac>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <msub>
       <mi>𝐩</mi>
       <mi>k</mi>
      </msub>
      <mo>,</mo>
      <mi>𝐛</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <msubsup>
      <mrow>
       <mo lspace="7.6pt">∥</mo>
       <msub>
        <mi>𝐩</mi>
        <mi>k</mi>
       </msub>
       <mo>∥</mo>
      </mrow>
      <mi>𝐀</mi>
      <mn>2</mn>
     </msubsup>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐩</ci>
         <ci>k</ci>
        </apply>
        <ci>normal-T</ci>
       </apply>
       <ci>𝐛</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐩</ci>
         <ci>k</ci>
        </apply>
        <ci>normal-T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐀𝐩</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐩</ci>
        <ci>k</ci>
       </apply>
       <ci>𝐛</ci>
      </list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐩</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐩</ci>
         <ci>k</ci>
        </apply>
       </list>
       <ci>𝐀</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <list>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐩</ci>
        <ci>k</ci>
       </apply>
       <ci>𝐛</ci>
      </list>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐩</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <ci>𝐀</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{k}=\frac{\mathbf{p}_{k}^{\mathrm{T}}\mathbf{b}}{\mathbf{p}_{k}^{%
\mathrm{T}}\mathbf{A}\mathbf{p}_{k}}=\frac{\langle\mathbf{p}_{k},\mathbf{b}%
\rangle}{\,\,\,\langle\mathbf{p}_{k},\mathbf{p}_{k}\rangle_{\mathbf{A}}}=\frac%
{\langle\mathbf{p}_{k},\mathbf{b}\rangle}{\,\,\,\|\mathbf{p}_{k}\|_{\mathbf{A}%
}^{2}}.
  </annotation>
 </semantics>
</math>

</p>

<p>This result is perhaps most transparent by considering the inner product defined above.</p>

<p>This gives the following method for solving the equation <strong>Ax</strong> = <strong>b</strong>: find a sequence of <em>n</em> conjugate directions, and then compute the coefficients 

<math display="inline" id="Conjugate_gradient_method:15">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\alpha_{k}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="the-conjugate-gradient-method-as-an-iterative-method">The conjugate gradient method as an iterative method</h2>

<p>If we choose the conjugate vectors <strong>p</strong><sub><em>k</em></sub> carefully, then we may not need all of them to obtain a good approximation to the solution 

<math display="inline" id="Conjugate_gradient_method:16">
 <semantics>
  <msub>
   <mi>𝐱</mi>
   <mo>*</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐱</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\mathbf{x}_{*}
  </annotation>
 </semantics>
</math>

. So, we want to regard the conjugate gradient method as an iterative method. This also allows us to approximately solve systems where <em>n</em> is so large that the direct method would take too much time.</p>

<p>We denote the initial guess for 

<math display="inline" id="Conjugate_gradient_method:17">
 <semantics>
  <msub>
   <mi>𝐱</mi>
   <mo>*</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐱</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\mathbf{x}_{*}
  </annotation>
 </semantics>
</math>

 by <strong>x</strong><sub>0</sub>. We can assume without loss of generality that <strong>x</strong><sub>0</sub> = 0 (otherwise, consider the system <strong>Az</strong> = <strong>b</strong> − <strong>Ax</strong><sub>0</sub> instead). Starting with <strong>x</strong><sub>0</sub> we search for the solution and in each iteration we need a metric to tell us whether we are closer to the solution 

<math display="inline" id="Conjugate_gradient_method:18">
 <semantics>
  <msub>
   <mi>𝐱</mi>
   <mo>*</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐱</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\mathbf{x}_{*}
  </annotation>
 </semantics>
</math>

 (that is unknown to us). This metric comes from the fact that the solution 

<math display="inline" id="Conjugate_gradient_method:19">
 <semantics>
  <msub>
   <mi>𝐱</mi>
   <mo>*</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐱</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\mathbf{x}_{*}
  </annotation>
 </semantics>
</math>

 is also the unique minimizer of the following <a href="quadratic_function" title="wikilink">quadratic function</a>; so if f(<strong>x</strong>) becomes smaller in an iteration it means that we are closer to 

<math display="inline" id="Conjugate_gradient_method:20">
 <semantics>
  <msub>
   <mi>𝐱</mi>
   <mo>*</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐱</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\mathbf{x}_{*}
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Conjugate_gradient_method:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>𝐱</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <mn>2</mn>
       </mfrac>
       <msup>
        <mi>𝐱</mi>
        <mi mathvariant="normal">T</mi>
       </msup>
       <mi>𝐀𝐱</mi>
      </mrow>
      <mo>-</mo>
      <mrow>
       <msup>
        <mi>𝐱</mi>
        <mi mathvariant="normal">T</mi>
       </msup>
       <mi>𝐛</mi>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mi>𝐱</mi>
     <mo>∈</mo>
     <msup>
      <mi>𝐑</mi>
      <mi>n</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>𝐱</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐱</ci>
        <ci>normal-T</ci>
       </apply>
       <ci>𝐀𝐱</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐱</ci>
        <ci>normal-T</ci>
       </apply>
       <ci>𝐛</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <ci>𝐱</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐑</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\mathbf{x})=\frac{1}{2}\mathbf{x}^{\mathrm{T}}\mathbf{A}\mathbf{x}-\mathbf{x%
}^{\mathrm{T}}\mathbf{b},\quad\mathbf{x}\in\mathbf{R}^{n}.
  </annotation>
 </semantics>
</math>

</p>

<p>This suggests taking the first basis vector <strong>p</strong><sub>0</sub> to be the negative of the gradient of <em>f</em> at <strong>x</strong> = <strong>x</strong><sub>0</sub>. The gradient of <em>f</em> equals <strong>Ax</strong>−<strong>b</strong>. Starting with a "guessed solution" <strong>x</strong><sub>0</sub> (we can always guess that 

<math display="inline" id="Conjugate_gradient_method:22">
 <semantics>
  <msub>
   <mi>𝐱</mi>
   <mo>*</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐱</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\mathbf{x}_{*}
  </annotation>
 </semantics>
</math>

 is <strong>0</strong> and set <strong>x</strong><sub>0</sub> to <strong>0</strong> if we have no reason to guess for anything else), this means we take <strong>p</strong><sub>0</sub> = <strong>b</strong>−<strong>Ax</strong><sub>0</sub>. The other vectors in the basis will be conjugate to the gradient, hence the name <em>conjugate gradient method</em>.</p>

<p>Let <strong>r</strong><sub><em>k</em></sub> be the <a href="residual_(numerical_analysis)" title="wikilink">residual</a> at the <em>k</em>th step:</p>

<p>

<math display="block" id="Conjugate_gradient_method:23">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐫</mi>
     <mi>k</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>𝐛</mi>
     <mo>-</mo>
     <msub>
      <mi>𝐀𝐱</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐫</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>𝐛</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐀𝐱</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r}_{k}=\mathbf{b}-\mathbf{Ax}_{k}.\,
  </annotation>
 </semantics>
</math>

 Note that <strong>r</strong><sub><em>k</em></sub> is the negative gradient of <em>f</em> at <strong>x</strong> = <strong>x</strong><sub><em>k</em></sub>, so the <a href="gradient_descent" title="wikilink">gradient descent</a> method would be to move in the direction <strong>r</strong><sub><em>k</em></sub>. Here, we insist that the directions <strong>p</strong><sub><em>k</em></sub> be conjugate to each other. We also require that the next search direction be built out of the current residue and all previous search directions, which is reasonable enough in practice.</p>

<p>The conjugation constraint is an orthonormal-type constraint and hence the algorithm bears resemblance to <a href="Gram–Schmidt_process" title="wikilink">Gram-Schmidt orthonormalization</a>.</p>

<p>This gives the following expression:</p>

<p>

<math display="block" id="Conjugate_gradient_method:24">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐩</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐫</mi>
     <mi>k</mi>
    </msub>
    <mo>-</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo><</mo>
       <mi>k</mi>
      </mrow>
     </munder>
     <mrow>
      <mfrac>
       <mrow>
        <msubsup>
         <mi>𝐩</mi>
         <mi>i</mi>
         <mi mathvariant="normal">T</mi>
        </msubsup>
        <msub>
         <mi>𝐀𝐫</mi>
         <mi>k</mi>
        </msub>
       </mrow>
       <mrow>
        <msubsup>
         <mi>𝐩</mi>
         <mi>i</mi>
         <mi mathvariant="normal">T</mi>
        </msubsup>
        <msub>
         <mi>𝐀𝐩</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </mfrac>
      <msub>
       <mi>𝐩</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐩</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐫</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <lt></lt>
        <ci>i</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐩</ci>
           <ci>i</ci>
          </apply>
          <ci>normal-T</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐀𝐫</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐩</ci>
           <ci>i</ci>
          </apply>
          <ci>normal-T</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐀𝐩</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐩</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{p}_{k}=\mathbf{r}_{k}-\sum_{i<k}\frac{\mathbf{p}_{i}^{\mathrm{T}}%
\mathbf{A}\mathbf{r}_{k}}{\mathbf{p}_{i}^{\mathrm{T}}\mathbf{A}\mathbf{p}_{i}}%
\mathbf{p}_{i}
  </annotation>
 </semantics>
</math>

 (see the picture at the top of the article for the effect of the conjugacy constraint on convergence). Following this direction, the next optimal location is given by</p>

<p>

<math display="block" id="Conjugate_gradient_method:25">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐱</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐱</mi>
     <mi>k</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>α</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>𝐩</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐱</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐩</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{k+1}=\mathbf{x}_{k}+\alpha_{k}\mathbf{p}_{k}
  </annotation>
 </semantics>
</math>

 with</p>

<p>

<math display="block" id="Conjugate_gradient_method:26">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>α</mi>
     <mi>k</mi>
    </msub>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <msubsup>
       <mi>𝐩</mi>
       <mi>k</mi>
       <mi mathvariant="normal">T</mi>
      </msubsup>
      <mi>𝐛</mi>
     </mrow>
     <mrow>
      <msubsup>
       <mi>𝐩</mi>
       <mi>k</mi>
       <mi mathvariant="normal">T</mi>
      </msubsup>
      <msub>
       <mi>𝐀𝐩</mi>
       <mi>k</mi>
      </msub>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <msubsup>
       <mi>𝐩</mi>
       <mi>k</mi>
       <mi mathvariant="normal">T</mi>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>𝐫</mi>
         <mrow>
          <mi>k</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mo>+</mo>
        <msub>
         <mi>𝐀𝐱</mi>
         <mrow>
          <mi>k</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <msubsup>
       <mi>𝐩</mi>
       <mi>k</mi>
       <mi mathvariant="normal">T</mi>
      </msubsup>
      <msub>
       <mi>𝐀𝐩</mi>
       <mi>k</mi>
      </msub>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <msubsup>
       <mi>𝐩</mi>
       <mi>k</mi>
       <mi mathvariant="normal">T</mi>
      </msubsup>
      <msub>
       <mi>𝐫</mi>
       <mrow>
        <mi>k</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
     <mrow>
      <msubsup>
       <mi>𝐩</mi>
       <mi>k</mi>
       <mi mathvariant="normal">T</mi>
      </msubsup>
      <msub>
       <mi>𝐀𝐩</mi>
       <mi>k</mi>
      </msub>
     </mrow>
    </mfrac>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐩</ci>
         <ci>k</ci>
        </apply>
        <ci>normal-T</ci>
       </apply>
       <ci>𝐛</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐩</ci>
         <ci>k</ci>
        </apply>
        <ci>normal-T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐀𝐩</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐩</ci>
         <ci>k</ci>
        </apply>
        <ci>normal-T</ci>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐫</ci>
         <apply>
          <minus></minus>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐀𝐱</ci>
         <apply>
          <minus></minus>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐩</ci>
         <ci>k</ci>
        </apply>
        <ci>normal-T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐀𝐩</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐩</ci>
         <ci>k</ci>
        </apply>
        <ci>normal-T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐫</ci>
        <apply>
         <minus></minus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐩</ci>
         <ci>k</ci>
        </apply>
        <ci>normal-T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐀𝐩</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{k}=\frac{\mathbf{p}_{k}^{\mathrm{T}}\mathbf{b}}{\mathbf{p}_{k}^{%
\mathrm{T}}\mathbf{A}\mathbf{p}_{k}}=\frac{\mathbf{p}_{k}^{\mathrm{T}}(\mathbf%
{r}_{k-1}+\mathbf{Ax}_{k-1})}{\mathbf{p}_{k}^{\mathrm{T}}\mathbf{A}\mathbf{p}_%
{k}}=\frac{\mathbf{p}_{k}^{\mathrm{T}}\mathbf{r}_{k-1}}{\mathbf{p}_{k}^{%
\mathrm{T}}\mathbf{A}\mathbf{p}_{k}},
  </annotation>
 </semantics>
</math>

 where the last equality holds because <strong>p</strong><sub><em>k</em></sub> and <strong>x</strong><sub><em>k-1</em></sub> are conjugate.</p>
<h3 id="the-resulting-algorithm">The resulting algorithm</h3>

<p>The above algorithm gives the most straightforward explanation of the conjugate gradient method. Seemingly, the algorithm as stated requires storage of all previous searching directions and residue vectors, as well as many matrix-vector multiplications, and thus can be computationally expensive. However, a closer analysis of the algorithm shows that <strong>r</strong><sub><em>k+1</em></sub> is conjugate to <strong>p</strong><sub><em>i</em></sub> for all <em>i </em>k'', <strong>p</strong><sub><em>k</em></sub>, and <strong>x</strong><sub><em>k</em></sub> are needed to construct <strong>r</strong><sub><em>k+1</em></sub>, <strong>p</strong><sub><em>k+1</em></sub>, and <strong>x</strong><sub><em>k+1</em></sub>. Furthermore, only one matrix-vector multiplication is needed in each iteration.</p>

<p>The algorithm is detailed below for solving <strong>Ax</strong> = <strong>b</strong> where <strong>A</strong> is a real, symmetric, positive-definite matrix. The input vector <strong>x</strong><sub>0</sub> can be an approximate initial solution or <strong>0</strong>. It is a different formulation of the exact procedure described above.</p>

<p>

<math display="inline" id="Conjugate_gradient_method:27">
 <semantics>
  <mtable>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <msub>
       <mi>𝐫</mi>
       <mn>0</mn>
      </msub>
      <mo>:=</mo>
      <mrow>
       <mi>𝐛</mi>
       <mo>-</mo>
       <msub>
        <mi>𝐀𝐱</mi>
        <mn>0</mn>
       </msub>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <msub>
       <mi>𝐩</mi>
       <mn>0</mn>
      </msub>
      <mo>:=</mo>
      <msub>
       <mi>𝐫</mi>
       <mn>0</mn>
      </msub>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>k</mi>
      <mo>:=</mo>
      <mn>0</mn>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mtext>repeat</mtext>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <msub>
       <mpadded lspace="20pt" width="+20pt">
        <mi>α</mi>
       </mpadded>
       <mi>k</mi>
      </msub>
      <mo>:=</mo>
      <mstyle displaystyle="true">
       <mfrac>
        <mrow>
         <msubsup>
          <mi>𝐫</mi>
          <mi>k</mi>
          <mi mathvariant="normal">T</mi>
         </msubsup>
         <msub>
          <mi>𝐫</mi>
          <mi>k</mi>
         </msub>
        </mrow>
        <mrow>
         <msubsup>
          <mi>𝐩</mi>
          <mi>k</mi>
          <mi mathvariant="normal">T</mi>
         </msubsup>
         <msub>
          <mi>𝐀𝐩</mi>
          <mi>k</mi>
         </msub>
        </mrow>
       </mfrac>
      </mstyle>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <msub>
       <mpadded lspace="20pt" width="+20pt">
        <mi>𝐱</mi>
       </mpadded>
       <mrow>
        <mi>k</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo>:=</mo>
      <mrow>
       <msub>
        <mi>𝐱</mi>
        <mi>k</mi>
       </msub>
       <mo>+</mo>
       <mrow>
        <msub>
         <mi>α</mi>
         <mi>k</mi>
        </msub>
        <msub>
         <mi>𝐩</mi>
         <mi>k</mi>
        </msub>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <msub>
       <mpadded lspace="20pt" width="+20pt">
        <mi>𝐫</mi>
       </mpadded>
       <mrow>
        <mi>k</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo>:=</mo>
      <mrow>
       <msub>
        <mi>𝐫</mi>
        <mi>k</mi>
       </msub>
       <mo>-</mo>
       <mrow>
        <msub>
         <mi>α</mi>
         <mi>k</mi>
        </msub>
        <msub>
         <mi>𝐀𝐩</mi>
         <mi>k</mi>
        </msub>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mpadded lspace="20pt" width="+20pt">
       <mtext>if</mtext>
      </mpadded>
      <msub>
       <mi>r</mi>
       <mrow>
        <mi>k</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mtext>is sufficiently small then exit loop</mtext>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <msub>
       <mpadded lspace="20pt" width="+20pt">
        <mi>β</mi>
       </mpadded>
       <mi>k</mi>
      </msub>
      <mo>:=</mo>
      <mstyle displaystyle="true">
       <mfrac>
        <mrow>
         <msubsup>
          <mi>𝐫</mi>
          <mrow>
           <mi>k</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
          <mi mathvariant="normal">T</mi>
         </msubsup>
         <msub>
          <mi>𝐫</mi>
          <mrow>
           <mi>k</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </mrow>
        <mrow>
         <msubsup>
          <mi>𝐫</mi>
          <mi>k</mi>
          <mi mathvariant="normal">T</mi>
         </msubsup>
         <msub>
          <mi>𝐫</mi>
          <mi>k</mi>
         </msub>
        </mrow>
       </mfrac>
      </mstyle>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <msub>
       <mpadded lspace="20pt" width="+20pt">
        <mi>𝐩</mi>
       </mpadded>
       <mrow>
        <mi>k</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo>:=</mo>
      <mrow>
       <msub>
        <mi>𝐫</mi>
        <mrow>
         <mi>k</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mo>+</mo>
       <mrow>
        <msub>
         <mi>β</mi>
         <mi>k</mi>
        </msub>
        <msub>
         <mi>𝐩</mi>
         <mi>k</mi>
        </msub>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mpadded lspace="20pt" width="+20pt">
       <mi>k</mi>
      </mpadded>
      <mo>:=</mo>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mtext>end repeat</mtext>
    </mtd>
   </mtr>
   <mtr>
    <mtd></mtd>
    <mtd columnalign="left">
     <mrow>
      <mtext>The result is</mtext>
      <msub>
       <mi>𝐱</mi>
       <mrow>
        <mi>k</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <csymbol cd="latexml">assign</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐫</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <minus></minus>
       <ci>𝐛</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐀𝐱</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <csymbol cd="latexml">assign</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐩</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐫</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <csymbol cd="latexml">assign</csymbol>
      <ci>k</ci>
      <cn type="integer">0</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <mtext>repeat</mtext>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <csymbol cd="latexml">assign</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐫</ci>
          <ci>k</ci>
         </apply>
         <ci>normal-T</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐫</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐩</ci>
          <ci>k</ci>
         </apply>
         <ci>normal-T</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐀𝐩</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <csymbol cd="latexml">assign</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐱</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>α</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐩</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <csymbol cd="latexml">assign</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐫</ci>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐫</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>α</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐀𝐩</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <times></times>
      <mtext>if</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <mtext>is sufficiently small then exit loop</mtext>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <csymbol cd="latexml">assign</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐫</ci>
          <apply>
           <plus></plus>
           <ci>k</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>normal-T</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐫</ci>
         <apply>
          <plus></plus>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐫</ci>
          <ci>k</ci>
         </apply>
         <ci>normal-T</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐫</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <csymbol cd="latexml">assign</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐩</ci>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐫</ci>
        <apply>
         <plus></plus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>β</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐩</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <csymbol cd="latexml">assign</csymbol>
      <ci>k</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <mtext>end repeat</mtext>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
     <apply>
      <times></times>
      <mtext>The result is</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{aligned}&\displaystyle\mathbf{r}_{0}:=\mathbf{b}-\mathbf{Ax}_{0}\\
&\displaystyle\mathbf{p}_{0}:=\mathbf{r}_{0}\\
&\displaystyle k:=0\\
&\displaystyle\hbox{repeat}\\
&\displaystyle\qquad\alpha_{k}:=\frac{\mathbf{r}_{k}^{\mathrm{T}}\mathbf{r}_{k%
}}{\mathbf{p}_{k}^{\mathrm{T}}\mathbf{Ap}_{k}}\\
&\displaystyle\qquad\mathbf{x}_{k+1}:=\mathbf{x}_{k}+\alpha_{k}\mathbf{p}_{k}%
\\
&\displaystyle\qquad\mathbf{r}_{k+1}:=\mathbf{r}_{k}-\alpha_{k}\mathbf{Ap}_{k}%
\\
&\displaystyle\qquad\hbox{if }r_{k+1}\hbox{ is sufficiently small then exit %
loop}\\
&\displaystyle\qquad\beta_{k}:=\frac{\mathbf{r}_{k+1}^{\mathrm{T}}\mathbf{r}_{%
k+1}}{\mathbf{r}_{k}^{\mathrm{T}}\mathbf{r}_{k}}\\
&\displaystyle\qquad\mathbf{p}_{k+1}:=\mathbf{r}_{k+1}+\beta_{k}\mathbf{p}_{k}%
\\
&\displaystyle\qquad k:=k+1\\
&\displaystyle\hbox{end repeat}\\
&\displaystyle\hbox{The result is }\mathbf{x}_{k+1}\end{aligned}
  </annotation>
 </semantics>
</math>

</p>

<p>This is the most commonly used algorithm. The same formula for 

<math display="inline" id="Conjugate_gradient_method:28">
 <semantics>
  <msub>
   <mi>β</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{k}
  </annotation>
 </semantics>
</math>

 is also used in the Fletcher–Reeves <a href="nonlinear_conjugate_gradient_method" title="wikilink">nonlinear conjugate gradient method</a>.</p>
<h4 id="computation-of-alpha-and-beta">Computation of alpha and beta</h4>

<p>In the algorithm, 

<math display="inline" id="Conjugate_gradient_method:29">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{k}
  </annotation>
 </semantics>
</math>

 is chosen such that 

<math display="inline" id="Conjugate_gradient_method:30">
 <semantics>
  <msub>
   <mi>𝐫</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐫</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r}_{k+1}
  </annotation>
 </semantics>
</math>

 is orthogonal to 

<math display="inline" id="Conjugate_gradient_method:31">
 <semantics>
  <msub>
   <mi>𝐫</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐫</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r}_{k}
  </annotation>
 </semantics>
</math>

. The denominator is simplified from</p>

<p>

<math display="inline" id="Conjugate_gradient_method:32">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msubsup>
      <mi>𝐫</mi>
      <mi>k</mi>
      <mi mathvariant="normal">T</mi>
     </msubsup>
     <msub>
      <mi>𝐫</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mrow>
     <msubsup>
      <mi>𝐫</mi>
      <mi>k</mi>
      <mi mathvariant="normal">T</mi>
     </msubsup>
     <msub>
      <mi>𝐀𝐩</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msubsup>
      <mi>𝐫</mi>
      <mi>k</mi>
      <mi mathvariant="normal">T</mi>
     </msubsup>
     <msub>
      <mi>𝐫</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mrow>
     <msubsup>
      <mi>𝐩</mi>
      <mi>k</mi>
      <mi mathvariant="normal">T</mi>
     </msubsup>
     <msub>
      <mi>𝐀𝐩</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐫</ci>
         <ci>k</ci>
        </apply>
        <ci>normal-T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐫</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐫</ci>
         <ci>k</ci>
        </apply>
        <ci>normal-T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐀𝐩</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐫</ci>
         <ci>k</ci>
        </apply>
        <ci>normal-T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐫</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐩</ci>
         <ci>k</ci>
        </apply>
        <ci>normal-T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐀𝐩</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{k}=\frac{\mathbf{r}_{k}^{\mathrm{T}}\mathbf{r}_{k}}{\mathbf{r}_{k}^{%
\mathrm{T}}\mathbf{Ap}_{k}}=\frac{\mathbf{r}_{k}^{\mathrm{T}}\mathbf{r}_{k}}{%
\mathbf{p}_{k}^{\mathrm{T}}\mathbf{Ap}_{k}}
  </annotation>
 </semantics>
</math>

</p>

<p>since 

<math display="inline" id="Conjugate_gradient_method:33">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐫</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐩</mi>
     <mi>k</mi>
    </msub>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>β</mi>
      <mrow>
       <mi>k</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msub>
      <mi>𝐩</mi>
      <mrow>
       <mi>k</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐫</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐩</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐩</ci>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r}_{k}=\mathbf{p}_{k}-\mathbf{\beta}_{k-1}\mathbf{p}_{k-1}
  </annotation>
 </semantics>
</math>

. The 

<math display="inline" id="Conjugate_gradient_method:34">
 <semantics>
  <msub>
   <mi>β</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{k}
  </annotation>
 </semantics>
</math>

 is chosen such that 

<math display="inline" id="Conjugate_gradient_method:35">
 <semantics>
  <msub>
   <mi>𝐩</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐩</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{p}_{k+1}
  </annotation>
 </semantics>
</math>

 is conjugated to 

<math display="inline" id="Conjugate_gradient_method:36">
 <semantics>
  <msub>
   <mi>𝐩</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐩</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{p}_{k}
  </annotation>
 </semantics>
</math>

. Initially, 

<math display="inline" id="Conjugate_gradient_method:37">
 <semantics>
  <msub>
   <mi>β</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{k}
  </annotation>
 </semantics>
</math>

 is</p>

<p>

<math display="inline" id="Conjugate_gradient_method:38">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <msubsup>
       <mi>𝐫</mi>
       <mrow>
        <mi>k</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mi mathvariant="normal">T</mi>
      </msubsup>
      <mi>A</mi>
      <msub>
       <mi>𝐩</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mrow>
      <msubsup>
       <mi>𝐩</mi>
       <mi>k</mi>
       <mi mathvariant="normal">T</mi>
      </msubsup>
      <mi>A</mi>
      <msub>
       <mi>𝐩</mi>
       <mi>k</mi>
      </msub>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐫</ci>
         <apply>
          <plus></plus>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>normal-T</ci>
       </apply>
       <ci>A</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐩</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐩</ci>
         <ci>k</ci>
        </apply>
        <ci>normal-T</ci>
       </apply>
       <ci>A</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐩</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{k}=-\frac{\mathbf{r}_{k+1}^{\mathrm{T}}A\mathbf{p}_{k}}{\mathbf{p}_{k}^%
{\mathrm{T}}A\mathbf{p}_{k}}
  </annotation>
 </semantics>
</math>

</p>

<p>using 

<math display="inline" id="Conjugate_gradient_method:39">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐫</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐫</mi>
     <mrow>
      <mi>k</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>α</mi>
      <mrow>
       <mi>k</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mi>A</mi>
     <msub>
      <mi>𝐩</mi>
      <mrow>
       <mi>k</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐫</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐫</ci>
      <apply>
       <minus></minus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐩</ci>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r}_{k}=\mathbf{r}_{k-1}-\alpha_{k-1}A\mathbf{p}_{k-1}
  </annotation>
 </semantics>
</math>

 and equivalently 

<math display="inline" id="Conjugate_gradient_method:40">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <msub>
     <mi>𝐩</mi>
     <mrow>
      <mi>k</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msub>
      <mi>α</mi>
      <mrow>
       <mi>k</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mfrac>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>𝐫</mi>
       <mrow>
        <mi>k</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>𝐫</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐩</ci>
      <apply>
       <minus></minus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐫</ci>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐫</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\mathbf{p}_{k-1}=\frac{1}{\alpha_{k-1}}(\mathbf{r}_{k-1}-\mathbf{r}_{k})
  </annotation>
 </semantics>
</math>

, the numerator of 

<math display="inline" id="Conjugate_gradient_method:41">
 <semantics>
  <msub>
   <mi>β</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{k}
  </annotation>
 </semantics>
</math>

 is rewritten as</p>

<p>

<math display="inline" id="Conjugate_gradient_method:42">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>𝐫</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mi mathvariant="normal">T</mi>
    </msubsup>
    <mi>A</mi>
    <msub>
     <mi>𝐩</mi>
     <mi>k</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msub>
      <mi>α</mi>
      <mi>k</mi>
     </msub>
    </mfrac>
    <msubsup>
     <mi>𝐫</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mi mathvariant="normal">T</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>𝐫</mi>
       <mi>k</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>𝐫</mi>
       <mrow>
        <mi>k</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <msub>
       <mi>α</mi>
       <mi>k</mi>
      </msub>
     </mfrac>
     <msubsup>
      <mi>𝐫</mi>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mi mathvariant="normal">T</mi>
     </msubsup>
     <msub>
      <mi>𝐫</mi>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐫</ci>
        <apply>
         <plus></plus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-T</ci>
      </apply>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐩</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐫</ci>
        <apply>
         <plus></plus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-T</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐫</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐫</ci>
        <apply>
         <plus></plus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>α</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐫</ci>
         <apply>
          <plus></plus>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>normal-T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐫</ci>
        <apply>
         <plus></plus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r}_{k+1}^{\mathrm{T}}A\mathbf{p}_{k}=\frac{1}{\alpha_{k}}\mathbf{r}_{k%
+1}^{\mathrm{T}}(\mathbf{r}_{k}-\mathbf{r}_{k+1})=-\frac{1}{\alpha_{k}}\mathbf%
{r}_{k+1}^{\mathrm{T}}\mathbf{r}_{k+1}
  </annotation>
 </semantics>
</math>

</p>

<p>because 

<math display="inline" id="Conjugate_gradient_method:43">
 <semantics>
  <msub>
   <mi>𝐫</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐫</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r}_{k+1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Conjugate_gradient_method:44">
 <semantics>
  <msub>
   <mi>𝐫</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐫</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r}_{k}
  </annotation>
 </semantics>
</math>

 are orthogonal by design. The denominator is rewritten as</p>

<p>

<math display="inline" id="Conjugate_gradient_method:45">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>𝐩</mi>
     <mi>k</mi>
     <mi mathvariant="normal">T</mi>
    </msubsup>
    <mi>A</mi>
    <msub>
     <mi>𝐩</mi>
     <mi>k</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>𝐫</mi>
        <mi>k</mi>
       </msub>
       <mo>+</mo>
       <mrow>
        <msub>
         <mi>β</mi>
         <mrow>
          <mi>k</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <msub>
         <mi>𝐩</mi>
         <mrow>
          <mi>k</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">T</mi>
    </msup>
    <mi>A</mi>
    <msub>
     <mi>𝐩</mi>
     <mi>k</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msub>
      <mi>α</mi>
      <mi>k</mi>
     </msub>
    </mfrac>
    <msubsup>
     <mi>𝐫</mi>
     <mi>k</mi>
     <mi mathvariant="normal">T</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>𝐫</mi>
       <mi>k</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>𝐫</mi>
       <mrow>
        <mi>k</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msub>
      <mi>α</mi>
      <mi>k</mi>
     </msub>
    </mfrac>
    <msubsup>
     <mi>𝐫</mi>
     <mi>k</mi>
     <mi mathvariant="normal">T</mi>
    </msubsup>
    <msub>
     <mi>𝐫</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐩</ci>
        <ci>k</ci>
       </apply>
       <ci>normal-T</ci>
      </apply>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐩</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐫</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>β</ci>
          <apply>
           <minus></minus>
           <ci>k</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐩</ci>
          <apply>
           <minus></minus>
           <ci>k</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
       <ci>normal-T</ci>
      </apply>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐩</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐫</ci>
        <ci>k</ci>
       </apply>
       <ci>normal-T</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐫</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐫</ci>
        <apply>
         <plus></plus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐫</ci>
        <ci>k</ci>
       </apply>
       <ci>normal-T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐫</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{p}_{k}^{\mathrm{T}}A\mathbf{p}_{k}=(\mathbf{r}_{k}+\beta_{k-1}\mathbf{%
p}_{k-1})^{\mathrm{T}}A\mathbf{p}_{k}=\frac{1}{\alpha_{k}}\mathbf{r}_{k}^{%
\mathrm{T}}(\mathbf{r}_{k}-\mathbf{r}_{k+1})=\frac{1}{\alpha_{k}}\mathbf{r}_{k%
}^{\mathrm{T}}\mathbf{r}_{k}
  </annotation>
 </semantics>
</math>

</p>

<p>using that the search directions 

<math display="inline" id="Conjugate_gradient_method:46">
 <semantics>
  <msub>
   <mi>𝐩</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐩</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{p}_{k}
  </annotation>
 </semantics>
</math>

 are conjugated and again that the residuals are orthogonal. This gives the 

<math display="inline" id="Conjugate_gradient_method:47">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

 in the algorithm after cancelling 

<math display="inline" id="Conjugate_gradient_method:48">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{k}
  </annotation>
 </semantics>
</math>

.</p>
<h4 id="example-code-in-matlab">Example code in <a class="uri" href="MATLAB" title="wikilink">MATLAB</a></h4>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab">function [x] = conjgrad(A,b,x)
    r=b-A*x;
    p=r;
    rsold=r*r';

    for i=<span class="fl">1</span>:<span class="fl">1e6</span>
        Ap=A*p;
        alpha=rsold/(p*Ap');
        x=x+alpha*p;
        r=r-alpha*Ap;
        rsnew=r*r';
        if sqrt(rsnew)&lt;<span class="fl">1e-10</span>
              break;
        end
        p=r+rsnew/rsold*p;
        rsold=rsnew;
    end
end</code></pre></div>
<h3 id="numerical-example">Numerical example</h3>

<p>To illustrate the conjugate gradient method, we will complete a simple example.</p>

<p>Considering the linear system <strong>Ax</strong> = <strong>b</strong> given by</p>
<dl>
<dd><dl>
<dd><math>\mathbf{A} \mathbf{x}= \begin{bmatrix}
</math></dd>
</dl>
</dd>
</dl>

<p>4 &amp; 1 \\ 1 &amp; 3 \end{bmatrix}\begin{bmatrix} x_1 \\ x_2 \end{bmatrix} = \begin{bmatrix} 1 \\ 2 \end{bmatrix} ,</p>

<p>we will perform two steps of the conjugate gradient method beginning with the initial guess</p>
<dl>
<dd><dl>
<dd><math>\mathbf{x}_0 =
</math></dd>
</dl>
</dd>
</dl>

<p>\begin{bmatrix} 2 \\ 1 \end{bmatrix} </p>

<p>in order to find an approximate solution to the system.</p>
<h4 id="solution">Solution</h4>

<p>For reference, the exact solution is</p>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\mathbf{x} = \begin{bmatrix} \frac{1}{11} \\\\ \frac{7}{11} \end{bmatrix}  Our first step is to calculate the residual vector <strong>r</strong><sub>0</sub> associated with <strong>x</strong><sub>0</sub>. This residual is computed from the formula <strong>r</strong><sub>0</sub> = <strong>b</strong> - <strong>Ax</strong><sub>0</sub>, and in our case is equal to</p>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\mathbf{r}_0 = \begin{bmatrix} 1 \\ 2 \end{bmatrix} - \begin{bmatrix} 4 &amp; 1 \\ 1 &amp; 3 \end{bmatrix} \begin{bmatrix} 2 \\ 1 \end{bmatrix} = \begin{bmatrix}-8 \\ -3 \end{bmatrix}.</p>

<p></p>

<p>Since this is the first iteration, we will use the residual vector <strong>r</strong><sub>0</sub> as our initial search direction <strong>p</strong><sub>0</sub>; the method of selecting <strong>p</strong><sub>k</sub> will change in further iterations.</p>

<p>We now compute the scalar α<sub>0</sub> using the relationship</p>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\alpha_0 = \frac{\mathbf{r}_0^\mathrm{T} \mathbf{r}_0}{\mathbf{p}_0^\mathrm{T} \mathbf{A p}_0} = \frac{\begin{bmatrix} -8 &amp; -3 \end{bmatrix} \begin{bmatrix} -8 \\ -3 \end{bmatrix}}{ \begin{bmatrix} -8 &amp; -3 \end{bmatrix} \begin{bmatrix} 4 &amp; 1 \\ 1 &amp; 3 \end{bmatrix} \begin{bmatrix} -8 \\ -3 \end{bmatrix} } = \frac{73}{331}. </p>

<p>We can now compute <strong>x</strong><sub>1</sub> using the formula</p>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\mathbf{x}_1 = \mathbf{x}_0 + \alpha_0\mathbf{p}_0 = \begin{bmatrix} 2 \\ 1 \end{bmatrix} + \frac{73}{331} \begin{bmatrix} -8 \\ -3 \end{bmatrix} = \begin{bmatrix} 0.2356 \\ 0.3384 \end{bmatrix}. </p>

<p>This result completes the first iteration, the result being an "improved" approximate solution to the system, <strong>x</strong><sub>1</sub>. We may now move on and compute the next residual vector <strong>r</strong><sub>1</sub> using the formula</p>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\mathbf{r}_1 = \mathbf{r}_0 - \alpha_0 \mathbf{A} \mathbf{p}_0 = \begin{bmatrix} -8 \\ -3 \end{bmatrix} - \frac{73}{331} \begin{bmatrix} 4 &amp; 1 \\ 1 &amp; 3 \end{bmatrix} \begin{bmatrix} -8 \\ -3 \end{bmatrix} = \begin{bmatrix} -0.2810 \\ 0.7492 \end{bmatrix}. </p>

<p>Our next step in the process is to compute the scalar β<sub>0</sub> that will eventually be used to determine the next search direction <strong>p</strong><sub>1</sub>.</p>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\beta_0 = \frac{\mathbf{r}_1^\mathrm{T} \mathbf{r}_1}{\mathbf{r}_0^\mathrm{T} \mathbf{r}_0} = \frac{\begin{bmatrix} -0.2810 &amp; 0.7492 \end{bmatrix} \begin{bmatrix} -0.2810 \\ 0.7492 \end{bmatrix}}{\begin{bmatrix} -8 &amp; -3 \end{bmatrix} \begin{bmatrix} -8 \\ -3 \end{bmatrix}} = 0.0088. </p>

<p>Now, using this scalar β<sub>0</sub>, we can compute the next search direction <strong>p</strong><sub>1</sub> using the relationship</p>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\mathbf{p}_1 = \mathbf{r}_1 + \beta_0 \mathbf{p}_0 = \begin{bmatrix} -0.2810 \\ 0.7492 \end{bmatrix} + 0.0088 \begin{bmatrix} -8 \\ -3 \end{bmatrix} = \begin{bmatrix} -0.3511 \\ 0.7229 \end{bmatrix}. </p>

<p>We now compute the scalar α<sub>1</sub> using our newly acquired <strong>p</strong><sub>1</sub> using the same method as that used for α<sub>0</sub>.</p>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\alpha_1 = \frac{\mathbf{r}_1^\mathrm{T} \mathbf{r}_1}{\mathbf{p}_1^\mathrm{T} \mathbf{A p}_1} = \frac{\begin{bmatrix} -0.2810 &amp; 0.7492 \end{bmatrix} \begin{bmatrix} -0.2810 \\ 0.7492 \end{bmatrix}}{ \begin{bmatrix} -0.3511 &amp; 0.7229 \end{bmatrix} \begin{bmatrix} 4 &amp; 1 \\ 1 &amp; 3 \end{bmatrix} \begin{bmatrix} -0.3511 \\ 0.7229 \end{bmatrix} } = 0.4122. </p>

<p>Finally, we find <strong>x</strong><sub>2</sub> using the same method as that used to find <strong>x</strong><sub>1</sub>.</p>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\mathbf{x}_2 = \mathbf{x}_1 + \alpha_1 \mathbf{p}_1 = \begin{bmatrix} 0.2356 \\ 0.3384 \end{bmatrix} + 0.4122 \begin{bmatrix} -0.3511 \\ 0.7229 \end{bmatrix} = \begin{bmatrix} 0.0909 \\ 0.6364 \end{bmatrix}. </p>

<p>The result, <strong>x</strong><sub>2</sub>, is a "better" approximation to the system's solution than <strong>x</strong><sub>1</sub> and <strong>x</strong><sub>0</sub>. If exact arithmetic were to be used in this example instead of limited-precision, then the exact solution would theoretically have been reached after <em>n</em> = 2 iterations (<em>n</em> being the order of the system).</p>
<h2 id="convergence-properties-of-the-conjugate-gradient-method">Convergence properties of the conjugate gradient method</h2>

<p>The conjugate gradient method can theoretically be viewed as a direct method, as it produces the exact solution after a finite number of iterations, which is not larger than the size of the matrix, in the absence of <a href="round-off_error" title="wikilink">round-off error</a>. However, the conjugate gradient method is unstable with respect to even small perturbations, e.g., most directions are not in practice conjugate, and the exact solution is never obtained. Fortunately, the conjugate gradient method can be used as an <a href="iterative_method" title="wikilink">iterative method</a> as it provides monotonically improving approximations 

<math display="inline" id="Conjugate_gradient_method:49">
 <semantics>
  <msub>
   <mi>𝐱</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐱</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{k}
  </annotation>
 </semantics>
</math>

 to the exact solution, which may reach the required tolerance after a relatively small (compared to the problem size) number of iterations. The improvement is typically linear and its speed is determined by the <a href="condition_number" title="wikilink">condition number</a> 

<math display="inline" id="Conjugate_gradient_method:50">
 <semantics>
  <mrow>
   <mi>κ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>κ</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa(A)
  </annotation>
 </semantics>
</math>

 of the system matrix 

<math display="inline" id="Conjugate_gradient_method:51">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

: the larger 

<math display="inline" id="Conjugate_gradient_method:52">
 <semantics>
  <mrow>
   <mi>κ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>κ</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa(A)
  </annotation>
 </semantics>
</math>

 is, the slower the improvement.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>If 

<math display="inline" id="Conjugate_gradient_method:53">
 <semantics>
  <mrow>
   <mi>κ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>κ</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa(A)
  </annotation>
 </semantics>
</math>

 is large, <a class="uri" href="preconditioning" title="wikilink">preconditioning</a> is used to replace the original system 

<math display="inline" id="Conjugate_gradient_method:54">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐀𝐱</mi>
    <mo>-</mo>
    <mi>𝐛</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <ci>𝐀𝐱</ci>
     <ci>𝐛</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Ax}-\mathbf{b}=0
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Conjugate_gradient_method:55">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>𝐌</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>𝐀𝐱</mi>
      <mo>-</mo>
      <mi>𝐛</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐌</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>𝐀𝐱</ci>
      <ci>𝐛</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}^{-1}(\mathbf{Ax}-\mathbf{b})=0
  </annotation>
 </semantics>
</math>

 so that 

<math display="inline" id="Conjugate_gradient_method:56">
 <semantics>
  <mrow>
   <mi>κ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>𝐌</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mi>𝐀</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>κ</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐌</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>𝐀</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa(\mathbf{M}^{-1}\mathbf{A})
  </annotation>
 </semantics>
</math>

 gets smaller than 

<math display="inline" id="Conjugate_gradient_method:57">
 <semantics>
  <mrow>
   <mi>κ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐀</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>κ</ci>
    <ci>𝐀</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \kappa(\mathbf{A})
  </annotation>
 </semantics>
</math>

, see below.</p>
<h2 id="the-preconditioned-conjugate-gradient-method">The preconditioned conjugate gradient method</h2>

<p>In most cases, <a class="uri" href="preconditioning" title="wikilink">preconditioning</a> is necessary to ensure fast convergence of the conjugate gradient method. The preconditioned conjugate gradient method takes the following form:</p>

<p>

<math display="block" id="Conjugate_gradient_method:58">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐫</mi>
    <mn>0</mn>
   </msub>
   <mo>:=</mo>
   <mrow>
    <mi>𝐛</mi>
    <mo>-</mo>
    <msub>
     <mi>𝐀𝐱</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐫</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <minus></minus>
     <ci>𝐛</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐀𝐱</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r}_{0}:=\mathbf{b}-\mathbf{Ax}_{0}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Conjugate_gradient_method:59">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐳</mi>
    <mn>0</mn>
   </msub>
   <mo>:=</mo>
   <mrow>
    <msup>
     <mi>𝐌</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <msub>
     <mi>𝐫</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐳</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐌</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐫</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{z}_{0}:=\mathbf{M}^{-1}\mathbf{r}_{0}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Conjugate_gradient_method:60">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐩</mi>
    <mn>0</mn>
   </msub>
   <mo>:=</mo>
   <msub>
    <mi>𝐳</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐩</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐳</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{p}_{0}:=\mathbf{z}_{0}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Conjugate_gradient_method:61">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>:=</mo>
   <mpadded width="+1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>k</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k:=0\,
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><strong>repeat</strong>

<p>

<math display="block" id="Conjugate_gradient_method:62">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mi>k</mi>
   </msub>
   <mo>:=</mo>
   <mfrac>
    <mrow>
     <msubsup>
      <mi>𝐫</mi>
      <mi>k</mi>
      <mi mathvariant="normal">T</mi>
     </msubsup>
     <msub>
      <mi>𝐳</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mrow>
     <msubsup>
      <mi>𝐩</mi>
      <mi>k</mi>
      <mi mathvariant="normal">T</mi>
     </msubsup>
     <msub>
      <mi>𝐀𝐩</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐫</ci>
        <ci>k</ci>
       </apply>
       <ci>normal-T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐳</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐩</ci>
        <ci>k</ci>
       </apply>
       <ci>normal-T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐀𝐩</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{k}:=\frac{\mathbf{r}_{k}^{\mathrm{T}}\mathbf{z}_{k}}{\mathbf{p}_{k}^{%
\mathrm{T}}\mathbf{Ap}_{k}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Conjugate_gradient_method:63">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐱</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>:=</mo>
   <mrow>
    <msub>
     <mi>𝐱</mi>
     <mi>k</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>α</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>𝐩</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐱</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐩</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{k+1}:=\mathbf{x}_{k}+\alpha_{k}\mathbf{p}_{k}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Conjugate_gradient_method:64">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐫</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>:=</mo>
   <mrow>
    <msub>
     <mi>𝐫</mi>
     <mi>k</mi>
    </msub>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>α</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>𝐀𝐩</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐫</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐫</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐀𝐩</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r}_{k+1}:=\mathbf{r}_{k}-\alpha_{k}\mathbf{Ap}_{k}
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><strong>if</strong> <strong>r</strong><sub><em>k</em>+1</sub> is sufficiently small <strong>then</strong> exit loop <strong>end if</strong>
</dd>
<dd>

<math display="inline" id="Conjugate_gradient_method:65">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐳</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>:=</mo>
   <mrow>
    <msup>
     <mi>𝐌</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <msub>
     <mi>𝐫</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐳</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐌</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐫</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{z}_{k+1}:=\mathbf{M}^{-1}\mathbf{r}_{k+1}
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Conjugate_gradient_method:66">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mi>k</mi>
   </msub>
   <mo>:=</mo>
   <mfrac>
    <mrow>
     <msubsup>
      <mi>𝐳</mi>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mi mathvariant="normal">T</mi>
     </msubsup>
     <msub>
      <mi>𝐫</mi>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mrow>
     <msubsup>
      <mi>𝐳</mi>
      <mi>k</mi>
      <mi mathvariant="normal">T</mi>
     </msubsup>
     <msub>
      <mi>𝐫</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐳</ci>
        <apply>
         <plus></plus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐫</ci>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐳</ci>
        <ci>k</ci>
       </apply>
       <ci>normal-T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐫</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{k}:=\frac{\mathbf{z}_{k+1}^{\mathrm{T}}\mathbf{r}_{k+1}}{\mathbf{z}_{k}%
^{\mathrm{T}}\mathbf{r}_{k}}
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Conjugate_gradient_method:67">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐩</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>:=</mo>
   <mrow>
    <msub>
     <mi>𝐳</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>β</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>𝐩</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐩</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐳</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐩</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{p}_{k+1}:=\mathbf{z}_{k+1}+\beta_{k}\mathbf{p}_{k}
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="Conjugate_gradient_method:68">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>:=</mo>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mpadded width="+1.7pt">
     <mn>1</mn>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>k</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k:=k+1\,
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd><strong>end repeat</strong>
</dd>
<dd>The result is <strong>x</strong><sub><em>k</em>+1</sub>
</dd>
</dl>

<p>The above formulation is equivalent to applying the conjugate gradient method without preconditioning to the system</p>

<p>

<math display="block" id="Conjugate_gradient_method:69">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>𝐄</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>𝐀</mi>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>𝐄</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">T</mi>
    </msup>
    <mover accent="true">
     <mi>𝐱</mi>
     <mo stretchy="false">^</mo>
    </mover>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>𝐄</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>𝐛</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐄</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>𝐀</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐄</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-T</ci>
     </apply>
     <apply>
      <ci>normal-^</ci>
      <ci>𝐱</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐄</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>𝐛</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{E}^{-1}\mathbf{A}(\mathbf{E}^{-1})^{\mathrm{T}}\mathbf{\hat{x}}=%
\mathbf{E}^{-1}\mathbf{b}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Conjugate_gradient_method:70">
 <semantics>
  <mrow>
   <msup>
    <mi>𝐄𝐄</mi>
    <mi mathvariant="normal">T</mi>
   </msup>
   <mo>=</mo>
   <mi>𝐌</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐄𝐄</ci>
     <ci>normal-T</ci>
    </apply>
    <ci>𝐌</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{EE}^{\mathrm{T}}=\mathbf{M}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Conjugate_gradient_method:71">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>𝐱</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>𝐄</mi>
     <mi mathvariant="normal">T</mi>
    </msup>
    <mi>𝐱</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-^</ci>
     <ci>𝐱</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐄</ci>
      <ci>normal-T</ci>
     </apply>
     <ci>𝐱</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\hat{x}}=\mathbf{E}^{\mathrm{T}}\mathbf{x}
  </annotation>
 </semantics>
</math>

.</p>

<p>The preconditioner matrix <strong>M</strong> has to be symmetric positive-definite and fixed, i.e., cannot change from iteration to iteration. If any of these assumptions on the preconditioner is violated, the behavior of the preconditioned conjugate gradient method may become unpredictable.</p>

<p>An example of a commonly used <a class="uri" href="preconditioner" title="wikilink">preconditioner</a> is the <a href="incomplete_Cholesky_factorization" title="wikilink">incomplete Cholesky factorization</a>.</p>
<h2 id="the-flexible-preconditioned-conjugate-gradient-method">The flexible preconditioned conjugate gradient method</h2>

<p>In numerically challenging applications, sophisticated preconditioners are used, which may lead to variable preconditioning, changing between iterations. Even if the preconditioner is symmetric positive-definite on every iteration, the fact that it may change makes the arguments above invalid, and in practical tests leads to a significant slow down of the convergence of the algorithm presented above. Using the <a href="nonlinear_conjugate_gradient_method" title="wikilink">Polak–Ribière</a> formula</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Conjugate_gradient_method:72">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mi>k</mi>
   </msub>
   <mo>:=</mo>
   <mfrac>
    <mrow>
     <msubsup>
      <mi>𝐳</mi>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mi mathvariant="normal">T</mi>
     </msubsup>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msub>
        <mi>𝐫</mi>
        <mrow>
         <mi>k</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>𝐫</mi>
        <mi>k</mi>
       </msub>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mrow>
     <msubsup>
      <mi>𝐳</mi>
      <mi>k</mi>
      <mi mathvariant="normal">T</mi>
     </msubsup>
     <msub>
      <mi>𝐫</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐳</ci>
        <apply>
         <plus></plus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-T</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐫</ci>
        <apply>
         <plus></plus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐫</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐳</ci>
        <ci>k</ci>
       </apply>
       <ci>normal-T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐫</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{k}:=\frac{\mathbf{z}_{k+1}^{\mathrm{T}}\left(\mathbf{r}_{k+1}-\mathbf{r%
}_{k}\right)}{\mathbf{z}_{k}^{\mathrm{T}}\mathbf{r}_{k}}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>instead of the <a href="nonlinear_conjugate_gradient_method" title="wikilink">Fletcher–Reeves</a> formula</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Conjugate_gradient_method:73">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mi>k</mi>
   </msub>
   <mo>:=</mo>
   <mfrac>
    <mrow>
     <msubsup>
      <mi>𝐳</mi>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mi mathvariant="normal">T</mi>
     </msubsup>
     <msub>
      <mi>𝐫</mi>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mrow>
     <msubsup>
      <mi>𝐳</mi>
      <mi>k</mi>
      <mi mathvariant="normal">T</mi>
     </msubsup>
     <msub>
      <mi>𝐫</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐳</ci>
        <apply>
         <plus></plus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐫</ci>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐳</ci>
        <ci>k</ci>
       </apply>
       <ci>normal-T</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐫</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{k}:=\frac{\mathbf{z}_{k+1}^{\mathrm{T}}\mathbf{r}_{k+1}}{\mathbf{z}_{k}%
^{\mathrm{T}}\mathbf{r}_{k}}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>may dramatically improve the convergence in this case.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> This version of the preconditioned conjugate gradient method can be called<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> <strong>flexible,</strong> as it allows for variable preconditioning. The implementation of the flexible version requires storing an extra vector. For a fixed preconditioner, 

<math display="inline" id="Conjugate_gradient_method:74">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mi>𝐳</mi>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mi mathvariant="normal">T</mi>
     </msubsup>
     <msub>
      <mi>𝐫</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐳</ci>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-T</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐫</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{z}_{k+1}^{\mathrm{T}}\mathbf{r}_{k}=0,
  </annotation>
 </semantics>
</math>

 so both formulas for 

<math display="inline" id="Conjugate_gradient_method:75">
 <semantics>
  <msub>
   <mi>β</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{k}
  </annotation>
 </semantics>
</math>

 are equivalent in exact arithmetic, i.e., without the <a href="round-off_error" title="wikilink">round-off error</a>.</p>

<p>The mathematical explanation of the better convergence behavior of the method with the <a href="nonlinear_conjugate_gradient_method" title="wikilink">Polak–Ribière</a> formula is that the method is <strong>locally optimal</strong> in this case, in particular, it does not converge slower than the locally optimal steepest descent method.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h3 id="example-code-in-matlab-1">Example code in MATLAB</h3>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab">function [x, k] = gcp(x0, A, C, b, mit, stol, bbA, bbC)
<span class="co">% Synopsis:</span>
<span class="co">% x0: initial point</span>
<span class="co">% A: Matrix A of the system Ax=b</span>
<span class="co">% C: Preconditioning Matrix can be left or right</span>
<span class="co">% mit: Maximum number of iterations</span>
<span class="co">% stol: residue norm tolerance</span>
<span class="co">% bbA: Black Box that computes the matrix-vector product for A * u</span>
<span class="co">% bbC: Black Box that computes:</span>
<span class="co">%      for left-side preconditioner : ha = C \ ra</span>
<span class="co">%      for right-side preconditioner: ha = C * ra</span>
<span class="co">% x: Estimated solution point</span>
<span class="co">% k: Number of iterations done </span>
<span class="co">%</span>
<span class="co">% Example:</span>
<span class="co">% tic;[x, t] = cgp(x0, S, speye(1), b, 3000, 10^-8, @(Z, o) Z*o, @(Z, o) o);toc</span>
<span class="co">% Elapsed time is 0.550190 seconds.</span>
<span class="co">%</span>
<span class="co">% Reference:</span>
<span class="co">%  Métodos iterativos tipo Krylov para sistema lineales</span>
<span class="co">%  B. Molina y M. Raydan - ISBN 908-261-078-X</span>
        if ( nargin &lt; <span class="fl">8</span> ), error(<span class="st">'Not enough input arguments. Try help.'</span>); end;
        if ( isempty(A) ), error(<span class="st">'Input matrix A must not be empty.'</span>); end;
        if ( isempty(C) ), error(<span class="st">'Input preconditioner matrix C must not be empty.'</span>); end;
        x = x0;
        ha = <span class="fl">0</span>;
        hp = <span class="fl">0</span>;
        hpp = <span class="fl">0</span>;
        ra = <span class="fl">0</span>;
        rp = <span class="fl">0</span>;
        rpp = <span class="fl">0</span>;
        u = <span class="fl">0</span>;
        k = <span class="fl">0</span>;

        ra = b - bbA(A, x0); <span class="co">% &lt;--- ra = b - A * x0;</span>
        while ( norm(ra, inf) &gt; stol ),
                ha = bbC(C, ra); <span class="co">% &lt;--- ha = C \ ra;</span>
                k = k + <span class="fl">1</span>;
                if ( k == mit ), warning(<span class="st">'GCP:MAXIT'</span>, <span class="st">'mit reached, no conversion.'</span>); return; end;
                hpp = hp;
                rpp = rp;
                hp = ha;
                rp = ra;
                t = rp'*hp;
                if ( k == <span class="fl">1</span> ),
                        u = hp;
                else
                        u = hp + ( t / (rpp'*hpp) ) * u;
                end;
                Au = bbA(A, u); <span class="co">% &lt;--- Au = A * u;</span>
                a = t / (u'*Au);
                x = x + a * u;
                ra = rp - a * Au;
        end;</code></pre></div>
<h2 id="the-conjugate-gradient-method-vs.-the-locally-optimal-steepest-descent-method">The conjugate gradient method vs. the locally optimal steepest descent method</h2>

<p>In both the original and the preconditioned conjugate gradient methods one only needs to set 

<math display="inline" id="Conjugate_gradient_method:76">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mi>k</mi>
   </msub>
   <mo>:=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>k</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{k}:=0
  </annotation>
 </semantics>
</math>

 in order to make them locally optimal, using the <a href="line_search" title="wikilink">line search</a>, <a href="steepest_descent" title="wikilink">steepest descent</a> methods. With this substitution, vectors 

<math display="inline" id="Conjugate_gradient_method:77">
 <semantics>
  <mi>𝐩</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐩</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{p}
  </annotation>
 </semantics>
</math>

 are always the same as vectors 

<math display="inline" id="Conjugate_gradient_method:78">
 <semantics>
  <mi>𝐳</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐳</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{z}
  </annotation>
 </semantics>
</math>

, so there is no need to store vectors 

<math display="inline" id="Conjugate_gradient_method:79">
 <semantics>
  <mi>𝐩</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐩</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{p}
  </annotation>
 </semantics>
</math>

. Thus, every iteration of these <a href="steepest_descent" title="wikilink">steepest descent</a> methods is a bit cheaper compared to that for the conjugate gradient methods. However, the latter converge faster, unless a (highly) variable <a class="uri" href="preconditioner" title="wikilink">preconditioner</a> is used, see above.</p>
<h2 id="derivation-of-the-method">Derivation of the method</h2>

<p>The conjugate gradient method can be derived from several different perspectives, including specialization of the conjugate direction method for optimization, and variation of the <a href="Arnoldi_iteration" title="wikilink">Arnoldi</a>/<a href="Lanczos_iteration" title="wikilink">Lanczos</a> iteration for <a class="uri" href="eigenvalue" title="wikilink">eigenvalue</a> problems. Despite differences in their approaches, these derivations share a common topic—proving the orthogonality of the residuals and conjugacy of the search directions. These two properties are crucial to developing the well-known succinct formulation of the method.</p>
<h2 id="conjugate-gradient-on-the-normal-equations">Conjugate gradient on the normal equations</h2>

<p>The conjugate gradient method can be applied to an arbitrary <em>n</em>-by-<em>m</em> matrix by applying it to <a href="normal_equations" title="wikilink">normal equations</a> <strong>A</strong><sup>T</sup><strong>A</strong> and right-hand side vector <strong>A</strong><sup>T</sup><strong>b</strong>, since <strong>A</strong><sup>T</sup><strong>A</strong> is a symmetric <a href="Positive-definite_matrix#Negative-definite.2C_semidefinite_and_indefinite_matrices" title="wikilink">positive-semidefinite</a> matrix for any <strong>A</strong>. The result is conjugate gradient on the normal equations (CGNR).</p>
<dl>
<dd><strong>A</strong><sup>T</sup><strong>Ax</strong> = <strong>A</strong><sup>T</sup><strong>b</strong>
</dd>
</dl>

<p>As an iterative method, it is not necessary to form <strong>A</strong><sup>T</sup><strong>A</strong> explicitly in memory but only to perform the matrix-vector and transpose matrix-vector multiplications. Therefore CGNR is particularly useful when <em>A</em> is a <a href="sparse_matrix" title="wikilink">sparse matrix</a> since these operations are usually extremely efficient. However the downside of forming the normal equations is that the <a href="condition_number" title="wikilink">condition number</a> κ(<strong>A</strong><sup>T</sup><strong>A</strong>) is equal to κ<sup>2</sup>(<strong>A</strong>) and so the rate of convergence of CGNR may be slow and the quality of the approximate solution may be sensitive to roundoff errors. Finding a good <a class="uri" href="preconditioner" title="wikilink">preconditioner</a> is often an important part of using the CGNR method.</p>

<p>Several algorithms have been proposed (e.g., CGLS, LSQR). The LSQR algorithm purportedly has the best numerical stability when <strong>A</strong> is ill-conditioned, i.e., <strong>A</strong> has a large <a href="condition_number" title="wikilink">condition number</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Biconjugate_gradient_method" title="wikilink">Biconjugate gradient method</a> (BiCG)</li>
<li><a href="Conjugate_residual_method" title="wikilink">Conjugate residual method</a></li>
<li><a href="Nonlinear_conjugate_gradient" title="wikilink">Nonlinear conjugate gradient</a> method</li>
<li><a href="Iterative_method#Linear_systems" title="wikilink">Iterative method. Linear systems</a></li>
<li><a class="uri" href="Preconditioning" title="wikilink">Preconditioning</a></li>
<li><a href="Belief_propagation#Gaussian_belief_propagation_.28GaBP.29" title="wikilink">Gaussian belief propagation</a></li>
<li><a href="Krylov_subspace" title="wikilink">Krylov subspace</a></li>
<li><a href="Sparse_matrix-vector_multiplication" title="wikilink">Sparse matrix-vector multiplication</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>

<p>The conjugate gradient method was originally proposed in</p>
<ul>
<li></li>
</ul>

<p>Descriptions of the method can be found in the following text books:</p>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li><a href="http://www.cs.cmu.edu/~quake-papers/painless-conjugate-gradient.pdf">An Introduction to the Conjugate Gradient Method Without the Agonizing Pain</a> by Jonathan Richard Shewchuk.</li>
<li><a href="http://www-users.cs.umn.edu/~saad/books.html">Iterative methods for sparse linear systems</a> by Yousef Saad</li>
<li><a href="http://www.stanford.edu/group/SOL/software/lsqr/">LSQR: Sparse Equations and Least Squares</a> by Christopher Paige and Michael Saunders.</li>
<li><a href="http://www.onmyphd.com/?p=conjugate.gradient.method">Derivation of fast implementation of conjugate gradient method and interactive example</a></li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_linear_algebra" title="wikilink">Category:Numerical linear algebra</a> <a href="Category:Gradient_methods" title="wikilink">Category:Gradient methods</a> <a href="Category:Articles_with_example_pseudocode" title="wikilink">Category:Articles with example pseudocode</a> <a href="Category:Articles_with_example_MATLAB/Octave_code" title="wikilink">Category:Articles with example MATLAB/Octave code</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>

