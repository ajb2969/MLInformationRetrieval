<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="138">Newton's method in optimization</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Newton's method in optimization</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>A comparison of <a href="gradient_descent" title="wikilink">gradient descent</a> (green) and Newton's method (red) for minimizing a function (with small step sizes). Newton's method uses curvature information to take a more direct route.</figcaption>
</figure>

<p>In <a class="uri" href="calculus" title="wikilink">calculus</a>, <a href="Newton's_method" title="wikilink">Newton's method</a> is an <a href="iterative_method" title="wikilink">iterative method</a> for finding the <a href="Zero_of_a_function" title="wikilink">roots</a> of a <a href="differentiable_function" title="wikilink">differentiable function</a> 

<math display="inline" id="Newton's_method_in_optimization:0">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 (i.e. solutions to the <a class="uri" href="equation" title="wikilink">equation</a> 

<math display="inline" id="Newton's_method_in_optimization:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=0
  </annotation>
 </semantics>
</math>

). In <a href="Mathematical_optimization" title="wikilink">optimization</a>, Newton's method is applied to the <a class="uri" href="derivative" title="wikilink">derivative</a> 

<math display="inline" id="Newton's_method_in_optimization:2">
 <semantics>
  <msup>
   <mi>f</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>f</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}
  </annotation>
 </semantics>
</math>

 of a <a href="smooth_function" title="wikilink">twice-differentiable function</a> 

<math display="inline" id="Newton's_method_in_optimization:3">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>


 to find the roots of the derivative (solutions to 

<math display="inline" id="Newton's_method_in_optimization:4">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(x)=0
  </annotation>
 </semantics>
</math>

), also known as the <a href="stationary_point" title="wikilink">stationary points</a> of 

<math display="inline" id="Newton's_method_in_optimization:5">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="method">Method</h2>

<p>In the one-dimensional problem, Newton's method attempts to construct a <a class="uri" href="sequence" title="wikilink">sequence</a> <em>x</em><sub><em>n</em></sub> from an initial guess <em>x</em><sub>0</sub> that converges towards some value <em>x*</em> satisfying <em>f</em> '(<em>x*</em>)=0. This <em>x*</em> is a <a href="stationary_point" title="wikilink">stationary point</a> of <em>f</em>.</p>

<p>The second order <a href="Taylor_expansion" title="wikilink">Taylor expansion</a> <em>f</em><sub><em>T</em></sub>(<em>x</em>) of <em>f</em> around <em>x</em><sub><em>n</em></sub> is:</p>

<p>

<math display="inline" id="Newton's_method_in_optimization:6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mi>T</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>f</mi>
     <mi>T</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo>+</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>x</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msup>
      <mi>f</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mstyle displaystyle="true">
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
     </mstyle>
     <msup>
      <mi>f</mi>
      <mi>′′</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">Δ</mi>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>T</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>T</ci>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <approx></approx>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
       <ci>normal-Δ</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>′′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
       <ci>normal-Δ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle f_{T}(x)=f_{T}(x_{n}+\Delta x)\approx f(x_{n})+f^{\prime}(x_{n})%
\Delta x+\frac{1}{2}f^{\prime\prime}(x_{n})\Delta x^{2}
  </annotation>
 </semantics>
</math>

.</p>

<p>The last expression attains its extremum with respect to Δ<em>x</em> when its derivative is equal to zero, i.e. when:</p>

<p>

<math display="inline" id="Newton's_method_in_optimization:7">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>=</mo>
   <mrow>
    <mstyle displaystyle="true">
     <mfrac>
      <mi>d</mi>
      <mrow>
       <mi>d</mi>
       <mi mathvariant="normal">Δ</mi>
       <mi>x</mi>
      </mrow>
     </mfrac>
    </mstyle>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msup>
        <mi>f</mi>
        <mo>′</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>x</mi>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mstyle displaystyle="true">
        <mfrac>
         <mn>1</mn>
         <mn>2</mn>
        </mfrac>
       </mstyle>
       <msup>
        <mi>f</mi>
        <mi>′′</mi>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi mathvariant="normal">Δ</mi>
       <msup>
        <mi>x</mi>
        <mn>2</mn>
       </msup>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>f</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msup>
      <mi>f</mi>
      <mi>′′</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <cn type="integer">0</cn>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>d</ci>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>normal-Δ</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
        <ci>normal-Δ</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>′′</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
        <ci>normal-Δ</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>x</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>′′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
       <ci>normal-Δ</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle 0=\frac{d}{d\Delta x}\left(f(x_{n})+f^{\prime}(x_{n})\Delta x+%
\frac{1}{2}f^{\prime\prime}(x_{n})\Delta x^{2}\right)=f^{\prime}(x_{n})+f^{%
\prime\prime}(x_{n})\Delta x
  </annotation>
 </semantics>
</math>

.</p>

<p>For the value of 

<math display="inline" id="Newton's_method_in_optimization:8">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <msup>
       <mi>f</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <msup>
       <mi>f</mi>
       <mi>′′</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>′′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta x=-\frac{f^{\prime}(x_{n})}{f^{\prime\prime}(x_{n})}
  </annotation>
 </semantics>
</math>


, which satisfies this equation, it can be hoped that 

<math display="inline" id="Newton's_method_in_optimization:9">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <msup>
       <mi>f</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <msup>
       <mi>f</mi>
       <mi>′′</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Δ</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>′′</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n+1}=x_{n}+\Delta x=x_{n}-\frac{f^{\prime}(x_{n})}{f^{\prime\prime}(x_{n})}
  </annotation>
 </semantics>
</math>

 will be closer to a stationary point <em>x*</em>. This is the case provided that <em>f</em> is a <a href="smooth_function" title="wikilink">twice-differentiable function</a> and other technical conditions are satisfied; the sequence <em>x</em><sub>0</sub>, <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, … converges to <em>x*</em>.</p>
<h2 id="geometric-interpretation">Geometric interpretation</h2>

<p>The geometric interpretation of Newton's method is that at each iteration one approximates 

<math display="inline" id="Newton's_method_in_optimization:10">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\mathbf{x})
  </annotation>
 </semantics>
</math>

 by a <a href="quadratic_function" title="wikilink">quadratic function</a> around 

<math display="inline" id="Newton's_method_in_optimization:11">
 <semantics>
  <msub>
   <mi>𝐱</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐱</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{n}
  </annotation>
 </semantics>
</math>

, and then takes a step towards the maximum/minimum of that quadratic function (in higher dimensions, this may also be a <a href="saddle_point" title="wikilink">saddle point</a>). Note that if 

<math display="inline" id="Newton's_method_in_optimization:12">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\mathbf{x})
  </annotation>
 </semantics>
</math>

 happens to <em>be</em> a quadratic function, then the exact extremum is found in one step.</p>
<h2 id="higher-dimensions">Higher dimensions</h2>

<p>The above <a href="iteration" title="wikilink">iterative scheme</a> can be generalized to several dimensions by replacing the derivative with the <a class="uri" href="gradient" title="wikilink">gradient</a>, 

<math display="inline" id="Newton's_method_in_optimization:13">
 <semantics>
  <mrow>
   <mrow>
    <mo>∇</mo>
    <mi>f</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-∇</ci>
     <ci>f</ci>
    </apply>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla f(\mathbf{x})
  </annotation>
 </semantics>
</math>


, and the <a href="Multiplicative_inverse" title="wikilink">reciprocal</a> of the second derivative with the <a href="Invertible_matrix" title="wikilink">inverse</a> of the <a href="Hessian_matrix" title="wikilink">Hessian matrix</a>, 

<math display="inline" id="Newton's_method_in_optimization:14">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>𝐱</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>f</ci>
    <ci>𝐱</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Hf(\mathbf{x})
  </annotation>
 </semantics>
</math>

. One obtains the iterative scheme</p>

<p>

<math display="block" id="Newton's_method_in_optimization:15">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐱</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>𝐱</mi>
      <mi>n</mi>
     </msub>
     <mo>-</mo>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mi>H</mi>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>𝐱</mi>
           <mi>n</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mrow>
       <mo>∇</mo>
       <mi>f</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>𝐱</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="7.5pt">,</mo>
   <mrow>
    <mi>n</mi>
    <mo>≥</mo>
    <mn>0.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <times></times>
          <ci>H</ci>
          <ci>f</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐱</ci>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <ci>normal-∇</ci>
        <ci>f</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐱</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <ci>n</ci>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{n+1}=\mathbf{x}_{n}-[Hf(\mathbf{x}_{n})]^{-1}\nabla f(\mathbf{x}_{%
n}),\ n\geq 0.
  </annotation>
 </semantics>
</math>

</p>

<p>Often Newton's method is modified to include a small step size 

<math display="inline" id="Newton's_method_in_optimization:16">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>γ</ci>
    <interval closure="open">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma\in(0,1)
  </annotation>
 </semantics>
</math>

 instead of 

<math display="inline" id="Newton's_method_in_optimization:17">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>γ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma=1
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Newton's_method_in_optimization:18">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐱</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>𝐱</mi>
      <mi>n</mi>
     </msub>
     <mo>-</mo>
     <mrow>
      <mi>γ</mi>
      <msup>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mi>H</mi>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>𝐱</mi>
           <mi>n</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mrow>
       <mo>∇</mo>
       <mi>f</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>𝐱</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐱</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>γ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <ci>H</ci>
         <ci>f</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐱</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <ci>normal-∇</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐱</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{n+1}=\mathbf{x}_{n}-\gamma[Hf(\mathbf{x}_{n})]^{-1}\nabla f(%
\mathbf{x}_{n}).
  </annotation>
 </semantics>
</math>

 This is often done to ensure that the <a href="Wolfe_conditions" title="wikilink">Wolfe conditions</a> are satisfied at each step 

<math display="inline" id="Newton's_method_in_optimization:19">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐱</mi>
    <mi>n</mi>
   </msub>
   <mo>→</mo>
   <msub>
    <mi>𝐱</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐱</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐱</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{n}\to\mathbf{x}_{n+1}
  </annotation>
 </semantics>
</math>

 of the iteration.</p>

<p>Where applicable, Newton's method converges much faster towards a local maximum or minimum than <a href="gradient_descent" title="wikilink">gradient descent</a>. In fact, every local minimum has a neighborhood 

<math display="inline" id="Newton's_method_in_optimization:20">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 such that, if we start with 

<math display="inline" id="Newton's_method_in_optimization:21">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>𝐱</mi>
     <mn>0</mn>
    </msub>
    <mo>∈</mo>
    <mi>N</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐱</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}_{0}\in N,
  </annotation>
 </semantics>
</math>

 Newton's method with step size 

<math display="inline" id="Newton's_method_in_optimization:22">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>γ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma=1
  </annotation>
 </semantics>
</math>

 converges <a href="rate_of_convergence" title="wikilink">quadratically</a> (if the Hessian is <a href="invertible_matrix" title="wikilink">invertible</a> and a <a href="Lipschitz_continuity" title="wikilink">Lipschitz continuous</a> function of 

<math display="inline" id="Newton's_method_in_optimization:23">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>


 in that neighborhood).</p>

<p>Finding the inverse of the Hessian in high dimensions can be an expensive operation. In such cases, instead of directly inverting the Hessian it's better to calculate the vector 

<math display="inline" id="Newton's_method_in_optimization:24">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐩</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>H</mi>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>𝐱</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo>∇</mo>
     <mi>f</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐱</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐩</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>H</ci>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐱</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <ci>normal-∇</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{p}_{n}=[Hf(\mathbf{x}_{n})]^{-1}\nabla f(\mathbf{x}_{n})
  </annotation>
 </semantics>
</math>

 as the solution to the <a href="system_of_linear_equations" title="wikilink">system of linear equations</a></p>

<p>

<math display="block" id="Newton's_method_in_optimization:25">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>H</mi>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>𝐱</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <msub>
     <mi>𝐩</mi>
     <mi>n</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>∇</mo>
     <mi>f</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐱</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>H</ci>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐱</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐩</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-∇</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [Hf(\mathbf{x}_{n})]\mathbf{p}_{n}=\nabla f(\mathbf{x}_{n})
  </annotation>
 </semantics>
</math>

</p>

<p>which may be solved by various factorizations or approximately (but to great accuracy) using <a href="iterative_methods" title="wikilink">iterative methods</a>. Many of these methods are only applicable to certain types of equations, for example the <a href="Cholesky_factorization" title="wikilink">Cholesky factorization</a> and <a href="Conjugate_gradient_method" title="wikilink">conjugate gradient</a> will only work if 

<math display="inline" id="Newton's_method_in_optimization:26">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <mi>H</mi>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐱</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [Hf(\mathbf{x}_{n})]
  </annotation>
 </semantics>
</math>

 is a positive definite matrix. While this may seem like a limitation, it's often useful indicator of something gone wrong, for example if a minimization problem is being approached and 

<math display="inline" id="Newton's_method_in_optimization:27">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <mi>H</mi>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐱</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [Hf(\mathbf{x}_{n})]
  </annotation>
 </semantics>
</math>

 is not positive definite, then the iterations are converging to a <a href="saddle_point" title="wikilink">saddle point</a> and not a minimum.</p>

<p>On the other hand, if a <a href="constrained_optimization" title="wikilink">constrained optimization</a> is done (for example, with <a href="Lagrange_multipliers" title="wikilink">Lagrange multipliers</a>), the problem may become one of saddle point finding, in which case the Hessian will be symmetric indefinite and the solution of 

<math display="inline" id="Newton's_method_in_optimization:28">
 <semantics>
  <msub>
   <mi>𝐩</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐩</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{p}_{n}
  </annotation>
 </semantics>
</math>


 will need to be done with a method that will work for such, such as the <strong>LDL</strong><sup>T</sup> variant of <a href="Cholesky_factorization" title="wikilink">Cholesky factorization</a> or the <a href="conjugate_residual_method" title="wikilink">conjugate residual method</a>.</p>

<p>There also exist various <a href="quasi-Newton_method" title="wikilink">quasi-Newton methods</a>, where an approximation for the Hessian (or its inverse directly) is built up from changes in the gradient.</p>

<p>If the Hessian is close to a non-<a href="invertible_matrix" title="wikilink">invertible matrix</a>, the inverted Hessian can be numerically unstable and the solution may diverge. In this case, certain workarounds have been tried in the past, which have varied success with certain problems. One can, for example, modify the Hessian by adding a correction matrix 

<math display="inline" id="Newton's_method_in_optimization:29">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{n}
  </annotation>
 </semantics>
</math>

 so as to make 

<math display="inline" id="Newton's_method_in_optimization:30">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>f</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐱</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <msub>
    <mi>B</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{f}(\mathbf{x}_{n})+B_{n}
  </annotation>
 </semantics>
</math>

 positive definite. One approach is to diagonalize 

<math display="inline" id="Newton's_method_in_optimization:31">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{f}
  </annotation>
 </semantics>
</math>

 and choose 

<math display="inline" id="Newton's_method_in_optimization:32">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{n}
  </annotation>
 </semantics>
</math>

 so that 

<math display="inline" id="Newton's_method_in_optimization:33">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>f</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>𝐱</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <msub>
    <mi>B</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐱</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{f}(\mathbf{x}_{n})+B_{n}
  </annotation>
 </semantics>
</math>


 has the same eigenvectors as 

<math display="inline" id="Newton's_method_in_optimization:34">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{f}
  </annotation>
 </semantics>
</math>

, but with each negative eigenvalue replaced by 

<math display="inline" id="Newton's_method_in_optimization:35">
 <semantics>
  <mrow>
   <mi>ϵ</mi>
   <mo>></mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>ϵ</ci>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon>0.
  </annotation>
 </semantics>
</math>

</p>

<p>An approach exploited in the <a href="Levenberg–Marquardt_algorithm" title="wikilink">Levenberg–Marquardt algorithm</a> (which uses an approximate Hessian) is to add a scaled identity matrix to the Hessian, 

<math display="inline" id="Newton's_method_in_optimization:36">
 <semantics>
  <mrow>
   <mi>μ</mi>
   <mi>𝐈</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>μ</ci>
    <ci>𝐈</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu\mathbf{I}
  </annotation>
 </semantics>
</math>

, with the scale adjusted at every iteration as needed. For large 

<math display="inline" id="Newton's_method_in_optimization:37">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 and small Hessian, the iterations will behave like <a href="gradient_descent" title="wikilink">gradient descent</a> with step size 

<math display="inline" id="Newton's_method_in_optimization:38">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <mi>μ</mi>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <ci>μ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{\mu}
  </annotation>
 </semantics>
</math>


. This results in slower but more reliable convergence where the Hessian doesn't provide useful information.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Quasi-Newton_method" title="wikilink">Quasi-Newton method</a></li>
<li><a href="Gradient_descent" title="wikilink">Gradient descent</a></li>
<li><a href="Gauss–Newton_algorithm" title="wikilink">Gauss–Newton algorithm</a></li>
<li><a href="Levenberg–Marquardt_algorithm" title="wikilink">Levenberg–Marquardt algorithm</a></li>
<li><a href="Trust_region" title="wikilink">Trust region</a></li>
<li><a href="Optimization_(mathematics)" title="wikilink">Optimization</a></li>
<li><a href="Nelder–Mead_method" title="wikilink">Nelder–Mead method</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>Avriel, Mordecai (2003). <em>Nonlinear Programming: Analysis and Methods</em>. Dover Publishing. ISBN 0-486-43227-0.</li>
<li></li>
<li>

<p>.</p></li>
<li>Nocedal, Jorge &amp; Wright, Stephen J. (1999). <em>Numerical Optimization</em>. Springer-Verlag. ISBN 0-387-98793-2.</li>
<li>

<p>.</p></li>
</ul>

<p><a href="fr:Méthode_de_Newton" title="wikilink">fr:Méthode de Newton</a>"</p>

<p><a href="Category:Optimization_algorithms_and_methods" title="wikilink">Category:Optimization algorithms and methods</a></p>
</body>
</html>
