<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="994">Tagged union</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Tagged union</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, a <strong>tagged union</strong>, also called a <strong><a href="variant_type" title="wikilink">variant</a></strong>, <strong>variant record</strong>, <strong>discriminated union</strong>, <strong><a href="disjoint_union" title="wikilink">disjoint union</a></strong>, or <strong>sum type</strong>, is a <a href="data_structure" title="wikilink">data structure</a> used to hold a value that could take on several different, but fixed, types. Only one of the types can be in use at any one time, and a <strong>tag</strong> field explicitly indicates which one is in use. It can be thought of as a type that has several "cases," each of which should be handled correctly when that type is manipulated. Like ordinary <a href="Union_(computer_science)" title="wikilink">unions</a>, tagged unions can save storage by overlapping storage areas for each type, since only one is in use at a time.</p>

<p>Tagged unions are most important in <a href="functional_language" title="wikilink">functional languages</a> such as <a href="ML_programming_language" title="wikilink">ML</a> and <a href="Haskell_(programming_language)" title="wikilink">Haskell</a>, where they are called <strong>datatypes</strong> (see <a href="algebraic_data_type" title="wikilink">algebraic data type</a>) and the compiler is able to verify that all cases of a tagged union are always handled, avoiding many types of errors. They can, however, be constructed in nearly any <a href="Programming_language" title="wikilink">language</a>, and are much safer than untagged unions, often simply called unions, which are similar but do not explicitly keep track of which member of the union is currently in use.</p>

<p>Tagged unions are often accompanied by the concept of a <a href="type_constructor" title="wikilink">type constructor</a>, which is similar but not the same as a <a href="constructor_(computer_science)" title="wikilink">constructor</a> for a class. Type constructors produce a tagged union type, given the initial tag type and the corresponding type.</p>

<p>Mathematically, tagged unions correspond to <em><a href="disjoint_union" title="wikilink">disjoint</a></em> or <em>discriminated unions</em>, usually written using +. Given an element of a disjoint union <em>A</em> + <em>B</em>, it is possible to determine whether it came from <em>A</em> or <em>B</em>. If an element lies in both, there will be two effectively distinct copies of the value in <em>A</em> + <em>B</em>, one from <em>A</em> and one from <em>B</em>.</p>

<p>In <a href="type_theory" title="wikilink">type theory</a>, a tagged union is called a <strong>sum type</strong>. Sum types are the <a href="dual_(mathematics)" title="wikilink">dual</a> of <a href="product_type" title="wikilink">product types</a>. Notations vary, but usually the sum type 

<math display="inline" id="Tagged_union:0">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>+</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A+B
  </annotation>
 </semantics>
</math>

 comes with two introduction forms 

<math display="inline" id="Tagged_union:1">
 <semantics>
  <mrow>
   <msub>
    <mtext>inj</mtext>
    <mn>1</mn>
   </msub>
   <mo>:</mo>
   <mrow>
    <mi>A</mi>
    <mo>‚Üí</mo>
    <mrow>
     <mi>A</mi>
     <mo>+</mo>
     <mi>B</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <mtext>inj</mtext>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <ci>normal-‚Üí</ci>
     <ci>A</ci>
     <apply>
      <plus></plus>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{inj}_{1}:A\to A+B
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Tagged_union:2">
 <semantics>
  <mrow>
   <msub>
    <mtext>inj</mtext>
    <mn>2</mn>
   </msub>
   <mo>:</mo>
   <mrow>
    <mi>B</mi>
    <mo>‚Üí</mo>
    <mrow>
     <mi>A</mi>
     <mo>+</mo>
     <mi>B</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <mtext>inj</mtext>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <ci>normal-‚Üí</ci>
     <ci>B</ci>
     <apply>
      <plus></plus>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{inj}_{2}:B\to A+B
  </annotation>
 </semantics>
</math>

. The elimination form is case analysis, known as <a href="pattern_matching" title="wikilink">pattern matching</a> in <a href="ML_(programming_language)" title="wikilink">ML-style</a> programming languages: if 

<math display="inline" id="Tagged_union:3">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>


 has type 

<math display="inline" id="Tagged_union:4">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>+</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A+B
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Tagged_union:5">
 <semantics>
  <msub>
   <mi>e</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Tagged_union:6">
 <semantics>
  <msub>
   <mi>e</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{2}
  </annotation>
 </semantics>
</math>

 have type 

<math display="inline" id="Tagged_union:7">
 <semantics>
  <mi>œÑ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>œÑ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 under the assumptions 

<math display="inline" id="Tagged_union:8">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>:</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>x</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x:A
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Tagged_union:9">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>:</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>y</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y:B
  </annotation>
 </semantics>
</math>

 respectively, then the term 

<math display="inline" id="Tagged_union:10">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <mi>ùñºùñ∫ùóåùñæ</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mi>e</mi>
   </mpadded>
   <mpadded width="+5pt">
    <mi>ùóàùñø</mi>
   </mpadded>
   <mi>x</mi>
   <mo>‚áí</mo>
   <msub>
    <mi>e</mi>
    <mn>1</mn>
   </msub>
   <mo stretchy="false">|</mo>
   <mi>y</mi>
   <mo>‚áí</mo>
   <msub>
    <mi>e</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">case</csymbol>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">of</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-‚áí</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-‚áí</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <cn type="integer">2</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathsf{case}\ e\ \mathsf{of}\ x\Rightarrow e_{1}|y\Rightarrow e_{2}
  </annotation>
 </semantics>
</math>

 has type 

<math display="inline" id="Tagged_union:11">
 <semantics>
  <mi>œÑ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>œÑ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

. The sum type corresponds to intuitionistic <a href="logical_disjunction" title="wikilink">logical disjunction</a> under the <a href="Curry‚ÄìHoward_correspondence" title="wikilink">Curry‚ÄìHoward correspondence</a>.</p>

<p>An <a href="enumerated_type" title="wikilink">enumerated type</a> can be seen as a degenerate case: a tagged union of <a href="unit_type" title="wikilink">unit types</a>. It corresponds to a set of nullary constructors and may be implemented as a simple tag variable, since it holds no additional data besides the value of the tag.</p>

<p>Many programming techniques and data structures ‚Äì including <a href="rope_(data_structure)" title="wikilink">rope (data structure)</a>, <a href="lazy_evaluation" title="wikilink">lazy evaluation</a>, <a href="class_hierarchy" title="wikilink">class hierarchy</a> (see below), <a href="arbitrary-precision_arithmetic" title="wikilink">arbitrary-precision arithmetic</a>, <a href="CDR_coding" title="wikilink">CDR coding</a>, the <a href="indirection_bit" title="wikilink">indirection bit</a> and other kinds of <a href="tagged_pointer" title="wikilink">tagged pointers</a>, etc. ‚Äì are usually implemented using some sort of tagged union.</p>

<p>A tagged union can be seen as the simplest kind of <a class="uri" href="self-describing" title="wikilink">self-describing</a> <a href="comparison_of_data_serialization_formats" title="wikilink"> data format</a>. The tag of the tagged union can be seen as the simplest kind of <a class="uri" href="metadata" title="wikilink">metadata</a>.</p>
<h2 id="advantages-and-disadvantages">Advantages and disadvantages</h2>

<p>The primary advantage of a tagged union over an untagged union is that all accesses are safe, and the compiler can even check that all cases are handled. Untagged unions depend on program logic to correctly identify the currently active field, which may result in strange behavior and hard-to-find bugs if that logic fails.</p>

<p>The primary advantage of a tagged union over a simple <a href="record_(computer_science)" title="wikilink">record</a> containing a field for each type is that it saves storage by overlapping storage for all the types. Some implementations reserve enough storage for the largest type, while others dynamically adjust the size of a tagged union value as needed. When the value is <a href="Immutable_object" title="wikilink">immutable</a>, it is simple to allocate just as much storage as is needed.</p>

<p>The main disadvantage of tagged unions is that the tag occupies space. Since there are usually a small number of alternatives, the tag can often be squeezed into 2 or 3 bits wherever space can be found, but sometimes even these bits are not available. In this case, a helpful alternative may be <strong>folded</strong>, <strong>computed</strong> or <strong>encoded tags</strong>, where the tag value is dynamically computed from the contents of the union field. Common examples of this are the use of <em>reserved values</em>, where, for example, a function returning a positive number may return -1 to indicate failure, and <a href="sentinel_value" title="wikilink">sentinel values</a>, most often used in <a href="tagged_pointer" title="wikilink">tagged pointers</a>.</p>

<p>Sometimes, untagged unions are used to perform bit-level conversions between types, called reinterpret casts in C++. Tagged unions are not intended for this purpose; typically a new value is assigned whenever the tag is changed.</p>

<p>Many languages support, to some extent, a <a href="Top_type" title="wikilink">universal data type</a>, which is a type that includes every value of every other type, and often a way is provided to test the actual type of a value of the universal type. These are sometimes referred to as <em>variants</em>. While universal data types are comparable to tagged unions in their formal definition, typical tagged unions include a relatively small number of cases, and these cases form different ways of expressing a single coherent concept, such as a data structure node or instruction. Also, there is an expectation that every possible case of a tagged union will be dealt with when it is used. The values of a universal data type are not related and there is no feasible way to deal with them all.</p>

<p>Like <a href="option_type" title="wikilink">option types</a> and <a href="exception_handling" title="wikilink">exception handling</a>, tagged unions are sometimes used to handle the occurrence of exceptional results. Often these tags are folded into the type as "reserved values", and their occurrence is not consistently checked: this is a fairly common source of programming errors. This use of tagged unions can be formalized as a <a href="monads_in_functional_programming" title="wikilink">monad</a> with the following functions:</p>

<p>

<math display="block" id="Tagged_union:12">
 <semantics>
  <mrow>
   <mtext>return</mtext>
   <mo>:</mo>
   <mrow>
    <mi>A</mi>
    <mo>‚Üí</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>A</mi>
      <mo>+</mo>
      <mi>E</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>=</mo>
    <mi>a</mi>
    <mo>‚Ü¶</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mtext>value</mtext>
     </mpadded>
     <mi>a</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <mtext>return</mtext>
    <apply>
     <and></and>
     <apply>
      <ci>normal-‚Üí</ci>
      <ci>A</ci>
      <apply>
       <plus></plus>
       <ci>A</ci>
       <ci>E</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <mtext>value</mtext>
       <ci>a</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{return}\colon A\to\left(A+E\right)=a\mapsto\text{value}\,a
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Tagged_union:13">
 <semantics>
  <mrow>
   <mtext>bind</mtext>
   <mo>:</mo>
   <mrow>
    <mo>(</mo>
    <mi>A</mi>
    <mo>+</mo>
    <mi>E</mi>
    <mo>)</mo>
   </mrow>
   <mo>‚Üí</mo>
   <mrow>
    <mo>(</mo>
    <mi>A</mi>
    <mo>‚Üí</mo>
    <mrow>
     <mo>(</mo>
     <mi>B</mi>
     <mo>+</mo>
     <mi>E</mi>
     <mo>)</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mo>‚Üí</mo>
   <mrow>
    <mo>(</mo>
    <mi>B</mi>
    <mo>+</mo>
    <mi>E</mi>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mi>a</mi>
   <mo>‚Ü¶</mo>
   <mi>f</mi>
   <mo>‚Ü¶</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mpadded width="+1.7pt">
         <mtext>err</mtext>
        </mpadded>
        <mi>e</mi>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mpadded width="+5pt">
          <mtext>if</mtext>
         </mpadded>
         <mi>a</mi>
        </mrow>
        <mo>=</mo>
        <mrow>
         <mpadded width="+1.7pt">
          <mtext>err</mtext>
         </mpadded>
         <mi>e</mi>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mpadded width="+1.7pt">
         <mi>f</mi>
        </mpadded>
        <msup>
         <mi>a</mi>
         <mo>‚Ä≤</mo>
        </msup>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mpadded width="+5pt">
          <mtext>if</mtext>
         </mpadded>
         <mi>a</mi>
        </mrow>
        <mo>=</mo>
        <mrow>
         <mpadded width="+1.7pt">
          <mtext>value</mtext>
         </mpadded>
         <msup>
          <mi>a</mi>
          <mo>‚Ä≤</mo>
         </msup>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>bind</mtext>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <plus></plus>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-‚Üí</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-‚Üí</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <plus></plus>
      <csymbol cd="unknown">E</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-‚Üí</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <plus></plus>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">a</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <times></times>
      <mtext>err</mtext>
      <ci>e</ci>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>a</ci>
      </apply>
      <apply>
       <times></times>
       <mtext>err</mtext>
       <ci>e</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>normal-‚Ä≤</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>a</ci>
      </apply>
      <apply>
       <times></times>
       <mtext>value</mtext>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <ci>normal-‚Ä≤</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{bind}\colon\left(A+E\right)\to\left(A\to\left(B+E\right)\right)\to\left(%
B+E\right)=a\mapsto f\mapsto\begin{cases}\text{err}\,e&\text{if}\ a=\text{err}%
\,e\\
f\,a^{\prime}&\text{if}\ a=\text{value}\,a^{\prime}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>where "value" and "err" are the constructors of the union type, <em>A</em> and <em>B</em> are valid result types and <em>E</em> is the type of error conditions. Alternately, the same monad may be described by <em>return</em> and two additional functions, <em>fmap</em> and <em>join</em>:</p>

<p>

<math display="block" id="Tagged_union:14">
 <semantics>
  <mrow>
   <mtext>fmap</mtext>
   <mo>:</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>‚Üí</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>‚Üí</mo>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mo>(</mo>
     <mi>A</mi>
     <mo>+</mo>
     <mi>E</mi>
     <mo>)</mo>
    </mrow>
    <mo>‚Üí</mo>
    <mrow>
     <mo>(</mo>
     <mi>B</mi>
     <mo>+</mo>
     <mi>E</mi>
     <mo>)</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mi>f</mi>
   <mo>‚Ü¶</mo>
   <mi>a</mi>
   <mo>‚Ü¶</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mpadded width="+1.7pt">
         <mtext>err</mtext>
        </mpadded>
        <mi>e</mi>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mpadded width="+5pt">
          <mtext>if</mtext>
         </mpadded>
         <mi>a</mi>
        </mrow>
        <mo>=</mo>
        <mrow>
         <mpadded width="+1.7pt">
          <mtext>err</mtext>
         </mpadded>
         <mi>e</mi>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mpadded width="+1.7pt">
         <mtext>value</mtext>
        </mpadded>
        <mpadded width="+1.7pt">
         <mi>f</mi>
        </mpadded>
        <msup>
         <mi>a</mi>
         <mo>‚Ä≤</mo>
        </msup>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mpadded width="+5pt">
          <mtext>if</mtext>
         </mpadded>
         <mi>a</mi>
        </mrow>
        <mo>=</mo>
        <mrow>
         <mpadded width="+1.7pt">
          <mtext>value</mtext>
         </mpadded>
         <msup>
          <mi>a</mi>
          <mo>‚Ä≤</mo>
         </msup>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>fmap</mtext>
    <ci>normal-:</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-‚Üí</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-‚Üí</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <plus></plus>
      <csymbol cd="unknown">E</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-‚Üí</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <plus></plus>
      <csymbol cd="unknown">E</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">f</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <csymbol cd="latexml">maps-to</csymbol>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <times></times>
      <mtext>err</mtext>
      <ci>e</ci>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>a</ci>
      </apply>
      <apply>
       <times></times>
       <mtext>err</mtext>
       <ci>e</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <mtext>value</mtext>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>normal-‚Ä≤</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>a</ci>
      </apply>
      <apply>
       <times></times>
       <mtext>value</mtext>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <ci>normal-‚Ä≤</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{fmap}\colon(A\to B)\to\left(\left(A+E\right)\to\left(B+E\right)\right)=f%
\mapsto a\mapsto\begin{cases}\text{err}\,e&\text{if}\ a=\text{err}\,e\\
\text{value}\,f\,a^{\prime}&\text{if}\ a=\text{value}\,a^{\prime}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Tagged_union:15">
 <semantics>
  <mrow>
   <mtext>join</mtext>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>A</mi>
        <mo>+</mo>
        <mi>E</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>+</mo>
      <mi>E</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>‚Üí</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>+</mo>
      <mi>E</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mi>a</mi>
    <mo>‚Ü¶</mo>
    <mrow>
     <mo>{</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="left">
        <mrow>
         <mpadded width="+1.7pt">
          <mtext>err</mtext>
         </mpadded>
         <mi>e</mi>
        </mrow>
       </mtd>
       <mtd columnalign="left">
        <mrow>
         <mrow>
          <mpadded width="+5pt">
           <mtext>if</mtext>
          </mpadded>
          <mi>a</mi>
         </mrow>
         <mo>=</mo>
         <mrow>
          <mpadded width="+1.7pt">
           <mtext>err</mtext>
          </mpadded>
          <mi>e</mi>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="left">
        <mrow>
         <mpadded width="+1.7pt">
          <mtext>err</mtext>
         </mpadded>
         <mi>e</mi>
        </mrow>
       </mtd>
       <mtd columnalign="left">
        <mrow>
         <mrow>
          <mpadded width="+5pt">
           <mtext>if</mtext>
          </mpadded>
          <mi>a</mi>
         </mrow>
         <mo>=</mo>
         <mrow>
          <mpadded width="+1.7pt">
           <mtext>value</mtext>
          </mpadded>
          <mpadded width="+1.7pt">
           <mtext>err</mtext>
          </mpadded>
          <mi>e</mi>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="left">
        <mrow>
         <mpadded width="+1.7pt">
          <mtext>value</mtext>
         </mpadded>
         <msup>
          <mi>a</mi>
          <mo>‚Ä≤</mo>
         </msup>
        </mrow>
       </mtd>
       <mtd columnalign="left">
        <mrow>
         <mrow>
          <mpadded width="+5pt">
           <mtext>if</mtext>
          </mpadded>
          <mi>a</mi>
         </mrow>
         <mo>=</mo>
         <mrow>
          <mpadded width="+1.7pt">
           <mtext>value</mtext>
          </mpadded>
          <mpadded width="+1.7pt">
           <mtext>value</mtext>
          </mpadded>
          <msup>
           <mi>a</mi>
           <mo>‚Ä≤</mo>
          </msup>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <mtext>join</mtext>
    <apply>
     <and></and>
     <apply>
      <ci>normal-‚Üí</ci>
      <apply>
       <plus></plus>
       <apply>
        <plus></plus>
        <ci>A</ci>
        <ci>E</ci>
       </apply>
       <ci>E</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>A</ci>
       <ci>E</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="latexml">cases</csymbol>
       <apply>
        <times></times>
        <mtext>err</mtext>
        <ci>e</ci>
       </apply>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <mtext>if</mtext>
         <ci>a</ci>
        </apply>
        <apply>
         <times></times>
         <mtext>err</mtext>
         <ci>e</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <mtext>err</mtext>
        <ci>e</ci>
       </apply>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <mtext>if</mtext>
         <ci>a</ci>
        </apply>
        <apply>
         <times></times>
         <mtext>value</mtext>
         <mtext>err</mtext>
         <ci>e</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <mtext>value</mtext>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>a</ci>
         <ci>normal-‚Ä≤</ci>
        </apply>
       </apply>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <mtext>if</mtext>
         <ci>a</ci>
        </apply>
        <apply>
         <times></times>
         <mtext>value</mtext>
         <mtext>value</mtext>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>a</ci>
          <ci>normal-‚Ä≤</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{join}\colon((A+E)+E)\to(A+E)=a\mapsto\begin{cases}\text{err}\,e&\mbox{if%
}\ a=\text{err}\,e\\
\text{err}\,e&\text{if}\ a=\text{value}\,\text{err}\,e\\
\text{value}\,a^{\prime}&\text{if}\ a=\text{value}\,\text{value}\,a^{\prime}%
\end{cases}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="examples">Examples</h2>

<p>Say we wanted to build a <a href="binary_tree" title="wikilink">binary tree</a> of integers. In ML, we would do this by creating a datatype like this:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml">datatype tree = <span class="dt">Leaf</span>
              | <span class="dt">Node</span> <span class="kw">of</span> (<span class="dt">int</span> * tree * tree)</code></pre></div>

<p>This is a tagged union with two cases: one, the leaf, is used to terminate a path of the tree, and functions much like a null value would in imperative languages. The other branch holds a node, which contains an integer and a left and right subtree. Leaf and Node are the constructors, which enable us to actually produce a particular tree, such as:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="dt">Node</span>(<span class="dv">5</span>, <span class="dt">Node</span>(<span class="dv">1</span>,<span class="dt">Leaf</span>,<span class="dt">Leaf</span>), <span class="dt">Node</span>(<span class="dv">3</span>, <span class="dt">Leaf</span>, <span class="dt">Node</span>(<span class="dv">4</span>, <span class="dt">Leaf</span>, <span class="dt">Leaf</span>)))</code></pre></div>

<p>which corresponds to this tree:</p>
<center>
<figure><b>(Figure)</b>
<figcaption>The tree produced by the above constructors</figcaption>
</figure>
</center>

<p>Now we can easily write a typesafe function that, say, counts the number of nodes in the tree:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">fun</span> countNodes(<span class="dt">Leaf</span>) = <span class="dv">0</span>
  | countNodes(<span class="dt">Node</span>(<span class="dt">int</span>,left,right)) =
      <span class="dv">1</span> + countNodes(left) + countNodes(right)</code></pre></div>
<h2 id="timeline-of-language-support">Timeline of language support</h2>
<h3 id="s">1960s</h3>

<p>In <a href="ALGOL_68" title="wikilink">ALGOL 68</a>, tagged unions are called <em>united modes</em>, the tag is implicit, and the <code>'''case'''</code> construct is used to determine which field is tagged:</p>

<p><code>'''mode''' '''node''' = '''union''' ('''real''', '''int''', '''compl''', '''string''');</code></p>

<p>Usage example for <code>'''union'''</code> <code>'''case'''</code> of <code>'''node'''</code>:</p>

<p><strong><code>node</code></strong><code>¬†n¬†:=¬†"1234";</code><br/>
<code>¬†</code><br/>
<strong><code>case</code></strong><code>¬†n¬†</code><strong><code>in</code></strong><br/>
<code>¬†¬†(</code><strong><code>real</code></strong><code>¬†r):¬†¬†¬†print(("real:",¬†r)),</code><br/>
<code>¬†¬†(</code><strong><code>int</code></strong><code>¬†i):¬†¬†¬†¬†print(("int:",¬†i)),</code><br/>
<code>¬†¬†(</code><strong><code>compl</code></strong><code>¬†c):¬†¬†print(("compl:",¬†c)),</code><br/>
<code>¬†¬†(</code><strong><code>string</code></strong><code>¬†s):¬†print(("string:",¬†s))</code><br/>
<code>¬†¬†</code><strong><code>out</code></strong><code>¬†¬†¬†¬†¬†¬†¬†¬†¬†print(("?:",¬†n))</code><br/>
<strong><code>esac</code></strong></p>
<h3 id="s-1980s">1970s &amp; 1980s</h3>

<p>Although primarily only <a href="functional_programming_language" title="wikilink">functional languages</a> such as <a href="ML_programming_language" title="wikilink">ML</a> and <a href="Haskell_(programming_language)" title="wikilink">Haskell</a> (from 1990s) give a central role to tagged unions and have the power to check that all cases are handled, other languages have support for tagged unions as well. However, in practice they can be less efficient in non-functional languages due to optimizations enabled by functional language compilers that can eliminate explicit tag checks and avoid explicit storage of tags.</p>

<p><a href="Pascal_programming_language" title="wikilink">Pascal</a>, <a href="Ada_programming_language" title="wikilink">Ada</a>, and <a class="uri" href="Modula-2" title="wikilink">Modula-2</a> call them <strong>variant records</strong> (formally <strong>discriminated type</strong> in Ada), and require the tag field to be manually created and the tag values specified, as in this Pascal example:</p>
<div class="sourceCode"><pre class="sourceCode pascal"><code class="sourceCode pascal"><span class="kw">type</span> shapeKind = (square, rectangle, circle);
     shape = <span class="kw">record</span>
                centerx : <span class="dt">integer</span>;
                centery : <span class="dt">integer</span>;
                <span class="kw">case</span> kind : shapeKind <span class="kw">of</span>
                   square : (side : <span class="dt">integer</span>);
                   rectangle : (length, height : <span class="dt">integer</span>);
                   circle : (radius : <span class="dt">integer</span>);
          <span class="kw">end</span>;</code></pre></div>

<p>and this Ada equivalent:</p>
<div class="sourceCode"><pre class="sourceCode ada"><code class="sourceCode ada"><span class="kw">type</span> Shape_Kind <span class="kw">is</span> (Square, Rectangle, Circle);
<span class="kw">type</span> Shape (Kind : Shape_Kind) <span class="kw">is</span> <span class="kw">record</span>
   Center_X : <span class="dt">Integer</span>;
   Center_Y : <span class="dt">Integer</span>;
   <span class="kw">case</span> Kind <span class="kw">is</span>
      <span class="kw">when</span> Square =&gt;
         Side : <span class="dt">Integer</span>;
      <span class="kw">when</span> Rectangle =&gt;
         Length, Height : <span class="dt">Integer</span>;
      <span class="kw">when</span> Circle =&gt;
         Radius : <span class="dt">Integer</span>;
   <span class="kw">end case</span>;
<span class="kw">end record</span>;

<span class="co">-- Any attempt to access a member whose existence depends</span>
<span class="co">-- on a particular value of the discriminant, while the</span>
<span class="co">-- discriminant is not the expected one, raises an error.</span></code></pre></div>

<p>In <a href="C_(programming_language)" title="wikilink">C</a> and <a class="uri" href="C++" title="wikilink">C++</a>, a tagged union can be created from untagged unions using a strict access discipline where the tag is always checked:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">enum</span> ShapeKind { Square, Rectangle, Circle };

<span class="kw">struct</span> Shape {
    <span class="dt">int</span> centerx;
    <span class="dt">int</span> centery;
    <span class="kw">enum</span> ShapeKind kind;
    <span class="kw">union</span> {
        <span class="kw">struct</span> { <span class="dt">int</span> side; };           <span class="co">/* Square */</span>
        <span class="kw">struct</span> { <span class="dt">int</span> length, height; }; <span class="co">/* Rectangle */</span>
        <span class="kw">struct</span> { <span class="dt">int</span> radius; };         <span class="co">/* Circle */</span>
    };
};

<span class="dt">int</span> getSquareSide(<span class="kw">struct</span> Shape* s) {
    assert(s-&gt;kind == Square);
    <span class="kw">return</span> s-&gt;side;
}

<span class="dt">void</span> setSquareSide(<span class="kw">struct</span> Shape* s, <span class="dt">int</span> side) {
    s-&gt;kind = Square;
    s-&gt;side = side;
}

<span class="co">/* and so on */</span></code></pre></div>

<p>As long as the union fields are only accessed through the functions, the accesses will be safe and correct. The same approach can be used for encoded tags; we simply decode the tag and then check it on each access. If the inefficiency of these tag checks is a concern, they may be automatically removed in the final version.</p>

<p>C and C++ also have language support for one particular tagged union: the possibly-null <a href="Pointer_(computer_programming)" title="wikilink">pointer</a>. This may be compared to the <code>option</code> type in ML or the <code>Maybe</code> type in Haskell, and can be seen as a <a href="tagged_pointer" title="wikilink">tagged pointer</a>: a tagged union (with an encoded tag) of two types:</p>
<ul>
<li>Valid pointers,</li>
<li>A type with only one value, <code>null</code>, indicating an exceptional condition.</li>
</ul>

<p>Unfortunately, C compilers do not verify that the null case is always handled, and this is a particularly prevalent source of errors in C code, since there is a tendency to ignore exceptional cases.</p>
<h3 id="s-1">2000s</h3>

<p>One advanced dialect of C called <a href="Cyclone_programming_language" title="wikilink">Cyclone</a> has extensive built-in support for tagged unions. See <a href="http://cyclone.thelanguage.org/wiki/Tagged%20Unions">the tagged union section of the on-line manual</a> for more information.</p>

<p>The enum types in the <a href="Rust_(programming_language)" title="wikilink">Rust</a> and <a href="Swift_(programming_language)" title="wikilink">Swift</a> languages also work as tagged unions.</p>

<p>The variant library from <a href="Boost_C++_Libraries" title="wikilink">Boost</a> has demonstrated it was possible to implement a safe tagged union as a library in C++, visitable using functors.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> display : boost::static_visitor&lt;<span class="dt">void</span>&gt;
{
    <span class="dt">void</span> <span class="kw">operator</span>()(<span class="dt">int</span> i)
    {
        std::cout &lt;&lt; <span class="st">"It's an int, with value "</span> &lt;&lt; i &lt;&lt; std::endl;
    }

    <span class="dt">void</span> <span class="kw">operator</span>()(<span class="dt">const</span> std::string&amp; s)
    {
        std::cout &lt;&lt; <span class="st">"It's a string, with value "</span> &lt;&lt; s &lt;&lt; std::endl;
    }
};

boost::variant&lt;<span class="dt">int</span>, std::string=<span class="st">""</span>&gt; v = <span class="dv">42</span>;
boost::apply_visitor(display(), v);

boost::variant&lt;<span class="dt">int</span>, std::string=<span class="st">""</span>&gt; v = <span class="st">"hello world"</span>;
boost::apply_visitor(display(), v);
<!--<span class="dt"-->int</code></pre></div></body>,&gt;<!--<span class="dt"-->int,&gt;<!--<span class="dt"-->void&gt;

<p><a href="Scala_(programming_language)" title="wikilink">Scala</a> has case classes:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">abstract</span> <span class="kw">class</span> Tree
<span class="kw">case</span> <span class="kw">object</span> Leaf <span class="kw">extends</span> Tree
<span class="kw">case</span> <span class="kw">class</span> Node(value: Int, left: Tree, right: Tree) <span class="kw">extends</span> Tree

<span class="kw">val</span> tree = Node(<span class="dv">5</span>, Node(<span class="dv">1</span>,Leaf,Leaf), Node(<span class="dv">3</span>, Leaf, Node(<span class="dv">4</span>, Leaf, Leaf)))</code></pre></div>

<p>Because the class hierarchy is sealed, the compiler can check that all cases are handled in a pattern match:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">tree <span class="kw">match</span> {
  <span class="kw">case</span> Node(x, _, _) =&gt; <span class="fu">println</span>(<span class="st">"top level node value: "</span> + x)
  <span class="kw">case</span> Leaf          =&gt; <span class="fu">println</span>(<span class="st">"top level node is a leaf"</span>)
}</code></pre></div>

<p>Scala's case classes also permit reuse through subtyping:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">abstract</span> <span class="kw">class</span> Shape(centerX: Int, centerY: Int)
<span class="kw">case</span> <span class="kw">class</span> <span class="fu">Square</span>(side: Int, centerX: Int, centerY: Int) <span class="kw">extends</span> Shape(centerX, centerY)
<span class="kw">case</span> <span class="kw">class</span> Rectangle(length: Int, height: Int, centerX: Int, centerY: Int) <span class="kw">extends</span> Shape(centerX, centerY)
<span class="kw">case</span> <span class="kw">class</span> <span class="fu">Circle</span>(radius: Int, centerX: Int, centerY: Int) <span class="kw">extends</span> Shape(centerX, centerY)</code></pre></div>
<h2 id="class-hierarchies-as-tagged-unions">Class hierarchies as tagged unions</h2>

<p>In a typical <a href="class_hierarchy" title="wikilink">class hierarchy</a> in <a href="object-oriented_programming" title="wikilink">object-oriented programming</a>, each subclass can encapsulate data unique to that class. The metadata used to perform <a href="virtual_method" title="wikilink">virtual method</a> lookup (for example, the object's <a href="virtual_method_table" title="wikilink">vtable</a> pointer in most C++ implementations) identifies the subclass and so effectively acts as a tag identifying the particular data stored by the instance (see <a class="uri" href="RTTI" title="wikilink">RTTI</a>). An object's <a href="Constructor_(computer_science)" title="wikilink">constructor</a> sets this tag, and it remains constant throughout the object's lifetime.</p>

<p>Nevertheless, a class hierarchy involves true <a href="subtype_polymorphism" title="wikilink">subtype polymorphism</a>; it can be extended by creating further subclasses of the same base type, which could not be handled correctly under a tag/dispatch model. Hence, it is usually not possible to do case analysis or dispatch on a subobject's 'tag' as one would for tagged unions. Some languages such as <a href="Scala_(programming_language)" title="wikilink">Scala</a> allow base classes to be "sealed", and unify tagged unions with sealed base classes.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Discriminator" title="wikilink">Discriminator</a>, the type tag for discriminated unions in <a class="uri" href="CORBA" title="wikilink">CORBA</a></li>
<li><a href="Apache_Thrift" title="wikilink">Apache Thrift</a>, an RPC system with tagged unions</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.boost.org/libs/variant/index.html">boost::variant</a> is a C++ typesafe discriminated union</li>
<li><a href="http://www.digitalmars.com/d/phobos/std_variant.html">std.variant</a> is an implementation of variant type in <a href="D_(programming_language)" title="wikilink">D</a> 2.0</li>
</ul>

<p>"</p>

<p><a href="Category:Data_types" title="wikilink">Category:Data types</a> <a href="Category:Type_theory" title="wikilink">Category:Type theory</a> <a href="Category:Articles_with_example_Pascal_code" title="wikilink">Category:Articles with example Pascal code</a> <a href="Category:Articles_with_example_ALGOL_68_code" title="wikilink">Category:Articles with example ALGOL 68 code</a> <a href="Category:Articles_with_example_C_code" title="wikilink">Category:Articles with example C code</a> <a href="Category:Articles_with_example_C++_code" title="wikilink">Category:Articles with example C++ code</a> <a href="Category:Articles_with_example_Ada_code" title="wikilink">Category:Articles with example Ada code</a></p>


