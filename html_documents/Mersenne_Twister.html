<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1477">Mersenne Twister</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Mersenne Twister</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>The <strong>Mersenne Twister</strong> is a <a href="pseudorandom_number_generator" title="wikilink">pseudorandom number generator</a> (PRNG). It is by far the most widely used PRNG.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Its name derives from the fact that its period length is chosen to be a <a href="Mersenne_prime" title="wikilink">Mersenne prime</a>.</p>

<p>The Mersenne Twister was developed in 1997 by  and .<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> It was designed specifically to rectify most of the flaws found in older PRNGs. It was the first PRNG to provide fast generation of high-quality pseudorandom integers.</p>

<p>The most commonly-used version of the Mersenne Twister algorithm is based on the Mersenne prime 2<sup>19937</sup>âˆ’1. The standard implementation of that, MT19937, uses a 32-bit word length. There is another implementation that uses a 64-bit word length, MT19937-64; it generates a different sequence.</p>
<h2 id="adoption-in-software-systems">Adoption in software systems</h2>

<p>The Mersenne Twister is the default PRNG for the following software systems: <a href="R_(programming_language)" title="wikilink">R</a>,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> <a href="Python_(programming_language)" title="wikilink">Python</a>,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> <a href="Ruby_(programming_language)" title="wikilink">Ruby</a>,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> <a class="uri" href="PHP" title="wikilink">PHP</a>,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> <a href="CMU_Common_Lisp" title="wikilink">CMU Common Lisp</a>,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> <a href="Steel_Bank_Common_Lisp" title="wikilink">Steel Bank Common Lisp</a>,<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> <a href="Free_Pascal" title="wikilink">Free Pascal</a>,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> <a class="uri" href="GLib" title="wikilink">GLib</a>,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> <a class="uri" href="SageMath" title="wikilink">SageMath</a>,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> <a href="Maple_(software)" title="wikilink">Maple</a>,<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> <a class="uri" href="MATLAB" title="wikilink">MATLAB</a>,<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> <a href="GAUSS_(software)" title="wikilink">GAUSS</a>,<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> <a href="IDL_(programming_language)" title="wikilink">IDL</a>,<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> <a href="Julia_(programming_language)" title="wikilink">Julia</a>,<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> <a class="uri" href="Scilab" title="wikilink">Scilab</a>,<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> <a href="GNU_Octave" title="wikilink">GNU Octave</a>,<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> the <a href="GNU_Scientific_Library" title="wikilink">GNU Scientific Library</a>,<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> the <a href="GNU_Multiple_Precision_Arithmetic_Library" title="wikilink">GNU Multiple Precision Arithmetic Library</a>,<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> and <a href="Microsoft_Visual_C++" title="wikilink">Microsoft Visual C++</a>.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> It is also available in standard <a class="uri" href="C++" title="wikilink">C++</a> (since <a class="uri" href="C++11" title="wikilink">C++11</a>)<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a><a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> and <a href="Apache_HTTP_Server" title="wikilink">Apache</a>.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> Add-on implementations are provided in many program libraries, including the <a href="Boost_(C++_libraries)" title="wikilink">Boost C++ Libraries</a><a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> and the <a href="NAG_Numerical_Library" title="wikilink">NAG Numerical Library</a>.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>

<p>The Mersenne Twister is one of two PRNGs in <a class="uri" href="SPSS" title="wikilink">SPSS</a>: the other generator is kept only for compatibility with older programs, and the Mersenne Twister is stated to be "more reliable".<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> The Mersenne Twister is similarly one of the PRNGs in <a href="SAS_(software)" title="wikilink">SAS</a>: the other generators are older and deprecated.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>
<h2 id="advantages">Advantages</h2>

<p>The commonly-used version of Mersenne Twister, MT19937, which produces a sequence of 32-bit integers, has the following desirable properties:</p>
<ol>
<li>It has a very long period of 2<sup>19937</sup>Â âˆ’Â 1. While a long period is not a guarantee of quality in a random number generator, short periods (such as the 2<sup>32</sup> common in many older software packages) can be problematic.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a></li>
<li>It is <em>k</em>-distributed to 32-bit accuracy for every 1 â‰¤ <em>k</em> â‰¤ 623 (see definition below).</li>
<li>It passes numerous tests for statistical randomness, including the <a href="Diehard_tests" title="wikilink">Diehard tests</a>.</li>
</ol>
<h2 id="disadvantages">Disadvantages</h2>

<p>The state space is very large and may needlessly stress the <a href="CPU_cache" title="wikilink">CPU cache</a> (a period above 2<sup>512</sup> is enough for any application<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a>). In 2011, Saito &amp; Matsumoto proposed a version of the Mersenne Twister to address this issue. The tiny version, TinyMT, uses just 127 bits of state space.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a></p>

<p>By today's standards, the Mersenne Twister is fairly slow, unless the SFMT implementation is used (see section below).</p>

<p>It passes most, but not all, of the stringent <a class="uri" href="TestU01" title="wikilink">TestU01</a> randomness tests.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></p>

<p>Multiple Mersenne Twister instances that differ only in seed value (but not other parameters) are not generally appropriate for Monte-Carlo simulations that require independent random number generators, though there exists a method for choosing multiple sets of parameter values.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a></p>

<p>It can take a long time to start generating output that passes <a href="randomness_tests" title="wikilink">randomness tests</a>, if the initial state is highly non-randomâ€”particularly if the initial state has many zeros. A consequence of this is that two instances of the generator, started with initial states that are almost the same, will usually output nearly the same sequence for many iterations, before eventually diverging. The 2002 update to the MT algorithm has improved initialization, so that reaching such a state is very unlikely.<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a></p>
<h2 id="k-distribution"><em>k</em>-distribution</h2>

<p>A pseudorandom sequence <em>x<sub>i</sub></em> of <em>w</em>-bit integers of period <em>P</em> is said to be <em>k</em>-distributed to <em>v</em>-bit accuracy if the following holds.</p>
<dl>
<dd>Let <em>trunc<sub>v</sub>(x)</em> denote the number formed by the leading <em>v</em> bits of <em>x</em>, and consider <em>P</em> of the <em>kv</em>-bit vectors

<p>

<math display="block" id="Mersenne_Twister:0">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mtext>trunc</mtext>
     <mi>v</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="4.2pt">,</mo>
    <msub>
     <mtext>trunc</mtext>
     <mi>v</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo rspace="4.2pt">,</mo>
    <mi mathvariant="normal">â€¦</mi>
    <mo rspace="4.2pt">,</mo>
    <msub>
     <mtext>trunc</mtext>
     <mi>v</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mrow>
       <mrow>
        <mi>i</mi>
        <mo>+</mo>
        <mi>k</mi>
       </mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>â‰¤</mo>
    <mi>i</mi>
    <mo><</mo>
    <mi>P</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>trunc</mtext>
      <ci>v</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>trunc</mtext>
      <ci>v</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-,</ci>
     <ci>normal-â€¦</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>trunc</mtext>
      <ci>v</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <apply>
         <plus></plus>
         <ci>i</ci>
         <ci>k</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci></ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">0</cn>
     <leq></leq>
     <csymbol cd="unknown">i</csymbol>
     <lt></lt>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\text{trunc}_{v}(x_{i}),\,\text{trunc}_{v}(x_{i+1}),\,...,\,\text{trunc}_{v}(%
x_{i+k-1}))\quad(0\leq i<P)
  </annotation>
 </semantics>
</math>

.</p>
</dd>
<dd>Then each of the 2<sup><em>kv</em></sup> possible combinations of bits occurs the same number of times in a period, except for the all-zero combination that occurs once less often.
</dd>
</dl>
<h2 id="alternatives">Alternatives</h2>

<p>The algorithm in its native form is not <a href="CSPRNG" title="wikilink">cryptographically secure</a>. The reason is that observing a sufficient number of iterations (624 in the case of MT19937, since this is the size of the state vector from which future iterations are produced) allows one to predict all future iterations.</p>

<p>A pair of cryptographic stream ciphers based on output from the Mersenne Twister has been proposed by Matsumoto, Nishimura, and co-authors. The authors claim speeds 1.5 to 2 times faster than <a href="Advanced_Encryption_Standard" title="wikilink">Advanced Encryption Standard</a> in <a href="counter_mode" title="wikilink">counter mode</a>.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a></p>

<p>An alternative generator, <a href="Well_Equidistributed_Long-period_Linear" title="wikilink">WELL</a> ("Well Equidistributed Long-period Linear"), offers quicker recovery, and equal randomness, and nearly-equal speed.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> Marsaglia's <a class="uri" href="xorshift" title="wikilink">xorshift</a> generators and variants are the fastest in this class.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a></p>
<h2 id="algorithmic-detail">Algorithmic detail</h2>

<p> For a <em>w</em>-bit word length, the Mersenne Twister generates integers in the range [0, 2<sup><em>w</em></sup>âˆ’1].</p>

<p>The Mersenne Twister algorithm is based on a <a href="Recurrence_relation" title="wikilink">matrix linear recurrence</a> over a finite <a href="binary_numeral_system" title="wikilink">binary</a> <a href="field_(mathematics)" title="wikilink">field</a> <em>F</em><sub>2</sub>. The algorithm is a twisted <a href="generalised_feedback_shift_register" title="wikilink">generalised feedback shift register</a><a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a> (twisted GFSR, or TGFSR) of <a href="rational_normal_form" title="wikilink">rational normal form</a> (TGFSR(R)), with state bit reflection and tempering. The basic idea is to define a series 

<math display="inline" id="Mersenne_Twister:1">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 through a simple recurrence relation, and then output numbers of the form 

<math display="inline" id="Mersenne_Twister:2">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}T
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Mersenne_Twister:3">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is an invertible <em>F</em><sub>2</sub> matrix called a <a href="Tempered_representation" title="wikilink">tempering matrix</a>.</p>

<p>The general algorithm is characterized by the following quantities: (some of these explanations make sense only after reading the rest of the algorithm)</p>
<ul>
<li><em>w</em>: word size (in number of bits)</li>
<li><em>n</em>: degree of recurrence</li>
<li><em>m</em>: middle word, an offset used in the recurrence relation defining the series <strong><em>x</em></strong>, 1 â‰¤ <em>m</em> &lt; <em>n</em></li>
<li><em>r</em>: separation point of one word, or the number of bits of the lower bitmask, 0 â‰¤ <em>r</em> â‰¤ <em>w</em> - 1</li>
<li><em>a</em>: coefficients of the rational normal form twist matrix</li>
<li><em>b</em>, <em>c</em>: TGFSR(R) tempering bitmasks</li>
<li><em>s</em>, <em>t</em>: TGFSR(R) tempering bit shifts</li>
<li><em>u</em>, <em>d</em>, <em>l</em>: additional Mersenne Twister tempering bit shifts/masks</li>
</ul>

<p>with the restriction that 2<sup><em>nw</em>Â âˆ’Â <em>r</em></sup>Â âˆ’Â 1 is a Mersenne prime. This choice simplifies the primitivity test and <em>k</em>-distribution test that are needed in the parameter search.</p>

<p>The series <strong><em>x</em></strong> is defined as a series of <em>w</em>-bit quantities with the recurrence relation:</p>

<p>

<math display="block" id="Mersenne_Twister:4">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mi>n</mi>
    </mrow>
   </msub>
   <mo>:=</mo>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mi>m</mi>
    </mrow>
   </msub>
   <mo>âŠ•</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mmultiscripts>
     <mi>x</mi>
     <mi>k</mi>
     <none></none>
     <none></none>
     <mi>u</mi>
    </mmultiscripts>
    <mo>âˆ£</mo>
    <mmultiscripts>
     <mi>x</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <none></none>
     <none></none>
     <mi>l</mi>
    </mmultiscripts>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>A</mi>
   <mi>k</mi>
   <mo>=</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mi mathvariant="normal">â€¦</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <csymbol cd="latexml">direct-sum</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
      <ci>u</ci>
     </apply>
     <ci>normal-âˆ£</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>l</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">A</csymbol>
    <ci>italic-</ci>
    <csymbol cd="unknown">k</csymbol>
    <eq></eq>
    <cn type="integer">0</cn>
    <ci>normal-,</ci>
    <cn type="integer">1</cn>
    <ci>normal-,</ci>
    <ci>normal-â€¦</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+n}:=x_{k+m}\oplus({x_{k}}^{u}\mid{x_{k+1}}^{l})A\qquad\qquad k=0,1,\ldots
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Mersenne_Twister:5">
 <semantics>
  <mo>âˆ£</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-âˆ£</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mid
  </annotation>
 </semantics>
</math>

 denotes the bitwise <a href="Logical_disjunction" title="wikilink">or</a>, 

<math display="inline" id="Mersenne_Twister:6">
 <semantics>
  <mo>âŠ•</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">direct-sum</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \oplus
  </annotation>
 </semantics>
</math>

 the bitwise <a href="exclusive_or" title="wikilink">exclusive or</a> (XOR), 

<math display="inline" id="Mersenne_Twister:7">
 <semantics>
  <mmultiscripts>
   <mi>x</mi>
   <mi>k</mi>
   <none></none>
   <none></none>
   <mi>u</mi>
  </mmultiscripts>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>k</ci>
    </apply>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x_{k}}^{u}
  </annotation>
 </semantics>
</math>

 means the upper 

<math display="inline" id="Mersenne_Twister:8">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>-</mo>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>w</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w-r
  </annotation>
 </semantics>
</math>

 bits of 

<math display="inline" id="Mersenne_Twister:9">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Mersenne_Twister:10">
 <semantics>
  <msubsup>
   <mi>x</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mi>l</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}^{l}
  </annotation>
 </semantics>
</math>

 means the lower 

<math display="inline" id="Mersenne_Twister:11">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 bits of 

<math display="inline" id="Mersenne_Twister:12">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k+1}
  </annotation>
 </semantics>
</math>

. The twist transformation <em>A</em> is defined in rational normal form as:</p>

<p>

<math display="inline" id="Mersenne_Twister:13">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <msub>
        <mi>I</mi>
        <mrow>
         <mi>w</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>a</mi>
        <mrow>
         <mi>w</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>a</mi>
         <mrow>
          <mi>w</mi>
          <mo>-</mo>
          <mn>2</mn>
         </mrow>
        </msub>
        <mo>,</mo>
        <mi mathvariant="normal">â€¦</mi>
        <mo>,</mo>
        <msub>
         <mi>a</mi>
         <mn>0</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <apply>
        <minus></minus>
        <ci>w</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <ci>w</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <apply>
         <minus></minus>
         <ci>w</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>normal-â€¦</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">0</cn>
       </apply>
      </vector>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\begin{pmatrix}0&I_{w-1}\\
a_{w-1}&(a_{w-2},\ldots,a_{0})\end{pmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>with <em>I</em><sub><em>n</em>Â âˆ’Â 1</sub> as the (<em>n</em>Â âˆ’Â 1)Â Ã—Â (<em>n</em>Â âˆ’Â 1) identity matrix. The rational normal form has the benefit that multiplication by <em>A</em> can be efficiently expressed as: (remember that here matrix multiplication is being done in <em>F</em><sub>2</sub>, and therefore bitwise XOR takes the place of addition)</p>

<p>

<math display="inline" id="Mersenne_Twister:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>ğ’™</mi>
    <mi>A</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>ğ’™</mi>
        <mo>â‰«</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <msub>
         <mi>x</mi>
         <mn>0</mn>
        </msub>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>ğ’™</mi>
         <mo>â‰«</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo>âŠ•</mo>
        <mi>ğ’‚</mi>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <msub>
         <mi>x</mi>
         <mn>0</mn>
        </msub>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ğ’™</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <csymbol cd="latexml">much-greater-than</csymbol>
      <ci>ğ’™</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <csymbol cd="latexml">much-greater-than</csymbol>
       <cn type="integer">1</cn>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="latexml">direct-sum</csymbol>
      <csymbol cd="unknown">a</csymbol>
     </cerror>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{x}A=\begin{cases}\boldsymbol{x}\gg 1&x_{0}=0\\
(\boldsymbol{x}\gg 1)\oplus\boldsymbol{a}&x_{0}=1\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>x</em><sub>0</sub> is the lowest order bit of <em>x</em>.</p>

<p>As like TGFSR(R), the Mersenne Twister is cascaded with a <a href="Tempered_representation" title="wikilink">tempering transform</a> to compensate for the reduced dimensionality of equidistribution (because of the choice of <em>A</em> being in the rational normal form). Note that this is equivalent to using the matrix <em>A'</em> where <em>A'</em>Â =Â <em>T</em><sup>âˆ’1</sup><em>AT</em> for <em>T</em> an invertible matrix, and therefore the analysis of characteristic polynomial mentioned below still holds.</p>

<p>As with <em>A</em>, we choose a tempering transform to be easily computable, and so do not actually construct <em>T</em> itself. The tempering is defined in the case of Mersenne Twister as</p>
<dl>
<dd><strong><em>y</em></strong> := <strong><em>x<strong><em>Â âŠ•Â ((</em></strong>x<strong><em>Â &gt;&gt;Â </em>u<em>)Â &amp;Â </em></strong>d</em></strong>)
</dd>
<dd><strong><em>y</em></strong> := <strong><em>y<strong><em>Â âŠ•Â ((</em></strong>y<strong><em>Â &lt;&lt;Â </em>s<em>)Â &amp;Â </em></strong>b</em></strong>)
</dd>
<dd><strong><em>y</em></strong> := <strong><em>y<strong><em>Â âŠ•Â ((</em></strong>y<strong><em>Â &lt;&lt;Â </em>t<em>)Â &amp;Â </em></strong>c</em></strong>)
</dd>
<dd><strong><em>z</em></strong> := <strong><em>y<strong><em>Â âŠ•Â (</em></strong>y</em></strong>Â &gt;&gt;Â <em>l</em>)
</dd>
</dl>

<p>where <strong><em>x</em></strong> is the next value from the series, <strong><em>y</em></strong> a temporary intermediate value, <strong><em>z</em></strong> the value returned from the algorithm, with &gt; as the bitwise left and right shifts, and &amp; as the bitwise <a href="Logical_conjunction" title="wikilink">and</a>. The first and last transforms are added in order to improve lower bit equidistribution. From the property of TGFSR, 

<math display="inline" id="Mersenne_Twister:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mo>+</mo>
    <mi>t</mi>
   </mrow>
   <mo>â‰¥</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">âŒŠ</mo>
     <mrow>
      <mi>w</mi>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
     <mo stretchy="false">âŒ‹</mo>
    </mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <plus></plus>
     <ci>s</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <floor></floor>
      <apply>
       <divide></divide>
       <ci>w</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s+t\geq\lfloor w/2\rfloor-1
  </annotation>
 </semantics>
</math>

 is required to reach the upper bound of equidistribution for the upper bits.</p>

<p>The coefficients for MT19937 are:</p>
<ul>
<li>(<em>w</em>, <em>n</em>, <em>m</em>, <em>r</em>)Â =Â (32, 624, 397, 31)</li>
<li><em>a</em>Â =Â 9908B0DF<sub>16</sub></li>
<li>(<em>u</em>, <em>d</em>)Â =Â (11, FFFFFFFF<sub>16</sub>)</li>
<li>(<em>s</em>, <em>b</em>)Â =Â (7, 9D2C5680<sub>16</sub>)</li>
<li>(<em>t</em>, <em>c</em>)Â =Â (15, EFC60000<sub>16</sub>)</li>
<li><em>l</em>Â =Â 18</li>
</ul>

<p>Note that 32-bit implementations of the Mersenne Twister generally have <em>d</em>Â =Â FFFFFFFF<sub>16</sub>, and therefore the <em>d</em> is occasionally omitted from the algorithm description. (since the bitwise <a href="Logical_conjunction" title="wikilink">and</a> with <em>d</em> is in that case a no-op)</p>

<p>The coefficients for MT19937-64 are:<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a></p>
<ul>
<li>(<em>w</em>, <em>n</em>, <em>m</em>, <em>r</em>)Â =Â (64, 312, 156, 31)</li>
<li><em>a</em>Â =Â B5026F5AA96619E9<sub>16</sub></li>
<li>(<em>u</em>, <em>d</em>)Â =Â (29, 5555555555555555<sub>16</sub>)</li>
<li>(<em>s</em>, <em>b</em>)Â =Â (17, 71D67FFFEDA60000<sub>16</sub>)</li>
<li>(<em>t</em>, <em>c</em>)Â =Â (37, FFF7EEE000000000<sub>16</sub>)</li>
<li><em>l</em>Â =Â 43</li>
</ul>
<h2 id="initialization">Initialization</h2>

<p>As should be apparent from the above description, the state needed for a Mersenne Twister implementation is an array of <em>n</em> values of <em>w</em> bits each. To initialize the array, a <em>w</em>-bit seed value is use to supply <em>x</em><sub>0</sub> through <em>x</em><sub><em>n</em>Â âˆ’Â 1</sub> by setting <em>x</em><sub>0</sub> to the seed value and thereafter setting</p>
<dl>
<dd><em>x</em><sub><em>i</em></sub> = <em>f</em> Ã— (<em>x</em><sub><em>i</em>-1</sub> âŠ• (<em>x</em><sub><em>i</em>-1</sub> &gt;&gt; (<em>w</em>-2))) + <em>i</em>
</dd>
</dl>

<p>for <em>i</em> from 1 to <em>n</em>-1. The first value the algorithm then generates is based on <em>x</em><sub><em>n</em></sub>. The constant <em>f</em> forms another parameter to the generator, though not part of the algorithm proper. The value for <em>f</em> for MT19937 is 1812433253 and for MT19937-64 is 6364136223846793005.<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a></p>
<h2 id="comparison-with-classical-gfsr">Comparison with classical GFSR</h2>

<p>In order to achieve the 2<sup><em>nw</em>Â âˆ’Â <em>r</em></sup>Â âˆ’Â 1 theoretical upper limit of the period in a TGFSR, <em>Ï†</em><sub><em>B</em></sub>(<em>t</em>) must be a <a href="primitive_polynomial_(field_theory)" title="wikilink">primitive polynomial</a>, <em>Ï†</em><sub><em>B</em></sub>(<em>t</em>) being the <a href="characteristic_polynomial" title="wikilink">characteristic polynomial</a> of</p>

<p>

<math display="inline" id="Mersenne_Twister:16">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mtable>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>I</mi>
         <mi>w</mi>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">â‹¯</mi>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi mathvariant="normal">â‹®</mi>
       </mtd>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>I</mi>
         <mi>w</mi>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">â‹®</mi>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">â‹±</mi>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">â‹®</mi>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">â‹®</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi mathvariant="normal">â‹®</mi>
       </mtd>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
       <mtd columnalign="center">
        <mi></mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">â‹¯</mi>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>I</mi>
         <mi>w</mi>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">â‹¯</mi>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>I</mi>
         <mrow>
          <mi>w</mi>
          <mo>-</mo>
          <mi>r</mi>
         </mrow>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi>S</mi>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mi mathvariant="normal">â‹¯</mi>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi></mi>
        <mo>â†</mo>
        <mrow>
         <mi>m</mi>
         <mtext>-th row</mtext>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>B</ci>
    <apply>
     <times></times>
     <matrix>
      <matrixrow>
       <cn type="integer">0</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>I</ci>
        <ci>w</ci>
       </apply>
       <ci>normal-â‹¯</ci>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <ci>normal-â‹®</ci>
       <csymbol cd="latexml">absent</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <csymbol cd="latexml">absent</csymbol>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>I</ci>
        <ci>w</ci>
       </apply>
       <ci>normal-â‹®</ci>
       <ci>normal-â‹±</ci>
       <ci>normal-â‹®</ci>
       <ci>normal-â‹®</ci>
      </matrixrow>
      <matrixrow>
       <ci>normal-â‹®</ci>
       <csymbol cd="latexml">absent</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <csymbol cd="latexml">absent</csymbol>
       <csymbol cd="latexml">absent</csymbol>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <ci>normal-â‹¯</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>I</ci>
        <ci>w</ci>
       </apply>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
       <ci>normal-â‹¯</ci>
       <cn type="integer">0</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>I</ci>
        <apply>
         <minus></minus>
         <ci>w</ci>
         <ci>r</ci>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <ci>S</ci>
       <cn type="integer">0</cn>
       <ci>normal-â‹¯</ci>
       <cn type="integer">0</cn>
       <cn type="integer">0</cn>
      </matrixrow>
     </matrix>
     <matrix>
      <matrixrow>
       <csymbol cd="latexml">absent</csymbol>
      </matrixrow>
      <matrixrow>
       <csymbol cd="latexml">absent</csymbol>
      </matrixrow>
      <matrixrow>
       <apply>
        <ci>normal-â†</ci>
        <csymbol cd="latexml">absent</csymbol>
        <apply>
         <times></times>
         <ci>m</ci>
         <mtext>-th row</mtext>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <csymbol cd="latexml">absent</csymbol>
      </matrixrow>
      <matrixrow>
       <csymbol cd="latexml">absent</csymbol>
      </matrixrow>
      <matrixrow>
       <csymbol cd="latexml">absent</csymbol>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B=\begin{pmatrix}0&I_{w}&\cdots&0&0\\
\vdots&&&&\\
I_{w}&\vdots&\ddots&\vdots&\vdots\\
\vdots&&&&\\
0&0&\cdots&I_{w}&0\\
0&0&\cdots&0&I_{w-r}\\
S&0&\cdots&0&0\end{pmatrix}\begin{matrix}\\
\\
\leftarrow m\hbox{-th row}\\
\\
\\
\\
\end{matrix}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Mersenne_Twister:17">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mtable>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>I</mi>
         <mi>r</mi>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>I</mi>
         <mrow>
          <mi>w</mi>
          <mo>-</mo>
          <mi>r</mi>
         </mrow>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <times></times>
     <matrix>
      <matrixrow>
       <cn type="integer">0</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>I</ci>
        <ci>r</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>I</ci>
        <apply>
         <minus></minus>
         <ci>w</ci>
         <ci>r</ci>
        </apply>
       </apply>
       <cn type="integer">0</cn>
      </matrixrow>
     </matrix>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\begin{pmatrix}0&I_{r}\\
I_{w-r}&0\end{pmatrix}A
  </annotation>
 </semantics>
</math>

</p>

<p>The twist transformation improves the classical GFSR with the following key properties:</p>
<ul>
<li>Period reaches the theoretical upper limit 2<sup><em>nw</em>Â âˆ’Â <em>r</em></sup>Â âˆ’Â 1 (except if initialized with 0)</li>
<li>Equidistribution in <em>n</em> dimensions (e.g. <a href="linear_congruential_generator" title="wikilink">linear congruential generators</a> can at best manage reasonable distribution in 5 dimensions)</li>
</ul>
<h2 id="pseudocode">Pseudocode</h2>

<p>The following piece of <a class="uri" href="pseudocode" title="wikilink">pseudocode</a> implements the general Mersenne Twister algorithm. The constants <strong>w</strong>, <strong>n</strong>, <strong>m</strong>, <strong>r</strong>, <strong>a</strong>, <strong>u</strong>, <strong>d</strong>, <strong>s</strong>, <strong>b</strong>, <strong>t</strong>, <strong>c</strong>, <strong>l</strong>, and <strong>f</strong> are as in the algorithm description above. It is assumed that <strong>int</strong> represents a type sufficient to hold values with <strong>w</strong> bits:</p>

<p><code>Â </code><em><code>//</code> <code>Create</code> <code>a</code> <code>length</code> <strong><code>n</code></strong> <code>array</code> <code>to</code> <code>store</code> <code>the</code> <code>state</code> <code>of</code> <code>the</code> <code>generator</code></em><br/>
<code>Â </code><strong><code>int</code></strong><code>[0..</code><strong><code>n</code></strong><code>-1]Â MT</code><br/>
<code>Â </code><strong><code>int</code></strong><code>Â indexÂ :=Â </code><strong><code>n</code></strong><code>+1</code><br/>
<code>Â </code><strong><code>const</code> <code>int</code></strong><code>Â lower_maskÂ =Â (1Â </code><code>&gt;Â (</code><strong><code>w</code></strong><code>-2)))Â +Â i)</code><br/>
<code>Â Â Â Â Â }</code><br/>
<code>Â }</code><br/>
<code>Â </code><br/>
<code>Â </code><em><code>//</code> <code>Extract</code> <code>a</code> <code>tempered</code> <code>value</code> <code>based</code> <code>on</code> <code>MT[index]</code></em><br/>
<code>Â </code><em><code>//</code> <code>calling</code> <code>twist()</code> <code>every</code> <strong><code>n</code></strong> <code>numbers</code></em><br/>
<code>Â </code><strong><code>function</code></strong><code>Â extract_number()Â {</code><br/>
<code>Â Â Â Â Â </code><strong><code>if</code></strong><code>Â indexÂ &gt;=Â </code><strong><code>n</code></strong><code>Â {</code><br/>
<code>Â Â Â Â Â Â Â Â Â </code><strong><code>if</code></strong><code>Â indexÂ &gt;Â </code><strong><code>n</code></strong><code>Â {</code><br/>
<code>Â Â Â Â Â Â Â Â Â Â Â </code><strong><code>error</code></strong><code>Â "GeneratorÂ wasÂ neverÂ seeded"</code><br/>
<code>Â Â Â Â Â Â Â Â Â Â Â </code><em><code>//</code> <code>Alternatively,</code> <code>seed</code> <code>with</code> <code>constant</code> <code>value;</code> <code>5489</code> <code>is</code> <code>used</code> <code>in</code> <code>reference</code> <code>C</code> <code>code</code><a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a></em><br/>
<code>Â Â Â Â Â Â Â Â Â }</code><br/>
<code>Â Â Â Â Â Â Â Â Â twist()</code><br/>
<code>Â Â Â Â Â }</code><br/>
<code>Â </code><br/>
<code>Â Â Â Â Â </code><strong><code>int</code></strong><code>Â yÂ :=Â MT[index]</code><br/>
<code>Â Â Â Â Â yÂ :=Â yÂ </code><strong><a href="Bitwise_operation#XOR" title="wikilink"><code>xor</code></a></strong><code>Â ((yÂ &gt;&gt;Â </code><strong><code>u</code></strong><code>)Â </code><strong><a href="Bitwise_operation#AND" title="wikilink"><code>and</code></a></strong><code>Â </code><strong><code>d</code></strong><code>)</code><br/>
<code>Â Â Â Â Â yÂ :=Â yÂ </code><strong><a href="Bitwise_operation#XOR" title="wikilink"><code>xor</code></a></strong><code>Â ((yÂ </code><code>&gt;Â </code><strong><code>l</code></strong><code>)</code><br/>
<br/>
<code>Â Â Â Â Â indexÂ :=Â indexÂ +Â 1</code><br/>
<code>Â Â Â Â Â </code><strong><code>return</code></strong><code>Â lowestÂ </code><strong><code>w</code></strong><code>Â bitsÂ ofÂ (y)</code><br/>
<code>Â }</code><br/>
<code>Â </code><br/>
<code>Â ''//Â GenerateÂ theÂ nextÂ </code><em><code>n</code></em><code>Â valuesÂ fromÂ theÂ seriesÂ x_iÂ ''</code><br/>
<code>Â </code><strong><code>function</code></strong><code>Â twist()Â {</code><br/>
<code>Â Â Â Â Â </code><strong><code>for</code></strong><code>Â iÂ </code><strong><code>from</code></strong><code>Â 0Â </code><strong><code>to</code></strong><code>Â (</code><strong><code>n</code></strong><code>-1)Â {</code><br/>
<code>Â Â Â Â Â Â Â Â Â </code><strong><code>int</code></strong><code>Â xÂ :=Â (MT[i]Â </code><strong><a href="Bitwise_operation#AND" title="wikilink"><code>and</code></a></strong><code>Â upper_mask)</code><br/>
<code>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â +Â (MT[(i+1)Â </code><strong><a href="modulo_operation" title="wikilink"><code>mod</code></a></strong><code>Â </code><strong><code>n</code></strong><code>]Â </code><strong><a href="Bitwise_operation#AND" title="wikilink"><code>and</code></a></strong><code>Â lower_mask)</code><br/>
<code>Â Â Â Â Â Â Â Â Â </code><strong><code>int</code></strong><code>Â xAÂ :=Â xÂ &gt;&gt;Â 1</code><br/>
<code>Â Â Â Â Â Â Â Â Â </code><strong><code>if</code></strong><code>Â (xÂ </code><strong><a href="modulo_operation" title="wikilink"><code>mod</code></a></strong><code>Â 2)Â !=Â 0Â {Â </code><em><code>//</code> <code>lowest</code> <code>bit</code> <code>of</code> <code>x</code> <code>is</code> <code>1</code></em><br/>
<code>Â Â Â Â Â Â Â Â Â Â Â Â Â xAÂ :=Â xAÂ </code><strong><a href="Bitwise_operation#XOR" title="wikilink"><code>xor</code></a></strong><code>Â </code><strong><code>a</code></strong><br/>
<code>Â Â Â Â Â Â Â Â Â }</code><br/>
<code>Â Â Â Â Â Â Â Â Â MT[i]Â :=Â MT[(iÂ +Â </code><strong><code>m</code></strong><code>)Â </code><strong><a href="modulo_operation" title="wikilink"><code>mod</code></a></strong><code>Â </code><strong><code>n</code></strong><code>]Â </code><strong><a href="Bitwise_operation#XOR" title="wikilink"><code>xor</code></a></strong><code>Â xA</code><br/>
<code>Â Â Â Â Â }</code><br/>
<code>Â Â Â Â Â indexÂ :=Â 0</code><br/>
<code>Â }</code></p>
<h3 id="python-implementation">Python Implementation</h3>

<p>This python implementation hard-codes the constants for MT19937:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> _int32(x):
    <span class="co"># Get the 32 least significant bits.</span>
    <span class="cf">return</span> <span class="bu">int</span>(<span class="bn">0xFFFFFFFF</span> <span class="op">&amp;</span> x)

<span class="kw">class</span> MT19937:

    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, seed):
        <span class="co"># Initialize the index to 0</span>
        <span class="va">self</span>.index <span class="op">=</span> <span class="dv">624</span>
        <span class="va">self</span>.mt <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> <span class="dv">624</span>
        <span class="va">self</span>.mt[<span class="dv">0</span>] <span class="op">=</span> seed  <span class="co"># Initialize the initial state to the seed</span>
        <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">624</span>):
            <span class="va">self</span>.mt[i] <span class="op">=</span> _int32(
                <span class="dv">1812433253</span> <span class="op">*</span> (<span class="va">self</span>.mt[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">^</span> <span class="va">self</span>.mt[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">&gt;&gt;</span> <span class="dv">30</span>) <span class="op">+</span> i)

    <span class="kw">def</span> extract_number(<span class="va">self</span>):
        <span class="cf">if</span> <span class="va">self</span>.index <span class="op">&gt;=</span> <span class="dv">624</span>:
            <span class="va">self</span>.twist()

        y <span class="op">=</span> <span class="va">self</span>.mt[<span class="va">self</span>.index]

        <span class="co"># Right shift by 11 bits</span>
        y <span class="op">=</span> y <span class="op">^</span> y <span class="op">&gt;&gt;</span> <span class="dv">11</span>
        <span class="co"># Shift y left by 7 and take the bitwise and of 2636928640</span>
        y <span class="op">=</span> y <span class="op">^</span> y <span class="op">&lt;&lt;</span> <span class="dv">7</span> <span class="op">&amp;</span> <span class="dv">2636928640</span>
        <span class="co"># Shift y left by 15 and take the bitwise and of y and 4022730752</span>
        y <span class="op">=</span> y <span class="op">^</span> y <span class="op">&lt;&lt;</span> <span class="dv">15</span> <span class="op">&amp;</span> <span class="dv">4022730752</span>
        <span class="co"># Right shift by 18 bits</span>
        y <span class="op">=</span> y <span class="op">^</span> y <span class="op">&gt;&gt;</span> <span class="dv">18</span>

        <span class="va">self</span>.index <span class="op">=</span> <span class="va">self</span>.index <span class="op">+</span> <span class="dv">1</span>

        <span class="cf">return</span> _int32(y)

    <span class="kw">def</span> twist(<span class="va">self</span>):
        <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">624</span>):
            <span class="co"># Get the most significant bit and add it to the less significant</span>
            <span class="co"># bits of the next number</span>
            y <span class="op">=</span> _int32((<span class="va">self</span>.mt[i] <span class="op">&amp;</span> <span class="bn">0x80000000</span>) <span class="op">+</span>
                       (<span class="va">self</span>.mt[(i <span class="op">+</span> <span class="dv">1</span>) <span class="op">%</span> <span class="dv">624</span>] <span class="op">&amp;</span> <span class="bn">0x7fffffff</span>))
            <span class="va">self</span>.mt[i] <span class="op">=</span> <span class="va">self</span>.mt[(i <span class="op">+</span> <span class="dv">397</span>) <span class="op">%</span> <span class="dv">624</span>] <span class="op">^</span> y <span class="op">&gt;&gt;</span> <span class="dv">1</span>

            <span class="cf">if</span> y <span class="op">%</span> <span class="dv">2</span> <span class="op">!=</span> <span class="dv">0</span>:
                <span class="va">self</span>.mt[i] <span class="op">=</span> <span class="va">self</span>.mt[i] <span class="op">^</span> <span class="bn">0x9908b0df</span>
        <span class="va">self</span>.index <span class="op">=</span> <span class="dv">0</span></code></pre></div>
<h2 id="sfmt">SFMT</h2>

<p>SFMT, the <a href="Single_instruction,_multiple_data" title="wikilink">Single instruction, multiple data</a>-oriented Fast Mersenne Twister, is a variant of Mersenne Twister, introduced in 2006,<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> designed to be fast when it runs on 128-bit SIMD.</p>
<ul>
<li>It is roughly twice as fast as Mersenne Twister.<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a></li>
<li>It has a better <a class="uri" href="equidistribution" title="wikilink">equidistribution</a> property of v-bit accuracy than MT but worse than <a href="Well_Equidistributed_Long-period_Linear" title="wikilink">WELL ("Well Equidistributed Long-period Linear")</a>.</li>
<li>It has quicker recovery from zero-excess initial state than MT, but slower than WELL.</li>
<li>It supports various periods from 2<sup>607</sup>âˆ’1 to 2<sup>216091</sup>âˆ’1.</li>
</ul>

<p>Intel <a class="uri" href="SSE2" title="wikilink">SSE2</a> and <a class="uri" href="PowerPC" title="wikilink">PowerPC</a> AltiVec are supported by SFMT. It is also used for games with the <a href="Cell_(microprocessor)" title="wikilink">Cell BE</a> in the <a href="PlayStation_3" title="wikilink">PlayStation 3</a>.<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a></p>
<h2 id="mtgp">MTGP</h2>

<p>MTGP is a variant of Mersenne Twister optimised for <a href="graphics_processing_unit" title="wikilink">graphics processing units</a> published by Mutsuo Saito and Makoto Matsumoto.<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a> The basic linear recurrence operations are extended from MT and parameters are chosen to allow many threads to compute the recursion in parallel, while sharing their state space to reduce memory load. The paper claims improved <a class="uri" href="equidistribution" title="wikilink">equidistribution</a> over MT and performance on a high specification GPU (<a class="uri" href="Nvidia" title="wikilink">Nvidia</a> GTX260 with 192 cores) of 4.7ms for 5x10<sup>7</sup> random 32-bit integers.</p>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/earticles.html">The academic paper for MT, and related articles by Makoto Matsumoto</a></li>
<li><a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html">Mersenne Twister home page, with codes in C, Fortran, Java, Lisp and some other languages</a></li>
<li><a href="http://www.codeproject.com/KB/DLL/SFMT_dll.aspx?msg=3130186">SFMT in Action</a> â€”<a href="The_Code_Project" title="wikilink">The Code Project</a></li>
</ul>

<p>"</p>

<p><a href="Category:Pseudorandom_number_generators" title="wikilink">Category:Pseudorandom number generators</a> <a href="Category:Articles_with_example_pseudocode" title="wikilink">Category:Articles with example pseudocode</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">E.g. Marsland S. (2011) <em>Machine Learning</em> (<a href="CRC_Press" title="wikilink">CRC Press</a>), Â§4.1.1. Also see the section "Adoption in software systems".<a href="#fnref1">â†©</a></li>
<li id="fn2"><a href="#fnref2">â†©</a></li>
<li id="fn3"><a href="#fnref3">â†©</a></li>
<li id="fn4"><a href="#fnref4">â†©</a></li>
<li id="fn5"><a href="#fnref5">â†©</a></li>
<li id="fn6"><a href="#fnref6">â†©</a></li>
<li id="fn7"><a href="#fnref7">â†©</a></li>
<li id="fn8"><a href="#fnref8">â†©</a></li>
<li id="fn9"><a href="#fnref9">â†©</a></li>
<li id="fn10"><a href="#fnref10">â†©</a></li>
<li id="fn11"><a href="https://developer.gnome.org/glib/stable/glib-Random-Numbers.html">Random Numbers</a> â€”GLib Reference Manual<a href="#fnref11">â†©</a></li>
<li id="fn12"><a href="http://doc.sagemath.org/html/en/reference/probability/sage/gsl/probability_distribution.html">Probability Distributions</a> â€”Sage Reference Manual<a href="#fnref12">â†©</a></li>
<li id="fn13"><a href="#fnref13">â†©</a></li>
<li id="fn14"><a href="http://www.mathworks.co.uk/help/matlab/ref/randstream.list.html">Random number generator algorithms</a> â€”Documentation Center, <a class="uri" href="MathWorks" title="wikilink">MathWorks</a><a href="#fnref14">â†©</a></li>
<li id="fn15"><a href="http://www.aptech.com/wp-content/uploads/2014/01/GAUSS14_LR.pdf">GAUSS 14 Language Reference</a><a href="#fnref15">â†©</a></li>
<li id="fn16"><a href="#fnref16">â†©</a></li>
<li id="fn17"><a href="http://julia.readthedocs.org/en/latest/stdlib/numbers/#random-numbers">Julia Language Documentation â€” The Standard Library</a><a href="#fnref17">â†©</a></li>
<li id="fn18"><a href="https://help.scilab.org/docs/5.5.2/en_US/grand.html">Random numbers</a> â€”Scilab Help<a href="#fnref18">â†©</a></li>
<li id="fn19"><a href="https://www.gnu.org/software/octave/doc/interpreter/Special-Utility-Matrices.html">GNU Octave: Â§16.3</a> â€”Built-in Function: rand<a href="#fnref19">â†©</a></li>
<li id="fn20"><a href="#fnref20">â†©</a></li>
<li id="fn21"><a href="#fnref21">â†©</a></li>
<li id="fn22"><a href="http://msdn.microsoft.com/en-us/library/bb982398.aspx"><random></random></a> â€”<a href="Microsoft_Developer_Network" title="wikilink">Microsoft Developer Network</a><a href="#fnref22">â†©</a></li>
<li id="fn23"><a href="https://isocpp.org/files/papers/n3551.pdf">Random Number Generation in C++11</a> â€”Standard C++ Foundation<a href="#fnref23">â†©</a></li>
<li id="fn24"><a href="#fnref24">â†©</a></li>
<li id="fn25"><a href="http://commons.apache.org/proper/commons-math/userguide/random.html">Data Generation</a> â€”Apache Commons Math User Guide<a href="#fnref25">â†©</a></li>
<li id="fn26"><a href="#fnref26">â†©</a></li>
<li id="fn27"><a href="#fnref27">â†©</a></li>
<li id="fn28"><a href="#fnref28">â†©</a></li>
<li id="fn29"><a href="#fnref29">â†©</a></li>
<li id="fn30">Note: 2<sup>19937</sup> is approximately 4.3Â Ã—Â 10<sup>6001</sup>; this is many orders of magnitude larger than the estimated number of particles in the <a href="observable_universe#Matter_content" title="wikilink">observable universe</a>, which is 10<sup>87</sup>.<a href="#fnref30">â†©</a></li>
<li id="fn31"><em><a href="Numerical_Recipes" title="wikilink">Numerical Recipes</a></em>, Â§7.1.<a href="#fnref31">â†©</a></li>
<li id="fn32"><a class="uri" href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/TINYMT/index.html">http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/TINYMT/index.html</a><a href="#fnref32">â†©</a></li>
<li id="fn33">P. L'Ecuyer and R. Simard, "<a href="http://www.iro.umontreal.ca/~lecuyer/myftp/papers/testu01.pdf">TestU01: "A C library for empirical testing of random number generators</a>", <em><a href="ACM_Transactions_on_Mathematical_Software" title="wikilink">ACM Transactions on Mathematical Software</a></em>, 33, 4, Article 22 (August 2007).<a href="#fnref33">â†©</a></li>
<li id="fn34"><a href="#fnref34">â†©</a></li>
<li id="fn35"><a class="uri" href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html">http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html</a><a href="#fnref35">â†©</a></li>
<li id="fn36"><a href="#fnref36">â†©</a></li>
<li id="fn37">P. L'Ecuyer, "Uniform Random Number Generators", <em><a href="International_Encyclopedia_of_Statistical_Science" title="wikilink">International Encyclopedia of Statistical Science</a></em>, Lovric, Miodrag (Ed.), Springer-Verlag, 2010.<a href="#fnref37">â†©</a></li>
<li id="fn38"><a href="#fnref38">â†©</a></li>
<li id="fn39"><a href="#fnref39">â†©</a></li>
<li id="fn40"><a href="#fnref40">â†©</a></li>
<li id="fn41"><a href="#fnref41">â†©</a></li>
<li id="fn42"><a href="#fnref42">â†©</a></li>
<li id="fn43"><a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/index.html">SIMD-oriented Fast Mersenne Twister (SFMT)</a><a href="#fnref43">â†©</a></li>
<li id="fn44"><a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/speed.html">SFMT:Comparison of speed</a><a href="#fnref44">â†©</a></li>
<li id="fn45"><a href="http://www.scei.co.jp/ps3-license/index.html">PLAYSTATION 3 License</a><a href="#fnref45">â†©</a></li>
<li id="fn46"><a href="#fnref46">â†©</a></li>
</ol>
</section>
</body>

