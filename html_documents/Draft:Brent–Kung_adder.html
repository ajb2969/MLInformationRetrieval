<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1212">Draft:Brent–Kung adder</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Draft:Brent–Kung adder</h1>
<hr/>

<p><mtpl></mtpl> </p>
<hr/>

<p>Adder in literal terms means a device which adds two number.A device which can tell 5 + 3 is 8. Similarly In electronics, an adder is a device which adds two number. the difference however lies in the type of number. When we come to electronics and specially to Digital electronics the numbers we are left with are 0 and 1 or commonly known as binary digits or Bits. This adder which we discuss here will add bits based on various techniques.In this article length of a numbers to be added is mentioned as 'n'.Having the basic knowledge of binary addition that<br/>
0+0=0<br/>
0+1=1<br/>
1+0=0<br/>
1+1=10 (where 1 is carry)<br/>
</p>

<p>An <a href="adder_(electronics)" title="wikilink">adder</a> is a combinatorial or sequential logic element which computes the (n+1)-bit sum of two n-bit numbers. Adders are very important in a VLSI world as they are used to perform Multiple functions in a processor chip.Research is on to find an adder which occupies lesser area, takes less time and use less power. The <strong>Brent–Kung adder</strong> proposed in 1982<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> is one of the most advanced designs, having a gate level depth of 

<math display="inline" id="Draft:Brent–Kung_adder:0">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>l</mi>
     <mi>o</mi>
     <msub>
      <mi>g</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(log_{2}(n))
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="introduction">Introduction</h2>

<p>The Brent–Kung adder is a parallel prefix form of <a href="carry_look-ahead_adder" title="wikilink">carry look-ahead adder</a>. It takes less area to implement than the <a href="Kogge-Stone_adder" title="wikilink">Kogge-Stone adder</a> and has less wiring congestion, but and is much quicker than Ripple carry Adder (RCA). It was proposed by Richard P. Brent and H. T. Kung in 1982 which introduces more regularity in the structure of adder leading to better performance and lower chip area .</p>

<p>Ripple carry adders were the Initial multi-bit adders which was developed in early days and got its name from the ripple effect which the carry make while moving from right to left. the carry is generated initially in the right then is propagated to left. So the time taken for addition is directly proportional to the length of the bit being added.This is reverse of Brent-kung Adder where the carry are calculated in parallel thus reducing the addition time drastically.Further the work has been done on Brent-kung adder and other parallel adders to reduce the power consumption, area and increase the speed thus bringing them in a low power category.</p>

<p>Brent-kung adder is a parallel adder made in regular layout with an aim of minimizing the chip area and ease of manufacturing. The addition of n-bit number can be performed in time 

<math display="inline" id="Draft:Brent–Kung_adder:1">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>l</mi>
     <mi>o</mi>
     <msub>
      <mi>g</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(log_{2}(n))
  </annotation>
 </semantics>
</math>

 with a chip size of area 

<math display="inline" id="Draft:Brent–Kung_adder:2">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>n</mi>
      <mo>*</mo>
      <mi>l</mi>
     </mrow>
     <mi>o</mi>
     <msub>
      <mi>g</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>l</ci>
     </apply>
     <ci>o</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n*log_{2}(n))
  </annotation>
 </semantics>
</math>

, thus making it a first adder made with a constraint on area and maximizing the performance.Its symmetry and regular fashion built up reduces its cost of production effectively and enable it to be used in pipeline fashion. In parallel adders the critical path is decided by computation of carry from Least Significant Bit adder to the Most Significant Bit adder, therefore efforts are in reducing the critical path for the carry to reach MSB.</p>

<p>Further the work has been done on Brent-kung adder and other parallel adders to reduce the power consumption, area and increase the speed thus bringing them in a low power category and appealing for Usage.</p>
<h2 id="basic-model-outline">Basic Model Outline</h2>

<p>In general, most of the adders, use carry in and the corresponding bits of two numbers (A and B) to get the corresponding sum bit and carry out.With ripple carry adder (RCA)taking 

<math display="inline" id="Draft:Brent–Kung_adder:3">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 time for carry to reach MSB.</p>
<ul>
<li>Let us consider<br/>
<big>A = a<sub>n</sub>a<sub>n-1</sub>....a<sub>1</sub></big> and <big>B = b<sub>n</sub>b<sub>n-1</sub>....b<sub>1</sub></big> both be n-bit binary numbers.<br/>
<br/>
</li>
</ul>
<ul>
<li>Let there Sum be<br/>
<big>S = s<sub>n+1</sub>s<sub>n</sub>....s<sub>1</sub></big> and carry generated in each stage is <big>C=c<sub>n</sub>....c<sub>0</sub></big> will be carry in to next stages.<br/>
<br/>
</li>
<li>For RCA, <big>c<sub>0</sub>=0,</big> and <em>i</em> th sum bit and carry bit generated are <big>c<sub>i</sub>=g<sub>i</sub>∨(a<sub>i</sub>)∨(a<sub>i</sub>∧c<sub>i-1</sub>)∨(b<sub>i</sub>∧c<sub>i-1</sub>),<br/>
s<sub>i</sub>=a<sub>i</sub>⊕b<sub>i</sub>⊕c<sub>i-1</sub> for ''i ''=1,2,....n<br/>
s<sub>n+1</sub>=c<sub>n</sub></big> respectively.<br/>
<br/>
</li>
<li>It is possible to transform the above Ripple Carry into Carry look ahead(CLA) by defining <em>i</em> th carry bit as <big>c<sub>0</sub>=0,<br/>
c<sub>i</sub>=(g<sub>i</sub>∧b<sub>i</sub>)∨(p<sub>i</sub>∧c<sub>i-1</sub>)</big> where<br/>
<big>g<sub>i</sub>=a<sub>i</sub>∧b<sub>i</sub></big> and <big>p<sub>i</sub>=a<sub>i</sub>⊕b<sub>i</sub></big> for i=1,2,....,n. p and g are known as carry propagate and carry generate.This corresponds to the fact that the carry c<sub>i</sub> is either generated by a<sub>i</sub> and b<sub>i</sub> or propagated from the previous carry c<sub>i-1</sub>.<br/>
</li>
</ul>

<p>Brent and Kung in [1] further transform carry generation and propagation by defining an operator <big><strong>o</strong></big> as<br/>
<big>(a<sub>1</sub>,b<sub>1</sub>)<em>o</em>(a<sub>2</sub>,b<sub>2</sub>)=(a<sub>1</sub>∨(b<sub>1</sub>∧a<sub>2</sub>),b<sub>1</sub>∧b<sub>2</sub>)</big>.</p>
<ul>
<li>They also define a function (G<sub>i</sub>,P<sub>i</sub>)=(g<sub>1</sub>,p<sub>1</sub>) for i=1;<br/>
otherwise(gi,pi)o(Gi-1,Pi-1)   for <big>i=2,3,....n.</big> It can be derived that <big>G<sub>i</sub></big> in the function is equivalent to <big>c<sub>i</sub></big>. Also <big>(G<sub>n</sub>,P<sub>n</sub>)</big> can be non recursively written as <big>=(g<sub>n</sub>,p<sub>n</sub>)o(g<sub>n-1</sub>,p<sub>n-1</sub>)o.....o(g<sub>1</sub>,p<sub>1</sub>).</big></li>
</ul>

<p>Taking advantage of associativity of operator <big>'o'</big> <big>(G<sub>n</sub>,P<sub>n</sub>)</big> can be computed in a tree like manner as shown in figure from [1].</p>

<p>The design of the white nodes above is trivial as they are just buffering the g<sub>i</sub>'s and p<sub>i</sub>'s, and the black nodes are performing operation defined by operator <big>o</big> which is similar to one bit adder.</p>
<ul>
<li>This tree like propagation of carry reduces its critical path to that of tree height.As the carry tree height can be maximum of 

<math display="inline" id="Draft:Brent–Kung_adder:4">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>l</mi>
     <mi>o</mi>
     <msub>
      <mi>g</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(log_{2}(n))
  </annotation>
 </semantics>
</math>

, The critical path of the Brent-Kung parallel adder is also 

<math display="inline" id="Draft:Brent–Kung_adder:5">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>l</mi>
     <mi>o</mi>
     <msub>
      <mi>g</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(log_{2}(n))
  </annotation>
 </semantics>
</math>

 which is better than normal adder performance of 

<math display="inline" id="Draft:Brent–Kung_adder:6">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

.The tree base layout also reduces the chip area and redundant wiring required in general CLA based adders.</li>
</ul>
<h2 id="final-processing-stage">Final Processing Stage</h2>

<p>Using the Carry propagation and generation transformation for working out addition and carry used by Brent and Kung, the performance of the adder increases considerably and also leading to increase in regularity. The Final sum can be calculated as follows: si=pi⊕ci-1</p>
<h2 id="low-power-adders">Low Power Adders</h2>

<p>The increase in performance in Brent-Kung adder is attributed to its tree structure of carry propagation which also lead to lower power consumption as carry signal now has to travel through less number of stages leading to lower switching of transistors. Also the decrease in amount of wiring and fan-out also contributes largely to its lower power consumption than CLA adders. A Brent-Kung adder can also be used in a pipeline manner which can further reduce power consumption by reducing the depth of combinatorial logic and glitches stabilization<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a>. The graph on right shows a low-power Brent-Kung adder<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a>.</p>
<h2 id="comparison-with-kogge-stone-adders">Comparison with Kogge-Stone Adders</h2>
<h3 id="advantages">Advantages</h3>

<p>Due to this type of adder requiring less modules to implement than the Kogge-Stone adder, the Brent-Kung adder is much simpler to build. It also contains far fewer connections to other modules, which also contributes to its simplicity.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h3 id="disadvantages">Disadvantages</h3>

<p>One major disadvantage of this adder is <a class="uri" href="fan-out" title="wikilink">fan-out</a>. Fan-out may split and weaken the current propagating through the adder.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.acsel-lab.com/Projects/fast_adder/adder_designs.htm">Adder Designs</a></li>
</ul>

<p><a href=":Category:Adders_(electronics)" title="wikilink">:Category:Adders (electronics)</a>"</p>

<p></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Brent, R. P. &amp; Kung, H. T. <a href="http://dx.doi.org/10.1109/TC.1982.1675982">"A Regular Layout for Parallel Adders"</a>. <em>IEEE Transactions on Computers</em>, 1982, <em>C-31</em>, 260-264<a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
</ol>
</section>
</body>
</html>
