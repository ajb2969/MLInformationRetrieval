<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1913">Post's lattice</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Post's lattice</h1>
<hr/>

<p>In <a class="uri" href="logic" title="wikilink">logic</a> and <a href="universal_algebra" title="wikilink">universal algebra</a>, <strong>Post's lattice</strong> denotes the <a href="lattice_(order)" title="wikilink">lattice</a> of all <a href="clone_(algebra)" title="wikilink">clones</a> on a two-element set {0, 1}, ordered by <a href="inclusion_(set_theory)" title="wikilink">inclusion</a>. It is named for <a href="Emil_Leon_Post" title="wikilink">Emil Post</a>, who published a complete description of the lattice in 1941.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The relative simplicity of Post's lattice is in stark contrast to the lattice of clones on a three-element (or larger) set, which has the <a href="cardinality_of_the_continuum" title="wikilink">cardinality of the continuum</a>, and a complicated inner structure. A modern exposition of Post's result can be found in Lau (2006).<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="basic-concepts">Basic concepts</h2>

<p>A <a href="Boolean_function" title="wikilink">Boolean function</a>, or <a href="logical_connective" title="wikilink">logical connective</a>, is an <em>n</em>-ary <a href="operation_(mathematics)" title="wikilink">operation</a> <mtpl></mtpl> for some , where <strong>2</strong> denotes the two-element set {0, 1}. Particular Boolean functions are the <a href="projection_(set_theory)" title="wikilink">projections</a></p>

<p>

<math display="block" id="Post's_lattice:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mi>π</mi>
      <mi>k</mi>
      <mi>n</mi>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mi>k</mi>
    </msub>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <ci>k</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{k}^{n}(x_{1},\dots,x_{n})=x_{k},
  </annotation>
 </semantics>
</math>

 and given an <em>m</em>-ary function <em>f</em>, and <em>n</em>-ary functions <em>g</em><sub>1</sub>, ..., <em>g</em><sub><em>m</em></sub>, we can construct another <em>n</em>-ary function</p>

<p>

<math display="block" id="Post's_lattice:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>g</mi>
        <mn>1</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mrow>
       <msub>
        <mi>g</mi>
        <mi>m</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <cn type="integer">1</cn>
       </apply>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </vector>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>m</ci>
       </apply>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </vector>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x_{1},\dots,x_{n})=f(g_{1}(x_{1},\dots,x_{n}),\dots,g_{m}(x_{1},\dots,x_{n})),
  </annotation>
 </semantics>
</math>

 called their <a href="function_composition" title="wikilink">composition</a>. A set of functions closed under composition, and containing all projections, is called a <a href="clone_(algebra)" title="wikilink">clone</a>.</p>

<p>Let <em>B</em> be a set of connectives. The functions which can be defined by a <a href="formula_(mathematical_logic)" title="wikilink">formula</a> using <a href="propositional_variable" title="wikilink">propositional variables</a> and connectives from <em>B</em> form a clone [<em>B</em>], indeed it is the smallest clone which includes <em>B</em>. We call [<em>B</em>] the clone <em>generated</em> by <em>B</em>, and say that <em>B</em> is the <em>basis</em> of [<em>B</em>]. For example, [¬, ∧] are all Boolean functions, and [0, 1, ∧, ∨] are the monotone functions.</p>

<p>We use the operations ¬ (<a class="uri" href="negation" title="wikilink">negation</a>), ∧ (<a href="logical_conjunction" title="wikilink">conjunction</a> or <a href="meet_(mathematics)" title="wikilink">meet</a>), ∨ (<a class="uri" href="disjunction" title="wikilink">disjunction</a> or <a href="join_(mathematics)" title="wikilink">join</a>), → (<a href="material_conditional" title="wikilink">implication</a>), ↔ (<a href="logical_biconditional" title="wikilink">biconditional</a>), + (<a href="exclusive_disjunction" title="wikilink">exclusive disjunction</a> or <a href="Boolean_ring" title="wikilink">Boolean ring</a> <a class="uri" href="addition" title="wikilink">addition</a>), ↛ (<a href="material_nonimplication" title="wikilink">nonimplication</a>), ?: (the ternary <a href="?:" title="wikilink">conditional operator</a>) and the constant unary functions 0 and 1. Moreover, we need the <a href="threshold_function" title="wikilink">threshold functions</a></p>

<p>

<math display="block" id="Post's_lattice:2">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>th</mi>
     <mi>k</mi>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mrow>
           <mo fence="true" maxsize="120%" minsize="120%">|</mo>
           <mrow>
            <mo stretchy="false">{</mo>
            <mi>i</mi>
            <mo>∣</mo>
            <mrow>
             <msub>
              <mi>x</mi>
              <mi>i</mi>
             </msub>
             <mo>=</mo>
             <mn>1</mn>
            </mrow>
            <mo stretchy="false">}</mo>
           </mrow>
           <mo fence="true" maxsize="120%" minsize="120%">|</mo>
          </mrow>
         </mrow>
         <mo>≥</mo>
         <mi>k</mi>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise.</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>th</ci>
       <ci>n</ci>
      </apply>
      <ci>k</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <geq></geq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <apply>
        <abs></abs>
        <apply>
         <csymbol cd="latexml">conditional-set</csymbol>
         <ci>i</ci>
         <apply>
          <eq></eq>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>i</ci>
          </apply>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
     <cn type="integer">0</cn>
     <mtext>otherwise.</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{th}^{n}_{k}(x_{1},\dots,x_{n})=\begin{cases}1&\text{if }\bigl|\{i\mid x%
_{i}=1\}\bigr|\geq k,\\
0&\text{otherwise.}\end{cases}
  </annotation>
 </semantics>
</math>

 For example, th<sub>1</sub><sup><em>n</em></sup> is the large disjunction of all the variables <em>x</em><sub><em>i</em></sub>, and th<sub><em>n</em></sub><sup><em>n</em></sup> is the large conjunction. Of particular importance is the <a href="majority_function" title="wikilink">majority function</a></p>

<p>

<math display="block" id="Post's_lattice:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>maj</mi>
    <mo>=</mo>
    <msubsup>
     <mi>th</mi>
     <mn>2</mn>
     <mn>3</mn>
    </msubsup>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>∧</mo>
       <mi>y</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∨</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>∧</mo>
       <mi>z</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∨</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>y</mi>
       <mo>∧</mo>
       <mi>z</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>maj</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>th</ci>
       <cn type="integer">3</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <or></or>
      <apply>
       <and></and>
       <ci>x</ci>
       <ci>y</ci>
      </apply>
      <apply>
       <and></and>
       <ci>x</ci>
       <ci>z</ci>
      </apply>
      <apply>
       <and></and>
       <ci>y</ci>
       <ci>z</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{maj}=\mathrm{th}^{3}_{2}=(x\land y)\lor(x\land z)\lor(y\land z).
  </annotation>
 </semantics>
</math>

</p>

<p>We denote elements of <strong>2</strong><sup><em>n</em></sup> (i.e., truth-assignments) as vectors: <mtpl></mtpl>. The set <strong>2</strong><sup><em>n</em></sup> carries a natural <a href="Cartesian_product" title="wikilink">product</a> <a href="Boolean_algebra_(structure)" title="wikilink">Boolean algebra</a> structure. That is, ordering, meets, joins, and other operations on <em>n</em>-ary truth assignments are defined pointwise:</p>

<p>

<math display="block" id="Post's_lattice:4">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>b</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>b</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⇔</mo>
   <msub>
    <mi>a</mi>
    <mi>i</mi>
   </msub>
   <mo>≤</mo>
   <msub>
    <mi>b</mi>
    <mi>i</mi>
   </msub>
   <mtext>for every</mtext>
   <mi>i</mi>
   <mo>=</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mi>n</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <leq></leq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">iff</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <ci>i</ci>
    </apply>
    <mtext>for every</mtext>
    <csymbol cd="unknown">i</csymbol>
    <eq></eq>
    <cn type="integer">1</cn>
    <ci>normal-,</ci>
    <ci>normal-…</ci>
    <ci>normal-,</ci>
    <csymbol cd="unknown">n</csymbol>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a_{1},\dots,a_{n})\leq(b_{1},\dots,b_{n})\iff a_{i}\leq b_{i}\text{ for every%
 }i=1,\dots,n,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Post's_lattice:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>a</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>a</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∧</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>b</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>b</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>a</mi>
       <mn>1</mn>
      </msub>
      <mo>∧</mo>
      <msub>
       <mi>b</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>n</mi>
      </msub>
      <mo>∧</mo>
      <msub>
       <mi>b</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <and></and>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
     </vector>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <vector>
     <apply>
      <and></and>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <and></and>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a_{1},\dots,a_{n})\land(b_{1},\dots,b_{n})=(a_{1}\land b_{1},\dots,a_{n}\land
b%
_{n}).
  </annotation>
 </semantics>
</math>

</p>
<h2 id="naming-of-clones">Naming of clones</h2>

<p><a href="intersection_(set_theory)" title="wikilink">Intersection</a> of an arbitrary number of clones is again a clone. It is convenient to denote intersection of clones by simple <a href="wiktionary:juxtaposition" title="wikilink">juxtaposition</a>, i.e., the clone <mtpl></mtpl> is denoted by <em>C</em><sub>1</sub><em>C</em><sub>2</sub>...<em>C</em><sub><em>k</em></sub>. Some special clones are introduced below:</p>
<ul>
<li>M is the set of <a href="Functional_completeness#Characterization_of_functional_completeness" title="wikilink">monotone</a> functions:  for every .</li>
<li>D is the set of <a href="Functional_completeness#Characterization_of_functional_completeness" title="wikilink">self-dual</a> functions: .</li>
<li>A is the set of <a href="Functional_completeness#Characterization_of_functional_completeness" title="wikilink">affine</a> functions: the functions satisfying</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Post's_lattice:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>,</mo>
     <mi>c</mi>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>d</mi>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo rspace="7.5pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo rspace="7.5pt">⇒</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>c</mi>
     <mo>,</mo>
     <msub>
      <mi>b</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>d</mi>
     <mo>,</mo>
     <msub>
      <mi>b</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <apply>
         <minus></minus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>c</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <apply>
         <plus></plus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>n</ci>
       </apply>
      </vector>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <ci>d</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <apply>
         <plus></plus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-…</ci>
      </vector>
     </apply>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <ci>c</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <apply>
         <plus></plus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-…</ci>
      </vector>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <ci>d</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <apply>
         <plus></plus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-…</ci>
      </vector>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(a_{1},\dots,a_{i-1},c,a_{i+1},\dots,a_{n})=f(a_{1},\dots,d,a_{i+1},\dots)\ %
\Rightarrow\ f(b_{1},\dots,c,b_{i+1},\dots)=f(b_{1},\dots,d,b_{i+1},\dots)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>for every <em>i</em> ≤ <em>n</em>, <strong>a</strong>, <strong>b</strong> ∈ <strong>2</strong><sup><em>n</em></sup>, and <em>c</em>, <em>d</em> ∈ <strong>2</strong>. Equivalently, the functions expressible as <mtpl></mtpl> for some <em>a</em><sub>0</sub>, <strong>a</strong>.
</dd>
</dl>
<ul>
<li>U is the set of <em>essentially unary</em> functions, i.e., functions which depend on at most one input variable: there exists an <em>i</em> = 1, ..., <em>n</em> such that  whenever <mtpl></mtpl>.</li>
<li>Λ is the set of <em>conjunctive</em> functions: . The clone Λ consists of the conjunctions 

<math display="inline" id="Post's_lattice:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋀</mo>
     <mrow>
      <mi>i</mi>
      <mo>∈</mo>
      <mi>I</mi>
     </mrow>
    </msub>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <and></and>
      <apply>
       <in></in>
       <ci>i</ci>
       <ci>I</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{1},\dots,x_{n})=\bigwedge_{i\in I}x_{i}
  </annotation>
 </semantics>
</math>

 for all subsets <em>I</em> of {1, ..., <em>n</em>} (including the empty conjunction, i.e., the constant 1), and the constant 0.</li>
<li>V is the set of <em>disjunctive</em> functions: . Equivalently, V consists of the disjunctions 

<math display="inline" id="Post's_lattice:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋁</mo>
     <mrow>
      <mi>i</mi>
      <mo>∈</mo>
      <mi>I</mi>
     </mrow>
    </msub>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <or></or>
      <apply>
       <in></in>
       <ci>i</ci>
       <ci>I</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{1},\dots,x_{n})=\bigvee_{i\in I}x_{i}
  </annotation>
 </semantics>
</math>

 for all subsets <em>I</em> of {1, ..., <em>n</em>} (including the empty disjunction 0), and the constant 1.</li>
<li>For any <em>k</em> ≥ 1, T<sub>0</sub><sup><em>k</em></sup> is the set of functions <em>f</em> such that</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Post's_lattice:9">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>𝐚</mi>
     <mn>1</mn>
    </msup>
    <mo>∧</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>∧</mo>
    <msup>
     <mi>𝐚</mi>
     <mi>k</mi>
    </msup>
   </mrow>
   <mo>=</mo>
   <mpadded width="+5pt">
    <mn>𝟎</mn>
   </mpadded>
   <mo rspace="7.5pt">⇒</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>𝐚</mi>
       <mn>1</mn>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∧</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>∧</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>𝐚</mi>
       <mi>k</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <and></and>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐚</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐚</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <and></and>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐚</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐚</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{a}^{1}\land\cdots\land\mathbf{a}^{k}=\mathbf{0}\ \Rightarrow\ f(%
\mathbf{a}^{1})\land\cdots\land f(\mathbf{a}^{k})=0.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>Moreover, 

<math display="inline" id="Post's_lattice:10">
 <semantics>
  <mrow>
   <msubsup>
    <mi mathvariant="normal">T</mi>
    <mn>0</mn>
    <mi mathvariant="normal">∞</mi>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋂</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <msubsup>
     <mi mathvariant="normal">T</mi>
     <mn>0</mn>
     <mi>k</mi>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-T</ci>
      <cn type="integer">0</cn>
     </apply>
     <infinity></infinity>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <intersect></intersect>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-T</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{T}_{0}^{\infty}=\bigcap_{k=1}^{\infty}\mathrm{T}_{0}^{k}
  </annotation>
 </semantics>
</math>

 is the set of functions bounded above by a variable: there exists <em>i</em> = 1, ..., <em>n</em> such that <mtpl></mtpl> for all <strong>a</strong>.
</dd>
<dd>As a special case, <mtpl></mtpl> is the set of <em>0-preserving</em> functions: .
</dd>
</dl>
<ul>
<li>For any <em>k</em> ≥ 1, T<sub>1</sub><sup><em>k</em></sup> is the set of functions <em>f</em> such that</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Post's_lattice:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>𝐚</mi>
      <mn>1</mn>
     </msup>
     <mo>∨</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>∨</mo>
     <msup>
      <mi>𝐚</mi>
      <mi>k</mi>
     </msup>
    </mrow>
    <mo>=</mo>
    <mpadded width="+5pt">
     <mn>𝟏</mn>
    </mpadded>
    <mo rspace="7.5pt">⇒</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>𝐚</mi>
        <mn>1</mn>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∨</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>∨</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>𝐚</mi>
        <mi>k</mi>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <or></or>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐚</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐚</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <or></or>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐚</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐚</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{a}^{1}\lor\cdots\lor\mathbf{a}^{k}=\mathbf{1}\ \Rightarrow\ f(\mathbf{%
a}^{1})\lor\cdots\lor f(\mathbf{a}^{k})=1,
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>and 

<math display="inline" id="Post's_lattice:12">
 <semantics>
  <mrow>
   <msubsup>
    <mi mathvariant="normal">T</mi>
    <mn>1</mn>
    <mi mathvariant="normal">∞</mi>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋂</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <msubsup>
     <mi mathvariant="normal">T</mi>
     <mn>1</mn>
     <mi>k</mi>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-T</ci>
      <cn type="integer">1</cn>
     </apply>
     <infinity></infinity>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <intersect></intersect>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-T</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{T}_{1}^{\infty}=\bigcap_{k=1}^{\infty}\mathrm{T}_{1}^{k}
  </annotation>
 </semantics>
</math>

 is the set of functions bounded below by a variable: there exists <em>i</em> = 1, ..., <em>n</em> such that <mtpl></mtpl> for all <strong>a</strong>.
</dd>
<dd>The special case <mtpl></mtpl> consists of the <em>1-preserving</em> functions: .
</dd>
</dl>
<ul>
<li>The largest clone of all functions is denoted ⊤, the smallest clone (which contains only projections) is denoted ⊥, and <mtpl></mtpl> is the clone of <em>constant-preserving</em> functions.</li>
</ul>
<h2 id="description-of-the-lattice">Description of the lattice</h2>

<p>The set of all clones is a <a href="closure_system" title="wikilink">closure system</a>, hence it forms a <a href="complete_lattice" title="wikilink">complete lattice</a>. The lattice is <a href="countably_infinite" title="wikilink">countably infinite</a>, and all its members are finitely generated. All the clones are listed in the table below.</p>

<p> </p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>clone</p></th>
<th style="text-align: left;">
<p>one of its bases</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>⊤</p></td>
<td style="text-align: left;">
<p>∨, ¬</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>P<sub>0</sub></p></td>
<td style="text-align: left;">
<p>∨, +</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>P<sub>1</sub></p></td>
<td style="text-align: left;">
<p>∧, →</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>P</p></td>
<td style="text-align: left;">
<p><em>x</em> ? <em>y</em> : <em>z</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>T<sub>0</sub><sup><em>k</em></sup>, <em>k</em> ≥ 2</p></td>
<td style="text-align: left;">
<p>th<sub><em>k</em></sub><sup><em>k</em>+1</sup>, ↛</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>T<sub>0</sub><sup>∞</sup></p></td>
<td style="text-align: left;">
<p>↛</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>PT<sub>0</sub><sup><em>k</em></sup>, <em>k</em> ≥ 2</p></td>
<td style="text-align: left;">
<p>th<sub><em>k</em></sub><sup><em>k</em>+1</sup>, <em>x</em> ∧ (<em>y</em> → <em>z</em>)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>PT<sub>0</sub><sup>∞</sup></p></td>
<td style="text-align: left;">
<p><em>x</em> ∧ (<em>y</em> → <em>z</em>)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>T<sub>1</sub><sup><em>k</em></sup>, <em>k</em> ≥ 2</p></td>
<td style="text-align: left;">
<p>th<sub>2</sub><sup><em>k</em>+1</sup>, →</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>T<sub>1</sub><sup>∞</sup></p></td>
<td style="text-align: left;">
<p>→</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>PT<sub>1</sub><sup><em>k</em></sup>, <em>k</em> ≥ 2</p></td>
<td style="text-align: left;">
<p>th<sub>2</sub><sup><em>k</em>+1</sup>, <em>x</em> ∨ (<em>y</em> + <em>z</em>)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>PT<sub>1</sub><sup>∞</sup></p></td>
<td style="text-align: left;">
<p><em>x</em> ∨ (<em>y</em> + <em>z</em>)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>M</p></td>
<td style="text-align: left;">
<p>∧, ∨, 0, 1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>MP<sub>0</sub></p></td>
<td style="text-align: left;">
<p>∧, ∨, 0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>MP<sub>1</sub></p></td>
<td style="text-align: left;">
<p>∧, ∨, 1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>MP</p></td>
<td style="text-align: left;">
<p>∧, ∨</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>MT<sub>0</sub><sup><em>k</em></sup>, <em>k</em> ≥ 2</p></td>
<td style="text-align: left;">
<p>th<sub><em>k</em></sub><sup><em>k</em>+1</sup>, 0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>MT<sub>0</sub><sup>∞</sup></p></td>
<td style="text-align: left;">
<p><em>x</em> ∧ (<em>y</em> ∨ <em>z</em>), 0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>MPT<sub>0</sub><sup><em>k</em></sup>, <em>k</em> ≥ 2</p></td>
<td style="text-align: left;">
<p>th<sub><em>k</em></sub><sup><em>k</em>+1</sup> for <em>k</em> ≥ 3,<br/>
maj, <em>x</em> ∧ (<em>y</em> ∨ <em>z</em>) for <em>k</em> = 2</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>MPT<sub>0</sub><sup>∞</sup></p></td>
<td style="text-align: left;">
<p><em>x</em> ∧ (<em>y</em> ∨ <em>z</em>)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>MT<sub>1</sub><sup><em>k</em></sup>, <em>k</em> ≥ 2</p></td>
<td style="text-align: left;">
<p>th<sub>2</sub><sup><em>k</em>+1</sup>, 1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>MT<sub>1</sub><sup>∞</sup></p></td>
<td style="text-align: left;">
<p><em>x</em> ∨ (<em>y</em> ∧ <em>z</em>), 1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>MPT<sub>1</sub><sup><em>k</em></sup>, <em>k</em> ≥ 2</p></td>
<td style="text-align: left;">
<p>th<sub>2</sub><sup><em>k</em>+1</sup> for <em>k</em> ≥ 3,<br/>
maj, <em>x</em> ∨ (<em>y</em> ∧ <em>z</em>) for <em>k</em> = 2</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>MPT<sub>1</sub><sup>∞</sup></p></td>
<td style="text-align: left;">
<p><em>x</em> ∨ (<em>y</em> ∧ <em>z</em>)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Λ</p></td>
<td style="text-align: left;">
<p>∧, 0, 1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>ΛP<sub>0</sub></p></td>
<td style="text-align: left;">
<p>∧, 0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>ΛP<sub>1</sub></p></td>
<td style="text-align: left;">
<p>∧, 1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>ΛP</p></td>
<td style="text-align: left;">
<p>∧</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>V</p></td>
<td style="text-align: left;">
<p>∨, 0, 1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>VP<sub>0</sub></p></td>
<td style="text-align: left;">
<p>∨, 0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>VP<sub>1</sub></p></td>
<td style="text-align: left;">
<p>∨, 1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>VP</p></td>
<td style="text-align: left;">
<p>∨</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>D</p></td>
<td style="text-align: left;">
<p>maj, ¬</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>DP</p></td>
<td style="text-align: left;">
<p>maj, <em>x</em> + <em>y</em> + <em>z</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>DM</p></td>
<td style="text-align: left;">
<p>maj</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>A</p></td>
<td style="text-align: left;">
<p>↔, 0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>AD</p></td>
<td style="text-align: left;">
<p>¬, <em>x</em> + <em>y</em> + <em>z</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>AP<sub>0</sub></p></td>
<td style="text-align: left;">
<p>+</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>AP<sub>1</sub></p></td>
<td style="text-align: left;">
<p>↔</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>AP</p></td>
<td style="text-align: left;">
<p><em>x</em> + <em>y</em> + <em>z</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>U</p></td>
<td style="text-align: left;">
<p>¬, 0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>UD</p></td>
<td style="text-align: left;">
<p>¬</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>UM</p></td>
<td style="text-align: left;">
<p>0, 1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>UP<sub>0</sub></p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>UP<sub>1</sub></p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>⊥</p></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>

<p>The eight infinite families have actually also members with <em>k</em> = 1, but these appear separately in the table: <mtpl></mtpl>, <mtpl></mtpl>, <mtpl></mtpl>, <mtpl></mtpl>, <mtpl></mtpl>, <mtpl></mtpl>.</p>

<p>The lattice has a natural symmetry mapping each clone <em>C</em> to its dual clone }, where <mtpl></mtpl> is the <a href="de_Morgan_dual" title="wikilink">de Morgan dual</a> of a Boolean function <em>f</em>. For example, <mtpl></mtpl>, <mtpl></mtpl>, and <mtpl></mtpl>.</p>
<h2 id="applications">Applications</h2>

<p>The complete classification of Boolean clones given by Post helps to resolve various questions about classes of Boolean functions. For example:</p>
<ul>
<li>An inspection of the lattice shows that the maximal clones different from ⊤ (often called <strong>Post's classes</strong>) are M, D, A, P<sub>0</sub>, P<sub>1</sub>, and every proper subclone of ⊤ is contained in one of them. As a set <em>B</em> of connectives is <a href="functional_completeness" title="wikilink">functionally complete</a> if and only if it generates ⊤, we obtain the following characterization: <em>B</em> is functionally complete iff it is not included in one of the five Post's classes.</li>
<li>The <a href="satisfiability_problem" title="wikilink">satisfiability problem</a> for Boolean formulas is <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> by <a href="Cook's_theorem" title="wikilink">Cook's theorem</a>. Consider a restricted version of the problem: for a fixed finite set <em>B</em> of connectives, let <em>B</em>-SAT be the algorithmic problem of checking whether a given <em>B</em>-formula is satisfiable. Lewis<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> used the description of Post's lattice to show that <em>B</em>-SAT is NP-complete if the function ↛ can be generated from <em>B</em> (i.e., <mtpl></mtpl>), and in all the other cases <em>B</em>-SAT is <a href="P_(complexity)" title="wikilink">polynomial-time</a> decidable.</li>
</ul>
<h2 id="variants">Variants</h2>

<p>Post originally did not work with the modern definition of clones, but with the so-called <em>iterative systems</em>, which are sets of operations closed under substitution</p>

<p>

<math display="block" id="Post's_lattice:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mrow>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mi>m</mi>
        </mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo>,</mo>
      <mrow>
       <mi>g</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <msub>
         <mi>x</mi>
         <mrow>
          <mrow>
           <mi>n</mi>
           <mo>+</mo>
           <mi>m</mi>
          </mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <ci>m</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>g</ci>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <apply>
          <minus></minus>
          <apply>
           <plus></plus>
           <ci>n</ci>
           <ci>m</ci>
          </apply>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </vector>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x_{1},\dots,x_{n+m-1})=f(x_{1},\dots,x_{n-1},g(x_{n},\dots,x_{n+m-1})),
  </annotation>
 </semantics>
</math>

 as well as permutation and identification of variables. The main difference is that iterative systems do not necessarily contain all projections. Every clone is an iterative system, and there are 20 non-empty iterative systems which are not clones. (Post also excluded the empty iterative system from the classification, hence his diagram has no least element and fails to be a lattice.) As another alternative, some authors work with the notion of a <em>closed class</em>, which is an iterative system closed under introduction of dummy variables. There are four closed classes which are not clones: the empty set, the set of constant 0 functions, the set of constant 1 functions, and the set of all constant functions.</p>

<p>Composition alone does not allow to generate a nullary function from the corresponding unary constant function, this is the technical reason why nullary functions are excluded from clones in Post's classification. If we lift the restriction, we get more clones. Namely, each clone <em>C</em> in Post's lattice which contains at least one constant function corresponds to two clones under the less restrictive definition: <em>C</em>, and <em>C</em> together with all nullary functions whose unary versions are in <em>C</em>.</p>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Universal_algebra" title="wikilink">Category:Universal algebra</a> <a class="uri" href="Category:Logic" title="wikilink">Category:Logic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">E. L. Post, <em>The two-valued iterative systems of mathematical logic</em>, Annals of Mathematics studies, no. 5, Princeton University Press, Princeton 1941, 122 pp.<a href="#fnref1">↩</a></li>
<li id="fn2">D. Lau, <em>Function algebras on finite sets: Basic course on many-valued logic and clone theory</em>, Springer, New York, 2006, 668 pp. ISBN 978-3-540-36022-3<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="Harry_R._Lewis" title="wikilink">H. R. Lewis</a>, <em>Satisfiability problems for propositional calculi</em>, Mathematical Systems Theory 13 (1979), pp. 45–53.<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
