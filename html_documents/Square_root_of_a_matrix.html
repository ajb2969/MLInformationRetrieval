<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1505">Square root of a matrix</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Square root of a matrix</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, the <strong>square root of a matrix</strong> extends the notion of <a href="square_root" title="wikilink">square root</a> from numbers to <a href="Matrix_(mathematics)" title="wikilink">matrices</a>.</p>

<p>Matrix 

<math display="inline" id="Square_root_of_a_matrix:0">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is said to be a square root of 

<math display="inline" id="Square_root_of_a_matrix:1">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 if the <a href="matrix_product" title="wikilink">matrix product</a> 

<math display="inline" id="Square_root_of_a_matrix:2">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>



<math display="inline" id="Square_root_of_a_matrix:3">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is equal to 

<math display="inline" id="Square_root_of_a_matrix:4">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="properties">Properties</h2>

<p>In general, a matrix can have several square roots. For example, the matrix 

<math display="inline" id="Square_root_of_a_matrix:5">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mtable>
    <mtr>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">33</mn>
     </mtd>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">24</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">48</mn>
     </mtd>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">57</mn>
     </mtd>
    </mtr>
   </mtable>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="integer">33</cn>
     <cn type="integer">24</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">48</cn>
     <cn type="integer">57</cn>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\begin{smallmatrix}33&24\\
48&57\end{smallmatrix}\right)
  </annotation>
 </semantics>
</math>

 has square roots 

<math display="inline" id="Square_root_of_a_matrix:6">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mtable>
    <mtr>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">4</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">8</mn>
     </mtd>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">5</mn>
     </mtd>
    </mtr>
   </mtable>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="integer">1</cn>
     <cn type="integer">4</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">8</cn>
     <cn type="integer">5</cn>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\begin{smallmatrix}1&4\\
8&5\end{smallmatrix}\right)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Square_root_of_a_matrix:7">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mtable>
    <mtr>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">5</mn>
     </mtd>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">2</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">4</mn>
     </mtd>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">7</mn>
     </mtd>
    </mtr>
   </mtable>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="integer">5</cn>
     <cn type="integer">2</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">4</cn>
     <cn type="integer">7</cn>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\begin{smallmatrix}5&2\\
4&7\end{smallmatrix}\right)
  </annotation>
 </semantics>
</math>

, as well as their <a href="additive_inverse" title="wikilink">additive inverses</a>.</p>

<p>Another example is the 2×2 <a href="identity_matrix" title="wikilink">identity matrix</a> 

<math display="inline" id="Square_root_of_a_matrix:8">
 <semantics>
  <mrow>
   <mrow>
    <mo maxsize="120%" minsize="120%">(</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mn mathsize="70%" stretchy="false">1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn mathsize="70%" stretchy="false">0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn mathsize="70%" stretchy="false">0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn mathsize="70%" stretchy="false">1</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo maxsize="120%" minsize="120%">)</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="integer">1</cn>
     <cn type="integer">0</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigl(\begin{smallmatrix}1&0\\
0&1\end{smallmatrix}\bigr),
  </annotation>
 </semantics>
</math>

 which has infinitely many <a href="symmetric_matrix" title="wikilink">symmetric</a> rational square roots given by</p>

<p>

<math display="block" id="Square_root_of_a_matrix:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>t</mi>
     </mfrac>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mi>s</mi>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mi>r</mi>
          <mo>;</mo>
         </mrow>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mi>r</mi>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mi>s</mi>
         </mrow>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>t</mi>
     </mfrac>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mi>s</mi>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mi>r</mi>
         </mrow>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mi>r</mi>
         </mrow>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mi>s</mi>
         </mrow>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>t</mi>
     </mfrac>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mi>s</mi>
         </mrow>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mi>r</mi>
          <mo>;</mo>
         </mrow>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mi>r</mi>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mi>s</mi>
          <mo>;</mo>
         </mrow>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>t</mi>
     </mfrac>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mi>s</mi>
         </mrow>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mi>r</mi>
         </mrow>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <mi>r</mi>
         </mrow>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mi>s</mi>
          <mo>;</mo>
         </mrow>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mn>1</mn>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mo>±</mo>
         <mn>1</mn>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mtext>and</mtext>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mo>±</mo>
         <mn>1</mn>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>t</ci>
     </apply>
     <matrix>
      <matrixrow>
       <ci>s</ci>
       <ci>r</ci>
      </matrixrow>
      <matrixrow>
       <ci>r</ci>
       <apply>
        <minus></minus>
        <ci>s</ci>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>t</ci>
     </apply>
     <matrix>
      <matrixrow>
       <ci>s</ci>
       <apply>
        <minus></minus>
        <ci>r</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <minus></minus>
        <ci>r</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>s</ci>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>t</ci>
     </apply>
     <matrix>
      <matrixrow>
       <apply>
        <minus></minus>
        <ci>s</ci>
       </apply>
       <ci>r</ci>
      </matrixrow>
      <matrixrow>
       <ci>r</ci>
       <ci>s</ci>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>t</ci>
     </apply>
     <matrix>
      <matrixrow>
       <apply>
        <minus></minus>
        <ci>s</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>r</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <minus></minus>
        <ci>r</ci>
       </apply>
       <ci>s</ci>
      </matrixrow>
     </matrix>
    </apply>
    <matrix>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="latexml">plus-or-minus</csymbol>
       <cn type="integer">1</cn>
      </apply>
     </matrixrow>
    </matrix>
    <mtext>and</mtext>
    <matrix>
     <matrixrow>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <apply>
       <csymbol cd="latexml">plus-or-minus</csymbol>
       <cn type="integer">1</cn>
      </apply>
     </matrixrow>
    </matrix>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{t}\left(\begin{matrix}s&r;\\
r&-s\end{matrix}\right),\quad\frac{1}{t}\left(\begin{matrix}s&-r\\
-r&-s\end{matrix}\right),\quad\frac{1}{t}\left(\begin{matrix}-s&r;\\
r&s;\end{matrix}\right),\quad\frac{1}{t}\left(\begin{matrix}-s&-r\\
-r&s;\end{matrix}\right),\quad\left(\begin{matrix}1&0\\
0&\pm 1\end{matrix}\right),\quad\text{and}\quad\left(\begin{matrix}-1&0\\
0&\pm 1\end{matrix}\right),
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Square_root_of_a_matrix:10">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>r</mi>
   <mo>,</mo>
   <mi>s</mi>
   <mo>,</mo>
   <mi>t</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>r</ci>
    <ci>s</ci>
    <ci>t</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (r,s,t)
  </annotation>
 </semantics>
</math>

 is any <a href="Pythagorean_triple" title="wikilink">Pythagorean triple</a>—that is, any set of positive integers such that 

<math display="inline" id="Square_root_of_a_matrix:11">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>r</mi>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <msup>
     <mi>s</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>t</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>r</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>t</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{2}+s^{2}=t^{2}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>However, a <em><a href="positive-semidefinite_matrix" title="wikilink">positive-semidefinite matrix</a></em> has precisely one positive-semidefinite square root, which can be called its <em>principal square root</em>.</p>

<p>While the square root of a nonnegative <a class="uri" href="integer" title="wikilink">integer</a> is either again an integer or an <a href="irrational_number" title="wikilink">irrational number</a>, in contrast an <em>integer matrix</em> can have a square root whose entries are rational, yet not integer. For example, the matrix 

<math display="inline" id="Square_root_of_a_matrix:12">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mtable>
    <mtr>
     <mtd columnalign="center">
      <mpadded lspace="3.3pt" width="+3.3pt">
       <mn mathsize="70%" stretchy="false">0</mn>
      </mpadded>
     </mtd>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">4</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mrow>
       <mo mathsize="70%" stretchy="false">-</mo>
       <mn mathsize="70%" stretchy="false">1</mn>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">5</mn>
     </mtd>
    </mtr>
   </mtable>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="float">0</cn>
     <cn type="integer">4</cn>
    </matrixrow>
    <matrixrow>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">5</cn>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\begin{smallmatrix}~{}\;0&4\\
-1&5\end{smallmatrix}\right)
  </annotation>
 </semantics>
</math>

 has the non-integer square root 

<math display="inline" id="Square_root_of_a_matrix:13">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mtable>
    <mtr>
     <mtd columnalign="center">
      <mpadded lspace="6.1pt" width="+6.1pt">
       <mfrac>
        <mn mathsize="70%" stretchy="false">2</mn>
        <mn mathsize="70%" stretchy="false">3</mn>
       </mfrac>
      </mpadded>
     </mtd>
     <mtd columnalign="center">
      <mfrac>
       <mn mathsize="70%" stretchy="false">4</mn>
       <mn mathsize="70%" stretchy="false">3</mn>
      </mfrac>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mrow>
       <mo mathsize="70%" stretchy="false">-</mo>
       <mfrac>
        <mn mathsize="70%" stretchy="false">1</mn>
        <mn mathsize="70%" stretchy="false">3</mn>
       </mfrac>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mfrac>
       <mn mathsize="70%" stretchy="false">7</mn>
       <mn mathsize="70%" stretchy="false">3</mn>
      </mfrac>
     </mtd>
    </mtr>
   </mtable>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <divide></divide>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">4</cn>
      <cn type="integer">3</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">7</cn>
      <cn type="integer">3</cn>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\begin{smallmatrix}~{}\;\frac{2}{3}&\frac{4}{3}\\
-\frac{1}{3}&\frac{7}{3}\end{smallmatrix}\right)
  </annotation>
 </semantics>
</math>

 as well as the integer square root matrix 

<math display="inline" id="Square_root_of_a_matrix:14">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mtable>
    <mtr>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">2</mn>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo mathsize="70%" stretchy="false">-</mo>
       <mn mathsize="70%" stretchy="false">4</mn>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">1</mn>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mo mathsize="70%" stretchy="false">-</mo>
       <mn mathsize="70%" stretchy="false">3</mn>
      </mrow>
     </mtd>
    </mtr>
   </mtable>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <cn type="integer">4</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <cn type="integer">1</cn>
     <apply>
      <minus></minus>
      <cn type="integer">3</cn>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\begin{smallmatrix}2&-4\\
1&-3\end{smallmatrix}\right)
  </annotation>
 </semantics>
</math>

. The 2×2 identity matrix is another example.</p>

<p>A 2×2 matrix with two distinct nonzero <a href="eigenvalue" title="wikilink">eigenvalues</a> has four square roots.</p>

<p>More generally, an 

<math display="inline" id="Square_root_of_a_matrix:15">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">×</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-×</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n×n
  </annotation>
 </semantics>
</math>

 matrix with 

<math display="inline" id="Square_root_of_a_matrix:16">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 <em>distinct nonzero eigenvalues</em> has 2<sup>n</sup> square roots. Such a matrix, 

<math display="inline" id="Square_root_of_a_matrix:17">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, has a decomposition <mtpl></mtpl> where 

<math display="inline" id="Square_root_of_a_matrix:18">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 is the matrix whose columns are eigenvectors of 

<math display="inline" id="Square_root_of_a_matrix:19">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Square_root_of_a_matrix:20">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 is the diagonal matrix whose diagonal elements are the corresponding 

<math display="inline" id="Square_root_of_a_matrix:21">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 eigenvalues <mtpl></mtpl>. Thus the square roots of 

<math display="inline" id="Square_root_of_a_matrix:22">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 are given by <mtpl></mtpl>, where 

<math display="inline" id="Square_root_of_a_matrix:23">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

<sup>½</sup> is any square root matrix of 

<math display="inline" id="Square_root_of_a_matrix:24">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

, which, for distinct eigenvalues, must be diagonal with diagonal elements equal to square roots of the diagonal elements of 

<math display="inline" id="Square_root_of_a_matrix:25">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

; since there are two possible choices for a square root of each diagonal element of 

<math display="inline" id="Square_root_of_a_matrix:26">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

, there are 2<sup><em>n</em></sup> choices for the matrix 

<math display="inline" id="Square_root_of_a_matrix:27">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

<sup>½</sup>.</p>

<p>This also leads to a proof of the above observation, that a positive-definite matrix has precisely one positive-definite square root: a positive definite matrix has only positive eigenvalues, and each of these eigenvalues has only one positive square root; and since the eigenvalues of the square root matrix are the diagonal elements of 

<math display="inline" id="Square_root_of_a_matrix:28">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

<sup>½</sup>, for the square root matrix to be itself positive definite necessitates the use of only the unique positive square roots of the original eigenvalues.</p>

<p>Just as with the <a href="real_numbers" title="wikilink">real numbers</a>, a real matrix may fail to have a real square root, but have a square root with <a href="Complex_number" title="wikilink">complex</a>-valued entries.</p>

<p>Some matrices have <em>no square root</em>. An example is the matrix 

<math display="inline" id="Square_root_of_a_matrix:29">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mtable>
    <mtr>
     <mtd columnalign="center">
      <mi></mi>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">1</mn>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn mathsize="70%" stretchy="false">0</mn>
     </mtd>
    </mtr>
   </mtable>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <csymbol cd="latexml">absent</csymbol>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\begin{smallmatrix}\\
0&1\\
0&0\end{smallmatrix}\right)
  </annotation>
 </semantics>
</math>

.</p>

<p>In general, a complex matrix with positive real eigenvalues has a unique square root with positive eigenvalues called the <em>principal square root</em>. Moreover, the operation of taking the principal square root is continuous on this set of matrices. If the matrix has real entries, then the square root also has real entries. These properties are consequences of the <a href="holomorphic_functional_calculus" title="wikilink">holomorphic functional calculus</a> applied to matrices. The existence and uniqueness of the principal square root can be deduced directly from the <a href="Jordan_normal_form" title="wikilink">Jordan normal form</a> (see below).<ref>For analytic functions of matrices, see</ref></p>
<ul>
<li></li>
<li>

<p></p></li>
</ul>

<p><ref>For the holomorphic functional calculus, see:</ref></p>
<ul>
<li></li>
<li></li>
<li></li>
</ul>

<p></p>
<h2 id="computation-methods">Computation methods</h2>
<h3 id="explicit-formulas">Explicit formulas</h3>

<p>For a 2 × 2 matrix, there are <a href="square_root_of_a_2_by_2_matrix" title="wikilink">explicit formulas</a> that give up to four square roots, if the matrix has any roots.</p>

<p>If 

<math display="inline" id="Square_root_of_a_matrix:30">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 is a <a href="diagonal_matrix" title="wikilink">diagonal</a> <em>n</em> × <em>n</em> matrix, one can obtain a square root by taking a diagonal matrix 

<math display="inline" id="Square_root_of_a_matrix:31">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

, where each element along the diagonal is a square root of the corresponding element of 

<math display="inline" id="Square_root_of_a_matrix:32">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

. If the diagonal elements of <em>D</em> are real and non-negative, and the square roots are taken with non-negative sign, the matrix 

<math display="inline" id="Square_root_of_a_matrix:33">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 will be the principal root of 

<math display="inline" id="Square_root_of_a_matrix:34">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

.</p>

<p>If a matrix is <a href="idempotent_matrix" title="wikilink">idempotent</a>, one of its square roots is the matrix itself.</p>
<h3 id="by-diagonalization">By diagonalization</h3>

<p>An <em>n</em> × <em>n</em> matrix 

<math display="inline" id="Square_root_of_a_matrix:35">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is <a href="diagonalizable_matrix" title="wikilink">diagonalizable</a> if there is a matrix 

<math display="inline" id="Square_root_of_a_matrix:36">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 and a diagonal matrix 

<math display="inline" id="Square_root_of_a_matrix:37">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 such that <mtpl> <em>VDV</em><sup>−1</sup>}}</mtpl>. This happens if and only if 

<math display="inline" id="Square_root_of_a_matrix:38">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 has <em>n</em> <a href="eigenvector" title="wikilink">eigenvectors</a> which constitute a basis for <mtpl></mtpl>. In this case, 

<math display="inline" id="Square_root_of_a_matrix:39">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 can be chosen to be the matrix with the <em>n</em> eigenvectors as columns, and thus a square root of 

<math display="inline" id="Square_root_of_a_matrix:40">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is</p>

<p>

<math display="block" id="Square_root_of_a_matrix:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mo>=</mo>
    <mrow>
     <mi>V</mi>
     <mi>S</mi>
     <mpadded width="+3.3pt">
      <msup>
       <mi>V</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mpadded>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>S</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=VSV^{-1}~{},
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Square_root_of_a_matrix:42">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is any square root of 

<math display="inline" id="Square_root_of_a_matrix:43">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

. Indeed,</p>

<p>

<math display="block" id="Square_root_of_a_matrix:44">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>V</mi>
       <msup>
        <mi>D</mi>
        <mrow>
         <mn>1</mn>
         <mo>/</mo>
         <mn>2</mn>
        </mrow>
       </msup>
       <msup>
        <mi>V</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>=</mo>
    <mrow>
     <mi>V</mi>
     <msup>
      <mi>D</mi>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>V</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mi>V</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mi>D</mi>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msup>
     <msup>
      <mi>V</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>V</mi>
     <mi>D</mi>
     <msup>
      <mi>V</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mo>=</mo>
    <mpadded width="+3.3pt">
     <mi>A</mi>
    </mpadded>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <ci>V</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>D</ci>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>V</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <ci>V</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>D</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>V</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>V</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>D</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>V</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>D</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>V</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (VD^{1/2}V^{-1})^{2}=VD^{1/2}(V^{-1}V)D^{1/2}V^{-1}=VDV^{-1}=A~{}.
  </annotation>
 </semantics>
</math>

</p>

<p>For example, the matrix 

<math display="inline" id="Square_root_of_a_matrix:45">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mo maxsize="120%" minsize="120%">(</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn mathsize="70%" stretchy="false">33</mn>
      </mtd>
      <mtd columnalign="center">
       <mn mathsize="70%" stretchy="false">24</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn mathsize="70%" stretchy="false">48</mn>
      </mtd>
      <mtd columnalign="center">
       <mn mathsize="70%" stretchy="false">57</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo maxsize="120%" minsize="120%">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <matrix>
     <matrixrow>
      <csymbol cd="latexml">absent</csymbol>
     </matrixrow>
     <matrixrow>
      <cn type="integer">33</cn>
      <cn type="integer">24</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">48</cn>
      <cn type="integer">57</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\bigl(\begin{smallmatrix}\\
33&24\\
48&57\end{smallmatrix}\bigr)
  </annotation>
 </semantics>
</math>

 can be diagonalized as <mtpl></mtpl>, where</p>

<p>

<math display="block" id="Square_root_of_a_matrix:46">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>=</mo>
   <mrow>
    <mo maxsize="120%" minsize="120%">(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn mathsize="70%" stretchy="false">1</mn>
      </mtd>
      <mtd columnalign="center">
       <mpadded lspace="3.3pt" width="+3.3pt">
        <mn mathsize="70%" stretchy="false">1</mn>
       </mpadded>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn mathsize="70%" stretchy="false">2</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mo mathsize="70%" stretchy="false">-</mo>
        <mn mathsize="70%" stretchy="false">1</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo maxsize="120%" minsize="120%">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>V</ci>
    <matrix>
     <matrixrow>
      <csymbol cd="latexml">absent</csymbol>
     </matrixrow>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="float">1</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V=\bigl(\begin{smallmatrix}\\
1&~{}\;1\\
2&-1\end{smallmatrix}\bigr)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Square_root_of_a_matrix:47">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mrow>
    <mo maxsize="120%" minsize="120%">(</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn mathsize="70%" stretchy="false">81</mn>
      </mtd>
      <mtd columnalign="center">
       <mn mathsize="70%" stretchy="false">0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mpadded lspace="3.3pt" width="+3.3pt">
        <mn mathsize="70%" stretchy="false">0</mn>
       </mpadded>
      </mtd>
      <mtd columnalign="center">
       <mn mathsize="70%" stretchy="false">9</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo maxsize="120%" minsize="120%">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>D</ci>
    <matrix>
     <matrixrow>
      <csymbol cd="latexml">absent</csymbol>
     </matrixrow>
     <matrixrow>
      <cn type="integer">81</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="float">0</cn>
      <cn type="integer">9</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=\bigl(\begin{smallmatrix}\\
81&0\\
~{}\;0&9\end{smallmatrix}\bigr)
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="inline" id="Square_root_of_a_matrix:48">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 has principal square root</p>

<p>

<math display="block" id="Square_root_of_a_matrix:49">
 <semantics>
  <mrow>
   <msup>
    <mi>D</mi>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo maxsize="120%" minsize="120%">(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn mathsize="70%" stretchy="false">9</mn>
      </mtd>
      <mtd columnalign="center">
       <mn mathsize="70%" stretchy="false">0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn mathsize="70%" stretchy="false">0</mn>
      </mtd>
      <mtd columnalign="center">
       <mn mathsize="70%" stretchy="false">3</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo maxsize="120%" minsize="120%">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>D</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <matrix>
     <matrixrow>
      <csymbol cd="latexml">absent</csymbol>
     </matrixrow>
     <matrixrow>
      <cn type="integer">9</cn>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <cn type="integer">3</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D^{1/2}=\bigl(\begin{smallmatrix}\\
9&0\\
0&3\end{smallmatrix}\bigr)
  </annotation>
 </semantics>
</math>

, giving the square root</p>

<p>

<math display="block" id="Square_root_of_a_matrix:50">
 <semantics>
  <mrow>
   <msup>
    <mi>A</mi>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>V</mi>
    <msup>
     <mi>D</mi>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msup>
    <msup>
     <mi>V</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo maxsize="120%" minsize="120%">(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mi></mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn mathsize="70%" stretchy="false">5</mn>
      </mtd>
      <mtd columnalign="center">
       <mn mathsize="70%" stretchy="false">2</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn mathsize="70%" stretchy="false">4</mn>
      </mtd>
      <mtd columnalign="center">
       <mn mathsize="70%" stretchy="false">7</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo maxsize="120%" minsize="120%">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>V</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>D</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>V</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <matrix>
      <matrixrow>
       <csymbol cd="latexml">absent</csymbol>
      </matrixrow>
      <matrixrow>
       <cn type="integer">5</cn>
       <cn type="integer">2</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">4</cn>
       <cn type="integer">7</cn>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{1/2}=VD^{1/2}V^{-1}=\bigl(\begin{smallmatrix}\\
5&2\\
4&7\end{smallmatrix}\bigr)
  </annotation>
 </semantics>
</math>

.</p>

<p>When 

<math display="inline" id="Square_root_of_a_matrix:51">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is symmetric, the diagonalizing matrix 

<math display="inline" id="Square_root_of_a_matrix:52">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 can be made an <a href="orthogonal_matrix" title="wikilink">orthogonal matrix</a> by suitably choosing the eigenvectors (see <a href="Eigendecomposition#Decomposition_for_special_matrices" title="wikilink">spectral theorem</a>). Then the inverse of 

<math display="inline" id="Square_root_of_a_matrix:53">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 is simply the transpose, so that</p>

<p>

<math display="block" id="Square_root_of_a_matrix:54">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mo>=</mo>
    <mrow>
     <mi>V</mi>
     <mi>S</mi>
     <mpadded width="+3.3pt">
      <msup>
       <mi>V</mi>
       <mi>T</mi>
      </msup>
     </mpadded>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>S</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=VSV^{T}~{}.
  </annotation>
 </semantics>
</math>

</p>
<h3 id="by-jordan-decomposition">By Jordan decomposition</h3>

<p>For non-diagonalizable matrices one can calculate the <a href="Jordan_normal_form" title="wikilink">Jordan normal form</a> followed by a series expansion, similar to the approach described in <a href="logarithm_of_a_matrix" title="wikilink">logarithm of a matrix</a>.</p>

<p>To see that any complex matrix with positive eigenvalues has a square root of the same form, it suffices to check this for a Jordan block. Any such block has the form λ(<em>I</em> + <em>N</em>) with λ &gt; 0 and <em>N</em> nilpotent. If <mtpl></mtpl> is the binomial expansion for the square root (valid in |<em>z</em>|  gives a square root of the Jordan block with eigenvalue 

<math display="inline" id="Square_root_of_a_matrix:55">
 <semantics>
  <mrow>
   <mi mathvariant="normal">√</mi>
   <mi>λ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-√</ci>
    <ci>λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   √λ
  </annotation>
 </semantics>
</math>

.</p>

<p>It suffices to check uniqueness for a Jordan block with λ = 1. The square constructed above has the form <em>S</em> = <em>I</em> + <em>L</em> where <em>L</em> is polynomial in <em>N</em> without constant term. Any other square root <em>T</em> with positive eigenvalues has the form <em>T</em> = <em>I</em> + <em>M</em> with 

<math display="inline" id="Square_root_of_a_matrix:56">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 nilpotent, commuting with <em>N</em> and hence <em>L</em>. But then <mtpl></mtpl>. Since <em>L</em> and 

<math display="inline" id="Square_root_of_a_matrix:57">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 commute, the matrix 

<math display="inline" id="Square_root_of_a_matrix:58">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>+</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>L</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L+M
  </annotation>
 </semantics>
</math>

 is nilpotent and 

<math display="inline" id="Square_root_of_a_matrix:59">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mo>+</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>L</mi>
      <mo>+</mo>
      <mi>M</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>I</ci>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <ci>L</ci>
      <ci>M</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I+(L+M)/2
  </annotation>
 </semantics>
</math>

 is invertible with inverse given by a <a href="Neumann_series" title="wikilink">Neumann series</a>. Hence <em>L</em> = 

<math display="inline" id="Square_root_of_a_matrix:60">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

.</p>

<p>If 

<math display="inline" id="Square_root_of_a_matrix:61">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is a matrix with positive eigenvalues and <a href="Minimal_polynomial_(linear_algebra)" title="wikilink">minimal polynomial</a> 

<math display="inline" id="Square_root_of_a_matrix:62">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(t)
  </annotation>
 </semantics>
</math>

, then the Jordan decomposition into generalized eigenspaces of 

<math display="inline" id="Square_root_of_a_matrix:63">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 can be deduced from the partial fraction expansion of <mtpl></mtpl>. The corresponding projections onto the generalized eigenspaces are given by real polynomials in 

<math display="inline" id="Square_root_of_a_matrix:64">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

. On each eigenspace, 

<math display="inline" id="Square_root_of_a_matrix:65">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 has the form 

<math display="inline" id="Square_root_of_a_matrix:66">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>I</mi>
     <mo>+</mo>
     <mi>N</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>λ</ci>
    <apply>
     <plus></plus>
     <ci>I</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   λ(I+N)
  </annotation>
 </semantics>
</math>

 as above. The power series expression for the square root on the eigenspace show that the principal square root of 

<math display="inline" id="Square_root_of_a_matrix:67">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 has the form <em>q</em>(<em>A</em>) where <em>q</em>(<em>t</em>) is a polynomial with real coefficients.</p>
<h3 id="by-denmanbeavers-iteration">By Denman–Beavers iteration</h3>

<p>Another way to find the square root of an <em>n</em> × <em>n</em> matrix <em>A</em> is the Denman–Beavers square root iteration.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>Let <em>Y</em><sub>0</sub> = <em>A</em> and <em>Z</em><sub>0</sub> = <em>I</em>, where <em>I</em> is the <em>n</em> × <em>n</em> <a href="identity_matrix" title="wikilink">identity matrix</a>. The iteration is defined by</p>

<p>

<math display="inline" id="Square_root_of_a_matrix:68">
 <semantics>
  <msub>
   <mi>Y</mi>
   <mrow>
    <mi>k</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Y</ci>
    <apply>
     <plus></plus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle Y_{k+1}
  </annotation>
 </semantics>
</math>


</p>

<p>As this uses a pair of sequences of matrix inverses whose later elements change comparatively little, only the first elements have a high computational cost since the remainder can be computed from earlier elements with only a few passes of a variant of <a href="Newton's_method" title="wikilink">Newton's method</a> for <a href="Invertible_matrix#Newton's_method" title="wikilink">computing inverses</a>,</p>

<p>

<math display="block" id="Square_root_of_a_matrix:69">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>X</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mn>2</mn>
      <msub>
       <mi>X</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>X</mi>
       <mi>n</mi>
      </msub>
      <mi>B</mi>
      <msub>
       <mi>X</mi>
       <mi>n</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>n</ci>
      </apply>
      <ci>B</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{n+1}=2X_{n}-X_{n}BX_{n}.
  </annotation>
 </semantics>
</math>

</p>

<p>With this, for later values of 

<math display="inline" id="Square_root_of_a_matrix:70">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 one would set 

<math display="inline" id="Square_root_of_a_matrix:71">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <msubsup>
    <mi>Z</mi>
    <mrow>
     <mi>k</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <apply>
       <minus></minus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{0}=Z_{k-1}^{-1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Square_root_of_a_matrix:72">
 <semantics>
  <mrow>
   <mrow>
    <mi>B</mi>
    <mo>=</mo>
    <msub>
     <mi>Z</mi>
     <mi>k</mi>
    </msub>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>B</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Z</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B=Z_{k},
  </annotation>
 </semantics>
</math>


 and then use 

<math display="inline" id="Square_root_of_a_matrix:73">
 <semantics>
  <mrow>
   <msubsup>
    <mi>Z</mi>
    <mi>k</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <msub>
    <mi>X</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{k}^{-1}=X_{n}
  </annotation>
 </semantics>
</math>

 for some small n (perhaps just 1), and similarly for 

<math display="inline" id="Square_root_of_a_matrix:74">
 <semantics>
  <mrow>
   <msubsup>
    <mi>Y</mi>
    <mi>k</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msubsup>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Y</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{k}^{-1}.
  </annotation>
 </semantics>
</math>

</p>

<p>Convergence is not guaranteed, even for matrices that do have square roots, but if the process converges, the matrix 

<math display="inline" id="Square_root_of_a_matrix:75">
 <semantics>
  <msub>
   <mi>Y</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Y</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{k}
  </annotation>
 </semantics>
</math>

 converges quadratically to a square root 

<math display="inline" id="Square_root_of_a_matrix:76">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

<sup>1/2</sup>, while 

<math display="inline" id="Square_root_of_a_matrix:77">
 <semantics>
  <msub>
   <mi>Z</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Z</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z_{k}
  </annotation>
 </semantics>
</math>


 converges to its inverse, 

<math display="inline" id="Square_root_of_a_matrix:78">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

<sup>−1/2</sup>.</p>
<h3 id="by-the-babylonian-method">By the Babylonian method</h3>

<p>Yet another iterative method is obtained by taking the well-known formula of the <a href="Babylonian_method" title="wikilink">Babylonian method</a> for computing the square root of a real number, and applying it to matrices. Let <em>X</em><sub>0</sub> = <em>I</em>, where <em>I</em> is the <a href="identity_matrix" title="wikilink">identity matrix</a>. The iteration is defined by</p>

<p>

<math display="block" id="Square_root_of_a_matrix:79">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>X</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <mstyle displaystyle="false">
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
     </mstyle>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>X</mi>
        <mi>k</mi>
       </msub>
       <mo>+</mo>
       <mrow>
        <mi>A</mi>
        <msubsup>
         <mi>X</mi>
         <mi>k</mi>
         <mrow>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msubsup>
       </mrow>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <ci>A</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{k+1}=\tfrac{1}{2}(X_{k}+AX_{k}^{-1})\,.
  </annotation>
 </semantics>
</math>

 Again, convergence is not guaranteed, but if the process converges, the matrix 

<math display="inline" id="Square_root_of_a_matrix:80">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{k}
  </annotation>
 </semantics>
</math>

 converges quadratically to a square root <em>A</em><sup>1/2</sup>. Compared to Denman–Beavers iteration, an advantage of the Babylonian method is that only one <a href="matrix_inverse" title="wikilink">matrix inverse</a> need be computed per iteration step. On the other hand, as Denman–Beavers iteration uses a pair of sequences of matrix inverses whose later elements change comparatively little, only the first elements have a high computational cost since the remainder can be computed from earlier elements with only a few passes of a variant of <a href="Newton's_method" title="wikilink">Newton's method</a> for <a href="Invertible_matrix#Newton's_method" title="wikilink">computing inverses</a> (see <a href="Square_root_of_a_matrix#Denman–Beavers_iteration" title="wikilink">Denman–Beavers iteration</a> above); of course, the same approach can be used to get the single sequence of inverses needed for the Babylonian method. However, unlike Denman–Beavers iteration, the Babylonian method is numerically unstable and more likely to fail to converge.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="square-roots-of-positive-operators">Square roots of positive operators</h2>

<p>In <a href="linear_algebra" title="wikilink">linear algebra</a> and <a href="operator_theory" title="wikilink">operator theory</a>, given a <a href="Bounded_operator" title="wikilink">bounded</a> <a href="positive_semidefinite_matrix" title="wikilink">positive semidefinite operator</a> (a non-negative operator) <em>T</em> on a complex Hilbert space, <em>B</em> is a square root of <em>T</em> if <em>T</em> = <em>B* B</em>, where <em>B*</em> denotes the <a href="Hermitian_adjoint" title="wikilink">Hermitian adjoint</a> of <em>B</em>.  According to the <a href="spectral_theorem" title="wikilink">spectral theorem</a>, the <a href="continuous_functional_calculus" title="wikilink">continuous functional calculus</a> can be applied to obtain an operator <em>T</em><sup>½</sup> such that <em>T</em><sup>½</sup> is itself positive and (<em>T</em><sup>½</sup>)<sup>2</sup> = <em>T</em>. The operator <em>T</em><sup>½</sup> is the <strong>unique non-negative square root</strong> of <em>T</em>. </p>

<p>A bounded non-negative operator on a complex Hilbert space is self adjoint by definition. So <em>T</em> = (<em>T</em><sup>½</sup>)* <em>T</em><sup>½</sup>. Conversely, it is trivially true that every operator of the form <em>B* B</em> is non-negative. Therefore, an operator <em>T</em> is non-negative <a href="if_and_only_if" title="wikilink">if and only if</a> <em>T</em> = <em>B* B</em> for some <em>B</em> (equivalently, <em>T</em> = <em>CC*</em> for some <em>C</em>).</p>

<p>The <a href="Cholesky_factorization" title="wikilink">Cholesky factorization</a> provides another particular example of square root, which should not be confused with the unique non-negative square root.</p>
<h3 id="unitary-freedom-of-square-roots">Unitary freedom of square roots</h3>

<p>If <em>T</em> is a non-negative operator on a finite-dimensional Hilbert space, then all square roots of <em>T</em> are related by unitary transformations. More precisely, if <em>T</em> = <em>A*A</em> = <em>B*B</em>, then there exists a <a href="Unitary_matrix" title="wikilink">unitary</a> <em>U</em> such that <em>A</em> = <em>UB</em>.</p>

<p>Indeed, take <em>B</em> = <em>T</em><sup>½</sup> to be the unique non-negative square root of <em>T</em>. If <em>T</em> is strictly positive, then <em>B</em> is invertible, and so <mtpl></mtpl> is unitary:</p>

<p>

<math display="inline" id="Square_root_of_a_matrix:81">
 <semantics>
  <mrow>
   <msup>
    <mi>U</mi>
    <mo>*</mo>
   </msup>
   <mi>U</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>U</ci>
     <times></times>
    </apply>
    <ci>U</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle U^{*}U
  </annotation>
 </semantics>
</math>


</p>

<p>If <em>T</em> is non-negative without being strictly positive, then the inverse of <em>B</em> cannot be defined, but the <a href="Moore–Penrose_pseudoinverse" title="wikilink">Moore–Penrose pseudoinverse</a> <em>B</em><sup>+</sup> can be. In that case, the operator <mtpl></mtpl> is a <a href="partial_isometry" title="wikilink">partial isometry</a>, that is, a unitary operator from the range of <em>T</em> to itself. This can then be extended to a unitary operator <em>U</em> on the whole space by setting it equal to the identity on the kernel of <em>T</em>. More generally, this is true on an infinite-dimensional Hilbert space if, in addition, <em>T</em> has <a href="closed_range_theorem" title="wikilink">closed range</a>. In general, if <em>A</em>, <em>B</em> are <a href="unbounded_operator" title="wikilink">closed and densely defined operators</a> on a Hilbert space <em>H</em>, and <em>A* A</em> = <em>B* B</em>, then <em>A = UB</em> where <em>U</em> is a partial isometry.</p>
<h3 id="some-applications">Some applications</h3>

<p>Square roots, and the unitary freedom of square roots, have applications throughout functional analysis and linear algebra.</p>
<h4 id="polar-decomposition">Polar decomposition</h4>

<p>If <em>A</em> is an invertible operator on a finite-dimensional Hilbert space, then there is a unique unitary operator <em>U</em> and positive operator <em>P</em> such that</p>

<p>

<math display="block" id="Square_root_of_a_matrix:82">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>=</mo>
    <mrow>
     <mi>U</mi>
     <mi>P</mi>
    </mrow>
   </mrow>
   <mo>;</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>U</ci>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=UP;\,
  </annotation>
 </semantics>
</math>

 this is the polar decomposition of <em>A</em>. The positive operator <em>P</em> is the unique positive square root of the positive operator <em>A</em><sup>∗</sup><em>A</em>, and <em>U</em> is defined by <mtpl></mtpl>.</p>

<p>If <em>A</em> is not invertible, then it still has a polar composition in which <em>P</em> is defined in the same way (and is unique). The unitary operator <em>U</em> is not unique. Rather it is possible to determine a "natural" unitary operator as follows: <em>AP</em><sup>+</sup> is a unitary operator from the range of <em>A</em> to itself, which can be extended by the identity on the kernel of <em>A</em><sup>∗</sup>. The resulting unitary operator <em>U</em> then yields the polar decomposition of <em>A</em>.</p>
<h4 id="kraus-operators">Kraus operators</h4>

<p>By Choi's result, a linear map</p>

<p>

<math display="block" id="Square_root_of_a_matrix:83">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>C</mi>
     <mrow>
      <mi>n</mi>
      <mo>×</mo>
      <mi>n</mi>
     </mrow>
    </msup>
    <mo>→</mo>
    <msup>
     <mi>C</mi>
     <mrow>
      <mi>m</mi>
      <mo>×</mo>
      <mi>m</mi>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>normal-Φ</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>C</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>C</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi:C^{n\times n}\rightarrow C^{m\times m}
  </annotation>
 </semantics>
</math>

</p>

<p>is completely positive if and only if it is of the form</p>

<p>

<math display="block" id="Square_root_of_a_matrix:84">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
     <mi>k</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>V</mi>
      <mi>i</mi>
     </msub>
     <mi>A</mi>
     <msubsup>
      <mi>V</mi>
      <mi>i</mi>
      <mo>*</mo>
     </msubsup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Φ</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>i</ci>
      </apply>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>V</ci>
        <ci>i</ci>
       </apply>
       <times></times>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(A)=\sum_{i}^{k}V_{i}AV_{i}^{*}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>k</em> ≤ <em>nm</em>. Let {<em>E<sub>p q</sub></em>} ⊂ <strong>C</strong><sup><em>n</em> × <em>n</em></sup> be the <em>n</em><sup>2</sup> elementary matrix units. The positive matrix</p>

<p>

<math display="block" id="Square_root_of_a_matrix:85">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mi mathvariant="normal">Φ</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi mathvariant="normal">Φ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>E</mi>
        <mrow>
         <mi>p</mi>
         <mi>q</mi>
        </mrow>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>p</mi>
     <mi>q</mi>
    </mrow>
   </msub>
   <mo>∈</mo>
   <msup>
    <mi>C</mi>
    <mrow>
     <mrow>
      <mrow>
       <mi>n</mi>
       <mi>m</mi>
      </mrow>
      <mo>×</mo>
      <mi>n</mi>
     </mrow>
     <mi>m</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>normal-Φ</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <times></times>
       <ci>normal-Φ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <apply>
         <times></times>
         <ci>p</ci>
         <ci>q</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>C</ci>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <apply>
         <times></times>
         <ci>n</ci>
         <ci>m</ci>
        </apply>
        <ci>n</ci>
       </apply>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{\Phi}=(\Phi(E_{pq}))_{pq}\in C^{nm\times nm}
  </annotation>
 </semantics>
</math>

</p>

<p>is called the <em>Choi matrix</em> of Φ. The Kraus operators correspond to the, not necessarily square, square roots of <em>M</em><sub>Φ</sub>: For any square root <em>B</em> of <em>M</em><sub>Φ</sub>, one can obtain a family of Kraus operators <em>V<sub>i</sub></em> by undoing the Vec operation to each column <em>b<sub>i</sub></em> of <em>B</em>. Thus all sets of Kraus operators are related by partial isometries.</p>
<h4 id="mixed-ensembles">Mixed ensembles</h4>

<p>In quantum physics, a density matrix for an <em>n</em>-level quantum system is an <em>n</em> × <em>n</em> complex matrix <em>ρ</em> that is positive semidefinite with trace 1. If <em>ρ</em> can be expressed as</p>

<p>

<math display="block" id="Square_root_of_a_matrix:86">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>i</mi>
    </munder>
    <mrow>
     <msub>
      <mi>p</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>v</mi>
      <mi>i</mi>
     </msub>
     <msubsup>
      <mi>v</mi>
      <mi>i</mi>
      <mo>*</mo>
     </msubsup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ρ</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>v</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <ci>i</ci>
       </apply>
       <times></times>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho=\sum_{i}p_{i}v_{i}v_{i}^{*}
  </annotation>
 </semantics>
</math>

</p>

<p>where ∑ <em>p<sub>i</sub></em> = 1, the set</p>

<p>

<math display="block" id="Square_root_of_a_matrix:87">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>p</mi>
    <mi>i</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mo rspace="4.2pt" stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{p_{i},v_{i}\}\,
  </annotation>
 </semantics>
</math>

</p>

<p>is said to be an <strong>ensemble</strong> that describes the mixed state <em>ρ</em>. Notice {<em>v<sub>i</sub></em>} is not required to be orthogonal. Different ensembles describing the state <em>ρ</em> are related by unitary operators, via the square roots of <em>ρ</em>. For instance, suppose</p>

<p>

<math display="block" id="Square_root_of_a_matrix:88">
 <semantics>
  <mrow>
   <mrow>
    <mi>ρ</mi>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>j</mi>
     </munder>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>j</mi>
      </msub>
      <msubsup>
       <mi>a</mi>
       <mi>j</mi>
       <mo>*</mo>
      </msubsup>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ρ</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>j</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>j</ci>
       </apply>
       <times></times>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho=\sum_{j}a_{j}a_{j}^{*}.
  </annotation>
 </semantics>
</math>

</p>

<p>The trace 1 condition means</p>

<p>

<math display="block" id="Square_root_of_a_matrix:89">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>j</mi>
    </munder>
    <mrow>
     <msubsup>
      <mi>a</mi>
      <mi>j</mi>
      <mo>*</mo>
     </msubsup>
     <msub>
      <mi>a</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>j</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>j</ci>
       </apply>
       <times></times>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <cn type="float">1.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{j}a_{j}^{*}a_{j}=1.
  </annotation>
 </semantics>
</math>

</p>

<p>Let</p>

<p>

<math display="block" id="Square_root_of_a_matrix:90">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mi>a</mi>
      <mi>i</mi>
      <mo>*</mo>
     </msubsup>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
      <times></times>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i}=a_{i}^{*}a_{i},
  </annotation>
 </semantics>
</math>

</p>

<p>and <em>v<sub>i</sub></em> be the normalized <em>a<sub>i</sub></em>. We see that</p>

<p>

<math display="block" id="Square_root_of_a_matrix:91">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>p</mi>
    <mi>i</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>v</mi>
    <mi>i</mi>
   </msub>
   <mo rspace="4.2pt" stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>v</ci>
     <ci>i</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{p_{i},v_{i}\}\,
  </annotation>
 </semantics>
</math>

</p>

<p>gives the mixed state <em>ρ</em>.</p>
<h4 id="unscented-kalman-filter">Unscented Kalman Filter</h4>

<p>In the Unscented Kalman Filter (UKF),<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> the square root of the state error <a href="covariance_matrix" title="wikilink">covariance matrix</a> is required for the <a href="unscented_transform" title="wikilink">unscented transform</a> which is the statistical linearization method used. A comparison between different matrix square root calculation methods within a UKF application of GPS/INS sensor fusion was presented, which indicated that the <a href="Cholesky_decomposition" title="wikilink">Cholesky decomposition</a> method was best suited for UKF applications.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Matrix_function" title="wikilink">Matrix function</a></li>
<li><a href="Holomorphic_functional_calculus" title="wikilink">Holomorphic functional calculus</a></li>
<li><a href="Logarithm_of_a_matrix" title="wikilink">Logarithm of a matrix</a></li>
<li><a href="Sylvester's_formula" title="wikilink">Sylvester's formula</a></li>
<li><a href="2_×_2_real_matrices#Functions_of_2_×_2_real_matrices" title="wikilink">2 × 2 real matrices#Functions of 2 × 2 real matrices</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li></li>
<li>

<p>, Chapter IV, Reisz functional calculus</p></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Matrix_theory" title="wikilink">Category:Matrix theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">Mitchell, Douglas W. "Using Pythagorean triples to generate square roots of <em>I</em><sub>2</sub>". <em><a href="The_Mathematical_Gazette" title="wikilink">The Mathematical Gazette</a></em> 87, November 2003, 499-500.<a href="#fnref2">↩</a></li>
<li id="fn3">; <a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
