<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="229">Envelope detector</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Envelope detector</h1>
<hr/>

<p> </p>

<p>An <strong>envelope detector</strong> is an electronic circuit that takes a high-frequency signal as input and provides an output which is the <a href="Envelope_(waves)" title="wikilink">envelope</a> of the original signal. The <a class="uri" href="capacitor" title="wikilink">capacitor</a> in the circuit stores up charge on the rising edge, and releases it slowly through the <a class="uri" href="resistor" title="wikilink">resistor</a> when the signal falls. The diode in series <a href="Rectifier" title="wikilink">rectifies</a> the incoming signal, allowing current flow only when the positive input terminal is at a higher potential than the negative input terminal.</p>

<p>Most practical envelope detectors use either half-wave or full-wave <a href="Rectifier" title="wikilink">rectification</a> of the signal to convert the <a href="Alternating_current" title="wikilink">AC</a> audio input into a pulsed <a href="Direct_current" title="wikilink">DC</a> signal. <a href="Electronic_filter" title="wikilink">Filtering</a> is then used to smooth the final result. This filtering is rarely perfect and some "ripple" is likely to remain on the envelope follower output, particularly for low frequency inputs such as notes from a bass guitar. More filtering gives a smoother result, but decreases the responsiveness; thus, real-world designs must be optimized for the application.</p>
<h2 id="definition-of-the-envelope">Definition of the envelope</h2>

<p>Any <a href="amplitude_modulation" title="wikilink">AM</a> or <a href="frequency_modulation" title="wikilink">FM</a> signal 

<math display="inline" id="Envelope_detector:0">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(t)
  </annotation>
 </semantics>
</math>

 can be written in the following form</p>

<p>

<math display="block" id="Envelope_detector:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>cos</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>ω</mi>
        <mi>t</mi>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>ϕ</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>t</ci>
     <apply>
      <cos></cos>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>ω</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <times></times>
        <ci>ϕ</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(t)=R(t)\cos(\omega t+\phi(t))\,
  </annotation>
 </semantics>
</math>

</p>

<p>In the case of AM, φ(<em>t</em>) (the phase component of the signal) is constant and can be ignored. In AM, the carrier frequency 

<math display="inline" id="Envelope_detector:2">
 <semantics>
  <mi>ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega
  </annotation>
 </semantics>
</math>

 is also constant. Thus, all the information in the AM signal is in <em>R</em>(<em>t</em>). <em>R</em>(<em>t</em>) is called the <strong>envelope</strong> of the signal. Hence an AM signal is given by the function</p>

<p>

<math display="block" id="Envelope_detector:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>C</mi>
      <mo>+</mo>
      <mrow>
       <mi>m</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>cos</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>ω</mi>
       <mi>t</mi>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>C</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <cos></cos>
      <apply>
       <times></times>
       <ci>ω</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(t)=(C+m(t))\cos(\omega t)\,
  </annotation>
 </semantics>
</math>

 with <em>m</em>(<em>t</em>) representing the original audio frequency message, <em>C</em> the carrier amplitude and <em>R</em>(<em>t</em>) equal to <em>C</em> + <em>m</em>(<em>t</em>). So, if the envelope of the AM signal can be extracted, the original message can be recovered.</p>

<p>In the case of FM, the transmitted signal 

<math display="inline" id="Envelope_detector:4">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(t)
  </annotation>
 </semantics>
</math>

 has a <a href="constant_envelope" title="wikilink">constant envelope</a> <em>R</em>(<em>t</em>) = R and can be ignored. However, many FM receivers measure the envelope anyway for <a href="received_signal_strength_indication" title="wikilink">received signal strength indication</a>.</p>
<h2 id="diode-detector">Diode detector</h2>

<p>The simplest form of envelope detector is the <strong><a href="diode_detector" title="wikilink">diode detector</a></strong> which is shown above. A diode detector is simply a <a class="uri" href="diode" title="wikilink">diode</a> between the input and output of a circuit, connected to a resistor and capacitor in parallel from the output of the circuit to the ground. If the resistor and capacitor are correctly chosen, the output of this circuit should approximate a voltage-shifted version of the original (<a class="uri" href="baseband" title="wikilink">baseband</a>) signal. A simple filter can then be applied to filter out the DC component.</p>
<h2 id="precision-detector">Precision detector</h2>

<p>An envelope detector can also be constructed to use a <strong><a href="precision_rectifier" title="wikilink">precision rectifier</a></strong> feeding into a <a href="low-pass_filter" title="wikilink">low-pass filter</a>.</p>
<h2 id="drawbacks">Drawbacks</h2>

<p>The envelope detector has several drawbacks:</p>
<ul>
<li>The input to the detector must be <a href="band-pass_filter" title="wikilink">band-pass filtered</a> around the desired signal, or else the detector will simultaneously demodulate several signals. The filtering can be done with a tunable filter or, more practically, a <a href="superheterodyne_receiver" title="wikilink">superheterodyne receiver</a></li>
<li>It is more susceptible to noise than a <a href="product_detector" title="wikilink">product detector</a></li>
<li>If the signal is <a href="overmodulation" title="wikilink">overmodulated</a>, distortion will occur</li>
</ul>

<p>Most of these drawbacks are relatively minor and are usually acceptable tradeoffs for the simplicity and low cost of using an envelope detector.</p>
<h2 id="demodulation-of-signals">Demodulation of signals</h2>

<p>An envelope detector can be used to <a class="uri" href="demodulate" title="wikilink">demodulate</a> a previously modulated signal by removing all high frequency components of the signal. The capacitor and resistor form a low-pass filter to filter out the carrier frequency. Such a device is often used to demodulate AM radio signals because the envelope of the modulated signal is equivalent to the <a class="uri" href="baseband" title="wikilink">baseband</a> signal.</p>
<h2 id="audio">Audio</h2>

<p>An envelope detector is sometimes referred to as an <strong>envelope follower</strong> in <a href="music" title="wikilink">musical</a> environments. It is still used to detect the <a class="uri" href="amplitude" title="wikilink">amplitude</a> variations of an incoming signal to produce a control signal that resembles those variations. However, in this case the input signal is made up of audible frequencies.</p>

<p>Envelope detectors are often a component of other circuits, such as a <a href="Audio_level_compression" title="wikilink">compressor</a> or an <a class="uri" href="auto-wah" title="wikilink">auto-wah</a> or envelope-followed filter. In these circuits, the envelope follower is part of what is known as the "<a href="Side_chain_(sound)" title="wikilink">side chain</a>", a circuit which describes some characteristic of the input, in this case its volume.</p>

<p>Both <a href="Dynamic_range_compression" title="wikilink">expanders</a> and <a href="Audio_level_compression" title="wikilink">compressors</a> use the envelope's output voltage to control the gain of an amplifier. Auto-wah uses the voltage to control the <a href="cutoff_frequency" title="wikilink">cutoff frequency</a> of a filter. The <a href="voltage-controlled_filter" title="wikilink">voltage-controlled filter</a> of an <a href="analog_synthesizer" title="wikilink">analog synthesizer</a> is a similar circuit.</p>

<p>Modern envelope followers can be implemented:</p>
<ol>
<li>directly as <a href="electronic_hardware" title="wikilink">electronic hardware</a>,</li>
<li>indirectly using <a href="Digital_signal_processor" title="wikilink">DSPs</a></li>
<li>completely virtually in <a class="uri" href="software" title="wikilink">software</a>.</li>
</ol>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Analytic_signal" title="wikilink">Analytic signal</a></li>
<li><a href="ADSR_envelope" title="wikilink">Attack-decay-sustain-release envelope</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="see-also-1">See also</h2>
<ul>
<li><a href="http://seniord.ee.iastate.edu/SSOL/RADAR/prjpln99/detector3.html">Envelope detector</a></li>
<li><a href="http://www.ele.uri.edu/Courses/ele436/labs/expA4.pdf">Envelope and envelope recovery</a></li>
</ul>

<p>"</p>

<p><a href="Category:Electronic_music" title="wikilink">Category:Electronic music</a> <a href="Category:Audio_engineering" title="wikilink">Category:Audio engineering</a> <a href="Category:Communication_circuits" title="wikilink">Category:Communication circuits</a> <a class="uri" href="Category:Detectors" title="wikilink">Category:Detectors</a> <a class="uri" href="Category:Demodulation" title="wikilink">Category:Demodulation</a></p>
</body>
</html>
