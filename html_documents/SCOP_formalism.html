<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1178">SCOP formalism</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>SCOP formalism</h1>
<hr/>
<h2 id="state-context-property-scop-formalism">State COntext Property (SCOP) formalism</h2>

<p>Our minds are able to construct a multitude of imaginary, hypothetical, or counterfactual deviations from the more prototypical states of particular concept, and the State COntext Property (SCOP) can model this. The SCOP formalism was inspired by the need to incorporate the effect of context into the formal description of a concept. It builds on an operational approach in the foundations of quantum mechanics in which a physical system is determined by the mathematical structure of its set of states, set of properties, the possible (measurement) contexts which can be applied to this entity, and the relations between these sets. The SCOP formalism is part of a longstanding effort to develop an operational approach to quantum mechanics known as the Geneva-Brussels approach.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> With SCOP it is possible to describe situations with any degree of contextuality. In fact, classical an quantum come out as special cases: quantum at the one end of extreme contextuality and classical at the other end of extreme lack of contextuality.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The SCOP formalism permits one to describe not only physical or conceptual entities, but also potential entities of a more abstract nature,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> which means that SCOP aims at a very general description of how the interaction between context and the state of an entity plays a fundamental role in its evolution.</p>
<h2 id="scop-entities">SCOP entities</h2>

<p>The description of SCOP entities seeks for a general description of an <em>observable</em>entity that evolves with time. Thus, the description of the entity needs to consider the different <em>states</em> that the entity can assume. In order to establish the differences among the states, we need to consider the <em>properties</em> that the states can hold. Note that a complete description of the states in terms of their properties requires that each state must hold a different properties, but in principle this is not the case. In order to <em>observe</em> the entity, we need a mechanism that permits us to measure properties on the states, i.e. there must exist a set of useful measurements or <em>contexts</em> that permits us to <em>observe</em> what properties are hold by the current state the entity. However, the context can affect the state of the entity, and change its state (this is well known as the <a href="Probe_effect" title="wikilink">observer effect</a>).</p>

<p>Formally, a SCOP entity consists of a 5-tuple 

<math display="inline" id="SCOP_formalism:0">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi mathvariant="normal">Σ</mi>
   <mo>,</mo>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\Mu</mtext>
   </merror>
   <mo>,</mo>
   <mi>L</mi>
   <mo>,</mo>
   <mi>μ</mi>
   <mo>,</mo>
   <mi>ν</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>normal-Σ</ci>
    <mtext>\Mu</mtext>
    <ci>L</ci>
    <ci>μ</ci>
    <ci>ν</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Sigma,\Mu,\mathit{L},\mu,\nu)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="SCOP_formalism:1">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

 represents the set of <em>states</em> that the entity can assume, 

<math display="inline" id="SCOP_formalism:2">
 <semantics>
  <merror class="ltx_ERROR undefined undefined">
   <mtext>\Mu</mtext>
  </merror>
  <annotation-xml encoding="MathML-Content">
   <mtext>\Mu</mtext>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Mu
  </annotation>
 </semantics>
</math>

 represents a set of <em>contexts</em> (measurements), 

<math display="inline" id="SCOP_formalism:3">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathit{L}
  </annotation>
 </semantics>
</math>


 represents a set of properties that the entity can hold, 

<math display="inline" id="SCOP_formalism:4">
 <semantics>
  <mrow>
   <mi>μ</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi mathvariant="normal">Σ</mi>
      <mo>×</mo>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\Mu</mtext>
      </merror>
      <mo>×</mo>
      <mi mathvariant="normal">Σ</mi>
     </mrow>
     <mo>→</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo rspace="5.8pt">,</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>p</mi>
      <mo>,</mo>
      <mi>e</mi>
      <mo>,</mo>
      <mi>q</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>↦</mo>
     <mrow>
      <mi>μ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>p</mi>
       <mo>,</mo>
       <mi>e</mi>
       <mo>,</mo>
       <mi>q</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>μ</ci>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <times></times>
       <ci>normal-Σ</ci>
       <mtext>\Mu</mtext>
       <ci>normal-Σ</ci>
      </apply>
      <interval closure="closed">
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </interval>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <vector>
       <ci>p</ci>
       <ci>e</ci>
       <ci>q</ci>
      </vector>
      <apply>
       <times></times>
       <ci>μ</ci>
       <vector>
        <ci>p</ci>
        <ci>e</ci>
        <ci>q</ci>
       </vector>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu:\Sigma\times\Mu\times\Sigma\to[0,1],~{}(p,e,q)\mapsto\mu(p,e,q)
  </annotation>
 </semantics>
</math>

 is a <em>state-transition probability function</em> that represents the likelihood to transition from the state 

<math display="inline" id="SCOP_formalism:5">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 to the state 

<math display="inline" id="SCOP_formalism:6">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 under the influence of the context 

<math display="inline" id="SCOP_formalism:7">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="SCOP_formalism:8">
 <semantics>
  <mrow>
   <mi>ν</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi mathvariant="normal">Σ</mi>
      <mo>×</mo>
      <mi>L</mi>
     </mrow>
     <mo>→</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo rspace="5.8pt">,</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>p</mi>
      <mo>,</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>↦</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>ν</ci>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <times></times>
       <ci>normal-Σ</ci>
       <ci>L</ci>
      </apply>
      <interval closure="closed">
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </interval>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <interval closure="open">
       <ci>p</ci>
       <ci>a</ci>
      </interval>
      <interval closure="closed">
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu:\Sigma\times\mathit{L}\to[0,1],~{}(p,a)\mapsto[0,1]
  </annotation>
 </semantics>
</math>


 is an <em>property-applicability function</em> that estimates how applicable is the property 

<math display="inline" id="SCOP_formalism:9">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 to the state 

<math display="inline" id="SCOP_formalism:10">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 of the entity.</p>
<h2 id="special-states-and-contexts">Special states and contexts</h2>

<p>It is possible to identify relations among the states and contexts, that recall the basic elements of the quantum formalism:</p>
<h3 id="unitary-context-and-ground-state">Unitary context and ground state</h3>

<p>It is possible that the entity is in a situation of <em>no contextual influence</em>. We identify such situation by the <em>unitary context</em>, denoted by 

<math display="inline" id="SCOP_formalism:11">
 <semantics>
  <mn>𝟏</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{1}
  </annotation>
 </semantics>
</math>

. Moreover, the state of the entity in this situation is identified by the <em>ground state</em> 

<math display="inline" id="SCOP_formalism:12">
 <semantics>
  <mover accent="true">
   <mi>p</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{p}
  </annotation>
 </semantics>
</math>

. We have that 

<math display="inline" id="SCOP_formalism:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>μ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>p</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mo>,</mo>
     <mn>𝟏</mn>
     <mo>,</mo>
     <mover accent="true">
      <mi>p</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>μ</ci>
     <vector>
      <apply>
       <ci>normal-^</ci>
       <ci>p</ci>
      </apply>
      <cn type="integer">1</cn>
      <apply>
       <ci>normal-^</ci>
       <ci>p</ci>
      </apply>
     </vector>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu(\hat{p},\mathbf{1},\hat{p})=1
  </annotation>
 </semantics>
</math>


, and thus 

<math display="inline" id="SCOP_formalism:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>μ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo>,</mo>
     <mn>𝟏</mn>
     <mo>,</mo>
     <mover accent="true">
      <mi>p</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>μ</ci>
     <vector>
      <ci>p</ci>
      <cn type="integer">1</cn>
      <apply>
       <ci>normal-^</ci>
       <ci>p</ci>
      </apply>
     </vector>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu(p,\mathbf{1},\hat{p})=1
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="SCOP_formalism:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mo>∈</mo>
    <mi mathvariant="normal">Σ</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>p</mi>
    <mo>≠</mo>
    <mover accent="true">
     <mi>p</mi>
     <mo stretchy="false">^</mo>
    </mover>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <ci>p</ci>
     <ci>normal-Σ</ci>
    </apply>
    <apply>
     <neq></neq>
     <ci>p</ci>
     <apply>
      <ci>normal-^</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\in\Sigma,p\neq\hat{p}
  </annotation>
 </semantics>
</math>

.</p>

<p>Thus, the interaction of the entity with any context different from the unitary context will lead to an evolutionary process of the state's entity.</p>
<h3 id="eigenstates-and-potentiality">Eigenstates and potentiality</h3>

<p>If for some context 

<math display="inline" id="SCOP_formalism:16">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 there is an state 

<math display="inline" id="SCOP_formalism:17">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="SCOP_formalism:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>μ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo>,</mo>
     <mi>e</mi>
     <mo>,</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>μ</ci>
     <vector>
      <ci>p</ci>
      <ci>e</ci>
      <ci>p</ci>
     </vector>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu(p,e,p)=1
  </annotation>
 </semantics>
</math>


, we say 

<math display="inline" id="SCOP_formalism:19">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is an <em>eigenstate</em> for the context 

<math display="inline" id="SCOP_formalism:20">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

. Any state 

<math display="inline" id="SCOP_formalism:21">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 that is not an eigenstate, it is referred to as <em>potential state</em>.</p>
<h2 id="order-theory-and-scop">Order theory and SCOP</h2>

<p>It is possible to describe the elements of SCOP using <a href="Order_theory" title="wikilink">order-theoretic</a> structures. In<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> it has been shown how to obtain a pre-ordered set of states and properties. In<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> it is shown that the set of contexts and properties can be equipped with an orthocomplemented lattice structure. By imposing axioms on the order-theoretical structures of the former elements of a SCOP entity it is possible, via representation theoretical techniques, to obtain the Hilbert space description of the entity.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="scop-concepts">SCOP concepts</h2>

<p>The SCOP approach to concepts belongs to the emergent field of <a href="quantum_cognition" title="wikilink">quantum cognition</a>. In a SCOP model of a concept we are able to incorporate all of the possible contexts that could influence the state of a concept. The more states and contexts included, the richer the model becomes. The level of refinement is determined by the role the model is expected to play. It is outstanding that in SCOP, unlike other mathematical models of concepts, the potential to include this richness is present in the formalism, i.e., it can incorporate even improbable states, and largely but not completely irrelevant contexts. The SCOP formalism has been successfully applied to model conceptual entities.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> It has been used shown how to solve the inconsistencies of other mathematical model of concepts,<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> and at the same time it permits to join different perspectives coming from psychology and phylosophy.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h3 id="contextual-dependence">Contextual dependence</h3>

<p>Early concept theorists such <a href="Eleanor_Rosch" title="wikilink">Eleanor Rosch</a> have noted that the context in which a concept is elicited plays a fundamental role in the meaning that it takes in natural reasoning tasks such as learning or planning. While in some theories, such as <a href="Peter_Gärdenfors" title="wikilink">Gärdenfors</a> or Nosofsky theories of concepts, the context is modeled as a weighting function across attributes or properties, in SCOP any effect of context occurs by way of its effect on the state.</p>
<h3 id="typicality-membership-and-similarity">Typicality, membership and similarity</h3>

<p>Many researchers in concepts such as Hampton, <a href="Hans_Kamp" title="wikilink">Kamp</a> and <a href="Barbara_Partee" title="wikilink">Partee</a>, Osherson and Smith, among others, have noticed that measures of typicality and membership in concepts are not equivalent. Typicality refers to how common or representative is an instance of a concept. Membership rather than measure representativeness only measures the allegiance or inclusiveness of a conceptual instances in the category determined by the concept. It is well known that both measures are context-dependent, and they have been related to the notion of similarity of concepts, in that <em>concept-similarity</em> would be a more fundamental notion and will imply determine their values. But no satisfactory mathematical theory of concept-similarity has been developed yet. In SCOP, similarity, membership, typicality, and any other measure, is modeled as a <em>measurement-operator</em> that acts on the state of the concept, in the same way as context do. This general manner of approach the measurement of quantities that permits to differentiate states are called "experiment-contexts".</p>
<h3 id="concept-combination-and-emergence">Concept combination and emergence</h3>

<p>The emergence of meaning when concepts are combined is at the core of the drawbacks in concept theories. For example, it has been shown that <em>guppy</em> is not a typical instance neither of concept PET or concept FISH, but is a highly typical instance of the combined concept PET-FISH. It has been proven that no logical-based approach can explain the ways these effects in concept combination.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> The SCOP-based approach to concepts has been shown to model the concept combination in a satisfactory manner, by embedding the states of the combined concept in tensor space formed by the Hilbert spaces representing each concept.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Cognitive_architecture" title="wikilink">Category:Cognitive architecture</a> <a href="Category:Quantum_information_theory" title="wikilink">Category:Quantum information theory</a> <a href="Category:Quantum_models" title="wikilink">Category:Quantum models</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
</ol>
</section>
</body>
</html>
