<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="637">Splitting circle method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Splitting circle method</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, the <strong>splitting circle method</strong> is a <a href="numerical_analysis" title="wikilink">numerical algorithm</a> for the numerical factorization of a <a class="uri" href="polynomial" title="wikilink">polynomial</a> and, ultimately, for finding its <a href="complex_number" title="wikilink">complex</a> <a href="Root_of_a_function" title="wikilink">roots</a>. It was introduced by <a href="Arnold_Schönhage" title="wikilink">Arnold Schönhage</a> in his 1982 paper <em>The fundamental theorem of algebra in terms of computational complexity</em> (Technical report, Mathematisches Institut der Universität Tübingen). A revised algorithm was presented by <a href="Victor_Pan" title="wikilink">Victor Pan</a> in 1998. An implementation was provided by <a href="Xavier_Gourdon" title="wikilink">Xavier Gourdon</a> in 1996 for the <a href="Magma_computer_algebra_system" title="wikilink">Magma</a> and <a class="uri" href="PARI/GP" title="wikilink">PARI/GP</a> computer algebra systems.</p>
<h2 id="general-description">General description</h2>

<p>The fundamental idea of the <strong>splitting circle method</strong> is to use methods of <a href="complex_analysis" title="wikilink">complex analysis</a>, more precisely the <a href="residue_theorem" title="wikilink">residue theorem</a>, to construct factors of polynomials. With those methods it is possible to construct a factor of a given polynomial 

<math display="inline" id="Splitting_circle_method:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mi>n</mi>
    </msup>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>p</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msup>
      <mi>x</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <msub>
     <mi>p</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)=x^{n}+p_{n-1}x^{n-1}+\cdots+p_{0}
  </annotation>
 </semantics>
</math>

 for any region of the complex plane with a piecewise smooth boundary. Most of those factors will be trivial, that is constant polynomials. Only regions that contain roots of <em>p(x)</em> result in nontrivial factors that have exactly those roots of <em>p(x)</em> as their own roots, preserving multiplicity.</p>

<p>In the numerical realization of this method one uses disks <em>D</em>(<em>c</em>,<em>r</em>) (center <em>c</em>, radius <em>r</em>) in the complex plane as regions. The boundary circle of a disk splits the set of roots of <em>p</em>(<em>x</em>) in two parts, hence the name of the method. To a given disk one computes approximate factors following the analytical theory and refines them using <a href="Newton's_method" title="wikilink">Newton's method</a>. To avoid numerical instability one has to demand that all roots are well separated from the boundary circle of the disk. So to obtain a good splitting circle it should be embedded in a root free annulus <em>A</em>(<em>c</em>,<em>r</em>,<em>R</em>) (center <em>c</em>, inner radius <em>r</em>, outer radius <em>R</em>) with a large relative width <em>R/r</em>.</p>

<p>Repeating this process for the factors found, one finally arrives at an approximative factorization of the polynomial at a required precision. The factors are either linear polynomials representing well isolated zeros or higher order polynomials representing clusters of zeros.</p>
<h2 id="details-of-the-analytical-construction">Details of the analytical construction</h2>

<p><a href="Newton's_identities" title="wikilink">Newton's identities</a> are a bijective relation between the <a href="elementary_symmetric_polynomial" title="wikilink">elementary symmetric polynomials</a> of a tuple of complex numbers and its sums of powers. Therefore, it is possible to compute the coefficients of a polynomial</p>

<p>

<math display="block" id="Splitting_circle_method:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mi>n</mi>
    </msup>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>p</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msup>
      <mi>x</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <msub>
     <mi>p</mi>
     <mn>0</mn>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <msub>
       <mi>z</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">⋯</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <msub>
       <mi>z</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)=x^{n}+p_{n-1}x^{n-1}+\cdots+p_{0}=(x-z_{1})\cdots(x-z_{n})
  </annotation>
 </semantics>
</math>

</p>

<p>(or of a factor of it) from the sums of powers of its zeros</p>

<p>

<math display="block" id="Splitting_circle_method:2">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mi>m</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>z</mi>
     <mn>1</mn>
     <mi>m</mi>
    </msubsup>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <msubsup>
     <mi>z</mi>
     <mi>n</mi>
     <mi>m</mi>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>m</ci>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>n</ci>
      </apply>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{m}=z_{1}^{m}+\cdots+z_{n}^{m}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Splitting_circle_method:3">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=0,1,\dots,n
  </annotation>
 </semantics>
</math>

</p>

<p>by solving the triangular system that is obtained by comparing the powers of <em>u</em> in the following identity of <a href="formal_power_series" title="wikilink">formal power series</a></p>

<p>

<math display="block" id="Splitting_circle_method:4">
 <semantics>
  <mrow>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>+</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mn>2</mn>
    </mpadded>
    <mpadded width="+1.7pt">
     <msub>
      <mi>a</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
     </msub>
    </mpadded>
    <mi>u</mi>
   </mrow>
   <mo>+</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>+</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
    <mpadded width="+1.7pt">
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
    </mpadded>
    <msup>
     <mi>u</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>2</mn>
     </mrow>
    </msup>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>n</mi>
    </mpadded>
    <mpadded width="+1.7pt">
     <msub>
      <mi>a</mi>
      <mn>0</mn>
     </msub>
    </mpadded>
    <msup>
     <mi>u</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>u</ci>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>u</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>u</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{n-1}+2\,a_{n-2}\,u+\cdots+(n-1)\,a_{1}\,u^{n-2}+n\,a_{0}\,u^{n-1}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Splitting_circle_method:5">
 <semantics>
  <mrow>
   <mrow>
    <mi></mi>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>+</mo>
        <mrow>
         <mpadded width="+1.7pt">
          <msub>
           <mi>a</mi>
           <mrow>
            <mi>n</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </msub>
         </mpadded>
         <mi>u</mi>
        </mrow>
        <mo>+</mo>
        <mi mathvariant="normal">⋯</mi>
        <mo>+</mo>
        <mrow>
         <mpadded width="+1.7pt">
          <msub>
           <mi>a</mi>
           <mn>1</mn>
          </msub>
         </mpadded>
         <msup>
          <mi>u</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msup>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mpadded width="+1.7pt">
          <msub>
           <mi>a</mi>
           <mn>0</mn>
          </msub>
         </mpadded>
         <msup>
          <mi>u</mi>
          <mi>n</mi>
         </msup>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>⋅</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>t</mi>
         <mn>1</mn>
        </msub>
        <mo>+</mo>
        <mrow>
         <mpadded width="+1.7pt">
          <msub>
           <mi>t</mi>
           <mn>2</mn>
          </msub>
         </mpadded>
         <mi>u</mi>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mpadded width="+1.7pt">
          <msub>
           <mi>t</mi>
           <mn>3</mn>
          </msub>
         </mpadded>
         <msup>
          <mi>u</mi>
          <mn>2</mn>
         </msup>
        </mrow>
        <mo>+</mo>
        <mi mathvariant="normal">…</mi>
        <mo>+</mo>
        <mrow>
         <mpadded width="+1.7pt">
          <msub>
           <mi>t</mi>
           <mi>n</mi>
          </msub>
         </mpadded>
         <msup>
          <mi>u</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msup>
        </mrow>
        <mo>+</mo>
        <mi mathvariant="normal">⋯</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <minus></minus>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>u</ci>
       </apply>
       <ci>normal-⋯</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>u</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <cn type="integer">0</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>u</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>u</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <cn type="integer">3</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>u</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>u</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <ci>normal-⋯</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =-(1+a_{n-1}\,u+\cdots+a_{1}\,u^{n-1}+a_{0}\,u^{n})\cdot(t_{1}+t_{2}\,u+t_{3}%
\,u^{2}+\dots+t_{n}\,u^{n-1}+\cdots).
  </annotation>
 </semantics>
</math>

</p>

<p>If 

<math display="inline" id="Splitting_circle_method:6">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>⊂</mo>
   <mi>ℂ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>G</ci>
    <ci>ℂ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G\subset\mathbb{C}
  </annotation>
 </semantics>
</math>

 is a domain with piecewise smooth boundary <em>C</em> and if the zeros of <em>p</em>(<em>x</em>) are pairwise distinct and not on the boundary <em>C</em>, then from the <a href="residue_theorem" title="wikilink">residue theorem</a> of residual calculus one gets</p>

<p>

<math display="block" id="Splitting_circle_method:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mn>2</mn>
       <mpadded width="+1.7pt">
        <mi>π</mi>
       </mpadded>
       <mi>i</mi>
      </mrow>
     </mfrac>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∮</mo>
       <mi>C</mi>
      </msub>
      <mrow>
       <mfrac>
        <mrow>
         <msup>
          <mi>p</mi>
          <mo>′</mo>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>z</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <mi>p</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>z</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mfrac>
       <mpadded width="+1.7pt">
        <msup>
         <mi>z</mi>
         <mi>m</mi>
        </msup>
       </mpadded>
       <mi>d</mi>
       <mi>z</mi>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mrow>
        <mi>z</mi>
        <mo>∈</mo>
        <mi>G</mi>
       </mrow>
       <mo rspace="4.2pt">:</mo>
       <mrow>
        <mrow>
         <mi>p</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>z</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
      </mrow>
     </munder>
     <mfrac>
      <mrow>
       <msup>
        <mi>p</mi>
        <mo>′</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <msup>
        <mi>z</mi>
        <mi>m</mi>
       </msup>
      </mrow>
      <mrow>
       <msup>
        <mi>p</mi>
        <mo>′</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mrow>
        <mi>z</mi>
        <mo>∈</mo>
        <mi>G</mi>
       </mrow>
       <mo rspace="4.2pt">:</mo>
       <mrow>
        <mrow>
         <mi>p</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>z</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
      </mrow>
     </munder>
     <msup>
      <mi>z</mi>
      <mi>m</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">contour-integral</csymbol>
        <ci>C</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>p</ci>
           <ci>normal-′</ci>
          </apply>
          <ci>z</ci>
         </apply>
         <apply>
          <times></times>
          <ci>p</ci>
          <ci>z</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <ci>m</ci>
        </apply>
        <ci>d</ci>
        <ci>z</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <ci>normal-:</ci>
        <apply>
         <in></in>
         <ci>z</ci>
         <ci>G</ci>
        </apply>
        <apply>
         <eq></eq>
         <apply>
          <times></times>
          <ci>p</ci>
          <ci>z</ci>
         </apply>
         <cn type="integer">0</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>p</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>z</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>z</ci>
         <ci>m</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>p</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>z</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <ci>normal-:</ci>
        <apply>
         <in></in>
         <ci>z</ci>
         <ci>G</ci>
        </apply>
        <apply>
         <eq></eq>
         <apply>
          <times></times>
          <ci>p</ci>
          <ci>z</ci>
         </apply>
         <cn type="integer">0</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2\pi\,i}\oint_{C}\frac{p^{\prime}(z)}{p(z)}z^{m}\,dz=\sum_{z\in G:\,p%
(z)=0}\frac{p^{\prime}(z)z^{m}}{p^{\prime}(z)}=\sum_{z\in G:\,p(z)=0}z^{m}.
  </annotation>
 </semantics>
</math>

</p>

<p>The identity of the left to the right side of this equation also holds for zeros with multiplicities. By using the Newton identities one is able to compute from those sums of powers the factor</p>

<p>

<math display="block" id="Splitting_circle_method:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
     <mrow>
      <mrow>
       <mi>z</mi>
       <mo>∈</mo>
       <mi>G</mi>
      </mrow>
      <mo rspace="4.2pt">:</mo>
      <mrow>
       <mrow>
        <mi>p</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>z</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
     </mrow>
    </munder>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <mi>z</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <ci>normal-:</ci>
       <apply>
        <in></in>
        <ci>z</ci>
        <ci>G</ci>
       </apply>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <ci>p</ci>
         <ci>z</ci>
        </apply>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x):=\prod_{z\in G:\,p(z)=0}(x-z)
  </annotation>
 </semantics>
</math>

</p>

<p>of <em>p</em>(<em>x</em>) corresponding to the zeros of <em>p</em>(<em>x</em>) inside <em>G</em>. By polynomial division one also obtains the second factor <em>g</em>(<em>x</em>) in <em>p</em>(<em>x</em>) = <em>f</em>(<em>x</em>)<em>g</em>(<em>x</em>).</p>

<p>The commonly used regions are circles in the complex plane. Each circle gives raise to a split of the polynomial <em>p</em>(<em>x</em>) in factors <em>f</em>(<em>x</em>) and <em>g</em>(<em>x</em>). Repeating this procedure on the factors using different circles yields finer and finer factorizations. This recursion stops after a finite number of proper splits with all factors being nontrivial powers of linear polynomials.</p>

<p>The challenge now consists in the conversion of this analytical procedure into a numerical algorithm with good running time. The integration is approximated by a finite sum of a numerical integration method, making use of the <a href="fast_Fourier_transform" title="wikilink">fast Fourier transform</a> for the evaluation of the polynomials <em>p</em>(<em>x</em>) and <em>p</em>'(<em>x</em>). The polynomial <em>f</em>(<em>x</em>) that results will only be an approximate factor. To ensure that its zeros are close to the zeros of <em>p</em> inside <em>G</em> and only to those, one must demand that all zeros of <em>p</em> are far away from the boundary <em>C</em> of the region <em>G</em>.</p>
<h2 id="basic-numerical-observation">Basic numerical observation</h2>

<p>(Schönhage 1982) Let 

<math display="inline" id="Splitting_circle_method:9">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>∈</mo>
   <mrow>
    <mi>ℂ</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>X</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>p</ci>
    <apply>
     <times></times>
     <ci>ℂ</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\in\mathbb{C}[X]
  </annotation>
 </semantics>
</math>

 be a polynomial of degree <em>n</em> has <em>k</em> zeros inside the circle of radius <em>1/2</em> and the remaining <em>n-k</em> zeros outside the circle of radius <em>2</em>. With <em>N=O(k)</em> large enough, the approximation of the contour integrals using <em>N</em> points results in an approximation 

<math display="inline" id="Splitting_circle_method:10">
 <semantics>
  <msub>
   <mi>f</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{0}
  </annotation>
 </semantics>
</math>

 of the factor <em>f</em> with error</p>

<p>

<math display="block" id="Splitting_circle_method:11">
 <semantics>
  <mrow>
   <mrow>
    <mo>∥</mo>
    <mrow>
     <mi>f</mi>
     <mo>-</mo>
     <msub>
      <mi>f</mi>
      <mn>0</mn>
     </msub>
    </mrow>
    <mo>∥</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <msup>
       <mn>2</mn>
       <mrow>
        <mrow>
         <mn>2</mn>
         <mi>k</mi>
        </mrow>
        <mo>-</mo>
        <mi>N</mi>
       </mrow>
      </msup>
     </mpadded>
     <mi>n</mi>
     <mi>k</mi>
     <mn>100</mn>
    </mrow>
    <mo>/</mo>
    <mn>98</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <minus></minus>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>k</ci>
        </apply>
        <ci>N</ci>
       </apply>
      </apply>
      <ci>n</ci>
      <ci>k</ci>
      <cn type="float">100</cn>
     </apply>
     <cn type="integer">98</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|f-f_{0}\|\leq 2^{2k-N}\,nk\,100/98
  </annotation>
 </semantics>
</math>

, where the norm of a polynomial is the sum of the moduli of its coefficients.</p>

<p>Since the zeros of a polynomial are continuous in its coefficients, one can make the zeros of 

<math display="inline" id="Splitting_circle_method:12">
 <semantics>
  <msub>
   <mi>f</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{0}
  </annotation>
 </semantics>
</math>

 as close as wanted to the zeros of <em>f</em> by choosing <em>N</em> large enough. However, one can improve this approximation faster using a Newton method. Division of <em>p</em> with remainder yields an approximation 

<math display="inline" id="Splitting_circle_method:13">
 <semantics>
  <msub>
   <mi>g</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>g</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{0}
  </annotation>
 </semantics>
</math>

 of the remaining factor <em>g</em>. Now</p>

<p>

<math display="block" id="Splitting_circle_method:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mn>0</mn>
     </msub>
     <msub>
      <mi>g</mi>
      <mn>0</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mo>-</mo>
       <msub>
        <mi>f</mi>
        <mn>0</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>g</mi>
      <mn>0</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>g</mi>
       <mo>-</mo>
       <msub>
        <mi>g</mi>
        <mn>0</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>f</mi>
      <mn>0</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mo>-</mo>
       <msub>
        <mi>f</mi>
        <mn>0</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>g</mi>
       <mo>-</mo>
       <msub>
        <mi>g</mi>
        <mn>0</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <ci>p</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <ci>g</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>g</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p-f_{0}g_{0}=(f-f_{0})g_{0}+(g-g_{0})f_{0}+(f-f_{0})(g-g_{0})
  </annotation>
 </semantics>
</math>

, so discarding the last second order term one has to solve 

<math display="inline" id="Splitting_circle_method:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mn>0</mn>
     </msub>
     <msub>
      <mi>g</mi>
      <mn>0</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>f</mi>
      <mn>0</mn>
     </msub>
     <mi mathvariant="normal">Δ</mi>
     <mi>g</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>g</mi>
      <mn>0</mn>
     </msub>
     <mi mathvariant="normal">Δ</mi>
     <mi>f</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <ci>p</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>normal-Δ</ci>
      <ci>g</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>normal-Δ</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p-f_{0}g_{0}=f_{0}\Delta g+g_{0}\Delta f
  </annotation>
 </semantics>
</math>

 using any variant of the <a href="extended_Euclidean_algorithm" title="wikilink">extended Euclidean algorithm</a> to obtain the incremented approximations 

<math display="inline" id="Splitting_circle_method:16">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>f</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>f</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>f</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{1}=f_{0}+\Delta f
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Splitting_circle_method:17">
 <semantics>
  <mrow>
   <msub>
    <mi>g</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>g</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>g</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>g</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{1}=g_{0}+\Delta g
  </annotation>
 </semantics>
</math>

. This is repeated until the increments are zero relative to the chosen precision.</p>
<h2 id="graeffe-iteration">Graeffe iteration</h2>

<p>The crucial step in this method is to find an annulus of relative width <em>4</em> in the complex plane that contains no zeros of <em>p</em> and contains approximately as many zeros of <em>p</em> inside as outside of it. Any annulus of this characteristic can be transformed, by translation and scaling of the polynomial, into the annulus between the radii 1/2 and 2 around the origin. But, not every polynomial admits such a splitting annulus.</p>

<p>To remedy this situation, the <a href="Graeffe's_method" title="wikilink">Graeffe iteration</a> is applied. It computes a sequence of polynomials</p>

<p>

<math display="block" id="Splitting_circle_method:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>p</mi>
      <mn>0</mn>
     </msub>
     <mo>=</mo>
     <mi>p</mi>
    </mrow>
    <mo rspace="22.5pt">,</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>p</mi>
       <mrow>
        <mi>j</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mi>deg</mi>
        <mi>p</mi>
       </mrow>
      </msup>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msqrt>
        <mi>x</mi>
       </msqrt>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <msqrt>
         <mi>x</mi>
        </msqrt>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>p</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <apply>
        <plus></plus>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="latexml">degree</csymbol>
        <ci>p</ci>
       </apply>
      </apply>
      <ci>p</ci>
      <apply>
       <root></root>
       <ci>x</ci>
      </apply>
      <ci>p</ci>
      <apply>
       <minus></minus>
       <apply>
        <root></root>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{0}=p,\qquad p_{j+1}(x)=(-1)^{\deg p}p(\sqrt{x})\,p(-\sqrt{x}),
  </annotation>
 </semantics>
</math>

</p>

<p>where the roots of 

<math display="inline" id="Splitting_circle_method:19">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mi>j</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>j</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{j}(x)
  </annotation>
 </semantics>
</math>

 are the 

<math display="inline" id="Splitting_circle_method:20">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>j</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{j}
  </annotation>
 </semantics>
</math>

-th dyadic powers of the roots of the initial polynomial <em>p</em>. By splitting 

<math display="inline" id="Splitting_circle_method:21">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mi>j</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>e</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>x</mi>
     </mpadded>
     <mi>o</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>j</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>e</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>o</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{j}(x)=e(x)+x\,o(x)
  </annotation>
 </semantics>
</math>

 into even and odd parts, the succeeding polynomial is obtained by purely arithmetic operations as 

<math display="inline" id="Splitting_circle_method:22">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mrow>
      <mi>j</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi>deg</mi>
      <mi>p</mi>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>e</mi>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mpadded width="+1.7pt">
        <mi>x</mi>
       </mpadded>
       <mi>o</mi>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <apply>
       <plus></plus>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">degree</csymbol>
       <ci>p</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>e</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>o</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{j+1}(x)=(-1)^{\deg p}(e(x)^{2}-x\,o(x)^{2})
  </annotation>
 </semantics>
</math>

. The ratios of the absolute moduli of the roots increase by the same power 

<math display="inline" id="Splitting_circle_method:23">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>j</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{j}
  </annotation>
 </semantics>
</math>

 and thus tend to infinity. Choosing <em>j</em> large enough one finally finds a splitting annulus of relative width 4 around the origin.</p>

<p>The approximate factorization of 

<math display="inline" id="Splitting_circle_method:24">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mi>j</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <msub>
     <mi>f</mi>
     <mi>j</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>g</mi>
     <mi>j</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>j</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>j</ci>
     </apply>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <ci>j</ci>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{j}(x)\approx f_{j}(x)\,g_{j}(x)
  </annotation>
 </semantics>
</math>

 is now to be lifted back to the original polynomial. To this end an alternation of Newton steps and <a href="Padé_approximant" title="wikilink">Padé approximations</a> is used. It is easy to check that</p>

<p>

<math display="block" id="Splitting_circle_method:25">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <msub>
      <mi>p</mi>
      <mrow>
       <mi>j</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <msub>
      <mi>g</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>≈</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>f</mi>
      <mrow>
       <mi>j</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <msub>
      <mi>g</mi>
      <mrow>
       <mi>j</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mi>x</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <apply>
        <minus></minus>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <apply>
        <minus></minus>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <apply>
        <minus></minus>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{p_{j-1}(x)}{g_{j}(x^{2})}\approx\frac{f_{j-1}(x)}{g_{j-1}(-x)}
  </annotation>
 </semantics>
</math>

 holds. The polynomials on the left side are known in step <em>j</em>, the polynomials on the right side can be obtained as <a href="Padé_approximant" title="wikilink">Padé approximants</a> of the corresponding degrees for the power series expansion of the fraction on the left side.</p>
<h2 id="finding-a-good-circle">Finding a good circle</h2>

<p>Making use of the Graeffe iteration and any known estimate for the absolute value of the largest root one can find estimates <em>R</em> of this absolute value of any precision. Now one computes estimates for the largest and smallest distances 

<math display="inline" id="Splitting_circle_method:26">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>j</mi>
   </msub>
   <mo>></mo>
   <msub>
    <mi>r</mi>
    <mi>j</mi>
   </msub>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <gt></gt>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <gt></gt>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{j}>r_{j}>0
  </annotation>
 </semantics>
</math>

 of any root of <em>p</em>(<em>x</em>) to any of the five center points 0, 2<em>R</em>, −2<em>R</em>, 2<em>Ri</em>, −2<em>Ri</em> and selects the one with the largest ratio 

<math display="inline" id="Splitting_circle_method:27">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>j</mi>
   </msub>
   <mo>/</mo>
   <msub>
    <mi>r</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{j}/r_{j}
  </annotation>
 </semantics>
</math>

 between the two. By this construction it can be guaranteed that 

<math display="inline" id="Splitting_circle_method:28">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>R</mi>
     <mi>j</mi>
    </msub>
    <mo>/</mo>
    <msub>
     <mi>r</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>></mo>
   <msup>
    <mi>e</mi>
    <mn>0.3</mn>
   </msup>
   <mo>≈</mo>
   <mn>1.35</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <gt></gt>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <cn type="float">0.3</cn>
     </apply>
    </apply>
    <apply>
     <approx></approx>
     <share href="#.cmml">
     </share>
     <cn type="float">1.35</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{j}/r_{j}>e^{0{.}3}\approx 1.35
  </annotation>
 </semantics>
</math>

 for at least one center. For such a center there has to be a root-free annulus of relative width 

<math display="inline" id="Splitting_circle_method:29">
 <semantics>
  <mrow>
   <msup>
    <mi>e</mi>
    <mrow>
     <mn>0.3</mn>
     <mo>/</mo>
     <mi>n</mi>
    </mrow>
   </msup>
   <mo>≈</mo>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mfrac>
     <mn>0.3</mn>
     <mi>n</mi>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <divide></divide>
      <cn type="float">0.3</cn>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <divide></divide>
      <cn type="float">0.3</cn>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle e^{0{.}3/n}\approx 1+\frac{0{.}3}{n}
  </annotation>
 </semantics>
</math>

. After 

<math display="inline" id="Splitting_circle_method:30">
 <semantics>
  <mrow>
   <mn>3</mn>
   <mo>+</mo>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">3</cn>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle 3+\log_{2}(n)
  </annotation>
 </semantics>
</math>

 Graeffe iterations, the corresponding annulus of the iterated polynomial has a relative width greater than 11 &gt; 4, as required for the initial splitting described above (see Schönhage (1982)). After 

<math display="inline" id="Splitting_circle_method:31">
 <semantics>
  <mrow>
   <mn>4</mn>
   <mo>+</mo>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>2</mn>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>log</mi>
        <mn>2</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <cn type="integer">4</cn>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">2</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <log></log>
        <cn type="integer">2</cn>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle 4+\log_{2}(n)+\log_{2}(2+\log_{2}(n))
  </annotation>
 </semantics>
</math>

 Graeffe iterations, the corresponding annulus has a relative width greater than 

<math display="inline" id="Splitting_circle_method:32">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mn>2</mn>
     <mn>13.8</mn>
    </msup>
    <mo>⋅</mo>
    <msup>
     <mi>n</mi>
     <mn>6.9</mn>
    </msup>
   </mrow>
   <mo>></mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>64</mn>
      <mo>⋅</mo>
      <msup>
       <mi>n</mi>
       <mn>3</mn>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <cn type="float">13.8</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="float">6.9</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <ci>normal-⋅</ci>
      <cn type="integer">64</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle 2^{13{.}8}\cdot n^{6{.}9}>(64\cdot n^{3})^{2}
  </annotation>
 </semantics>
</math>

, allowing a much simplified initial splitting (see Malajovich/Zubelli (1997))</p>

<p>To locate the best root-free annulus one uses a consequence of the <a href="Rouché_theorem" title="wikilink">Rouché theorem</a>: For <em>k</em> = 1, ..., <em>n</em> − 1 the polynomial equation</p>

<p>

<math display="block" id="Splitting_circle_method:33">
 <semantics>
  <mrow>
   <mrow>
    <mn>0</mn>
    <mo>=</mo>
    <mrow>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>j</mi>
        <mo>≠</mo>
        <mi>k</mi>
       </mrow>
      </munder>
      <mrow>
       <mrow>
        <mo stretchy="false">|</mo>
        <msub>
         <mi>p</mi>
         <mi>j</mi>
        </msub>
        <mo stretchy="false">|</mo>
       </mrow>
       <msup>
        <mi>u</mi>
        <mi>j</mi>
       </msup>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">|</mo>
       <msub>
        <mi>p</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">|</mo>
      </mrow>
      <msup>
       <mi>u</mi>
       <mi>k</mi>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <cn type="float">0</cn>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <neq></neq>
        <ci>j</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <abs></abs>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>u</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>u</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,0=\sum_{j\neq k}|p_{j}|u^{j}-|p_{k}|u^{k},
  </annotation>
 </semantics>
</math>

</p>

<p><em>u</em> &gt; 0, has, by <a href="Descartes'_rule_of_signs" title="wikilink">Descartes' rule of signs</a> zero or two positive roots 

<math display="inline" id="Splitting_circle_method:34">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <msub>
     <mi>u</mi>
     <mi>k</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>v</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <vector>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>k</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(0,u_{k},v_{k})
  </annotation>
 </semantics>
</math>

 and <span class="LaTeX">$A(0,u_k,v_k)$</span> is a root-free (open) annulus.</p>
<h2 id="references">References</h2>
<ul>
<li>Schönhage, Arnold (1982): <a href="http://www.informatik.uni-bonn.de/~schoe/fdthmrep.ps.gz"><em>The fundamental theorem of algebra in terms of computational complexity.</em></a> Preliminary Report, Math. Inst. Univ. Tübingen (1982), 49 pages. (ps.gz)</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>Pan, Victor (1998). <a href="http://algo.inria.fr/seminars/sem97-98/pan.html"><em>Algorithm for Approximating Complex Polynomial Zeros</em></a></li>
<li>Pan, Victor (2002). <a href="http://comet.lehman.cuny.edu/vpan/pdf/JSCOptimal.pdf"><em>Univariate Polynomials: Nearly Optimal Algorithms for Numerical Factorization and Root-finding</em></a></li>
<li>Magma documentation. <a href="http://magma.maths.usyd.edu.au/magma/handbook/text/223#2021">Real and Complex Fields: Element Operations</a>.</li>
</ul>

<p>"</p>

<p><a href="Category:Root-finding_algorithms" title="wikilink">Category:Root-finding algorithms</a></p>
</body>
</html>
