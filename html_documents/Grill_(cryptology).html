<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1950">Grill (cryptology)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Grill (cryptology)</h1>
<hr/>

<p>The <strong>grill method</strong> (),<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> in <a class="uri" href="cryptology" title="wikilink">cryptology</a>, was a method used chiefly early on, before the advent of the <a class="uri" href="cyclometer" title="wikilink">cyclometer</a>, by the mathematician-cryptologists of the Polish Cipher Bureau (<em><a href="Biuro_Szyfrów" title="wikilink">Biuro Szyfrów</a></em>) in <a href="decryption" title="wikilink">decrypting</a> German <a href="Enigma_machine" title="wikilink">Enigma machine</a> <a href="cipher" title="wikilink">ciphers</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The Enigma <a href="Rotor_machine" title="wikilink">rotor cipher machine</a> changes <a class="uri" href="plaintext" title="wikilink">plaintext</a> characters into <a href="Ciphertext" title="wikilink">cipher text</a> using a different <a class="uri" href="permutation" title="wikilink">permutation</a> for each character, and so implements a <a href="polyalphabetic_cipher" title="wikilink">polyalphabetic</a> <a href="substitution_cipher" title="wikilink">substitution cipher</a>.</p>
<h2 id="background">Background</h2>

<p>The German navy started using Enigma machines in 1926; it was called <em>Funkschlüssel C</em> ("Radio cipher C"). By 15 July 1928, the German Army (<em><a class="uri" href="Reichswehr" title="wikilink">Reichswehr</a></em>) had introduced their own version of the Enigma—the <em>Enigma G</em>; a revised <em>Enigma I</em> (with <a href="Enigma_machine#Plugboard" title="wikilink">plugboard</a>) appeared in June 1930. The Enigma I used by the German military in the 1930s was a 3-rotor machine. Initially, there were only three <a href="Enigma_rotor_details" title="wikilink">rotors</a> labeled <em>I</em>, <em>II</em>, and <em>III</em>, but they could be arranged in any order when placed in the machine. Rejewski identified the rotor permutations by 

<math display="inline" id="Grill_(cryptology):0">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Grill_(cryptology):1">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Grill_(cryptology):2">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

; the encipherment produced by the rotors altered as each character was encrypted. The rightmost permutation (

<math display="inline" id="Grill_(cryptology):3">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

) changed with each character. In addition, there was a plugboard that did some additional scrambling.</p>

<p>The number of possible different rotor wirings is:<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>

<math display="block" id="Grill_(cryptology):4">
 <semantics>
  <mrow>
   <mrow>
    <mn>26</mn>
    <mo lspace="0pt" rspace="3.5pt">!</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>403</mn>
    <mo>,</mo>
    <mn>291</mn>
    <mo>,</mo>
    <mn>461</mn>
    <mo>,</mo>
    <mn>126</mn>
    <mo>,</mo>
    <mn>605</mn>
    <mo>,</mo>
    <mn>635</mn>
    <mo>,</mo>
    <mn>584</mn>
    <mo>,</mo>
    <mn>000</mn>
    <mo>,</mo>
    <mn>000</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <factorial></factorial>
     <cn type="integer">26</cn>
    </apply>
    <list>
     <cn type="integer">403</cn>
     <cn type="integer">291</cn>
     <cn type="integer">461</cn>
     <cn type="integer">126</cn>
     <cn type="integer">605</cn>
     <cn type="integer">635</cn>
     <cn type="integer">584</cn>
     <cn type="integer">000</cn>
     <cn type="integer">000</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   26!=403,291,461,126,605,635,584,000,000
  </annotation>
 </semantics>
</math>

</p>

<p>The number of possible different <a href="Enigma_machine#Reflector" title="wikilink">reflector</a> wirings is:<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>

<math display="block" id="Grill_(cryptology):5">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mn>26</mn>
     <mo lspace="0pt" rspace="3.5pt">!</mo>
    </mrow>
    <mrow>
     <msup>
      <mn>2</mn>
      <mn>13</mn>
     </msup>
     <mrow>
      <mn>13</mn>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mn>7</mn>
    <mo>,</mo>
    <mn>905</mn>
    <mo>,</mo>
    <mn>853</mn>
    <mo>,</mo>
    <mn>580</mn>
    <mo>,</mo>
    <mn>025</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <factorial></factorial>
      <cn type="integer">26</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <cn type="integer">13</cn>
      </apply>
      <apply>
       <factorial></factorial>
       <cn type="float">13</cn>
      </apply>
     </apply>
    </apply>
    <list>
     <cn type="integer">7</cn>
     <cn type="integer">905</cn>
     <cn type="integer">853</cn>
     <cn type="integer">580</cn>
     <cn type="integer">025</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{26!}{2^{13}\,13!}=7,905,853,580,025
  </annotation>
 </semantics>
</math>

</p>

<p>The number of possible different plugboard wirings (for six cables) is:<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>

<math display="block" id="Grill_(cryptology):6">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mn>26</mn>
     <mo lspace="0pt" rspace="3.5pt">!</mo>
    </mrow>
    <mrow>
     <msup>
      <mn>2</mn>
      <mn>6</mn>
     </msup>
     <mrow>
      <mn>6</mn>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
     <mrow>
      <mn>14</mn>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mn>100</mn>
    <mo>,</mo>
    <mn>391</mn>
    <mo>,</mo>
    <mn>791</mn>
    <mo>,</mo>
    <mn>500</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <factorial></factorial>
      <cn type="integer">26</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <cn type="integer">6</cn>
      </apply>
      <apply>
       <factorial></factorial>
       <cn type="float">6</cn>
      </apply>
      <apply>
       <factorial></factorial>
       <cn type="float">14</cn>
      </apply>
     </apply>
    </apply>
    <list>
     <cn type="integer">100</cn>
     <cn type="integer">391</cn>
     <cn type="integer">791</cn>
     <cn type="integer">500</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{26!}{2^{6}\,6!\,14!}=100,391,791,500
  </annotation>
 </semantics>
</math>

</p>

<p>To encrypt or decrypt, the operator made the following machine key settings:<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<ul>
<li>the rotor order (<em>Walzenlage</em>)</li>
<li>the <a href="Enigma_machine#Turnover" title="wikilink">ring</a> settings (<em>Ringstellung</em>)</li>
<li>the plugboard connections (<em>Steckerverbindung</em>)</li>
<li>an initial rotor position (<em>Grundstellung</em>)</li>
</ul>

<p>In the early 1930s, the Germans distributed a secret monthly list of all the daily machine settings. The Germans knew that it would be foolish to encrypt the day's traffic using the same key, so each message had its own "message key". This message key was the sender-chosen initial rotor positions (e.g., YEK). The message key had to be conveyed to the recipient operator, so the Germans decided to encrypt it using the day's pre-specified daily ground setting (<em>Grundstellung</em>). The recipient would use the daily machine settings for all messages. He would set the Enigma's initial rotor position to the ground setting and decrypt the message key. The recipient would then set the initial rotor position to the message key and decrypt the body of the message.</p>

<p>The Enigma was used with radio communications, so letters were occasionally corrupted during transmission or reception. If the recipient did not have the correct message key, then the recipient could not decipher the message. The Germans decided to send the three-letter message key twice to guard against transmission errors. Instead of encrypting the message key "YEK" once and sending the encrypted key twice, the Germans doubled the message key to "YEKYEK" ("doubled key"), encrypted the doubled key with the ground setting, and sent the encrypted doubled key. The recipient could then recognize a garbled message key and still decrypt the message. For example, if the recipient received and decrypted the doubled key as "YEKYEN", then the recipient could try both message keys "YEK" and "YEN"; one would produce the desired message and the other would produce gibberish.</p>

<p>The encrypted doubled key was a huge cryptographic mistake because it allowed cryptanalysts to know two encipherments of the same letter, three places apart, for each of the three letters. The Polish codebreakers exploited this mistake in many ways. <a href="Marian_Rejewski" title="wikilink">Marian Rejewski</a> used the doubled key and some known daily keys obtained by a spy, to determine the wiring of the three rotors and the reflector. In addition, code clerks often did not choose secure random keys, but instead chose weak keys such as "AAA", "ABC", and "SSS". The Poles later used the doubled weak keys to find the unknown daily keys. The grill method was an early exploitation of the doubled key to recover part of the daily settings. The <a class="uri" href="cyclometer" title="wikilink">cyclometer</a> and the <a href="Bomba_(cryptography)" title="wikilink"><em>bomba kryptologiczna</em></a> were later exploitations of the doubled key.</p>
<h3 id="example-message">Example message</h3>
<figure><b>(Figure)</b>
<figcaption>The <a href="Enigma_machine" title="wikilink">Enigma machine</a> was an electro-mechanical <a href="rotor_machine" title="wikilink">rotor machine</a> with a scrambler consisting of (from right to left) an entry drum, three rotors and a reflector. It was available commercially from the early 1920s and was modified for use by the German military who adopted it later in the decade.</figcaption>
</figure>

<p>Frode Weierud provides the procedure, secret settings, and results that were used in a 1930 German technical manual.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<pre><code>Daily settings (shared secret):
  Wheel Order  : II  I  III
  Ringstellung : 24  13  22 (XMV)
  Reflector    : A
  Plugboard    : A-M, F-I, N-V, P-S, T-U, W-Z
  Grundstellung: 06  15  12 (FOL)

Operator chosen message key : ABL
Enciphered starting with FOL: PKPJXI

Cleartext message to send and resulting cleartext:
  Feindliche Infanteriekolonne beobachtet.
  Anfang Südausgang Bärwalde.
  Ende 3 km ostwärts Neustadt.

  FEIND LIQEI NFANT ERIEK 
  OLONN EBEOB AQTET XANFA 
  NGSUE DAUSG ANGBA ERWAL 
  DEXEN DEDRE IKMOS TWAER 
  TSNEU STADT

Resulting message:
  1035 – 90 – 341 – 
  PKPJX IGCDS EAHUG WTQGR
  KVLFG XUCAL XVYMI GMMNM
  FDXTG NVHVR MMEVO UYFZS
  LRHDR RXFJW CFHUH MUNZE
  FRDIS IKBGP MYVXU Z</code></pre>

<p>The first line of the message is not encrypted. The "1035" is the time, "90" is number of characters encrypted under the message key, and "341" is a system indicator that tells the recipient how the message was encrypted (i.e., using Enigma with a certain daily key). The first six letters in the body ("PKPJXI") are the doubled key ("ABLABL") encrypted using the daily key settings and starting the encryption at the ground setting/Grundstellung "FOL". The recipient would decipher the first six letters to recover the message key ("ABL"); he would then set the machine's rotors to "ABL" and decipher the remaining 90 characters. Notice that the Enigma does not have numerals, punctuation, or umlauts. Numbers were spelled out. Most spaces were ignored; an "X" was used for a period. Umlauts used their alternative spelling with a trailing "e". Some abbreviations were used: a "Q" was used for "CH".</p>

<p>When Rejewski started his attack in 1932, it was obvious that the first six letters were the enciphered doubled key.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h3 id="key-encryption">Key encryption</h3>

<p>The daily key settings and ground setting will permute the message key characters in different ways. That can be shown by encrypting six of the same letter for all 26 letters</p>
<pre><code>AAAAAA -&gt; PUUJJN
BBBBBB -&gt; TKYWXV
CCCCCC -&gt; KZMVVY
DDDDDD -&gt; XMSRQK
EEEEEE -&gt; RYZOLZ
FFFFFF -&gt; ZXNSTU
GGGGGG -&gt; QRQUNT
HHHHHH -&gt; SSWYYS
IIIIII -&gt; WNOZPL
JJJJJJ -&gt; MQVAAX
KKKKKK -&gt; CBTTSD
LLLLLL -&gt; OWPQEI
MMMMMM -&gt; JDCXUO
NNNNNN -&gt; YIFPGA
OOOOOO -&gt; LPIEZM
PPPPPP -&gt; AOLNIW
QQQQQQ -&gt; GJGLDR
RRRRRR -&gt; EGXDWQ
SSSSSS -&gt; HHDFKH
TTTTTT -&gt; BVKKFG
UUUUUU -&gt; VAAGMF
VVVVVV -&gt; UTJCCB
WWWWWW -&gt; ILHBRP
XXXXXX -&gt; DFRMBJ
YYYYYY -&gt; NEBHHC
ZZZZZZ -&gt; FCEIOE</code></pre>

<p>From this information, the permutations for each of the six message keys can be found. Label each permutation <em>A B C D E F</em>. These permutations are secret: the enemy should not know them.</p>

<p>

<math display="inline" id="Grill_(cryptology):7">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle A=
  </annotation>
 </semantics>
</math>


 Notice the permutations are disjoint transpositions. For the <em>A</em> permutation, it not only changes "A" into "P" but it also changes "P" into "A". That allows the machine to both encrypt and decrypt messages.</p>

<p><a href="Augustin-Louis_Cauchy" title="wikilink">Augustin-Louis Cauchy</a> introduced <em><a href="Permutation#Two-line_notation" title="wikilink">two-line notation</a></em> in 1815 and <em><a href="Permutation#Cycle_notation" title="wikilink">cycle notation</a></em> in 1844.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h2 id="rejewskis-characteristic">Rejewski's characteristic</h2>

<p>Rejewski made an incredible discovery. Without knowing the plugboard settings, the rotor positions, the ring settings, or the ground setting, he could solve for all the daily message keys. All he needed were enough messages and some code clerks using non-random message keys.</p>

<p>The message key is three characters long, so the doubled key is six characters long. Rejewski labeled the permutations for the successive message-key characters <em>A B C D E F</em>. He did not know what those permutations were, but he did know that <em>A</em> and <em>D</em> permutations encrypted the same message key letter, that <em>B</em> and <em>E</em> encrypted the same letter, and that <em>C</em> and <em>F</em> encrypted the same letter. If <mtpl></mtpl> are the (unknown) plaintext letters of the message key and <mtpl></mtpl> are the corresponding (known) ciphertext letters, then</p>

<p>

<math display="inline" id="Grill_(cryptology):8">
 <semantics>
  <msub>
   <mi>p</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle p_{1}
  </annotation>
 </semantics>
</math>


</p>

<p>The equations can be post multiplied by <em>D</em>, <em>E</em>, and <em>F</em> respectively to simplify the right hand sides:</p>

<p>

<math display="inline" id="Grill_(cryptology):9">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle p_{1}D
  </annotation>
 </semantics>
</math>


</p>

<p>The plaintext values are unknown, so those terms are just dropped to leave:</p>

<p>

<math display="inline" id="Grill_(cryptology):10">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mn>1</mn>
   </msub>
   <msup>
    <mi>A</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle c_{1}A^{-1}D
  </annotation>
 </semantics>
</math>


</p>

<p>The above equations describe a path through the permutations. If <mtpl></mtpl> is passed through the inverse of 

<math display="inline" id="Grill_(cryptology):11">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, then it produces <mtpl></mtpl>. If that character passes through 

<math display="inline" id="Grill_(cryptology):12">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

, then the result is <mtpl></mtpl>.</p>

<p>Rejewski also knew that the Enigma permutations were self inverses: Enigma encryption and decryption were identical. That means that 

<math display="inline" id="Grill_(cryptology):13">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi>A</mi>
   </mrow>
   <mo>=</mo>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>A</ci>
    </apply>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   AA=I
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Grill_(cryptology):14">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 is the identity permutation. Consequently, <mtpl><em>A</em><sup>−1</sup>}}</mtpl>. Thus:</p>

<p>

<math display="inline" id="Grill_(cryptology):15">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mn>1</mn>
   </msub>
   <mi>A</mi>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>A</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle c_{1}AD
  </annotation>
 </semantics>
</math>


</p>

<p>The above equations show the relationship between the doubled key characters. Although Rejewski did not know the individual permutations <em>A B C D E F</em>, a single message told him how specific characters were permuted by the composed permutations <em>AD</em>, <em>BE</em>, and <em>CF</em>.</p>

<p>From many messages, Rejewski could determine the composed permutations completely. In practice, about 60 messages were needed to determine the permutations.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>Rejewski recorded the three permutations with a cyclic notation he called the characteristic.  gives an example:</p>

<p>

<math display="inline" id="Grill_(cryptology):16">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle AD
  </annotation>
 </semantics>
</math>


</p>

<p>In this notation, the first cycle of permutation 

<math display="inline" id="Grill_(cryptology):17">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   AD
  </annotation>
 </semantics>
</math>


 would map d to v, v to p, p to f, ..., y to o, and o would wrap around to d.</p>

<p>Furthermore, Enigma permutations were simple transpositions, which meant that each permutation <em>A B C D E F</em> only transposed pairs of characters. Those character pairs had to come from different cycles of the same length. Moreover, any one pairing between two cycles determined all the other pairs in those cycles. Consequently, permutations <em>A</em> and <em>D</em> both had to transpose a and s because (a) and (s) are the only cycles of length one and there is only one way to pair them. There are two ways to match (bc) and (rw) because b must pair with either r or w. Similarly, there are ten ways to match the remaining ten-character cycles. In other words, Rejewski now knew that there were only twenty possibilities for the permutations <em>A</em> and <em>D</em>. Similarly, there were 27 candidates for <em>B</em> and <em>E</em>, and 13 candidates for <em>C</em> and <em>F</em>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h3 id="weak-keys">Weak keys</h3>

<p>At this point, the Poles would exploit weaknesses in the code clerks' selection of message keys to determine which candidates were the correct ones. If the Poles could correctly guess the key for a particular message, then that guess would anchor two cycles in each of the three characteristics.</p>

<p>The Poles intercepted many messages; they would need about 60 messages in the same daily key to determine the characteristic, but they may have many more. Early on, Rejewski had identified the 6 characters that made up the message key.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> If the code clerks were choosing random message keys, then one would not expect to see much correlation in the encrypted six characters. However, some code clerks were lazy. What if, out of a hundred messages, there were five messages from five different stations (meaning five different code clerks) that all used the same message key "PUUJJN"?<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> That they all came up with the same key suggests they used a very simple or very common key. The Poles kept track of different stations and how those stations would choose message keys. Early on, clerks often used simple keys such as "AAA" or "BBB".<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>

<p>The end result was that without knowing the Enigma's plugboard settings, the rotor positions, or the ring settings, Rejewski determined each of the permutations <em>A B C D E F</em>, and hence all of the day's message keys.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>Initially, Rejewski used the knowledge of permutations <em>A B C D E F</em> (and a manual obtained by a French spy) to determine the rotor wirings. After learning the rotor wirings, the Poles used the permutations to determine the rotor order, plugboard connections, and ring settings through further steps of the grill method.</p>
<h3 id="continuing-the-1930-example">Continuing the 1930 example</h3>

<p>Using the daily key in the 1930 technical manual above, then (with enough messages) Rejewski could find the following characteristics:</p>

<p>

<math display="inline" id="Grill_(cryptology):18">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle AD
  </annotation>
 </semantics>
</math>


</p>

<p>Although there are theoretically 7 trillion possibilities for each of the <em>A B C D E F</em> permutations, the characteristics above have narrowed the <em>A</em> and <em>D</em> permutations to just 13 possibilities, <em>B</em> and <em>E</em> to just 30 possibilities, and <em>C</em> and <em>F</em> to just 20 possibilities. The characteristic for <em>CF</em> has two singleton cycles, <code>(e)</code> and <code>(z)</code>.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> Those singleton cycles must pair in the individual permutations, so the characteristic for <em>CF</em> implies that the "E" and "Z" exchange in both the <em>C</em> and <em>F</em> permutations.</p>

<p>

<math display="inline" id="Grill_(cryptology):19">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle C
  </annotation>
 </semantics>
</math>


 The pairing of "E" and "Z" can be checked in the original (secret) permutations given above.</p>

<p>Rejewski would now know that indicators with the pattern "..E..E" were from a message key of "..Z"; similarly an indicator of "..Z..Z" were from a message key of "..E". In the day's traffic, he might find indicators such as "PKZJXZ" or "RYZOLZ"; might one of these indicators be the common (lazy) message key "EEE"? The characteristic limits the number of possible permutations to a small number, and that allows some simple checks. "PKZJXZ" cannot be "EEE" because it requires "K" and "E" to interchange in <em>B</em>, but both "K" and "E" are part of the same cycle in <em>BE</em>: <code>(kxtcoigweh)</code>.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> Interchanging letters must come from distinct cycles of the same length. The repeating key could also be confirmed because it could uncover other repeating keys.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>

<p>The indicator "RYZOLZ" is a good candidate for the message key "EEE", and it would immediately determine both permutations <em>A</em> and <em>D</em>. For example, in <em>AD</em>, the assumed message key "EEE" requires that "E" and "R" interchange in <em>A</em> and that "E" and "O" interchange in <em>D</em>.</p>

<p>

<math display="inline" id="Grill_(cryptology):20">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle A
  </annotation>
 </semantics>
</math>


</p>

<p>If "E" interchanges with "R" in <em>A</em> (notice one character came from the first cycle in <em>AD</em> and the other character came from the second cycle), then the letter following "E" (i.e. "D") will interchange with the letter preceding "R" (i.e. "X") .</p>

<p>

<math display="inline" id="Grill_(cryptology):21">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle A
  </annotation>
 </semantics>
</math>


</p>

<p>That can be continued to get all the characters for both permutations.</p>

<p>

<math display="inline" id="Grill_(cryptology):22">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle A
  </annotation>
 </semantics>
</math>


</p>

<p>This characteristic notation is equivalent to the expressions given for the 1930 permutations <em>A</em> and <em>D</em> given above by sorting the cycles so that the earliest letter is first.</p>

<p>

<math display="inline" id="Grill_(cryptology):23">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle A
  </annotation>
 </semantics>
</math>


</p>

<p>The guessed message key of "EEE" producing indicator "RYZOLZ" would also determine the pairing of the 10-long cycles in permutation <em>BE</em>.</p>

<p>

<math display="inline" id="Grill_(cryptology):24">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle B
  </annotation>
 </semantics>
</math>


</p>

<p>That determines most of <em>B</em> and <em>E</em>, and there would only be 3 possible variations left that pair <code>(ujd)</code> and <code>(mqa)</code>. There are still 20 possible variations for <em>C</em> and <em>F</em>. At this point, the Poles could decrypt all of the first and fourth letters of the daily keys; they could also decrypt 20 out 26 of the second and fifth letters. The Poles' belief in these permutations could be checked by looking at other keys and seeing if they were typical keys used by code clerks.</p>

<p>With that information, they could go looking for and find other likely weak message keys that would determine the rest of the <em>A B C D E F</em> permutations. For example, if the Poles had an indicator "TKYWXV", they could decrypt it as "BB.BB."; checking the cycles for <em>CF</em> would reveal that the indicator is consistent with message key "BBB".</p>
<h2 id="rejewskis-model">Rejewski's model</h2>

<p>Rejewski modeled the machine as permutation made from permutations of plugboard (

<math display="inline" id="Grill_(cryptology):25">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

), the wiring from the keyboard/lamps to the rotors (

<math display="inline" id="Grill_(cryptology):26">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

, the three rotors (

<math display="inline" id="Grill_(cryptology):27">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mi>M</mi>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>M</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   LMN
  </annotation>
 </semantics>
</math>

), and the reflector (

<math display="inline" id="Grill_(cryptology):28">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

). The permutation for each position of the doubled key was different, but they were related by a permutation 

<math display="inline" id="Grill_(cryptology):29">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 that represented a single step of a rotor (

<math display="inline" id="Grill_(cryptology):30">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is known). Rejewski assumed that the left and middle rotors did not move while encrypting the doubled key. The six letters of the doubled key consequently see the permutations A B C D E F:<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>

<p>

<math display="inline" id="Grill_(cryptology):31">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle A
  </annotation>
 </semantics>
</math>


</p>

<p>Rejewski simplied these equations by creating 

<math display="inline" id="Grill_(cryptology):32">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 as a composite reflector made from the real reflector and two leftmost rotors:</p>

<p>

<math display="block" id="Grill_(cryptology):33">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>=</mo>
   <mrow>
    <mi>L</mi>
    <mi>M</mi>
    <mi>R</mi>
    <msup>
     <mi>M</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <msup>
     <mi>L</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Q</ci>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>M</ci>
     <ci>R</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>M</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q=LMRM^{-1}L^{-1}
  </annotation>
 </semantics>
</math>

</p>

<p>Substitution produces:</p>

<p>

<math display="inline" id="Grill_(cryptology):34">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle A
  </annotation>
 </semantics>
</math>


</p>

<p>The result is six equations in four unknowns (<em>S H N Q</em>).<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> Rejewski had a commercial Enigma machine, and he initially thought that 

<math display="inline" id="Grill_(cryptology):35">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 would be the same. In other words, Rejewski guessed that</p>

<p>

<math display="block" id="Grill_(cryptology):36">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable columnspacing="0.4em" rowspacing="0.2ex">
     <mtr>
      <mtd>
       <mrow>
        <mi>q</mi>
        <mi>w</mi>
        <mi>e</mi>
        <mi>r</mi>
        <mi>t</mi>
        <mi>z</mi>
        <mi>u</mi>
        <mi>i</mi>
        <mi>o</mi>
        <mi>a</mi>
        <mi>s</mi>
        <mi>d</mi>
        <mi>f</mi>
        <mi>g</mi>
        <mi>h</mi>
        <mi>j</mi>
        <mi>k</mi>
        <mi>p</mi>
        <mi>y</mi>
        <mi>x</mi>
        <mi>c</mi>
        <mi>v</mi>
        <mi>b</mi>
        <mi>n</mi>
        <mi>m</mi>
        <mi>l</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd>
       <mrow>
        <mi>a</mi>
        <mi>b</mi>
        <mi>c</mi>
        <mi>d</mi>
        <mi>e</mi>
        <mi>f</mi>
        <mi>g</mi>
        <mi>h</mi>
        <mi>i</mi>
        <mi>j</mi>
        <mi>k</mi>
        <mi>l</mi>
        <mi>m</mi>
        <mi>n</mi>
        <mi>o</mi>
        <mi>p</mi>
        <mi>q</mi>
        <mi>r</mi>
        <mi>s</mi>
        <mi>t</mi>
        <mi>u</mi>
        <mi>v</mi>
        <mi>w</mi>
        <mi>x</mi>
        <mi>y</mi>
        <mi>z</mi>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <apply>
     <csymbol cd="latexml">binomial</csymbol>
     <apply>
      <times></times>
      <ci>q</ci>
      <ci>w</ci>
      <ci>e</ci>
      <ci>r</ci>
      <ci>t</ci>
      <ci>z</ci>
      <ci>u</ci>
      <ci>i</ci>
      <ci>o</ci>
      <ci>a</ci>
      <ci>s</ci>
      <ci>d</ci>
      <ci>f</ci>
      <ci>g</ci>
      <ci>h</ci>
      <ci>j</ci>
      <ci>k</ci>
      <ci>p</ci>
      <ci>y</ci>
      <ci>x</ci>
      <ci>c</ci>
      <ci>v</ci>
      <ci>b</ci>
      <ci>n</ci>
      <ci>m</ci>
      <ci>l</ci>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
      <ci>c</ci>
      <ci>d</ci>
      <ci>e</ci>
      <ci>f</ci>
      <ci>g</ci>
      <ci>h</ci>
      <ci>i</ci>
      <ci>j</ci>
      <ci>k</ci>
      <ci>l</ci>
      <ci>m</ci>
      <ci>n</ci>
      <ci>o</ci>
      <ci>p</ci>
      <ci>q</ci>
      <ci>r</ci>
      <ci>s</ci>
      <ci>t</ci>
      <ci>u</ci>
      <ci>v</ci>
      <ci>w</ci>
      <ci>x</ci>
      <ci>y</ci>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H={\left({{qwertzuioasdfghjkpyxcvbnml}\atop{abcdefghijklmnopqrstuvwxyz}}\right)}
  </annotation>
 </semantics>
</math>

 Later, Rejewski realized that guess was wrong. Rejewski then guessed (correctly) that 

<math display="inline" id="Grill_(cryptology):37">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 was just the identity permutation:</p>

<p>

<math display="block" id="Grill_(cryptology):38">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable columnspacing="0.4em" rowspacing="0.2ex">
     <mtr>
      <mtd>
       <mrow>
        <mi>a</mi>
        <mi>b</mi>
        <mi>c</mi>
        <mi>d</mi>
        <mi>e</mi>
        <mi>f</mi>
        <mi>g</mi>
        <mi>h</mi>
        <mi>i</mi>
        <mi>j</mi>
        <mi>k</mi>
        <mi>l</mi>
        <mi>m</mi>
        <mi>n</mi>
        <mi>o</mi>
        <mi>p</mi>
        <mi>q</mi>
        <mi>r</mi>
        <mi>s</mi>
        <mi>t</mi>
        <mi>u</mi>
        <mi>v</mi>
        <mi>w</mi>
        <mi>x</mi>
        <mi>y</mi>
        <mi>z</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd>
       <mrow>
        <mi>a</mi>
        <mi>b</mi>
        <mi>c</mi>
        <mi>d</mi>
        <mi>e</mi>
        <mi>f</mi>
        <mi>g</mi>
        <mi>h</mi>
        <mi>i</mi>
        <mi>j</mi>
        <mi>k</mi>
        <mi>l</mi>
        <mi>m</mi>
        <mi>n</mi>
        <mi>o</mi>
        <mi>p</mi>
        <mi>q</mi>
        <mi>r</mi>
        <mi>s</mi>
        <mi>t</mi>
        <mi>u</mi>
        <mi>v</mi>
        <mi>w</mi>
        <mi>x</mi>
        <mi>y</mi>
        <mi>z</mi>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>H</ci>
    <apply>
     <csymbol cd="latexml">binomial</csymbol>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
      <ci>c</ci>
      <ci>d</ci>
      <ci>e</ci>
      <ci>f</ci>
      <ci>g</ci>
      <ci>h</ci>
      <ci>i</ci>
      <ci>j</ci>
      <ci>k</ci>
      <ci>l</ci>
      <ci>m</ci>
      <ci>n</ci>
      <ci>o</ci>
      <ci>p</ci>
      <ci>q</ci>
      <ci>r</ci>
      <ci>s</ci>
      <ci>t</ci>
      <ci>u</ci>
      <ci>v</ci>
      <ci>w</ci>
      <ci>x</ci>
      <ci>y</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
      <ci>c</ci>
      <ci>d</ci>
      <ci>e</ci>
      <ci>f</ci>
      <ci>g</ci>
      <ci>h</ci>
      <ci>i</ci>
      <ci>j</ci>
      <ci>k</ci>
      <ci>l</ci>
      <ci>m</ci>
      <ci>n</ci>
      <ci>o</ci>
      <ci>p</ci>
      <ci>q</ci>
      <ci>r</ci>
      <ci>s</ci>
      <ci>t</ci>
      <ci>u</ci>
      <ci>v</ci>
      <ci>w</ci>
      <ci>x</ci>
      <ci>y</ci>
      <ci>z</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H={\left({{abcdefghijklmnopqrstuvwxyz}\atop{abcdefghijklmnopqrstuvwxyz}}\right)}
  </annotation>
 </semantics>
</math>

 That still left three unknowns. Rejewski comments:</p>
<dl>
<dd>So I had a set of six equations in three unknowns, S, N, and Q. While I puzzled over how to solve that set of equations, on December 9, 1932, completely unepectedly and at the most opportune moment, a photocopy of two tables of daily keys for September and October 1932 was delivered to me.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a>
</dd>
</dl>

<p>Having the daily keys meant that 

<math display="inline" id="Grill_(cryptology):39">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 was now known. The known permuations were moved to the left side in the equations by premultiplying and post multiplying.</p>

<p>

<math display="inline" id="Grill_(cryptology):40">
 <semantics>
  <mrow>
   <msup>
    <mi>H</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <msup>
    <mi>S</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mi>A</mi>
   <mi>S</mi>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>H</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>A</ci>
    <ci>S</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle H^{-1}S^{-1}ASH
  </annotation>
 </semantics>
</math>


</p>

<p>The leftmost and rightmost 

<math display="inline" id="Grill_(cryptology):41">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 permutations on the right-hand side (which were also known) were moved to the left; the results were given the variable names <em>U V W X Y Z</em>:</p>

<p>

<math display="inline" id="Grill_(cryptology):42">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle U
  </annotation>
 </semantics>
</math>


</p>

<p>Rejewski then multiplied each equation with the next:</p>

<p>

<math display="inline" id="Grill_(cryptology):43">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>U</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle UV
  </annotation>
 </semantics>
</math>


 Next, Rejewski elimnated the common subexpression <mtpl></mtpl> by substituting its value obtained from the previous product.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>

<p>

<math display="inline" id="Grill_(cryptology):44">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mi>W</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle VW
  </annotation>
 </semantics>
</math>


 The result is a set of four equations in just one unknown: <mtpl></mtpl>.</p>
<h3 id="back-to-1930-example">Back to 1930 example</h3>

<p>For the 1930 example above,</p>
<pre><code>     ABCDEFGHIJKLMNOPQRSTUVWXYZ
  A  ptkxrzqswmcojylagehbvuidnf
  B  ukzmyxrsnqbwdipojghvatlfec
  C  uymsznqwovtpcfilgxdkajhrbe
  D  jwvrosuyzatqxpenldfkgcbmhi
  E  jxvqltnypaseugzidwkfmcrbho
  F  nvykzutslxdioamwrqhgfbpjce</code></pre>

<p>are transformed to the 

<math display="inline" id="Grill_(cryptology):45">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mi>V</mi>
   <mi>W</mi>
   <mi>X</mi>
   <mi>Y</mi>
   <mi>Z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>U</ci>
    <ci>V</ci>
    <ci>W</ci>
    <ci>X</ci>
    <ci>Y</ci>
    <ci>Z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   UVWXYZ
  </annotation>
 </semantics>
</math>

 permutations:</p>
<pre><code>     ABCDEFGHIJKLMNOPQRSTUVWXYZ
  U  gkvlysarqxbdptumihfnoczjew
  V  gnfmycaxtrzsdbvwujliqophek
  W  uekfbdszrtcyqxvwmigjaopnlh
  X  jelfbdrvsaxctqyungimphzkow
  Y  ltgmwycsvqxadzrujohbpiekfn
  Z  mskpiyuteqcravzdjlbhgnxwfo</code></pre>

<p>and then multiplied to produce the five successive products:</p>
<pre><code>       ABCDEFGHIJKLMNOPQRSTUVWXYZ
  UV = azoselgjuhnmwiqdtxcbvfkryp = (a)(e)(g)(y)(hj)(rx)(bzpdscoqt)(flmwkniuv)
  VW = sxdqlkunjihgfeopatyrmvwzbc = (o)(p)(v)(w)(ij)(rt)(asybxzcdq)(elgumfkhn)
  WX = pbxdefiwgmlonkhztsrajyuqcv = (b)(d)(e)(f)(gi)(rs)(apzvycxqt)(hwujmnklo)
  XY = qwaytmoihlkgbjfpzcvdusnxre = (k)(p)(u)(x)(hi)(sv)(aqzetdyrc)(bwnjlgofm)
  YZ = rhuaxfkbnjwmpolgqztsdeicyv = (f)(j)(q)(y)(bh)(st)(arzvexcud)(gkwinolmp)</code></pre>

<p>Now the goal is to find the single structure preserving map that transforms UV to VW, VW to WX, WX to XY, and XY to YZ. Found by subscription of cycle notation. When 

<math display="inline" id="Grill_(cryptology):46">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>U</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   UV
  </annotation>
 </semantics>
</math>

 maps to 

<math display="inline" id="Grill_(cryptology):47">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mi>W</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   VW
  </annotation>
 </semantics>
</math>

, the map must mate cycles of the same length. That means that <code>(a)</code> in 

<math display="inline" id="Grill_(cryptology):48">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>U</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   UV
  </annotation>
 </semantics>
</math>

 must map to one of <code>(o)(p)(v)(w)</code> in 

<math display="inline" id="Grill_(cryptology):49">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mi>W</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>W</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   VW
  </annotation>
 </semantics>
</math>

. In other words, <code>a</code> must map to one of <code>opvw</code>. These can be tried in turn.</p>
<pre><code>  UV = (a)(e)(g)(y)(hj)(rx)(bzpdscoqt)(flmwkniuv)
  VW = (o)                                        (p)(v)(w)(ij)(rt)(asybxzcdq)(elgumfkhn)
 
  VW = (o)(p)(v)(w)(ij)(rt)(asybxzcdq)(elgumfkhn)
  WX =                                            (b)(d)(e)(f)(gi)(rs)(apzvycxqt)(hwujmnklo)
 
  WX = (b)(d)(e)(f)(gi)(rs)(apzvycxqt)(hwujmnklo)
  XY =                                            (k)(p)(u)(x)(hi)(sv)(aqzetdyrc)(bwnjlgofm)
 
  XY = (k)(p)(u)(x)(hi)(sv)(aqzetdyrc)(bwnjlgofm)
  YZ =                                            (f)(j)(q)(y)(bh)(st)(arzvexcud)(gkwinolmp)</code></pre>

<p>But <code>a</code> must map the same to <code>o</code> in each pairing, so other character mappings are also determined:</p>
<pre><code>  UV = (a)(e)(g)(y)(hj)(rx)(bzpdscoqt)(flmwkniuv)
  VW = (o)                                        (p)(v)(w)(ij)(rt)(asybxzcdq)(elgumfkhn)
 
  VW = (o)(p)(v)(w)(ij)(rt)(asybxzcdq)(elgumfkhn)
  WX =                     (ohwujmnkl)            (b)(d)(e)(f)(gi)(rs)(apzvycxqt)
 
  WX = (b)(d)(e)(f)(gi)(rs)(apzvycxqt)(hwujmnklo)
  XY =                     (ofmbwnjlg)            (k)(p)(u)(x)(hi)(sv)(aqzetdyrc)
 
  XY = (k)(p)(u)(x)(hi)(sv)(aqzetdyrc)(bwnjlgofm)
  YZ =                     (olmpgkwin)            (f)(j)(q)(y)(bh)(st)(arzvexcud)</code></pre>

<p>Consequently, the character maps for <code>sybxzcdq</code>, <code>pzvycxqt</code>, and <code>qzetdyrc</code> are discovered and consistent. Those mappings can be exploited:</p>
<pre><code>  UV = (a)(e)(g)(y)(hj)(rx)(bzpdscoqt)(flmwkniuv)
  VW = (o)(p)   (w)    (ij)(umfkhnelg)(xzcdqasyb) (v)(rt)
 
  VW = (o)(p)(v)(w)(ij)(rt)(asybxzcdq)(elgumfkhn)
  WX =    (f)(b)       (ig)(ohwujmnkl)(pzvycxqta) (d)(e)(rs)
 
  WX = (b)(d)(e)(f)(gi)(rs)(apzvycxqt)(hwujmnklo)
  XY = (u)(k)(p)       (ih)(ofmbwnjlg)            (x)(sv)(aqzetdyrc)
 
  XY = (k)(p)(u)(x)(hi)(sv)(aqzetdyrc)(bwnjlgofm)
  YZ =    (f)   (j)    (hb)(olmpgkwin)(udarzvexc) (q)(y)(st)</code></pre>

<p>Which determines the rest of the map and consistently subscribes:</p>
<pre><code>  UV = (a)(e)(g)(y)(hj)(rx)(bzpdscoqt)(flmwkniuv)
  VW = (o)(p)(v)(w)(tr)(ij)(umfkhnelg)(xzcdqasyb)
 
  VW = (o)(p)(v)(w)(ij)(rt)(asybxzcdq)(elgumfkhn)
  WX = (e)(f)(b)(d)(sr)(ig)(ohwujmnkl)(pzvycxqta)
 
  WX = (b)(d)(e)(f)(gi)(rs)(apzvycxqt)(hwujmnklo)
  XY = (u)(k)(p)(x)(vs)(ih)(ofmbwnjlg)(tdyrcaqze)
 
  XY = (k)(p)(u)(x)(hi)(sv)(aqzetdyrc)(bwnjlgofm)
  YZ = (q)(f)(y)(j)(ts)(hb)(olmpgkwin)(udarzvexc)</code></pre>

<p>The resulting map with successive subscriptions:</p>
<pre><code> resulting map: ABCDEFGHIJKLMNOPQRSTUVWXYZ
                ounkpxvtsrqzcaeflihgybdjwm = (aoepfxjrishtgvbuywdkqlzmcn)
  UV = (a)(e)(g)(y)(hj)(rx)(bzpdscoqt)(flmwkniuv)
  VW = (o)(p)(v)(w)(tr)(ij)(umfkhnelg)(xzcdqasyb)
  WX = (e)(f)(b)(d)(gi)(sr)(ycxqtapzv)(jmnklohwu)
  XY = (p)(x)(u)(k)(vs)(hi)(wnjlgofmb)(rcaqzetdy)
  YZ = (f)(j)(y)(q)(bh)(ts)(darzvexcu)(inolmpgkw)</code></pre>

<p>The map gives us <mtpl></mtpl>, but that is also congugate (structure preserving). Consequently, the 26 possible values for 

<math display="inline" id="Grill_(cryptology):50">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 are found by subscribing 

<math display="inline" id="Grill_(cryptology):51">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 in 26 possible ways.</p>

<p>The model above ignored the right rotor's ring setting (22) and ground setting (12), both of which were known because Rejewski had the daily keys. The ring setting has the effect of counterrotating the drum by 21; the ground setting advances it by 11. Consequently the rotor rotation is -10, which is also 16.</p>
<pre><code>         ABCDEFGHIJKLMNOPQRSTUVWXYZ
Straight ounkpxvtsrqzcaeflihgybdjwm
Shifted  gpsquvbyxwortzmcekdafnljih = (agbpcsdqeufvnzhyixjwlrkomt)
subscribe P in different ways:        (abcdefghijklmnopqrstuvwxyz)
                                      (bcdefghijklmnopqrstuvwxyza) * actual rotor wiring
                                      (cdefghijklmnopqrstuvwxyzab)
                                      ...
                                      (zabcdefghijklmnopqrstuvwxy)

rotor *   ABCDEFGHIJKLMNOPQRSTUVWXYZ
          bdfhjlcprtxvznyeiwgakmusqo</code></pre>
<h2 id="grill">Grill</h2>

<p>The physical grill was used to determine both the rightmost rotor, its initial position, and the plugboard settings.</p>
<h3 id="bottom-sheet">Bottom sheet</h3>

<p>Rejewsky observed that 

<math display="inline" id="Grill_(cryptology):52">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is close to the identity permutation (in the early 1930s, only 12 of 26 letters were affected by the plugboard). He moved everything but 

<math display="inline" id="Grill_(cryptology):53">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 to the left side of the equations by premultiplying or postmultiplying. The resulting system of equations is:</p>

<p>

<math display="inline" id="Grill_(cryptology):54">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>P</mi>
      <mn>1</mn>
     </msup>
     <msup>
      <mi>N</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <msup>
      <mi>P</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <msup>
    <mi>S</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mi>A</mi>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>P</mi>
      <mn>1</mn>
     </msup>
     <mi>N</mi>
     <msup>
      <mi>P</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>N</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>A</ci>
    <ci>S</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>N</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle(P^{1}N^{-1}P^{-1})S^{-1}AS(P^{1}NP^{-1})
  </annotation>
 </semantics>
</math>


</p>

<p>At his point, 

<math display="inline" id="Grill_(cryptology):55">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is unknown, but it is the same for each equation. Rejewski does not know 

<math display="inline" id="Grill_(cryptology):56">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

, but he knows it is one of the rotors (I, II, and III), and he knows the wiring for each of those rotors. There were only three rotors and 26 possible initial rotations. Consequently, there are only 84 possible values for 

<math display="inline" id="Grill_(cryptology):57">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

. Rejewski can look at each possible value to see if the 

<math display="inline" id="Grill_(cryptology):58">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 permutation is consistent. If there were no steckers (

<math display="inline" id="Grill_(cryptology):59">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 were the identity), then each equation would produce the same 

<math display="inline" id="Grill_(cryptology):60">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

.</p>

<p>Consequently, he made one bottom sheet for each possible rotor (3 sheets). Each bottom sheet consisted of 31 lines (26 + 5 to make 6 lines contiguous). Each line contained the stepped permutation of a known rotor.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> For example, a suitable bottom sheet for rotor III is,</p>

<p>

<math display="inline" id="Grill_(cryptology):61">
 <semantics>
  <msup>
   <mi>P</mi>
   <mn>0</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>P</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P^{0}
  </annotation>
 </semantics>
</math>


</p>

<p>In the early 1930s, the rotor order was the same for a month or more, so the Poles usually knew which rotor was in the rightmost position and only needed to use one bottom sheet. After 1 November 1936, the rotor order changed every day. The Poles could use the <a href="Clock_(cryptography)" title="wikilink">clock method</a> to determine the rightmost rotor, so the grill would only need to examine that rotor's bottom sheet.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></p>
<h3 id="top-sheet">Top sheet</h3>

<p>For the top sheet, Rejewski wrote the six permutations 

<math display="inline" id="Grill_(cryptology):62">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 through 

<math display="inline" id="Grill_(cryptology):63">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

.</p>
<pre><code>A: abcdefghijklmnopqrstuvwxyz
   srwivhnfdolkygjtxbapzecqmu
(..slit......................)
...

F: abcdefghijklmnopqrstuvwxyz
   wxofkduihzevqscymtnrglabpj
(..slit......................)</code></pre>

<p>There were six slits so the permutations on the bottom sheet would show through at the proper place.</p>

<p>The top sheet would then be slid through all possible positions of rotor 

<math display="inline" id="Grill_(cryptology):64">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

, and the cryptanalyst would look for consistency with some unknown but constant permutation 

<math display="inline" id="Grill_(cryptology):65">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

. If there isn't a consistent 

<math display="inline" id="Grill_(cryptology):66">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

, then the next position is tried.</p>

<p>Here's what the grill would show for the above permutations at its consistent alignment:</p>
<pre><code>A: abcdefghijklmnopqrstuvwxyz
   ptkxrzqswmcojylagehbvuidnf
17 fpjtvdbzxkmoqsulyacgeiwhnr (visible through slit)

B: abcdefghijklmnopqrstuvwxyz
   ukzmyxrsnqbwdipojghvatlfec
18 oisucaywjlnprtkxzbfdhvgmqe (visible through slit)

C: abcdefghijklmnopqrstuvwxyz
   uymsznqwovtpcfilgxdkajhrbe
19 hrtbzxvikmoqsjwyaecguflpdn (visible through slit)

D: abcdefghijklmnopqrstuvwxyz
   jwvrosuyzatqxpenldfkgcbmhi
20 qsaywuhjlnprivxzdbftekocmg (visible through slit)

E: abcdefghijklmnopqrstuvwxyz
   jxvqltnypaseugzidwkfmcrbho
21 rzxvtgikmoqhuwycaesdjnblfp (visible through slit)

F: abcdefghijklmnopqrstuvwxyz
   nvykzutslxdioamwrqhgfbpjce
22 ywusfhjlnpgtvxbzdrcimakeoq (visible through slit)</code></pre>

<p>In permutation 

<math display="inline" id="Grill_(cryptology):67">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, the cryptanalyst knows that <code>(c k)</code> interchange. He can see how rotor III would scramble those letters by looking at the first line (the alphabet in order) and the line visible through the slit. The rotor maps <code>c</code> into <code>j</code> and it maps <code>k</code> into <code>m</code>. If we ignore steckers for the moment, that means permutation 

<math display="inline" id="Grill_(cryptology):68">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 would interchange <code>(j m)</code>. For 

<math display="inline" id="Grill_(cryptology):69">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 to be consistent, it must be the same for all six 

<math display="inline" id="Grill_(cryptology):70">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mi>B</mi>
   <mi>C</mi>
   <mi>D</mi>
   <mi>E</mi>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>B</ci>
    <ci>C</ci>
    <ci>D</ci>
    <ci>E</ci>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ABCDEF
  </annotation>
 </semantics>
</math>

 permutations.</p>

<p>Look at the grill near permutation 

<math display="inline" id="Grill_(cryptology):71">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 to check if its 

<math display="inline" id="Grill_(cryptology):72">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 also interchanges <code>(j m)</code>. Through the slit, find the letter <code>j</code> and look in the same column two lines above it to find <code>h</code>. That tells us the rotor, when it has advanced three positions, now maps <code>h</code> into <code>j</code>. Similarly, the advanced rotor will map <code>y</code> into <code>m</code>. Looking at permutation 

<math display="inline" id="Grill_(cryptology):73">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

, it interchanges <code>(h y)</code>, so the two tests are consistent.</p>

<p>Similarly, in permutation 

<math display="inline" id="Grill_(cryptology):74">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, the <code>(d x)</code> interchange and imply that <code>(t h)</code> interchange in 

<math display="inline" id="Grill_(cryptology):75">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

. Looking at permutation 

<math display="inline" id="Grill_(cryptology):76">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

, <code>(e l)</code> interchange and also imply that <code>(t h)</code> interchange in 

<math display="inline" id="Grill_(cryptology):77">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

.</p>

<p>All such tests would be consistent if there were no steckers, but the steckers confuse the issue by hiding such matches. If any of the letters involved in the test is steckered, then it will not look like a match.</p>

<p>The effect of the rotor permutation can be removed to leave the 

<math display="inline" id="Grill_(cryptology):78">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 implied by the 

<math display="inline" id="Grill_(cryptology):79">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mi>B</mi>
   <mi>C</mi>
   <mi>D</mi>
   <mi>E</mi>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>B</ci>
    <ci>C</ci>
    <ci>D</ci>
    <ci>E</ci>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ABCDEF
  </annotation>
 </semantics>
</math>

 permutations. The result (along with the actual value of 

<math display="inline" id="Grill_(cryptology):80">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

) is:</p>
<pre><code>   -: ABCDEFGHIJKLMNOPQRSTUVWXYZ
Q(A): vyzrilptemqfjsugkdnhoaxwbc
Q(B): myqvswpontxzaihgcuejrdfkbl
Q(C): vcbrpmoulxwifzgeydtshakjqn
Q(D): kyirhulecmagjqstndopfzxwbv
Q(E): vemgbkdtwufzcxrysoqhjainpl
Q(F): wvlrpqsmjizchtuefdgnobayxk

Q   : vyqrpkstnmfzjiuecdghoaxwbl (this actual Q is unknown to the cryptanalyst)</code></pre>

<p>Most of the letters in an implied permutation are incorrect. An exchange in an implied permutation is correct if two letters are not steckered. About one half the letters are steckered, so the expectation is only one fourth of the letters in an implied permutation are correct. Several columns show correlations; column <code>A</code> has three <code>v</code> characters, and <code>(a v)</code> interchange in the actual 

<math display="inline" id="Grill_(cryptology):81">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

; column <code>D</code> has four <code>r</code> characters, and <code>(d r)</code> interchange in 

<math display="inline" id="Grill_(cryptology):82">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a>  describes the possibility of writing down the six implied 

<math display="inline" id="Grill_(cryptology):83">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

s for all 26 possible rotor positions. Rejewski states, "If permutation 

<math display="inline" id="Grill_(cryptology):84">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 actually were the identity, then ... for a particular [initial position] we would obtain the same value for all expressions 

<math display="inline" id="Grill_(cryptology):85">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 and in this way we would find the setting of drum 

<math display="inline" id="Grill_(cryptology):86">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

. Permutation 

<math display="inline" id="Grill_(cryptology):87">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 does exist, however, so for no [initial position] will the expression 

<math display="inline" id="Grill_(cryptology):88">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 be equal to each other, but among them will be a certain similarity for a particular [initial position], since permutation 

<math display="inline" id="Grill_(cryptology):89">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 does not change all the letters."</p>

<p>Rejewski states that writing down all the possible 

<math display="inline" id="Grill_(cryptology):90">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 "would be too laborious", so he developed the grill (grid) method.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> "Next, the grid is moved along the paper on which the drum connections are written until it hits upon a position where some similarities show up among the several expression 

<math display="inline" id="Grill_(cryptology):91">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

. ... In this way the setting of drum 

<math display="inline" id="Grill_(cryptology):92">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 and the changes resulting from permutation 

<math display="inline" id="Grill_(cryptology):93">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 are found simultaneously. This process requires considerable concentration since the similarities I mentioned do not always manifest themselves distinctly and can be very easily overlooked."<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> The reference does not describe what techniques were used. Rejewski did state that the grill method required unsteckered pairs of letters.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a></p>

<p>Permutation 

<math display="inline" id="Grill_(cryptology):94">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 has the exchanges <code>(ap)(bt)(ck)...</code>. If we assume the exchange <code>(ap)</code> is unsteckered, that implies 

<math display="inline" id="Grill_(cryptology):95">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 exchanges <code>(fl)</code>. The other five permutations 

<math display="inline" id="Grill_(cryptology):96">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mi>C</mi>
   <mi>D</mi>
   <mi>E</mi>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <ci>C</ci>
    <ci>D</ci>
    <ci>E</ci>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   BCDEF
  </annotation>
 </semantics>
</math>

 can be quickly checked for an unsteckered pair that is consistent with 

<math display="inline" id="Grill_(cryptology):97">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 interchanging <code>(fl)</code> — essentially checking column <code>F</code> for other rows with <code>l</code> without computing the entire table. None are found, so <code>(ap)</code> would have at least one stecker so the assumption it is unsteckered is abandoned. The next pair can be guessed as unsteckered. The exchange <code>(bt)</code> implies 

<math display="inline" id="Grill_(cryptology):98">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 exchanges <code>(pg)</code>; that is consistent with <code>(lw)</code> in 

<math display="inline" id="Grill_(cryptology):99">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

, but that guess fails to pan out because <code>t</code> and <code>w</code> are steckered.</p>
<pre><code>A: b↔t   B: l↔w   C: k←t   D: x→m   E: m→u   F: j←x
   ↓ ↓      ↓ ↓      * ↑      ↑ *      ↑ *      * ↑
   b t      l w      x t      k z      z f      j k
   ↓ ↓      ↑ ↑      ↑ ↑      ↑ ↑      ↑ ↑      ↑ ↑
Q: p↔g      p↔g      p↔g      p↔g      p↔g      p↔g
guessing (b)(t) unsteckered in S leads to the guess (l)(w) unsteckered in S
 C finds stecker (k x)
 D finds stecker (z m)
 E finds stecker (f u)
 F finds (j)</code></pre>

<p>Following those guesses ultimately leads to a contradiction:</p>
<pre><code>A: f↔z   B: m→d   C: p←l   D: f→s   E: p!x   F:
   ↓ ↓      ↑ *      * ↑      ↑ *      ↑ ↑
   u m      z y      r l      u a      r k      
   ↓ ↓      ↑ ↑      ↑ ↑      ↑ ↑      ↑ ↑      ↑ ↑
Q: e↔q      e↔q      e↔q      e↔q      e↔q      e↔q
exploit (f z) in A leads to (e q) exchange in Q
 B finds (d y) steckered
 C finds (p r) steckered
 D finds (a s) steckered
 E finds (p x) steckered - but p is already steckered to r! failure</code></pre>

<p>The third exchange <code>(ck)</code> implies 

<math display="inline" id="Grill_(cryptology):100">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 exchanges <code>(jm)</code>; this time permutation 

<math display="inline" id="Grill_(cryptology):101">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 with an unsteckered <code>(hy)</code> would be consistent with 

<math display="inline" id="Grill_(cryptology):102">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 exchanging <code>(jm)</code>.</p>
<pre><code>A: c↔k   B:       C:       D: h↔y   E:       F:
   ↓ ↓                        ↑ ↑
   c k      i x      n j      h y      u i      g u
   ↓ ↓      ↑ ↑      ↑ ↑      ↑ ↑      ↑ ↑      ↑ ↑
Q: j↔m      j↔m      j↔m      j↔m      j↔m      j↔m
guessing (c)(y) unsteckered in S leads to the guess (h)(y) unsteckered in S</code></pre>

<p>At this point, the guess is that the letters <code>chky</code> are unsteckered. From that guess, all the steckers can be solved for this particular problem. The known (assumed) exchanges in 

<math display="inline" id="Grill_(cryptology):103">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 are used to find exchanges in 

<math display="inline" id="Grill_(cryptology):104">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

, and those exchanges are used to extend what is known about 

<math display="inline" id="Grill_(cryptology):105">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

.</p>

<p>Using those unsteckered letters as seeds finds <code>(hy)</code> interchange in 

<math display="inline" id="Grill_(cryptology):106">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 and implies <code>(kf)</code> is in 

<math display="inline" id="Grill_(cryptology):107">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

; similarly <code>(cy)</code> interchange in 

<math display="inline" id="Grill_(cryptology):108">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 and implies <code>(uo)</code> is in 

<math display="inline" id="Grill_(cryptology):109">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

. Examining <code>(uo)</code> in the other permutations finds <code>(tu)</code> is a stecker.</p>
<pre><code>A:       B:       C:       D:       E: h↔y   F:
                                       ↓ ↓
   j a      o s      i v      v s      h y      w e
   ↑ ↑      ↑ ↑      ↑ ↑      ↑ ↑      ↓ ↓      ↑ ↑
Q: k↔f      k↔f      k↔f      k↔f      k↔f      k↔f
exploit (hy) in E

A:       B:       C: t←k   D:       E:       F: c↔y
                     * ↑                        ↓ ↓
   o l      d a      u k      f w      m j      c y
   ↑ ↑      ↑ ↑      ↑ ↑      ↑ ↑      ↓ ↓      ↑ ↑
Q: u↔o      u↔o      u↔o      u↔o      u↔o      u↔o
exploit (cy) in F shows (tu) are in S</code></pre>

<p>That adds letters <code>tu</code> to the seeds. Those letters were also unknown above, so further information can be gleaned by revisiting: 

<math display="inline" id="Grill_(cryptology):110">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 also has <code>(g)(if)(x)</code>.</p>
<pre><code>A: c↔k   B: f→x   C:       D: h↔y   E: t→f   F: g←t
   ↓ ↓      ↑ *               ↑ ↑      ↑ *      * ↑
   c k      i x      n j      h y      u i      g u
   ↓ ↓      ↑ ↑      ↑ ↑      ↑ ↑      ↑ ↑      ↑ ↑
Q: j↔m      j↔m      j↔m      j↔m      j↔m      j↔m
knowing (tu) in S leads to (g)(if) in S
then (if) in S can be used to find (x) in S</code></pre>

<p>Revisit <code>(kf)(uo)</code> in 

<math display="inline" id="Grill_(cryptology):111">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 gives more information:</p>
<pre><code>A:       B: o←p   C: f→n   D: n→p   E: h↔y   F: z→e
            * ↑      ↑ *      ↑ *      ↓ ↓      ↑ *
   j a      o s      i v      v s      h y      w e
   ↑ ↑      ↑ ↑      ↑ ↑      ↑ ↑      ↓ ↓      ↑ ↑
Q: k↔f      k↔f      k↔f      k↔f      k↔f      k↔f
exploit (if) in S leads to (nv) in S
 (nv) in S leads to stecker (ps)
 (ps) in S leads to (o)
 (wz) in S leads to (e)

A: o→l   B:       C: t←k   D: i→z   E:       F: c↔y
   ↑ *               * ↑      ↑ *               ↓ ↓
   o l      d a      u k      f w      m j      c y
   ↑ ↑      ↑ ↑      ↑ ↑      ↑ ↑      ↓ ↓      ↑ ↑
Q: u↔o      u↔o      u↔o      u↔o      u↔o      u↔o
exploit (if) in S leads to stecker (wz) in S
 (o) in S leads to (l) in S</code></pre>

<p>Another revisit fully exploits <code>(jm)</code>:</p>
<pre><code>A: c↔k   B: f x   C: v→j   D: h↔y   E: t→f   F: g←t
   ↓ ↓      ↑ *      ↑ *      ↑ ↑      ↑ *      * ↑
   c k      i x      n j      h y      u i      g u
   ↓ ↓      ↑ ↑      ↑ ↑      ↑ ↑      ↑ ↑      ↑ ↑
Q: j↔m      j↔m      j↔m      j↔m      j↔m      j↔m
knowing (nv) in S leads to (j) in S</code></pre>

<p>That addition fills out even more:</p>
<pre><code>A: j→m   B: o←p   C: f→n   D: n→p   E: h↔y   F: z→e
   ↑ *      * ↑      ↑ *      ↑ *      ↓ ↓      ↑ *
   j a      o s      i v      v s      h y      w e
   ↑ ↑      ↑ ↑      ↑ ↑      ↑ ↑      ↓ ↓      ↑ ↑
Q: k↔f      k↔f      k↔f      k↔f      k↔f      k↔f
exploit (j) in S leads to (am) in S

A: o→l   B: d←m   C: t←k   D: i→z   E: a↔j   F: c↔y
   ↑ *      * ↑      * ↑      ↑ *      ↑ ↑      ↓ ↓
   o l      d a      u k      f w      m j      c y
   ↑ ↑      ↑ ↑      ↑ ↑      ↑ ↑      ↓ ↓      ↑ ↑
Q: u↔o      u↔o      u↔o      u↔o      u↔o      u↔o
exploit (j)(am) in S leads to (d) in S

Q = ( (fk)(jm)(ou)... )
 missing 10 pairings
S = ( (am)(c)(d)(fi)(g)(h)(j)(k)(l)(nv)(o)(ps)(tu)(wz)(x)(y)... )
 22 characters so far: missing beqr
 have found all 6 steckers, so (b)(e)(q)(r)</code></pre>

<p>All of 

<math display="inline" id="Grill_(cryptology):112">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is now known after examining 3 exchanges in 

<math display="inline" id="Grill_(cryptology):113">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

. The rest of 

<math display="inline" id="Grill_(cryptology):114">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 can be found easily.</p>

<p>When a match is found, then the cryptanalyst would learn both the initial rotation of 

<math display="inline" id="Grill_(cryptology):115">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 and the plugboard (<em>Stecker</em>) permutation 

<math display="inline" id="Grill_(cryptology):116">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></p>
<h2 id="recovering-absolute-rotor-positions-for-the-message-key">Recovering absolute rotor positions for the message key</h2>

<p>At this point, the rotor positions for the 

<math display="inline" id="Grill_(cryptology):117">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 permutation is not known. That is, the initial positions (and possibly the order) of rotors 

<math display="inline" id="Grill_(cryptology):118">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Grill_(cryptology):119">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 are not known. The Poles applied brute force by trying all possible initial positions (<mtpl> 676}}</mtpl>) of the two rotors.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> With three rotors, knowing which rotor was at position 

<math display="inline" id="Grill_(cryptology):120">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 meant there were only two possible ways to load the other two rotors.</p>

<p>Later, the Poles developed a catalog of all the 

<math display="inline" id="Grill_(cryptology):121">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 permutations. The catalog was not large: there were six possible <a href="combination" title="wikilink">combinations</a> of two left rotors with <mtpl>676}}</mtpl> initial settings, so the catalog had 4,056 entries. After using the grill, the Poles would look up 

<math display="inline" id="Grill_(cryptology):122">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 in the catalog to learn the order and initial positions of the other two rotors.<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a></p>

<p>Initially, the Germans changed the rotor order infrequently, so the Poles would often know the rotor order before they began working. The rotor order changed every quarter until 1 February 1936. Then it changed every month until 1 November 1936, when it was changed daily.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a></p>
<h2 id="recovering-the-ring-setting">Recovering the ring setting</h2>

<p>The cryptanalyst now knew the plugboard, the rotor order, and the absolute setting of the rotors for the doubled key, but he did not know the ring setting. He also knew what the message key setting should be, but that setting was useless without knowing the ring setting. The ring setting could be anything, and that meant the Poles did know how to position the rotors for the message body. All the work up to this point had focussed on exploiting the doubled key. To determine the ring setting, the attention now shifted to the actual message.</p>

<p>Here, the Germans had made another mistake. Each message usually started with the text "ANX", which was German <em>an</em> meaning "to:" with the "X" meaning space. The Poles applied brute force here, too. They would go through up to <mtpl> 17,576}}</mtpl> settings to find settings that produced "ANX". Once found, the cryptanalyst would use the absolute setting of the rotors to determine the ring setting. The entire daily key was thus recovered.</p>

<p>Later, the Poles refined the brute force search technique. By examining some messages, they could determine the position of the rightmost rotor; consequently, only 676 rotor positions would have to be tried. Rejewski no longer remembers how this trick worked.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a></p>
<h2 id="decline">Decline</h2>

<p>The grill method is described by <a href="Marian_Rejewski" title="wikilink">Marian Rejewski</a> as being "manual and tedious"<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> and, like the later cryptologic bomb, as being "based... on the fact that the plug connections [in the Enigma's commutator, or "plugboard"] did not change all the letters." Unlike the bomb, however, "the grill method required unchanged <em>pairs</em> of letters [rather than] only unchanged letters."<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a></p>

<p>Initially, the plugboard only swapped six pairs of letters. That left more than half of the alphabet unaffected by permutation 

<math display="inline" id="Grill_(cryptology):123">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

. The number of steckers changed 1 August 1936; then it could be from 5 to 8 pairs of letters were swapped.<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a> The extra swapped characters reduced the effectiveness of the grid method, so the Poles started looking for other methods. The result was the cyclometer and corresponding card catalog; that method was immune to steckers.</p>

<p>The grill method found application as late as December 1938 in working out the wiring in two Enigma rotors newly introduced by the Germans. (This was made possible by the fact that a <em><a class="uri" href="Sicherheitsdienst" title="wikilink">Sicherheitsdienst</a></em> net, while it had introduced the new drums IV and V, continued using the old system for enciphering the individual message keys.)<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a></p>

<p>On 15 September 1938, most German nets stopped encrypting the doubled key with a common setting (the ground setting). The Poles had been able to take advantage of all messages in a net using the same machine settings to encrypt the doubled key. Now most nets stopped doing that; instead, the operator would choose his own ground setting and send it in the clear to the recipient.<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a> This change frustrated the grill method and the cyclometer card catalog. One net, the <em><a class="uri" href="Sicherheitsdienst" title="wikilink">Sicherheitsdienst</a></em> (SD) net, continued to use a common ground setting, and that net was used to reverse engineer new rotors (IV and V) that were introduced.<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> The SD net traffic was doubly encoded, so the ANX method would not work.<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a> The grill method would sometimes fail after the Germans increased the number of plugboard connections to ten on 1 January 1939. When the SD net switched to the new message-key protocol on 1 July 1939, the grill method (and the cyclometer method) were no longer useful.<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a></p>

<p>Here's an example of the new message procedure for a message on 21 September 1938.<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a></p>
<pre><code>2109 -1750 - 3 TLE - FRX FRX - 1TL -172=
HCALN UQKRQ AXPWT WUQTZ KFXZO MJFOY RHYZW VBXYS IWMMV WBLEB
DMWUW BTVHM RFLKS DCCEX IYPAH RMPZI OVBBR VLNHZ UPOSY EIPWJ
TUGYO SLAOX RHKVC HQOSV DTRBP DJEUK SBBXH TYGVH GFICA CVGUV
OQFAQ WBKXZ JSQJF ZPEVJ RO -</code></pre>

<p>The "3 TLE" (German <em>Teile</em>, parts) says it is a 3-part message; the "1TL" (German <em>Teil</em>, part) says this is the first part; the "172" says there are 172 characters in the message (including the message key). For this message, the ground setting "FRX" is transmitted twice in the clear; the ground setting would/should be different for every message on net. Consequently, the Poles could not find the needed sixty message keys encrypted under the same ground setting. Without the same-key message volume, they could not determine the characteristic, so they could not determine the permutations <em>A B C D E F</em> or use the grill. For this message, the daily settings (rotor order, plugboard, and ring settings) were used with "FRX" to decrypt the first six characters ("HCALN U") to obtain the doubled message key ("AGIAGI").</p>

<p>To decrypt these messages, the Poles used other techniques to exploit the doubled message key.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Permutation_matrix" title="wikilink">Permutation matrix</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>

<p>of </p></li>
<li>

<p>of </p></li>
<li>

<p>of </p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>Polish Contributions to Computing, <a class="uri" href="http://chc60.fgcu.edu/EN/HistoryDetail.aspx?c=1">http://chc60.fgcu.edu/EN/HistoryDetail.aspx?c=1</a></li>
<li>

<p>Also <a class="uri" href="https://www.iacr.org/archive/eurocrypt2003/26560106/26560106.doc">https://www.iacr.org/archive/eurocrypt2003/26560106/26560106.doc</a></p></li>
<li></li>
<li></li>
<li><a href="https://www.nsa.gov/public_info/_files/european_axis_sigint/volume_2_notes_on_german.pdf">European Axis Signal Intelligence in World War II as Revealed by "TICOM" Investigations and by other Prisoner of War Interrogations and Captured Material, Principally German: Volume 2 — Notes on German High Level Cryptography and Cryptanalysis</a>; see page 76: Swiss changed rotor wirings every 3 months, but Germans figured out the wirings because some messages were sent twice during the tri-monthly changeover. Germans were told new Croat rotor wirings by the company that manufactured the rotors.</li>
<li>[<a class="uri" href="https://books.google.com/books?id=pQBrsonDp6cC&amp;pg">https://books.google.com/books?id=pQBrsonDp6cC&amp;pg;</a>;=PA419&amp;lpg;=PA419&amp;source;=bl&amp;hl;=en&amp;sa;=X&amp;f;=false Bauer p 419]</li>
</ul>

<p>"</p>

<p><a href="Category:History_of_cryptography" title="wikilink">Category:History of cryptography</a> <a href="Category:Science_and_technology_in_Poland" title="wikilink">Category:Science and technology in Poland</a> <a href="Category:Biuro_Szyfrów" title="wikilink">Category:Biuro Szyfrów</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Marian Rejewski, Mathematical Solution of the Enigma Cipher, trans Christopher Kasparek, Cryptologia, Vol 6, Number 1, pp 1–18 at 17, January 1982<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"> This is the number of ways to arrange 26 distinct objects.<a href="#fnref3">↩</a></li>
<li id="fn4"> Take the number of ways to arrange 26 distinct letters (26!) and pair the selected letters. The paired letters interchange, so divide by 2<sup>13</sup> to account for the two orderings of each pair. The order the pairs are enumerated does not matter, so divide by the number of ways to order the 13 pairs (13!).<a href="#fnref4">↩</a></li>
<li id="fn5"> Take the number of ways to arrange 26 distinct letters and pair off the first 12 letters; divide by 2<sup>6</sup> because the pairs can be swapped (AB is same as BA), divide by 6! because the order of the pairs does not matter, and divide by 14! because the order of the trailing 14 characters does not matter.<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a class="uri" href="http://cryptocellar.web.cern.ch/cryptocellar/Enigma/EMsg1930.html">http://cryptocellar.web.cern.ch/cryptocellar/Enigma/EMsg1930.html</a>, citing 1930 "Schlüsselanleitung zur Chiffriermachine Enigma I" ["Directions for use of Keys on the Cypher Machine 'Enigma I'"]<a href="#fnref7">↩</a></li>
<li id="fn8">Can be checked with a simulator. For example, <a class="uri" href="http://people.physik.hu-berlin.de/~palloks/js/enigma/enigma-u_v20_en.html">http://people.physik.hu-berlin.de/~palloks/js/enigma/enigma-u_v20_en.html</a> Select Enigma I, choose reflector A (at the time, the Germans only had one reflector), set the wheel order (II, I, III), set the rings (24, 13, 22), set the plugs (AM, FI, NV, PS, TU, WZ), activate the plugboard, and set the wheels to the ground setting ("FOL"). Typing ABLABL in the input box should produce PKPJXI as the output.<a href="#fnref8">↩</a></li>
<li id="fn9"> stating, "The fact that the first six letters of each message formed its three-letter key, twice enciphered, was obvious, and I will not dwell on the matter."<a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"> at page 129 implies both notations used in 1815.<a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"> gives an example table of 65 message keys, but only 40 of those keys were distinct. Sixteen keys were repeated at least once. The encrypted key "SYX SCV" was used five times; it corresponded to the message key "AAA". The encrypted message key "RJL WPX" was used four times; it corresponded to "BBB".<a href="#fnref16">↩</a></li>
<li id="fn17"> states, "When I first assumed that there would be many keys of the sort <em>aaa</em>, <em>bbb</em>, etc., it was only a hypothesis that luckily turned out to be true. The changing tastes of cryptographers were very carefully followed, and other predilictions were uncovered."<a href="#fnref17">↩</a></li>
<li id="fn18"> stating, "Thus, one of the mysteries of the Enigma cipher, the secret of the message key, was solved. It is interesting that knowledge of neither of the positions of the drums nor the daily keys – in other words, none of the remaining secrets of the Enigma cipher – was needed to attain the result."<a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20">Later known as a "female".<a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29">One of the <code>D</code> interchanges is accidental due to a double stecker mapping a different interchange.<a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
<li id="fn31"></li>
<li id="fn32"><a href="#fnref32">↩</a></li>
<li id="fn33"></li>
<li id="fn34"></li>
<li id="fn35"></li>
<li id="fn36"></li>
<li id="fn37">: "...we soon noticed that if some part of the message was to begin with <em>ANX</em>, several positions of drum <em>N</em> would be impossible and should no longer be considered. Since there were a dozen or so messages every day in which one could expect to find the letters <em>ANX</em> at the beginning, it was usually possible to reject, purely by calculation, all impossible positions of drum <em>N</em> leaving just one or two to consider. (I no longer remember which calculations had to be performed and on which theoretical principles they were based.)"<a href="#fnref37">↩</a></li>
<li id="fn38"></li>
<li id="fn39"></li>
<li id="fn40"><a href="#fnref40">↩</a></li>
<li id="fn41"><a href="#fnref41">↩</a></li>
<li id="fn42"><a href="#fnref42">↩</a></li>
<li id="fn43"><a href="#fnref43">↩</a></li>
<li id="fn44"><a href="#fnref44">↩</a></li>
<li id="fn45"></li>
<li id="fn46"><a class="uri" href="http://cryptocellar.web.cern.ch/cryptocellar/Enigma/tbombe.html">http://cryptocellar.web.cern.ch/cryptocellar/Enigma/tbombe.html</a> transcribed from Cryptologia, C. A. Deavours and Louis Kruh, "The Turing Bombe: Was It Enough?", Cryptologia, Vol. XIV, No.4, October 1990, pp. 331-349, at page 342.<a href="#fnref46">↩</a></li>
</ol>
</section>
</body>
</html>
