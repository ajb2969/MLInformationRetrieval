<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="297">Analytic torsion</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Analytic torsion</h1>
<hr/>

<p>In mathematics, <strong>Reidemeister torsion</strong> (or <strong>R-torsion</strong>, or <strong>Reidemeister–Franz torsion</strong>) is a <a href="topological_invariant" title="wikilink">topological invariant</a> of <a href="manifold" title="wikilink">manifolds</a> introduced by <a href="Kurt_Reidemeister" title="wikilink">Kurt Reidemeister</a> () for <a href="3-manifold" title="wikilink">3-manifolds</a> and generalized to higher <a href="dimension" title="wikilink">dimensions</a> by  and . <strong>Analytic torsion</strong> (or <strong>Ray–Singer torsion</strong>) is an invariant of <a href="Riemannian_manifold" title="wikilink">Riemannian manifolds</a> defined by  as an analytic analogue of Reidemeister torsion.  and  proved Ray and Singer's conjecture that <a href="Reidemeister_torsion" title="wikilink">Reidemeister torsion</a> and analytic torsion are the same for compact Riemannian manifolds.</p>

<p>Reidemeister torsion was the first invariant in <a href="algebraic_topology" title="wikilink">algebraic topology</a> that could distinguish between spaces which are <a href="homotopy_equivalent" title="wikilink">homotopy equivalent</a> but not <a class="uri" href="homeomorphic" title="wikilink">homeomorphic</a>, and can thus be seen as the birth of <a href="geometric_topology" title="wikilink">geometric topology</a> as a distinct field. It can be used to classify <a href="lens_space" title="wikilink">lens spaces</a>.</p>

<p>Reidemeister torsion is closely related to <a href="Whitehead_torsion" title="wikilink">Whitehead torsion</a>; see . For later work on torsion see the books , . And it had given one of important motivation to <a href="arithmetic_topology" title="wikilink">arithmetic topology</a>. </p>
<h2 id="definition-of-analytic-torsion">Definition of analytic torsion</h2>

<p>If <em>M</em> is a Riemannian manifold and <em>E</em> a vector bundle over <em>M</em>, then there is a <a href="Laplacian_operator" title="wikilink">Laplacian operator</a> acting on the <em>i</em>-forms with values in <em>E</em>. If the <a href="eigenvalue" title="wikilink">eigenvalues</a> on <em>i</em>-forms are λ<sub><em>j</em></sub> then the zeta function ζ<sub><em>i</em></sub> is defined to be</p>

<p>

<math display="block" id="Analytic_torsion:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>ζ</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <msub>
       <mi>λ</mi>
       <mi>j</mi>
      </msub>
      <mo>></mo>
      <mn>0</mn>
     </mrow>
    </munder>
    <msubsup>
     <mi>λ</mi>
     <mi>j</mi>
     <mrow>
      <mo>-</mo>
      <mi>s</mi>
     </mrow>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ζ</ci>
      <ci>i</ci>
     </apply>
     <ci>s</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <gt></gt>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>λ</ci>
        <ci>j</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>λ</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \zeta_{i}(s)=\sum_{\lambda_{j}>0}\lambda_{j}^{-s}
  </annotation>
 </semantics>
</math>

</p>

<p>for <em>s</em> large, and this is extended to all complex <em>s</em> by <a href="analytic_continuation" title="wikilink">analytic continuation</a>. The zeta regularized determinant of the Laplacian acting on <em>i</em>-forms is</p>

<p>

<math display="block" id="Analytic_torsion:1">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Δ</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>exp</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mrow>
       <msubsup>
        <mi>ζ</mi>
        <mi>i</mi>
        <mo>′</mo>
       </msubsup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>0</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Δ</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <exp></exp>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ζ</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>i</ci>
       </apply>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta_{i}=\exp(-\zeta^{\prime}_{i}(0))
  </annotation>
 </semantics>
</math>

</p>

<p>which is formally the product of the positive eigenvalues of the laplacian acting on <em>i</em>-forms. The <strong>analytic torsion</strong> <em>T</em>(<em>M</em>,<em>E</em>) is defined to be</p>

<p>

<math display="block" id="Analytic_torsion:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo>,</mo>
      <mi>E</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <munder>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mi>i</mi>
       </munder>
       <mrow>
        <mrow>
         <msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi>i</mi>
         </msup>
         <mi>i</mi>
         <msubsup>
          <mi>ζ</mi>
          <mi>i</mi>
          <mo>′</mo>
         </msubsup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>0</mn>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
      <mi>i</mi>
     </munder>
     <msubsup>
      <mi mathvariant="normal">Δ</mi>
      <mi>i</mi>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mrow>
         <msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi>i</mi>
         </msup>
         <mi>i</mi>
        </mrow>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
     </msubsup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>T</ci>
      <interval closure="open">
       <ci>M</ci>
       <ci>E</ci>
      </interval>
     </apply>
     <apply>
      <exp></exp>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <ci>i</ci>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
          </apply>
          <ci>i</ci>
         </apply>
         <ci>i</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>ζ</ci>
           <ci>normal-′</ci>
          </apply>
          <ci>i</ci>
         </apply>
         <cn type="integer">0</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Δ</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <minus></minus>
            <cn type="integer">1</cn>
           </apply>
           <ci>i</ci>
          </apply>
          <ci>i</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(M,E)=\exp\left(\sum_{i}(-1)^{i}i\zeta^{\prime}_{i}(0)/2\right)=\prod_{i}%
\Delta_{i}^{-(-1)^{i}i/2}.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="definition-of-reidemeister-torsion">Definition of Reidemeister torsion</h2>

<p>Let 

<math display="inline" id="Analytic_torsion:3">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>


 be a finite connected <a href="CW_complex" title="wikilink">CW-complex</a> with <a href="fundamental_group" title="wikilink">fundamental group</a> 

<math display="inline" id="Analytic_torsion:4">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mo>:=</mo>
   <mrow>
    <msub>
     <mi>π</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>π</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>π</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi:=\pi_{1}(X)
  </annotation>
 </semantics>
</math>

 and <a href="universal_cover" title="wikilink">universal cover</a> 

<math display="inline" id="Analytic_torsion:5">
 <semantics>
  <mover accent="true">
   <mi>X</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\tilde{X}}
  </annotation>
 </semantics>
</math>

, and let 

<math display="inline" id="Analytic_torsion:6">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 be an orthogonal finite-dimensional 

<math display="inline" id="Analytic_torsion:7">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

-representation. Suppose that</p>

<p>

<math display="block" id="Analytic_torsion:8">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>H</mi>
     <mi>n</mi>
     <mi>π</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>;</mo>
     <mi>U</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <msub>
     <mi>H</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>U</mi>
       <msub>
        <mo>⊗</mo>
        <mrow>
         <mi>𝐙</mi>
         <mrow>
          <mo stretchy="false">[</mo>
          <mi>π</mi>
          <mo stretchy="false">]</mo>
         </mrow>
        </mrow>
       </msub>
       <msub>
        <mi>C</mi>
        <mo>*</mo>
       </msub>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mover accent="true">
        <mi>X</mi>
        <mo stretchy="false">~</mo>
       </mover>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>H</ci>
        <ci>π</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <list>
       <ci>X</ci>
       <ci>U</ci>
      </list>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <csymbol cd="latexml">tensor-product</csymbol>
         <apply>
          <times></times>
          <ci>𝐙</ci>
          <apply>
           <csymbol cd="latexml">delimited-[]</csymbol>
           <ci>π</ci>
          </apply>
         </apply>
        </apply>
        <ci>U</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>C</ci>
         <times></times>
        </apply>
       </apply>
       <apply>
        <ci>normal-~</ci>
        <ci>X</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H^{\pi}_{n}(X;U):=H_{n}(U\otimes_{\mathbf{Z}[\pi]}C_{*}({\tilde{X}}))=0
  </annotation>
 </semantics>
</math>

</p>

<p>for all n. If we fix a cellular basis for 

<math display="inline" id="Analytic_torsion:9">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mo>*</mo>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>X</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <times></times>
    </apply>
    <apply>
     <ci>normal-~</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{*}({\tilde{X}})
  </annotation>
 </semantics>
</math>

 and an orthogonal 

<math display="inline" id="Analytic_torsion:10">
 <semantics>
  <mi>𝐑</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐑</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{R}
  </annotation>
 </semantics>
</math>

-basis for 

<math display="inline" id="Analytic_torsion:11">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Analytic_torsion:12">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mo>*</mo>
   </msub>
   <mo>:=</mo>
   <mrow>
    <mrow>
     <mi>U</mi>
     <msub>
      <mo>⊗</mo>
      <mrow>
       <mi>𝐙</mi>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>π</mi>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </msub>
     <msub>
      <mi>C</mi>
      <mo>*</mo>
     </msub>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>X</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <times></times>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <times></times>
        <ci>𝐙</ci>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <ci>π</ci>
        </apply>
       </apply>
      </apply>
      <ci>U</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <times></times>
      </apply>
     </apply>
     <apply>
      <ci>normal-~</ci>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{*}:=U\otimes_{\mathbf{Z}[\pi]}C_{*}({\tilde{X}})
  </annotation>
 </semantics>
</math>

 is a contractible finite based free 

<math display="inline" id="Analytic_torsion:13">
 <semantics>
  <mi>𝐑</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐑</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{R}
  </annotation>
 </semantics>
</math>


-chain complex. Let 

<math display="inline" id="Analytic_torsion:14">
 <semantics>
  <mrow>
   <msub>
    <mi>γ</mi>
    <mo>*</mo>
   </msub>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi>D</mi>
     <mo>*</mo>
    </msub>
    <mo>→</mo>
    <msub>
     <mi>D</mi>
     <mrow>
      <mi></mi>
      <mo>*</mo>
      <mrow>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>γ</ci>
     <times></times>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <times></times>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <apply>
       <times></times>
       <csymbol cd="latexml">absent</csymbol>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma_{*}:D_{*}\to D_{*+1}
  </annotation>
 </semantics>
</math>

 be any chain contraction of D<sub>*</sub>, i.e. 

<math display="inline" id="Analytic_torsion:15">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>d</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>∘</mo>
     <msub>
      <mi>γ</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>γ</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>∘</mo>
     <msub>
      <mi>d</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>i</mi>
    <msub>
     <mi>d</mi>
     <msub>
      <mi>D</mi>
      <mi>n</mi>
     </msub>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <compose></compose>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>γ</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <compose></compose>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>γ</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>D</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{n+1}\circ\gamma_{n}+\gamma_{n-1}\circ d_{n}=id_{D_{n}}
  </annotation>
 </semantics>
</math>

 for all n. We obtain an isomorphism 

<math display="inline" id="Analytic_torsion:16">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>d</mi>
       <mo>*</mo>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>γ</mi>
       <mo>*</mo>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mi>o</mi>
     <mi>d</mi>
     <mi>d</mi>
    </mrow>
   </msub>
   <mo>:</mo>
   <mrow>
    <msub>
     <mi>D</mi>
     <mrow>
      <mi>o</mi>
      <mi>d</mi>
      <mi>d</mi>
     </mrow>
    </msub>
    <mo>→</mo>
    <msub>
     <mi>D</mi>
     <mrow>
      <mi>e</mi>
      <mi>v</mi>
      <mi>e</mi>
      <mi>n</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <times></times>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>γ</ci>
       <times></times>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>d</ci>
      <ci>d</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <apply>
       <times></times>
       <ci>o</ci>
       <ci>d</ci>
       <ci>d</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <apply>
       <times></times>
       <ci>e</ci>
       <ci>v</ci>
       <ci>e</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (d_{*}+\gamma_{*})_{odd}:D_{odd}\to D_{even}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Analytic_torsion:17">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mrow>
     <mi>o</mi>
     <mi>d</mi>
     <mi>d</mi>
    </mrow>
   </msub>
   <mo>:=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <msub>
      <mo>⊕</mo>
      <mrow>
       <mpadded width="+1.7pt">
        <mi>n</mi>
       </mpadded>
       <mi>o</mi>
       <mi>d</mi>
       <mi>d</mi>
      </mrow>
     </msub>
    </mpadded>
    <msub>
     <mi>D</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>d</ci>
      <ci>d</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>o</ci>
       <ci>d</ci>
       <ci>d</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{odd}:=\oplus_{n\,odd}\,D_{n}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Analytic_torsion:18">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mrow>
     <mi>e</mi>
     <mi>v</mi>
     <mi>e</mi>
     <mi>n</mi>
    </mrow>
   </msub>
   <mo>:=</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <msub>
      <mo>⊕</mo>
      <mrow>
       <mpadded width="+1.7pt">
        <mi>n</mi>
       </mpadded>
       <mi>e</mi>
       <mi>v</mi>
       <mi>e</mi>
       <mi>n</mi>
      </mrow>
     </msub>
    </mpadded>
    <msub>
     <mi>D</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <apply>
      <times></times>
      <ci>e</ci>
      <ci>v</ci>
      <ci>e</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>e</ci>
       <ci>v</ci>
       <ci>e</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{even}:=\oplus_{n\,even}\,D_{n}
  </annotation>
 </semantics>
</math>


. We define the <strong>Reidemeister torsion</strong></p>

<p>

<math display="block" id="Analytic_torsion:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>ρ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>;</mo>
     <mi>U</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mrow>
       <mi>d</mi>
       <mi>e</mi>
       <mi>t</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>∈</mo>
   <msup>
    <mi>𝐑</mi>
    <mrow>
     <mi></mi>
     <mo>></mo>
     <mn>0</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <apply>
      <times></times>
      <ci>ρ</ci>
      <list>
       <ci>X</ci>
       <ci>U</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <apply>
         <times></times>
         <ci>d</ci>
         <ci>e</ci>
         <ci>t</ci>
        </apply>
        <ci>A</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐑</ci>
      <apply>
       <gt></gt>
       <csymbol cd="latexml">absent</csymbol>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(X;U):=|\mathop{det}(A)|^{-1}\in\mathbf{R}^{>0}
  </annotation>
 </semantics>
</math>

</p>

<p>where A is the matrix of 

<math display="inline" id="Analytic_torsion:20">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>d</mi>
      <mo>*</mo>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>γ</mi>
      <mo>*</mo>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>o</mi>
    <mi>d</mi>
    <mi>d</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <times></times>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>γ</ci>
      <times></times>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>d</ci>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (d_{*}+\gamma_{*})_{odd}
  </annotation>
 </semantics>
</math>

 with respect to the given bases. The Reidemeister torsion 

<math display="inline" id="Analytic_torsion:21">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>;</mo>
    <mi>U</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ρ</ci>
    <list>
     <ci>X</ci>
     <ci>U</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho(X;U)
  </annotation>
 </semantics>
</math>

 is independent of the choice of the cellular basis for 

<math display="inline" id="Analytic_torsion:22">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mo>*</mo>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>X</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <times></times>
    </apply>
    <apply>
     <ci>normal-~</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{*}({\tilde{X}})
  </annotation>
 </semantics>
</math>

, the orthogonal basis for 

<math display="inline" id="Analytic_torsion:23">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>


 and the chain contraction 

<math display="inline" id="Analytic_torsion:24">
 <semantics>
  <msub>
   <mi>γ</mi>
   <mo>*</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>γ</ci>
    <times></times>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma_{*}
  </annotation>
 </semantics>
</math>

.</p>

<p>Let 

<math display="inline" id="Analytic_torsion:25">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 be a compact smooth manifold, and let 

<math display="inline" id="Analytic_torsion:26">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>π</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mi>G</mi>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>E</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>ρ</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>π</ci>
      <ci>M</ci>
     </apply>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>L</ci>
      <ci>E</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho:\pi(M)\rightarrow GL(E)
  </annotation>
 </semantics>
</math>

 be a unimodular representation. 

<math display="inline" id="Analytic_torsion:27">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 has a smooth triangulation. For any choice of a volume 

<math display="inline" id="Analytic_torsion:28">
 <semantics>
  <mrow>
   <mi>μ</mi>
   <mo>∈</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mi>e</mi>
     <mi>t</mi>
    </mrow>
    <mrow>
     <msub>
      <mi>H</mi>
      <mo>*</mo>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>μ</ci>
    <apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>e</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <times></times>
      </apply>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu\in\mathop{det}H_{*}(M)
  </annotation>
 </semantics>
</math>


, we get an invariant 

<math display="inline" id="Analytic_torsion:29">
 <semantics>
  <mrow>
   <msub>
    <mi>τ</mi>
    <mi>M</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ρ</mi>
    <mo>:</mo>
    <mi>μ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>𝐑</mi>
    <mo>+</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>τ</ci>
     <ci>M</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ρ</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">μ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝐑</ci>
     <plus></plus>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau_{M}(\rho:\mu)\in\mathbf{R}^{+}
  </annotation>
 </semantics>
</math>

. Then we call the positive real number 

<math display="inline" id="Analytic_torsion:30">
 <semantics>
  <mrow>
   <msub>
    <mi>τ</mi>
    <mi>M</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ρ</mi>
    <mo>:</mo>
    <mi>μ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>τ</ci>
     <ci>M</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ρ</csymbol>
     <ci>normal-:</ci>
     <csymbol cd="unknown">μ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau_{M}(\rho:\mu)
  </annotation>
 </semantics>
</math>

 the Reidemiester torsion of the manifold 

<math display="inline" id="Analytic_torsion:31">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 respect to 

<math display="inline" id="Analytic_torsion:32">
 <semantics>
  <mi>ρ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ρ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Analytic_torsion:33">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>


.</p>
<h2 id="a-short-history-of-reidemeister-torsion">A short history of Reidemeister torsion</h2>

<p>Reidemeister torsion was first used to combinatorially classify 3-dimensional <a href="lens_space" title="wikilink">lens spaces</a> in  by Reidemeister, and in higher-dimensional spaces by Franz. The classification includes examples of <a href="homotopy_equivalent" title="wikilink">homotopy equivalent</a> 3-dimensional manifolds which are not <a class="uri" href="homeomorphic" title="wikilink">homeomorphic</a> – at the time (1935) the classification was only up to <a href="PL_homeomorphism" title="wikilink">PL homeomorphism</a>, but later  showed that this was in fact a classification up to <a class="uri" href="homeomorphism" title="wikilink">homeomorphism</a>.</p>

<p>J. H. C. Whitehead defined the "torsion" of a homotopy equivalence between finite complexes. This is a direct generalization of the Reidemeister, Franz, and de Rham concept; but is a more delicate invariant. <a href="Whitehead_torsion" title="wikilink">Whitehead torsion</a> provides a key tool for the study of combinatorial or differentiable manifolds with nontrivial fundamental group and is closely related to the concept of "simple homotopy type." see </p>

<p>In 1960 Milnor discovered the duality relation of torsion invariants of manifolds and show that the (twisted) Alexander polynomial of knots is the Reidemister torsion of its knot complement in <em>S</em><sup>3</sup>.  For each <em>q</em> the <a href="Poincaré_duality" title="wikilink">Poincaré duality</a> 

<math display="inline" id="Analytic_torsion:34">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>o</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>o</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{o}
  </annotation>
 </semantics>
</math>

 induces</p>

<p>

<math display="block" id="Analytic_torsion:35">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>o</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo>det</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>H</mi>
        <mi>q</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>M</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mover>
     <mo movablelimits="false">⟶</mo>
     <mo>∼</mo>
    </mover>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>det</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>H</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mi>q</mi>
          </mrow>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>M</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>o</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-⟶</ci>
      <csymbol cd="latexml">similar-to</csymbol>
     </apply>
     <apply>
      <ci>det</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>H</ci>
        <ci>q</ci>
       </apply>
       <ci>M</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <ci>det</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>H</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <ci>q</ci>
         </apply>
        </apply>
        <ci>M</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{o}:\operatorname{det}(H_{q}(M))\stackrel{\sim}{\longrightarrow}(%
\operatorname{det}(H_{n-q}(M)))^{-1}
  </annotation>
 </semantics>
</math>

 and then we obtain</p>

<p>

<math display="block" id="Analytic_torsion:36">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>±</mo>
     <mrow>
      <msup>
       <mi>t</mi>
       <mi>n</mi>
      </msup>
      <mi mathvariant="normal">Δ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mi>t</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">plus-or-minus</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>t</ci>
       <ci>n</ci>
      </apply>
      <ci>normal-Δ</ci>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta(t)=\pm t^{n}\Delta(1/t).
  </annotation>
 </semantics>
</math>

 The representation of the fundamental group of knot complement plays a central role in them. It gives the relation between knot theory and torsion invariants.</p>
<h2 id="cheegermüller-theorem">Cheeger–Müller theorem</h2>

<p>Let 

<math display="inline" id="Analytic_torsion:37">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>M</mi>
   <mo>,</mo>
   <mi>g</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>M</ci>
    <ci>g</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (M,g)
  </annotation>
 </semantics>
</math>

 be an orientable compact Riemann manifold of dimension n and 

<math display="inline" id="Analytic_torsion:38">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>π</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>M</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mrow>
      <mi>G</mi>
      <mi>L</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>E</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>ρ</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>π</ci>
      <ci>M</ci>
     </apply>
     <apply>
      <apply>
       <times></times>
       <ci>G</ci>
       <ci>L</ci>
      </apply>
      <ci>E</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho:\pi(M)\rightarrow\mathop{GL}(E)
  </annotation>
 </semantics>
</math>


 a representation of the fundamental group of 

<math display="inline" id="Analytic_torsion:39">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 on a real vector space of dimension N. Then we can define the De Rham complex</p>

<p>

<math display="block" id="Analytic_torsion:40">
 <semantics>
  <mrow>
   <msup>
    <mi mathvariant="normal">Λ</mi>
    <mn>0</mn>
   </msup>
   <mover>
    <mo movablelimits="false">⟶</mo>
    <msub>
     <mi>d</mi>
     <mn>0</mn>
    </msub>
   </mover>
   <msup>
    <mi mathvariant="normal">Λ</mi>
    <mn>1</mn>
   </msup>
   <mover>
    <mo movablelimits="false">⟶</mo>
    <msub>
     <mi>d</mi>
     <mn>1</mn>
    </msub>
   </mover>
   <mi mathvariant="normal">⋯</mi>
   <mover>
    <mo movablelimits="false">⟶</mo>
    <msub>
     <mi>d</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mover>
   <msup>
    <mi mathvariant="normal">Λ</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-⟶</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Λ</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Λ</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-⟶</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-⟶</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Λ</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda^{0}\stackrel{d_{0}}{\longrightarrow}\Lambda^{1}\stackrel{d_{1}}{%
\longrightarrow}\cdots\stackrel{d_{n-1}}{\longrightarrow}\Lambda^{n}
  </annotation>
 </semantics>
</math>

 and the formal adjoint 

<math display="inline" id="Analytic_torsion:41">
 <semantics>
  <msub>
   <mi>d</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{p}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Analytic_torsion:42">
 <semantics>
  <msub>
   <mi>δ</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>δ</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{p}
  </annotation>
 </semantics>
</math>

 due to the flatness of 

<math display="inline" id="Analytic_torsion:43">
 <semantics>
  <msub>
   <mi>E</mi>
   <mi>q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{q}
  </annotation>
 </semantics>
</math>


. And we also obtain the Laplacian on p-form as usual</p>

<p>

<math display="block" id="Analytic_torsion:44">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Δ</mi>
     <mi>p</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>δ</mi>
       <mi>p</mi>
      </msub>
      <msub>
       <mi>d</mi>
       <mi>p</mi>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>d</mi>
       <mrow>
        <mi>p</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <msub>
       <mi>δ</mi>
       <mrow>
        <mi>p</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Δ</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>δ</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <ci>p</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <apply>
        <minus></minus>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>δ</ci>
       <apply>
        <minus></minus>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta_{p}=\delta_{p}d_{p}+d_{p-1}\delta_{p-1}.
  </annotation>
 </semantics>
</math>

</p>

<p>We assume 

<math display="inline" id="Analytic_torsion:45">
 <semantics>
  <mrow>
   <mrow>
    <mo>∂</mo>
    <mi>M</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <partialdiff></partialdiff>
     <ci>M</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial M=0
  </annotation>
 </semantics>
</math>

, then the Laplacian is a symmetric positive simipositive elliptic operator with pure point spectrum</p>

<p>

<math display="block" id="Analytic_torsion:46">
 <semantics>
  <mrow>
   <mrow>
    <mn>0</mn>
    <mo>≤</mo>
    <msub>
     <mi>λ</mi>
     <mn>0</mn>
    </msub>
    <mo>≤</mo>
    <msub>
     <mi>λ</mi>
     <mn>1</mn>
    </msub>
    <mo>≤</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>→</mo>
    <mi mathvariant="normal">∞</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <infinity></infinity>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq\lambda_{0}\leq\lambda_{1}\leq\cdots\rightarrow\infty.
  </annotation>
 </semantics>
</math>

 As same as the above definition we can define the zeta function associated with the Laplacian 

<math display="inline" id="Analytic_torsion:47">
 <semantics>
  <msub>
   <mi mathvariant="normal">Δ</mi>
   <mi>q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Δ</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta_{q}
  </annotation>
 </semantics>
</math>

 on 

<math display="inline" id="Analytic_torsion:48">
 <semantics>
  <mrow>
   <msup>
    <mi mathvariant="normal">Λ</mi>
    <mi>q</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Λ</ci>
     <ci>q</ci>
    </apply>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda^{q}(E)
  </annotation>
 </semantics>
</math>


 by</p>

<p>

<math display="block" id="Analytic_torsion:49">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>ζ</mi>
      <mi>q</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo>;</mo>
      <mi>ρ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <msub>
        <mi>λ</mi>
        <mi>j</mi>
       </msub>
       <mo>></mo>
       <mn>0</mn>
      </mrow>
     </munder>
     <msubsup>
      <mi>λ</mi>
      <mi>j</mi>
      <mrow>
       <mo>-</mo>
       <mi>s</mi>
      </mrow>
     </msubsup>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mi mathvariant="normal">Γ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <mn>0</mn>
       <mi mathvariant="normal">∞</mi>
      </msubsup>
      <mrow>
       <msup>
        <mi>t</mi>
        <mrow>
         <mi>s</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mrow>
        <mrow>
         <mi>T</mi>
         <mi>r</mi>
        </mrow>
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msup>
            <mi>e</mi>
            <mrow>
             <mo>-</mo>
             <mrow>
              <mi>t</mi>
              <msub>
               <mi mathvariant="normal">Δ</mi>
               <mi>q</mi>
              </msub>
             </mrow>
            </mrow>
           </msup>
           <mo>-</mo>
           <msub>
            <mi>P</mi>
            <mi>q</mi>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mi>d</mi>
         <mi>t</mi>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="17.5pt">,</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>R</mi>
      <mi>e</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>></mo>
    <mfrac>
     <mi>n</mi>
     <mn>2</mn>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ζ</ci>
        <ci>q</ci>
       </apply>
       <list>
        <ci>s</ci>
        <ci>ρ</ci>
       </list>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <gt></gt>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>λ</ci>
          <ci>j</ci>
         </apply>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>λ</ci>
         <ci>j</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <ci>normal-Γ</ci>
         <ci>s</ci>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <int></int>
          <infinity></infinity>
         </apply>
         <cn type="integer">0</cn>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>t</ci>
          <apply>
           <minus></minus>
           <ci>s</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <apply>
           <times></times>
           <ci>T</ci>
           <ci>r</ci>
          </apply>
          <apply>
           <times></times>
           <apply>
            <minus></minus>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>e</ci>
             <apply>
              <minus></minus>
              <apply>
               <times></times>
               <ci>t</ci>
               <apply>
                <csymbol cd="ambiguous">subscript</csymbol>
                <ci>normal-Δ</ci>
                <ci>q</ci>
               </apply>
              </apply>
             </apply>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>P</ci>
             <ci>q</ci>
            </apply>
           </apply>
           <ci>d</ci>
           <ci>t</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <gt></gt>
     <apply>
      <apply>
       <times></times>
       <ci>R</ci>
       <ci>e</ci>
      </apply>
      <ci>s</ci>
     </apply>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \zeta_{q}(s;\rho)=\sum_{\lambda_{j}>0}\lambda_{j}^{-s}=\frac{1}{\Gamma(s)}\int%
^{\infty}_{0}t^{s-1}\mathop{Tr}(e^{-t\Delta_{q}}-P_{q})dt,\ \ \ \mathop{Re}(s)%
>\frac{n}{2}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Analytic_torsion:50">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is the projection of 

<math display="inline" id="Analytic_torsion:51">
 <semantics>
  <mrow>
   <msup>
    <mi>L</mi>
    <mn>2</mn>
   </msup>
   <mi mathvariant="normal">Λ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>L</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-Λ</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{2}\Lambda(E)
  </annotation>
 </semantics>
</math>

 onto the kernel space 

<math display="inline" id="Analytic_torsion:52">
 <semantics>
  <mrow>
   <msup>
    <mi class="ltx_font_mathcaligraphic">ℋ</mi>
    <mi>q</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℋ</ci>
     <ci>q</ci>
    </apply>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}^{q}(E)
  </annotation>
 </semantics>
</math>

 of the Laplacian 

<math display="inline" id="Analytic_torsion:53">
 <semantics>
  <msub>
   <mi mathvariant="normal">Δ</mi>
   <mi>q</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Δ</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta_{q}
  </annotation>
 </semantics>
</math>


.</p>

<p>In 1967 Seeley proved that 

<math display="inline" id="Analytic_torsion:54">
 <semantics>
  <mrow>
   <msub>
    <mi>ζ</mi>
    <mi>q</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>;</mo>
    <mi>ρ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ζ</ci>
     <ci>q</ci>
    </apply>
    <list>
     <ci>s</ci>
     <ci>ρ</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \zeta_{q}(s;\rho)
  </annotation>
 </semantics>
</math>

 extends to a meromorphic function of 

<math display="inline" id="Analytic_torsion:55">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>∈</mo>
   <mi>𝐂</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>s</ci>
    <ci>𝐂</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\in\mathbf{C}
  </annotation>
 </semantics>
</math>

 which is holomorphic at 

<math display="inline" id="Analytic_torsion:56">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=0
  </annotation>
 </semantics>
</math>

. </p>

<p>As in the case of an orthogonal representation, we define the analytic torsion 

<math display="inline" id="Analytic_torsion:57">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mi>M</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ρ</mi>
    <mo>;</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <ci>M</ci>
    </apply>
    <list>
     <ci>ρ</ci>
     <ci>E</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{M}(\rho;E)
  </annotation>
 </semantics>
</math>

 by</p>

<p>

<math display="block" id="Analytic_torsion:58">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mi>M</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ρ</mi>
    <mo>;</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>exp</mi>
   <mrow>
    <mo maxsize="210%" minsize="210%">(</mo>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>q</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>n</mi>
    </munderover>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>-</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>q</mi>
    </msup>
    <mi>q</mi>
    <mfrac>
     <mi>d</mi>
     <mrow>
      <mi>d</mi>
      <mi>s</mi>
     </mrow>
    </mfrac>
    <msub>
     <mi>ζ</mi>
     <mi>q</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo>;</mo>
     <mi>ρ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <msub>
      <mo fence="true" maxsize="210%" minsize="210%">|</mo>
      <mrow>
       <mi>s</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
     </msub>
     <mo maxsize="210%" minsize="210%">)</mo>
    </mrow>
    <mo>.</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <ci>M</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ρ</csymbol>
     <ci>normal-;</ci>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <exp></exp>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <sum></sum>
       <ci>n</ci>
      </apply>
      <apply>
       <eq></eq>
       <ci>q</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <minus></minus>
       <csymbol cd="unknown">l</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>q</ci>
     </apply>
     <csymbol cd="unknown">q</csymbol>
     <apply>
      <divide></divide>
      <ci>d</ci>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ζ</ci>
      <ci>q</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-;</ci>
      <csymbol cd="unknown">ρ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-|</ci>
       <apply>
        <eq></eq>
        <ci>s</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-.</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{M}(\rho;E)=\exp\biggl(\frac{1}{2}\sum^{n}_{q=0}(-l)^{q}q\frac{d}{ds}\zeta_{%
q}(s;\rho)\biggl|_{s=0}\biggr).
  </annotation>
 </semantics>
</math>

</p>

<p>In 1971 D.B. Ray and I.M. Singer conjectured that 

<math display="inline" id="Analytic_torsion:59">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>T</mi>
     <mi>M</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ρ</mi>
     <mo>;</mo>
     <mi>E</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>τ</mi>
     <mi>M</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ρ</mi>
     <mo>;</mo>
     <mi>μ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>M</ci>
     </apply>
     <list>
      <ci>ρ</ci>
      <ci>E</ci>
     </list>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <ci>M</ci>
     </apply>
     <list>
      <ci>ρ</ci>
      <ci>μ</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{M}(\rho;E)=\tau_{M}(\rho;\mu)
  </annotation>
 </semantics>
</math>

 for any unitary representation 

<math display="inline" id="Analytic_torsion:60">
 <semantics>
  <mi>ρ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ρ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

. Independently, J. Cheeger  and W. Muller  proved the Ray–Singer conjecture. Their idea is considering the logarithm of torsions and their traces. Firstly for odd-dimensional manifolds they had proved the equality of two torsions and then for even-dimensional, which have some technical difficulties.</p>

<p>In later years, along with <a href="Atiyah–Singer_index_theorem" title="wikilink">Atiyah–Patodi–Singer theorem</a>, the Cheeger–Müller theorem, i.e. the equivalence of two torsions, forms the basis of <a href="Chern–Simons_theory" title="wikilink">Chern–Simons perturbation theory</a>.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>

<p>Online book</p></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Differential_geometry" title="wikilink">Category:Differential geometry</a> <a class="uri" href="Category:3-manifolds" title="wikilink">Category:3-manifolds</a> <a href="Category:Surgery_theory" title="wikilink">Category:Surgery theory</a></p>
</body>
</html>
