<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1175">Kleene's T predicate</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Kleene's T predicate</h1>
<hr/>

<p>In <a href="computability_theory" title="wikilink">computability theory</a>, the <strong>T predicate</strong>, first studied by mathematician <a href="Stephen_Cole_Kleene" title="wikilink">Stephen Cole Kleene</a>, is a particular <a href="ternary_relation" title="wikilink">set of triples</a> of <a href="natural_number" title="wikilink">natural numbers</a> that is used to represent <a href="computable_function" title="wikilink">computable functions</a> within <a href="theory_(mathematical_logic)" title="wikilink">formal theories</a> of <a class="uri" href="arithmetic" title="wikilink">arithmetic</a>. Informally, the <em>T</em> predicate tells whether a particular <a href="computer_program" title="wikilink">computer program</a> will halt when run with a particular input, and the corresponding <em>U</em> function is used to obtain the results of the computation if the program does halt. As with the <a href="Smn_theorem" title="wikilink">s<sub>mn</sub> theorem</a>, the original notation used by Kleene has become standard terminology for the concept.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="definition">Definition</h2>

<p>The definition depends on a suitable <a href="Gödel_numbering" title="wikilink">Gödel numbering</a> that assigns natural numbers to <a href="computable_function" title="wikilink">computable functions</a>. This numbering must be sufficiently effective that, given an index of a computable function and an input to the function, it is possible to effectively simulate the computation of the function on that input. The <em>T</em> predicate is obtained by formalizing this simulation.</p>

<p>The <a href="ternary_relation" title="wikilink">ternary relation</a> <em>T</em><sub>1</sub>(<em>e</em>,<em>i</em>,<em>x</em>) takes three natural numbers as arguments. The triples of numbers (<em>e</em>,<em>i</em>,<em>x</em>) that belong to the relation (the ones for which <em>T</em><sub>1</sub>(<em>e</em>,<em>i</em>,<em>x</em>) is true) are defined to be exactly the triples in which <em>x</em> encodes a computation history of the computable function with index <em>e</em> when run with input <em>i</em>, and the program halts as the last step of this computation history. That is, <em>T</em><sub>1</sub> first asks whether <em>x</em> is the <a href="Gödel_numbering_for_sequences" title="wikilink">Gödel number</a> of a finite sequence 〈<em>x</em><sub><em>j</em></sub>〉 of complete configurations of the Turing machine with index <em>e</em>, running a computation on input <em>i</em>. If so, <em>T</em><sub>1</sub> then asks if this sequence begins with the starting state of the computation and each successive element of the sequence corresponds to a single step of the Turing machine. If it does, <em>T</em><sub>1</sub> finally asks whether the sequence 〈<em>x</em><sub><em>j</em></sub>〉 ends with the machine in a halting state. If all three of these questions have a positive answer, then <em>T</em><sub>1</sub>(<em>e</em>,<em>i</em>,<em>x</em>) holds (is true). Otherwise, <em>T</em><sub>1</sub>(<em>e</em>,<em>i</em>,<em>x</em>) does not hold (is false).</p>

<p>There is a corresponding function <em>U</em> such that if <em>T</em>(<em>e</em>,<em>i</em>,<em>x</em>) holds then <em>U</em>(<em>x</em>) returns the output of the function with index <em>e</em> on input <em>i</em>.</p>

<p>Because Kleene's formalism attaches a number of inputs to each function, the predicate <em>T</em><sub>1</sub> can only be used for functions that take one input. There are additional predicates for functions with multiple inputs; the relation</p>

<p>

<math display="block" id="Kleene's_T_predicate:0">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo>,</mo>
    <msub>
     <mi>i</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>i</mi>
     <mi>k</mi>
    </msub>
    <mo>,</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <ci>k</ci>
    </apply>
    <vector>
     <ci>e</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>i</ci>
      <ci>k</ci>
     </apply>
     <ci>x</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{k}(e,i_{1},\ldots,i_{k},x)
  </annotation>
 </semantics>
</math>

,</p>

<p>holds if <em>x</em> encodes a halting computation of the function with index <em>e</em> on the inputs <em>i</em><sub>1</sub>,...,<em>i</em><sub><em>k</em></sub>.</p>
<h2 id="normal-form-theorem">Normal form theorem</h2>

<p>The <em>T</em> predicate can be used to obtain <strong>Kleene's normal form theorem</strong> for computable functions (Soare 1987, p. 15). This states there exists a <a href="primitive_recursive_function" title="wikilink">primitive recursive function</a> <em>U</em> such that a function <em>f</em> of one integer argument is computable if and only if there is a number <em>e</em> such that for all <em>n</em> one has</p>

<p>

<math display="block" id="Kleene's_T_predicate:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≃</mo>
   <mrow>
    <mi>U</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>μ</mi>
      <mpadded width="+1.7pt">
       <mi>x</mi>
      </mpadded>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>e</mi>
       <mo>,</mo>
       <mi>n</mi>
       <mo>,</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to-or-equals</csymbol>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>U</ci>
     <apply>
      <times></times>
      <ci>μ</ci>
      <ci>x</ci>
      <ci>T</ci>
      <vector>
       <ci>e</ci>
       <ci>n</ci>
       <ci>x</ci>
      </vector>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)\simeq U(\mu x\,T(e,n,x))
  </annotation>
 </semantics>
</math>

, where <em>μ</em> is the <a href="mu_operator" title="wikilink"><em>μ</em> operator</a> (

<math display="inline" id="Kleene's_T_predicate:2">
 <semantics>
  <mrow>
   <mi>μ</mi>
   <mpadded width="+1.7pt">
    <mi>x</mi>
   </mpadded>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>μ</ci>
    <ci>x</ci>
    <ci>ϕ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu x\,\phi(x)
  </annotation>
 </semantics>
</math>

 is the smallest natural number for which 

<math display="inline" id="Kleene's_T_predicate:3">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(x)
  </annotation>
 </semantics>
</math>

 holds) and 

<math display="inline" id="Kleene's_T_predicate:4">
 <semantics>
  <mo>≃</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">similar-to-or-equals</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \simeq
  </annotation>
 </semantics>
</math>

 holds if both sides are undefined or if both are defined and they are equal. Here <em>U</em> is a universal operation (it is independent of the computable function <em>f</em>) whose purpose is to extract, from the number <em>x</em> (encoding a complete computation history) returned by the operator <em>μ</em>, just the value <em>f</em>(<em>n</em>) that was found at the end of the computation.</p>
<h2 id="formalization">Formalization</h2>

<p>The <em>T</em> predicate is <a href="primitive_recursive" title="wikilink">primitive recursive</a> in the sense that there is a primitive recursive function that, given inputs for the predicate, correctly determine the truth value of the predicate on those inputs. Similarly, the <em>U</em> function is primitive recursive.</p>

<p>Because of this, any theory of arithmetic that is able to represent every primitive recursive function is able to represent <em>T</em> and <em>U</em>. Examples of such arithmetical theories include <a href="Robinson_arithmetic" title="wikilink">Robinson arithmetic</a> and stronger theories such as <a href="Peano_arithmetic" title="wikilink">Peano arithmetic</a>.</p>
<h2 id="arithmetical-hierarchy">Arithmetical hierarchy</h2>

<p>In addition to encoding computability, the <em>T</em> predicate can be used to generate complete sets in the <a href="arithmetical_hierarchy" title="wikilink">arithmetical hierarchy</a>. In particular, the set</p>

<p>

<math display="block" id="Kleene's_T_predicate:5">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>e</mi>
     <mrow></mrow>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow></mrow>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <mi>x</mi>
       <mi>T</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>e</mi>
        <mo>,</mo>
        <mn>0</mn>
        <mo>,</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>K</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <ci>e</ci>
      <mtext></mtext>
     </apply>
     <apply>
      <times></times>
      <mtext></mtext>
      <apply>
       <exists></exists>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>T</ci>
        <vector>
         <ci>e</ci>
         <cn type="integer">0</cn>
         <ci>x</ci>
        </vector>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K=\{e\mbox{ }:\mbox{ }\exists xT(e,0,x)\}
  </annotation>
 </semantics>
</math>

</p>

<p>which is of the same <a href="Turing_degree" title="wikilink">Turing degree</a> as the <a href="halting_problem" title="wikilink">halting problem</a>, is a 

<math display="inline" id="Kleene's_T_predicate:6">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mn>1</mn>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0}_{1}
  </annotation>
 </semantics>
</math>

 complete unary relation (Soare 1987, pp. 28, 41). More generally, the set</p>

<p>

<math display="block" id="Kleene's_T_predicate:7">
 <semantics>
  <mrow>
   <msub>
    <mi>K</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>e</mi>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <mi>x</mi>
      <mi>T</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>e</mi>
       <mo>,</mo>
       <msub>
        <mi>a</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>a</mi>
        <mi>n</mi>
       </msub>
       <mo>,</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <list>
      <ci>e</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
     </list>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>T</ci>
       <vector>
        <ci>e</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>n</ci>
        </apply>
        <ci>x</ci>
       </vector>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{n+1}=\{\langle e,a_{1},\ldots,a_{n}\rangle:\exists xT(e,a_{1},\ldots,a_{n},%
x)\}
  </annotation>
 </semantics>
</math>

 is a 

<math display="inline" id="Kleene's_T_predicate:8">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mn>1</mn>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0}_{1}
  </annotation>
 </semantics>
</math>

 complete (<em>n</em>+1)-ary predicate. Thus, once a representation of the <em>T</em> predicate is obtained in a theory of arithmetic, a representation of a 

<math display="inline" id="Kleene's_T_predicate:9">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mn>1</mn>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0}_{1}
  </annotation>
 </semantics>
</math>

-complete predicate can be obtained from it.</p>

<p>This construction can be extended higher in the arithmetical hierarchy, as in <a href="Post's_theorem" title="wikilink">Post's theorem</a> (compare Hinman 2005, p. 397). For example, if a set 

<math display="inline" id="Kleene's_T_predicate:10">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>⊆</mo>
   <msup>
    <mi>ℕ</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>A</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℕ</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\subseteq\mathbb{N}^{k+1}
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Kleene's_T_predicate:11">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Σ</mi>
   <mi>n</mi>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{0}_{n}
  </annotation>
 </semantics>
</math>

 complete then the set</p>

<p>

<math display="block" id="Kleene's_T_predicate:12">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>:</mo>
   <mo>∀</mo>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mi>k</mi>
     </msub>
     <mo>,</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-{</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>k</ci>
     </apply>
     <ci>normal-⟩</ci>
    </cerror>
    <ci>normal-:</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-⟨</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <ci>normal-…</ci>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>k</ci>
      </apply>
      <ci>normal-,</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-}</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\langle a_{1},\ldots,a_{k}\rangle:\forall x(\langle a_{1},\ldots,a_{k},x)\in
A)\}
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Kleene's_T_predicate:13">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Π</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Π</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi^{0}_{n+1}
  </annotation>
 </semantics>
</math>

 complete.</p>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li>Peter Hinman, 2005, <em>Fundamentals of Mathematical Logic</em>, A K Peters. ISBN 978-1-56881-262-5</li>
<li><a href="Stephen_Cole_Kleene" title="wikilink">Stephen Cole Kleene</a>, 1943, "Recursive predicates and quantifiers", <em>Transactions of the AMS</em> v. 53 n. 1, pp. 41–73. Reprinted in <em>The Undecidable</em>, Martin Davis, ed., 1965, pp. 255–287.</li>
<li>—, 1952, <em>Introduction to Metamathematics</em>, North-Holland. Reprinted by Ishi press, 2009, ISBN 0-923891-57-9.</li>
<li>—, 1967. <em>Mathematical Logic,</em> John Wiley. Reprinted by Dover, 2001, ISBN 0-486-42533-9.</li>
<li><a href="Robert_I._Soare" title="wikilink">Robert I. Soare</a>, 1987, <em>Recursively enumerable sets and degrees,</em> Perspectives in Mathematical Logic, Springer. ISBN 0-387-15299-7</li>
</ul>

<p>"</p>

<p><a href="Category:Computability_theory" title="wikilink">Category:Computability theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">The predicate described here was presented in (Kleene 1943) and (Kleene 1952), and this is what is usually called "Kleene's <em>T</em> predicate". (Kleene 1967) uses the letter <em>T</em> to describe a different predicate related to computable functions, but which cannot be used to obtain Kleene's normal form theorem.<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
