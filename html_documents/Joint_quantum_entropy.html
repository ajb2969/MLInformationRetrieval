<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1257">Joint quantum entropy</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Joint quantum entropy</h1>
<hr/>

<p>The <strong>joint quantum entropy</strong> generalizes the classical <a href="joint_entropy" title="wikilink">joint entropy</a> to the context of <a href="quantum_information_theory" title="wikilink">quantum information theory</a>. Intuitively, given two <a href="quantum_state" title="wikilink">quantum states</a> 

<math display="inline" id="Joint_quantum_entropy:0">
 <semantics>
  <mi>ρ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ρ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Joint_quantum_entropy:1">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

, represented as <a href="density_operator" title="wikilink">density operators</a> that are subparts of a quantum system, the joint quantum entropy is a measure of the total uncertainty or <a class="uri" href="entropy" title="wikilink">entropy</a> of the joint system. It is written 

<math display="inline" id="Joint_quantum_entropy:2">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ρ</mi>
    <mo>,</mo>
    <mi>σ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <interval closure="open">
     <ci>ρ</ci>
     <ci>σ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\rho,\sigma)
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Joint_quantum_entropy:3">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ρ</mi>
    <mo>,</mo>
    <mi>σ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <interval closure="open">
     <ci>ρ</ci>
     <ci>σ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(\rho,\sigma)
  </annotation>
 </semantics>
</math>


, depending on the notation being used for the <a href="von_Neumann_entropy" title="wikilink">von Neumann entropy</a>. Like other entropies, the joint quantum entropy is measured in <a href="bit" title="wikilink">bits</a>, i.e. the logarithm is taken in base 2.</p>

<p>In this article, we will use 

<math display="inline" id="Joint_quantum_entropy:4">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ρ</mi>
    <mo>,</mo>
    <mi>σ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <interval closure="open">
     <ci>ρ</ci>
     <ci>σ</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\rho,\sigma)
  </annotation>
 </semantics>
</math>

 for the joint quantum entropy.</p>
<h2 id="background">Background</h2>

<p>In <a href="information_theory" title="wikilink">information theory</a>, for any classical <a href="random_variable" title="wikilink">random variable</a> 

<math display="inline" id="Joint_quantum_entropy:5">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

, the classical <a href="Shannon_entropy" title="wikilink">Shannon entropy</a> 

<math display="inline" id="Joint_quantum_entropy:6">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(X)
  </annotation>
 </semantics>
</math>

 is a measure of how uncertain we are about the outcome of 

<math display="inline" id="Joint_quantum_entropy:7">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

. For example, if 

<math display="inline" id="Joint_quantum_entropy:8">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>


 is a probability distribution concentrated at one point, the outcome of 

<math display="inline" id="Joint_quantum_entropy:9">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is certain and therefore its entropy 

<math display="inline" id="Joint_quantum_entropy:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>X</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(X)=0
  </annotation>
 </semantics>
</math>

. At the other extreme, if 

<math display="inline" id="Joint_quantum_entropy:11">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 is the uniform probability distribution with 

<math display="inline" id="Joint_quantum_entropy:12">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 possible values, intuitively one would expect 

<math display="inline" id="Joint_quantum_entropy:13">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>


 is associated with the most uncertainty. Indeed such uniform probability distributions have maximum possible entropy 

<math display="inline" id="Joint_quantum_entropy:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(X)=\log_{2}(n)
  </annotation>
 </semantics>
</math>

.</p>

<p>In <a href="quantum_information_theory" title="wikilink">quantum information theory</a>, the notion of entropy is extended from probability distributions to quantum states, or <a href="density_matrix" title="wikilink">density matrices</a>. For a state 

<math display="inline" id="Joint_quantum_entropy:15">
 <semantics>
  <mi>ρ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ρ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

, the <a href="von_Neumann_entropy" title="wikilink">von Neumann entropy</a> is defined by</p>

<p>

<math display="block" id="Joint_quantum_entropy:16">
 <semantics>
  <mrow>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mo>Tr</mo>
     <mrow>
      <mi>ρ</mi>
      <mrow>
       <mi>log</mi>
       <mi>ρ</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <ci>Tr</ci>
     <apply>
      <times></times>
      <ci>ρ</ci>
      <apply>
       <log></log>
       <ci>ρ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\operatorname{Tr}\rho\log\rho.
  </annotation>
 </semantics>
</math>

</p>

<p>Applying the <a href="spectral_theorem" title="wikilink">spectral theorem</a>, or <a href="Borel_functional_calculus" title="wikilink">Borel functional calculus</a> for infinite dimensional systems, we see that it generalizes the classical entropy. The physical meaning remains the same. A <a href="maximally_mixed_state" title="wikilink">maximally mixed state</a>, the quantum analog of the uniform probability distribution, has maximum von Neumann entropy. On the other hand, a <a href="pure_state" title="wikilink">pure state</a>, or a rank one projection, will have zero von Neumann entropy. We write the von Neumann entropy 

<math display="inline" id="Joint_quantum_entropy:17">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ρ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>ρ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\rho)
  </annotation>
 </semantics>
</math>

 (or sometimes 

<math display="inline" id="Joint_quantum_entropy:18">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ρ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>ρ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(\rho)
  </annotation>
 </semantics>
</math>


.</p>
<h2 id="definition">Definition</h2>

<p>Given a quantum system with two subsystems <em>A</em> and <em>B</em>, the term <strong>joint quantum entropy</strong> simply refers to the von Neumann entropy of the combined system. This is to distinguish from the entropy of the subsystems. In symbols, if the combined system is in state 

<math display="inline" id="Joint_quantum_entropy:19">
 <semantics>
  <msup>
   <mi>ρ</mi>
   <mrow>
    <mi>A</mi>
    <mi>B</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ρ</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho^{AB}
  </annotation>
 </semantics>
</math>

,</p>

<p>the joint quantum entropy is then</p>

<p>

<math display="block" id="Joint_quantum_entropy:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>ρ</mi>
       <mi>A</mi>
      </msup>
      <mo>,</mo>
      <msup>
       <mi>ρ</mi>
       <mi>B</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>ρ</mi>
       <mrow>
        <mi>A</mi>
        <mi>B</mi>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mo>Tr</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>ρ</mi>
         <mrow>
          <mi>A</mi>
          <mi>B</mi>
         </mrow>
        </msup>
        <mrow>
         <mi>log</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msup>
           <mi>ρ</mi>
           <mrow>
            <mi>A</mi>
            <mi>B</mi>
           </mrow>
          </msup>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>S</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ρ</ci>
        <ci>A</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ρ</ci>
        <ci>B</ci>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ρ</ci>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>B</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <ci>Tr</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ρ</ci>
         <apply>
          <times></times>
          <ci>A</ci>
          <ci>B</ci>
         </apply>
        </apply>
        <apply>
         <log></log>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>ρ</ci>
          <apply>
           <times></times>
           <ci>A</ci>
           <ci>B</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\rho^{A},\rho^{B})=S(\rho^{AB})=-\operatorname{Tr}(\rho^{AB}\log(\rho^{AB})).
  </annotation>
 </semantics>
</math>

</p>

<p>Each subsystem has it own entropy. The state of the subsystems are given by the <a href="partial_trace" title="wikilink">partial trace</a> operation.</p>
<h2 id="properties">Properties</h2>

<p>The classical joint entropy is always at least equal to the entropy of each individual system. This is not the case for the joint quantum entropy. If the quantum state 

<math display="inline" id="Joint_quantum_entropy:21">
 <semantics>
  <msup>
   <mi>ρ</mi>
   <mrow>
    <mi>A</mi>
    <mi>B</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ρ</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho^{AB}
  </annotation>
 </semantics>
</math>

 exhibits <a href="quantum_entanglement" title="wikilink">quantum entanglement</a>, then the entropy of each subsystem may be larger than the joint entropy. This is equivalent to the fact that the conditional quantum entropy may be negative, while the classical conditional entropy may never be.</p>

<p>Consider a <a href="maximally_entangled_state" title="wikilink">maximally entangled state</a> such as a <a href="Bell_state" title="wikilink">Bell state</a>. If 

<math display="inline" id="Joint_quantum_entropy:22">
 <semantics>
  <msup>
   <mi>ρ</mi>
   <mrow>
    <mi>A</mi>
    <mi>B</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ρ</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho^{AB}
  </annotation>
 </semantics>
</math>

 is a Bell state, say,</p>

<p>

<math display="block" id="Joint_quantum_entropy:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo fence="true">|</mo>
     <mi mathvariant="normal">Ψ</mi>
     <mo>⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <msqrt>
       <mn>2</mn>
      </msqrt>
     </mfrac>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>00</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>11</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>normal-Ψ</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">00</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">11</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left|\Psi\right\rangle=\frac{1}{\sqrt{2}}\left(|00\rangle+|11\rangle\right),
  </annotation>
 </semantics>
</math>

</p>

<p>then the total system is a pure state, with entropy 0, while each individual subsystem is a maximally mixed state, with maximum von Neumann entropy 

<math display="inline" id="Joint_quantum_entropy:24">
 <semantics>
  <mrow>
   <mrow>
    <mi>log</mi>
    <mn>2</mn>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <log></log>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log 2=1
  </annotation>
 </semantics>
</math>

. Thus the joint entropy of the combined system is less than that of subsystems. This is because for entangled states, definite states cannot be assigned to subsystems, resulting in positive entropy.</p>

<p>Notice that the above phenomenon cannot occur if a state is a separable pure state. In that case, the reduced states of the subsystems are also pure. Therefore all entropies are zero.</p>
<h2 id="relations-to-other-entropy-measures">Relations to other entropy measures</h2>

<p>The joint quantum entropy 

<math display="inline" id="Joint_quantum_entropy:25">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>ρ</mi>
     <mrow>
      <mi>A</mi>
      <mi>B</mi>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ρ</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\rho^{AB})
  </annotation>
 </semantics>
</math>

 can be used to define of the <a href="conditional_quantum_entropy" title="wikilink">conditional quantum entropy</a>:</p>

<p>

<math display="block" id="Joint_quantum_entropy:26">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>ρ</mi>
     <mi>A</mi>
    </msup>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>ρ</mi>
     <mi>B</mi>
    </msup>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mpadded width="+5pt">
    <mover>
     <mo movablelimits="false">=</mo>
     <mi>def</mi>
    </mover>
   </mpadded>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>ρ</mi>
     <mi>A</mi>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>ρ</mi>
     <mi>B</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>-</mo>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>ρ</mi>
     <mi>B</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ρ</ci>
      <ci>A</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ρ</ci>
      <ci>B</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <ci>def</ci>
    </apply>
    <csymbol cd="unknown">S</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ρ</ci>
      <ci>A</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ρ</ci>
      <ci>B</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <minus></minus>
    <csymbol cd="unknown">S</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ρ</ci>
      <ci>B</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\rho^{A}|\rho^{B})\ \stackrel{\mathrm{def}}{=}\ S(\rho^{A},\rho^{B})-S(\rho^%
{B})
  </annotation>
 </semantics>
</math>

</p>

<p>and the <a href="quantum_mutual_information" title="wikilink">quantum mutual information</a>:</p>

<p>

<math display="block" id="Joint_quantum_entropy:27">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>ρ</mi>
     <mi>A</mi>
    </msup>
    <mo>:</mo>
    <msup>
     <mi>ρ</mi>
     <mi>B</mi>
    </msup>
    <mo rspace="7.5pt" stretchy="false">)</mo>
   </mrow>
   <mpadded width="+5pt">
    <mover>
     <mo movablelimits="false">=</mo>
     <mi>def</mi>
    </mover>
   </mpadded>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>ρ</mi>
     <mi>A</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>ρ</mi>
     <mi>B</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>-</mo>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>ρ</mi>
     <mi>A</mi>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>ρ</mi>
     <mi>B</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">I</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ρ</ci>
      <ci>A</ci>
     </apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ρ</ci>
      <ci>B</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <eq></eq>
     <ci>def</ci>
    </apply>
    <csymbol cd="unknown">S</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ρ</ci>
      <ci>A</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <csymbol cd="unknown">S</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ρ</ci>
      <ci>B</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <minus></minus>
    <csymbol cd="unknown">S</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ρ</ci>
      <ci>A</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ρ</ci>
      <ci>B</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(\rho^{A}:\rho^{B})\ \stackrel{\mathrm{def}}{=}\ S(\rho^{A})+S(\rho^{B})-S(%
\rho^{A},\rho^{B})
  </annotation>
 </semantics>
</math>

</p>

<p>These definitions parallel the use of the classical <a href="joint_entropy" title="wikilink">joint entropy</a> to define the <a href="conditional_entropy" title="wikilink">conditional entropy</a> and <a href="mutual_information" title="wikilink">mutual information</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Quantum_relative_entropy" title="wikilink">Quantum relative entropy</a></li>
</ul>
<ul>
<li><a href="Quantum_mutual_information" title="wikilink">Quantum mutual information</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Nielsen, Michael A. and Isaac L. Chuang, <em>Quantum Computation and Quantum Information</em>. Cambridge University Press, 2000. ISBN 0-521-63235-8</li>
</ul>

<p>"</p>

<p><a href="Category:Quantum_mechanical_entropy" title="wikilink">Category:Quantum mechanical entropy</a> <a href="Category:Quantum_information_theory" title="wikilink">Category:Quantum information theory</a></p>
</body>
</html>
