<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1192">Polylogarithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Polylogarithm</h1>
<hr/>

<p>In mathematics, the <strong>polylogarithm</strong> (also known as <a href="#{{harvid" title="wikilink">Jonquière|1889}}|<strong>Jonquière's function</strong></a>, for <a href="Alfred_Jonquière" title="wikilink">Alfred Jonquière</a>) is a <a href="special_function" title="wikilink">special function</a> Li<sub><em>s</em></sub>(<em>z</em>) of order <em>s</em> and argument <em>z</em>. Only for special values of <em>s</em> does the polylogarithm reduce to an <a href="elementary_function" title="wikilink">elementary function</a> such as the <a href="natural_logarithm" title="wikilink">natural logarithm</a> or <a href="rational_function" title="wikilink">rational functions</a>. In <a href="quantum_statistics" title="wikilink">quantum statistics</a>, the polylogarithm function appears as the closed form of integrals of the <a href="Fermi–Dirac_distribution" title="wikilink">Fermi–Dirac distribution</a> and the <a href="Bose–Einstein_distribution" title="wikilink">Bose–Einstein distribution</a>, and is also known as the <strong>Fermi–Dirac integral</strong> or the <strong>Bose–Einstein integral</strong>. In <a href="quantum_electrodynamics" title="wikilink">quantum electrodynamics</a>, polylogarithms of positive integer order arise in the calculation of processes represented by higher-order <a href="Feynman_diagram" title="wikilink">Feynman diagrams</a>.</p>

<p>The polylogarithm function is equivalent to the <a href="Hurwitz_zeta_function" title="wikilink">Hurwitz zeta function</a> — either function can be expressed in terms of the other — and both functions are special cases of the <a href="Lerch_transcendent" title="wikilink">Lerch transcendent</a>. Polylogarithms should not be confused with <a href="polylogarithmic_function" title="wikilink">polylogarithmic functions</a> nor with the <a href="offset_logarithmic_integral" title="wikilink">offset logarithmic integral</a> which has a similar notation.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p><strong>Different polylogarithm functions in the complex plane</strong></p></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Complex polylogminus3.jpg</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Complex polylogminus2.jpg</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Complex polylogminus1.jpg</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Complex polylog0.jpg</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Complex polylog1.jpg</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Complex polylog2.jpg</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Complex polylog3.jpg</figcaption>
</figure></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>Li<sub>−3</sub>(<em>z</em>)</p></td>
<td style="text-align: left;">

<p>Li<sub>−2</sub>(<em>z</em>)</p></td>
<td style="text-align: left;">

<p>Li<sub>−1</sub>(<em>z</em>)</p></td>
<td style="text-align: left;">

<p>Li<sub>0</sub>(<em>z</em>)</p></td>
<td style="text-align: left;">

<p>Li<sub>1</sub>(<em>z</em>)</p></td>
<td style="text-align: left;">

<p>Li<sub>2</sub>(<em>z</em>)</p></td>
<td style="text-align: left;">

<p>Li<sub>3</sub>(<em>z</em>)</p></td>
</tr>
</tbody>
</table>

<p>The polylogarithm function is defined by the infinite sum, or <a href="power_series" title="wikilink">power series</a>:</p>

<p>
<math display="block" id="Polylogarithm:0">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>k</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mi mathvariant="normal">∞</mi>
</munderover>
<mfrac>
<msup>
<mi>z</mi>
<mi>k</mi>
</msup>
<msup>
<mi>k</mi>
<mi>s</mi>
</msup>
</mfrac>
</mrow>
<mo>=</mo>
<mrow>
<mi>z</mi>
<mo>+</mo>
<mfrac>
<msup>
<mi>z</mi>
<mn>2</mn>
</msup>
<msup>
<mn>2</mn>
<mi>s</mi>
</msup>
</mfrac>
<mo>+</mo>
<mfrac>
<msup>
<mi>z</mi>
<mn>3</mn>
</msup>
<msup>
<mn>3</mn>
<mi>s</mi>
</msup>
</mfrac>
<mo>+</mo>
<mpadded width="+1.7pt">
<mi mathvariant="normal">⋯</mi>
</mpadded>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<ci>z</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<infinity></infinity>
</apply>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>k</ci>
<ci>s</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<plus></plus>
<ci>z</ci>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<ci>s</ci>
</apply>
</apply>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<cn type="integer">3</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">3</cn>
<ci>s</ci>
</apply>
</apply>
<ci>normal-⋯</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{s}(z)=\sum_{k=1}^{\infty}{z^{k}\over k^{s}}=z+{z^{2}\over 2%
^{s}}+{z^{3}\over 3^{s}}+\cdots\,.
  </annotation>
</semantics>
</math>
</p>

<p>This definition is valid for arbitrary <a href="complex_numbers" title="wikilink">complex</a> order <em>s</em> and for all complex arguments <em>z</em> with |<em>z</em>| 1(<em>z</em>) = −ln(1−<em>z</em>), while the special cases <em>s</em> = 2 and <em>s</em> = 3 are called the <a class="uri" href="dilogarithm" title="wikilink">dilogarithm</a> (also referred to as Spence's function) and trilogarithm respectively. The name of the function comes from the fact that it may also be defined as the repeated <a href="indefinite_integral" title="wikilink">integral</a> of itself:</p>

<p>
<math display="block" id="Polylogarithm:1">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mrow>
<mi>s</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">∫</mo>
<mn>0</mn>
<mi>z</mi>
</msubsup>
<mrow>
<mpadded width="+1.7pt">
<mfrac>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mi>t</mi>
</mfrac>
</mpadded>
<mi mathvariant="normal">d</mi>
<mpadded width="+1.7pt">
<mi>t</mi>
</mpadded>
</mrow>
</mrow>
</mrow>
<mo>;</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<apply>
<plus></plus>
<ci>s</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>z</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<int></int>
<cn type="integer">0</cn>
</apply>
<ci>z</ci>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<ci>t</ci>
</apply>
<ci>t</ci>
</apply>
<ci>normal-d</ci>
<ci>t</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{s+1}(z)=\int_{0}^{z}\frac{\operatorname{Li}_{s}(t)}{t}\,%
\mathrm{d}t\,;
  </annotation>
</semantics>
</math>
</p>

<p>thus the dilogarithm is an integral of the logarithm, and so on. For nonpositive <a class="uri" href="integer" title="wikilink">integer</a> orders <em>s</em>, the polylogarithm is a <a href="rational_function" title="wikilink">rational function</a>.</p>
<h2 id="properties">Properties</h2>

<p><strong>Preliminary note</strong>: In the important case where the polylogarithm order <em>s</em> is an integer, it will be represented by <em>n</em> (or −<em>n</em> when negative). It is often convenient to define <em>μ</em> = ln(<em>z</em>) where ln(<em>z</em>) is the <a href="principal_branch" title="wikilink">principal branch</a> of the <a href="complex_logarithm" title="wikilink">complex logarithm</a> Ln(<em>z</em>) so that −<em>π</em> <em>s</em> = exp(<em>s</em> ln(<em>z</em>)).</p>

<p>Depending on the order <em>s</em>, the polylogarithm may be multi-valued. The <strong>principal branch</strong> of Li<sub><em>s</em></sub>(<em>z</em>) is taken to be given for |<em>z</em>| \textrm{Im}\left( \operatorname{Li}_s(z) \right) = -{{\pi \mu^{s-1}}\over{\Gamma(s)}} \,.</p>

<p>Going across the cut, if <em>ε</em> is an infinitesimally small positive real number, then:</p>

<p>
<math display="block" id="Polylogarithm:2">
<semantics>
<mrow>
<mrow>
<mrow>
<mtext>Im</mtext>
<mrow>
<mo>(</mo>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>z</mi>
<mo>+</mo>
<mrow>
<mi>i</mi>
<mi>ϵ</mi>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mpadded width="+1.7pt">
<mfrac>
<mrow>
<mi>π</mi>
<msup>
<mi>μ</mi>
<mrow>
<mi>s</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
<mrow>
<mi mathvariant="normal">Γ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>s</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
</mpadded>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<mtext>Im</mtext>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<apply>
<plus></plus>
<ci>z</ci>
<apply>
<times></times>
<ci>i</ci>
<ci>ϵ</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>π</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>μ</ci>
<apply>
<minus></minus>
<ci>s</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<apply>
<times></times>
<ci>normal-Γ</ci>
<ci>s</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \textrm{Im}\left(\operatorname{Li}_{s}(z+i\epsilon)\right)={{\pi\mu^{s-1}}%
\over{\Gamma(s)}}\,.
  </annotation>
</semantics>
</math>
</p>

<p>Both can be concluded from the series expansion (<a href="#Series_representations" title="wikilink">see below</a>) of Li<sub><em>s</em></sub>(<em>e</em><sup><em>µ</em></sup>) about <em>µ</em> = 0.</p>

<p>The <strong>derivatives</strong> of the polylogarithm follow from the defining power series:</p>

<p>
<math display="block" id="Polylogarithm:3">
<semantics>
<mrow>
<mrow>
<mpadded width="+1.7pt">
<mi>z</mi>
</mpadded>
<mfrac>
<mrow>
<mo>∂</mo>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mrow>
<mo>∂</mo>
<mi>z</mi>
</mrow>
</mfrac>
</mrow>
<mo>=</mo>
<mrow>
<msub>
<mo>Li</mo>
<mrow>
<mi>s</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>z</ci>
<apply>
<divide></divide>
<apply>
<partialdiff></partialdiff>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<ci>z</ci>
</apply>
</apply>
<apply>
<partialdiff></partialdiff>
<ci>z</ci>
</apply>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<apply>
<minus></minus>
<ci>s</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>z</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   z\,{\partial\operatorname{Li}_{s}(z)\over\partial z}=\operatorname{Li}_{s-1}(z)
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Polylogarithm:4">
<semantics>
<mrow>
<mrow>
<mfrac>
<mrow>
<mo>∂</mo>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>e</mi>
<mi>μ</mi>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mrow>
<mo>∂</mo>
<mi>μ</mi>
</mrow>
</mfrac>
<mo>=</mo>
<mrow>
<msub>
<mo>Li</mo>
<mrow>
<mi>s</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>e</mi>
<mi>μ</mi>
</msup>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<divide></divide>
<apply>
<partialdiff></partialdiff>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<ci>μ</ci>
</apply>
</apply>
</apply>
<apply>
<partialdiff></partialdiff>
<ci>μ</ci>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<apply>
<minus></minus>
<ci>s</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<ci>μ</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   {\partial\operatorname{Li}_{s}(e^{\mu})\over\partial\mu}=\operatorname{Li}_{s-%
1}(e^{\mu})\,.
  </annotation>
</semantics>
</math>
</p>

<p>The <strong>square relationship</strong> is easily seen from the <a href="duplication_formula" title="wikilink">duplication formula</a> (see also , ):</p>

<p>
<math display="block" id="Polylogarithm:5">
<semantics>
<mrow>
<mrow>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mi>z</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mpadded width="+1.7pt">
<msup>
<mn>2</mn>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>s</mi>
</mrow>
</msup>
</mpadded>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>z</mi>
<mn>2</mn>
</msup>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<plus></plus>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<apply>
<minus></minus>
<ci>z</ci>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<ci>z</ci>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>s</ci>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{s}(-z)+\operatorname{Li}_{s}(z)=2^{1-s}\,\operatorname{Li}_%
{s}(z^{2})\,.
  </annotation>
</semantics>
</math>
</p>

<p>Note that <a href="Kummer's_function" title="wikilink">Kummer's function</a> obeys a very similar duplication formula. This is a special case of the <a href="multiplication_formula" title="wikilink">multiplication formula</a>, for any positive integer <em>p</em>:</p>

<p>
<math display="block" id="Polylogarithm:6">
<semantics>
<mrow>
<mrow>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>m</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mrow>
<mi>p</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</munderover>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mpadded width="+1.7pt">
<mi>z</mi>
</mpadded>
<msup>
<mi>e</mi>
<mrow>
<mrow>
<mn>2</mn>
<mi>π</mi>
<mi>i</mi>
<mi>m</mi>
</mrow>
<mo>/</mo>
<mi>p</mi>
</mrow>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mpadded width="+1.7pt">
<msup>
<mi>p</mi>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>s</mi>
</mrow>
</msup>
</mpadded>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>z</mi>
<mi>p</mi>
</msup>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>m</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<apply>
<minus></minus>
<ci>p</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<apply>
<times></times>
<ci>z</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<apply>
<divide></divide>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>π</ci>
<ci>i</ci>
<ci>m</ci>
</apply>
<ci>p</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>p</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>s</ci>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<ci>p</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \sum_{m=0}^{p-1}\operatorname{Li}_{s}(z\,e^{2\pi im/p})=p^{1-s}\,\operatorname%
{Li}_{s}(z^{p})\,,
  </annotation>
</semantics>
</math>
</p>

<p>which can be proved using the series definition of the polylogarithm and the orthogonality of the exponential terms (see e.g. <a href="discrete_Fourier_transform" title="wikilink">discrete Fourier transform</a>).</p>

<p>Another important property, the <strong>inversion formula</strong>, involves the <a href="Hurwitz_zeta_function" title="wikilink">Hurwitz zeta function</a> or the <a href="Bernoulli_polynomials" title="wikilink">Bernoulli polynomials</a> and is found under <a href="#Relationship_to_other_functions" title="wikilink">relationship to other functions</a> below.</p>
<h2 id="particular-values">Particular values</h2>
<figure><b>(Figure)</b>
<figcaption>Polylogarithm plot negative.svg</figcaption>
</figure>

<p>For particular cases, the polylogarithm may be expressed in terms of other functions (<a href="#Relationship_to_other_functions" title="wikilink">see below</a>). Particular values for the polylogarithm may thus also be found as particular values of these other functions.</p>

<p><strong>1.</strong> For integer values of the polylogarithm order, the following explicit expressions are obtained by repeated application of <em>z</em>·∂/∂<em>z</em> to Li<sub>1</sub>(<em>z</em>):</p>

<p>
<math display="block" id="Polylogarithm:7">
<semantics>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mn>1</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mrow>
<mi>ln</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>z</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">1</cn>
</apply>
<ci>z</ci>
</apply>
<apply>
<minus></minus>
<apply>
<ln></ln>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>z</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{1}(z)=-\ln(1-z)
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Polylogarithm:8">
<semantics>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mn>0</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mfrac>
<mi>z</mi>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>z</mi>
</mrow>
</mfrac>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">0</cn>
</apply>
<ci>z</ci>
</apply>
<apply>
<divide></divide>
<ci>z</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>z</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{0}(z)={z\over 1-z}
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Polylogarithm:9">
<semantics>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mfrac>
<mi>z</mi>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>z</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mn>2</mn>
</msup>
</mfrac>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>z</ci>
</apply>
<apply>
<divide></divide>
<ci>z</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>z</ci>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{-1}(z)={z\over(1-z)^{2}}
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Polylogarithm:10">
<semantics>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mrow>
<mo>-</mo>
<mn>2</mn>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mfrac>
<mrow>
<mpadded width="+1.7pt">
<mi>z</mi>
</mpadded>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>+</mo>
<mi>z</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>z</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mn>3</mn>
</msup>
</mfrac>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<apply>
<minus></minus>
<cn type="integer">2</cn>
</apply>
</apply>
<ci>z</ci>
</apply>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>z</ci>
<apply>
<plus></plus>
<cn type="integer">1</cn>
<ci>z</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>z</ci>
</apply>
<cn type="integer">3</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{-2}(z)={z\,(1+z)\over(1-z)^{3}}
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Polylogarithm:11">
<semantics>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mrow>
<mo>-</mo>
<mn>3</mn>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mfrac>
<mrow>
<mpadded width="+1.7pt">
<mi>z</mi>
</mpadded>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>+</mo>
<mrow>
<mn>4</mn>
<mi>z</mi>
</mrow>
<mo>+</mo>
<msup>
<mi>z</mi>
<mn>2</mn>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>z</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mn>4</mn>
</msup>
</mfrac>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<apply>
<minus></minus>
<cn type="integer">3</cn>
</apply>
</apply>
<ci>z</ci>
</apply>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>z</ci>
<apply>
<plus></plus>
<cn type="integer">1</cn>
<apply>
<times></times>
<cn type="integer">4</cn>
<ci>z</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>z</ci>
</apply>
<cn type="integer">4</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{-3}(z)={z\,(1+4z+z^{2})\over(1-z)^{4}}
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Polylogarithm:12">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mrow>
<mo>-</mo>
<mn>4</mn>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mpadded width="+1.7pt">
<mfrac>
<mrow>
<mpadded width="+1.7pt">
<mi>z</mi>
</mpadded>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>+</mo>
<mi>z</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>+</mo>
<mrow>
<mn>10</mn>
<mi>z</mi>
</mrow>
<mo>+</mo>
<msup>
<mi>z</mi>
<mn>2</mn>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>z</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mn>5</mn>
</msup>
</mfrac>
</mpadded>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<apply>
<minus></minus>
<cn type="integer">4</cn>
</apply>
</apply>
<ci>z</ci>
</apply>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>z</ci>
<apply>
<plus></plus>
<cn type="integer">1</cn>
<ci>z</ci>
</apply>
<apply>
<plus></plus>
<cn type="integer">1</cn>
<apply>
<times></times>
<cn type="integer">10</cn>
<ci>z</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>z</ci>
</apply>
<cn type="integer">5</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{-4}(z)={z\,(1+z)(1+10z+z^{2})\over(1-z)^{5}}\,.
  </annotation>
</semantics>
</math>
</p>

<p>Accordingly the polylogarithm reduces to a ratio of polynomials in <em>z</em>, and is therefore a <a href="rational_function" title="wikilink">rational function</a> of <em>z</em>, for all nonpositive integer orders. The general case may be expressed as a finite sum:</p>

<p>
<math display="block" id="Polylogarithm:13">
<semantics>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mrow>
<mo>-</mo>
<mi>n</mi>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msup>
<mrow>
<mo>(</mo>
<mrow>
<mpadded width="+1.7pt">
<mi>z</mi>
</mpadded>
<mfrac>
<mo>∂</mo>
<mrow>
<mo>∂</mo>
<mi>z</mi>
</mrow>
</mfrac>
</mrow>
<mo>)</mo>
</mrow>
<mi>n</mi>
</msup>
<mfrac>
<mi>z</mi>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>z</mi>
</mrow>
</mfrac>
</mrow>
<mo>=</mo>
<mi></mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<apply>
<minus></minus>
<ci>n</ci>
</apply>
</apply>
<ci>z</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<ci>z</ci>
<apply>
<divide></divide>
<partialdiff></partialdiff>
<apply>
<partialdiff></partialdiff>
<ci>z</ci>
</apply>
</apply>
</apply>
<ci>n</ci>
</apply>
<apply>
<divide></divide>
<ci>z</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>z</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<csymbol cd="latexml">absent</csymbol>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{-n}(z)=\left(z\,{\partial\over\partial z}\right)^{n}{z\over%
{1-z}}=
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Polylogarithm:14">
<semantics>
<mrow>
<mo>=</mo>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>k</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mi>n</mi>
</munderover>
<mi>k</mi>
<mo lspace="0pt" rspace="3.5pt">!</mo>
<mi>S</mi>
<mrow>
<mo stretchy="false">(</mo>
<mpadded width="-1.7pt">
<mi>n</mi>
</mpadded>
<mo rspace="0.8pt">+</mo>
<mn>1</mn>
<mo rspace="4.2pt">,</mo>
<mpadded width="-1.7pt">
<mi>k</mi>
</mpadded>
<mo rspace="0.8pt">+</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mrow>
<msup>
<mrow>
<mo>(</mo>
<mfrac>
<mi>z</mi>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>z</mi>
</mrow>
</mfrac>
<mo>)</mo>
</mrow>
<mrow>
<mi>k</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>=</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo>,</mo>
<mn>2</mn>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>k</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<ci>n</ci>
</apply>
<csymbol cd="unknown">k</csymbol>
<factorial></factorial>
<csymbol cd="unknown">S</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">n</csymbol>
<plus></plus>
<cn type="integer">1</cn>
<ci>normal-,</ci>
<csymbol cd="unknown">k</csymbol>
<plus></plus>
<cn type="integer">1</cn>
<ci>normal-)</ci>
</cerror>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<divide></divide>
<ci>z</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>z</ci>
</apply>
</apply>
<ci>normal-)</ci>
</cerror>
<apply>
<plus></plus>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>italic-</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">n</csymbol>
<eq></eq>
<cn type="integer">0</cn>
<ci>normal-,</ci>
<cn type="integer">1</cn>
<ci>normal-,</ci>
<cn type="integer">2</cn>
<ci>normal-,</ci>
<ci>normal-…</ci>
<ci>normal-)</ci>
</cerror>
<ci>normal-,</ci>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   =\sum_{k=0}^{n}k!\,S(n\!+\!1,\,k\!+\!1)\left({z\over{1-z}}\right)^{k+1}\qquad(%
n=0,1,2,\ldots)\,,
  </annotation>
</semantics>
</math>
</p>

<p>where <em>S</em>(<em>n</em>,<em>k</em>) are the <a href="Stirling_numbers_of_the_second_kind" title="wikilink">Stirling numbers of the second kind</a>. Equivalent formulae applicable to negative integer orders are :</p>

<p>
<math display="block" id="Polylogarithm:15">
<semantics>
<mrow>
<msub>
<mo>Li</mo>
<mrow>
<mo>-</mo>
<mi>n</mi>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>=</mo>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mo>-</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msup>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>k</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mi>n</mi>
</munderover>
<mi>k</mi>
<mo lspace="0pt" rspace="3.5pt">!</mo>
<mi>S</mi>
<mrow>
<mo stretchy="false">(</mo>
<mpadded width="-1.7pt">
<mi>n</mi>
</mpadded>
<mo rspace="0.8pt">+</mo>
<mn>1</mn>
<mo rspace="4.2pt">,</mo>
<mpadded width="-1.7pt">
<mi>k</mi>
</mpadded>
<mo rspace="0.8pt">+</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mrow>
<msup>
<mrow>
<mo>(</mo>
<mfrac>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>z</mi>
</mrow>
</mfrac>
<mo>)</mo>
</mrow>
<mrow>
<mi>k</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>=</mo>
<mn>1</mn>
<mo>,</mo>
<mn>2</mn>
<mo>,</mo>
<mn>3</mn>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<apply>
<minus></minus>
<ci>n</ci>
</apply>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">z</csymbol>
<ci>normal-)</ci>
</cerror>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<minus></minus>
<cn type="integer">1</cn>
<ci>normal-)</ci>
</cerror>
<apply>
<plus></plus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>k</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<ci>n</ci>
</apply>
<csymbol cd="unknown">k</csymbol>
<factorial></factorial>
<csymbol cd="unknown">S</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">n</csymbol>
<plus></plus>
<cn type="integer">1</cn>
<ci>normal-,</ci>
<csymbol cd="unknown">k</csymbol>
<plus></plus>
<cn type="integer">1</cn>
<ci>normal-)</ci>
</cerror>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<divide></divide>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>z</ci>
</apply>
</apply>
<ci>normal-)</ci>
</cerror>
<apply>
<plus></plus>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>italic-</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">n</csymbol>
<eq></eq>
<cn type="integer">1</cn>
<ci>normal-,</ci>
<cn type="integer">2</cn>
<ci>normal-,</ci>
<cn type="integer">3</cn>
<ci>normal-,</ci>
<ci>normal-…</ci>
<ci>normal-)</ci>
</cerror>
<ci>normal-,</ci>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{-n}(z)=(-1)^{n+1}\sum_{k=0}^{n}k!\,S(n\!+\!1,\,k\!+\!1)%
\left({{-1}\over{1-z}}\right)^{k+1}\qquad(n=1,2,3,\ldots)\,,
  </annotation>
</semantics>
</math>
</p>

<p>and:</p>

<p>
<math display="block" id="Polylogarithm:16">
<semantics>
<mrow>
<msub>
<mo>Li</mo>
<mrow>
<mo>-</mo>
<mi>n</mi>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>=</mo>
<mfrac>
<mn>1</mn>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>z</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msup>
</mfrac>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>k</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</munderover>
<mrow>
<mo>⟨</mo>
<mtable columnspacing="0.4em" rowspacing="0.2ex">
<mtr>
<mtd>
<mi>n</mi>
</mtd>
</mtr>
<mtr>
<mtd>
<mi>k</mi>
</mtd>
</mtr>
</mtable>
<mo>⟩</mo>
</mrow>
<msup>
<mi>z</mi>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>=</mo>
<mn>1</mn>
<mo>,</mo>
<mn>2</mn>
<mo>,</mo>
<mn>3</mn>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<apply>
<minus></minus>
<ci>n</ci>
</apply>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">z</csymbol>
<ci>normal-)</ci>
</cerror>
<eq></eq>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>z</ci>
</apply>
<apply>
<plus></plus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>k</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<apply>
<minus></minus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-⟨</ci>
<apply>
<ci>STACKED</ci>
<ci>n</ci>
<ci>k</ci>
</apply>
<ci>normal-⟩</ci>
</cerror>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<apply>
<minus></minus>
<ci>n</ci>
<ci>k</ci>
</apply>
</apply>
<ci>italic-</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">n</csymbol>
<eq></eq>
<cn type="integer">1</cn>
<ci>normal-,</ci>
<cn type="integer">2</cn>
<ci>normal-,</ci>
<cn type="integer">3</cn>
<ci>normal-,</ci>
<ci>normal-…</ci>
<ci>normal-)</ci>
</cerror>
<ci>normal-,</ci>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{-n}(z)={1\over(1-z)^{n+1}}\sum_{k=0}^{n-1}\left\langle{n%
\atop k}\right\rangle z^{n-k}\qquad(n=1,2,3,\ldots)\,,
  </annotation>
</semantics>
</math>
</p>

<p>where 

<math display="inline" id="Polylogarithm:17">
<semantics>
<mrow>
<mo>⟨</mo>
<mstyle scriptlevel="+1">
<mstyle scriptlevel="+1">
<mtable columnspacing="0.4em" rowspacing="0.2ex">
<mtr>
<mtd>
<mi>n</mi>
</mtd>
</mtr>
<mtr>
<mtd>
<mi>k</mi>
</mtd>
</mtr>
</mtable>
</mstyle>
</mstyle>
<mo>⟩</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">delimited-⟨⟩</csymbol>
<apply>
<ci>STACKED</ci>
<ci>n</ci>
<ci>k</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \scriptstyle\left\langle{n\atop k}\right\rangle
  </annotation>
</semantics>
</math>

 are the <a href="Eulerian_numbers" title="wikilink">Eulerian numbers</a>. All roots of Li<sub>−<em>n</em></sub>(<em>z</em>) are distinct and real; they include <em>z</em> = 0, while the remainder is negative and centered about <em>z</em> = −1 on a logarithmic scale. As <em>n</em> becomes large, the numerical evaluation of these rational expressions increasingly suffers from cancellation ; full accuracy can be obtained, however, by computing Li<sub>−<em>n</em></sub>(<em>z</em>) via the general relation with the Hurwitz zeta function (<a href="#Relationship_to_other_functions" title="wikilink">see below</a>).</p>

<p><strong>2.</strong> Some particular expressions for half-integer values of the argument <em>z</em> are:</p>

<p>
<math display="block" id="Polylogarithm:18">
<semantics>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mn>1</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mstyle>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi>ln</mi>
<mn>2</mn>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<ln></ln>
<cn type="integer">2</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{1}(\tfrac{1}{2})=\ln 2
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Polylogarithm:19">
<semantics>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mstyle>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>12</mn>
</mfrac>
</mstyle>
<msup>
<mi>π</mi>
<mn>2</mn>
</msup>
</mrow>
<mo>-</mo>
<mrow>
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mstyle>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>ln</mi>
<mn>2</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mn>2</mn>
</msup>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">12</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>π</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<ln></ln>
<cn type="integer">2</cn>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{2}(\tfrac{1}{2})=\tfrac{1}{12}\pi^{2}-\tfrac{1}{2}(\ln 2)^{2}
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Polylogarithm:20">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mn>3</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mstyle>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mrow>
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>6</mn>
</mfrac>
</mstyle>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>ln</mi>
<mn>2</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mn>3</mn>
</msup>
</mrow>
<mo>-</mo>
<mrow>
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>12</mn>
</mfrac>
</mstyle>
<msup>
<mi>π</mi>
<mn>2</mn>
</msup>
<mrow>
<mi>ln</mi>
<mn>2</mn>
</mrow>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<mpadded width="+1.7pt">
<mstyle displaystyle="false">
<mfrac>
<mn>7</mn>
<mn>8</mn>
</mfrac>
</mstyle>
</mpadded>
<mi>ζ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mn>3</mn>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">3</cn>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<plus></plus>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">6</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<ln></ln>
<cn type="integer">2</cn>
</apply>
<cn type="integer">3</cn>
</apply>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">12</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>π</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<ln></ln>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">7</cn>
<cn type="integer">8</cn>
</apply>
<ci>ζ</ci>
<cn type="integer">3</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{3}(\tfrac{1}{2})=\tfrac{1}{6}(\ln 2)^{3}-\tfrac{1}{12}\pi^{%
2}\ln 2+\tfrac{7}{8}\,\zeta(3)\,,
  </annotation>
</semantics>
</math>
</p>

<p>where <em>ζ</em> is the <a href="Riemann_zeta_function" title="wikilink">Riemann zeta function</a>. No formulae of this type are known for higher integer orders , but one has for instance :</p>

<p>
<math display="block" id="Polylogarithm:21">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mn>4</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mstyle>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mrow>
<mrow>
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>360</mn>
</mfrac>
</mstyle>
<msup>
<mi>π</mi>
<mn>4</mn>
</msup>
</mrow>
<mo>-</mo>
<mrow>
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>24</mn>
</mfrac>
</mstyle>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>ln</mi>
<mn>2</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mn>4</mn>
</msup>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>24</mn>
</mfrac>
</mstyle>
<msup>
<mi>π</mi>
<mn>2</mn>
</msup>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>ln</mi>
<mn>2</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mn>2</mn>
</msup>
</mrow>
</mrow>
<mo>-</mo>
<mrow>
<mpadded width="+1.7pt">
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mstyle>
</mpadded>
<mi>ζ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mover accent="true">
<mn>3</mn>
<mo stretchy="false">¯</mo>
</mover>
<mo>,</mo>
<mover accent="true">
<mn>1</mn>
<mo stretchy="false">¯</mo>
</mover>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">4</cn>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<minus></minus>
<apply>
<plus></plus>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">360</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>π</ci>
<cn type="integer">4</cn>
</apply>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">24</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<ln></ln>
<cn type="integer">2</cn>
</apply>
<cn type="integer">4</cn>
</apply>
</apply>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">24</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>π</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<ln></ln>
<cn type="integer">2</cn>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
<ci>ζ</ci>
<interval closure="open">
<apply>
<ci>normal-¯</ci>
<cn type="integer">3</cn>
</apply>
<apply>
<ci>normal-¯</ci>
<cn type="integer">1</cn>
</apply>
</interval>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{4}(\tfrac{1}{2})=\tfrac{1}{360}\pi^{4}-\tfrac{1}{24}(\ln 2)%
^{4}+\tfrac{1}{24}\pi^{2}(\ln 2)^{2}-\tfrac{1}{2}\,\zeta(\bar{3},\bar{1})\,,
  </annotation>
</semantics>
</math>
</p>

<p>which involves the alternating double sum 

<math display="inline" id="Polylogarithm:22">
<semantics>
<mrow>
<mrow>
<mi>ζ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mover accent="true">
<mn>3</mn>
<mo stretchy="false">¯</mo>
</mover>
<mo>,</mo>
<mover accent="true">
<mn>1</mn>
<mo stretchy="false">¯</mo>
</mover>
<mo rspace="5.8pt" stretchy="false">)</mo>
</mrow>
</mrow>
<mo rspace="4.2pt">=</mo>
<mrow>
<mpadded width="+1.7pt">
<msub>
<mo largeop="true" symmetric="true">∑</mo>
<mrow>
<mi>m</mi>
<mo>&gt;</mo>
<mi>n</mi>
<mo>&gt;</mo>
<mn>0</mn>
</mrow>
</msub>
</mpadded>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>m</mi>
<mo>+</mo>
<mi>n</mi>
</mrow>
</msup>
<msup>
<mi>m</mi>
<mrow>
<mo>-</mo>
<mn>3</mn>
</mrow>
</msup>
<msup>
<mi>n</mi>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>ζ</ci>
<interval closure="open">
<apply>
<ci>normal-¯</ci>
<cn type="integer">3</cn>
</apply>
<apply>
<ci>normal-¯</ci>
<cn type="integer">1</cn>
</apply>
</interval>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<and></and>
<apply>
<gt></gt>
<ci>m</ci>
<ci>n</ci>
</apply>
<apply>
<gt></gt>
<share href="#.cmml">
</share>
<cn type="integer">0</cn>
</apply>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
<apply>
<plus></plus>
<ci>m</ci>
<ci>n</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>m</ci>
<apply>
<minus></minus>
<cn type="integer">3</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>n</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \scriptstyle\zeta(\bar{3},\bar{1})~{}=\,\sum_{m&gt;n&gt;0}\,(-1)^{m+n}m^{-3}n^{-1}
  </annotation>
</semantics>
</math>

. In general one has for integer orders <em>n</em> ≥ 2 :</p>

<p>
<math display="block" id="Polylogarithm:23">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mi>n</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mstyle>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mrow>
<mi>ζ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mover accent="true">
<mn>1</mn>
<mo stretchy="false">¯</mo>
</mover>
<mo>,</mo>
<mover accent="true">
<mn>1</mn>
<mo stretchy="false">¯</mo>
</mover>
<mo>,</mo>
<msup>
<mrow>
<mo>{</mo>
<mn>1</mn>
<mo>}</mo>
</mrow>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mn>2</mn>
</mrow>
</msup>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>n</ci>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<ci>ζ</ci>
<vector>
<apply>
<ci>normal-¯</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<ci>normal-¯</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<set>
<cn type="integer">1</cn>
</set>
<apply>
<minus></minus>
<ci>n</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</vector>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{n}(\tfrac{1}{2})=-\zeta(\bar{1},\bar{1},\left\{1\right\}^{n%
-2})\,,
  </annotation>
</semantics>
</math>
</p>

<p>where <em>ζ</em>(<em>s</em><sub>1</sub>, ..., <em>s</em><sub><em>k</em></sub>) is the <a href="multiple_zeta_function" title="wikilink">multiple zeta function</a>; for example:</p>

<p>
<math display="block" id="Polylogarithm:24">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mn>5</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mstyle>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mrow>
<mi>ζ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mover accent="true">
<mn>1</mn>
<mo stretchy="false">¯</mo>
</mover>
<mo>,</mo>
<mover accent="true">
<mn>1</mn>
<mo stretchy="false">¯</mo>
</mover>
<mo>,</mo>
<mn>1</mn>
<mo>,</mo>
<mn>1</mn>
<mo>,</mo>
<mn>1</mn>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">5</cn>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<ci>ζ</ci>
<vector>
<apply>
<ci>normal-¯</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<ci>normal-¯</ci>
<cn type="integer">1</cn>
</apply>
<cn type="integer">1</cn>
<cn type="integer">1</cn>
<cn type="integer">1</cn>
</vector>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{5}(\tfrac{1}{2})=-\zeta(\bar{1},\bar{1},1,1,1)\,.
  </annotation>
</semantics>
</math>
</p>

<p><strong>3.</strong> As a straightforward consequence of the series definition, values of the polylogarithm at the <em>p</em>th complex <a href="roots_of_unity" title="wikilink">roots of unity</a> are given by the <a href="discrete_Fourier_transform" title="wikilink">Fourier sum</a>:</p>

<p>
<math display="block" id="Polylogarithm:25">
<semantics>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>e</mi>
<mrow>
<mrow>
<mn>2</mn>
<mi>π</mi>
<mi>i</mi>
<mi>m</mi>
</mrow>
<mo>/</mo>
<mi>p</mi>
</mrow>
</msup>
<mo stretchy="false">)</mo>
</mrow>
<mo>=</mo>
<msup>
<mi>p</mi>
<mrow>
<mo>-</mo>
<mi>s</mi>
</mrow>
</msup>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>k</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mi>p</mi>
</munderover>
<mpadded width="+1.7pt">
<msup>
<mi>e</mi>
<mrow>
<mrow>
<mn>2</mn>
<mi>π</mi>
<mi>i</mi>
<mi>m</mi>
<mi>k</mi>
</mrow>
<mo>/</mo>
<mi>p</mi>
</mrow>
</msup>
</mpadded>
<mi>ζ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>s</mi>
<mo>,</mo>
<mstyle displaystyle="false">
<mfrac>
<mi>k</mi>
<mi>p</mi>
</mfrac>
</mstyle>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>m</mi>
<mo>=</mo>
<mn>1</mn>
<mo>,</mo>
<mn>2</mn>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<mi>p</mi>
<mo>-</mo>
<mn>1</mn>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<apply>
<divide></divide>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>π</ci>
<ci>i</ci>
<ci>m</ci>
</apply>
<ci>p</ci>
</apply>
</apply>
<ci>normal-)</ci>
</cerror>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>p</ci>
<apply>
<minus></minus>
<ci>s</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>p</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<apply>
<divide></divide>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>π</ci>
<ci>i</ci>
<ci>m</ci>
<ci>k</ci>
</apply>
<ci>p</ci>
</apply>
</apply>
<csymbol cd="unknown">ζ</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">s</csymbol>
<ci>normal-,</ci>
<apply>
<divide></divide>
<ci>k</ci>
<ci>p</ci>
</apply>
<ci>normal-)</ci>
</cerror>
<ci>italic-</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">m</csymbol>
<eq></eq>
<cn type="integer">1</cn>
<ci>normal-,</ci>
<cn type="integer">2</cn>
<ci>normal-,</ci>
<ci>normal-…</ci>
<ci>normal-,</ci>
<csymbol cd="unknown">p</csymbol>
<minus></minus>
<cn type="integer">1</cn>
<ci>normal-)</ci>
</cerror>
<ci>normal-,</ci>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{s}(e^{2\pi im/p})=p^{-s}\sum_{k=1}^{p}e^{2\pi imk/p}\,\zeta%
(s,\tfrac{k}{p})\qquad(m=1,2,\dots,p-1)\,,
  </annotation>
</semantics>
</math>
</p>

<p>where <em>ζ</em> is the <a href="Hurwitz_zeta_function" title="wikilink">Hurwitz zeta function</a>. For Re(<em>s</em>) &gt; 1, where Li<sub><em>s</em></sub>(1) is finite, the relation also holds with <em>m</em> = 0 or <em>m</em> = <em>p</em>. While this formula is not as simple as that implied by the more general relation with the Hurwitz zeta function listed under <a href="#Relationship_to_other_functions" title="wikilink">relationship to other functions</a> below, it has the advantage of applying to non-negative integer values of <em>s</em> as well. As usual, the relation may be inverted to express ζ(<em>s</em>, <sup><em>m</em></sup>⁄<sub><em>p</em></sub>) for any <em>m</em> = 1, ..., <em>p</em> as a Fourier sum of Li<sub><em>s</em></sub>(exp(2<em>πi</em> <sup><em>k</em></sup>⁄<sub><em>p</em></sub>)) over <em>k</em> = 1, ..., <em>p</em>.</p>
<h2 id="relationship-to-other-functions">Relationship to other functions</h2>
<ul>
<li>For <em>z</em> = 1 the polylogarithm reduces to the <a href="Riemann_zeta_function" title="wikilink">Riemann zeta function</a></li>
</ul>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\operatorname{Li}_s(1) = \zeta(s) \qquad (\textrm{Re}(s)&gt;1) \,. </p>
<ul>
<li>The polylogarithm is related to <a href="Dirichlet_eta_function" title="wikilink">Dirichlet eta function</a> and the <a href="Dirichlet_beta_function" title="wikilink">Dirichlet beta function</a>:</li>
</ul>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\operatorname{Li}_s(-1) = -\eta(s) \,, </p>
<dl>
<dd>where <em>η</em>(<em>s</em>) is the Dirichlet eta function. For pure imaginary arguments, we have:
</dd>
</dl>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\operatorname{Li}_s(\pm i) = -2^{-s} \,\eta(s) \pm i \,\beta(s) \,, </p>
<dl>
<dd>where <em>β</em>(<em>s</em>) is the Dirichlet beta function.
</dd>
</dl>
<ul>
<li>The polylogarithm is related to the <a href="complete_Fermi–Dirac_integral" title="wikilink">complete Fermi–Dirac integral</a> as:</li>
</ul>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>F_s(\mu) = -\operatorname{Li}_{s+1}(-e^\mu) \,. </p>
<ul>
<li>The polylogarithm is a special case of the <a href="incomplete_polylogarithm" title="wikilink">incomplete polylogarithm</a> function</li>
</ul>
<dl>
<dd><dl>
<dd>
<math display="inline" id="Polylogarithm:26">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mn>0</mn>
<mo>,</mo>
<mi>z</mi>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<ci>z</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<cn type="integer">0</cn>
<ci>z</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{s}(z)=\operatorname{Li}_{s}(0,z)\,.
  </annotation>
</semantics>
</math>
</dd>
</dl>
</dd>
</dl>
<ul>
<li>The polylogarithm is a special case of the <a href="Lerch_transcendent" title="wikilink">Lerch transcendent</a> </li>
</ul>
<dl>
<dd><dl>
<dd>
<math display="inline" id="Polylogarithm:27">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mpadded width="+1.7pt">
<mi>z</mi>
</mpadded>
<mi mathvariant="normal">Φ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo>,</mo>
<mi>s</mi>
<mo>,</mo>
<mn>1</mn>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<ci>z</ci>
</apply>
<apply>
<times></times>
<ci>z</ci>
<ci>normal-Φ</ci>
<vector>
<ci>z</ci>
<ci>s</ci>
<cn type="integer">1</cn>
</vector>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{s}(z)=z\,\Phi(z,s,1)\,.
  </annotation>
</semantics>
</math>
</dd>
</dl>
</dd>
</dl>
<ul>
<li>The polylogarithm is related to the <a href="Hurwitz_zeta_function" title="wikilink">Hurwitz zeta function</a> by:</li>
</ul>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\operatorname{Li}_s(z) = {\Gamma(1 \!-\! s) \over (2\pi)^{1-s}} \left[i^{1-s} ~\zeta \!\left(1 \!-\! s, ~\frac{1}{2} + {\ln(-z) \over {2\pi i}} \right) + i^{s-1} ~\zeta \!\left(1 \!-\! s, ~\frac{1}{2} - {\ln(-z) \over {2\pi i}} \right) \right] , </p>
<dl>
<dd>which relation, however, is invalidated at positive integer <em>s</em> by <a href="pole_(complex_analysis)" title="wikilink">poles</a> of the <a href="gamma_function" title="wikilink">gamma function</a> Γ(1−<em>s</em>), and at <em>s</em> = 0 by a pole of both zeta functions; a derivation of this formula is given under <a href="#Series_representations" title="wikilink">series representations</a> below. With a little help from a functional equation for the Hurwitz zeta function, the polylogarithm is consequently also related to that function via :
</dd>
</dl>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>i^{-s} \,\operatorname{Li}_s(e^{2\pi i x}) + i^s \,\operatorname{Li}_s(e^{-2\pi i x}) = {(2\pi)^s \over \Gamma(s)} \,\zeta(1 \!-\! s, \,x) \,, </p>
<dl>
<dd>which relation holds for 0 ≤ Re(<em>x</em>) &lt; 1 if Im(<em>x</em>) ≥ 0, and for 0 &lt; Re(<em>x</em>) ≤ 1 if Im(<em>x</em>) &lt; 0. Equivalently, for all complex <em>s</em> and for complex <em>z</em> ∉ ]0;1], the <strong>inversion formula</strong> reads
</dd>
</dl>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\operatorname{Li}_s(z) + (-1)^s \,\operatorname{Li}_s(1/z) = {(2\pi i)^s \over \Gamma(s)} ~\zeta \!\left(1 \!-\! s, ~\frac{1}{2} + {\ln(-z) \over {2\pi i}} \right) , </p>
<dl>
<dd>and for all complex <em>s</em> and for complex <em>z</em> ∉ ]1;∞[
</dd>
</dl>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\operatorname{Li}_s(z) + (-1)^s \,\operatorname{Li}_s(1/z) = {(2\pi i)^s \over \Gamma(s)} ~\zeta \!\left(1 \!-\! s, ~\frac{1}{2} - {\ln(-1/z) \over {2\pi i}} \right) . </p>
<dl>
<dd>For <em>z</em> ∉ ]0;∞[ one has ln(−<em>z</em>) = −ln(−<sup>1</sup>⁄<sub><em>z</em></sub>), and both expressions agree. These relations furnish the analytic continuation of the polylogarithm beyond the circle of convergence |<em>z</em>| = 1 of the defining power series. (Note that the corresponding equation of  and  is not correct if one assumes that the principal branches of the polylogarithm and the logarithm are used simultaneously.) See the next item for a simplified formula when <em>s</em> is an integer.
</dd>
</dl>
<ul>
<li>For positive integer polylogarithm orders <em>s</em>, the Hurwitz zeta function ζ(1−<em>s</em>, <em>x</em>) reduces to <a href="Bernoulli_polynomials" title="wikilink">Bernoulli polynomials</a>, ζ(1−<em>n</em>, <em>x</em>) = −B<sub><em>n</em></sub>(<em>x</em>) / <em>n</em>, and Jonquière's inversion formula for <em>n</em> = 1, 2, 3, ... becomes:</li>
</ul>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\operatorname{Li}_{n}(e^{2\pi i x}) + (-1)^n \,\operatorname{Li}_{n}(e^{-2\pi i x}) = -{(2\pi i)^n \over n!} \,B_n(x) \,, </p>
<dl>
<dd>where again 0 ≤ Re(<em>x</em>) <em>n</em>(<em>e</em><sup>2<em>πix</em></sup>)) if <em>n</em> is even, and to 2<em>i</em> Im(Li<sub><em>n</em></sub>(<em>e</em><sup>2<em>πix</em></sup>)) if <em>n</em> is odd. For negative integer orders, on the other hand, the divergence of Γ(<em>s</em>) implies for all <em>z</em> that :
</dd>
</dl>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\operatorname{Li}_{-n}(z) + (-1)^n \,\operatorname{Li}_{-n}(1/z) = 0 \qquad (n = 1,2,3,\ldots) \,. </p>
<dl>
<dd>More generally one has for <em>n</em> = 0, ±1, ±2, ±3, ... :
</dd>
</dl>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\operatorname{Li}_{n}(z) + (-1)^n \,\operatorname{Li}_{n}(1/z) = -\frac{(2\pi i)^n}{n!} ~B_n \!\left( \frac{1}{2} + {\ln(-z) \over {2\pi i}} \right) \qquad (z ~\not\in ~]0;1]) \,, </p>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\operatorname{Li}_{n}(z) + (-1)^n \,\operatorname{Li}_{n}(1/z) = -\frac{(2\pi i)^n}{n!} ~B_n \!\left( \frac{1}{2} - {\ln(-1/z) \over {2\pi i}} \right) \qquad (z ~\not\in ~]1;\infty[) \,, </p>
<dl>
<dd>where both expressions agree for <em>z</em> ∉ ]0;∞[. (Note that the corresponding equation of  and  is again not correct.)
</dd>
</dl>
<ul>
<li>The polylogarithm with pure imaginary <em>μ</em> may be expressed in terms of the <a href="Clausen_function" title="wikilink">Clausen functions</a> <em>Ci</em><sub><em>s</em></sub>(θ) and <em>Si</em><sub><em>s</em></sub>(θ), and vice versa (; ):</li>
</ul>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\operatorname{Li}_s(e^{\pm i \theta}) = Ci_s(\theta) \pm i \,Si_s(\theta) \,. </p>
<ul>
<li>The <a href="inverse_tangent_integral" title="wikilink">inverse tangent integral</a> <em>Ti</em><sub><em>s</em></sub>(<em>z</em>)  can be expressed in terms of polylogarithms:</li>
</ul>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>Ti_s(z) = {1 \over 2i} \left[ \operatorname{Li}_s(i z) - \operatorname{Li}_s(-i z) \right] . </p>
<dl>
<dd>The relation in particular implies:
</dd>
</dl>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>Ti_0(z) = {z \over 1+z^2}, \quad Ti_1(z) = \arctan z, \quad Ti_2(z) = \int_0^z {\arctan t \over t} \,\mathrm{d}t, </p>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\quad \ldots~, \quad Ti_{n+1}(z) = \int_0^z {Ti_n(t) \over t} \,\mathrm{d}t \,, </p>
<dl>
<dd>which explains the function name.
</dd>
</dl>
<ul>
<li>The <a href="Legendre_chi_function" title="wikilink">Legendre chi function</a> <em>χ</em><sub><em>s</em></sub>(<em>z</em>) (; ) can be expressed in terms of polylogarithms:</li>
</ul>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\chi_s(z) = \tfrac {1}{2} \left[ \operatorname{Li}_s(z) - \operatorname{Li}_s(-z) \right] . </p>
<ul>
<li>The polylogarithm of integer order can be expressed as a <a href="generalized_hypergeometric_function" title="wikilink">generalized hypergeometric function</a>:</li>
</ul>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\operatorname{Li}_n(z) = z \;_{n+1}F_{n} (1,1,\dots,1; \,2,2,\dots,2; \,z) \qquad (n = 0,1,2,\ldots) ~, </p>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\operatorname{Li}_{-n}(z) = z \;_{n}F_{n-1} (2,2,\dots,2; \,1,1,\dots,1; \,z) \qquad (n = 1,2,3,\ldots) ~. </p>
<ul>
<li>In terms of the <a href="Riemann_zeta_function#Generalizations" title="wikilink">incomplete zeta functions</a> or "<a href="Debye_function" title="wikilink">Debye functions</a>" :</li>
</ul>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>Z_n(z) = {1 \over (n \!-\! 1)!} \int_z^\infty {t^{n-1} \over e^t-1} \,\mathrm{d}t \qquad (n = 1,2,3,\ldots) \,, </p>
<dl>
<dd>the polylogarithm Li<sub><em>n</em></sub>(<em>z</em>) for positive integer n may be expressed as the finite sum :
</dd>
</dl>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\operatorname{Li}_{n}(e^\mu) = \sum_{k=0}^{n-1} Z_{n-k}(-\mu) \,{\mu^k \over k!} \qquad (n = 1,2,3,\ldots) \,. </p>
<dl>
<dd>A remarkably similar expression relates the "Debye functions" <em>Z</em><sub><em>n</em></sub>(<em>z</em>) to the polylogarithm:
</dd>
</dl>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>Z_n(z) = \sum_{k=0}^{n-1} \operatorname{Li}_{n-k}(e^{-z}) \,{z^k \over k!} \qquad (n = 1,2,3,\ldots) \,. </p>
<h2 id="integral-representations">Integral representations</h2>

<p>Any of the following integral representations furnishes the <a href="analytic_continuation" title="wikilink">analytic continuation</a> of the polylogarithm beyond the circle of convergence |<em>z</em>| = 1 of the defining power series.</p>

<p><strong>1.</strong> The polylogarithm can be expressed in term of the integral of the <a href="Bose–Einstein_distribution" title="wikilink">Bose–Einstein distribution</a>:</p>

<p>
<math display="block" id="Polylogarithm:28">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mfrac>
<mn>1</mn>
<mrow>
<mi mathvariant="normal">Γ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>s</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">∫</mo>
<mn>0</mn>
<mi mathvariant="normal">∞</mi>
</msubsup>
<mrow>
<mpadded width="+1.7pt">
<mfrac>
<msup>
<mi>t</mi>
<mrow>
<mi>s</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mrow>
<mrow>
<msup>
<mi>e</mi>
<mi>t</mi>
</msup>
<mo>/</mo>
<mi>z</mi>
</mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</mfrac>
</mpadded>
<mi mathvariant="normal">d</mi>
<mpadded width="+1.7pt">
<mi>t</mi>
</mpadded>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<ci>z</ci>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<times></times>
<ci>normal-Γ</ci>
<ci>s</ci>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<int></int>
<cn type="integer">0</cn>
</apply>
<infinity></infinity>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>t</ci>
<apply>
<minus></minus>
<ci>s</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<minus></minus>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<ci>t</ci>
</apply>
<ci>z</ci>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>normal-d</ci>
<ci>t</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{s}(z)={1\over\Gamma(s)}\int_{0}^{\infty}{t^{s-1}\over e^{t}%
/z-1}\,\mathrm{d}t\,.
  </annotation>
</semantics>
</math>
</p>

<p>This converges for Re(<em>s</em>) &gt; 0 and all <em>z</em> except for <em>z</em> real and ≥ 1. The polylogarithm in this context is sometimes referred to as a Bose integral or a <a href="complete_Bose–Einstein_integral" title="wikilink">Bose–Einstein integral</a>. Similarly, the polylogarithm can be expressed in terms of the integral of the <a href="Fermi–Dirac_distribution" title="wikilink">Fermi–Dirac distribution</a>:</p>

<p>
<math display="block" id="Polylogarithm:29">
<semantics>
<mrow>
<mrow>
<mrow>
<mo>-</mo>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mi>z</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mfrac>
<mn>1</mn>
<mrow>
<mi mathvariant="normal">Γ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>s</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">∫</mo>
<mn>0</mn>
<mi mathvariant="normal">∞</mi>
</msubsup>
<mrow>
<mpadded width="+1.7pt">
<mfrac>
<msup>
<mi>t</mi>
<mrow>
<mi>s</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mrow>
<mrow>
<msup>
<mi>e</mi>
<mi>t</mi>
</msup>
<mo>/</mo>
<mi>z</mi>
</mrow>
<mo>+</mo>
<mn>1</mn>
</mrow>
</mfrac>
</mpadded>
<mi mathvariant="normal">d</mi>
<mpadded width="+1.7pt">
<mi>t</mi>
</mpadded>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<minus></minus>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<apply>
<minus></minus>
<ci>z</ci>
</apply>
</apply>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<times></times>
<ci>normal-Γ</ci>
<ci>s</ci>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<int></int>
<cn type="integer">0</cn>
</apply>
<infinity></infinity>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>t</ci>
<apply>
<minus></minus>
<ci>s</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<plus></plus>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<ci>t</ci>
</apply>
<ci>z</ci>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>normal-d</ci>
<ci>t</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   -\operatorname{Li}_{s}(-z)={1\over\Gamma(s)}\int_{0}^{\infty}{t^{s-1}\over e^{%
t}/z+1}\,\mathrm{d}t\,.
  </annotation>
</semantics>
</math>
</p>

<p>This converges for Re(<em>s</em>) &gt; 0 and all <em>z</em> except for <em>z</em> real and ≤ −1. The polylogarithm in this context is sometimes referred to as a Fermi integral or a <a href="complete_Fermi–Dirac_integral" title="wikilink">Fermi–Dirac integral</a> . These representations are readily verified by <a href="Taylor_series" title="wikilink">Taylor expansion</a> of the integrand with respect to <em>z</em> and termwise integration.</p>

<p><strong>2.</strong> A complementary integral representation applies to Re(<em>s</em>)  \operatorname{Li}_{s}(z) =</p>

<p>\int_0^\infty {t^{-s} \,\sin[s \,\pi /2 - t \ln(-z)] \over \sinh(\pi t)} \,\mathrm{d}t \,. </p>

<p>This integral follows from the general relation of the polylogarithm with the <a href="Hurwitz_zeta_function" title="wikilink">Hurwitz zeta function</a> (<a href="#Relationship_to_other_functions" title="wikilink">see above</a>) and a familiar integral representation of the latter.</p>

<p><strong>3.</strong> The polylogarithm may be quite generally represented by a <a href="Hankel_contour" title="wikilink">Hankel contour</a> integral , which extends the Bose–Einstein representation to negative orders <em>s</em>. As long as the <em>t</em> = <em>μ</em> <a href="pole_(complex_analysis)" title="wikilink">pole</a> of the integrand does not lie on the non-negative real axis, and <em>s</em> ≠ 1, 2, 3, ..., we have:</p>

<p>
<math display="block" id="Polylogarithm:30">
<semantics>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>e</mi>
<mi>μ</mi>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mrow>
<mfrac>
<mrow>
<mi mathvariant="normal">Γ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mpadded width="-1.7pt">
<mn>1</mn>
</mpadded>
<mo rspace="0.8pt">-</mo>
<mi>s</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mrow>
<mn>2</mn>
<mi>π</mi>
<mi>i</mi>
</mrow>
</mfrac>
<mrow>
<msub>
<mo largeop="true" symmetric="true">∮</mo>
<mi>H</mi>
</msub>
<mrow>
<mpadded width="+1.7pt">
<mfrac>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mi>t</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>s</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mrow>
<msup>
<mi>e</mi>
<mrow>
<mi>t</mi>
<mo>-</mo>
<mi>μ</mi>
</mrow>
</msup>
<mo>-</mo>
<mn>1</mn>
</mrow>
</mfrac>
</mpadded>
<mi mathvariant="normal">d</mi>
<mi>t</mi>
</mrow>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<ci>μ</ci>
</apply>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>normal-Γ</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>s</ci>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>π</ci>
<ci>i</ci>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<csymbol cd="latexml">contour-integral</csymbol>
<ci>H</ci>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<ci>t</ci>
</apply>
<apply>
<minus></minus>
<ci>s</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<apply>
<minus></minus>
<ci>t</ci>
<ci>μ</ci>
</apply>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>normal-d</ci>
<ci>t</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{s}(e^{\mu})=-{{\Gamma(1\!-\!s)}\over{2\pi i}}\oint_{H}{{(-t%
)^{s-1}}\over{e^{t-\mu}-1}}\,\mathrm{d}t
  </annotation>
</semantics>
</math>
</p>

<p>where <em>H</em> represents the Hankel contour. The integrand has a cut along the real axis from zero to infinity, with the axis belonging to the lower half plane of <em>t</em>. The integration starts at +∞ on the upper half plane (Im(<em>t</em>) &gt; 0), circles the origin without enclosing any of the poles <em>t</em> = <em>µ</em> + 2<em>kπi</em>, and terminates at +∞ on the lower half plane (Im(<em>t</em>)  \operatorname{Li}_s(e^\mu) = -{{\Gamma(1 \!-\! s)} \over {2\pi i}} \oint_H {{(-t)^{s-1}} \over {e^{t-\mu}}-1} \,\mathrm{d}t - 2\pi i R </p>

<p>where <em>R</em> is the <a href="residue_(complex_analysis)" title="wikilink">residue</a> of the pole:</p>

<p>
<math display="block" id="Polylogarithm:31">
<semantics>
<mrow>
<mrow>
<mi>R</mi>
<mo>=</mo>
<mrow>
<mfrac>
<mi>i</mi>
<mrow>
<mn>2</mn>
<mi>π</mi>
</mrow>
</mfrac>
<mi mathvariant="normal">Γ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mpadded width="-1.7pt">
<mn>1</mn>
</mpadded>
<mo rspace="0.8pt">-</mo>
<mi>s</mi>
</mrow>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
<mpadded width="+1.7pt">
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mi>μ</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>s</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mpadded>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>R</ci>
<apply>
<times></times>
<apply>
<divide></divide>
<ci>i</ci>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>π</ci>
</apply>
</apply>
<ci>normal-Γ</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>s</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<ci>μ</ci>
</apply>
<apply>
<minus></minus>
<ci>s</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   R={i\over 2\pi}\Gamma(1\!-\!s)\,(-\mu)^{s-1}\,.
  </annotation>
</semantics>
</math>
</p>

<p><strong>4.</strong> When the <a href="Abel–Plana_formula" title="wikilink">Abel–Plana formula</a> is applied to the defining series of the polylogarithm, a <a href="Charles_Hermite" title="wikilink">Hermite</a>-type integral representation results that is valid for all complex <em>z</em> and for all complex <em>s</em>:</p>

<p>
<math display="block" id="Polylogarithm:32">
<semantics>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mstyle>
<mi>z</mi>
</mrow>
<mo>+</mo>
<mfrac>
<mrow>
<mi mathvariant="normal">Γ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mpadded width="-1.7pt">
<mn>1</mn>
</mpadded>
<mo rspace="0.8pt">-</mo>
<mi>s</mi>
</mrow>
<mo>,</mo>
<mrow>
<mo>-</mo>
<mrow>
<mi>ln</mi>
<mi>z</mi>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mrow>
<mi>ln</mi>
<mi>z</mi>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>s</mi>
</mrow>
</msup>
</mfrac>
<mo>+</mo>
<mrow>
<mn>2</mn>
<mi>z</mi>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">∫</mo>
<mn>0</mn>
<mi mathvariant="normal">∞</mi>
</msubsup>
<mrow>
<mpadded width="+1.7pt">
<mfrac>
<mrow>
<mi>sin</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<mi>s</mi>
<mrow>
<mi>arctan</mi>
<mpadded width="+1.7pt">
<mi>t</mi>
</mpadded>
</mrow>
</mrow>
<mo rspace="4.2pt">-</mo>
<mrow>
<mi>t</mi>
<mrow>
<mi>ln</mi>
<mi>z</mi>
</mrow>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mrow>
<mpadded width="+1.7pt">
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>+</mo>
<msup>
<mi>t</mi>
<mn>2</mn>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>s</mi>
<mo>/</mo>
<mn>2</mn>
</mrow>
</msup>
</mpadded>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msup>
<mi>e</mi>
<mrow>
<mn>2</mn>
<mi>π</mi>
<mi>t</mi>
</mrow>
</msup>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
</mpadded>
<mi mathvariant="normal">d</mi>
<mi>t</mi>
</mrow>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<ci>z</ci>
</apply>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
<ci>z</ci>
</apply>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>normal-Γ</ci>
<interval closure="open">
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>s</ci>
</apply>
<apply>
<minus></minus>
<apply>
<ln></ln>
<ci>z</ci>
</apply>
</apply>
</interval>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<apply>
<ln></ln>
<ci>z</ci>
</apply>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>s</ci>
</apply>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>z</ci>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<int></int>
<cn type="integer">0</cn>
</apply>
<infinity></infinity>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<sin></sin>
<apply>
<minus></minus>
<apply>
<times></times>
<ci>s</ci>
<apply>
<arctan></arctan>
<ci>t</ci>
</apply>
</apply>
<apply>
<times></times>
<ci>t</ci>
<apply>
<ln></ln>
<ci>z</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<plus></plus>
<cn type="integer">1</cn>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>t</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<divide></divide>
<ci>s</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>π</ci>
<ci>t</ci>
</apply>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<ci>normal-d</ci>
<ci>t</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{s}(z)=\tfrac{1}{2}z+{\Gamma(1\!-\!s,-\ln z)\over(-\ln z)^{1%
-s}}+2z\int_{0}^{\infty}\frac{\sin(s\arctan t\,-\,t\ln z)}{(1+t^{2})^{s/2}\,(e%
^{2\pi t}-1)}\,\mathrm{d}t
  </annotation>
</semantics>
</math>
</p>

<p>where Γ is the <a href="incomplete_gamma_function" title="wikilink">upper incomplete gamma-function</a>. Note that all (but not part) of the ln(<em>z</em>) in this expression can be replaced by −ln(<sup>1</sup>⁄<sub><em>z</em></sub>). A related representation which also holds for all complex <em>s</em>,</p>

<p>
<math display="block" id="Polylogarithm:33">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mstyle>
<mi>z</mi>
</mrow>
<mo>+</mo>
<mrow>
<mi>z</mi>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">∫</mo>
<mn>0</mn>
<mi mathvariant="normal">∞</mi>
</msubsup>
<mrow>
<mpadded width="+1.7pt">
<mfrac>
<mrow>
<mi>sin</mi>
<mrow>
<mo stretchy="false">[</mo>
<mrow>
<mrow>
<mi>s</mi>
<mrow>
<mi>arctan</mi>
<mpadded width="+1.7pt">
<mi>t</mi>
</mpadded>
</mrow>
</mrow>
<mo rspace="4.2pt">-</mo>
<mrow>
<mi>t</mi>
<mrow>
<mi>ln</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mi>z</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<mo stretchy="false">]</mo>
</mrow>
</mrow>
<mrow>
<mpadded width="+1.7pt">
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>+</mo>
<msup>
<mi>t</mi>
<mn>2</mn>
</msup>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>s</mi>
<mo>/</mo>
<mn>2</mn>
</mrow>
</msup>
</mpadded>
<mrow>
<mi>sinh</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>π</mi>
<mi>t</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mfrac>
</mpadded>
<mi mathvariant="normal">d</mi>
<mpadded width="+1.7pt">
<mi>t</mi>
</mpadded>
</mrow>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<ci>z</ci>
</apply>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
<ci>z</ci>
</apply>
<apply>
<times></times>
<ci>z</ci>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<int></int>
<cn type="integer">0</cn>
</apply>
<infinity></infinity>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<sin></sin>
<apply>
<minus></minus>
<apply>
<times></times>
<ci>s</ci>
<apply>
<arctan></arctan>
<ci>t</ci>
</apply>
</apply>
<apply>
<times></times>
<ci>t</ci>
<apply>
<ln></ln>
<apply>
<minus></minus>
<ci>z</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<plus></plus>
<cn type="integer">1</cn>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>t</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<divide></divide>
<ci>s</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<sinh></sinh>
<apply>
<times></times>
<ci>π</ci>
<ci>t</ci>
</apply>
</apply>
</apply>
</apply>
<ci>normal-d</ci>
<ci>t</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{s}(z)=\tfrac{1}{2}z+z\int_{0}^{\infty}\frac{\sin[s\arctan t%
\,-\,t\ln(-z)]}{(1+t^{2})^{s/2}\,\sinh(\pi t)}\,\mathrm{d}t\,,
  </annotation>
</semantics>
</math>
</p>

<p>avoids the use of the incomplete gamma function, but this integral fails for <em>z</em> on the positive real axis if Re(<em>s</em>) ≤ 0. This expression is found by writing 2<sup><em>s</em></sup> Li<sub><em>s</em></sub>(−<em>z</em>) / (−<em>z</em>) = Φ(<em>z</em><sup>2</sup>, <em>s</em>, <sup>1</sup>⁄<sub>2</sub>) − <em>z</em> Φ(<em>z</em><sup>2</sup>, <em>s</em>, 1), where Φ is the <a href="Lerch_transcendent" title="wikilink">Lerch transcendent</a>, and applying the Abel–Plana formula to the first Φ series and a complementary formula that involves 1 / (<em>e</em><sup>2<em>πt</em></sup> + 1) in place of 1 / (<em>e</em><sup>2<em>πt</em></sup> − 1) to the second Φ series.</p>
<h2 id="series-representations">Series representations</h2>

<p><strong>1.</strong> As noted under <a href="#Integral_representations" title="wikilink">integral representations</a> above, the Bose–Einstein integral representation of the polylogarithm may be extended to negative orders <em>s</em> by means of <a href="Hankel_contour" title="wikilink">Hankel contour</a> integration:</p>

<p>
<math display="block" id="Polylogarithm:34">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>e</mi>
<mi>μ</mi>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mrow>
<mfrac>
<mrow>
<mi mathvariant="normal">Γ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mpadded width="-1.7pt">
<mn>1</mn>
</mpadded>
<mo rspace="0.8pt">-</mo>
<mi>s</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mrow>
<mn>2</mn>
<mi>π</mi>
<mi>i</mi>
</mrow>
</mfrac>
<mrow>
<msub>
<mo largeop="true" symmetric="true">∮</mo>
<mi>H</mi>
</msub>
<mrow>
<mpadded width="+1.7pt">
<mfrac>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mi>t</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>s</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mrow>
<msup>
<mi>e</mi>
<mrow>
<mi>t</mi>
<mo>-</mo>
<mi>μ</mi>
</mrow>
</msup>
<mo>-</mo>
<mn>1</mn>
</mrow>
</mfrac>
</mpadded>
<mi mathvariant="normal">d</mi>
<mpadded width="+1.7pt">
<mi>t</mi>
</mpadded>
</mrow>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<ci>μ</ci>
</apply>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>normal-Γ</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>s</ci>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>π</ci>
<ci>i</ci>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<csymbol cd="latexml">contour-integral</csymbol>
<ci>H</ci>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<ci>t</ci>
</apply>
<apply>
<minus></minus>
<ci>s</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<apply>
<minus></minus>
<ci>t</ci>
<ci>μ</ci>
</apply>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>normal-d</ci>
<ci>t</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{s}(e^{\mu})=-{\Gamma(1\!-\!s)\over 2\pi i}\oint_{H}{(-t)^{s%
-1}\over e^{t-\mu}-1}\,\mathrm{d}t\,,
  </annotation>
</semantics>
</math>
</p>

<p>where <em>H</em> is the Hankel contour, <em>s</em> ≠ 1, 2, 3, ..., and the <em>t</em> = <em>μ</em> pole of the integrand does not lie on the non-negative real axis. The <a href="methods_of_contour_integration" title="wikilink">contour</a> can be modified so that it encloses the <a href="pole_(complex_analysis)" title="wikilink">poles</a> of the integrand at <em>t</em> − <em>µ</em> = 2<em>kπi</em>, and the integral can be evaluated as the sum of the <a href="residue_(complex_analysis)" title="wikilink">residues</a> (; ):</p>

<p>
<math display="block" id="Polylogarithm:35">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>e</mi>
<mi>μ</mi>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mi mathvariant="normal">Γ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mpadded width="-1.7pt">
<mn>1</mn>
</mpadded>
<mo rspace="0.8pt">-</mo>
<mi>s</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>k</mi>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</mrow>
<mi mathvariant="normal">∞</mi>
</munderover>
<mpadded width="+1.7pt">
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<mn>2</mn>
<mi>k</mi>
<mi>π</mi>
<mi>i</mi>
</mrow>
<mo>-</mo>
<mi>μ</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>s</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mpadded>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<ci>μ</ci>
</apply>
</apply>
<apply>
<times></times>
<ci>normal-Γ</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>s</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>k</ci>
<apply>
<minus></minus>
<infinity></infinity>
</apply>
</apply>
</apply>
<infinity></infinity>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>k</ci>
<ci>π</ci>
<ci>i</ci>
</apply>
<ci>μ</ci>
</apply>
<apply>
<minus></minus>
<ci>s</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{s}(e^{\mu})=\Gamma(1\!-\!s)\sum_{k=-\infty}^{\infty}(2k\pi i%
-\mu)^{s-1}\,.
  </annotation>
</semantics>
</math>
</p>

<p>This will hold for Re(<em>s</em>) <em>μ</em> = 1. For 0  \operatorname{Li}_s(e^\mu) = \Gamma(1-s) \left[ (-2\pi i)^{s-1} \sum_{k=0}^\infty \left(k + {\mu \over {2\pi i}} \right)^{s-1} + (2\pi i)^{s-1} \sum_{k=0}^\infty \left(k+1- {\mu \over {2\pi i}} \right)^{s-1} \right] , </p>

<p>where the two series can now be identified with the <a href="Hurwitz_zeta_function" title="wikilink">Hurwitz zeta function</a>:</p>

<p>
<math display="block" id="Polylogarithm:36">
<semantics>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>e</mi>
<mi>μ</mi>
</msup>
<mo stretchy="false">)</mo>
</mrow>
<mo>=</mo>
<mfrac>
<mrow>
<mi mathvariant="normal">Γ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mpadded width="-1.7pt">
<mn>1</mn>
</mpadded>
<mo rspace="0.8pt">-</mo>
<mi>s</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>2</mn>
<mi>π</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>s</mi>
</mrow>
</msup>
</mfrac>
<mrow>
<mo>[</mo>
<mpadded width="+3.3pt">
<msup>
<mi>i</mi>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>s</mi>
</mrow>
</msup>
</mpadded>
<mpadded width="-1.7pt">
<mi>ζ</mi>
</mpadded>
<mrow>
<mo>(</mo>
<mpadded width="-1.7pt">
<mn>1</mn>
</mpadded>
<mo rspace="0.8pt">-</mo>
<mi>s</mi>
<mo rspace="5.8pt">,</mo>
<mfrac>
<mi>μ</mi>
<mrow>
<mn>2</mn>
<mi>π</mi>
<mi>i</mi>
</mrow>
</mfrac>
<mo>)</mo>
</mrow>
<mo>+</mo>
<mpadded width="+3.3pt">
<msup>
<mi>i</mi>
<mrow>
<mi>s</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mpadded>
<mpadded width="-1.7pt">
<mi>ζ</mi>
</mpadded>
<mrow>
<mo>(</mo>
<mpadded width="-1.7pt">
<mn>1</mn>
</mpadded>
<mo rspace="0.8pt">-</mo>
<mi>s</mi>
<mo rspace="5.8pt">,</mo>
<mn>1</mn>
<mo>-</mo>
<mfrac>
<mi>μ</mi>
<mrow>
<mn>2</mn>
<mi>π</mi>
<mi>i</mi>
</mrow>
</mfrac>
<mo>)</mo>
</mrow>
<mo>]</mo>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mn>0</mn>
<mo>&lt;</mo>
<mtext>Im</mtext>
<mrow>
<mo stretchy="false">(</mo>
<mi>μ</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>≤</mo>
<mn>2</mn>
<mi>π</mi>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<ci>μ</ci>
</apply>
<ci>normal-)</ci>
</cerror>
<eq></eq>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>normal-Γ</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>s</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>π</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>s</ci>
</apply>
</apply>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-[</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>i</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>s</ci>
</apply>
</apply>
<csymbol cd="unknown">ζ</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<cn type="integer">1</cn>
<minus></minus>
<csymbol cd="unknown">s</csymbol>
<ci>normal-,</ci>
<apply>
<divide></divide>
<ci>μ</ci>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>π</ci>
<ci>i</ci>
</apply>
</apply>
<ci>normal-)</ci>
</cerror>
<plus></plus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>i</ci>
<apply>
<minus></minus>
<ci>s</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<csymbol cd="unknown">ζ</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<cn type="integer">1</cn>
<minus></minus>
<csymbol cd="unknown">s</csymbol>
<ci>normal-,</ci>
<cn type="integer">1</cn>
<minus></minus>
<apply>
<divide></divide>
<ci>μ</ci>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>π</ci>
<ci>i</ci>
</apply>
</apply>
<ci>normal-)</ci>
</cerror>
<ci>normal-]</ci>
</cerror>
<ci>italic-</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<cn type="integer">0</cn>
<lt></lt>
<mtext>Im</mtext>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">μ</csymbol>
<ci>normal-)</ci>
</cerror>
<leq></leq>
<cn type="integer">2</cn>
<csymbol cd="unknown">π</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-.</ci>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{s}(e^{\mu})={\Gamma(1\!-\!s)\over(2\pi)^{1-s}}\left[i^{1-s}%
~{}\zeta\!\left(1\!-\!s,~{}{\mu\over{2\pi i}}\right)+i^{s-1}~{}\zeta\!\left(1%
\!-\!s,~{}1-{\mu\over{2\pi i}}\right)\right]\qquad(0&lt;\textrm{Im}(\mu)\leq 2\pi%
)\,.
  </annotation>
</semantics>
</math>
</p>

<p>This relation, which has already been given under <a href="#Relationship_to_other_functions" title="wikilink">relationship to other functions</a> above, holds for all complex <em>s</em> ≠ 0, 1, 2, 3, ... and was first derived in .</p>

<p><strong>2.</strong> In order to represent the polylogarithm as a power series about <em>µ</em> = 0, we write the series derived from the Hankel contour integral as:</p>

<p>
<math display="block" id="Polylogarithm:37">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>e</mi>
<mi>μ</mi>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mi mathvariant="normal">Γ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mpadded width="-1.7pt">
<mn>1</mn>
</mpadded>
<mo rspace="0.8pt">-</mo>
<mi>s</mi>
</mrow>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mi>μ</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>s</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
<mo>+</mo>
<mrow>
<mi mathvariant="normal">Γ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mpadded width="-1.7pt">
<mn>1</mn>
</mpadded>
<mo rspace="0.8pt">-</mo>
<mi>s</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>h</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mi mathvariant="normal">∞</mi>
</munderover>
<mrow>
<mo>[</mo>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<mo>-</mo>
<mrow>
<mn>2</mn>
<mi>h</mi>
<mi>π</mi>
<mi>i</mi>
</mrow>
</mrow>
<mo>-</mo>
<mi>μ</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>s</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mo>+</mo>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<mn>2</mn>
<mi>h</mi>
<mi>π</mi>
<mi>i</mi>
</mrow>
<mo>-</mo>
<mi>μ</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>s</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
<mo>]</mo>
</mrow>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<ci>μ</ci>
</apply>
</apply>
<apply>
<plus></plus>
<apply>
<times></times>
<ci>normal-Γ</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>s</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<ci>μ</ci>
</apply>
<apply>
<minus></minus>
<ci>s</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<apply>
<times></times>
<ci>normal-Γ</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>s</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>h</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<infinity></infinity>
</apply>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<apply>
<minus></minus>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>h</ci>
<ci>π</ci>
<ci>i</ci>
</apply>
</apply>
<ci>μ</ci>
</apply>
<apply>
<minus></minus>
<ci>s</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>h</ci>
<ci>π</ci>
<ci>i</ci>
</apply>
<ci>μ</ci>
</apply>
<apply>
<minus></minus>
<ci>s</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{s}(e^{\mu})=\Gamma(1\!-\!s)\,(-\mu)^{s-1}+\Gamma(1\!-\!s)%
\sum_{h=1}^{\infty}\left[(-2h\pi i-\mu)^{s-1}+(2h\pi i-\mu)^{s-1}\right].
  </annotation>
</semantics>
</math>
</p>

<p>When the binomial powers in the sum are expanded about <em>µ</em> = 0 and the order of summation is reversed, the sum over <em>h</em> can be expressed in closed form:</p>

<p>
<math display="block" id="Polylogarithm:38">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>e</mi>
<mi>μ</mi>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mi mathvariant="normal">Γ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mpadded width="-1.7pt">
<mn>1</mn>
</mpadded>
<mo rspace="0.8pt">-</mo>
<mi>s</mi>
</mrow>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mi>μ</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>s</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
<mo>+</mo>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>k</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mi mathvariant="normal">∞</mi>
</munderover>
<mrow>
<mpadded width="+1.7pt">
<mfrac>
<mrow>
<mi>ζ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>s</mi>
<mo>-</mo>
<mi>k</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mrow>
<mi>k</mi>
<mo lspace="0pt" rspace="3.5pt">!</mo>
</mrow>
</mfrac>
</mpadded>
<mpadded width="+1.7pt">
<msup>
<mi>μ</mi>
<mi>k</mi>
</msup>
</mpadded>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<ci>μ</ci>
</apply>
</apply>
<apply>
<plus></plus>
<apply>
<times></times>
<ci>normal-Γ</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>s</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<ci>μ</ci>
</apply>
<apply>
<minus></minus>
<ci>s</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>k</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<infinity></infinity>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>ζ</ci>
<apply>
<minus></minus>
<ci>s</ci>
<ci>k</ci>
</apply>
</apply>
<apply>
<factorial></factorial>
<ci>k</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>μ</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{s}(e^{\mu})=\Gamma(1\!-\!s)\,(-\mu)^{s-1}+\sum_{k=0}^{%
\infty}{\zeta(s-k)\over k!}\,\mu^{k}\,.
  </annotation>
</semantics>
</math>
</p>

<p>This result holds for |<em>µ</em>|  \lim_{s \rightarrow k+1} \left[ {\zeta(s-k) \over k!} \,\mu^k + \Gamma(1 \!-\! s) \,(-\mu)^{s-1} \right] = {\mu^k \over k!} \left[ \,\sum_{h=1}^k {1 \over h} - \ln(-\mu) \right] , </p>

<p>where the sum over <em>h</em> vanishes if <em>k</em> = 0. So, for positive integer orders and for |<em>μ</em>|  \operatorname{Li}_{n}(e^\mu) = {\mu^{n-1} \over (n \!-\! 1)!} \left[ H_{n-1} - \ln(-\mu) \right] + \sum_{k=0,\,k\ne n-1}^\infty {\zeta(n-k) \over k!} \,\mu^k \,, </p>

<p>where <em>H</em><sub><em>n</em></sub> denotes the <em>n</em>th <a href="harmonic_number" title="wikilink">harmonic number</a>:</p>

<p>
<math display="block" id="Polylogarithm:39">
<semantics>
<mrow>
<mrow>
<msub>
<mi>H</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>h</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mi>n</mi>
</munderover>
<mfrac>
<mn>1</mn>
<mi>h</mi>
</mfrac>
</mrow>
</mrow>
<mo rspace="22.5pt">,</mo>
<mrow>
<msub>
<mi>H</mi>
<mn>0</mn>
</msub>
<mo>=</mo>
<mn>0 .</mn>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<ci>n</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>h</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>n</ci>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<ci>h</ci>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>H</ci>
<cn type="integer">0</cn>
</apply>
<cn type="float">0 .</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   H_{n}=\sum_{h=1}^{n}{1\over h},\qquad H_{0}=0\,.
  </annotation>
</semantics>
</math>
</p>

<p>The problem terms now contain −ln(−<em>μ</em>) which, when multiplied by <em>μ</em><sup><em>n</em>−1</sup>, will tend to zero as <em>μ</em> → 0, except for <em>n</em> = 1. This reflects the fact that Li<sub><em>s</em></sub>(<em>z</em>) exhibits a true <a href="mathematical_singularity" title="wikilink">logarithmic singularity</a> at <em>s</em> = 1 and <em>z</em> = 1 since:</p>

<p>
<math display="block" id="Polylogarithm:40">
<semantics>
<mrow>
<munder>
<mo movablelimits="false">lim</mo>
<mrow>
<mi>μ</mi>
<mo>→</mo>
<mn>0</mn>
</mrow>
</munder>
<mi mathvariant="normal">Γ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mpadded width="-1.7pt">
<mn>1</mn>
</mpadded>
<mo rspace="0.8pt">-</mo>
<mi>s</mi>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mo>-</mo>
<mi>μ</mi>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>s</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mo>=</mo>
<mn>0</mn>
<mrow>
<mo stretchy="false">(</mo>
<mtext>Re</mtext>
<mrow>
<mo stretchy="false">(</mo>
<mi>s</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>&gt;</mo>
<mn>1</mn>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<limit></limit>
<apply>
<ci>normal-→</ci>
<ci>μ</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<csymbol cd="unknown">Γ</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<cn type="integer">1</cn>
<minus></minus>
<csymbol cd="unknown">s</csymbol>
<ci>normal-)</ci>
</cerror>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<minus></minus>
<csymbol cd="unknown">μ</csymbol>
<ci>normal-)</ci>
</cerror>
<apply>
<minus></minus>
<ci>s</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<eq></eq>
<cn type="integer">0</cn>
<ci>italic-</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<mtext>Re</mtext>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">s</csymbol>
<ci>normal-)</ci>
</cerror>
<gt></gt>
<cn type="integer">1</cn>
<ci>normal-)</ci>
</cerror>
<ci>normal-.</ci>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lim_{\mu\rightarrow 0}\Gamma(1\!-\!s)\,(-\mu)^{s-1}=0\qquad(\textrm{Re}(s)&gt;1)\,.
  </annotation>
</semantics>
</math>
</p>

<p>For <em>s</em> close, but not equal, to a positive integer, the divergent terms in the expansion about <em>µ</em> = 0 can be expected to cause computational difficulties . Note also that Erdélyi's corresponding expansion  in powers of ln(<em>z</em>) is not correct if one assumes that the principal branches of the polylogarithm and the logarithm are used simultaneously, since ln(<sup>1</sup>⁄<sub><em>z</em></sub>) is not uniformly equal to −ln(<em>z</em>).</p>

<p>For nonpositive integer values of <em>s</em>, the zeta function ζ(<em>s</em> − <em>k</em>) in the expansion about <em>µ</em> = 0 reduces to <a href="Bernoulli_numbers" title="wikilink">Bernoulli numbers</a>: ζ(−<em>n</em> − <em>k</em>) = −B<sub>1+<em>n</em>+<em>k</em></sub> / (1 + <em>n</em> + <em>k</em>). Numerical evaluation of Li<sub>−<em>n</em></sub>(<em>z</em>) by this series does not suffer from the cancellation effects that the finite rational expressions given under <a href="#Particular_values" title="wikilink">particular values</a> above exhibit for large <em>n</em>.</p>

<p><strong>3.</strong> By use of the identity</p>

<p>
<math display="block" id="Polylogarithm:41">
<semantics>
<mrow>
<mn>1</mn>
<mo>=</mo>
<mfrac>
<mn>1</mn>
<mrow>
<mi mathvariant="normal">Γ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>s</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
<msubsup>
<mo largeop="true" symmetric="true">∫</mo>
<mn>0</mn>
<mi mathvariant="normal">∞</mi>
</msubsup>
<mpadded width="+1.7pt">
<msup>
<mi>e</mi>
<mrow>
<mo>-</mo>
<mi>t</mi>
</mrow>
</msup>
</mpadded>
<mpadded width="+1.7pt">
<msup>
<mi>t</mi>
<mrow>
<mi>s</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mpadded>
<mi mathvariant="normal">d</mi>
<mi>t</mi>
<mrow>
<mo stretchy="false">(</mo>
<mtext>Re</mtext>
<mrow>
<mo stretchy="false">(</mo>
<mi>s</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>&gt;</mo>
<mn>0</mn>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<cn type="integer">1</cn>
<eq></eq>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<times></times>
<ci>normal-Γ</ci>
<ci>s</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<int></int>
<cn type="integer">0</cn>
</apply>
<infinity></infinity>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<apply>
<minus></minus>
<ci>t</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>t</ci>
<apply>
<minus></minus>
<ci>s</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<csymbol cd="unknown">d</csymbol>
<csymbol cd="unknown">t</csymbol>
<ci>italic-</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<mtext>Re</mtext>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">s</csymbol>
<ci>normal-)</ci>
</cerror>
<gt></gt>
<cn type="integer">0</cn>
<ci>normal-)</ci>
</cerror>
<ci>normal-,</ci>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   1={1\over\Gamma(s)}\int_{0}^{\infty}e^{-t}\,t^{s-1}\,\mathrm{d}t\qquad(\textrm%
{Re}(s)&gt;0)\,,
  </annotation>
</semantics>
</math>
</p>

<p>the Bose–Einstein integral representation of the polylogarithm (<a href="#Integral_representations" title="wikilink">see above</a>) may be cast in the form:</p>

<p>
<math display="block" id="Polylogarithm:42">
<semantics>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>=</mo>
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mstyle>
<mi>z</mi>
<mo>+</mo>
<mfrac>
<mi>z</mi>
<mrow>
<mn>2</mn>
<mi mathvariant="normal">Γ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>s</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
<msubsup>
<mo largeop="true" symmetric="true">∫</mo>
<mn>0</mn>
<mi mathvariant="normal">∞</mi>
</msubsup>
<mpadded width="+1.7pt">
<msup>
<mi>e</mi>
<mrow>
<mo>-</mo>
<mi>t</mi>
</mrow>
</msup>
</mpadded>
<msup>
<mi>t</mi>
<mrow>
<mi>s</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mi>coth</mi>
<mpadded width="+1.7pt">
<mfrac>
<mrow>
<mi>t</mi>
<mo>-</mo>
<mrow>
<mi>ln</mi>
<mi>z</mi>
</mrow>
</mrow>
<mn>2</mn>
</mfrac>
</mpadded>
<mi mathvariant="normal">d</mi>
<mi>t</mi>
<mrow>
<mo stretchy="false">(</mo>
<mtext>Re</mtext>
<mrow>
<mo stretchy="false">(</mo>
<mi>s</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>&gt;</mo>
<mn>0</mn>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">z</csymbol>
<ci>normal-)</ci>
</cerror>
<eq></eq>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
<csymbol cd="unknown">z</csymbol>
<plus></plus>
<apply>
<divide></divide>
<ci>z</ci>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>normal-Γ</ci>
<ci>s</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<int></int>
<cn type="integer">0</cn>
</apply>
<infinity></infinity>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<apply>
<minus></minus>
<ci>t</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>t</ci>
<apply>
<minus></minus>
<ci>s</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<csymbol cd="latexml">hyperbolic-cotangent</csymbol>
<apply>
<divide></divide>
<apply>
<minus></minus>
<ci>t</ci>
<apply>
<ln></ln>
<ci>z</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
<csymbol cd="unknown">d</csymbol>
<csymbol cd="unknown">t</csymbol>
<ci>italic-</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<mtext>Re</mtext>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">s</csymbol>
<ci>normal-)</ci>
</cerror>
<gt></gt>
<cn type="integer">0</cn>
<ci>normal-)</ci>
</cerror>
<ci>normal-.</ci>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{s}(z)=\tfrac{1}{2}z+{z\over 2\Gamma(s)}\int_{0}^{\infty}e^{%
-t}\,t^{s-1}\coth{t-\ln z\over 2}\,\mathrm{d}t\qquad(\textrm{Re}(s)&gt;0)\,.
  </annotation>
</semantics>
</math>
</p>

<p>Replacing the hyperbolic cotangent with a bilateral series,</p>

<p>
<math display="block" id="Polylogarithm:43">
<semantics>
<mrow>
<mrow>
<mrow>
<mi>coth</mi>
<mfrac>
<mrow>
<mi>t</mi>
<mo>-</mo>
<mrow>
<mi>ln</mi>
<mi>z</mi>
</mrow>
</mrow>
<mn>2</mn>
</mfrac>
</mrow>
<mo>=</mo>
<mrow>
<mn>2</mn>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>k</mi>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</mrow>
<mi mathvariant="normal">∞</mi>
</munderover>
<mpadded width="+1.7pt">
<mfrac>
<mn>1</mn>
<mrow>
<mrow>
<mrow>
<mn>2</mn>
<mi>k</mi>
<mi>π</mi>
<mi>i</mi>
</mrow>
<mo>+</mo>
<mi>t</mi>
</mrow>
<mo>-</mo>
<mrow>
<mi>ln</mi>
<mi>z</mi>
</mrow>
</mrow>
</mfrac>
</mpadded>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="latexml">hyperbolic-cotangent</csymbol>
<apply>
<divide></divide>
<apply>
<minus></minus>
<ci>t</ci>
<apply>
<ln></ln>
<ci>z</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">2</cn>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>k</ci>
<apply>
<minus></minus>
<infinity></infinity>
</apply>
</apply>
</apply>
<infinity></infinity>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<minus></minus>
<apply>
<plus></plus>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>k</ci>
<ci>π</ci>
<ci>i</ci>
</apply>
<ci>t</ci>
</apply>
<apply>
<ln></ln>
<ci>z</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \coth{t-\ln z\over 2}=2\sum_{k=-\infty}^{\infty}{1\over 2k\pi i+t-\ln z}\,,
  </annotation>
</semantics>
</math>
</p>

<p>then reversing the order of integral and sum, and finally identifying the summands with an integral representation of the <a href="incomplete_gamma_function" title="wikilink">upper incomplete gamma function</a>, one obtains:</p>

<p>
<math display="block" id="Polylogarithm:44">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mstyle>
<mi>z</mi>
</mrow>
<mo>+</mo>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>k</mi>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</mrow>
<mi mathvariant="normal">∞</mi>
</munderover>
<mpadded width="+1.7pt">
<mfrac>
<mrow>
<mi mathvariant="normal">Γ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mpadded width="-1.7pt">
<mn>1</mn>
</mpadded>
<mo rspace="0.8pt">-</mo>
<mi>s</mi>
</mrow>
<mo>,</mo>
<mrow>
<mrow>
<mn>2</mn>
<mi>k</mi>
<mi>π</mi>
<mi>i</mi>
</mrow>
<mo>-</mo>
<mrow>
<mi>ln</mi>
<mi>z</mi>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<mn>2</mn>
<mi>k</mi>
<mi>π</mi>
<mi>i</mi>
</mrow>
<mo>-</mo>
<mrow>
<mi>ln</mi>
<mi>z</mi>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>s</mi>
</mrow>
</msup>
</mfrac>
</mpadded>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<ci>z</ci>
</apply>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
<ci>z</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>k</ci>
<apply>
<minus></minus>
<infinity></infinity>
</apply>
</apply>
</apply>
<infinity></infinity>
</apply>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>normal-Γ</ci>
<interval closure="open">
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>s</ci>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<cn type="float">2</cn>
<ci>k</ci>
<ci>π</ci>
<ci>i</ci>
</apply>
<apply>
<ln></ln>
<ci>z</ci>
</apply>
</apply>
</interval>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>k</ci>
<ci>π</ci>
<ci>i</ci>
</apply>
<apply>
<ln></ln>
<ci>z</ci>
</apply>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>s</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{s}(z)=\tfrac{1}{2}z+\sum_{k=-\infty}^{\infty}{\Gamma(1\!-\!%
s,\,2k\pi i-\ln z)\over(2k\pi i-\ln z)^{1-s}}\,.
  </annotation>
</semantics>
</math>
</p>

<p>For both the bilateral series of this result and that for the hyperbolic cotangent, symmetric partial sums from −<em>k</em><sub>max</sub> to <em>k</em><sub>max</sub> converge unconditionally as <em>k</em><sub>max</sub> → ∞. Provided the summation is performed symmetrically, this series for Li<sub><em>s</em></sub>(<em>z</em>) thus holds for all complex <em>s</em> as well as all complex <em>z</em>.</p>

<p><strong>4.</strong> Introducing an explicit expression for the <a href="Stirling_numbers_of_the_second_kind" title="wikilink">Stirling numbers of the second kind</a> into the finite sum for the polylogarithm of nonpositive integer order (<a href="#Particular_values" title="wikilink">see above</a>) one may write:</p>

<p>
<math display="block" id="Polylogarithm:45">
<semantics>
<mrow>
<msub>
<mo>Li</mo>
<mrow>
<mo>-</mo>
<mi>n</mi>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>=</mo>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>k</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mi>n</mi>
</munderover>
<mpadded width="+3.3pt">
<msup>
<mrow>
<mo>(</mo>
<mfrac>
<mrow>
<mo>-</mo>
<mi>z</mi>
</mrow>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>z</mi>
</mrow>
</mfrac>
<mo>)</mo>
</mrow>
<mrow>
<mi>k</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msup>
</mpadded>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>j</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mi>k</mi>
</munderover>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mo>-</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>j</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msup>
<mrow>
<mo>(</mo>
<mtable columnspacing="0.4em" rowspacing="0.2ex">
<mtr>
<mtd>
<mi>k</mi>
</mtd>
</mtr>
<mtr>
<mtd>
<mi>j</mi>
</mtd>
</mtr>
</mtable>
<mo>)</mo>
</mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>j</mi>
<mo>+</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mrow>
<mi>n</mi>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>=</mo>
<mn>0</mn>
<mo>,</mo>
<mn>1</mn>
<mo>,</mo>
<mn>2</mn>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<apply>
<minus></minus>
<ci>n</ci>
</apply>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">z</csymbol>
<ci>normal-)</ci>
</cerror>
<eq></eq>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>k</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<divide></divide>
<apply>
<minus></minus>
<ci>z</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>z</ci>
</apply>
</apply>
<ci>normal-)</ci>
</cerror>
<apply>
<plus></plus>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>j</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<minus></minus>
<cn type="integer">1</cn>
<ci>normal-)</ci>
</cerror>
<apply>
<plus></plus>
<ci>j</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="latexml">binomial</csymbol>
<ci>k</ci>
<ci>j</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">j</csymbol>
<plus></plus>
<cn type="integer">1</cn>
<ci>normal-)</ci>
</cerror>
<ci>n</ci>
</apply>
<ci>italic-</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">n</csymbol>
<eq></eq>
<cn type="integer">0</cn>
<ci>normal-,</ci>
<cn type="integer">1</cn>
<ci>normal-,</ci>
<cn type="integer">2</cn>
<ci>normal-,</ci>
<ci>normal-…</ci>
<ci>normal-)</ci>
</cerror>
<ci>normal-.</ci>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{-n}(z)=\sum_{k=0}^{n}\left({-z\over 1-z}\right)^{k+1}~{}%
\sum_{j=0}^{k}(-1)^{j+1}{k\choose j}(j+1)^{n}\qquad(n=0,1,2,\ldots)\,.
  </annotation>
</semantics>
</math>
</p>

<p>The infinite series obtained by simply extending the outer summation to ∞ :</p>

<p>
<math display="block" id="Polylogarithm:46">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>k</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mi mathvariant="normal">∞</mi>
</munderover>
<mrow>
<mpadded width="+3.3pt">
<msup>
<mrow>
<mo>(</mo>
<mfrac>
<mrow>
<mo>-</mo>
<mi>z</mi>
</mrow>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>z</mi>
</mrow>
</mfrac>
<mo>)</mo>
</mrow>
<mrow>
<mi>k</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msup>
</mpadded>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>j</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mi>k</mi>
</munderover>
<mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>j</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msup>
<mrow>
<mo>(</mo>
<mtable columnspacing="0.4em" rowspacing="0.2ex">
<mtr>
<mtd>
<mi>k</mi>
</mtd>
</mtr>
<mtr>
<mtd>
<mi>j</mi>
</mtd>
</mtr>
</mtable>
<mo>)</mo>
</mrow>
<mpadded width="+1.7pt">
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>j</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mi>s</mi>
</mrow>
</msup>
</mpadded>
</mrow>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<ci>z</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>k</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<infinity></infinity>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<divide></divide>
<apply>
<minus></minus>
<ci>z</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>z</ci>
</apply>
</apply>
<apply>
<plus></plus>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>j</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<ci>k</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
<apply>
<plus></plus>
<ci>j</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="latexml">binomial</csymbol>
<ci>k</ci>
<ci>j</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<plus></plus>
<ci>j</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<minus></minus>
<ci>s</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{s}(z)=\sum_{k=0}^{\infty}\left({-z\over 1-z}\right)^{k+1}~{%
}\sum_{j=0}^{k}(-1)^{j+1}{k\choose j}(j+1)^{-s}\,,
  </annotation>
</semantics>
</math>
</p>

<p>turns out to converge to the polylogarithm for all complex <em>s</em> and for complex <em>z</em> with Re(<em>z</em>) 1⁄<sub>2</sub>, as can be verified for |<sup>−<em>z</em></sup>⁄<sub>(1−<em>z</em>)</sub>| 1⁄<sub>2</sub> by reversing the order of summation and using:</p>

<p>
<math display="block" id="Polylogarithm:47">
<semantics>
<mrow>
<mrow>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>k</mi>
<mo>=</mo>
<mi>j</mi>
</mrow>
<mi mathvariant="normal">∞</mi>
</munderover>
<mrow>
<mrow>
<mo>(</mo>
<mtable columnspacing="0.4em" rowspacing="0.2ex">
<mtr>
<mtd>
<mi>k</mi>
</mtd>
</mtr>
<mtr>
<mtd>
<mi>j</mi>
</mtd>
</mtr>
</mtable>
<mo>)</mo>
</mrow>
<msup>
<mrow>
<mo>(</mo>
<mfrac>
<mrow>
<mo>-</mo>
<mi>z</mi>
</mrow>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>z</mi>
</mrow>
</mfrac>
<mo>)</mo>
</mrow>
<mrow>
<mi>k</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
</mrow>
<mo>=</mo>
<msup>
<mrow>
<mo>[</mo>
<mrow>
<msup>
<mrow>
<mo>(</mo>
<mfrac>
<mrow>
<mo>-</mo>
<mi>z</mi>
</mrow>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>z</mi>
</mrow>
</mfrac>
<mo>)</mo>
</mrow>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo>]</mo>
</mrow>
<mrow>
<mrow>
<mo>-</mo>
<mi>j</mi>
</mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mo>=</mo>
<mpadded width="+1.7pt">
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mi>z</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>j</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msup>
</mpadded>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>k</ci>
<ci>j</ci>
</apply>
</apply>
<infinity></infinity>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="latexml">binomial</csymbol>
<ci>k</ci>
<ci>j</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<divide></divide>
<apply>
<minus></minus>
<ci>z</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>z</ci>
</apply>
</apply>
<apply>
<plus></plus>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<divide></divide>
<apply>
<minus></minus>
<ci>z</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>z</ci>
</apply>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<minus></minus>
<apply>
<minus></minus>
<ci>j</ci>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<ci>z</ci>
</apply>
<apply>
<plus></plus>
<ci>j</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \sum_{k=j}^{\infty}{k\choose j}\left({-z\over 1-z}\right)^{k+1}=\left[\left({-%
z\over 1-z}\right)^{-1}-1\right]^{-j-1}=(-z)^{j+1}\,.
  </annotation>
</semantics>
</math>
</p>

<p>For the other arguments with Re(<em>z</em>) 1⁄<sub>2</sub> the result follows by <a href="analytic_continuation" title="wikilink">analytic continuation</a>. This procedure is equivalent to applying <a href="binomial_transform" title="wikilink">Euler's transformation</a> to the series in <em>z</em> that defines the polylogarithm.</p>
<h2 id="asymptotic-expansions">Asymptotic expansions</h2>

<p>For |<em>z</em>| ≫ 1, the polylogarithm can be expanded into <a href="asymptotic_expansion" title="wikilink">asymptotic series</a> in terms of ln(−<em>z</em>):</p>

<p>
<math display="block" id="Polylogarithm:48">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mpadded width="+1.7pt">
<mfrac>
<mrow>
<mo>±</mo>
<mrow>
<mi>i</mi>
<mi>π</mi>
</mrow>
</mrow>
<mrow>
<mi mathvariant="normal">Γ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>s</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
</mpadded>
<msup>
<mrow>
<mo stretchy="false">[</mo>
<mrow>
<mrow>
<mi>ln</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mi>z</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>±</mo>
<mrow>
<mi>i</mi>
<mi>π</mi>
</mrow>
</mrow>
<mo stretchy="false">]</mo>
</mrow>
<mrow>
<mi>s</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
</mrow>
<mo>-</mo>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>k</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mi mathvariant="normal">∞</mi>
</munderover>
<mrow>
<mpadded width="+1.7pt">
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi>k</mi>
</msup>
</mpadded>
<mpadded width="+1.7pt">
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>2</mn>
<mi>π</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mn>2</mn>
<mi>k</mi>
</mrow>
</msup>
</mpadded>
<mpadded width="+1.7pt">
<mfrac>
<msub>
<mi>B</mi>
<mrow>
<mn>2</mn>
<mi>k</mi>
</mrow>
</msub>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>2</mn>
<mi>k</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo lspace="0pt" rspace="3.5pt">!</mo>
</mrow>
</mfrac>
</mpadded>
<mpadded width="+3.3pt">
<mfrac>
<msup>
<mrow>
<mo stretchy="false">[</mo>
<mrow>
<mrow>
<mi>ln</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mi>z</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>±</mo>
<mrow>
<mi>i</mi>
<mi>π</mi>
</mrow>
</mrow>
<mo stretchy="false">]</mo>
</mrow>
<mrow>
<mi>s</mi>
<mo>-</mo>
<mrow>
<mn>2</mn>
<mi>k</mi>
</mrow>
</mrow>
</msup>
<mrow>
<mi mathvariant="normal">Γ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<mi>s</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
<mo>-</mo>
<mrow>
<mn>2</mn>
<mi>k</mi>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
</mpadded>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<ci>z</ci>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<csymbol cd="latexml">plus-or-minus</csymbol>
<apply>
<times></times>
<ci>i</ci>
<ci>π</ci>
</apply>
</apply>
<apply>
<times></times>
<ci>normal-Γ</ci>
<ci>s</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<apply>
<csymbol cd="latexml">plus-or-minus</csymbol>
<apply>
<ln></ln>
<apply>
<minus></minus>
<ci>z</ci>
</apply>
</apply>
<apply>
<times></times>
<ci>i</ci>
<ci>π</ci>
</apply>
</apply>
</apply>
<apply>
<minus></minus>
<ci>s</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>k</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<infinity></infinity>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>π</ci>
</apply>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>k</ci>
</apply>
</apply>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>B</ci>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>k</ci>
</apply>
</apply>
<apply>
<factorial></factorial>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>k</ci>
</apply>
</apply>
</apply>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<apply>
<csymbol cd="latexml">plus-or-minus</csymbol>
<apply>
<ln></ln>
<apply>
<minus></minus>
<ci>z</ci>
</apply>
</apply>
<apply>
<times></times>
<ci>i</ci>
<ci>π</ci>
</apply>
</apply>
</apply>
<apply>
<minus></minus>
<ci>s</ci>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>k</ci>
</apply>
</apply>
</apply>
<apply>
<times></times>
<ci>normal-Γ</ci>
<apply>
<minus></minus>
<apply>
<plus></plus>
<ci>s</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>k</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{s}(z)={\pm i\pi\over\Gamma(s)}\,[\ln(-z)\pm i\pi]^{s-1}-%
\sum_{k=0}^{\infty}(-1)^{k}\,(2\pi)^{2k}\,{B_{2k}\over(2k)!}\,{[\ln(-z)\pm i%
\pi]^{s-2k}\over\Gamma(s+1-2k)}~{},
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Polylogarithm:49">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>k</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mi mathvariant="normal">∞</mi>
</munderover>
<mrow>
<mpadded width="+1.7pt">
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mi>k</mi>
</msup>
</mpadded>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<msup>
<mn>2</mn>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mrow>
<mn>2</mn>
<mi>k</mi>
</mrow>
</mrow>
</msup>
</mrow>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
<mpadded width="+1.7pt">
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>2</mn>
<mi>π</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mn>2</mn>
<mi>k</mi>
</mrow>
</msup>
</mpadded>
<mpadded width="+1.7pt">
<mfrac>
<msub>
<mi>B</mi>
<mrow>
<mn>2</mn>
<mi>k</mi>
</mrow>
</msub>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>2</mn>
<mi>k</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo lspace="0pt" rspace="3.5pt">!</mo>
</mrow>
</mfrac>
</mpadded>
<mpadded width="+3.3pt">
<mfrac>
<msup>
<mrow>
<mo stretchy="false">[</mo>
<mrow>
<mi>ln</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mi>z</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">]</mo>
</mrow>
<mrow>
<mi>s</mi>
<mo>-</mo>
<mrow>
<mn>2</mn>
<mi>k</mi>
</mrow>
</mrow>
</msup>
<mrow>
<mi mathvariant="normal">Γ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<mi>s</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
<mo>-</mo>
<mrow>
<mn>2</mn>
<mi>k</mi>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
</mpadded>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<ci>z</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>k</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<infinity></infinity>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
<ci>k</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>k</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>π</ci>
</apply>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>k</ci>
</apply>
</apply>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>B</ci>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>k</ci>
</apply>
</apply>
<apply>
<factorial></factorial>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>k</ci>
</apply>
</apply>
</apply>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="latexml">delimited-[]</csymbol>
<apply>
<ln></ln>
<apply>
<minus></minus>
<ci>z</ci>
</apply>
</apply>
</apply>
<apply>
<minus></minus>
<ci>s</ci>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>k</ci>
</apply>
</apply>
</apply>
<apply>
<times></times>
<ci>normal-Γ</ci>
<apply>
<minus></minus>
<apply>
<plus></plus>
<ci>s</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>k</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{s}(z)=\sum_{k=0}^{\infty}(-1)^{k}\,(1-2^{1-2k})\,(2\pi)^{2k%
}\,{B_{2k}\over(2k)!}\,{[\ln(-z)]^{s-2k}\over\Gamma(s+1-2k)}~{},
  </annotation>
</semantics>
</math>
</p>

<p>where <em>B</em><sub>2<em>k</em></sub> are the <a href="Bernoulli_numbers" title="wikilink">Bernoulli numbers</a>. Both versions hold for all <em>s</em> and for any arg(<em>z</em>). As usual, the summation should be terminated when the terms start growing in magnitude. For negative integer <em>s</em>, the expansions vanish entirely; for non-negative integer <em>s</em>, they break off after a finite number of terms.  describes a method for obtaining these series from the Bose–Einstein integral representation (note that his equation 11.2 for Li<sub><em>s</em></sub>(<em>e</em><sup><em>µ</em></sup>) requires −2<em>π</em>  \lim_{|z|\rightarrow 0} \operatorname{Li}_s(z) = z </p>

<p>
<math display="block" id="Polylogarithm:50">
<semantics>
<mrow>
<munder>
<mo movablelimits="false">lim</mo>
<mrow>
<mrow>
<mo stretchy="false">|</mo>
<mi>μ</mi>
<mo stretchy="false">|</mo>
</mrow>
<mo>→</mo>
<mn>0</mn>
</mrow>
</munder>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>e</mi>
<mi>μ</mi>
</msup>
<mo stretchy="false">)</mo>
</mrow>
<mo>=</mo>
<mi mathvariant="normal">Γ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mpadded width="-1.7pt">
<mn>1</mn>
</mpadded>
<mo rspace="0.8pt">-</mo>
<mi>s</mi>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mo>-</mo>
<mi>μ</mi>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>s</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>Re</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>s</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>&lt;</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<limit></limit>
<apply>
<ci>normal-→</ci>
<apply>
<abs></abs>
<ci>μ</ci>
</apply>
<cn type="integer">0</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<ci>μ</ci>
</apply>
<ci>normal-)</ci>
</cerror>
<eq></eq>
<csymbol cd="unknown">Γ</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<cn type="integer">1</cn>
<minus></minus>
<csymbol cd="unknown">s</csymbol>
<ci>normal-)</ci>
</cerror>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<minus></minus>
<csymbol cd="unknown">μ</csymbol>
<ci>normal-)</ci>
</cerror>
<apply>
<minus></minus>
<ci>s</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>italic-</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">Re</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">s</csymbol>
<ci>normal-)</ci>
</cerror>
<lt></lt>
<cn type="integer">1</cn>
<ci>normal-)</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lim_{|\mu|\rightarrow 0}\operatorname{Li}_{s}(e^{\mu})=\Gamma(1\!-\!s)\,(-\mu%
)^{s-1}\qquad(\mathrm{Re}(s)&lt;1)
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Polylogarithm:51">
<semantics>
<mrow>
<munder>
<mo movablelimits="false">lim</mo>
<mrow>
<mrow>
<mi>Re</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>μ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>→</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</munder>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mo>-</mo>
<msup>
<mi>e</mi>
<mi>μ</mi>
</msup>
<mo stretchy="false">)</mo>
</mrow>
<mo>=</mo>
<mo>-</mo>
<mfrac>
<msup>
<mi>μ</mi>
<mi>s</mi>
</msup>
<mrow>
<mi mathvariant="normal">Γ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>s</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
<mrow>
<mo stretchy="false">(</mo>
<mi>s</mi>
<mo>≠</mo>
<mo>-</mo>
<mn>1</mn>
<mo>,</mo>
<mo>-</mo>
<mn>2</mn>
<mo>,</mo>
<mo>-</mo>
<mn>3</mn>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<limit></limit>
<apply>
<ci>normal-→</ci>
<apply>
<times></times>
<ci>Re</ci>
<ci>μ</ci>
</apply>
<infinity></infinity>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<minus></minus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<ci>μ</ci>
</apply>
<ci>normal-)</ci>
</cerror>
<eq></eq>
<minus></minus>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>μ</ci>
<ci>s</ci>
</apply>
<apply>
<times></times>
<ci>normal-Γ</ci>
<apply>
<plus></plus>
<ci>s</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<ci>italic-</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">s</csymbol>
<neq></neq>
<minus></minus>
<cn type="integer">1</cn>
<ci>normal-,</ci>
<minus></minus>
<cn type="integer">2</cn>
<ci>normal-,</ci>
<minus></minus>
<cn type="integer">3</cn>
<ci>normal-,</ci>
<ci>normal-…</ci>
<ci>normal-)</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lim_{\mathrm{Re}(\mu)\rightarrow\infty}\operatorname{Li}_{s}(-e^{\mu})=-{\mu^%
{s}\over\Gamma(s+1)}\qquad(s\neq-1,-2,-3,\ldots)
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Polylogarithm:52">
<semantics>
<mrow>
<munder>
<mo movablelimits="false">lim</mo>
<mrow>
<mrow>
<mi>Re</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>μ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>→</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</munder>
<msub>
<mo>Li</mo>
<mrow>
<mo>-</mo>
<mi>n</mi>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>e</mi>
<mi>μ</mi>
</msup>
<mo stretchy="false">)</mo>
</mrow>
<mo>=</mo>
<mo>-</mo>
<mpadded width="+1.7pt">
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mo>-</mo>
<mn>1</mn>
<mo stretchy="false">)</mo>
</mrow>
<mi>n</mi>
</msup>
</mpadded>
<msup>
<mi>e</mi>
<mrow>
<mo>-</mo>
<mi>μ</mi>
</mrow>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>n</mi>
<mo>=</mo>
<mn>1</mn>
<mo>,</mo>
<mn>2</mn>
<mo>,</mo>
<mn>3</mn>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<limit></limit>
<apply>
<ci>normal-→</ci>
<apply>
<times></times>
<ci>Re</ci>
<ci>μ</ci>
</apply>
<infinity></infinity>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<apply>
<minus></minus>
<ci>n</ci>
</apply>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<ci>μ</ci>
</apply>
<ci>normal-)</ci>
</cerror>
<eq></eq>
<minus></minus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<minus></minus>
<cn type="integer">1</cn>
<ci>normal-)</ci>
</cerror>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<apply>
<minus></minus>
<ci>μ</ci>
</apply>
</apply>
<ci>italic-</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">n</csymbol>
<eq></eq>
<cn type="integer">1</cn>
<ci>normal-,</ci>
<cn type="integer">2</cn>
<ci>normal-,</ci>
<cn type="integer">3</cn>
<ci>normal-,</ci>
<ci>normal-…</ci>
<ci>normal-)</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lim_{\mathrm{Re}(\mu)\rightarrow\infty}\operatorname{Li}_{-n}(e^{\mu})=-(-1)^%
{n}\,e^{-\mu}\qquad(n=1,2,3,\ldots)
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Polylogarithm:53">
<semantics>
<mrow>
<mrow>
<munder>
<mo movablelimits="false">lim</mo>
<mrow>
<mrow>
<mi>Re</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>s</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>→</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</munder>
<mrow>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>=</mo>
<mi>z</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<limit></limit>
<apply>
<ci>normal-→</ci>
<apply>
<times></times>
<ci>Re</ci>
<ci>s</ci>
</apply>
<infinity></infinity>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<ci>z</ci>
</apply>
</apply>
<ci>z</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lim_{\mathrm{Re}(s)\rightarrow\infty}\operatorname{Li}_{s}(z)=z
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Polylogarithm:54">
<semantics>
<mrow>
<munder>
<mo movablelimits="false">lim</mo>
<mrow>
<mrow>
<mi>Re</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>s</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>→</mo>
<mrow>
<mo>-</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</mrow>
</munder>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>e</mi>
<mi>μ</mi>
</msup>
<mo stretchy="false">)</mo>
</mrow>
<mo>=</mo>
<mi mathvariant="normal">Γ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mpadded width="-1.7pt">
<mn>1</mn>
</mpadded>
<mo rspace="0.8pt">-</mo>
<mi>s</mi>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mo>-</mo>
<mi>μ</mi>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>s</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mo>-</mo>
<mi>π</mi>
<mo>&lt;</mo>
<mi>Im</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>μ</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>&lt;</mo>
<mi>π</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<limit></limit>
<apply>
<ci>normal-→</ci>
<apply>
<times></times>
<ci>Re</ci>
<ci>s</ci>
</apply>
<apply>
<minus></minus>
<infinity></infinity>
</apply>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<ci>μ</ci>
</apply>
<ci>normal-)</ci>
</cerror>
<eq></eq>
<csymbol cd="unknown">Γ</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<cn type="integer">1</cn>
<minus></minus>
<csymbol cd="unknown">s</csymbol>
<ci>normal-)</ci>
</cerror>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<minus></minus>
<csymbol cd="unknown">μ</csymbol>
<ci>normal-)</ci>
</cerror>
<apply>
<minus></minus>
<ci>s</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>italic-</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<minus></minus>
<csymbol cd="unknown">π</csymbol>
<lt></lt>
<csymbol cd="unknown">Im</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">μ</csymbol>
<ci>normal-)</ci>
</cerror>
<lt></lt>
<csymbol cd="unknown">π</csymbol>
<ci>normal-)</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lim_{\mathrm{Re}(s)\rightarrow-\infty}\operatorname{Li}_{s}(e^{\mu})=\Gamma(1%
\!-\!s)\,(-\mu)^{s-1}\qquad(-\pi&lt;\mathrm{Im}(\mu)&lt;\pi)
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Polylogarithm:55">
<semantics>
<mrow>
<munder>
<mo movablelimits="false">lim</mo>
<mrow>
<mrow>
<mi>Re</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>s</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>→</mo>
<mrow>
<mo>-</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</mrow>
</munder>
<msub>
<mo>Li</mo>
<mi>s</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mo>-</mo>
<msup>
<mi>e</mi>
<mi>μ</mi>
</msup>
<mo stretchy="false">)</mo>
</mrow>
<mo>=</mo>
<mi mathvariant="normal">Γ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mpadded width="-1.7pt">
<mn>1</mn>
</mpadded>
<mo rspace="0.8pt">-</mo>
<mi>s</mi>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo>[</mo>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mo>-</mo>
<mi>μ</mi>
<mo>-</mo>
<mi>i</mi>
<mi>π</mi>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>s</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mo>+</mo>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mo>-</mo>
<mi>μ</mi>
<mo>+</mo>
<mi>i</mi>
<mi>π</mi>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>s</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mo>]</mo>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mi>Im</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>μ</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>=</mo>
<mn>0</mn>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<limit></limit>
<apply>
<ci>normal-→</ci>
<apply>
<times></times>
<ci>Re</ci>
<ci>s</ci>
</apply>
<apply>
<minus></minus>
<infinity></infinity>
</apply>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<ci>s</ci>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<minus></minus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>e</ci>
<ci>μ</ci>
</apply>
<ci>normal-)</ci>
</cerror>
<eq></eq>
<csymbol cd="unknown">Γ</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<cn type="integer">1</cn>
<minus></minus>
<csymbol cd="unknown">s</csymbol>
<ci>normal-)</ci>
</cerror>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-[</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<minus></minus>
<csymbol cd="unknown">μ</csymbol>
<minus></minus>
<csymbol cd="unknown">i</csymbol>
<csymbol cd="unknown">π</csymbol>
<ci>normal-)</ci>
</cerror>
<apply>
<minus></minus>
<ci>s</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<minus></minus>
<csymbol cd="unknown">μ</csymbol>
<plus></plus>
<csymbol cd="unknown">i</csymbol>
<csymbol cd="unknown">π</csymbol>
<ci>normal-)</ci>
</cerror>
<apply>
<minus></minus>
<ci>s</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>normal-]</ci>
</cerror>
<ci>italic-</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">Im</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">μ</csymbol>
<ci>normal-)</ci>
</cerror>
<eq></eq>
<cn type="integer">0</cn>
<ci>normal-)</ci>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lim_{\mathrm{Re}(s)\rightarrow-\infty}\operatorname{Li}_{s}(-e^{\mu})=\Gamma(%
1\!-\!s)\left[(-\mu-i\pi)^{s-1}+(-\mu+i\pi)^{s-1}\right]\qquad(\mathrm{Im}(\mu%
)=0)
  </annotation>
</semantics>
</math>
</p>

<p>Note that Wood's first limit for Re(<em>µ</em>) → ∞ has been corrected in accordance with his equation 11.3. The limit for Re(<em>s</em>) → −∞ follows from the general relation of the polylogarithm with the <a href="Hurwitz_zeta_function" title="wikilink">Hurwitz zeta function</a> (<a href="#Relationship_to_other_functions" title="wikilink">see above</a>).</p>
<h2 id="dilogarithm">Dilogarithm</h2>

<p>The dilogarithm is just the polylogarithm of order <em>s</em> = 2. An alternate integral expression of the dilogarithm for arbitrary complex argument <em>z</em> is :</p>

<p>
<math display="block" id="Polylogarithm:56">
<semantics>
<mrow>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">∫</mo>
<mn>0</mn>
<mi>z</mi>
</msubsup>
<mrow>
<mpadded width="+1.7pt">
<mfrac>
<mrow>
<mi>ln</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>t</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mi>t</mi>
</mfrac>
</mpadded>
<mi mathvariant="normal">d</mi>
<mi>t</mi>
</mrow>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">∫</mo>
<mn>0</mn>
<mn>1</mn>
</msubsup>
<mrow>
<mpadded width="+1.7pt">
<mfrac>
<mrow>
<mi>ln</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mrow>
<mi>z</mi>
<mi>t</mi>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mi>t</mi>
</mfrac>
</mpadded>
<mi mathvariant="normal">d</mi>
<mi>t</mi>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">2</cn>
</apply>
<ci>z</ci>
</apply>
<apply>
<minus></minus>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<int></int>
<cn type="integer">0</cn>
</apply>
<ci>z</ci>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<ln></ln>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>t</ci>
</apply>
</apply>
<ci>t</ci>
</apply>
<ci>normal-d</ci>
<ci>t</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<minus></minus>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<int></int>
<cn type="integer">0</cn>
</apply>
<cn type="integer">1</cn>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<ln></ln>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<apply>
<times></times>
<ci>z</ci>
<ci>t</ci>
</apply>
</apply>
</apply>
<ci>t</ci>
</apply>
<ci>normal-d</ci>
<ci>t</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{2}(z)=-\int_{0}^{z}{\ln(1-t)\over t}\,\mathrm{d}t=-\int_{0}%
^{1}{\ln(1-zt)\over t}\,\mathrm{d}t.
  </annotation>
</semantics>
</math>
</p>

<p>A source of confusion is that some <a href="computer_algebra_system" title="wikilink">computer algebra systems</a> define the dilogarithm as dilog(<em>z</em>) = Li<sub>2</sub>(1−<em>z</em>).</p>

<p>In the case of real <em>z</em> ≥ 1 the first integral expression for the dilogarithm can be written as</p>

<p>
<math display="block" id="Polylogarithm:57">
<semantics>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mfrac>
<msup>
<mi>π</mi>
<mn>2</mn>
</msup>
<mn>6</mn>
</mfrac>
<mo>-</mo>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">∫</mo>
<mn>1</mn>
<mi>z</mi>
</msubsup>
<mrow>
<mpadded width="+1.7pt">
<mfrac>
<mrow>
<mi>ln</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>t</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mi>t</mi>
</mfrac>
</mpadded>
<mi mathvariant="normal">d</mi>
<mi>t</mi>
</mrow>
</mrow>
<mo>-</mo>
<mrow>
<mi>i</mi>
<mi>π</mi>
<mrow>
<mi>ln</mi>
<mi>z</mi>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">2</cn>
</apply>
<ci>z</ci>
</apply>
<apply>
<minus></minus>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>π</ci>
<cn type="integer">2</cn>
</apply>
<cn type="integer">6</cn>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<int></int>
<cn type="integer">1</cn>
</apply>
<ci>z</ci>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<ln></ln>
<apply>
<minus></minus>
<ci>t</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>t</ci>
</apply>
<ci>normal-d</ci>
<ci>t</ci>
</apply>
</apply>
<apply>
<times></times>
<ci>i</ci>
<ci>π</ci>
<apply>
<ln></ln>
<ci>z</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{2}(z)=\frac{\pi^{2}}{6}-\int_{1}^{z}{\ln(t-1)\over t}\,%
\mathrm{d}t-i\pi\ln z
  </annotation>
</semantics>
</math>
</p>

<p>from which expanding ln(<em>t</em>−1) and integrating term by term we obtain</p>

<p>
<math display="block" id="Polylogarithm:58">
<semantics>
<mrow>
<msub>
<mo>Li</mo>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>=</mo>
<mfrac>
<msup>
<mi>π</mi>
<mn>2</mn>
</msup>
<mn>3</mn>
</mfrac>
<mo>-</mo>
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>ln</mi>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mn>2</mn>
</msup>
<mo>-</mo>
<munderover>
<mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
<mrow>
<mi>k</mi>
<mo>=</mo>
<mn>1</mn>
</mrow>
<mi mathvariant="normal">∞</mi>
</munderover>
<mfrac>
<mn>1</mn>
<mrow>
<msup>
<mi>k</mi>
<mn>2</mn>
</msup>
<msup>
<mi>z</mi>
<mi>k</mi>
</msup>
</mrow>
</mfrac>
<mo>-</mo>
<mi>i</mi>
<mi>π</mi>
<mi>ln</mi>
<mi>z</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo>≥</mo>
<mn>1</mn>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">2</cn>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">z</csymbol>
<ci>normal-)</ci>
</cerror>
<eq></eq>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>π</ci>
<cn type="integer">2</cn>
</apply>
<cn type="integer">3</cn>
</apply>
<minus></minus>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<ln></ln>
<csymbol cd="unknown">z</csymbol>
<ci>normal-)</ci>
</cerror>
<cn type="integer">2</cn>
</apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<sum></sum>
<apply>
<eq></eq>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<infinity></infinity>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>k</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>z</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
<minus></minus>
<csymbol cd="unknown">i</csymbol>
<csymbol cd="unknown">π</csymbol>
<ln></ln>
<csymbol cd="unknown">z</csymbol>
<ci>italic-</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">z</csymbol>
<geq></geq>
<cn type="integer">1</cn>
<ci>normal-)</ci>
</cerror>
<ci>normal-.</ci>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{2}(z)=\frac{\pi^{2}}{3}-\frac{1}{2}(\ln z)^{2}-\sum_{k=1}^{%
\infty}{1\over k^{2}z^{k}}-i\pi\ln z\qquad(z\geq 1)\,.
  </annotation>
</semantics>
</math>
</p>

<p>The <strong><a href="Niels_Henrik_Abel" title="wikilink">Abel</a> identity</strong> for the dilogarithm is given by </p>

<p>
<math display="block" id="Polylogarithm:59">
<semantics>
<mrow>
<mrow>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mn>2</mn>
</msub>
<mrow>
<mo>(</mo>
<mfrac>
<mi>x</mi>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>y</mi>
</mrow>
</mfrac>
<mo>)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<msub>
<mo>Li</mo>
<mn>2</mn>
</msub>
<mrow>
<mo>(</mo>
<mfrac>
<mi>y</mi>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>x</mi>
</mrow>
</mfrac>
<mo>)</mo>
</mrow>
</mrow>
</mrow>
<mo>-</mo>
<mrow>
<msub>
<mo>Li</mo>
<mn>2</mn>
</msub>
<mrow>
<mo>(</mo>
<mfrac>
<mrow>
<mi>x</mi>
<mi>y</mi>
</mrow>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>x</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>y</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
<mo>)</mo>
</mrow>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<msub>
<mo>Li</mo>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<mrow>
<mi>ln</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>x</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mrow>
<mi>ln</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>y</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<minus></minus>
<apply>
<plus></plus>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<divide></divide>
<ci>x</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>y</ci>
</apply>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<divide></divide>
<ci>y</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>x</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<divide></divide>
<apply>
<times></times>
<ci>x</ci>
<ci>y</ci>
</apply>
<apply>
<times></times>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>x</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>y</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
<apply>
<plus></plus>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">2</cn>
</apply>
<ci>x</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">2</cn>
</apply>
<ci>y</ci>
</apply>
<apply>
<times></times>
<apply>
<ln></ln>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>x</ci>
</apply>
</apply>
<apply>
<ln></ln>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>y</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{2}\left(\frac{x}{1-y}\right)+\operatorname{Li}_{2}\left(%
\frac{y}{1-x}\right)-\operatorname{Li}_{2}\left(\frac{xy}{(1-x)(1-y)}\right)=%
\operatorname{Li}_{2}(x)+\operatorname{Li}_{2}(y)+\ln(1-x)\ln(1-y)
  </annotation>
</semantics>
</math>
</p>

<p>
<math display="block" id="Polylogarithm:60">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mrow>
<mi>Re</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>≤</mo>
<mrow>
<mpadded width="+2.8pt">
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mstyle>
</mpadded>
<mo rspace="5.3pt">∧</mo>
<mrow>
<mi>Re</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>≤</mo>
<mrow>
<mpadded width="+2.8pt">
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mstyle>
</mpadded>
<mo rspace="5.3pt">∨</mo>
<mrow>
<mi>Im</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>&gt;</mo>
<mrow>
<mpadded width="+2.8pt">
<mn>0</mn>
</mpadded>
<mo rspace="5.3pt">∧</mo>
<mrow>
<mi>Im</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>&gt;</mo>
<mrow>
<mpadded width="+2.8pt">
<mn>0</mn>
</mpadded>
<mo rspace="5.3pt">∨</mo>
<mrow>
<mi>Im</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>&lt;</mo>
<mrow>
<mpadded width="+2.8pt">
<mn>0</mn>
</mpadded>
<mo rspace="5.3pt">∧</mo>
<mrow>
<mi>Im</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>y</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>&lt;</mo>
<mrow>
<mpadded width="+2.8pt">
<mn>0</mn>
</mpadded>
<mo rspace="5.3pt">∨</mo>
<mi mathvariant="normal">…</mi>
</mrow>
</mrow>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<leq></leq>
<apply>
<times></times>
<ci>Re</ci>
<ci>x</ci>
</apply>
<apply>
<and></and>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
<apply>
<times></times>
<ci>Re</ci>
<ci>y</ci>
</apply>
</apply>
</apply>
<apply>
<leq></leq>
<share href="#.cmml">
</share>
<apply>
<or></or>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
<apply>
<times></times>
<ci>Im</ci>
<ci>x</ci>
</apply>
</apply>
</apply>
<apply>
<gt></gt>
<share href="#.cmml">
</share>
<apply>
<and></and>
<cn type="integer">0</cn>
<apply>
<times></times>
<ci>Im</ci>
<ci>y</ci>
</apply>
</apply>
</apply>
<apply>
<gt></gt>
<share href="#.cmml">
</share>
<apply>
<or></or>
<cn type="integer">0</cn>
<apply>
<times></times>
<ci>Im</ci>
<ci>x</ci>
</apply>
</apply>
</apply>
<apply>
<lt></lt>
<share href="#.cmml">
</share>
<apply>
<and></and>
<cn type="integer">0</cn>
<apply>
<times></times>
<ci>Im</ci>
<ci>y</ci>
</apply>
</apply>
</apply>
<apply>
<lt></lt>
<share href="#.cmml">
</share>
<apply>
<or></or>
<cn type="integer">0</cn>
<ci>normal-…</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (\mathrm{Re}(x)\leq\tfrac{1}{2}\;\wedge\;\mathrm{Re}(y)\leq\tfrac{1}{2}\;\vee%
\;\mathrm{Im}(x)&gt;0\;\wedge\;\mathrm{Im}(y)&gt;0\;\vee\;\mathrm{Im}(x)&lt;0\;\wedge\;%
\mathrm{Im}(y)&lt;0\;\vee\;\ldots)\,.
  </annotation>
</semantics>
</math>
</p>

<p>This is immediately seen to hold for either <em>x</em> = 0 or <em>y</em> = 0, and for general arguments is then easily verified by differentiation ∂/∂<em>x</em> ∂/∂<em>y</em>. For <em>y</em> = 1−<em>x</em> the identity reduces to <a href="Leonhard_Euler" title="wikilink">Euler</a>'s <strong>reflection formula</strong></p>

<p>
<math display="block" id="Polylogarithm:61">
<semantics>
<mrow>
<mrow>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mn>2</mn>
</msub>
<mrow>
<mo>(</mo>
<mi>x</mi>
<mo>)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<msub>
<mo>Li</mo>
<mn>2</mn>
</msub>
<mrow>
<mo>(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>x</mi>
</mrow>
<mo>)</mo>
</mrow>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mfrac>
<mn>1</mn>
<mn>6</mn>
</mfrac>
<msup>
<mi>π</mi>
<mn>2</mn>
</msup>
</mrow>
<mo>-</mo>
<mrow>
<mrow>
<mi>ln</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mrow>
<mi>ln</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>x</mi>
</mrow>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<plus></plus>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">2</cn>
</apply>
<ci>x</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>x</ci>
</apply>
</apply>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">6</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>π</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<times></times>
<apply>
<ln></ln>
<ci>x</ci>
</apply>
<apply>
<ln></ln>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>x</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{2}\left(x\right)+\operatorname{Li}_{2}\left(1-x\right)=%
\frac{1}{6}\pi^{2}-\ln(x)\ln(1-x)\,,
  </annotation>
</semantics>
</math>

 where Li<sub>2</sub>(1) = ζ(2) = <sup>1</sup>⁄<sub>6</sub> <em>π</em><sup>2</sup> has been used and <em>x</em> may take any complex value.</p>

<p>In terms of the new variables <em>u</em> = <em>x</em>/(1−<em>y</em>), <em>v</em> = <em>y</em>/(1−<em>x</em>) the Abel identity reads</p>

<p>
<math display="block" id="Polylogarithm:62">
<semantics>
<mrow>
<mrow>
<mrow>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>u</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<msub>
<mo>Li</mo>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>v</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>-</mo>
<mrow>
<msub>
<mo>Li</mo>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>u</mi>
<mi>v</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mn>2</mn>
</msub>
<mrow>
<mo>(</mo>
<mfrac>
<mrow>
<mi>u</mi>
<mo>-</mo>
<mrow>
<mi>u</mi>
<mi>v</mi>
</mrow>
</mrow>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mrow>
<mi>u</mi>
<mi>v</mi>
</mrow>
</mrow>
</mfrac>
<mo>)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<msub>
<mo>Li</mo>
<mn>2</mn>
</msub>
<mrow>
<mo>(</mo>
<mfrac>
<mrow>
<mi>v</mi>
<mo>-</mo>
<mrow>
<mi>u</mi>
<mi>v</mi>
</mrow>
</mrow>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mrow>
<mi>u</mi>
<mi>v</mi>
</mrow>
</mrow>
</mfrac>
<mo>)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<mrow>
<mi>ln</mi>
<mrow>
<mo>(</mo>
<mfrac>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>u</mi>
</mrow>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mrow>
<mi>u</mi>
<mi>v</mi>
</mrow>
</mrow>
</mfrac>
<mo>)</mo>
</mrow>
</mrow>
<mrow>
<mi>ln</mi>
<mrow>
<mo>(</mo>
<mfrac>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>v</mi>
</mrow>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mrow>
<mi>u</mi>
<mi>v</mi>
</mrow>
</mrow>
</mfrac>
<mo>)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<minus></minus>
<apply>
<plus></plus>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">2</cn>
</apply>
<ci>u</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">2</cn>
</apply>
<ci>v</ci>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<times></times>
<ci>u</ci>
<ci>v</ci>
</apply>
</apply>
</apply>
<apply>
<plus></plus>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<divide></divide>
<apply>
<minus></minus>
<ci>u</ci>
<apply>
<times></times>
<ci>u</ci>
<ci>v</ci>
</apply>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<apply>
<times></times>
<ci>u</ci>
<ci>v</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<divide></divide>
<apply>
<minus></minus>
<ci>v</ci>
<apply>
<times></times>
<ci>u</ci>
<ci>v</ci>
</apply>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<apply>
<times></times>
<ci>u</ci>
<ci>v</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<times></times>
<apply>
<ln></ln>
<apply>
<divide></divide>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>u</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<apply>
<times></times>
<ci>u</ci>
<ci>v</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<ln></ln>
<apply>
<divide></divide>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>v</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<apply>
<times></times>
<ci>u</ci>
<ci>v</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{2}(u)+\operatorname{Li}_{2}(v)-\operatorname{Li}_{2}(uv)=%
\operatorname{Li}_{2}\left(\frac{u-uv}{1-uv}\right)+\operatorname{Li}_{2}\left%
(\frac{v-uv}{1-uv}\right)+\ln\left(\frac{1-u}{1-uv}\right)\ln\left(\frac{1-v}{%
1-uv}\right),
  </annotation>
</semantics>
</math>
</p>

<p>which corresponds to the <strong>pentagon identity</strong> given in .</p>

<p>From the Abel identity for <em>x</em> = <em>y</em> = 1−<em>z</em> and the square relationship we have <strong><a href="John_Landen" title="wikilink">Landen</a>'s identity</strong></p>

<p>
<math display="block" id="Polylogarithm:63">
<semantics>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mn>1</mn>
<mo>-</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>+</mo>
<msub>
<mo>Li</mo>
<mn>2</mn>
</msub>
<mrow>
<mo>(</mo>
<mn>1</mn>
<mo>-</mo>
<mfrac>
<mn>1</mn>
<mi>z</mi>
</mfrac>
<mo>)</mo>
</mrow>
<mo>=</mo>
<mo>-</mo>
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>ln</mi>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mn>2</mn>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo rspace="5.8pt">∉</mo>
<mo stretchy="false">]</mo>
</mrow>
<mo>-</mo>
<mi mathvariant="normal">∞</mi>
<mo>;</mo>
<mn>0</mn>
<mo stretchy="false">]</mo>
</mrow>
<mo rspace="4.2pt" stretchy="false">)</mo>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">2</cn>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<cn type="integer">1</cn>
<minus></minus>
<csymbol cd="unknown">z</csymbol>
<ci>normal-)</ci>
</cerror>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">2</cn>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<cn type="integer">1</cn>
<minus></minus>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<ci>z</ci>
</apply>
<ci>normal-)</ci>
</cerror>
<eq></eq>
<minus></minus>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<ln></ln>
<csymbol cd="unknown">z</csymbol>
<ci>normal-)</ci>
</cerror>
<cn type="integer">2</cn>
</apply>
<ci>italic-</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">z</csymbol>
<notin></notin>
<ci>normal-]</ci>
</cerror>
<minus></minus>
<infinity></infinity>
<ci>normal-;</ci>
<cn type="integer">0</cn>
<ci>normal-]</ci>
</cerror>
<ci>normal-)</ci>
<ci>normal-,</ci>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{2}(1-z)+\operatorname{Li}_{2}\left(1-\frac{1}{z}\right)=-%
\frac{1}{2}(\ln z)^{2}\qquad(z\not\in~{}]-\infty;0])\,,
  </annotation>
</semantics>
</math>
</p>

<p>and applying the reflection formula to each dilogarithm we find the <strong>inversion formula</strong></p>

<p>
<math display="block" id="Polylogarithm:64">
<semantics>
<mrow>
<msub>
<mo>Li</mo>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>+</mo>
<msub>
<mo>Li</mo>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mn>1</mn>
<mo>/</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>=</mo>
<mo>-</mo>
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>6</mn>
</mfrac>
</mstyle>
<msup>
<mi>π</mi>
<mn>2</mn>
</msup>
<mo>-</mo>
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mstyle>
<msup>
<mrow>
<mo stretchy="false">[</mo>
<mi>ln</mi>
<mrow>
<mo stretchy="false">(</mo>
<mo>-</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo stretchy="false">]</mo>
</mrow>
<mn>2</mn>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo>∉</mo>
<mrow>
<mo stretchy="false">[</mo>
<mn>0</mn>
<mo>;</mo>
<mn>1</mn>
<mrow>
<mo stretchy="false">[</mo>
<mo rspace="4.2pt" stretchy="false">)</mo>
</mrow>
<mo>,</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">2</cn>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">z</csymbol>
<ci>normal-)</ci>
</cerror>
<plus></plus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">2</cn>
</apply>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<cn type="integer">1</cn>
<divide></divide>
<csymbol cd="unknown">z</csymbol>
<ci>normal-)</ci>
</cerror>
<eq></eq>
<minus></minus>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">6</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>π</ci>
<cn type="integer">2</cn>
</apply>
<minus></minus>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-[</ci>
<ln></ln>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<minus></minus>
<csymbol cd="unknown">z</csymbol>
<ci>normal-)</ci>
</cerror>
<ci>normal-]</ci>
</cerror>
<cn type="integer">2</cn>
</apply>
<ci>italic-</ci>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">z</csymbol>
<notin></notin>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-[</ci>
<cn type="integer">0</cn>
<ci>normal-;</ci>
<cn type="integer">1</cn>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-[</ci>
<ci>normal-)</ci>
</cerror>
<ci>normal-,</ci>
</cerror>
</cerror>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{2}(z)+\operatorname{Li}_{2}(1/z)=-\tfrac{1}{6}\pi^{2}-%
\tfrac{1}{2}[\ln(-z)]^{2}\qquad(z\not\in[0;1[)\,,
  </annotation>
</semantics>
</math>
</p>

<p>and for real <em>z</em> ≥ 1 also</p>

<p>
<math display="block" id="Polylogarithm:65">
<semantics>
<mrow>
<mrow>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>z</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<msub>
<mo>Li</mo>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>/</mo>
<mi>z</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>3</mn>
</mfrac>
</mstyle>
<msup>
<mi>π</mi>
<mn>2</mn>
</msup>
</mrow>
<mo>-</mo>
<mrow>
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mstyle>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>ln</mi>
<mi>z</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mn>2</mn>
</msup>
</mrow>
<mo>-</mo>
<mrow>
<mi>i</mi>
<mi>π</mi>
<mrow>
<mi>ln</mi>
<mpadded width="+1.7pt">
<mi>z</mi>
</mpadded>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<plus></plus>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">2</cn>
</apply>
<ci>z</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<ci>z</ci>
</apply>
</apply>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">3</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>π</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<ln></ln>
<ci>z</ci>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<times></times>
<ci>i</ci>
<ci>π</ci>
<apply>
<ln></ln>
<ci>z</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{2}(z)+\operatorname{Li}_{2}(1/z)=\tfrac{1}{3}\pi^{2}-\tfrac%
{1}{2}(\ln z)^{2}-i\pi\ln z\,.
  </annotation>
</semantics>
</math>
</p>

<p>Known closed-form evaluations of the dilogarithm at special arguments are collected in the table below. Arguments in the first column are related by reflection <em>x</em> ↔ 1−<em>x</em> or inversion <em>x</em> ↔ <sup>1</sup>⁄<sub><em>x</em></sub> to either <em>x</em> = 0 or <em>x</em> = −1; arguments in the third column are all interrelated by these operations.</p>

<p><strong>Historical note</strong>:  discusses the 17th to 19th century references. The reflection formula was already published by Landen in 1760, prior to its appearance in a 1768 book by Euler ; an equivalent to Abel's identity was already published by <a href="William_Spence_(mathematician)" title="wikilink">Spence</a> in 1809, before Abel wrote his manuscript in 1826 . The designation <em>bilogarithmische Function</em> was introduced by <a href=":sv:Carl_Johan_Hill" title="wikilink">Carl Johan Danielsson Hill</a> (professor in Lund, Sweden) in 1828 .  has remarked that the dilogarithm is the only mathematical function possessing a sense of humor.</p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p><strong>Special values of the dilogarithm</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>
<math display="inline" id="Polylogarithm:66">
<semantics>
<mpadded width="+1.7pt">
<mi>x</mi>
</mpadded>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x\,
  </annotation>
</semantics>
</math>
</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>
<math display="inline" id="Polylogarithm:67">
<semantics>
<mrow>
<mo>-</mo>
<mpadded width="+1.7pt">
<mn>1</mn>
</mpadded>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   -1\,
  </annotation>
</semantics>
</math>
</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>
<math display="inline" id="Polylogarithm:68">
<semantics>
<mpadded width="+1.7pt">
<mn>0</mn>
</mpadded>
<annotation-xml encoding="MathML-Content">
<cn type="integer">0</cn>
</annotation-xml>
<annotation encoding="application/x-tex">
   0\,
  </annotation>
</semantics>
</math>
</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>
<math display="inline" id="Polylogarithm:69">
<semantics>
<mpadded width="+1.7pt">
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
</mpadded>
<annotation-xml encoding="MathML-Content">
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \tfrac{1}{2}\,
  </annotation>
</semantics>
</math>
</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>
<math display="inline" id="Polylogarithm:70">
<semantics>
<mpadded width="+1.7pt">
<mn>1</mn>
</mpadded>
<annotation-xml encoding="MathML-Content">
<cn type="integer">1</cn>
</annotation-xml>
<annotation encoding="application/x-tex">
   1\,
  </annotation>
</semantics>
</math>
</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">

<p>
<math display="inline" id="Polylogarithm:71">
<semantics>
<mpadded width="+1.7pt">
<mn>2</mn>
</mpadded>
<annotation-xml encoding="MathML-Content">
<cn type="integer">2</cn>
</annotation-xml>
<annotation encoding="application/x-tex">
   2\,
  </annotation>
</semantics>
</math>
</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
</tr>
</tbody>
</table>
</dd>
</dl>
<dl>
<dd>Here 

<math display="inline" id="Polylogarithm:72">
<semantics>
<mrow>
<mpadded width="+1.7pt">
<mi>ϕ</mi>
</mpadded>
<mo rspace="4.2pt">=</mo>
<mrow>
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msqrt>
<mn>5</mn>
</msqrt>
<mo>+</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>ϕ</ci>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
<apply>
<plus></plus>
<apply>
<root></root>
<cn type="integer">5</cn>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \scriptstyle\phi\,=\,\tfrac{1}{2}(\sqrt{5}+1)
  </annotation>
</semantics>
</math>


 denotes the <a href="golden_ratio" title="wikilink">golden ratio</a>.
</dd>
</dl>
<h2 id="polylogarithm-ladders">Polylogarithm ladders</h2>

<p><a href="Leonard_Lewin_(mathematician)" title="wikilink">Leonard Lewin</a> discovered a remarkable and broad generalization of a number of classical relationships on the polylogarithm for special values. These are now called <strong>polylogarithm ladders</strong>. Define 

<math display="inline" id="Polylogarithm:73">
<semantics>
<mrow>
<mpadded width="+1.7pt">
<mi>ρ</mi>
</mpadded>
<mo rspace="4.2pt">=</mo>
<mrow>
<mfrac>
<mn>1</mn>
<mn>2</mn>
</mfrac>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msqrt>
<mn>5</mn>
</msqrt>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>ρ</ci>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">2</cn>
</apply>
<apply>
<minus></minus>
<apply>
<root></root>
<cn type="integer">5</cn>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \scriptstyle\rho\,=\,\tfrac{1}{2}(\sqrt{5}-1)
  </annotation>
</semantics>
</math>

 as the reciprocal of the <a href="golden_ratio" title="wikilink">golden ratio</a>. Then two simple examples of dilogarithm ladders are</p>

<p>
<math display="block" id="Polylogarithm:74">
<semantics>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>ρ</mi>
<mn>6</mn>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mrow>
<mrow>
<mn>4</mn>
<mrow>
<msub>
<mo>Li</mo>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>ρ</mi>
<mn>3</mn>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<mn>3</mn>
<mrow>
<msub>
<mo>Li</mo>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msup>
<mi>ρ</mi>
<mn>2</mn>
</msup>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>-</mo>
<mrow>
<mn>6</mn>
<mrow>
<msub>
<mo>Li</mo>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>ρ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mrow>
<mo>+</mo>
<mrow>
<mstyle displaystyle="false">
<mfrac>
<mn>7</mn>
<mn>30</mn>
</mfrac>
</mstyle>
<msup>
<mi>π</mi>
<mn>2</mn>
</msup>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ρ</ci>
<cn type="integer">6</cn>
</apply>
</apply>
<apply>
<plus></plus>
<apply>
<minus></minus>
<apply>
<plus></plus>
<apply>
<times></times>
<cn type="integer">4</cn>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ρ</ci>
<cn type="integer">3</cn>
</apply>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">3</cn>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>ρ</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">6</cn>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">2</cn>
</apply>
<ci>ρ</ci>
</apply>
</apply>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">7</cn>
<cn type="integer">30</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>π</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{2}(\rho^{6})=4\operatorname{Li}_{2}(\rho^{3})+3%
\operatorname{Li}_{2}(\rho^{2})-6\operatorname{Li}_{2}(\rho)+\tfrac{7}{30}\pi^%
{2}
  </annotation>
</semantics>
</math>
</p>

<p>given by  and</p>

<p>
<math display="block" id="Polylogarithm:75">
<semantics>
<mrow>
<mrow>
<msub>
<mo>Li</mo>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>ρ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mrow>
<mstyle displaystyle="false">
<mfrac>
<mn>1</mn>
<mn>10</mn>
</mfrac>
</mstyle>
<msup>
<mi>π</mi>
<mn>2</mn>
</msup>
</mrow>
<mo>-</mo>
<mrow>
<msup>
<mi>ln</mi>
<mn>2</mn>
</msup>
<mi>ρ</mi>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>Li</ci>
<cn type="integer">2</cn>
</apply>
<ci>ρ</ci>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<apply>
<divide></divide>
<cn type="integer">1</cn>
<cn type="integer">10</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>π</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ln></ln>
<cn type="integer">2</cn>
</apply>
<ci>ρ</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \operatorname{Li}_{2}(\rho)=\tfrac{1}{10}\pi^{2}-\ln^{2}\rho
  </annotation>
</semantics>
</math>
</p>

<p>given by <a href="John_Landen" title="wikilink">Landen</a>. Polylogarithm ladders occur naturally and deeply in <a class="uri" href="K-theory" title="wikilink">K-theory</a> and <a href="algebraic_geometry" title="wikilink">algebraic geometry</a>. Polylogarithm ladders provide the basis for the rapid computations of various mathematical constants by means of the <a href="BBP_algorithm" title="wikilink">BBP algorithm</a> .</p>
<h2 id="monodromy">Monodromy</h2>

<p>The polylogarithm has two <a href="branch_point" title="wikilink">branch points</a>; one at <em>z</em> = 1 and another at <em>z</em> = 0. The second branch point, at <em>z</em> = 0, is not visible on the main sheet of the polylogarithm; it becomes visible only when the function is <a href="analytically_continued" title="wikilink">analytically continued</a> to its other sheets. The <a class="uri" href="monodromy" title="wikilink">monodromy</a> group for the polylogarithm consists of the <a class="uri" href="homotopy" title="wikilink">homotopy</a> classes of loops that wind around the two branch points. Denoting these two by <em>m</em><sub>0</sub> and <em>m</em><sub>1</sub>, the monodromy group has the <a href="group_presentation" title="wikilink">group presentation</a></p>

<p>
<math display="block" id="Polylogarithm:76">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">⟨</mo>
<mrow>
<msub>
<mi>m</mi>
<mn>0</mn>
</msub>
<mo>,</mo>
<mpadded width="+1.7pt">
<msub>
<mi>m</mi>
<mn>1</mn>
</msub>
</mpadded>
</mrow>
<mo rspace="4.2pt" stretchy="false">|</mo>
<mrow>
<mrow>
<mi>w</mi>
<mo>=</mo>
<mrow>
<msub>
<mi>m</mi>
<mn>0</mn>
</msub>
<msub>
<mi>m</mi>
<mn>1</mn>
</msub>
<msubsup>
<mi>m</mi>
<mn>0</mn>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msubsup>
<msubsup>
<mi>m</mi>
<mn>1</mn>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msubsup>
</mrow>
</mrow>
<mo rspace="4.2pt">,</mo>
<mrow>
<mrow>
<mi>w</mi>
<msub>
<mi>m</mi>
<mn>1</mn>
</msub>
</mrow>
<mo>=</mo>
<mrow>
<msub>
<mi>m</mi>
<mn>1</mn>
</msub>
<mi>w</mi>
</mrow>
</mrow>
</mrow>
<mo stretchy="false">⟩</mo>
</mrow>
<mo>.</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">inner-product</csymbol>
<list>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>m</ci>
<cn type="integer">0</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>m</ci>
<cn type="integer">1</cn>
</apply>
</list>
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<eq></eq>
<ci>w</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>m</ci>
<cn type="integer">0</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>m</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>m</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<cn type="integer">0</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>m</ci>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<apply>
<eq></eq>
<apply>
<times></times>
<ci>w</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>m</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>m</ci>
<cn type="integer">1</cn>
</apply>
<ci>w</ci>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \langle m_{0},m_{1}\,|\,w=m_{0}m_{1}m^{-1}_{0}m^{-1}_{1},\,wm_{1}=m_{1}w\rangle.
  </annotation>
</semantics>
</math>
</p>

<p>For the special case of the dilogarithm, one also has that <em>wm</em><sub>0</sub> = <em>m</em><sub>0</sub><em>w</em>, and the monodromy group becomes the <a href="Heisenberg_group" title="wikilink">Heisenberg group</a> (identifying <em>m</em><sub>0</sub>, <em>m</em><sub>1</sub> and <em>w</em> with <em>x</em>, <em>y</em>, <em>z</em>) .</p>
<h2 id="references">References</h2>
<ul>
<li>

<p>(this 1826 manuscript was only published posthumously.)</p></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>

<p>(this is a reprint of the McGraw–Hill original of 1953.)</p></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>

<p>(see § 1.2, "The generalized zeta function, Bernoulli polynomials, Euler polynomials, and polylogarithms", p. 23.)</p></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>

<p>(this edition has been reprinted many times, a 1996 paperback has ISBN 0-521-09189-6.)</p></li>
<li></li>
<li></li>
<li>

<p>(also appeared as "The remarkable dilogarithm" in <em>Journal of Mathematical and Physical Sciences</em> <strong>22</strong> (1988), pp. 131–145, and as Chapter I of .)</p></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li></li>
<li><a href="https://launchpad.net/anant">Algorithms in Analytic Number Theory</a> provides an arbitrary-precision, <a href="GNU_Multiple_Precision_Arithmetic_Library" title="wikilink">GMP</a>-based, <a class="uri" href="GPL" title="wikilink">GPL</a>-licensed implementation.</li>
</ul>

<p>"</p>

<p><a href="Category:Special_functions" title="wikilink">Category:Special functions</a> <a href="Category:Zeta_and_L-functions" title="wikilink">Category:Zeta and L-functions</a> <a href="Category:Rational_functions" title="wikilink">Category:Rational functions</a></p>
</body>
</html>
