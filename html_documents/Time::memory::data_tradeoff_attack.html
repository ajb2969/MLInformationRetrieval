<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1101">Time/memory/data tradeoff attack</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Time/memory/data tradeoff attack</h1>
<hr/>

<p>A <strong>time/memory/data tradeoff attack</strong> is a type <a href="cryptanalysis" title="wikilink">cryptographic attack</a> of where an attacker tries to achieve a situation similar to the <a href="space–time_tradeoff" title="wikilink">space–time tradeoff</a> but with one more parameter <em>data:</em> amount of data available to the attacker at real time. An attacker balances or reduces one or two of those parameters in favor of the other one or two. This type of attack is very hard and most of the ciphers and encryption schemes were not designed to resist such type of attack. This attack is a special type of the general cryptanalytic time/memory tradeoff attack.</p>
<h2 id="history">History</h2>

<p><strong>Tradeoff attacks on <a href="Symmetric-key_algorithm" title="wikilink">symmetric cryptosystems</a></strong> dates back to 1980 when <a href="Martin_Hellman" title="wikilink">Hellman</a> suggested a time/memory tradeoff method to break <strong><a href="block_cipher" title="wikilink">block ciphers</a></strong> with 

<math display="inline" id="Time::memory::data_tradeoff_attack:0">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 possible keys in time 

<math display="inline" id="Time::memory::data_tradeoff_attack:1">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 and memory 

<math display="inline" id="Time::memory::data_tradeoff_attack:2">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 related by the tradeoff curve 

<math display="inline" id="Time::memory::data_tradeoff_attack:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <msup>
     <mi>M</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>N</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>M</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>N</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T{M^{2}}={N^{2}}
  </annotation>
 </semantics>
</math>


 where 

<math display="inline" id="Time::memory::data_tradeoff_attack:4">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>T</mi>
   <mo>≤</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>T</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq T\leq N
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Later, Babbage and Golic devised a different tradeoff attack for <strong><a href="stream_cipher" title="wikilink">stream ciphers</a></strong> with a new bound such that 

<math display="inline" id="Time::memory::data_tradeoff_attack:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mi>M</mi>
   </mrow>
   <mo>=</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>M</ci>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   TM=N
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Time::memory::data_tradeoff_attack:6">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>T</mi>
   <mo>≤</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>T</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq T\leq D
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Time::memory::data_tradeoff_attack:7">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 <em>is the output data available to the cryptanalyst at real time</em>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="attack-mechanics">Attack Mechanics</h2>

<p>This attack is a special type of the general cryptanalytic <em>time/memory tradeoff attack</em>. A general <strong><em>time/memory tradeoff attack</em></strong> has two main phases:</p>
<ol>
<li><em>Preprocessing:</em></li>
</ol>
<dl>
<dd><dl>
<dd>During this phase, the attacker explores the structure of the cryptosystem and is allowed to record his findings in large tables. This can take long time.
</dd>
</dl>
</dd>
</dl>
<ol>
<li><em>Realtime:</em></li>
</ol>
<dl>
<dd><dl>
<dd>In this phase, the cryptanalyst is granted real data obtained from a specific unknown key. He tries to use the precomputed table from the <em>preprocessing</em> phase to find the particular in as little time as possible.
</dd>
</dl>
</dd>
</dl>

<p>Any time/memory/data tradeoff attack has the following parameters:</p>

<p>

<math display="block" id="Time::memory::data_tradeoff_attack:8">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 search space size</p>

<p>

<math display="block" id="Time::memory::data_tradeoff_attack:9">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 time required for the <em>preprocessing</em> phase</p>

<p>

<math display="block" id="Time::memory::data_tradeoff_attack:10">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 time required for the <em>realtime</em> phase</p>

<p>

<math display="block" id="Time::memory::data_tradeoff_attack:11">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 amount of memory available to the attacker</p>

<p>

<math display="block" id="Time::memory::data_tradeoff_attack:12">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 amount of realtime data available to the attacker</p>
<h2 id="hellmans-tradeoff-attack-on-block-ciphers"><a href="Martin_Hellman" title="wikilink">Hellman</a>'s tradeoff attack on <a href="block_cipher" title="wikilink">block ciphers</a> <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></h2>

<p>For block ciphers, 

<math display="inline" id="Time::memory::data_tradeoff_attack:13">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>


 is the total number of possible keys and also assume the number of possible plaintexts and ciphertexts to be 

<math display="inline" id="Time::memory::data_tradeoff_attack:14">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

. Also let the given data be a single ciphertext block of a specific plaintext counterpart. If we consider the mapping from the key 

<math display="inline" id="Time::memory::data_tradeoff_attack:15">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 to the ciphertext 

<math display="inline" id="Time::memory::data_tradeoff_attack:16">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 as a random permutation function 

<math display="inline" id="Time::memory::data_tradeoff_attack:17">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 over an 

<math display="inline" id="Time::memory::data_tradeoff_attack:18">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>


 point space, and if this function 

<math display="inline" id="Time::memory::data_tradeoff_attack:19">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is invertible; we need to find the inverse of this function 

<math display="inline" id="Time::memory::data_tradeoff_attack:20">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>y</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {f}^{-1}(y)=x
  </annotation>
 </semantics>
</math>

. Hellman's technique to invert this function:</p>
<dl>
<dd><strong><em>During the preprocessing stage</em></strong>
</dd>
<dd>Try to cover the 

<math display="inline" id="Time::memory::data_tradeoff_attack:21">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 point space by an 

<math display="inline" id="Time::memory::data_tradeoff_attack:22">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>×</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\times t
  </annotation>
 </semantics>
</math>

 rectangular matrix that is constructed by iterating the function 

<math display="inline" id="Time::memory::data_tradeoff_attack:23">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>


 on 

<math display="inline" id="Time::memory::data_tradeoff_attack:24">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 random starting points in 

<math display="inline" id="Time::memory::data_tradeoff_attack:25">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Time::memory::data_tradeoff_attack:26">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 times. The start points are the leftmost column in the matrix and the end points are the rightmost column. Then store the pairs of start and end points in increasing order of end points values.
</dd>
</dl>
<figure><b>(Figure)</b>
<figcaption>Hellman's Matrix</figcaption>
</figure>
<dl>
<dd>Now, only one matrix will not be able to cover the whole 

<math display="inline" id="Time::memory::data_tradeoff_attack:27">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 space. But if we add more rows to the matrix we will end up with a huge matrix that includes recovered points more than once. So we find the critical value of 

<math display="inline" id="Time::memory::data_tradeoff_attack:28">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>


 at which the matrix contains exactly 

<math display="inline" id="Time::memory::data_tradeoff_attack:29">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 different points. Consider the first 

<math display="inline" id="Time::memory::data_tradeoff_attack:30">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 paths from start points to end points are all disjoint with 

<math display="inline" id="Time::memory::data_tradeoff_attack:31">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   mt
  </annotation>
 </semantics>
</math>

 points, such that the next path which has at least one common point with one of those previous paths and includes exactly 

<math display="inline" id="Time::memory::data_tradeoff_attack:32">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 points. Those two sets of 

<math display="inline" id="Time::memory::data_tradeoff_attack:33">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   mt
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Time::memory::data_tradeoff_attack:34">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 points are disjoint by the <a href="Birthday_problem" title="wikilink">birthday paradox</a> if we make sure that 

<math display="inline" id="Time::memory::data_tradeoff_attack:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\sdot</mtext>
    </merror>
    <mi>m</mi>
    <mi>t</mi>
   </mrow>
   <mo>≤</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>t</ci>
     <mtext>\sdot</mtext>
     <ci>m</ci>
     <ci>t</ci>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\sdot mt\leq N
  </annotation>
 </semantics>
</math>

. We achieve this by enforcing the <strong>matrix stopping rule:</strong> 

<math display="inline" id="Time::memory::data_tradeoff_attack:36">
 <semantics>
  <mrow>
   <mrow>
    <mi>m</mi>
    <msup>
     <mi>t</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>m</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m{t}^{2}=N
  </annotation>
 </semantics>
</math>

.
</dd>
<dd>Nevertheless, an 

<math display="inline" id="Time::memory::data_tradeoff_attack:37">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>×</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m\times t
  </annotation>
 </semantics>
</math>

 matrix with 

<math display="inline" id="Time::memory::data_tradeoff_attack:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>m</mi>
    <msup>
     <mi>t</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>m</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m{t}^{2}=N
  </annotation>
 </semantics>
</math>


 covers a portion 

<math display="inline" id="Time::memory::data_tradeoff_attack:39">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>m</mi>
     <mi>t</mi>
    </mrow>
    <mo>/</mo>
    <mi>N</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>t</ci>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   mt/N=1/t
  </annotation>
 </semantics>
</math>

 of the whole space. To generate 

<math display="inline" id="Time::memory::data_tradeoff_attack:40">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 to cover the whole space, we use a variant of 

<math display="inline" id="Time::memory::data_tradeoff_attack:41">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 defined

<math display="block" id="Time::memory::data_tradeoff_attack:42">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>h</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>i</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {f}_{i}(x)={h}_{i}(f(x))
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Time::memory::data_tradeoff_attack:43">
 <semantics>
  <msub>
   <mi>h</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {h}_{i}
  </annotation>
 </semantics>
</math>


 is simple out manipulation such as reordering of bits of 

<math display="inline" id="Time::memory::data_tradeoff_attack:44">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> (refer to the original paper for more details). And one can see that the total preprocessing time is 

<math display="inline" id="Time::memory::data_tradeoff_attack:45">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>≈</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>P</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\approx N
  </annotation>
 </semantics>
</math>

. Also 

<math display="inline" id="Time::memory::data_tradeoff_attack:46">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mrow>
    <mi>m</mi>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=mt
  </annotation>
 </semantics>
</math>

 since we only need to store the pairs of start and end points and we have 

<math display="inline" id="Time::memory::data_tradeoff_attack:47">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 matrices each of 

<math display="inline" id="Time::memory::data_tradeoff_attack:48">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>


 pairs.
</dd>
</dl>
<dl>
<dd><strong><em>During the real time phase</em></strong>
</dd>
<dd>The total computation required to find 

<math display="inline" id="Time::memory::data_tradeoff_attack:49">
 <semantics>
  <mrow>
   <msup>
    <mi>f</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{-1}(y)
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Time::memory::data_tradeoff_attack:50">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <msup>
    <mi>t</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>t</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=t^{2}
  </annotation>
 </semantics>
</math>

 because we need to do 

<math display="inline" id="Time::memory::data_tradeoff_attack:51">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 inversion attempts as it is likely to be covered by one matrix and each of the attempts takes 

<math display="inline" id="Time::memory::data_tradeoff_attack:52">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 evaluations of some 

<math display="inline" id="Time::memory::data_tradeoff_attack:53">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}
  </annotation>
 </semantics>
</math>


. The optimum tradeoff curve is obtained by using the <strong>matrix stopping rule 

<math display="inline" id="Time::memory::data_tradeoff_attack:54">
 <semantics>
  <mrow>
   <mrow>
    <mi>m</mi>
    <msup>
     <mi>t</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>m</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m{t}^{2}=N
  </annotation>
 </semantics>
</math>

</strong> and we get 

<math display="inline" id="Time::memory::data_tradeoff_attack:55">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>T</mi>
     <msup>
      <mi>M</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>=</mo>
    <msup>
     <mi>N</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mo>=</mo>
     <mi>N</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>D</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>T</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>M</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>N</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <ci>P</ci>
      <ci>N</ci>
     </apply>
     <apply>
      <eq></eq>
      <ci>D</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T{M^{2}}={N^{2}},P=N,D=1
  </annotation>
 </semantics>
</math>

 and choice of 

<math display="inline" id="Time::memory::data_tradeoff_attack:56">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Time::memory::data_tradeoff_attack:57">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 depends on the cost of each resource.
</dd>
</dl>

<p>According to Hellman, if the block cipher at hand has the property that the mapping from its key to cipher text is a random permutation function 

<math display="inline" id="Time::memory::data_tradeoff_attack:58">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>


 over an 

<math display="inline" id="Time::memory::data_tradeoff_attack:59">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 point space, and if this 

<math display="inline" id="Time::memory::data_tradeoff_attack:60">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is invertible, the tradeoff relationship becomes ways better

<math display="block" id="Time::memory::data_tradeoff_attack:61">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mi>M</mi>
   </mrow>
   <mo>=</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>M</ci>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   TM=N
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="babbage-and-golic-tradeoff-attack-on-stream-ciphers">Babbage-and-Golic tradeoff attack on <a href="stream_cipher" title="wikilink">stream ciphers</a> <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></h2>

<p>For stream ciphers, 

<math display="inline" id="Time::memory::data_tradeoff_attack:62">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 is specified by the number of internal states of the bit generator - probably different from the number of keys. 

<math display="inline" id="Time::memory::data_tradeoff_attack:63">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>


 is the count of the first pseudorandom bits produced from the generator. Finally, the attacker goal is to find one of the actual internal states of the bit generator to be able to run the generator from this point on to generate the rest of the key. Associate each of the possible 

<math display="inline" id="Time::memory::data_tradeoff_attack:64">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 internal states of the bit generator with the corresponding string that consists of the first 

<math display="inline" id="Time::memory::data_tradeoff_attack:65">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mi>o</mi>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <ci>o</ci>
    <ci>g</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   log(N)
  </annotation>
 </semantics>
</math>

 bits obtained by running the generator from that state by the mapping 

<math display="inline" id="Time::memory::data_tradeoff_attack:66">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=y
  </annotation>
 </semantics>
</math>

 from states 

<math display="inline" id="Time::memory::data_tradeoff_attack:67">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 to output prefixes 

<math display="inline" id="Time::memory::data_tradeoff_attack:68">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>


. This previous mapping is considered a random function over the 

<math display="inline" id="Time::memory::data_tradeoff_attack:69">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 points common space. To invert this function, an attacker establishes the following.</p>
<ol>
<li>During the preprocessing phase, pick 

<math display="inline" id="Time::memory::data_tradeoff_attack:70">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 random 

<math display="inline" id="Time::memory::data_tradeoff_attack:71">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x}_{i}
  </annotation>
 </semantics>
</math>

 states and compute their corresponding 

<math display="inline" id="Time::memory::data_tradeoff_attack:72">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {y}_{i}
  </annotation>
 </semantics>
</math>

 output prefixes.</li>
<li>Store the pairs 

<math display="inline" id="Time::memory::data_tradeoff_attack:73">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>i</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ({x}_{i},{y}_{i})
  </annotation>
 </semantics>
</math>


 in increasing order of 

<math display="inline" id="Time::memory::data_tradeoff_attack:74">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {y}_{i}
  </annotation>
 </semantics>
</math>

 in a large table.</li>
<li>During the realtime phase, you have 

<math display="inline" id="Time::memory::data_tradeoff_attack:75">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mo>+</mo>
    <mrow>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>N</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <plus></plus>
     <ci>D</ci>
     <apply>
      <times></times>
      <ci>l</ci>
      <ci>o</ci>
      <ci>g</ci>
      <ci>N</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D+log(N)-1
  </annotation>
 </semantics>
</math>

 generated bits. Calculate from them all 

<math display="inline" id="Time::memory::data_tradeoff_attack:76">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 possible combinations of 

<math display="inline" id="Time::memory::data_tradeoff_attack:77">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>D</mi>
    </msub>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>D</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {y}_{1},{y}_{2},...,{y}_{D},
  </annotation>
 </semantics>
</math>

 of consecutive bits with length 

<math display="inline" id="Time::memory::data_tradeoff_attack:78">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mi>o</mi>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <ci>o</ci>
    <ci>g</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   log(N)
  </annotation>
 </semantics>
</math>


.</li>
<li>Search for each 

<math display="inline" id="Time::memory::data_tradeoff_attack:79">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {y}_{i}
  </annotation>
 </semantics>
</math>

 in the generated table which takes log time.</li>
<li>If you have a hit, this 

<math display="inline" id="Time::memory::data_tradeoff_attack:80">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {y}_{i}
  </annotation>
 </semantics>
</math>

 corresponds to an internal state 

<math display="inline" id="Time::memory::data_tradeoff_attack:81">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {x}_{i}
  </annotation>
 </semantics>
</math>

 of the bit generator from which you can forward run the generator to obtain the rest of the key.</li>
<li>By the <a href="Birthday_problem" title="wikilink">Birthday Paradox</a>, you are guaranteed that two subsets of a space with 

<math display="inline" id="Time::memory::data_tradeoff_attack:82">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 points have an intersection if their sizes product is greater than 

<math display="inline" id="Time::memory::data_tradeoff_attack:83">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>


.</li>
</ol>

<p>This result from the <a href="Birthday_problem" title="wikilink">Birthday attack</a> gives the condition 

<math display="inline" id="Time::memory::data_tradeoff_attack:84">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mi>M</mi>
   </mrow>
   <mo>=</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>M</ci>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   DM=N
  </annotation>
 </semantics>
</math>

 with attack time 

<math display="inline" id="Time::memory::data_tradeoff_attack:85">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=D
  </annotation>
 </semantics>
</math>

 and preprocessing time 

<math display="inline" id="Time::memory::data_tradeoff_attack:86">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=M
  </annotation>
 </semantics>
</math>

 which is just a particular point on the tradeoff curve 

<math display="inline" id="Time::memory::data_tradeoff_attack:87">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mi>M</mi>
   </mrow>
   <mo>=</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>M</ci>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   TM=N
  </annotation>
 </semantics>
</math>

. We can generalize this relation if we ignore some of the available data at real time and we are able to reduce 

<math display="inline" id="Time::memory::data_tradeoff_attack:88">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>


 from 

<math display="inline" id="Time::memory::data_tradeoff_attack:89">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=D
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Time::memory::data_tradeoff_attack:90">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 and the general tradeoff curve eventually becomes 

<math display="inline" id="Time::memory::data_tradeoff_attack:91">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mi>M</mi>
   </mrow>
   <mo>=</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>M</ci>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   TM=N
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Time::memory::data_tradeoff_attack:92">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>≤</mo>
   <mi>T</mi>
   <mo>≤</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <ci>T</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq T\leq D
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Time::memory::data_tradeoff_attack:93">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=M
  </annotation>
 </semantics>
</math>


.</p>
<h2 id="timememorydata-tradeoff-attack-by-a.-shamir-and-a.-biryukov-on-stream-ciphers">Time/Memory/Data Tradeoff attack by <a href="Adi_Shamir" title="wikilink">A. Shamir</a> and <a href="Alex_Biryukov" title="wikilink">A. Biryukov</a> on <a href="stream_cipher" title="wikilink">stream ciphers</a> <a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></h2>

<p>This novel idea introduced in 2000 combines both techniques: <em>Hellman tradeoff</em><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> and <em>Babbage-and-Golic tradeoff</em><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> attacks to achieve a new tradeoff curve with better bounds for <a href="stream_cipher" title="wikilink">stream ciphers</a> cryptoanalysis. You can apply Hellman's block cipher technique to stream cipher by using the same idea of covering the 

<math display="inline" id="Time::memory::data_tradeoff_attack:94">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 points space through matrices obtained from multiple variants 

<math display="inline" id="Time::memory::data_tradeoff_attack:95">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}
  </annotation>
 </semantics>
</math>

 of the function 

<math display="inline" id="Time::memory::data_tradeoff_attack:96">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 which is the mapping of internal states to output prefixes. Recall that this tradeoff attack on stream cipher is successful if any of the given 

<math display="inline" id="Time::memory::data_tradeoff_attack:97">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 output prefixes is found in any of the matrices covering 

<math display="inline" id="Time::memory::data_tradeoff_attack:98">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>


. Therefore, we can cut the number of covered points by the matrices from 

<math display="inline" id="Time::memory::data_tradeoff_attack:99">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Time::memory::data_tradeoff_attack:100">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>/</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>N</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N/D
  </annotation>
 </semantics>
</math>

 points. This is done by reducing the number of matrices from 

<math display="inline" id="Time::memory::data_tradeoff_attack:101">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Time::memory::data_tradeoff_attack:102">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>/</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>t</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t/D
  </annotation>
 </semantics>
</math>

 while keeping 

<math display="inline" id="Time::memory::data_tradeoff_attack:103">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>


 as large as possible (but this requires 

<math display="inline" id="Time::memory::data_tradeoff_attack:104">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>≥</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>t</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\geq D
  </annotation>
 </semantics>
</math>

 to have at least one table). For this new attack, we have 

<math display="inline" id="Time::memory::data_tradeoff_attack:105">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>m</mi>
     <mi>t</mi>
    </mrow>
    <mo>/</mo>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>t</ci>
     </apply>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=mt/D
  </annotation>
 </semantics>
</math>

 because we reduced the number of matrices to 

<math display="inline" id="Time::memory::data_tradeoff_attack:106">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>/</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>t</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t/D
  </annotation>
 </semantics>
</math>

 and the same for the preprocessing time 

<math display="inline" id="Time::memory::data_tradeoff_attack:107">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <mi>N</mi>
    <mo>/</mo>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <apply>
     <divide></divide>
     <ci>N</ci>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=N/D
  </annotation>
 </semantics>
</math>

. The realtime required for the attack is 

<math display="inline" id="Time::memory::data_tradeoff_attack:108">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>t</mi>
      <mo>/</mo>
      <mi>D</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\sdot</mtext>
    </merror>
    <mi>t</mi>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\sdot</mtext>
    </merror>
    <mi>D</mi>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>t</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>T</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>t</ci>
       <ci>D</ci>
      </apply>
      <mtext>\sdot</mtext>
      <ci>t</ci>
      <mtext>\sdot</mtext>
      <ci>D</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=(t/D)\sdot t\sdot D=t^{2}
  </annotation>
 </semantics>
</math>


 which is the product of the number of matrices, length of each iteration and number of available data points at attack time.</p>

<p>Eventually, we again use the <strong>matrix stopping rule</strong> to obtain the tradeoff curve 

<math display="inline" id="Time::memory::data_tradeoff_attack:109">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <msup>
     <mi>M</mi>
     <mn>2</mn>
    </msup>
    <msup>
     <mi>D</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>t</mi>
     <mn>2</mn>
    </msup>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\sdot</mtext>
    </merror>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msup>
        <mi>m</mi>
        <mn>2</mn>
       </msup>
       <msup>
        <mi>t</mi>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo>/</mo>
      <msup>
       <mi>D</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\sdot</mtext>
    </merror>
    <msup>
     <mi>D</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>m</mi>
     <mn>2</mn>
    </msup>
    <msup>
     <mi>t</mi>
     <mn>4</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>N</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>T</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>M</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>D</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>t</ci>
       <cn type="integer">2</cn>
      </apply>
      <mtext>\sdot</mtext>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>m</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>t</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>D</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <mtext>\sdot</mtext>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>D</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>m</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>t</ci>
       <cn type="integer">4</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>N</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   TM^{2}D^{2}=t^{2}\sdot(m^{2}t^{2}/D^{2})\sdot D^{2}=m^{2}t^{4}=N^{2}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Time::memory::data_tradeoff_attack:110">
 <semantics>
  <mrow>
   <msup>
    <mi>D</mi>
    <mn>2</mn>
   </msup>
   <mo>≤</mo>
   <mi>T</mi>
   <mo>≤</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>D</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>T</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D^{2}\leq T\leq N
  </annotation>
 </semantics>
</math>

 (because 

<math display="inline" id="Time::memory::data_tradeoff_attack:111">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>≥</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>t</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\geq D
  </annotation>
 </semantics>
</math>

).</p>
<h3 id="tradeoff-attacks-on-stream-ciphers-with-low-sampling-resistance">Tradeoff attacks on <a href="stream_cipher" title="wikilink">stream ciphers</a> with low sampling resistance <a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></h3>

<p>This attack was invented by <a href="Alex_Biryukov" title="wikilink">Biryukov</a>, <a href="Adi_Shamir" title="wikilink">Shamir</a>, <a href="David_A._Wagner" title="wikilink">Wagner</a>. The idea relies on the following feature of various stream ciphers: <em>the bit generator undergoes only few changes in its internal state before producing the next output bit.</em> Therefore, we can enumerate those special states that generate 

<math display="inline" id="Time::memory::data_tradeoff_attack:112">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 zero bits for small values of 

<math display="inline" id="Time::memory::data_tradeoff_attack:113">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>


 at low cost. But when forcing large number of output bits to take specific values, this enumeration process become very expensive and difficult. Now, we can define the <strong><em>sampling resistance of a stream cipher</em></strong> to be 

<math display="inline" id="Time::memory::data_tradeoff_attack:114">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo>-</mo>
     <mi>k</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=2^{-k}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Time::memory::data_tradeoff_attack:115">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 the maximum value which makes such enumeration feasible.</p>

<p>Let the stream cipher be of 

<math display="inline" id="Time::memory::data_tradeoff_attack:116">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=2^{n}
  </annotation>
 </semantics>
</math>

 states each has a <em>full name</em> of 

<math display="inline" id="Time::memory::data_tradeoff_attack:117">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 bits and a corresponding <em>output name</em> which is the first 

<math display="inline" id="Time::memory::data_tradeoff_attack:118">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


 bits in the output sequence of bits. If this stream cipher has sampling resistance 

<math display="inline" id="Time::memory::data_tradeoff_attack:119">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo>-</mo>
     <mi>k</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=2^{-k}
  </annotation>
 </semantics>
</math>

, then an efficient enumeration can use a <em>short name</em> of 

<math display="inline" id="Time::memory::data_tradeoff_attack:120">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-k
  </annotation>
 </semantics>
</math>

 bits to define the special states of the generator. Each special state with 

<math display="inline" id="Time::memory::data_tradeoff_attack:121">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-k
  </annotation>
 </semantics>
</math>

 <em>short name</em> has a corresponding <em>short output</em> name of 

<math display="inline" id="Time::memory::data_tradeoff_attack:122">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-k
  </annotation>
 </semantics>
</math>

 bits which is the output sequence of the special state after removing the first 

<math display="inline" id="Time::memory::data_tradeoff_attack:123">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>


 leading bits. Now, we are able to define a new mapping over a reduced space of 

<math display="inline" id="Time::memory::data_tradeoff_attack:124">
 <semantics>
  <mrow>
   <mrow>
    <mi>N</mi>
    <mi>R</mi>
   </mrow>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mi>k</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>N</ci>
     <ci>R</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   NR=2^{n-k}
  </annotation>
 </semantics>
</math>

 points and this mapping is equivalent to the original mapping. If we let 

<math display="inline" id="Time::memory::data_tradeoff_attack:125">
 <semantics>
  <mrow>
   <mrow>
    <mi>D</mi>
    <mi>R</mi>
   </mrow>
   <mo>≥</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>R</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   DR\geq 1
  </annotation>
 </semantics>
</math>

, the realtime data available to the attacker is guaranteed to have at least one output of those special states. Otherwise, we relax the definition of special states to include more points. If we substitute for 

<math display="inline" id="Time::memory::data_tradeoff_attack:126">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Time::memory::data_tradeoff_attack:127">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   DR
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Time::memory::data_tradeoff_attack:128">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>


 by 

<math display="inline" id="Time::memory::data_tradeoff_attack:129">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   NR
  </annotation>
 </semantics>
</math>

 in the new time/memory/data tradeoff attack by Shamir and Biryukov, we obtain the same tradeoff curve 

<math display="inline" id="Time::memory::data_tradeoff_attack:130">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <msup>
     <mi>M</mi>
     <mn>2</mn>
    </msup>
    <msup>
     <mi>D</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>N</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>M</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>D</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>N</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   TM^{2}D^{2}=N^{2}
  </annotation>
 </semantics>
</math>

 but with 

<math display="inline" id="Time::memory::data_tradeoff_attack:131">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>D</mi>
      <mi>R</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>≤</mo>
   <mi>T</mi>
   <mo>≤</mo>
   <mrow>
    <mi>N</mi>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <ci>D</ci>
       <ci>R</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <ci>T</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>N</ci>
      <ci>R</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (DR)^{2}\leq T\leq NR
  </annotation>
 </semantics>
</math>

. This is actually an improvement since we could relax the lower bound on 

<math display="inline" id="Time::memory::data_tradeoff_attack:132">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 since 

<math display="inline" id="Time::memory::data_tradeoff_attack:133">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>D</mi>
     <mi>R</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>R</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (DR)^{2}
  </annotation>
 </semantics>
</math>


 can be small up to 

<math display="inline" id="Time::memory::data_tradeoff_attack:134">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 which means that our attack can be made faster. Another advantage of this technique is that we reduced the number of expensive disk access operations from 

<math display="inline" id="Time::memory::data_tradeoff_attack:135">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Time::memory::data_tradeoff_attack:136">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   tR
  </annotation>
 </semantics>
</math>

 since we will be accessing only the special 

<math display="inline" id="Time::memory::data_tradeoff_attack:137">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>D</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   DR
  </annotation>
 </semantics>
</math>

 points. And this also can greatly make our attack faster because of the reduced number of expensive disk operations.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Cryptographic_attacks" title="wikilink">Cryptographic attacks</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Hellman, M.E., [<a class="uri" href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp</a>=&amp;arnumber;=1056220&amp;isnumber;=22715&amp;tag;=1 "A cryptanalytic time-memory trade-off,"] Information Theory, IEEE Transactions on , vol.26, no.4, pp.401,406, Jul 1980<a href="#fnref1">↩</a></li>
<li id="fn2">Babbage, S. H., [<a class="uri" href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp</a>=&amp;arnumber;=491713&amp;isnumber;=10615 "Improved “exhaustive search” attacks on stream ciphers,"] Security and Detection, 1995., European Convention on , vol., no., pp.161-166, 16–18 May 1995<a href="#fnref2">↩</a></li>
<li id="fn3">Golic, J., [<a href="http://download.springer.com/static/pdf/148/bok%253A978-3-540-69053-5.pdf?auth66=1401110566_72da97c839c322d7c836aef0143383ef&amp;ext">http://download.springer.com/static/pdf/148/bok%253A978-3-540-69053-5.pdf?auth66=1401110566_72da97c839c322d7c836aef0143383ef&amp;ext;</a>;=.pdf "Cryptanalysis of Alleged A5 Stream Cipher"] Lecture Notes in Computer Science, Advances in Cryptology — EUROCRYPT ’97, LNCS 1233, pp.239-255, Springer-Verlag 1997<a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8">Biryukov A., Shamir A., [<a href="http://download.springer.com/static/pdf/172/bok%253A978-3-540-44448-0.pdf?auth66=1401110102_dc9d0e992866dc89d3e0ce609a8be048&amp;ext">http://download.springer.com/static/pdf/172/bok%253A978-3-540-44448-0.pdf?auth66=1401110102_dc9d0e992866dc89d3e0ce609a8be048&amp;ext;</a>;=.pdf "Cryptanalytic Time/Memory/Data Tradeoffs for Stream Ciphers"] Lecture Notes in Computer Science, Advances in Cryptology — ASIACRYPT 2000, LNCS 1976, pp.1-13, Springer-Verlag Berlin Heidelberg 2000<a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13">Biryukov A., Shamir A., Wagner D., [<a href="http://download.springer.com/static/pdf/727/chp%253A10.1007%252F3-540-44706-7_1.pdf?auth66=1401140883_a1cfca3494421690d3d980db71300870&amp;ext">http://download.springer.com/static/pdf/727/chp%253A10.1007%252F3-540-44706-7_1.pdf?auth66=1401140883_a1cfca3494421690d3d980db71300870&amp;ext;</a>;=.pdf "Real Time Cryptanalysis of A5/1 on a PC"] Fast Software Encryption 2000, pp.1-18, Springer-Verlag 2000<a href="#fnref13">↩</a></li>
</ol>
</section>
</body>
</html>
