<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1205">Viterbi algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Viterbi algorithm</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>The <strong>Viterbi algorithm</strong> is a <a href="dynamic_programming" title="wikilink">dynamic programming</a> <a class="uri" href="algorithm" title="wikilink">algorithm</a> for finding the most <a href="likelihood_function" title="wikilink">likely</a> sequence of hidden states – called the <strong>Viterbi path</strong> – that results in a sequence of observed events, especially in the context of <a href="Markov_information_source" title="wikilink">Markov information sources</a> and <a href="hidden_Markov_model" title="wikilink">hidden Markov models</a>.</p>

<p>The algorithm has found universal application in decoding the <a href="convolutional_code" title="wikilink">convolutional codes</a> used in both <a class="uri" href="CDMA" title="wikilink">CDMA</a> and <a class="uri" href="GSM" title="wikilink">GSM</a> digital cellular, <a class="uri" href="dial-up" title="wikilink">dial-up</a> modems, satellite, deep-space communications, and <a class="uri" href="802.11" title="wikilink">802.11</a> wireless LANs. It is now also commonly used in <a href="speech_recognition" title="wikilink">speech recognition</a>, <a href="speech_synthesis" title="wikilink">speech synthesis</a>, <a class="uri" href="diarization" title="wikilink">diarization</a>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> <a href="keyword_spotting" title="wikilink">keyword spotting</a>, <a href="computational_linguistics" title="wikilink">computational linguistics</a>, and <a class="uri" href="bioinformatics" title="wikilink">bioinformatics</a>. For example, in <a class="uri" href="speech-to-text" title="wikilink">speech-to-text</a> (speech recognition), the acoustic signal is treated as the observed sequence of events, and a string of text is considered to be the "hidden cause" of the acoustic signal. The Viterbi algorithm finds the most likely string of text given the acoustic signal.</p>
<h2 id="history">History</h2>

<p>The Viterbi algorithm is named after <a href="Andrew_Viterbi" title="wikilink">Andrew Viterbi</a>, who proposed it in 1967 as a decoding algorithm for <a href="Convolution_code" title="wikilink">convolutional codes</a> over noisy digital communication links.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> It has, however, a history of <a href="multiple_invention" title="wikilink">multiple invention</a>, with at least seven independent discoveries, including those by Viterbi, <a href="Needleman–Wunsch_algorithm" title="wikilink">Needleman and Wunsch</a>, and <a href="Wagner–Fischer_algorithm" title="wikilink">Wagner and Fischer</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>"Viterbi (path, algorithm)" has become a standard term for the application of dynamic programming algorithms to maximization problems involving probabilities.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> For example, in <a href="statistical_parsing" title="wikilink">statistical parsing</a> a dynamic programming algorithm can be used to discover the single most likely context-free derivation (parse) of a string, which is commonly called the "Viterbi parse".<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="algorithm">Algorithm</h2>

<p>Suppose we are given a <a href="hidden_Markov_model" title="wikilink">hidden Markov model</a> (HMM) with state space 

<math display="inline" id="Viterbi_algorithm:0">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, initial probabilities 

<math display="inline" id="Viterbi_algorithm:1">
 <semantics>
  <msub>
   <mi>π</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>π</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{i}
  </annotation>
 </semantics>
</math>

 of being in state 

<math display="inline" id="Viterbi_algorithm:2">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 and transition probabilities 

<math display="inline" id="Viterbi_algorithm:3">
 <semantics>
  <msub>
   <mi>a</mi>
   <mrow>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <list>
     <ci>i</ci>
     <ci>j</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i,j}
  </annotation>
 </semantics>
</math>

 of transitioning from state 

<math display="inline" id="Viterbi_algorithm:4">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 to state 

<math display="inline" id="Viterbi_algorithm:5">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

. Say we observe outputs 

<math display="inline" id="Viterbi_algorithm:6">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mi>T</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>T</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{1},\dots,y_{T}
  </annotation>
 </semantics>
</math>

. The most likely state sequence 

<math display="inline" id="Viterbi_algorithm:7">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>T</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>T</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1},\dots,x_{T}
  </annotation>
 </semantics>
</math>

 that produces the observations is given by the recurrence relations:<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>

<math display="block" id="Viterbi_algorithm:8">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="right">
     <msub>
      <mi>V</mi>
      <mrow>
       <mn>1</mn>
       <mo>,</mo>
       <mi>k</mi>
      </mrow>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi mathvariant="normal">P</mi>
      <mrow>
       <mo maxsize="120%" minsize="120%">(</mo>
       <mpadded width="+5pt">
        <msub>
         <mi>y</mi>
         <mn>1</mn>
        </msub>
       </mpadded>
       <mo rspace="7.5pt" stretchy="false">|</mo>
       <mi>k</mi>
       <mo maxsize="120%" minsize="120%">)</mo>
      </mrow>
      <mo>⋅</mo>
      <msub>
       <mi>π</mi>
       <mi>k</mi>
      </msub>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <msub>
      <mi>V</mi>
      <mrow>
       <mi>t</mi>
       <mo>,</mo>
       <mi>k</mi>
      </mrow>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <munder>
       <mi>max</mi>
       <mrow>
        <mi>x</mi>
        <mo>∈</mo>
        <mi>S</mi>
       </mrow>
      </munder>
      <mrow>
       <mo>(</mo>
       <mi mathvariant="normal">P</mi>
       <mrow>
        <mo maxsize="120%" minsize="120%">(</mo>
        <mpadded width="+5pt">
         <msub>
          <mi>y</mi>
          <mi>t</mi>
         </msub>
        </mpadded>
        <mo rspace="7.5pt" stretchy="false">|</mo>
        <mi>k</mi>
        <mo maxsize="120%" minsize="120%">)</mo>
       </mrow>
       <mo>⋅</mo>
       <msub>
        <mi>a</mi>
        <mrow>
         <mi>x</mi>
         <mo>,</mo>
         <mi>k</mi>
        </mrow>
       </msub>
       <mo>⋅</mo>
       <msub>
        <mi>V</mi>
        <mrow>
         <mrow>
          <mi>t</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo>,</mo>
         <mi>x</mi>
        </mrow>
       </msub>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <list>
       <cn type="integer">1</cn>
       <ci>k</ci>
      </list>
     </apply>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">P</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-|</ci>
       <csymbol cd="unknown">k</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <ci>k</ci>
      </apply>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <list>
       <ci>t</ci>
       <ci>k</ci>
      </list>
     </apply>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <max></max>
       <apply>
        <in></in>
        <ci>x</ci>
        <ci>S</ci>
       </apply>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">P</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>t</ci>
        </apply>
        <ci>normal-|</ci>
        <csymbol cd="unknown">k</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <list>
         <ci>x</ci>
         <ci>k</ci>
        </list>
       </apply>
       <ci>normal-⋅</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>V</ci>
        <list>
         <apply>
          <minus></minus>
          <ci>t</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>x</ci>
        </list>
       </apply>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{rcl}V_{1,k}&=&\mathrm{P}\big(y_{1}\ |\ k\big)\cdot\pi_{k}\\
V_{t,k}&=&\max_{x\in S}\left(\mathrm{P}\big(y_{t}\ |\ k\big)\cdot a_{x,k}\cdot
V%
_{t-1,x}\right)\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>Here 

<math display="inline" id="Viterbi_algorithm:9">
 <semantics>
  <msub>
   <mi>V</mi>
   <mrow>
    <mi>t</mi>
    <mo>,</mo>
    <mi>k</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <list>
     <ci>t</ci>
     <ci>k</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{t,k}
  </annotation>
 </semantics>
</math>

 is the probability of the most probable state sequence responsible for the first 

<math display="inline" id="Viterbi_algorithm:10">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 observations that has 

<math display="inline" id="Viterbi_algorithm:11">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 as its final state. The Viterbi path can be retrieved by saving back pointers that remember which state 

<math display="inline" id="Viterbi_algorithm:12">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 was used in the second equation. Let 

<math display="inline" id="Viterbi_algorithm:13">
 <semantics>
  <mrow>
   <mi>Ptr</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>Ptr</ci>
    <interval closure="open">
     <ci>k</ci>
     <ci>t</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{Ptr}(k,t)
  </annotation>
 </semantics>
</math>

 be the function that returns the value of 

<math display="inline" id="Viterbi_algorithm:14">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 used to compute 

<math display="inline" id="Viterbi_algorithm:15">
 <semantics>
  <msub>
   <mi>V</mi>
   <mrow>
    <mi>t</mi>
    <mo>,</mo>
    <mi>k</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <list>
     <ci>t</ci>
     <ci>k</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{t,k}
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Viterbi_algorithm:16">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>></mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>t</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t>1
  </annotation>
 </semantics>
</math>

, or 

<math display="inline" id="Viterbi_algorithm:17">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Viterbi_algorithm:18">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=1
  </annotation>
 </semantics>
</math>

. Then:</p>

<p>

<math display="block" id="Viterbi_algorithm:19">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="right">
     <msub>
      <mi>x</mi>
      <mi>T</mi>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>arg</mi>
      <mrow>
       <munder>
        <mi>max</mi>
        <mrow>
         <mi>x</mi>
         <mo>∈</mo>
         <mi>S</mi>
        </mrow>
       </munder>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>V</mi>
         <mrow>
          <mi>T</mi>
          <mo>,</mo>
          <mi>x</mi>
         </mrow>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>Ptr</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>t</mi>
       </msub>
       <mo>,</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>T</ci>
     </apply>
     <eq></eq>
     <apply>
      <arg></arg>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <max></max>
        <apply>
         <in></in>
         <ci>x</ci>
         <ci>S</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>V</ci>
        <list>
         <ci>T</ci>
         <ci>x</ci>
        </list>
       </apply>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>Ptr</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>t</ci>
       </apply>
       <ci>t</ci>
      </interval>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{rcl}x_{T}&=&\arg\max_{x\in S}(V_{T,x})\\
x_{t-1}&=&\mathrm{Ptr}(x_{t},t)\end{array}
  </annotation>
 </semantics>
</math>

 Here we're using the standard definition of <a href="arg_max" title="wikilink">arg max</a>.<br/>
The complexity of this algorithm is 

<math display="inline" id="Viterbi_algorithm:20">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>T</mi>
     <mo>×</mo>
     <msup>
      <mrow>
       <mo>|</mo>
       <mi>S</mi>
       <mo>|</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>T</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <ci>S</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(T\times\left|{S}\right|^{2})
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="example">Example</h2>

<p>Consider a village where all villagers are either healthy or have a fever and only the village doctor can determine whether each has a fever. The doctor diagnoses fever by asking patients how they feel. The villagers may only answer that they feel normal, dizzy, or cold.</p>

<p>The doctor believes that the health condition of his patients operate as a discrete <a href="Markov_chain" title="wikilink">Markov chain</a>. There are two states, "Healthy" and "Fever", but the doctor cannot observe them directly, they are <em>hidden</em> from him. On each day, there is a certain chance that the patient will tell the doctor she is "normal", "cold", or "dizzy", depending on her health condition.</p>

<p>The <em>observations</em> (normal, cold, dizzy) along with a <em>hidden</em> state (healthy, fever) form a hidden Markov model (HMM), and can be represented as follows in the <a href="Python_(programming_language)" title="wikilink">Python programming language</a>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">states <span class="op">=</span> (<span class="st">'Healthy'</span>, <span class="st">'Fever'</span>)
 
observations <span class="op">=</span> (<span class="st">'normal'</span>, <span class="st">'cold'</span>, <span class="st">'dizzy'</span>)
 
start_probability <span class="op">=</span> {<span class="st">'Healthy'</span>: <span class="fl">0.6</span>, <span class="st">'Fever'</span>: <span class="fl">0.4</span>}
 
transition_probability <span class="op">=</span> {
   <span class="st">'Healthy'</span> : {<span class="st">'Healthy'</span>: <span class="fl">0.7</span>, <span class="st">'Fever'</span>: <span class="fl">0.3</span>},
   <span class="co">'Fever'</span> : {<span class="st">'Healthy'</span>: <span class="fl">0.4</span>, <span class="st">'Fever'</span>: <span class="fl">0.6</span>}
   }
 
emission_probability <span class="op">=</span> {
   <span class="st">'Healthy'</span> : {<span class="st">'normal'</span>: <span class="fl">0.5</span>, <span class="st">'cold'</span>: <span class="fl">0.4</span>, <span class="st">'dizzy'</span>: <span class="fl">0.1</span>},
   <span class="co">'Fever'</span> : {<span class="st">'normal'</span>: <span class="fl">0.1</span>, <span class="st">'cold'</span>: <span class="fl">0.3</span>, <span class="st">'dizzy'</span>: <span class="fl">0.6</span>}
   }</code></pre></div>

<p>In this piece of code, <code>start_probability</code> represents the doctor's belief about which state the HMM is in when the patient first visits (all he knows is that the patient tends to be healthy). The particular probability distribution used here is not the equilibrium one, which is (given the transition probabilities) approximately <code>{'Healthy': 0.57, 'Fever': 0.43}</code>. The <code>transition_probability</code> represents the change of the health condition in the underlying Markov chain. In this example, there is only a 30% chance that tomorrow the patient will have a fever if he is healthy today. The <code>emission_probability</code> represents how likely the patient is to feel on each day. If he is healthy, there is a 50% chance that he feels normal; if he has a fever, there is a 60% chance that he feels dizzy.</p>
<figure><b>(Figure)</b>
<figcaption>Graphical representation of the given HMM</figcaption>
</figure>

<p>The patient visits three days in a row and the doctor discovers that on the first day she feels normal, on the second day she feels cold, on the third day she feels dizzy. The doctor has a question: what is the most likely sequence of health conditions of the patient that would explain these observations? This is answered by the Viterbi algorithm.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> viterbi(obs, states, start_p, trans_p, emit_p):
    V <span class="op">=</span> [{}]
    path <span class="op">=</span> {}
    
    <span class="co"># Initialize base cases (t == 0)</span>
    <span class="cf">for</span> y <span class="op">in</span> states:
        V[<span class="dv">0</span>][y] <span class="op">=</span> start_p[y] <span class="op">*</span> emit_p[y][obs[<span class="dv">0</span>]]
        path[y] <span class="op">=</span> [y]
    
    <span class="co"># Run Viterbi for t &gt; 0</span>
    <span class="cf">for</span> t <span class="op">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(obs)):
        V.append({})
        newpath <span class="op">=</span> {}

        <span class="cf">for</span> y <span class="op">in</span> states:
            (prob, state) <span class="op">=</span> <span class="bu">max</span>((V[t<span class="dv">-1</span>][y0] <span class="op">*</span> trans_p[y0][y] <span class="op">*</span> emit_p[y][obs[t]], y0) <span class="cf">for</span> y0 <span class="op">in</span> states)
            V[t][y] <span class="op">=</span> prob
            newpath[y] <span class="op">=</span> path[state] <span class="op">+</span> [y]

        <span class="co"># Don't need to remember the old paths</span>
        path <span class="op">=</span> newpath
    n <span class="op">=</span> <span class="dv">0</span>           <span class="co"># if only one element is observed max is sought in the initialization values</span>
    <span class="cf">if</span> <span class="bu">len</span>(obs) <span class="op">!=</span> <span class="dv">1</span>:
        n <span class="op">=</span> t
    print_dptable(V)
    (prob, state) <span class="op">=</span> <span class="bu">max</span>((V[n][y], y) <span class="cf">for</span> y <span class="op">in</span> states)
    <span class="cf">return</span> (prob, path[state])

<span class="co"># Don't study this, it just prints a table of the steps.</span>
<span class="kw">def</span> print_dptable(V):
    s <span class="op">=</span> <span class="st">"    "</span> <span class="op">+</span> <span class="st">" "</span>.join((<span class="st">"</span><span class="sc">%7d</span><span class="st">"</span> <span class="op">%</span> i) <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="bu">len</span>(V))) <span class="op">+</span> <span class="st">"</span><span class="ch">\n</span><span class="st">"</span>
    <span class="cf">for</span> y <span class="op">in</span> V[<span class="dv">0</span>]:
        s <span class="op">+=</span> <span class="st">"</span><span class="sc">%.5s</span><span class="st">: "</span> <span class="op">%</span> y
        s <span class="op">+=</span> <span class="st">" "</span>.join(<span class="st">"</span><span class="sc">%.7s</span><span class="st">"</span> <span class="op">%</span> (<span class="st">"</span><span class="sc">%f</span><span class="st">"</span> <span class="op">%</span> v[y]) <span class="cf">for</span> v <span class="op">in</span> V)
        s <span class="op">+=</span> <span class="st">"</span><span class="ch">\n</span><span class="st">"</span>
    <span class="bu">print</span>(s)</code></pre></div>

<p>The function <code>viterbi</code> takes the following arguments: <code>obs</code> is the sequence of observations, e.g. <code>['normal', 'cold', 'dizzy']</code>; <code>states</code> is the set of hidden states; <code>start_p</code> is the start probability; <code>trans_p</code> are the transition probabilities; and <code>emit_p</code> are the emission probabilities. For simplicity of code, we assume that the observation sequence <code>obs</code> is non-empty and that <code>trans_p[i][j]</code> and <code>emit_p[i][j]</code> is defined for all states i,j.</p>

<p>In the running example, the forward/Viterbi algorithm is used as follows:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> example():
    <span class="cf">return</span> viterbi(observations,
                   states,
                   start_probability,
                   transition_probability,
                   emission_probability)
<span class="bu">print</span>(example())</code></pre></div>

<p>This reveals that the observations <code>['normal', 'cold', 'dizzy']</code> were most likely generated by states <code>['Healthy', 'Healthy', 'Fever']</code>. In other words, given the observed activities, the patient was most likely to have been healthy both on the first day when she felt normal as well as on the second day when she felt cold, and then she contracted a fever the third day.</p>

<p>The operation of Viterbi's algorithm can be visualized by means of a <a href="Trellis_diagram#Trellis_diagram" title="wikilink">trellis diagram</a>. The Viterbi path is essentially the shortest path through this trellis. The trellis for the clinic example is shown below; the corresponding Viterbi path is in bold: </p>

<p>When implementing Viterbi's algorithm, it should be noted that many languages use <a href="floating_point" title="wikilink">floating point</a> arithmetic - as p is small, this may lead to <a href="Arithmetic_underflow" title="wikilink">underflow</a> in the results. A common technique to avoid this is to take the <a href="log_probability" title="wikilink">logarithm of the probabilities</a> and use it throughout the computation, the same technique used in the <a href="Logarithmic_Number_System" title="wikilink">Logarithmic Number System</a>. Once the algorithm has terminated, an accurate value can be obtained by performing the appropriate exponentiation.</p>
<h2 id="extensions">Extensions</h2>

<p>A generalization of the Viterbi algorithm, termed the <em>max-sum algorithm</em> (or <em>max-product algorithm</em>) can be used to find the most likely assignment of all or some subset of <a href="latent_variable" title="wikilink">latent variables</a> in a large number of <a href="graphical_model" title="wikilink">graphical models</a>, e.g. <a href="Bayesian_network" title="wikilink">Bayesian networks</a>, <a href="Markov_random_field" title="wikilink">Markov random fields</a> and <a href="conditional_random_field" title="wikilink">conditional random fields</a>. The latent variables need in general to be connected in a way somewhat similar to an HMM, with a limited number of connections between variables and some type of linear structure among the variables. The general algorithm involves <em>message passing</em> and is substantially similar to the <a href="belief_propagation" title="wikilink">belief propagation</a> algorithm (which is the generalization of the <a href="forward-backward_algorithm" title="wikilink">forward-backward algorithm</a>).</p>

<p>With the algorithm called <a href="iterative_Viterbi_decoding" title="wikilink">iterative Viterbi decoding</a> one can find the subsequence of an observation that matches best (on average) to a given HMM. This algorithm is proposed by Qi Wang et al.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> to deal with <a href="turbo_code" title="wikilink">turbo code</a>. Iterative Viterbi decoding works by iteratively invoking a modified Viterbi algorithm, reestimating the score for a filler until convergence.</p>

<p>An alternative algorithm, the <a href="Lazy_Viterbi_algorithm" title="wikilink">Lazy Viterbi algorithm</a>, has been proposed recently.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> For many codes of practical interest, under reasonable noise conditions, the lazy decoder (using Lazy Viterbi algorithm) is much faster than the original <a href="Viterbi_decoder" title="wikilink">Viterbi decoder</a> (using Viterbi algorithm). This algorithm works by not expanding any nodes until it really needs to, and usually manages to get away with doing a lot less work (in software) than the ordinary Viterbi algorithm for the same result - however, it is not so easy to parallelize in hardware.</p>
<h2 id="pseudocode">Pseudocode</h2>

<p>Given the observation space 

<math display="inline" id="Viterbi_algorithm:21">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>o</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>o</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>o</mi>
     <mi>N</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>O</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>o</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>o</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>o</ci>
      <ci>N</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O=\{o_{1},o_{2},\dots,o_{N}\}
  </annotation>
 </semantics>
</math>

, the state space 

<math display="inline" id="Viterbi_algorithm:22">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>s</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>s</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>s</mi>
     <mi>K</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>K</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\{s_{1},s_{2},\dots,s_{K}\}
  </annotation>
 </semantics>
</math>

, a sequence of observations 

<math display="inline" id="Viterbi_algorithm:23">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>T</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Y</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>T</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y=\{y_{1},y_{2},\ldots,y_{T}\}
  </annotation>
 </semantics>
</math>

, transition matrix 

<math display="inline" id="Viterbi_algorithm:24">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 of size 

<math display="inline" id="Viterbi_algorithm:25">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>×</mo>
   <mi>K</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\times K
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Viterbi_algorithm:26">
 <semantics>
  <msub>
   <mi>A</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{ij}
  </annotation>
 </semantics>
</math>

 stores the transition probability of transiting from state 

<math display="inline" id="Viterbi_algorithm:27">
 <semantics>
  <msub>
   <mi>s</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{i}
  </annotation>
 </semantics>
</math>

 to state 

<math display="inline" id="Viterbi_algorithm:28">
 <semantics>
  <msub>
   <mi>s</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{j}
  </annotation>
 </semantics>
</math>

, emission matrix 

<math display="inline" id="Viterbi_algorithm:29">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 of size 

<math display="inline" id="Viterbi_algorithm:30">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>×</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\times N
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Viterbi_algorithm:31">
 <semantics>
  <msub>
   <mi>B</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{ij}
  </annotation>
 </semantics>
</math>

 stores the probability of observing 

<math display="inline" id="Viterbi_algorithm:32">
 <semantics>
  <msub>
   <mi>o</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>o</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o_{j}
  </annotation>
 </semantics>
</math>

 from state 

<math display="inline" id="Viterbi_algorithm:33">
 <semantics>
  <msub>
   <mi>s</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{i}
  </annotation>
 </semantics>
</math>

, an array of initial probabilities 

<math display="inline" id="Viterbi_algorithm:34">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 of size 

<math display="inline" id="Viterbi_algorithm:35">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Viterbi_algorithm:36">
 <semantics>
  <msub>
   <mi>π</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>π</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{i}
  </annotation>
 </semantics>
</math>

 stores the probability that 

<math display="inline" id="Viterbi_algorithm:37">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mo>=</mo>
   <msub>
    <mi>s</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <eq></eq>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>i</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}==s_{i}
  </annotation>
 </semantics>
</math>

.We say a path 

<math display="inline" id="Viterbi_algorithm:38">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>T</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>X</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>T</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=\{x_{1},x_{2},\ldots,x_{T}\}
  </annotation>
 </semantics>
</math>

 is a sequence of states that generate the observations 

<math display="inline" id="Viterbi_algorithm:39">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>T</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Y</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>T</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y=\{y_{1},y_{2},\ldots,y_{T}\}
  </annotation>
 </semantics>
</math>

.</p>

<p>In this dynamic programming problem, we construct two 2-dimensional tables 

<math display="inline" id="Viterbi_algorithm:40">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>T</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{1},T_{2}
  </annotation>
 </semantics>
</math>

 of size 

<math display="inline" id="Viterbi_algorithm:41">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>×</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>K</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\times T
  </annotation>
 </semantics>
</math>

. Each element of 

<math display="inline" id="Viterbi_algorithm:42">
 <semantics>
  <msub>
   <mi>T</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{1}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Viterbi_algorithm:43">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">1</cn>
    </apply>
    <interval closure="closed">
     <ci>i</ci>
     <ci>j</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{1}[i,j]
  </annotation>
 </semantics>
</math>

, stores the probability of the most likely path so far 

<math display="inline" id="Viterbi_algorithm:44">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>X</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-^</ci>
     <ci>X</ci>
    </apply>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>x</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>x</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>x</ci>
      </apply>
      <ci>j</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{X}=\{\hat{x}_{1},\hat{x}_{2},\ldots,\hat{x}_{j}\}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Viterbi_algorithm:45">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>x</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>j</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>s</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>x</ci>
     </apply>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{x}_{j}=s_{i}
  </annotation>
 </semantics>
</math>

 that generates 

<math display="inline" id="Viterbi_algorithm:46">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Y</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>j</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y=\{y_{1},y_{2},\ldots,y_{j}\}
  </annotation>
 </semantics>
</math>

. Each element of 

<math display="inline" id="Viterbi_algorithm:47">
 <semantics>
  <msub>
   <mi>T</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{2}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Viterbi_algorithm:48">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">2</cn>
    </apply>
    <interval closure="closed">
     <ci>i</ci>
     <ci>j</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{2}[i,j]
  </annotation>
 </semantics>
</math>

, stores 

<math display="inline" id="Viterbi_algorithm:49">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>x</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mrow>
    <mi>j</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-^</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>j</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{x}_{j-1}
  </annotation>
 </semantics>
</math>

 of the most likely path so far 

<math display="inline" id="Viterbi_algorithm:50">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>X</mi>
    <mo stretchy="false">^</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mi>j</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>,</mo>
    <msub>
     <mover accent="true">
      <mi>x</mi>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-^</ci>
     <ci>X</ci>
    </apply>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>x</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>x</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <ci>x</ci>
      </apply>
      <ci>j</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{X}=\{\hat{x}_{1},\hat{x}_{2},\ldots,\hat{x}_{j-1},\hat{x}_{j}\}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Viterbi_algorithm:51">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>j</mi>
    </mrow>
    <mo>,</mo>
    <mn>2</mn>
   </mrow>
   <mo>≤</mo>
   <mi>j</mi>
   <mo>≤</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <list>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>j</ci>
      </apply>
      <cn type="integer">2</cn>
     </list>
     <ci>j</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall j,2\leq j\leq T
  </annotation>
 </semantics>
</math>

</p>

<p>We fill entries of two tables 

<math display="inline" id="Viterbi_algorithm:52">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>T</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>T</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <cn type="integer">1</cn>
     </apply>
     <interval closure="closed">
      <ci>i</ci>
      <ci>j</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <cn type="integer">2</cn>
     </apply>
     <interval closure="closed">
      <ci>i</ci>
      <ci>j</ci>
     </interval>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{1}[i,j],T_{2}[i,j]
  </annotation>
 </semantics>
</math>

 by increasing order of 

<math display="inline" id="Viterbi_algorithm:53">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mo>⋅</mo>
    <mi>j</mi>
   </mrow>
   <mo>+</mo>
   <mi>i</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <ci>normal-⋅</ci>
     <ci>K</ci>
     <ci>j</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\cdot j+i
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Viterbi_algorithm:54">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>T</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mi>max</mi>
     <mi>k</mi>
    </munder>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>T</mi>
        <mn>1</mn>
       </msub>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>k</mi>
        <mo>,</mo>
        <mrow>
         <mi>j</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo>⋅</mo>
      <msub>
       <mi>A</mi>
       <mrow>
        <mi>k</mi>
        <mi>i</mi>
       </mrow>
      </msub>
      <mo>⋅</mo>
      <msub>
       <mi>B</mi>
       <mrow>
        <mi>i</mi>
        <msub>
         <mi>y</mi>
         <mi>j</mi>
        </msub>
       </mrow>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <cn type="integer">1</cn>
     </apply>
     <interval closure="closed">
      <ci>i</ci>
      <ci>j</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <ci>k</ci>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <cn type="integer">1</cn>
       </apply>
       <interval closure="closed">
        <ci>k</ci>
        <apply>
         <minus></minus>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </interval>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <apply>
        <times></times>
        <ci>k</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{1}[i,j]=\max_{k}{(T_{1}[k,j-1]\cdot A_{ki}\cdot B_{iy_{j}})}
  </annotation>
 </semantics>
</math>

, and</p>

<p>

<math display="block" id="Viterbi_algorithm:55">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>T</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>arg</mi>
    <mrow>
     <munder>
      <mi>max</mi>
      <mi>k</mi>
     </munder>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>T</mi>
         <mn>1</mn>
        </msub>
        <mrow>
         <mo stretchy="false">[</mo>
         <mi>k</mi>
         <mo>,</mo>
         <mrow>
          <mi>j</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
       <mo>⋅</mo>
       <msub>
        <mi>A</mi>
        <mrow>
         <mi>k</mi>
         <mi>i</mi>
        </mrow>
       </msub>
       <mo>⋅</mo>
       <msub>
        <mi>B</mi>
        <mrow>
         <mi>i</mi>
         <msub>
          <mi>y</mi>
          <mi>j</mi>
         </msub>
        </mrow>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <cn type="integer">2</cn>
     </apply>
     <interval closure="closed">
      <ci>i</ci>
      <ci>j</ci>
     </interval>
    </apply>
    <apply>
     <arg></arg>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <max></max>
       <ci>k</ci>
      </apply>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>T</ci>
         <cn type="integer">1</cn>
        </apply>
        <interval closure="closed">
         <ci>k</ci>
         <apply>
          <minus></minus>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </interval>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>A</ci>
        <apply>
         <times></times>
         <ci>k</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{2}[i,j]=\arg\max_{k}{(T_{1}[k,j-1]\cdot A_{ki}\cdot B_{iy_{j}})}
  </annotation>
 </semantics>
</math>

</p>

<p>Note that 

<math display="inline" id="Viterbi_algorithm:56">
 <semantics>
  <msub>
   <mi>B</mi>
   <mrow>
    <mi>i</mi>
    <msub>
     <mi>y</mi>
     <mi>j</mi>
    </msub>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{iy_{j}}
  </annotation>
 </semantics>
</math>

 does not need to appear in the latter expression, as it's constant with 

<math display="inline" id="Viterbi_algorithm:57">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Viterbi_algorithm:58">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 and does not affect the argmax.</p>

<p><code>   INPUT:  The observation space </code>

<math display="inline" id="Viterbi_algorithm:59">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>o</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>o</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>o</mi>
     <mi>N</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>O</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>o</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>o</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>o</ci>
      <ci>N</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O=\{o_{1},o_{2},\dots,o_{N}\}
  </annotation>
 </semantics>
</math>

<code>, </code><br/>
<code>           the state space </code>

<math display="inline" id="Viterbi_algorithm:60">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>s</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>s</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>s</mi>
     <mi>K</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>K</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\{s_{1},s_{2},\dots,s_{K}\}
  </annotation>
 </semantics>
</math>

<code>, </code><br/>
<code>           a sequence of observations  </code>

<math display="inline" id="Viterbi_algorithm:61">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>T</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Y</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>T</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y=\{y_{1},y_{2},\ldots,y_{T}\}
  </annotation>
 </semantics>
</math>

<code> such that </code>

<math display="inline" id="Viterbi_algorithm:62">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mo>=</mo>
   <mi>i</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>t</ci>
    </apply>
    <eq></eq>
    <eq></eq>
    <csymbol cd="unknown">i</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{t}==i
  </annotation>
 </semantics>
</math>

<code> if the </code><br/>
<code>             observation at time </code>

<math display="inline" id="Viterbi_algorithm:63">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

<code> is </code>

<math display="inline" id="Viterbi_algorithm:64">
 <semantics>
  <msub>
   <mi>o</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>o</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o_{i}
  </annotation>
 </semantics>
</math>

<code>,</code><br/>
<code>           transition matrix </code>

<math display="inline" id="Viterbi_algorithm:65">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

<code> of size </code>

<math display="inline" id="Viterbi_algorithm:66">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>⋅</mo>
   <mi>K</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <ci>K</ci>
    <ci>K</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\cdot K
  </annotation>
 </semantics>
</math>

<code> such that </code>

<math display="inline" id="Viterbi_algorithm:67">
 <semantics>
  <msub>
   <mi>A</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{ij}
  </annotation>
 </semantics>
</math>

<code> stores the transition</code><br/>
<code>             probability of transiting from state </code>

<math display="inline" id="Viterbi_algorithm:68">
 <semantics>
  <msub>
   <mi>s</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{i}
  </annotation>
 </semantics>
</math>

<code> to state </code>

<math display="inline" id="Viterbi_algorithm:69">
 <semantics>
  <msub>
   <mi>s</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{j}
  </annotation>
 </semantics>
</math>

<code>,</code><br/>
<code>           emission matrix </code>

<math display="inline" id="Viterbi_algorithm:70">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

<code> of size </code>

<math display="inline" id="Viterbi_algorithm:71">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>⋅</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⋅</ci>
    <ci>K</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\cdot N
  </annotation>
 </semantics>
</math>

<code> such that </code>

<math display="inline" id="Viterbi_algorithm:72">
 <semantics>
  <msub>
   <mi>B</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{ij}
  </annotation>
 </semantics>
</math>

<code> stores the probability of</code><br/>
<code>             observing </code>

<math display="inline" id="Viterbi_algorithm:73">
 <semantics>
  <msub>
   <mi>o</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>o</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o_{j}
  </annotation>
 </semantics>
</math>

<code> from  state </code>

<math display="inline" id="Viterbi_algorithm:74">
 <semantics>
  <msub>
   <mi>s</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{i}
  </annotation>
 </semantics>
</math>

<code>, </code><br/>
<code>           an array of initial probabilities </code>

<math display="inline" id="Viterbi_algorithm:75">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

<code> of size </code>

<math display="inline" id="Viterbi_algorithm:76">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

<code> such that </code>

<math display="inline" id="Viterbi_algorithm:77">
 <semantics>
  <msub>
   <mi>π</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>π</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{i}
  </annotation>
 </semantics>
</math>

<code> stores the probability</code><br/>
<code>             that </code>

<math display="inline" id="Viterbi_algorithm:78">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mo>=</mo>
   <msub>
    <mi>s</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <eq></eq>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>i</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}==s_{i}
  </annotation>
 </semantics>
</math>

<br/>
<code>   OUTPUT: The most likely hidden state sequence </code>

<math display="inline" id="Viterbi_algorithm:79">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>T</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>X</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>T</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X=\{x_{1},x_{2},\ldots,x_{T}\}
  </annotation>
 </semantics>
</math>

<br/>
<code>A01 </code><strong><code>function</code></strong><code> </code><em><code>VITERBI</code></em><code>( </code><em><code>O</code></em><code>, </code><em><code>S</code></em><code>,</code><em><code>π</code></em><code>,</code><em><code>Y</code></em><code>,</code><em><code>A</code></em><code>,</code><em><code>B</code></em><code> ) : </code><em><code>X</code></em><br/>
<code>A02     </code><strong><code>for</code></strong><code> each state </code><em><code>s</code><sub><code>i</code></sub></em><code> </code><strong><code>do</code></strong><br/>
<code>A03         </code><em><code>T</code><sub><code>1</code></sub><code>[i,1]</code></em><code>←</code><em><code>π</code><sub><code>i</code></sub></em>

<math display="inline" id="Viterbi_algorithm:80">
 <semantics>
  <mo>⋅</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⋅</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cdot
  </annotation>
 </semantics>
</math>

<code>''B</code><sub><code>iy</code><sub><code>1</code></sub></sub><br/>
<code>A04         </code><em><code>T</code><sub><code>2</code></sub><code>[i,1]</code></em><code>←0</code><br/>
<code>A05     </code><strong><code>end</code> <code>for</code></strong><br/>
<code>A06     </code><strong><code>for</code></strong><code> </code><em><code>i</code></em><code>←</code><em><code>2</code></em><code>,</code><em><code>3</code></em><code>,...,</code><em><code>T</code></em><code> </code><strong><code>do</code></strong><br/>
<code>A07         </code><strong><code>for</code></strong><code> each state </code><em><code>s</code><sub><code>j</code></sub></em><code> </code><strong><code>do</code></strong><br/>
<code>A08             </code><em><code>T</code><sub><code>1</code></sub><code>[j,i]</code></em><code>←</code>

<math display="inline" id="Viterbi_algorithm:81">
 <semantics>
  <mrow>
   <msub>
    <mi>max</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>T</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>k</mi>
       <mo>,</mo>
       <mrow>
        <mi>i</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>⋅</mo>
     <msub>
      <mi>A</mi>
      <mrow>
       <mi>k</mi>
       <mi>j</mi>
      </mrow>
     </msub>
     <mo>⋅</mo>
     <msub>
      <mi>B</mi>
      <mrow>
       <mi>j</mi>
       <msub>
        <mi>y</mi>
        <mi>i</mi>
       </msub>
      </mrow>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <max></max>
     <ci>k</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <cn type="integer">1</cn>
      </apply>
      <interval closure="closed">
       <ci>k</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </interval>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <apply>
       <times></times>
       <ci>k</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <apply>
       <times></times>
       <ci>j</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max_{k}{(T_{1}[k,i-1]\cdot A_{kj}\cdot B_{jy_{i}})}
  </annotation>
 </semantics>
</math>

<br/>
<code>A09             </code><em><code>T</code><sub><code>2</code></sub><code>[j,i]</code></em><code>←</code>

<math display="inline" id="Viterbi_algorithm:82">
 <semantics>
  <mrow>
   <mi>arg</mi>
   <mrow>
    <msub>
     <mi>max</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>T</mi>
        <mn>1</mn>
       </msub>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>k</mi>
        <mo>,</mo>
        <mrow>
         <mi>i</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo>⋅</mo>
      <msub>
       <mi>A</mi>
       <mrow>
        <mi>k</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <mo>⋅</mo>
      <msub>
       <mi>B</mi>
       <mrow>
        <mi>j</mi>
        <msub>
         <mi>y</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <arg></arg>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <ci>k</ci>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <cn type="integer">1</cn>
       </apply>
       <interval closure="closed">
        <ci>k</ci>
        <apply>
         <minus></minus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </interval>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <apply>
        <times></times>
        <ci>k</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <apply>
        <times></times>
        <ci>j</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \arg\max_{k}{(T_{1}[k,i-1]\cdot A_{kj}\cdot B_{jy_{i}})}
  </annotation>
 </semantics>
</math>

<br/>
<code>A10         </code><strong><code>end</code> <code>for</code></strong><br/>
<code>A11     </code><strong><code>end</code> <code>for</code></strong><br/>
<code>A12     </code><em><code>z</code><sub><code>T</code></sub></em><code>←</code>

<math display="inline" id="Viterbi_algorithm:83">
 <semantics>
  <mrow>
   <mi>arg</mi>
   <mrow>
    <msub>
     <mi>max</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>T</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>k</mi>
       <mo>,</mo>
       <mi>T</mi>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <arg></arg>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <cn type="integer">1</cn>
      </apply>
      <interval closure="closed">
       <ci>k</ci>
       <ci>T</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \arg\max_{k}{(T_{1}[k,T])}
  </annotation>
 </semantics>
</math>

<br/>
<code>A13     </code><em><code>x</code><sub><code>T</code></sub></em><code>←s</code><sub><code>z</code><sub><code>T</code></sub></sub><br/>
<code>A14     </code><strong><code>for</code></strong><code> </code><em><code>i</code></em><code>←</code><em><code>T</code></em><code>,</code><em><code>T-1</code></em><code>,...,</code><em><code>2</code></em><code> </code><strong><code>do</code></strong><br/>
<code>A15         </code><em><code>z</code><sub><code>i-1</code></sub></em><code>←T</code><sub><code>2</code></sub><code>[z</code><sub><code>i</code></sub><code>,i]</code><br/>
<code>A16         </code><em><code>x</code><sub><code>i-1</code></sub></em><code>←</code><em><code>s</code><sub><code>z</code><sub><code>i-1</code></sub></sub></em><br/>
<code>A17     </code><strong><code>end</code> <code>for</code></strong><br/>
<code>A18     </code><strong><code>return</code></strong><code> </code><em><code>X</code></em><br/>
<code>A19 </code><strong><code>end</code> <code>function</code></strong></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Expectation–maximization_algorithm" title="wikilink">Expectation–maximization algorithm</a></li>
<li><a href="Baum–Welch_algorithm" title="wikilink">Baum–Welch algorithm</a></li>
<li><a href="Forward-backward_algorithm" title="wikilink">Forward-backward algorithm</a></li>
<li><a href="Forward_algorithm" title="wikilink">Forward algorithm</a></li>
<li><a href="Error-correcting_code" title="wikilink">Error-correcting code</a></li>
<li><a href="Soft_output_Viterbi_algorithm" title="wikilink">Soft output Viterbi algorithm</a></li>
<li><a href="Viterbi_decoder" title="wikilink">Viterbi decoder</a></li>
<li><a href="Hidden_Markov_model" title="wikilink">Hidden Markov model</a></li>
<li><a href="Part-of-speech_tagging" title="wikilink">Part-of-speech tagging</a></li>
</ul>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li>

<p>(note: the Viterbi decoding algorithm is described in section IV.) Subscription required.</p></li>
<li></li>
<li>

<p>Subscription required.</p></li>
<li></li>
<li>

<p>(Describes the forward algorithm and Viterbi algorithm for HMMs).</p></li>
<li>Shinghal, R. and <a href="Godfried_Toussaint" title="wikilink">Godfried T. Toussaint</a>, "Experiments in text recognition with the modified Viterbi algorithm," <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>, Vol. PAMI-l, April 1979, pp. 184–193.</li>
<li>Shinghal, R. and <a href="Godfried_Toussaint" title="wikilink">Godfried T. Toussaint</a>, "The sensitivity of the modified Viterbi algorithm to the source statistics," <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>, vol. PAMI-2, March 1980, pp. 181–185.</li>
</ul>
<h2 id="implementations">Implementations</h2>
<ul>
<li><a href="http://susalib.org/">Susa</a> signal processing framework provides the C++ implementation for <a href="Forward_error_correction" title="wikilink">Forward error correction</a> codes and channel equalization <a href="https://github.com/behrooza/susa/blob/master/inc/channel.h">here</a>.</li>
<li><a href="http://pcarvalho.com/forward_viterbi/">C#</a></li>
<li><a href="http://www.cs.stonybrook.edu/~pfodor/viterbi/Viterbi.java">Java</a></li>
<li>[<a class="uri" href="https://metacpan.org/module/Algorithm">https://metacpan.org/module/Algorithm</a>::Viterbi Perl]</li>
<li><a href="http://www.cs.stonybrook.edu/~pfodor/viterbi/viterbi.P">Prolog</a></li>
<li><a href="https://hackage.haskell.org/package/hmm-0.2.1.1/docs/src/Data-HMM.html#viterbi">Haskell</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://en.wikibooks.org/wiki/Algorithm_Implementation/Viterbi_algorithm">Implementations in Java, F#, Clojure, C# on Wikibooks</a></li>
<li><a href="http://home.netcom.com/~chip.f/viterbi/tutorial.html">Tutorial</a> on convolutional coding with viterbi decoding, by Chip Fleming</li>
<li><a href="http://arxiv.org/abs/cs/0504020v2">The history of the Viterbi Algorithm</a>, by David Forney</li>
<li><a href="http://www.cambridge.org/resources/0521882672/7934_kaeslin_dynpro_new.pdf">A Gentle Introduction to Dynamic Programming and the Viterbi Algorithm</a></li>
<li><a href="http://www.kanungo.com/software/hmmtut.pdf">A tutorial for a Hidden Markov Model toolkit (implemented in C) that contains a description of the Viterbi algorithm</a></li>
</ul>

<p>"</p>

<p><a href="Category:Error_detection_and_correction" title="wikilink">Category:Error detection and correction</a> <a href="Category:Dynamic_programming" title="wikilink">Category:Dynamic programming</a> <a href="Category:Markov_models" title="wikilink">Category:Markov models</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Xavier Anguera et Al, <a href="http://www1.icsi.berkeley.edu/~vinyals/Files/taslp2011a.pdf">"Speaker Diarization: A Review of Recent Research"</a>, retrieved 19. August 2010, IEEE TASLP<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="http://arxiv.org/abs/cs/0504020v2">29 Apr 2005, G. David Forney Jr: The Viterbi Algorithm: A Personal History</a><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8">Xing E, slide 11<a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
</ol>
</section>
</body>

