<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1579">Lehmer code</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Lehmer code</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a> and in particular in <a class="uri" href="combinatorics" title="wikilink">combinatorics</a>, the <strong>Lehmer code</strong> is a particular way to <a href="encoding" title="wikilink">encode</a> each possible <a class="uri" href="permutation" title="wikilink">permutation</a> of a sequence of <em>n</em> numbers. It is an instance of a scheme for <a href="Permutation#Numbering_permutations" title="wikilink">numbering permutations</a> and is an example of an <strong>inversion table</strong>.</p>

<p>The Lehmer code is named in reference to <a href="Derrick_Henry_Lehmer" title="wikilink">Derrick Henry Lehmer</a>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> but the code had been known since 1888 at least.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="the-code">The code</h2>

<p>The Lehmer code makes use of the fact that there are</p>

<p>

<math display="block" id="Lehmer_code:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>n</mi>
    <mo lspace="0pt" rspace="3.5pt">!</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>n</mi>
    <mo>×</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>×</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>×</mo>
    <mn>2</mn>
    <mo>×</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <factorial></factorial>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋯</ci>
     <cn type="integer">2</cn>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n!=n\times(n-1)\times\cdots\times 2\times 1
  </annotation>
 </semantics>
</math>

 permutations of a sequence of <em>n</em> numbers. If a permutation <em>σ</em> is specified by the sequence (<em>σ</em><sub>1</sub>, …, <em>σ</em><sub><em>n</em></sub>) of its images of 1, …, <em>n</em>, then it is encoded by a sequence of <em>n</em> numbers, but not all such sequences are valid since every number must be used only once. By contrast the encodings considered here choose the first number from a set of <em>n</em> values, the next number from a fixed set of 

<math display="inline" id="Lehmer_code:1">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">−</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-−</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n−1
  </annotation>
 </semantics>
</math>

 values, and so forth decreasing the number of possibilities until the last number for which only a single fixed value is allowed; <em>every</em> sequence of numbers chosen from these sets encodes a single permutation. While several <a href="encoding" title="wikilink">encodings</a> can be defined, the Lehmer code has several additional useful properties; it is the sequence</p>

<p>

<math display="block" id="Lehmer_code:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>σ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>L</mi>
        <msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>σ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mn>1</mn>
        </msub>
       </mrow>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <mrow>
        <mi>L</mi>
        <msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>σ</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mi>n</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mtext>where</mtext>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mi>L</mi>
      <msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>σ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi mathvariant="normal">#</mi>
      <mrow>
       <mo stretchy="false">{</mo>
       <mrow>
        <mi>j</mi>
        <mo>></mo>
        <mi>i</mi>
       </mrow>
       <mo>:</mo>
       <mrow>
        <msub>
         <mi>σ</mi>
         <mi>j</mi>
        </msub>
        <mo><</mo>
        <msub>
         <mi>σ</mi>
         <mi>i</mi>
        </msub>
       </mrow>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>σ</ci>
     </apply>
     <list>
      <vector>
       <apply>
        <times></times>
        <ci>L</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>σ</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <times></times>
        <ci>L</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>σ</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </vector>
      <mtext>where</mtext>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>L</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>normal-#</ci>
      <apply>
       <csymbol cd="latexml">conditional-set</csymbol>
       <apply>
        <gt></gt>
        <ci>j</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <lt></lt>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>σ</ci>
         <ci>j</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>σ</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(\sigma)=(L(\sigma)_{1},\ldots,L(\sigma)_{n})\quad\text{where}\quad L(\sigma)%
_{i}=\#\{j>i:\sigma_{j}<\sigma_{i}\},
  </annotation>
 </semantics>
</math>

 in other words the term <em>L</em>(<em>σ</em>)<sub><em>i</em></sub> counts the number of terms in (<em>σ</em><sub>1</sub>, …, <em>σ</em><sub><em>n</em></sub>) to the right of <em>σ</em><sub><em>i</em></sub> that are smaller than it, a number between 0 and 

<math display="inline" id="Lehmer_code:3">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">−</mi>
   <mi>i</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-−</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n−i
  </annotation>
 </semantics>
</math>

, allowing for 

<math display="inline" id="Lehmer_code:4">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>+</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">−</mi>
    <mi>i</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>n</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-−</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n+1−i
  </annotation>
 </semantics>
</math>

 different values.</p>

<p>A pair of indices (<em>i</em>,<em>j</em>) with 

<math display="inline" id="Lehmer_code:5">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">−</mi>
   <mi>i</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-−</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n−i
  </annotation>
 </semantics>
</math>

</p>

<p>Variations of this encoding can be obtained by counting inversions (<em>i</em>,<em>j</em>) for fixed <em>j</em> rather than fixed <em>i</em>, by counting inversions with a fixed smaller <em>value</em> <mtpl></mtpl> rather than smaller index <em>i</em>, or by counting non-inversions rather than inversions; while this does not produce a fundamentally different type of encoding, some properties of the encoding will change correspondingly. In particular counting inversions with a fixed smaller value <mtpl></mtpl> gives the inversion table of <em>σ</em>, which can be seen to be the Lehmer code of the inverse permutation.</p>
<h2 id="encoding-and-decoding">Encoding and decoding</h2>

<p>The usual way to prove that there are <em>n</em>! different permutations of <em>n</em> objects is to observe that the first object can be chosen in 

<math display="inline" id="Lehmer_code:7">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">−</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-−</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n−1
  </annotation>
 </semantics>
</math>

 different ways, the next object in 

<math display="inline" id="Lehmer_code:8">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">−</mi>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-−</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n−2
  </annotation>
 </semantics>
</math>

 different ways (because choosing the same number as the first is forbidden), the next in 

<math display="inline" id="Lehmer_code:9">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>></mo>
   <mi>i</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>j</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j>i
  </annotation>
 </semantics>
</math>

 different ways (because there are now 2 forbidden values), and so forth. Translating this freedom of choice at each step into a number, one obtains an encoding algorithm, one that finds the Lehmer code of a given permutation. One need not suppose the objects permuted to be numbers, but one needs a <a href="total_ordering" title="wikilink">total ordering</a> of the set of objects. Since the code numbers are to start from 0, the appropriate number to encode each object <em>σ</em><sub><em>i</em></sub> by is the number of objects that were available at that point (so they do not occur before position <em>i</em>), but which are smaller than the object <em>σ</em><sub><em>i</em></sub> actually chosen. (Inevitably such objects must appear at some position 

<math display="inline" id="Lehmer_code:10">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">−</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-−</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n−1
  </annotation>
 </semantics>
</math>

, and (<em>i</em>,<em>j</em>) will be an inversion, which shows that this number is indeed <em>L</em>(<em>σ</em>)<sub><em>i</em></sub>.)</p>

<p>This number to encode each object can be found by direct counting, in several ways (directly counting inversions, or correcting the total number of objects smaller than a given one, which is its sequence number starting from 0 in the set, by those that are unavailable at its position). Another method which is in-place, but not really more efficient, is to start with the permutation of {0, 1, … 

<math display="block" id="Lehmer_code:11">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="center">
     <mn>𝟏</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>5</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>0</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>6</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>3</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>4</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>2</mn>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mn>1</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>𝟒</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>0</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>5</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>2</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>3</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>1</mn>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mn>1</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>4</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>𝟎</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>4</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>2</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>3</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>1</mn>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mn>1</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>4</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>0</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>𝟑</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>1</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>2</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>0</mn>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mn>1</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>4</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>0</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>3</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>𝟏</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>2</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>0</mn>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mn>1</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>4</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>0</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>3</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>1</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>𝟏</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>0</mn>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <mn>1</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>4</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>0</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>3</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>1</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>1</mn>
    </mtd>
    <mtd columnalign="center">
     <mn>𝟎</mn>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="integer">1</cn>
     <cn type="integer">5</cn>
     <cn type="integer">0</cn>
     <cn type="integer">6</cn>
     <cn type="integer">3</cn>
     <cn type="integer">4</cn>
     <cn type="integer">2</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">1</cn>
     <cn type="integer">4</cn>
     <cn type="integer">0</cn>
     <cn type="integer">5</cn>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
     <cn type="integer">1</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">1</cn>
     <cn type="integer">4</cn>
     <cn type="integer">0</cn>
     <cn type="integer">4</cn>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
     <cn type="integer">1</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">1</cn>
     <cn type="integer">4</cn>
     <cn type="integer">0</cn>
     <cn type="integer">3</cn>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <cn type="integer">0</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">1</cn>
     <cn type="integer">4</cn>
     <cn type="integer">0</cn>
     <cn type="integer">3</cn>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <cn type="integer">0</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">1</cn>
     <cn type="integer">4</cn>
     <cn type="integer">0</cn>
     <cn type="integer">3</cn>
     <cn type="integer">1</cn>
     <cn type="integer">1</cn>
     <cn type="integer">0</cn>
    </matrixrow>
    <matrixrow>
     <cn type="integer">1</cn>
     <cn type="integer">4</cn>
     <cn type="integer">0</cn>
     <cn type="integer">3</cn>
     <cn type="integer">1</cn>
     <cn type="integer">1</cn>
     <cn type="integer">0</cn>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{matrix}\mathbf{1}&5&0&6&3&4&2\\
1&\mathbf{4}&0&5&2&3&1\\
1&4&\mathbf{0}&4&2&3&1\\
1&4&0&\mathbf{3}&1&2&0\\
1&4&0&3&\mathbf{1}&2&0\\
1&4&0&3&1&\mathbf{1}&0\\
1&4&0&3&1&1&\mathbf{0}\\
\end{matrix}
  </annotation>
 </semantics>
</math>

} obtained by representing each object by its mentioned sequence number, and then for each entry <em>x</em>, in order from left to right, correct the items to its right by subtracting 1 from all entries (still) greater than <em>x</em> (to reflect the fact that the object corresponding to <em>x</em> is no longer available). Concretely a Lehmer code for the permutation B,F,A,G,D,E,C of letters, ordered alphabetically, would first give the list of sequence numbers 1,5,0,6,3,4,2, which is successively transformed</p>

<p>

<math display="inline" id="Lehmer_code:12">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">−</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-−</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n−1
  </annotation>
 </semantics>
</math>

 where the final line is the Lehmer code (at each line one subtracts 1 from the larger entries to the right of the boldface element to form the next line).</p>

<p>For decoding a Lehmer code into a permutation of a given set, the latter procedure may be reversed: for each entry <em>x</em>, in order from right to left, correct the items to its right by adding 1 to all those (currently) greater than or equal to <em>x</em>; finally interpret the resulting permutation of {0, 1, … 

<math display="inline" id="Lehmer_code:13">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>×</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>×</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>×</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>2</mn>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>×</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [n]\times[n-1]\times\cdots\times[2]\times[1]
  </annotation>
 </semantics>
</math>

} as sequence numbers (which amounts to adding 1 to each entry if a permutation of {1, 2, … <em>n</em>} is sought). Alternatively the entries of the Lehmer code can be processed from left to right, and interpreted as a number determining the next choice of an element as indicated above; this requires maintaining a list of available elements, from which each chosen element is removed. In the example this would mean choosing element 1 from {A,B,C,D,E,F,G} (which is B) then element 4 from {A,C,D,E,F,G} (which is F), then element 0 from {A,C,D,E,G} (giving A) and so on, reconstructing the sequence B,F,A,G,D,E,C.</p>
<h2 id="applications-to-combinatorics-and-probabilities">Applications to combinatorics and probabilities</h2>
<h3 id="independence-of-relative-ranks">Independence of relative ranks</h3>

<p>The Lehmer code defines a bijection from the <a href="symmetric_group" title="wikilink">symmetric group</a> <em>S</em><sub><em>n</em></sub> to the Cartesian product 

<math display="inline" id="Lehmer_code:14">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mi>k</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
    <ci>normal-…</ci>
    <apply>
     <minus></minus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{0,1,\ldots,k-1\}
  </annotation>
 </semantics>
</math>

, where [<em>k</em>] designates the <em>k</em>-element set 

<math display="inline" id="Lehmer_code:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>n</mi>
    <mi>n</mi>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">−</mi>
    <mi>i</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-−</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   nn+1−i
  </annotation>
 </semantics>
</math>

. As a consequence, under the uniform law on the <em>S</em><sub><em>n</em></sub>, the component <em>L</em>(<em>σ</em>)<sub><em>i</em></sub> defines a uniformly distributed <a href="random_variable" title="wikilink">random variable</a> on 

<math display="inline" id="Lehmer_code:16">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>

, and these random variables are mutually <a href="Independence_(probability_theory)" title="wikilink">independent</a>, because they are projections on different factors of a <a href="Cartesian_product" title="wikilink">Cartesian product</a>.</p>
<h3 id="number-of-right-to-left-minima-and-maxima">Number of right-to-left minima and maxima</h3>

<p>Definition : In a sequence <em>u

<math display="inline" id="Lehmer_code:17">
 <semantics>
  <msub>
   <mpadded lspace="5pt" width="+5pt">
    <mi>𝔖</mi>
   </mpadded>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝔖</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\ \mathfrak{S}_{n}
  </annotation>
 </semantics>
</math>

(u<sub>k</sub>)<sub>1≤k≤n</sub></em>, there is <strong>right-to-left minimum</strong> (resp. <strong>maximum</strong>) at rank <em>k</em> if <em>u<sub>k</sub></em> is strictly smaller (resp. strictly bigger) than each element <em>u<sub>i</sub></em> with <em>i&gt;k</em>, i.e., to its right.</p>

<p>Let <em>B(k)</em> (resp. <em>H(k)</em>) be the event "there is right-to-left minimum (resp. maximum) at rank <em>k</em>", i.e. <em>B(k)</em> is the set of the permutations 

<math display="inline" id="Lehmer_code:18">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>ω</mi>
    <mo>∈</mo>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo>,</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
   <mtext>and</mtext>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>ω</mi>
    <mo>∈</mo>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo>,</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mi>k</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">ω</csymbol>
     <in></in>
     <csymbol cd="unknown">B</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">k</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-}</ci>
    </cerror>
    <ci>normal-⇔</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">L</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">k</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">ω</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-}</ci>
    </cerror>
    <ci></ci>
    <mtext>and</mtext>
    <ci></ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">ω</csymbol>
     <in></in>
     <csymbol cd="unknown">H</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">k</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-}</ci>
    </cerror>
    <ci>normal-⇔</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">L</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">k</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">ω</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <csymbol cd="unknown">k</csymbol>
     <ci>normal-}</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\omega\in B(k)\}\Leftrightarrow\{L(k,\omega)=1\}\quad\text{and}\quad\{\omega%
\in H(k)\}\Leftrightarrow\{L(k,\omega)=k\}.
  </annotation>
 </semantics>
</math>

 which exhibit a right-to-left minimum (resp. maximum) at rank <em>k</em>. We clearly have</p>
<center>

<p>

<math display="inline" id="Lehmer_code:19">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>N</mi>
       <mi>b</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ω</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mrow>
       <msub>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mn>1</mn>
         <mo>≤</mo>
         <mi>k</mi>
         <mo>≤</mo>
         <mi>n</mi>
        </mrow>
       </msub>
       <mrow>
        <mpadded width="-3.4pt">
         <mn>1</mn>
        </mpadded>
        <msub>
         <mn>1</mn>
         <mrow>
          <mi>B</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>k</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </msub>
       </mrow>
      </mrow>
      <mtext>and</mtext>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>N</mi>
       <mi>b</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ω</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mn>1</mn>
        <mo>≤</mo>
        <mi>k</mi>
        <mo>≤</mo>
        <mi>n</mi>
       </mrow>
      </msub>
      <mrow>
       <mpadded width="-3.4pt">
        <mn>1</mn>
       </mpadded>
       <msub>
        <mn>1</mn>
        <mrow>
         <mi>H</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>k</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </msub>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <ci>b</ci>
      </apply>
      <ci>ω</ci>
     </apply>
     <list>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <and></and>
         <apply>
          <leq></leq>
          <cn type="integer">1</cn>
          <ci>k</ci>
         </apply>
         <apply>
          <leq></leq>
          <share href="#.cmml">
          </share>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="float">1</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <cn type="integer">1</cn>
         <apply>
          <times></times>
          <ci>B</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <mtext>and</mtext>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <ci>b</ci>
      </apply>
      <ci>ω</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <and></and>
        <apply>
         <leq></leq>
         <cn type="integer">1</cn>
         <ci>k</ci>
        </apply>
        <apply>
         <leq></leq>
         <share href="#.cmml">
         </share>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="float">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <ci>H</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{b}(\omega)=\sum_{1\leq k\leq n}\ 1\!\!1_{B(k)}\quad\text{and}\quad N_{b}(%
\omega)=\sum_{1\leq k\leq n}\ 1\!\!1_{H(k)}.
  </annotation>
 </semantics>
</math>

</p>
</center>

<p>Thus the number <em>N<sub>b</sub>(ω)</em> (resp. <em>N<sub>h</sub>(ω)</em>) of right-to-left minimum (resp. maximum) for the permutation <em>ω</em> can be written as a sum of independent <a href="Bernoulli_random_variable" title="wikilink">Bernoulli random variables</a> each with a respective parameter of 1/k :</p>
<center>

<p>

<math display="inline" id="Lehmer_code:20">
 <semantics>
  <mrow>
   <mrow>
    <mo lspace="7.5pt" rspace="0.8pt" stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mi>k</mi>
     <mo rspace="0.8pt" stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <interval closure="closed">
     <cn type="integer">1</cn>
     <ci>k</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\ [\![1,k]\!],
  </annotation>
 </semantics>
</math>

</p>
</center>

<p>Indeed, as <em>L(k)</em> follows the uniform law on 

<math display="inline" id="Lehmer_code:21">
 <semantics>
  <mrow>
   <mi>ℙ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>ℙ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>ℙ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>ℙ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mi>k</mi>
   </mfrac>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">k</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">L</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">k</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">H</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">k</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">L</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">k</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <csymbol cd="unknown">k</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>k</ci>
    </apply>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{P}(B(k))=\mathbb{P}(L(k)=1)=\mathbb{P}(H(k))=\mathbb{P}(L(k)=k)=\tfrac%
{1}{k}.
  </annotation>
 </semantics>
</math>

</p>
<center>

<p>

<math display="inline" id="Lehmer_code:22">
 <semantics>
  <mrow>
   <mpadded width="-3.4pt">
    <mn>1</mn>
   </mpadded>
   <msub>
    <mn>1</mn>
    <mrow>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>k</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">1</cn>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\!\!1_{B(k)}
  </annotation>
 </semantics>
</math>

</p>
</center>

<p>The <a href="generating_function" title="wikilink">generating function</a> for the Bernoulli random variable 

<math display="inline" id="Lehmer_code:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>G</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mrow>
       <mi>k</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo>+</mo>
      <mi>s</mi>
     </mrow>
     <mi>k</mi>
    </mfrac>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <ci>k</ci>
     </apply>
     <ci>s</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>s</ci>
     </apply>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{k}(s)=\frac{k-1+s}{k},
  </annotation>
 </semantics>
</math>

 is</p>
<center>

<p>

<math display="inline" id="Lehmer_code:24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>G</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∏</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>G</mi>
       <mi>k</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo rspace="7.5pt" stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="7.5pt">=</mo>
    <mfrac>
     <msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mi></mi>
       <mo>↑</mo>
       <mi>n</mi>
      </mrow>
     </msub>
     <mrow>
      <mi>n</mi>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
    </mfrac>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>G</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>G</ci>
        <ci>k</ci>
       </apply>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <apply>
        <ci>normal-↑</ci>
        <csymbol cd="latexml">absent</csymbol>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <factorial></factorial>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G(s)=\prod_{k=1}^{n}G_{k}(s)\ =\ \frac{(s)_{\uparrow n}}{n!},
  </annotation>
 </semantics>
</math>

</p>
</center>

<p>therefore the generating function of <em>N<sub>b</sub></em> is</p>
<center>

<p><span class="LaTeX">$G(s)=\prod_{k=1}^nG_k(s)\ =\ \frac{(s)_{\uparrow n}}{n!},$</span></p>
</center>

<p>which allow us to find again the product form for the generative series of the <a href="Stirling_numbers_of_the_first_kind" title="wikilink">Stirling numbers of the first kind</a> (unsigned).</p>
<h3 id="the-secretary-problem">The secretary problem</h3>

<p>This is an optimal stop problem, a classic in decision theory, statistics and applied probabilities, where a random permutation is gradually revealed through the first elements of its Lehmer code, and where the goal is to stop exactly at the element k such as σ(k)=n, whereas the only available information (the k first values of the Lehmer code) is not sufficient to compute σ(k).</p>

<p>In less mathematical words : a series of n applicants are interviewed one after the other. The interviewer must hire the best applicant, but must make his decision (“Hire” or “Not hire”) on the spot, without interviewing the next applicant (and <em>a fortiori</em> without interviewing all applicants).</p>

<p>The interviewer thus knows the rank of the k<sup>th</sup> applicant, therefore, at the moment of making his k<sup>th</sup> decision, the interviewer knows only the k first elements of the Lehmer code whereas he would need to know all of them to make a well informed decision. To determine the optimal strategies (i.e. the strategy maximizing the probability of a win), the statistical properties of the Lehmer code are crucial.</p>

<p>Allegedly, <a href="Johannes_Kepler" title="wikilink">Johannes Kepler</a> clearly exposed this <a href="secretary_problem" title="wikilink">secretary problem</a> to a friend of his at a time when he was trying to make up his mind and choose one out eleven prospective brides as his second wife. His first marriage had been an unhappy one, having been arranged without himself being consulted, and he was thus very concerned that he could reach the right decision.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Bernoulli_distribution" title="wikilink">Bernoulli distribution</a></li>
<li><a class="uri" href="Factoradic" title="wikilink">Factoradic</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="bibliography">Bibliography</h2>
<ul>
<li></li>
<li>{{ Citation</li>
</ul>

<p><code>| last1=Knuth</code><br/>
<code>| first1=Don</code><br/>
<code>| title=The art of computer programming</code><br/>
<code>| volume=3</code><br/>
<code>| publisher=Addison-Wesley</code><br/>
<code>| place=Reading</code><br/>
<code>| year=1981</code><br/>
<code>| pages=12–13</code></p>

<p>}}</p>

<p>"</p>

<p><a class="uri" href="Category:Combinatorics" title="wikilink">Category:Combinatorics</a> <a class="uri" href="Category:Permutations" title="wikilink">Category:Permutations</a> <a href="Category:Resampling_(statistics)" title="wikilink">Category:Resampling (statistics)</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"><a class="uri" href="http://www.math.upenn.edu/~ted/210F10/References/Secretary.pdf">http://www.math.upenn.edu/~ted/210F10/References/Secretary.pdf</a><a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
