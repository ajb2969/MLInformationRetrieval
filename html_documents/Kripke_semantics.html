<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1061">Kripke semantics</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Kripke semantics</h1>
<hr/>

<p><strong>Kripke semantics</strong> (also known as <strong>relational semantics</strong> or <strong>frame semantics</strong>, and often confused with <a href="possible_world_semantics" title="wikilink">possible world semantics</a>) is a formal <a class="uri" href="semantics" title="wikilink">semantics</a> for <a href="non-classical_logic" title="wikilink">non-classical logic</a> systems created in the late 1950s and early 1960s by <a href="Saul_Kripke" title="wikilink">Saul Kripke</a> and <a href="André_Joyal" title="wikilink">André Joyal</a>. It was first conceived for <a href="modal_logic" title="wikilink">modal logics</a>, and later adapted to <a href="intuitionistic_logic" title="wikilink">intuitionistic logic</a> and other non-classical systems. The discovery of Kripke semantics was a breakthrough in the theory of non-classical logics, because the <a href="model_theory" title="wikilink">model theory</a> of such logics was almost non-existent before Kripke (algebraic semantics existed, but were considered 'syntax in disguise').</p>
<h2 id="semantics-of-modal-logic">Semantics of modal logic</h2>

<p>The language of propositional modal logic consists of a <a href="countable_set" title="wikilink">countably infinite set</a> of <a href="propositional_variable" title="wikilink">propositional variables</a>, a set of truth-functional <a href="Logical_connective" title="wikilink">connectives</a> (in this article 

<math display="inline" id="Kripke_semantics:0">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \to
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Kripke_semantics:1">
 <semantics>
  <mi mathvariant="normal">¬</mi>
  <annotation-xml encoding="MathML-Content">
   <not></not>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg
  </annotation>
 </semantics>
</math>

), and the modal operator 

<math display="inline" id="Kripke_semantics:2">
 <semantics>
  <mi mathvariant="normal">□</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-□</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box
  </annotation>
 </semantics>
</math>

 ("necessarily"). The modal operator 

<math display="inline" id="Kripke_semantics:3">
 <semantics>
  <mi mathvariant="normal">◇</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-◇</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Diamond
  </annotation>
 </semantics>
</math>


 ("possibly") is (classically) the <a href="duality_(mathematics)#Duality_in_logic_and_set_theory" title="wikilink">dual</a> of 

<math display="inline" id="Kripke_semantics:4">
 <semantics>
  <mi mathvariant="normal">□</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-□</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box
  </annotation>
 </semantics>
</math>

 and <a href="Classical_modal_logic" title="wikilink">may be defined</a> in terms of necessity like so

<math display="block" id="Kripke_semantics:5">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">◇</mi>
    <mi>A</mi>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi mathvariant="normal">□</mi>
    <mi mathvariant="normal">¬</mi>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>normal-◇</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>normal-□</ci>
     <not></not>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Diamond A:=\neg\Box\neg A
  </annotation>
 </semantics>
</math>

 ("possibly A" is defined as equivalent to "not necessarily not A").<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h3 id="basic-definitions">Basic definitions</h3>

<p>A <strong>Kripke frame</strong> or <strong>modal frame</strong> is a pair 

<math display="inline" id="Kripke_semantics:6">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>W</mi>
   <mo>,</mo>
   <mi>R</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>W</ci>
    <ci>R</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle W,R\rangle
  </annotation>
 </semantics>
</math>

, where <em>W</em> is a (possibly empty) set, and <em>R</em> is a <a href="binary_relation" title="wikilink">binary relation</a> on <em>W</em>. Elements of <em>W</em> are called <em>nodes</em> or <em>worlds</em>, and <em>R</em> is known as the <a href="accessibility_relation" title="wikilink">accessibility relation</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>A <strong>Kripke model</strong> is a triple 

<math display="inline" id="Kripke_semantics:7">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>W</mi>
   <mo>,</mo>
   <mi>R</mi>
   <mo>,</mo>
   <mo>⊩</mo>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>W</ci>
    <ci>R</ci>
    <csymbol cd="latexml">forces</csymbol>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle W,R,\Vdash\rangle
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Kripke_semantics:8">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>W</mi>
   <mo>,</mo>
   <mi>R</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>W</ci>
    <ci>R</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle W,R\rangle
  </annotation>
 </semantics>
</math>


 is a Kripke frame, and 

<math display="inline" id="Kripke_semantics:9">
 <semantics>
  <mo>⊩</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">forces</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Vdash
  </annotation>
 </semantics>
</math>

 is a relation between nodes of <em>W</em> and modal formulas, such that:</p>
<ul>
<li>

<math display="inline" id="Kripke_semantics:10">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <not></not>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash\neg A
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Kripke_semantics:11">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊮</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">not-forces</csymbol>
    <ci>w</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\nVdash A
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Kripke_semantics:12">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mi>A</mi>
   <mo>→</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">forces</csymbol>
     <ci>w</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash A\to B
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Kripke_semantics:13">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊮</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">not-forces</csymbol>
    <ci>w</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\nVdash A
  </annotation>
 </semantics>
</math>


 or 

<math display="inline" id="Kripke_semantics:14">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash B
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Kripke_semantics:15">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash\Box A
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Kripke_semantics:16">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>⊩</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>u</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\Vdash A
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="Kripke_semantics:17">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Kripke_semantics:18">
 <semantics>
  <mrow>
   <mpadded width="+2.8pt">
    <mi>w</mi>
   </mpadded>
   <mpadded width="+2.8pt">
    <mi>R</mi>
   </mpadded>
   <mi>u</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>w</ci>
    <ci>R</ci>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\;R\;u
  </annotation>
 </semantics>
</math>


.</li>
</ul>

<p>We read 

<math display="inline" id="Kripke_semantics:19">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash A
  </annotation>
 </semantics>
</math>

 as “<em>w</em> satisfies <em>A</em>”, “<em>A</em> is satisfied in <em>w</em>”, or “<em>w</em> forces <em>A</em>”. The relation 

<math display="inline" id="Kripke_semantics:20">
 <semantics>
  <mo>⊩</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">forces</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Vdash
  </annotation>
 </semantics>
</math>

 is called the <em>satisfaction relation</em>, <em>evaluation</em>, or <em><a href="Forcing_(mathematics)" title="wikilink">forcing</a> relation</em>. The satisfaction relation is uniquely determined by its value on propositional variables.</p>

<p>A formula <em>A</em> is <strong>valid</strong> in:</p>
<ul>
<li>a model 

<math display="inline" id="Kripke_semantics:21">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>W</mi>
   <mo>,</mo>
   <mi>R</mi>
   <mo>,</mo>
   <mo>⊩</mo>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>W</ci>
    <ci>R</ci>
    <csymbol cd="latexml">forces</csymbol>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle W,R,\Vdash\rangle
  </annotation>
 </semantics>
</math>

, if 

<math display="inline" id="Kripke_semantics:22">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash A
  </annotation>
 </semantics>
</math>

 for all <em>w</em> ∈ <em>W</em>,</li>
<li>a frame 

<math display="inline" id="Kripke_semantics:23">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>W</mi>
   <mo>,</mo>
   <mi>R</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>W</ci>
    <ci>R</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle W,R\rangle
  </annotation>
 </semantics>
</math>


, if it is valid in 

<math display="inline" id="Kripke_semantics:24">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>W</mi>
   <mo>,</mo>
   <mi>R</mi>
   <mo>,</mo>
   <mo>⊩</mo>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>W</ci>
    <ci>R</ci>
    <csymbol cd="latexml">forces</csymbol>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle W,R,\Vdash\rangle
  </annotation>
 </semantics>
</math>

 for all possible choices of 

<math display="inline" id="Kripke_semantics:25">
 <semantics>
  <mo>⊩</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">forces</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Vdash
  </annotation>
 </semantics>
</math>

,</li>
<li>a class <em>C</em> of frames or models, if it is valid in every member of <em>C</em>.</li>
</ul>

<p>We define Thm(<em>C</em>) to be the set of all formulas that are valid in <em>C</em>. Conversely, if <em>X</em> is a set of formulas, let Mod(<em>X</em>) be the class of all frames which validate every formula from <em>X</em>.</p>

<p>A modal logic (i.e., a set of formulas) <em>L</em> is <strong><a href="Soundness" title="wikilink">sound</a></strong> with respect to a class of frames <em>C</em>, if <em>L</em> ⊆ Thm(<em>C</em>). <em>L</em> is <strong><a href="Completeness_(logic)" title="wikilink">complete</a></strong> wrt <em>C</em> if <em>L</em> ⊇ Thm(<em>C</em>).</p>
<h3 id="correspondence-and-completeness">Correspondence and completeness</h3>

<p>Semantics is useful for investigating a logic (i.e. a <a href="Formal_system" title="wikilink">derivation system</a>) only if the <a href="Logical_consequence#Semantic_consequence" title="wikilink">semantic consequence</a> relation reflects its syntactical counterpart, the <em><a href="Logical_consequence#Syntactic_consequence" title="wikilink">syntactic consequence</a></em> relation (<em>derivability</em>).<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> It is vital to know which modal logics are sound and complete with respect to a class of Kripke frames, and to determine also which class that is.</p>

<p>For any class <em>C</em> of Kripke frames, Thm(<em>C</em>) is a <a href="normal_modal_logic" title="wikilink">normal modal logic</a> (in particular, theorems of the minimal normal modal logic, <em>K</em>, are valid in every Kripke model). However, the converse does not hold in general: while most of the modal systems studied are complete of classes of frames described by simple conditions, Kripke incomplete normal modal logics do exist. A natural example of such a system is <a href="Japaridze's_Polymodal_Logic" title="wikilink">Japaridze's Polymodal Logic</a>.</p>

<p>A normal modal logic <em>L</em> <strong>corresponds</strong> to a class of frames <em>C</em>, if <em>C</em> = Mod(<em>L</em>). In other words, <em>C</em> is the largest class of frames such that <em>L</em> is sound wrt <em>C</em>. It follows that <em>L</em> is Kripke complete if and only if it is complete of its corresponding class.</p>

<p>Consider the schema <strong>T</strong> 

<math display="block" id="Kripke_semantics:26">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <mi>A</mi>
   </mrow>
   <mo>→</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <ci>A</ci>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box A\to A
  </annotation>
 </semantics>
</math>

. <strong>T</strong> is valid in any <a href="reflexive_relation" title="wikilink">reflexive</a> frame 

<math display="inline" id="Kripke_semantics:27">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>W</mi>
   <mo>,</mo>
   <mi>R</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>W</ci>
    <ci>R</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle W,R\rangle
  </annotation>
 </semantics>
</math>

: if 

<math display="inline" id="Kripke_semantics:28">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash\Box A
  </annotation>
 </semantics>
</math>


, then 

<math display="inline" id="Kripke_semantics:29">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash A
  </annotation>
 </semantics>
</math>

 since <em>w</em> <em>R</em> <em>w</em>. On the other hand, a frame which validates <strong>T</strong> has to be reflexive: fix <em>w</em> ∈ <em>W</em>, and define satisfaction of a propositional variable <em>p</em> as follows: 

<math display="inline" id="Kripke_semantics:30">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>⊩</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>u</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\Vdash p
  </annotation>
 </semantics>
</math>

 if and only if <em>w</em> <em>R</em> <em>u</em>. Then 

<math display="inline" id="Kripke_semantics:31">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash\Box p
  </annotation>
 </semantics>
</math>

, thus 

<math display="inline" id="Kripke_semantics:32">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash p
  </annotation>
 </semantics>
</math>

 by <strong>T</strong>, which means <em>w</em> <em>R</em> <em>w</em> using the definition of 

<math display="inline" id="Kripke_semantics:33">
 <semantics>
  <mo>⊩</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">forces</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Vdash
  </annotation>
 </semantics>
</math>


. <strong>T</strong> corresponds to the class of reflexive Kripke frames.</p>

<p>It is often much easier to characterize the corresponding class of <em>L</em> than to prove its completeness, thus correspondence serves as a guide to completeness proofs. Correspondence is also used to show <em>incompleteness</em> of modal logics: suppose <em>L</em><sub>1</sub> ⊆ <em>L</em><sub>2</sub> are normal modal logics that correspond to the same class of frames, but <em>L</em><sub>1</sub> does not prove all theorems of <em>L</em><sub>2</sub>. Then <em>L</em><sub>1</sub> is Kripke incomplete. For example, the schema 

<math display="inline" id="Kripke_semantics:34">
 <semantics>
  <mrow>
   <mi mathvariant="normal">□</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>↔</mo>
    <mi mathvariant="normal">□</mi>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi mathvariant="normal">□</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">□</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-↔</ci>
     <csymbol cd="unknown">□</csymbol>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">□</csymbol>
    <csymbol cd="unknown">A</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box(A\leftrightarrow\Box A)\to\Box A
  </annotation>
 </semantics>
</math>

 generates an incomplete logic, as it corresponds to the same class of frames as <strong>GL</strong> (viz. transitive and converse well-founded frames), but does not prove the <strong>GL</strong>-tautology 

<math display="inline" id="Kripke_semantics:35">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <mi>A</mi>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <mi mathvariant="normal">□</mi>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <ci>normal-□</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box A\to\Box\Box A
  </annotation>
 </semantics>
</math>

.</p>

<p>The table below is a list of common modal axioms together with their corresponding classes. The naming of the axioms often varies.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Common modal axiom schemata</strong></p></td>
<td style="text-align: left;">
<p>Name</p></td>
<td style="text-align: left;">
<p>Axiom</p></td>
<td style="text-align: left;">
<p>Frame condition</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>K</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Kripke_semantics:36">
 <semantics>
  <mrow>
   <mi mathvariant="normal">□</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">□</mi>
    <mi>A</mi>
    <mo>→</mo>
    <mi mathvariant="normal">□</mi>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">□</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">□</csymbol>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">□</csymbol>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box(A\to B)\to(\Box A\to\Box B)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>N/A</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Kripke_semantics:37">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <mi>A</mi>
   </mrow>
   <mo>→</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <ci>A</ci>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box A\to A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><a href="reflexive_relation" title="wikilink">reflexive</a>

<math display="block" id="Kripke_semantics:38">
 <semantics>
  <mrow>
   <mpadded width="+1.7pt">
    <mi>w</mi>
   </mpadded>
   <mpadded width="+1.7pt">
    <mi>R</mi>
   </mpadded>
   <mi>w</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>w</ci>
    <ci>R</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\,R\,w
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Kripke_semantics:39">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <mi>A</mi>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <mi mathvariant="normal">□</mi>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <ci>normal-□</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box A\to\Box\Box A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><a href="transitive_relation" title="wikilink">transitive</a>

<math display="block" id="Kripke_semantics:40">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>w</mi>
     </mpadded>
     <mpadded width="+1.7pt">
      <mi>R</mi>
     </mpadded>
     <mi>v</mi>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>v</mi>
     </mpadded>
     <mpadded width="+1.7pt">
      <mi>R</mi>
     </mpadded>
     <mi>u</mi>
    </mrow>
   </mrow>
   <mo>⇒</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>w</mi>
    </mpadded>
    <mpadded width="+1.7pt">
     <mi>R</mi>
    </mpadded>
    <mi>u</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇒</ci>
    <apply>
     <and></and>
     <apply>
      <times></times>
      <ci>w</ci>
      <ci>R</ci>
      <ci>v</ci>
     </apply>
     <apply>
      <times></times>
      <ci>v</ci>
      <ci>R</ci>
      <ci>u</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>w</ci>
     <ci>R</ci>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\,R\,v\wedge v\,R\,u\Rightarrow w\,R\,u
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Kripke_semantics:41">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <mi mathvariant="normal">□</mi>
    <mi>A</mi>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <ci>normal-□</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box\Box A\to\Box A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><a href="dense_relation" title="wikilink">dense</a>

<math display="block" id="Kripke_semantics:42">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>w</mi>
    </mpadded>
    <mpadded width="+1.7pt">
     <mi>R</mi>
    </mpadded>
    <mi>u</mi>
   </mrow>
   <mo>⇒</mo>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>v</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mpadded width="+1.7pt">
         <mi>w</mi>
        </mpadded>
        <mpadded width="+1.7pt">
         <mi>R</mi>
        </mpadded>
        <mi>v</mi>
       </mrow>
       <mo>∧</mo>
       <mrow>
        <mpadded width="+1.7pt">
         <mi>v</mi>
        </mpadded>
        <mpadded width="+1.7pt">
         <mi>R</mi>
        </mpadded>
        <mi>u</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇒</ci>
    <apply>
     <times></times>
     <ci>w</ci>
     <ci>R</ci>
     <ci>u</ci>
    </apply>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>v</ci>
      <apply>
       <and></and>
       <apply>
        <times></times>
        <ci>w</ci>
        <ci>R</ci>
        <ci>v</ci>
       </apply>
       <apply>
        <times></times>
        <ci>v</ci>
        <ci>R</ci>
        <ci>u</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\,R\,u\Rightarrow\exists v\,(w\,R\,v\land v\,R\,u)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>D</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Kripke_semantics:43">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <mi>A</mi>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi mathvariant="normal">◇</mi>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-◇</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box A\to\Diamond A
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Kripke_semantics:44">
 <semantics>
  <mrow>
   <mi mathvariant="normal">◇</mi>
   <mo>⊤</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">limit-from</csymbol>
    <ci>normal-◇</ci>
    <csymbol cd="latexml">top</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Diamond\top
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><a href="serial_relation" title="wikilink">serial</a>

<math display="block" id="Kripke_semantics:45">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>w</mi>
    </mpadded>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mi>v</mi>
      </mpadded>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mpadded width="+1.7pt">
         <mi>w</mi>
        </mpadded>
        <mpadded width="+1.7pt">
         <mi>R</mi>
        </mpadded>
        <mi>v</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <times></times>
     <ci>w</ci>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <ci>v</ci>
       <apply>
        <times></times>
        <ci>w</ci>
        <ci>R</ci>
        <ci>v</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall w\,\exists v\,(w\,R\,v)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>B</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Kripke_semantics:46">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>→</mo>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <mi mathvariant="normal">◇</mi>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <ci>normal-◇</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\to\Box\Diamond A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><a href="symmetric_relation" title="wikilink">symmetric</a> 

<math display="block" id="Kripke_semantics:47">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>w</mi>
    </mpadded>
    <mpadded width="+1.7pt">
     <mi>R</mi>
    </mpadded>
    <mi>v</mi>
   </mrow>
   <mo>⇒</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>v</mi>
    </mpadded>
    <mpadded width="+1.7pt">
     <mi>R</mi>
    </mpadded>
    <mi>w</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇒</ci>
    <apply>
     <times></times>
     <ci>w</ci>
     <ci>R</ci>
     <ci>v</ci>
    </apply>
    <apply>
     <times></times>
     <ci>v</ci>
     <ci>R</ci>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\,R\,v\Rightarrow v\,R\,w
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Kripke_semantics:48">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">◇</mi>
    <mi>A</mi>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <mi mathvariant="normal">◇</mi>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>normal-◇</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <ci>normal-◇</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Diamond A\to\Box\Diamond A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><a href="Euclidean_relation" title="wikilink">Euclidean</a>

<math display="block" id="Kripke_semantics:49">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>w</mi>
     </mpadded>
     <mpadded width="+1.7pt">
      <mi>R</mi>
     </mpadded>
     <mi>u</mi>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>w</mi>
     </mpadded>
     <mpadded width="+1.7pt">
      <mi>R</mi>
     </mpadded>
     <mi>v</mi>
    </mrow>
   </mrow>
   <mo>⇒</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>u</mi>
    </mpadded>
    <mpadded width="+1.7pt">
     <mi>R</mi>
    </mpadded>
    <mi>v</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇒</ci>
    <apply>
     <and></and>
     <apply>
      <times></times>
      <ci>w</ci>
      <ci>R</ci>
      <ci>u</ci>
     </apply>
     <apply>
      <times></times>
      <ci>w</ci>
      <ci>R</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>u</ci>
     <ci>R</ci>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\,R\,u\land w\,R\,v\Rightarrow u\,R\,v
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>GL</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Kripke_semantics:50">
 <semantics>
  <mrow>
   <mi mathvariant="normal">□</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">□</mi>
    <mi>A</mi>
    <mo>→</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi mathvariant="normal">□</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">□</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">□</csymbol>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">□</csymbol>
    <csymbol cd="unknown">A</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box(\Box A\to A)\to\Box A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><em>R</em> transitive, <em>R</em><sup>−1</sup> <a class="uri" href="well-founded" title="wikilink">well-founded</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Grz</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Kripke_semantics:51">
 <semantics>
  <mrow>
   <mi mathvariant="normal">□</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">□</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>→</mo>
     <mi mathvariant="normal">□</mi>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">□</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">□</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">□</csymbol>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">A</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box(\Box(A\to\Box A)\to A)\to A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><em>R</em> reflexive and transitive, <em>R</em><sup>−1</sup>−<em>Id</em> well-founded</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>H</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Kripke_semantics:52">
 <semantics>
  <mrow>
   <mi mathvariant="normal">□</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">□</mi>
    <mi>A</mi>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∨</mo>
   <mi mathvariant="normal">□</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">□</mi>
    <mi>B</mi>
    <mo>→</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">□</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">□</csymbol>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <or></or>
    <csymbol cd="unknown">□</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">□</csymbol>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box(\Box A\to B)\lor\Box(\Box B\to A)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Kripke_semantics:53">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>w</mi>
     </mpadded>
     <mpadded width="+1.7pt">
      <mi>R</mi>
     </mpadded>
     <mi>u</mi>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>w</mi>
     </mpadded>
     <mpadded width="+1.7pt">
      <mi>R</mi>
     </mpadded>
     <mi>v</mi>
    </mrow>
   </mrow>
   <mo>⇒</mo>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>u</mi>
     </mpadded>
     <mpadded width="+1.7pt">
      <mi>R</mi>
     </mpadded>
     <mi>v</mi>
    </mrow>
    <mo>∨</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>v</mi>
     </mpadded>
     <mpadded width="+1.7pt">
      <mi>R</mi>
     </mpadded>
     <mi>u</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇒</ci>
    <apply>
     <and></and>
     <apply>
      <times></times>
      <ci>w</ci>
      <ci>R</ci>
      <ci>u</ci>
     </apply>
     <apply>
      <times></times>
      <ci>w</ci>
      <ci>R</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <or></or>
     <apply>
      <times></times>
      <ci>u</ci>
      <ci>R</ci>
      <ci>v</ci>
     </apply>
     <apply>
      <times></times>
      <ci>v</ci>
      <ci>R</ci>
      <ci>u</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\,R\,u\land w\,R\,v\Rightarrow u\,R\,v\lor v\,R\,u
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>M</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Kripke_semantics:54">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <mi mathvariant="normal">◇</mi>
    <mi>A</mi>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi mathvariant="normal">◇</mi>
    <mi mathvariant="normal">□</mi>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <ci>normal-◇</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-◇</ci>
     <ci>normal-□</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box\Diamond A\to\Diamond\Box A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>(a complicated <a href="second-order_logic" title="wikilink">second-order</a> property)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>G</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Kripke_semantics:55">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">◇</mi>
    <mi mathvariant="normal">□</mi>
    <mi>A</mi>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <mi mathvariant="normal">◇</mi>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>normal-◇</ci>
     <ci>normal-□</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <ci>normal-◇</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Diamond\Box A\to\Box\Diamond A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>convergent

<math display="block" id="Kripke_semantics:56">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>w</mi>
     </mpadded>
     <mpadded width="+1.7pt">
      <mi>R</mi>
     </mpadded>
     <mi>u</mi>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>w</mi>
     </mpadded>
     <mpadded width="+1.7pt">
      <mi>R</mi>
     </mpadded>
     <mi>v</mi>
    </mrow>
   </mrow>
   <mo>⇒</mo>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>x</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mpadded width="+1.7pt">
         <mi>u</mi>
        </mpadded>
        <mpadded width="+1.7pt">
         <mi>R</mi>
        </mpadded>
        <mi>x</mi>
       </mrow>
       <mo>∧</mo>
       <mrow>
        <mpadded width="+1.7pt">
         <mi>v</mi>
        </mpadded>
        <mpadded width="+1.7pt">
         <mi>R</mi>
        </mpadded>
        <mi>x</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇒</ci>
    <apply>
     <and></and>
     <apply>
      <times></times>
      <ci>w</ci>
      <ci>R</ci>
      <ci>u</ci>
     </apply>
     <apply>
      <times></times>
      <ci>w</ci>
      <ci>R</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>x</ci>
      <apply>
       <and></and>
       <apply>
        <times></times>
        <ci>u</ci>
        <ci>R</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <times></times>
        <ci>v</ci>
        <ci>R</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\,R\,u\land w\,R\,v\Rightarrow\exists x\,(u\,R\,x\land v\,R\,x)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Kripke_semantics:57">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>→</mo>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\to\Box A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Kripke_semantics:58">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>w</mi>
    </mpadded>
    <mpadded width="+1.7pt">
     <mi>R</mi>
    </mpadded>
    <mi>v</mi>
   </mrow>
   <mo>⇒</mo>
   <mi>w</mi>
   <mo>=</mo>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-⇒</ci>
     <apply>
      <times></times>
      <ci>w</ci>
      <ci>R</ci>
      <ci>v</ci>
     </apply>
     <ci>w</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\,R\,v\Rightarrow w=v
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Kripke_semantics:59">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">◇</mi>
    <mi>A</mi>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>normal-◇</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Diamond A\to\Box A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p><a href="partial_function" title="wikilink">partial function</a>

<math display="block" id="Kripke_semantics:60">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>w</mi>
     </mpadded>
     <mpadded width="+1.7pt">
      <mi>R</mi>
     </mpadded>
     <mi>u</mi>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>w</mi>
     </mpadded>
     <mpadded width="+1.7pt">
      <mi>R</mi>
     </mpadded>
     <mi>v</mi>
    </mrow>
   </mrow>
   <mo>⇒</mo>
   <mi>u</mi>
   <mo>=</mo>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-⇒</ci>
     <apply>
      <and></and>
      <apply>
       <times></times>
       <ci>w</ci>
       <ci>R</ci>
       <ci>u</ci>
      </apply>
      <apply>
       <times></times>
       <ci>w</ci>
       <ci>R</ci>
       <ci>v</ci>
      </apply>
     </apply>
     <ci>u</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\,R\,u\land w\,R\,v\Rightarrow u=v
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Kripke_semantics:61">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">◇</mi>
    <mi>A</mi>
   </mrow>
   <mo>↔</mo>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <apply>
     <times></times>
     <ci>normal-◇</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Diamond A\leftrightarrow\Box A
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>function

<math display="block" id="Kripke_semantics:62">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>w</mi>
    </mpadded>
    <mrow>
     <mrow>
      <mo>∃</mo>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
     <mrow>
      <mpadded width="+1.7pt">
       <mi>u</mi>
      </mpadded>
      <mpadded width="+1.7pt">
       <mi>w</mi>
      </mpadded>
      <mpadded width="+1.7pt">
       <mi>R</mi>
      </mpadded>
      <mi>u</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <times></times>
     <ci>w</ci>
     <apply>
      <apply>
       <factorial></factorial>
       <exists></exists>
      </apply>
      <apply>
       <times></times>
       <ci>u</ci>
       <ci>w</ci>
       <ci>R</ci>
       <ci>u</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall w\,\exists!u\,w\,R\,u
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Kripke_semantics:63">
 <semantics>
  <mrow>
   <mi mathvariant="normal">□</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-□</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box A
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Kripke_semantics:64">
 <semantics>
  <mrow>
   <mi mathvariant="normal">□</mi>
   <mo>⊥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">limit-from</csymbol>
    <ci>normal-□</ci>
    <csymbol cd="latexml">bottom</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box\bot
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>empty

<math display="block" id="Kripke_semantics:65">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>w</mi>
    </mpadded>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mi>u</mi>
      </mpadded>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mpadded width="+1.7pt">
          <mi>w</mi>
         </mpadded>
         <mpadded width="+1.7pt">
          <mi>R</mi>
         </mpadded>
         <mi>u</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <times></times>
     <ci>w</ci>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <ci>u</ci>
       <apply>
        <not></not>
        <apply>
         <times></times>
         <ci>w</ci>
         <ci>R</ci>
         <ci>u</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall w\,\forall u\,\neg(w\,R\,u)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
</tr>
</tbody>
</table>

<p>Here is a list of several common modal systems. Frame conditions for some of them were simplified: the logics are <em>complete</em> with respect to the frame classes given in the table, but they may <em>correspond</em> to a larger class of frames.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>Common normal modal logics</strong></p></td>
<td style="text-align: left;">
<p>name</p></td>
<td style="text-align: left;">
<p>axioms</p></td>
<td style="text-align: left;">
<p>frame condition</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>K</p></td>
<td style="text-align: left;">
<p>—</p></td>
<td style="text-align: left;">
<p>all frames</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>T</p></td>
<td style="text-align: left;">
<p>reflexive</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>K4</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>transitive</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>S4</p></td>
<td style="text-align: left;">
<p>T, 4</p></td>
<td style="text-align: left;">
<p><a class="uri" href="preorder" title="wikilink">preorder</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="S5_(modal_logic)" title="wikilink">S5</a></p></td>
<td style="text-align: left;">
<p>T, 5 or D, B, 4</p></td>
<td style="text-align: left;">
<p><a href="equivalence_relation" title="wikilink">equivalence relation</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>S4.3</p></td>
<td style="text-align: left;">
<p>T, 4, H</p></td>
<td style="text-align: left;">
<p><a href="total_preorder" title="wikilink">total preorder</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>S4.1</p></td>
<td style="text-align: left;">
<p>T, 4, M</p></td>
<td style="text-align: left;">
<p>preorder, 

<math display="inline" id="Kripke_semantics:66">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mpadded width="+1.7pt">
    <mi>w</mi>
   </mpadded>
   <mo>∃</mo>
   <mpadded width="+1.7pt">
    <mi>u</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+1.7pt">
     <mi>w</mi>
    </mpadded>
    <mpadded width="+1.7pt">
     <mi>R</mi>
    </mpadded>
    <mi>u</mi>
    <mo>∧</mo>
    <mo>∀</mo>
    <mpadded width="+1.7pt">
     <mi>v</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mpadded width="+1.7pt">
      <mi>u</mi>
     </mpadded>
     <mpadded width="+1.7pt">
      <mi>R</mi>
     </mpadded>
     <mi>v</mi>
     <mo>⇒</mo>
     <mi>u</mi>
     <mo>=</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">w</csymbol>
    <exists></exists>
    <csymbol cd="unknown">u</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">w</csymbol>
     <csymbol cd="unknown">R</csymbol>
     <csymbol cd="unknown">u</csymbol>
     <and></and>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">v</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">u</csymbol>
      <csymbol cd="unknown">R</csymbol>
      <csymbol cd="unknown">v</csymbol>
      <ci>normal-⇒</ci>
      <csymbol cd="unknown">u</csymbol>
      <eq></eq>
      <csymbol cd="unknown">v</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall w\,\exists u\,(w\,R\,u\land\forall v\,(u\,R\,v\Rightarrow u=v))
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>S4.2</p></td>
<td style="text-align: left;">
<p>T, 4, G</p></td>
<td style="text-align: left;">
<p><a href="directed_set" title="wikilink">directed</a> preorder</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="provability_logic" title="wikilink">GL</a></p></td>
<td style="text-align: left;">
<p>GL or 4, GL</p></td>
<td style="text-align: left;">
<p>finite <a href="strict_order" title="wikilink">strict partial order</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Grz, S4Grz</p></td>
<td style="text-align: left;">
<p>Grz or T, 4, Grz</p></td>
<td style="text-align: left;">
<p>finite <a href="partial_order" title="wikilink">partial order</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>D</p></td>
<td style="text-align: left;">
<p>D</p></td>
<td style="text-align: left;">
<p>serial</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>D45</p></td>
<td style="text-align: left;">
<p>D, 4, 5</p></td>
<td style="text-align: left;">
<p>transitive, serial, and Euclidean</p></td>
</tr>
</tbody>
</table>
<h3 id="canonical-models">Canonical models</h3>

<p>For any normal modal logic, <em>L</em>, a Kripke model (called the <strong>canonical model</strong>) can be constructed that refutes precisely the non-theorems of <em>L</em>, by an adaptation of the standard technique of using <a href="maximal_consistent_set" title="wikilink">maximal consistent sets</a> as models. Canonical Kripke models play a role similar to the <a href="Lindenbaum–Tarski_algebra" title="wikilink">Lindenbaum–Tarski algebra</a> construction in algebraic semantics.</p>

<p>A set of formulas is <em>L</em>-<em>consistent</em> if no contradiction can be derived from it using the theorems of <em>L</em>, and Modus Ponens. A <em>maximal L-consistent set</em> (an <em>L</em>-<em>MCS</em> for short) is an <em>L</em>-consistent set that has no proper <em>L</em>-consistent superset.</p>

<p>The <strong>canonical model</strong> of <em>L</em> is a Kripke model 

<math display="inline" id="Kripke_semantics:67">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>W</mi>
   <mo>,</mo>
   <mi>R</mi>
   <mo>,</mo>
   <mo>⊩</mo>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>W</ci>
    <ci>R</ci>
    <csymbol cd="latexml">forces</csymbol>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle W,R,\Vdash\rangle
  </annotation>
 </semantics>
</math>

, where <em>W</em> is the set of all <em>L</em>-<em>MCS</em>, and the relations <em>R</em> and 

<math display="inline" id="Kripke_semantics:68">
 <semantics>
  <mo>⊩</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">forces</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Vdash
  </annotation>
 </semantics>
</math>

 are as follows:</p>

<p>

<math display="block" id="Kripke_semantics:69">
 <semantics>
  <mrow>
   <mpadded width="+2.8pt">
    <mi>X</mi>
   </mpadded>
   <mpadded width="+2.8pt">
    <mi>R</mi>
   </mpadded>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <ci>R</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\;R\;Y
  </annotation>
 </semantics>
</math>

 if and only if for every formula 

<math display="inline" id="Kripke_semantics:70">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, if 

<math display="inline" id="Kripke_semantics:71">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <mi>A</mi>
   </mrow>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <ci>A</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box A\in X
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Kripke_semantics:72">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∈</mo>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>A</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\in Y
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="block" id="Kripke_semantics:73">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>⊩</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>X</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\Vdash A
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Kripke_semantics:74">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>A</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\in X
  </annotation>
 </semantics>
</math>

. The canonical model is a model of <em>L</em>, as every <em>L</em>-<em>MCS</em> contains all theorems of <em>L</em>. By <a href="Zorn's_lemma" title="wikilink">Zorn's lemma</a>, each <em>L</em>-consistent set is contained in an <em>L</em>-<em>MCS</em>, in particular every formula unprovable in <em>L</em> has a counterexample in the canonical model.</p>

<p>The main application of canonical models are completeness proofs. Properties of the canonical model of <strong>K</strong> immediately imply completeness of <strong>K</strong> with respect to the class of all Kripke frames. This argument does <em>not</em> work for arbitrary <em>L</em>, because there is no guarantee that the underlying <em>frame</em> of the canonical model satisfies the frame conditions of <em>L</em>.</p>

<p>We say that a formula or a set <em>X</em> of formulas is <strong>canonical</strong> with respect to a property <em>P</em> of Kripke frames, if</p>
<ul>
<li><em>X</em> is valid in every frame that satisfies <em>P</em>,</li>
<li>for any normal modal logic <em>L</em> that contains <em>X</em>, the underlying frame of the canonical model of <em>L</em> satisfies <em>P</em>.</li>
</ul>

<p>A union of canonical sets of formulas is itself canonical. It follows from the preceding discussion that any logic axiomatized by a canonical set of formulas is Kripke complete, and <a href="compactness_theorem" title="wikilink">compact</a>.</p>

<p>The axioms T, 4, D, B, 5, H, G (and thus any combination of them) are canonical. GL and Grz are not canonical, because they are not compact. The axiom M by itself is not canonical (Goldblatt, 1991), but the combined logic <strong>S4.1</strong> (in fact, even <strong>K4.1</strong>) is canonical.</p>

<p>In general, it is <a href="decision_problem" title="wikilink">undecidable</a> whether a given axiom is canonical. We know a nice sufficient condition: Henrik Sahlqvist identified a broad class of formulas (now called <a href="Sahlqvist_formula" title="wikilink">Sahlqvist formulas</a>) such that</p>
<ul>
<li>a Sahlqvist formula is canonical,</li>
<li>the class of frames corresponding to a Sahlqvist formula is <a href="first-order_logic" title="wikilink">first-order</a> definable,</li>
<li>there is an algorithm that computes the corresponding frame condition to a given Sahlqvist formula.</li>
</ul>

<p>This is a powerful criterion: for example, all axioms listed above as canonical are (equivalent to) Sahlqvist formulas.</p>
<h3 id="finite-model-property">Finite model property</h3>

<p>A logic has the <strong><a href="finite_model_property" title="wikilink">finite model property</a></strong> (FMP) if it is complete with respect to a class of finite frames. An application of this notion is the <a href="decidability_(logic)" title="wikilink">decidability</a> question: it follows from <a href="Post's_theorem" title="wikilink">Post's theorem</a> that a recursively axiomatized modal logic <em>L</em> which has FMP is decidable, provided it is decidable whether a given finite frame is a model of <em>L</em>. In particular, every finitely axiomatizable logic with FMP is decidable.</p>

<p>There are various methods for establishing FMP for a given logic. Refinements and extensions of the canonical model construction often work, using tools such as <a href="#Model_constructions" title="wikilink">filtration</a> or <a href="#Model_constructions" title="wikilink">unravelling</a>. As another possibility, completeness proofs based on <a href="cut-elimination" title="wikilink">cut-free</a> <a href="sequent_calculus" title="wikilink">sequent calculi</a> usually produce finite models directly.</p>

<p>Most of the modal systems used in practice (including all listed above) have FMP.</p>

<p>In some cases, we can use FMP to prove Kripke completeness of a logic: every normal modal logic is complete with respect to a class of <a href="modal_algebra" title="wikilink">modal algebras</a>, and a <em>finite</em> modal algebra can be transformed into a Kripke frame. As an example, Robert Bull proved using this method that every normal extension of <strong>S4.3</strong> has FMP, and is Kripke complete.</p>
<h3 id="multimodal-logics">Multimodal logics</h3>

<p>Kripke semantics has a straightforward generalization to logics with more than one modality. A Kripke frame for a language with 

<math display="inline" id="Kripke_semantics:75">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi mathvariant="normal">□</mi>
    <mi>i</mi>
   </msub>
   <mo rspace="4.2pt">∣</mo>
   <mrow>
    <mi>i</mi>
    <mo>∈</mo>
    <mi>I</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-□</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <in></in>
     <ci>i</ci>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\Box_{i}\mid\,i\in I\}
  </annotation>
 </semantics>
</math>

 as the set of its necessity operators consists of a non-empty set <em>W</em> equipped with binary relations <em>R<sub>i</sub></em> for each <em>i</em> ∈ <em>I</em>. The definition of a satisfaction relation is modified as follows:</p>

<p>

<math display="block" id="Kripke_semantics:76">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mrow>
    <msub>
     <mi mathvariant="normal">□</mi>
     <mi>i</mi>
    </msub>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-□</ci>
      <ci>i</ci>
     </apply>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash\Box_{i}A
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Kripke_semantics:77">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mpadded width="+1.7pt">
    <mi>u</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+2.8pt">
     <mi>w</mi>
    </mpadded>
    <mpadded width="+2.8pt">
     <msub>
      <mi>R</mi>
      <mi>i</mi>
     </msub>
    </mpadded>
    <mi>u</mi>
    <mo>⇒</mo>
    <mi>u</mi>
    <mo>⊩</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">u</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">w</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>i</ci>
     </apply>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">u</csymbol>
     <csymbol cd="latexml">forces</csymbol>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall u\,(w\;R_{i}\;u\Rightarrow u\Vdash A).
  </annotation>
 </semantics>
</math>

</p>

<p>A simplified semantics, discovered by Tim Carlson, is often used for polymodal <a href="provability_logic" title="wikilink">provability logics</a>. A <strong>Carlson model</strong> is a structure 

<math display="inline" id="Kripke_semantics:78">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>W</mi>
   <mo>,</mo>
   <mi>R</mi>
   <mo>,</mo>
   <msub>
    <mrow>
     <mo stretchy="false">{</mo>
     <msub>
      <mi>D</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mrow>
     <mi>i</mi>
     <mo>∈</mo>
     <mi>I</mi>
    </mrow>
   </msub>
   <mo>,</mo>
   <mo>⊩</mo>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>W</ci>
    <ci>R</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>D</ci>
       <ci>i</ci>
      </apply>
     </set>
     <apply>
      <in></in>
      <ci>i</ci>
      <ci>I</ci>
     </apply>
    </apply>
    <csymbol cd="latexml">forces</csymbol>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle W,R,\{D_{i}\}_{i\in I},\Vdash\rangle
  </annotation>
 </semantics>
</math>

 with a single accessibility relation <em>R</em>, and subsets <em>D<sub>i</sub></em> ⊆ <em>W</em> for each modality. Satisfaction is defined as</p>

<p>

<math display="block" id="Kripke_semantics:79">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mrow>
    <msub>
     <mi mathvariant="normal">□</mi>
     <mi>i</mi>
    </msub>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-□</ci>
      <ci>i</ci>
     </apply>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash\Box_{i}A
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Kripke_semantics:80">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>u</mi>
   <mo>∈</mo>
   <mpadded width="+1.7pt">
    <msub>
     <mi>D</mi>
     <mi>i</mi>
    </msub>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mpadded width="+2.8pt">
     <mi>w</mi>
    </mpadded>
    <mpadded width="+2.8pt">
     <mi>R</mi>
    </mpadded>
    <mi>u</mi>
    <mo>⇒</mo>
    <mi>u</mi>
    <mo>⊩</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">u</csymbol>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <ci>i</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">w</csymbol>
     <csymbol cd="unknown">R</csymbol>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">u</csymbol>
     <csymbol cd="latexml">forces</csymbol>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall u\in D_{i}\,(w\;R\;u\Rightarrow u\Vdash A).
  </annotation>
 </semantics>
</math>

</p>

<p>Carlson models are easier to visualize and to work with than usual polymodal Kripke models; there are, however, Kripke complete polymodal logics which are Carlson incomplete.</p>
<h2 id="semantics-of-intuitionistic-logic">Semantics of intuitionistic logic</h2>

<p>Kripke semantics for the <a href="intuitionistic_logic" title="wikilink">intuitionistic logic</a> follows the same principles as the semantics of modal logic, but it uses a different definition of satisfaction.</p>

<p>An <strong>intuitionistic Kripke model</strong> is a triple 

<math display="inline" id="Kripke_semantics:81">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>W</mi>
   <mo>,</mo>
   <mo>≤</mo>
   <mo>,</mo>
   <mo>⊩</mo>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>W</ci>
    <leq></leq>
    <csymbol cd="latexml">forces</csymbol>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle W,\leq,\Vdash\rangle
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Kripke_semantics:82">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>W</mi>
   <mo>,</mo>
   <mo>≤</mo>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>W</ci>
    <leq></leq>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle W,\leq\rangle
  </annotation>
 </semantics>
</math>

 is a <a href="Preorder" title="wikilink">preordered</a> Kripke frame, and 

<math display="inline" id="Kripke_semantics:83">
 <semantics>
  <mo>⊩</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">forces</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Vdash
  </annotation>
 </semantics>
</math>

 satisfies the following conditions:</p>
<ul>
<li>if <em>p</em> is a propositional variable, 

<math display="inline" id="Kripke_semantics:84">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>≤</mo>
   <mi>u</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>w</ci>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\leq u
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Kripke_semantics:85">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash p
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Kripke_semantics:86">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>⊩</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>u</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\Vdash p
  </annotation>
 </semantics>
</math>

 (<em>persistency</em> condition (cf. <a class="uri" href="monotonicity" title="wikilink">monotonicity</a>)),</li>
<li>

<math display="inline" id="Kripke_semantics:87">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mrow>
    <mi>A</mi>
    <mo>∧</mo>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <apply>
     <and></and>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash A\land B
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Kripke_semantics:88">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Kripke_semantics:89">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash B
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Kripke_semantics:90">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mrow>
    <mi>A</mi>
    <mo>∨</mo>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <apply>
     <or></or>
     <ci>A</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash A\lor B
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Kripke_semantics:91">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash A
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Kripke_semantics:92">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash B
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Kripke_semantics:93">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mi>A</mi>
   <mo>→</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">forces</csymbol>
     <ci>w</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash A\to B
  </annotation>
 </semantics>
</math>

 if and only if for all 

<math display="inline" id="Kripke_semantics:94">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>≥</mo>
   <mi>w</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>u</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\geq w
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Kripke_semantics:95">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>⊩</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>u</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\Vdash A
  </annotation>
 </semantics>
</math>

 implies 

<math display="inline" id="Kripke_semantics:96">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>⊩</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>u</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\Vdash B
  </annotation>
 </semantics>
</math>

,</li>
<li>not 

<math display="inline" id="Kripke_semantics:97">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mo>⊥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <csymbol cd="latexml">bottom</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash\bot
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>The negation of <em>A</em>, ¬<em>A</em>, could be defined as an abbreviation for <em>A</em> → ⊥. If for all <em>u</em> such that <em>w</em> ≤ <em>u</em>, not <em>u</em> <big>⊩</big> <em>A</em>, then <em>w</em> <big>⊩</big> <em>A</em> → ⊥ is <a href="vacuous_truth" title="wikilink">vacuously true</a>, so <em>w</em> <big>⊩</big> ¬<em>A</em>.</p>

<p>Intuitionistic logic is sound and complete with respect to its Kripke semantics, and it has FMP.</p>
<h3 id="intuitionistic-first-order-logic">Intuitionistic first-order logic</h3>

<p>Let <em>L</em> be a <a href="first-order_logic" title="wikilink">first-order</a> language. A Kripke model of <em>L</em> is a triple 

<math display="inline" id="Kripke_semantics:98">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>W</mi>
   <mo>,</mo>
   <mo>≤</mo>
   <mo>,</mo>
   <msub>
    <mrow>
     <mo stretchy="false">{</mo>
     <msub>
      <mi>M</mi>
      <mi>w</mi>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mrow>
     <mi>w</mi>
     <mo>∈</mo>
     <mi>W</mi>
    </mrow>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>W</ci>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <ci>w</ci>
      </apply>
     </set>
     <apply>
      <in></in>
      <ci>w</ci>
      <ci>W</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle W,\leq,\{M_{w}\}_{w\in W}\rangle
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Kripke_semantics:99">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>W</mi>
   <mo>,</mo>
   <mo>≤</mo>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>W</ci>
    <leq></leq>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle W,\leq\rangle
  </annotation>
 </semantics>
</math>

 is an intuitionistic Kripke frame, <em>M<sub>w</sub></em> is a (classical) <em>L</em>-structure for each node <em>w</em> ∈ <em>W</em>, and the following compatibility conditions hold whenever <em>u</em> ≤ <em>v</em>:</p>
<ul>
<li>the domain of <em>M<sub>u</sub></em> is included in the domain of <em>M<sub>v</sub></em>,</li>
<li>realizations of function symbols in <em>M<sub>u</sub></em> and <em>M<sub>v</sub></em> agree on elements of <em>M<sub>u</sub></em>,</li>
<li>for each <em>n</em>-ary predicate <em>P</em> and elements <em>a</em><sub>1</sub>,…,<em>a<sub>n</sub></em> ∈ <em>M<sub>u</sub></em>: if <em>P</em>(<em>a</em><sub>1</sub>,…,<em>a<sub>n</sub></em>) holds in <em>M<sub>u</sub></em>, then it holds in <em>M<sub>v</sub></em>.</li>
</ul>

<p>Given an evaluation <em>e</em> of variables by elements of <em>M<sub>w</sub></em>, we define the satisfaction relation 

<math display="inline" id="Kripke_semantics:100">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>e</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash A[e]
  </annotation>
 </semantics>
</math>

:</p>
<ul>
<li>

<math display="inline" id="Kripke_semantics:101">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>t</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>t</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>e</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <ci>P</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>n</ci>
      </apply>
     </vector>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash P(t_{1},\dots,t_{n})[e]
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Kripke_semantics:102">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>t</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>e</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>t</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>e</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <vector>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>e</ci>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>e</ci>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(t_{1}[e],\dots,t_{n}[e])
  </annotation>
 </semantics>
</math>

 holds in <em>M<sub>w</sub></em>,</li>
<li>

<math display="inline" id="Kripke_semantics:103">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∧</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>e</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <apply>
      <and></and>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash(A\land B)[e]
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Kripke_semantics:104">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>e</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash A[e]
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Kripke_semantics:105">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mrow>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>e</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <ci>B</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash B[e]
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Kripke_semantics:106">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∨</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>e</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <apply>
      <or></or>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash(A\lor B)[e]
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Kripke_semantics:107">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>e</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash A[e]
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Kripke_semantics:108">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mrow>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>e</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <ci>B</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash B[e]
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Kripke_semantics:109">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>e</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">w</csymbol>
    <csymbol cd="latexml">forces</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">e</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash(A\to B)[e]
  </annotation>
 </semantics>
</math>

 if and only if for all 

<math display="inline" id="Kripke_semantics:110">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>≥</mo>
   <mi>w</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>u</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\geq w
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Kripke_semantics:111">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>⊩</mo>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>e</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>u</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\Vdash A[e]
  </annotation>
 </semantics>
</math>

 implies 

<math display="inline" id="Kripke_semantics:112">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>⊩</mo>
   <mrow>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>e</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>u</ci>
    <apply>
     <times></times>
     <ci>B</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\Vdash B[e]
  </annotation>
 </semantics>
</math>

,</li>
<li>not 

<math display="inline" id="Kripke_semantics:113">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mrow>
    <mo>⊥</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>e</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <apply>
     <csymbol cd="latexml">bottom</csymbol>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash\bot[e]
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Kripke_semantics:114">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <mpadded width="+1.7pt">
        <mi>x</mi>
       </mpadded>
       <mi>A</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>e</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>A</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash(\exists x\,A)[e]
  </annotation>
 </semantics>
</math>

 if and only if there exists an 

<math display="inline" id="Kripke_semantics:115">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∈</mo>
   <msub>
    <mi>M</mi>
    <mi>w</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>a</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\in M_{w}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Kripke_semantics:116">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>→</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">w</csymbol>
    <csymbol cd="latexml">forces</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">e</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash A[e(x\to a)]
  </annotation>
 </semantics>
</math>

,</li>
<li>

<math display="inline" id="Kripke_semantics:117">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>∀</mo>
      <mrow>
       <mpadded width="+1.7pt">
        <mi>x</mi>
       </mpadded>
       <mi>A</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>e</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>A</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash(\forall x\,A)[e]
  </annotation>
 </semantics>
</math>

 if and only if for every 

<math display="inline" id="Kripke_semantics:118">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>≥</mo>
   <mi>w</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>u</ci>
    <ci>w</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\geq w
  </annotation>
 </semantics>
</math>

 and every 

<math display="inline" id="Kripke_semantics:119">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∈</mo>
   <msub>
    <mi>M</mi>
    <mi>u</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>a</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\in M_{u}
  </annotation>
 </semantics>
</math>

 , 

<math display="inline" id="Kripke_semantics:120">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>⊩</mo>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>→</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">u</csymbol>
    <csymbol cd="latexml">forces</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">e</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\Vdash A[e(x\to a)]
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>Here <em>e</em>(<em>x</em>→<em>a</em>) is the evaluation which gives <em>x</em> the value <em>a</em>, and otherwise agrees with <em>e</em>.</p>

<p>See a slightly different formalization in.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h3 id="kripkejoyal-semantics">Kripke–Joyal semantics</h3>

<p>As part of the independent development of <a href="sheaf_theory" title="wikilink">sheaf theory</a>, it was realised around 1965 that Kripke semantics was intimately related to the treatment of <a href="existential_quantification" title="wikilink">existential quantification</a> in <a href="topos_theory" title="wikilink">topos theory</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> That is, the 'local' aspect of existence for sections of a sheaf was a kind of logic of the 'possible'. Though this development was the work of a number of people, the name <strong>Kripke–Joyal semantics</strong> is often used in this connection.</p>
<h2 id="model-constructions">Model constructions</h2>

<p>As in the classical <a href="model_theory" title="wikilink">model theory</a>, there are methods for constructing a new Kripke model from other models.</p>

<p>The natural <a href="homomorphism" title="wikilink">homomorphisms</a> in Kripke semantics are called <strong>p-morphisms</strong> (which is short for <em>pseudo-epimorphism</em>, but the latter term is rarely used). A p-morphism of Kripke frames 

<math display="inline" id="Kripke_semantics:121">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>W</mi>
   <mo>,</mo>
   <mi>R</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>W</ci>
    <ci>R</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle W,R\rangle
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Kripke_semantics:122">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <msup>
    <mi>W</mi>
    <mo>′</mo>
   </msup>
   <mo>,</mo>
   <msup>
    <mi>R</mi>
    <mo>′</mo>
   </msup>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>W</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <ci>normal-′</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle W^{\prime},R^{\prime}\rangle
  </annotation>
 </semantics>
</math>

 is a mapping 

<math display="inline" id="Kripke_semantics:123">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>W</mi>
    <mo>→</mo>
    <msup>
     <mi>W</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>W</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>W</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\colon W\to W^{\prime}
  </annotation>
 </semantics>
</math>

 such that</p>
<ul>
<li><em>f</em> preserves the accessibility relation, i.e., <em>u R v</em> implies <em>f</em>(<em>u</em>) <em>R’</em> <em>f</em>(<em>v</em>),</li>
<li>whenever <em>f</em>(<em>u</em>) <em>R’</em> <em>v</em>’, there is a <em>v</em> ∈ <em>W</em> such that <em>u R v</em> and <em>f</em>(<em>v</em>) = <em>v</em>’.</li>
</ul>

<p>A p-morphism of Kripke models 

<math display="inline" id="Kripke_semantics:124">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>W</mi>
   <mo>,</mo>
   <mi>R</mi>
   <mo>,</mo>
   <mo>⊩</mo>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>W</ci>
    <ci>R</ci>
    <csymbol cd="latexml">forces</csymbol>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle W,R,\Vdash\rangle
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Kripke_semantics:125">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <msup>
    <mi>W</mi>
    <mo>′</mo>
   </msup>
   <mo>,</mo>
   <msup>
    <mi>R</mi>
    <mo>′</mo>
   </msup>
   <mo>,</mo>
   <msup>
    <mo>⊩</mo>
    <mo>′</mo>
   </msup>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>W</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <csymbol cd="latexml">forces</csymbol>
     <ci>normal-′</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle W^{\prime},R^{\prime},\Vdash^{\prime}\rangle
  </annotation>
 </semantics>
</math>

 is a p-morphism of their underlying frames 

<math display="inline" id="Kripke_semantics:126">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi>W</mi>
    <mo>→</mo>
    <msup>
     <mi>W</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>W</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>W</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\colon W\to W^{\prime}
  </annotation>
 </semantics>
</math>

, which satisfies</p>

<p>

<math display="block" id="Kripke_semantics:127">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash p
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Kripke_semantics:128">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <msup>
    <mo>⊩</mo>
    <mo>′</mo>
   </msup>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <csymbol cd="latexml">forces</csymbol>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>w</ci>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(w)\Vdash^{\prime}p
  </annotation>
 </semantics>
</math>

, for any propositional variable <em>p</em>.</p>

<p>P-morphisms are a special kind of <a href="bisimulation" title="wikilink">bisimulations</a>. In general, a <strong>bisimulation</strong> between frames 

<math display="inline" id="Kripke_semantics:129">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>W</mi>
   <mo>,</mo>
   <mi>R</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>W</ci>
    <ci>R</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle W,R\rangle
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Kripke_semantics:130">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <msup>
    <mi>W</mi>
    <mo>′</mo>
   </msup>
   <mo>,</mo>
   <msup>
    <mi>R</mi>
    <mo>′</mo>
   </msup>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>W</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <ci>normal-′</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle W^{\prime},R^{\prime}\rangle
  </annotation>
 </semantics>
</math>

 is a relation <em>B ⊆ W × W’</em>, which satisfies the following “zig-zag” property:</p>
<ul>
<li>if <em>u B u’</em> and <em>u R v</em>, there exists <em>v’</em> ∈ <em>W’</em> such that <em>v B v’</em> and <em>u’ R’ v’</em>,</li>
<li>if <em>u B u’</em> and <em>u’ R’ v’</em>, there exists <em>v</em> ∈ <em>W</em> such that <em>v B v’</em> and <em>u R v</em>.</li>
</ul>

<p>A bisimulation of models is additionally required to preserve forcing of <a href="atomic_formula" title="wikilink">atomic formulas</a>:</p>
<dl>
<dd>if <em>w B w’</em>, then 

<math display="inline" id="Kripke_semantics:131">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>⊩</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>w</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\Vdash p
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Kripke_semantics:132">
 <semantics>
  <mrow>
   <msup>
    <mi>w</mi>
    <mo>′</mo>
   </msup>
   <msup>
    <mo>⊩</mo>
    <mo>′</mo>
   </msup>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <csymbol cd="latexml">forces</csymbol>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>w</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w^{\prime}\Vdash^{\prime}p
  </annotation>
 </semantics>
</math>

, for any propositional variable <em>p</em>.
</dd>
</dl>

<p>The key property which follows from this definition is that bisimulations (hence also p-morphisms) of models preserve the satisfaction of <em>all</em> formulas, not only propositional variables.</p>

<p>We can transform a Kripke model into a <a href="tree_(graph_theory)" title="wikilink">tree</a> using <strong>unravelling</strong>. Given a model 

<math display="inline" id="Kripke_semantics:133">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>W</mi>
   <mo>,</mo>
   <mi>R</mi>
   <mo>,</mo>
   <mo>⊩</mo>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>W</ci>
    <ci>R</ci>
    <csymbol cd="latexml">forces</csymbol>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle W,R,\Vdash\rangle
  </annotation>
 </semantics>
</math>

 and a fixed node <em>w</em><sub>0</sub> ∈ <em>W</em>, we define a model 

<math display="inline" id="Kripke_semantics:134">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <msup>
    <mi>W</mi>
    <mo>′</mo>
   </msup>
   <mo>,</mo>
   <msup>
    <mi>R</mi>
    <mo>′</mo>
   </msup>
   <mo>,</mo>
   <msup>
    <mo>⊩</mo>
    <mo>′</mo>
   </msup>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>W</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <csymbol cd="latexml">forces</csymbol>
     <ci>normal-′</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle W^{\prime},R^{\prime},\Vdash^{\prime}\rangle
  </annotation>
 </semantics>
</math>

, where <em>W’</em> is the set of all finite sequences 

<math display="inline" id="Kripke_semantics:135">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <msub>
     <mi>w</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>w</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>w</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>n</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=\langle w_{0},w_{1},\dots,w_{n}\rangle
  </annotation>
 </semantics>
</math>

 such that <em>w<sub>i</sub> R w<sub>i+1</sub></em> for all <em>i</em> s\Vdash p if and only if 

<math display="inline" id="Kripke_semantics:136">
 <semantics>
  <mrow>
   <msub>
    <mi>w</mi>
    <mi>n</mi>
   </msub>
   <mo>⊩</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>n</ci>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{n}\Vdash p
  </annotation>
 </semantics>
</math>

 for a propositional variable <em>p</em>. The definition of the accessibility relation <em>R’</em> varies; in the simplest case we put</p>

<p>

<math display="block" id="Kripke_semantics:137">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <msub>
     <mi>w</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>w</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>w</mi>
     <mi>n</mi>
    </msub>
    <mo rspace="5.3pt" stretchy="false">⟩</mo>
   </mrow>
   <mpadded width="+2.8pt">
    <msup>
     <mi>R</mi>
     <mo>′</mo>
    </msup>
   </mpadded>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <msub>
     <mi>w</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>w</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>w</mi>
     <mi>n</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>n</ci>
     </apply>
    </list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <ci>normal-′</ci>
    </apply>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle w_{0},w_{1},\dots,w_{n}\rangle\;R^{\prime}\;\langle w_{0},w_{1},\dots,%
w_{n},w_{n+1}\rangle
  </annotation>
 </semantics>
</math>

, but many applications need the reflexive and/or transitive closure of this relation, or similar modifications.</p>

<p><strong>Filtration</strong> is a useful construction which uses to prove <a href="Kripke_semantics#Finite_model_property" title="wikilink">FMP</a> for many logics. Let <em>X</em> be a set of formulas closed under taking subformulas. An <em>X</em>-filtration of a model 

<math display="inline" id="Kripke_semantics:138">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>W</mi>
   <mo>,</mo>
   <mi>R</mi>
   <mo>,</mo>
   <mo>⊩</mo>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>W</ci>
    <ci>R</ci>
    <csymbol cd="latexml">forces</csymbol>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle W,R,\Vdash\rangle
  </annotation>
 </semantics>
</math>

 is a mapping <em>f</em> from <em>W</em> to a model 

<math display="inline" id="Kripke_semantics:139">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <msup>
    <mi>W</mi>
    <mo>′</mo>
   </msup>
   <mo>,</mo>
   <msup>
    <mi>R</mi>
    <mo>′</mo>
   </msup>
   <mo>,</mo>
   <msup>
    <mo>⊩</mo>
    <mo>′</mo>
   </msup>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>W</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <csymbol cd="latexml">forces</csymbol>
     <ci>normal-′</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle W^{\prime},R^{\prime},\Vdash^{\prime}\rangle
  </annotation>
 </semantics>
</math>

 such that</p>
<ul>
<li><em>f</em> is a <a class="uri" href="surjection" title="wikilink">surjection</a>,</li>
<li><em>f</em> preserves the accessibility relation, and (in both directions) satisfaction of variables <em>p</em> ∈ <em>X</em>,</li>
<li>if <em>f</em>(<em>u</em>) <em>R’</em> <em>f</em>(<em>v</em>) and 

<math display="inline" id="Kripke_semantics:140">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>⊩</mo>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>u</ci>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\Vdash\Box A
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Kripke_semantics:141">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">□</mi>
    <mi>A</mi>
   </mrow>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>normal-□</ci>
     <ci>A</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box A\in X
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Kripke_semantics:142">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>⊩</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>v</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\Vdash A
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>It follows that <em>f</em> preserves satisfaction of all formulas from <em>X</em>. In typical applications, we take <em>f</em> as the projection onto the <a href="quotient_set" title="wikilink">quotient</a> of <em>W</em> over the relation</p>
<dl>
<dd><em>u ≡<sub>X</sub> v</em> if and only if for all <em>A</em> ∈ <em>X</em>, 

<math display="inline" id="Kripke_semantics:143">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>⊩</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>u</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u\Vdash A
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Kripke_semantics:144">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mo>⊩</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">forces</csymbol>
    <ci>v</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v\Vdash A
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>

<p>As in the case of unravelling, the definition of the accessibility relation on the quotient varies.</p>
<h2 id="general-frame-semantics">General frame semantics</h2>

<p>The main defect of Kripke semantics is the existence of Kripke incomplete logics, and logics which are complete but not compact. It can be remedied by equipping Kripke frames with extra structure which restricts the set of possible valuations, using ideas from algebraic semantics. This gives rise to the <a href="general_frame" title="wikilink">general frame</a> semantics.</p>
<h2 id="computer-science-applications">Computer science applications</h2>

<p>Blackburn et al. (2001) point out that because a relational structure is simply a set together with a collection of relations on that set, it is unsurprising that relational structures are to be found just about everywhere. As an example from <a href="theoretical_computer_science" title="wikilink">theoretical computer science</a>, they give <a href="labeled_transition_system" title="wikilink">labeled transition systems</a>, which model <a href="computer_program" title="wikilink">program execution</a>. Blackburn et al. thus claim because of this connection that modal languages are ideally suited in providing "internal, local perspective on relational structures." (p. xii)</p>
<h2 id="history-and-terminology">History and terminology</h2>

<p>Kripke semantics does not originate with Kripke, but instead the idea of giving semantics in the style given above, that is based on valuations made that are relative to nodes, predates Kripke by a long margin:</p>
<ul>
<li><a href="Rudolf_Carnap" title="wikilink">Rudolf Carnap</a> seems to have been the first to have the idea that one can give a <strong>possible world semantics</strong> for the modalities of necessity and possibility by means of giving the valuation function a parameter that ranges over Leibnizian possible worlds. Bayart develops this idea further, but neither gave recursive definitions of satisfaction in the style introduced by Tarski;</li>
<li>J.C.C. McKinsey and <a href="Alfred_Tarski" title="wikilink">Alfred Tarski</a> developed an approach to modeling modal logics that is still influential in modern research, namely the algebraic approach, in which Boolean algebras with operators are used as models. <a href="Bjarni_Jónsson" title="wikilink">Bjarni Jónsson</a> and Tarski established the representability of Boolean algebras with operators in terms of frames. If the two ideas had been put together, the result would have been precisely frame models, which is to say Kripke models, years before Kripke. But no one (not even Tarski) saw the connection at the time.</li>
<li><a href="Arthur_Prior" title="wikilink">Arthur Prior</a>, building on unpublished work of <a href="C._A._Meredith" title="wikilink">C. A. Meredith</a>, developed a translation of sentential modal logic into classical predicate logic that, if he had combined it with the usual model theory for the latter, would have produced a model theory equivalent to Kripke models for the former. But his approach was resolutely syntactic and anti-model-theoretic.</li>
<li><a href="Stig_Kanger" title="wikilink">Stig Kanger</a> gave a rather more complex approach to the interpretation of modal logic, but one that contains many of the key ideas of Kripke's approach. He first noted the relationship between conditions on accessibility relations and <a href="C.I._Lewis" title="wikilink">Lewis</a>-style axioms for modal logic. Kanger failed, however, to give a completeness proof for his system;</li>
<li><a href="Jaakko_Hintikka" title="wikilink">Jaakko Hintikka</a> gave a semantics in his papers introducing epistemic logic that is a simple variation of Kripke's semantics, equivalent to the characterisation of valuations by means of maximal consistent sets. He doesn't give inference rules for epistemic logic, and so cannot give a completeness proof;</li>
<li><a href="Richard_Montague" title="wikilink">Richard Montague</a> had many of the key ideas contained in Kripke's work, but he did not regard them as significant, because he had no completeness proof, and so did not publish until after Kripke's papers had created a sensation in the logic community;</li>
<li><a href="Evert_Willem_Beth" title="wikilink">Evert Willem Beth</a> presented a semantics of intuitionistic logic based on trees, which closely resembles Kripke semantics, except for using a more cumbersome definition of satisfaction.</li>
</ul>

<p>Though the essential ideas of <strong>Kripke semantics</strong> were very much in the air by the time Kripke first published, <a href="Saul_Kripke" title="wikilink">Saul Kripke</a>'s work on modal logic is rightly regarded as ground-breaking. Most importantly, it was Kripke who proved the completeness theorems for modal logic, and Kripke who identified the weakest normal modal logic.</p>

<p>Despite the seminal contribution of Kripke's work, many modal logicians deprecate the term <strong>Kripke semantics</strong> as disrespectful of the important contributions these other pioneers made. The other most widely used term <strong>possible world semantics</strong> is deprecated as inappropriate when applied to modalities other than possibility and necessity, such as in epistemic or deontic logic. Instead they prefer the terms <strong>relational semantics</strong> or <strong>frame semantics</strong>. The use of "semantics" for "model theory" has been objected to as well, on the grounds that it invites confusion with linguistic semantics: whether the apparatus of "possible worlds" that appears in models has anything to do with the <a href="linguistic_meaning" title="wikilink">linguistic meaning</a> of modal constructions in natural language is a contentious issue.</p>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Alexandrov_topology" title="wikilink">Alexandrov topology</a></li>
<li><a href="Normal_modal_logic" title="wikilink">Normal modal logic</a></li>
<li><a href="Two_dimensionalism" title="wikilink">Two dimensionalism</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Blackburn, P., <a href="Maarten_de_Rijke" title="wikilink">M. de Rijke</a>, and Y. Venema, 2001. <em>Modal Logic</em>. Cambridge University Press.</li>
<li>Bull, Robert. A., and K. Segerberg, 1984, "Basic Modal Logic" in <em>The Handbook of Philosophical Logic,</em> vol. 2. Kluwer: 1–88.</li>
<li>Chagrov, A, and Zakharyaschev, M., 1997. <em>Modal Logic</em>. Oxford University Press.</li>
<li><a href="Michael_Dummett" title="wikilink">Michael Dummett</a>, 1977. <em>Elements of Intuitionism</em>. Oxford Univ. Press.</li>
<li>Fitting, Melvin, 1969. <em>Intuitionistic Logic, Model Theory and Forcing</em>. North Holland.</li>
<li><a href="Robert_Goldblatt" title="wikilink">Robert Goldblatt</a> <a href="http://www.msor.vuw.ac.nz/~rob/">(link)</a>, 2003, "<a href="http://www.msor.vuw.ac.nz/~rob/papers/modalhist.pdf">Mathematical Modal Logic: a View of its Evolution</a>", In <em>Logic &amp; the Modalities in the Twentieth Century</em>, volume 7 of the <em>Handbook of the History of Logic</em>, edited by Dov M. Gabbay and John Woods, Elsevier, 2006, 1-98.</li>
<li>Hughes, G. E., and M. J. Cresswell, 1996. <em>A New Introduction to Modal Logic</em>. Routledge.</li>
<li><a href="Saunders_Mac_Lane" title="wikilink">Saunders Mac Lane</a> and <a href="Ieke_Moerdijk" title="wikilink">Moerdijk</a>, I., 1991. <em>Sheaves in Geometry and Logic</em>. Springer-Verlag.</li>
<li>van Dalen, Dirk, 1986, "Intuitionistic Logic" in <em>The Handbook of Philosophical Logic,</em> vol. 3. Reidel: 225–339.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="The_Stanford_Encyclopedia_of_Philosophy" title="wikilink">The Stanford Encyclopedia of Philosophy</a>: "<a href="http://plato.stanford.edu/archives/win2001/entries/logic-modal">Modal Logic</a>" — by James Garson.</li>
<li><a href="http://plato.stanford.edu/entries/logic-intuitionistic/">Intuitionistic Logic</a>. Written by <a href="http://www.math.ucla.edu/~joan/">Joan Moschovakis</a>. Published in Stanford Encyclopedia of Philosophy.</li>
<li>Detlovs and Podnieks, K., "<a href="http://www.ltn.lv/~podnieks/mlog/ml4a.htm#s44">Constructive Propositional Logic — Kripke Semantics.</a>" Chapter 4.4 of <em>Introduction to Mathematical Logic</em>. N.B: Constructive = intuitionistic.</li>
<li>Burgess, John P., "<a href="http://www.princeton.edu/~jburgess/Kripke1.doc">Kripke Models.</a>"</li>
<li></li>
</ul>

<p><a class="uri" href="de:Kripke-Semantik" title="wikilink">de:Kripke-Semantik</a>"</p>

<p><a href="Category:Modal_logic" title="wikilink">Category:Modal logic</a> <a href="Category:Model_theory" title="wikilink">Category:Model theory</a> <a href="Category:Mathematical_logic" title="wikilink">Category:Mathematical logic</a> <a href="Category:Philosophical_logic" title="wikilink">Category:Philosophical logic</a> <a href="Category:Sheaf_theory" title="wikilink">Category:Sheaf theory</a> <a href="Category:Non-classical_logic" title="wikilink">Category:Non-classical logic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="http://plato.stanford.edu/archives/spr2004/entries/logic-intuitionistic/">Intuitionistic Logic</a>. Written by <a href="http://www.math.ucla.edu/~joan/">Joan Moschovakis</a>. Published in Stanford Encyclopedia of Philosophy.<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="Robert_Goldblatt" title="wikilink">Goldblatt, Robert</a>; A Kripke-Joyal Semantics for Noncommutative Logic in Quantales; Advances in Modal Logic; Volume 6; 2006<a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
