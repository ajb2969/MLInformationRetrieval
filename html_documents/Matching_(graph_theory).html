<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1754">Matching (graph theory)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Matching (graph theory)</h1>
<hr/>

<p>In the <a href="mathematics" title="wikilink">mathematical</a> discipline of <a href="graph_theory" title="wikilink">graph theory</a>, a <strong>matching</strong> or <strong>independent edge set</strong> in a <a href="graph_(mathematics)" title="wikilink">graph</a> is a set of <a href="Edge_(graph_theory)" title="wikilink">edges</a> without common <a href="vertex_(graph_theory)" title="wikilink">vertices</a>. It may also be an entire graph consisting of edges without common vertices. Bipartite matching is a special case of a network flow problem.</p>
<h2 id="definition">Definition</h2>

<p>Given a <a href="graph_(mathematics)" title="wikilink">graph</a> <em>G</em> = (<em>V</em>,<em>E</em>), a <strong>matching</strong> <em>M</em> in <em>G</em> is a set of pairwise <a class="uri" href="non-adjacent" title="wikilink">non-adjacent</a> edges; that is, no two edges share a common vertex.</p>

<p>A vertex is <strong>matched</strong> (or <strong>saturated</strong>) if it is an endpoint of one of the edges in the matching. Otherwise the vertex is <strong>unmatched</strong>.</p>

<p>A <strong>maximal matching</strong> is a matching <em>M</em> of a graph <em>G</em> with the property that if any edge not in <em>M</em> is added to <em>M</em>, it is no longer a matching, that is, <em>M</em> is maximal if it is not a proper subset of any other matching in graph <em>G</em>. In other words, a matching <em>M</em> of a graph <em>G</em> is maximal if every edge in <em>G</em> has a non-empty intersection with at least one edge in <em>M</em>. The following figure shows examples of maximal matchings (red) in three graphs.</p>
<dl>
<dd>
</dd>
</dl>

<p>A <strong>maximum matching</strong> (also known as maximum-cardinality matching<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a>) is a matching that contains the largest possible number of edges. There may be many maximum matchings. The <strong>matching number</strong> 

<math display="inline" id="Matching_(graph_theory):0">
 <semantics>
  <mrow>
   <mi>ν</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ν</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu(G)
  </annotation>
 </semantics>
</math>

 of a graph 

<math display="inline" id="Matching_(graph_theory):1">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 is the size of a maximum matching. Note that every maximum matching is maximal, but not every maximal matching is a maximum matching. The following figure shows examples of maximum matchings in the same three graphs.</p>
<dl>
<dd>
</dd>
</dl>

<p>A <strong>perfect matching</strong> (a.k.a. <a class="uri" href="1-factor" title="wikilink">1-factor</a>) is a matching which matches all vertices of the graph. That is, every vertex of the graph is <a href="incidence_(geometry)" title="wikilink">incident</a> to exactly one edge of the matching. Figure (b) above is an example of a perfect matching. Every perfect matching is maximum and hence maximal. In some literature, the term <strong>complete matching</strong> is used. In the above figure, only part (b) shows a perfect matching. A perfect matching is also a minimum-size <a href="edge_cover" title="wikilink">edge cover</a>. Thus, <mtpl></mtpl>, that is, the size of a maximum matching is no larger than the size of a minimum edge cover.</p>

<p>A <strong>near-perfect matching</strong> is one in which exactly one vertex is unmatched. This can only occur when the graph has an <a href="odd_number" title="wikilink">odd number</a> of vertices, and such a matching must be maximum. In the above figure, part (c) shows a near-perfect matching. If, for every vertex in a graph, there is a near-perfect matching that omits only that vertex, the graph is also called <a href="factor-critical_graph" title="wikilink">factor-critical</a>.</p>

<p>Given a matching <em>M</em>,</p>
<ul>
<li>an <strong>alternating path</strong> is a path in which the edges belong alternatively to the matching and not to the matching.</li>
<li>an <strong>augmenting path</strong> is an alternating path that starts from and ends on free (unmatched) vertices.</li>
</ul>

<p>One can prove that a matching is maximum if and only if it does not have any augmenting path. (This result is sometimes called <a href="Berge's_lemma" title="wikilink">Berge's lemma</a>.)</p>
<h2 id="properties">Properties</h2>

<p>In any graph without isolated vertices, the sum of the matching number and the <a href="edge_covering_number" title="wikilink">edge covering number</a> equals the number of vertices.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> If there is a perfect matching, then both the matching number and the edge cover number are |<em>V</em>| / 2.</p>

<p>If <em>A</em> and <em>B</em> are two maximal matchings, then |<em>A</em>| ≤ 2|<em>B</em>| and |<em>B</em>| ≤ 2|<em>A</em>|. To see this, observe that each edge in <em>B</em> \ <em>A</em> can be adjacent to at most two edges in <em>A</em> \ <em>B</em> because <em>A</em> is a matching; moreover each edge in <em>A</em> \ <em>B</em> is adjacent to an edge in <em>B</em> \ <em>A</em> by maximality of <em>B</em>, hence</p>

<p>

<math display="block" id="Matching_(graph_theory):2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mi>A</mi>
      <mo>∖</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mn>2</mn>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>B</mi>
       <mo>∖</mo>
       <mi>A</mi>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <apply>
      <setdiff></setdiff>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <abs></abs>
      <apply>
       <setdiff></setdiff>
       <ci>B</ci>
       <ci>A</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A\setminus B|\leq 2|B\setminus A|.
  </annotation>
 </semantics>
</math>

</p>

<p>Further we get that</p>

<p>

<math display="block" id="Matching_(graph_theory):3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>A</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>A</mi>
       <mo>∩</mo>
       <mi>B</mi>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>A</mi>
       <mo>∖</mo>
       <mi>B</mi>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <mi>B</mi>
        <mo>∩</mo>
        <mi>A</mi>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mn>2</mn>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <mi>B</mi>
        <mo>∖</mo>
        <mi>A</mi>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>2</mn>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>B</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <abs></abs>
      <ci>A</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <abs></abs>
       <apply>
        <intersect></intersect>
        <ci>A</ci>
        <ci>B</ci>
       </apply>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <setdiff></setdiff>
        <ci>A</ci>
        <ci>B</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <abs></abs>
        <apply>
         <intersect></intersect>
         <ci>B</ci>
         <ci>A</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <abs></abs>
        <apply>
         <setdiff></setdiff>
         <ci>B</ci>
         <ci>A</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <abs></abs>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |A|=|A\cap B|+|A\setminus B|\leq 2|B\cap A|+2|B\setminus A|=2|B|.
  </annotation>
 </semantics>
</math>

</p>

<p>In particular, this shows that any maximal matching is a 2-approximation of a maximum matching and also a 2-approximation of a minimum maximal matching. This inequality is tight: for example, if <em>G</em> is a path with 3 edges and 4 nodes, the size of a minimum maximal matching is 1 and the size of a maximum matching is 2.</p>
<h2 id="matching-polynomials">Matching polynomials</h2>

<p>A <a href="generating_function" title="wikilink">generating function</a> of the number of <em>k</em>-edge matchings in a graph is called a matching polynomial. Let <em>G</em> be a graph and <em>m<sub>k</sub></em> be the number of <em>k</em>-edge matchings. One matching polynomial of <em>G</em> is</p>

<p>

<math display="block" id="Matching_(graph_theory):4">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>≥</mo>
      <mn>0</mn>
     </mrow>
    </munder>
    <mrow>
     <msub>
      <mi>m</mi>
      <mi>k</mi>
     </msub>
     <msup>
      <mi>x</mi>
      <mi>k</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <geq></geq>
      <ci>k</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{k\geq 0}m_{k}x^{k}.
  </annotation>
 </semantics>
</math>

 Another definition gives the matching polynomial as</p>

<p>

<math display="block" id="Matching_(graph_theory):5">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>≥</mo>
      <mn>0</mn>
     </mrow>
    </munder>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>k</mi>
     </msup>
     <msub>
      <mi>m</mi>
      <mi>k</mi>
     </msub>
     <msup>
      <mi>x</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mrow>
        <mn>2</mn>
        <mi>k</mi>
       </mrow>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <geq></geq>
      <ci>k</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{k\geq 0}(-1)^{k}m_{k}x^{n-2k},
  </annotation>
 </semantics>
</math>

 where <em>n</em> is the number of vertices in the graph. Each type has its uses; for more information see the article on matching polynomials.</p>
<h2 id="algorithms-and-computational-complexity">Algorithms and computational complexity</h2>
<h3 id="in-unweighted-bipartite-graphs">In unweighted bipartite graphs</h3>

<p>Matching problems are often concerned with <a href="bipartite_graph" title="wikilink">bipartite graphs</a>. Finding a <strong>maximum bipartite matching</strong><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> (often called a <strong>maximum cardinality bipartite matching</strong>) in a bipartite graph 

<math display="inline" id="Matching_(graph_theory):6">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">G</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">V</csymbol>
     <eq></eq>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">X</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">Y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-,</ci>
     <csymbol cd="unknown">E</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V=(X,Y),E)
  </annotation>
 </semantics>
</math>

 is perhaps the simplest problem.</p>

<p>The <a href="augmenting_path_algorithm" title="wikilink">augmenting path algorithm</a> finds it by finding an augmenting path from each <mtpl></mtpl> to 

<math display="inline" id="Matching_(graph_theory):7">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>Y</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ Y
  </annotation>
 </semantics>
</math>

 and adding it to the matching if it exists. As each path can be found in 

<math display="inline" id="Matching_(graph_theory):8">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>O</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ O(E)
  </annotation>
 </semantics>
</math>


 time, the running time is 

<math display="inline" id="Matching_(graph_theory):9">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>O</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>V</mi>
     <mi>E</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ O(VE)
  </annotation>
 </semantics>
</math>

. This solution is equivalent to adding a <em>super source</em> 

<math display="inline" id="Matching_(graph_theory):10">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 with edges to all vertices in 

<math display="inline" id="Matching_(graph_theory):11">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>X</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ X
  </annotation>
 </semantics>
</math>

, and a <em>super sink</em> 

<math display="inline" id="Matching_(graph_theory):12">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>t</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ t
  </annotation>
 </semantics>
</math>

 with edges from all vertices in 

<math display="inline" id="Matching_(graph_theory):13">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>Y</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ Y
  </annotation>
 </semantics>
</math>


, and finding a <a href="maximum_flow_problem" title="wikilink">maximal flow</a> from 

<math display="inline" id="Matching_(graph_theory):14">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>s</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ s
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Matching_(graph_theory):15">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>t</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ t
  </annotation>
 </semantics>
</math>

. All edges with flow from 

<math display="inline" id="Matching_(graph_theory):16">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>X</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ X
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Matching_(graph_theory):17">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>Y</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ Y
  </annotation>
 </semantics>
</math>

 then constitute a maximum matching.</p>

<p>An improvement over this is the <a href="Hopcroft–Karp_algorithm" title="wikilink">Hopcroft–Karp algorithm</a>, which runs in 

<math display="inline" id="Matching_(graph_theory):18">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msqrt>
      <mi>V</mi>
     </msqrt>
     <mi>E</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <root></root>
      <ci>V</ci>
     </apply>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\sqrt{V}E)
  </annotation>
 </semantics>
</math>


 time. Another approach is based on the fast <a href="matrix_multiplication" title="wikilink">matrix multiplication</a> algorithm and gives 

<math display="inline" id="Matching_(graph_theory):19">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>V</mi>
     <mn>2.376</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <cn type="float">2.376</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(V^{2.376})
  </annotation>
 </semantics>
</math>

 complexity,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> which is better in theory for sufficiently <a href="dense_graph" title="wikilink">dense graphs</a>, but in practice the algorithm is slower.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Finally, for sparse graphs, 

<math display="inline" id="Matching_(graph_theory):20">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>O</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>E</mi>
     <mrow>
      <mn>10</mn>
      <mo>/</mo>
      <mn>7</mn>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-~</ci>
     <ci>O</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>E</ci>
     <apply>
      <divide></divide>
      <cn type="integer">10</cn>
      <cn type="integer">7</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{O}(E^{10/7})
  </annotation>
 </semantics>
</math>

 is possible with Madry's algorithm based on electric flows. <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>In addition, the algorithm of Chandran and Hochbaum<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> runs in time that depends on the size of the maximum matching 

<math display="inline" id="Matching_(graph_theory):21">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, which for 

<math display="inline" id="Matching_(graph_theory):22">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>X</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo><</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>Y</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <abs></abs>
     <ci>X</ci>
    </apply>
    <apply>
     <abs></abs>
     <ci>Y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |X|<|Y|
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Matching_(graph_theory):23">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mrow>
      <mi>min</mi>
      <mrow>
       <mo stretchy="false">{</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">|</mo>
         <mi>X</mi>
         <mo stretchy="false">|</mo>
        </mrow>
        <mi>k</mi>
       </mrow>
       <mo>,</mo>
       <mi>E</mi>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msqrt>
       <mi>k</mi>
      </msqrt>
      <mrow>
       <mi>min</mi>
       <mrow>
        <mo stretchy="false">{</mo>
        <msup>
         <mi>k</mi>
         <mn>2</mn>
        </msup>
        <mo>,</mo>
        <mi>E</mi>
        <mo stretchy="false">}</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <plus></plus>
     <apply>
      <min></min>
      <apply>
       <times></times>
       <apply>
        <abs></abs>
        <ci>X</ci>
       </apply>
       <ci>k</ci>
      </apply>
      <ci>E</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <root></root>
       <ci>k</ci>
      </apply>
      <apply>
       <min></min>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>k</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>E</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O\left(\min\{|X|k,E\}+\sqrt{k}\min\{k^{2},E\}\right)
  </annotation>
 </semantics>
</math>


. Using boolean operations on words of size 

<math display="inline" id="Matching_(graph_theory):24">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 the complexity is further improved to 

<math display="inline" id="Matching_(graph_theory):25">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mrow>
      <mi>min</mi>
      <mrow>
       <mo>{</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">|</mo>
         <mi>X</mi>
         <mo stretchy="false">|</mo>
        </mrow>
        <mi>k</mi>
       </mrow>
       <mo>,</mo>
       <mfrac>
        <mrow>
         <mrow>
          <mo stretchy="false">|</mo>
          <mi>X</mi>
          <mo stretchy="false">|</mo>
         </mrow>
         <mrow>
          <mo stretchy="false">|</mo>
          <mi>Y</mi>
          <mo stretchy="false">|</mo>
         </mrow>
        </mrow>
        <mi>λ</mi>
       </mfrac>
       <mo>,</mo>
       <mi>E</mi>
       <mo>}</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <msup>
      <mi>k</mi>
      <mn>2</mn>
     </msup>
     <mo>+</mo>
     <mfrac>
      <msup>
       <mi>k</mi>
       <mn>2.5</mn>
      </msup>
      <mi>λ</mi>
     </mfrac>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <plus></plus>
     <apply>
      <min></min>
      <apply>
       <times></times>
       <apply>
        <abs></abs>
        <ci>X</ci>
       </apply>
       <ci>k</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <abs></abs>
         <ci>X</ci>
        </apply>
        <apply>
         <abs></abs>
         <ci>Y</ci>
        </apply>
       </apply>
       <ci>λ</ci>
      </apply>
      <ci>E</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>k</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>k</ci>
       <cn type="float">2.5</cn>
      </apply>
      <ci>λ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O\left(\min\left\{|X|k,\frac{|X||Y|}{\lambda},E\right\}+k^{2}+\frac{k^{2.5}}{%
\lambda}\right)
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="in-weighted-bipartite-graphs">In weighted bipartite graphs</h3>

<p>In a <a href="weighted_graph" title="wikilink">weighted</a> bipartite graph, each edge has an associated value. A <strong>maximum weighted bipartite matching</strong><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> is defined as a matching where the sum of the values of the edges in the matching have a maximal value. If the graph is not <a href="Complete_bipartite_graph" title="wikilink">complete bipartite</a>, missing edges are inserted with value zero. Finding such a matching is known as the <a href="assignment_problem" title="wikilink">assignment problem</a>. The remarkable <a href="Hungarian_algorithm" title="wikilink">Hungarian algorithm</a> solves the assignment problem and it was one of the beginnings of combinatorial optimization algorithms. It uses a modified <a href="shortest_path" title="wikilink">shortest path</a> search in the augmenting path algorithm. If the <a href="Bellman–Ford_algorithm" title="wikilink">Bellman–Ford algorithm</a> is used for this step, the running time of the Hungarian algorithm becomes 

<math display="inline" id="Matching_(graph_theory):26">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>V</mi>
      <mn>2</mn>
     </msup>
     <mi>E</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(V^{2}E)
  </annotation>
 </semantics>
</math>

, or the edge cost can be shifted with a potential to achieve 

<math display="inline" id="Matching_(graph_theory):27">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>V</mi>
       <mn>2</mn>
      </msup>
      <mrow>
       <mi>log</mi>
       <mi>V</mi>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>V</mi>
      <mi>E</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>V</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <log></log>
       <ci>V</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>E</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(V^{2}\log{V}+VE)
  </annotation>
 </semantics>
</math>

 running time with the <a href="Dijkstra_algorithm" title="wikilink">Dijkstra algorithm</a> and <a href="Fibonacci_heap" title="wikilink">Fibonacci heap</a>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h3 id="in-general-graphs">In general graphs</h3>

<p>There is a polynomial time algorithm to find a maximum matching or a maximum weight matching in a graph that is not bipartite; it is due to <a href="Jack_Edmonds" title="wikilink">Jack Edmonds</a>, is called the <em>paths, trees, and flowers</em> method or simply <a href="Edmonds's_matching_algorithm" title="wikilink">Edmonds's algorithm</a>, and uses <a href="bidirected_graph" title="wikilink">bidirected edges</a>. A generalization of the same technique can also be used to find <a href="maximum_independent_set" title="wikilink">maximum independent sets</a> in <a href="claw-free_graph" title="wikilink">claw-free graphs</a>. Edmonds' algorithm has subsequently been improved to run in time <mtpl></mtpl> time, matching the time for bipartite maximum matching.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>Another (randomized) algorithm by Mucha and Sankowski,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> based on the fast <a href="matrix_multiplication" title="wikilink">matrix multiplication</a> algorithm, gives 

<math display="inline" id="Matching_(graph_theory):28">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>V</mi>
     <mn>2.376</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <cn type="float">2.376</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(V^{2.376})
  </annotation>
 </semantics>
</math>


 complexity.</p>
<h3 id="maximal-matchings">Maximal matchings</h3>

<p>A maximal matching can be found with a simple greedy algorithm. A maximum matching is also a maximal matching, and hence it is possible to find a <em>largest</em> maximal matching in polynomial time. However, no polynomial-time algorithm is known for finding a <strong>minimum maximal matching</strong>, that is, a maximal matching that contains the <em>smallest</em> possible number of edges.</p>

<p>Note that a maximal matching with <em>k</em> edges is an <a href="edge_dominating_set" title="wikilink">edge dominating set</a> with <em>k</em> edges. Conversely, if we are given a minimum edge dominating set with <em>k</em> edges, we can construct a maximal matching with <em>k</em> edges in polynomial time. Therefore the problem of finding a minimum maximal matching is essentially equal to the problem of finding a minimum edge dominating set.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> Both of these two optimisation problems are known to be <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>; the decision versions of these problems are classical examples of <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> problems.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> Both problems can be <a href="approximation_algorithm" title="wikilink">approximated</a> within factor 2 in polynomial time: simply find an arbitrary maximal matching <em>M</em>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h3 id="counting-problems">Counting problems</h3>

<p>The number of matchings in a graph is known as the <a href="Hosoya_index" title="wikilink">Hosoya index</a> of the graph. It is <a href="Sharp-P-complete" title="wikilink">#P-complete</a> to compute this quantity. It remains #P-complete in the special case of counting the number of perfect matchings in a given <a href="bipartite_graph" title="wikilink">bipartite graph</a>, because computing the <a class="uri" href="permanent" title="wikilink">permanent</a> of an arbitrary 0–1 matrix (another #P-complete problem) is the same as computing the number of perfect matchings in the bipartite graph having the given matrix as its <a href="biadjacency_matrix" title="wikilink">biadjacency matrix</a>. However, there exists a fully polynomial time randomized approximation scheme for counting the number of bipartite matchings.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> A remarkable theorem of <a href="Pieter_Kasteleyn" title="wikilink">Kasteleyn</a> states that the number of perfect matchings in a <a href="planar_graph" title="wikilink">planar graph</a> can be computed exactly in polynomial time via the <a href="FKT_algorithm" title="wikilink">FKT algorithm</a>.</p>

<p>The number of perfect matchings in a <a href="complete_graph" title="wikilink">complete graph</a> <em>K</em><sub><em>n</em></sub> (with <em>n</em> even) is given by the <a href="double_factorial" title="wikilink">double factorial</a> (<em>n</em> − 1)!!.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> The numbers of matchings in complete graphs, without constraining the matchings to be perfect, are given by the <a href="Telephone_number_(mathematics)" title="wikilink">telephone numbers</a>.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<h3 id="finding-all-maximally-matchable-edges">Finding all maximally-matchable edges</h3>

<p>One of the basic problems in matching theory is to find in a given graph all edges that may be extended to a maximum matching in the graph. (Such edges are called <strong>maximally-matchable</strong> edges, or <strong>allowed</strong> edges.) The best deterministic algorithm for solving this problem in general graphs runs in time 

<math display="inline" id="Matching_(graph_theory):29">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>V</mi>
     <mi>E</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(VE)
  </annotation>
 </semantics>
</math>

 .<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> There exists a randomized algorithm that solves this problem in time 

<math display="inline" id="Matching_(graph_theory):30">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>O</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>V</mi>
     <mn>2.376</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-~</ci>
     <ci>O</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <cn type="float">2.376</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{O}(V^{2.376})
  </annotation>
 </semantics>
</math>

 .<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> In the case of bipartite graphs, it is possible to find a single maximum matching and then use it in order to find all maximally-matchable edges in linear time;<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> the resulting overall runtime is 

<math display="inline" id="Matching_(graph_theory):31">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>V</mi>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msup>
     <mi>E</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(V^{1/2}E)
  </annotation>
 </semantics>
</math>

 for general bipartite graphs and 

<math display="inline" id="Matching_(graph_theory):32">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>V</mi>
        <mo>/</mo>
        <mrow>
         <mi>log</mi>
         <mi>V</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msup>
     <mi>E</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <divide></divide>
       <ci>V</ci>
       <apply>
        <log></log>
        <ci>V</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O((V/\log V)^{1/2}E)
  </annotation>
 </semantics>
</math>

 for dense bipartite graphs with 

<math display="inline" id="Matching_(graph_theory):33">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Θ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>V</mi>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>E</ci>
    <apply>
     <times></times>
     <ci>normal-Θ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E=\Theta(V^{2})
  </annotation>
 </semantics>
</math>


. In cases where one of the maximum matchings is known upfront,<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> the overall runtime of the algorithm is 

<math display="inline" id="Matching_(graph_theory):34">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>V</mi>
     <mo>+</mo>
     <mi>E</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <plus></plus>
     <ci>V</ci>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(V+E)
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="characterizations-and-notes">Characterizations and notes</h2>

<p><a href="König's_theorem_(graph_theory)" title="wikilink">König's theorem</a> states that, in bipartite graphs, the maximum matching is equal in size to the minimum <a href="vertex_cover" title="wikilink">vertex cover</a>. Via this result, the minimum vertex cover, <a href="maximum_independent_set" title="wikilink">maximum independent set</a>, and <a href="maximum_vertex_biclique" title="wikilink">maximum vertex biclique</a> problems may be solved in <a href="polynomial_time" title="wikilink">polynomial time</a> for bipartite graphs.</p>

<p><a href="Hall's_marriage_theorem" title="wikilink">Hall's marriage theorem</a> provides a characterization of bipartite graphs which have a perfect matching and the <a href="Tutte_theorem" title="wikilink">Tutte theorem</a> provides a characterization for arbitrary graphs.</p>

<p>A perfect matching is a spanning <a href="Regular_graph" title="wikilink">1-regular</a> subgraph, a.k.a. a <a class="uri" href="1-factor" title="wikilink">1-factor</a>. In general, a spanning <em>k</em>-regular subgraph is a <a href="Factor_(graph_theory)" title="wikilink"><em>k</em>-factor</a>.</p>
<h2 id="applications">Applications</h2>
<h3 id="matching-in-general-graphs">Matching in general graphs</h3>
<ul>
<li>A <strong>Kekulé structure</strong> of an <a href="Aromaticity" title="wikilink">aromatic compound</a> consists of a perfect matching of its <a href="skeletal_formula" title="wikilink">carbon skeleton</a>, showing the locations of <a href="double_bond" title="wikilink">double bonds</a> in the <a href="chemical_structure" title="wikilink">chemical structure</a>. These structures are named after <a href="Friedrich_August_Kekulé_von_Stradonitz" title="wikilink">Friedrich August Kekulé von Stradonitz</a>, who showed that <a class="uri" href="benzene" title="wikilink">benzene</a> (in graph theoretical terms, a 6-vertex cycle) can be given such a structure.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></li>
<li>The <a href="Hosoya_index" title="wikilink">Hosoya index</a> is the number of non-empty matchings plus one; it is used in <a href="computational_chemistry" title="wikilink">computational chemistry</a> and <a href="mathematical_chemistry" title="wikilink">mathematical chemistry</a> investigations for organic compounds.</li>
</ul>
<h3 id="matching-in-bipartite-graphs">Matching in Bipartite Graphs</h3>
<ul>
<li>[<a class="uri" href="http://community.topcoder.com/stat?c=problem_statement±=2852&amp;rd">http://community.topcoder.com/stat?c=problem_statement±=2852&amp;rd;</a>;=5075 Graduation problem] is about choosing minimum set of classes from given requirements for graduation.</li>
<li><a href="Transportation_theory_(mathematics)" title="wikilink">Hitchcock Transport Problem</a> involves bipartite matching as sub-problem.</li>
<li><a href="Subgraph_isomorphism_problem" title="wikilink">Subtree isomorphism</a> problem involves bipartite matching as sub-problem.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Dulmage–Mendelsohn_decomposition" title="wikilink">Dulmage–Mendelsohn decomposition</a>, a partition of the vertices of a bipartite graph into subsets such that each edge belongs to a perfect matching if and only if its endpoints belong to the same subset</li>
<li><a href="Edge_coloring" title="wikilink">Edge coloring</a>, a partition of the edges of a graph into matchings</li>
<li><a href="Matching_preclusion" title="wikilink">Matching preclusion</a>, the minimum number of edges to delete to prevent a perfect matching from existing</li>
<li><a href="Rainbow_matching" title="wikilink">Rainbow matching</a>, a matching in an edge-colored bipartite graph with no repeated colors</li>
<li><a href="Skew-symmetric_graph" title="wikilink">Skew-symmetric graph</a>, a type of graph that can be used to model alternating path searches for matchings</li>
<li><a href="Stable_matching" title="wikilink">Stable matching</a>, a matching in which no two elements prefer each other to their matched partners</li>
<li><a href="Vertex_independent_set" title="wikilink">Vertex independent set</a>, a set of vertices (rather than edges) no two of which are adjacent to each other</li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ol>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ol>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://lemon.cs.elte.hu/">A graph library with Hopcroft–Karp and Push–Relabel-based maximum cardinality matching implementation</a></li>
</ul>

<p>"</p>

<p><a href="Category:Matching" title="wikilink"> </a> <a href="Category:Combinatorial_optimization" title="wikilink">Category:Combinatorial optimization</a> <a href="Category:Polynomial-time_problems" title="wikilink">Category:Polynomial-time problems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Alan Gibbons, Algorithmic Graph Theory, Cambridge University Press, 1985, Chapter 5.<a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">.<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10">.<a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12">.<a href="#fnref12">↩</a></li>
<li id="fn13">. Edge dominating set (decision version) is discussed under the dominating set problem, which is the problem GT2 in Appendix A1.1. Minimum maximal matching (decision version) is the problem GT10 in Appendix A1.1.<a href="#fnref13">↩</a></li>
<li id="fn14">. Minimum edge dominating set (optimisation version) is the problem GT3 in Appendix B (page 370). Minimum maximal matching (optimisation version) is the problem GT10 in Appendix B (page 374). See also <a href="http://www.nada.kth.se/~viggo/wwwcompendium/node13.html">Minimum Edge Dominating Set</a> and <a href="http://www.nada.kth.se/~viggo/wwwcompendium/node21.html">Minimum Maximal Matching</a> in the <a href="http://www.nada.kth.se/~viggo/wwwcompendium/">web compendium</a>.<a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16">.<a href="#fnref16">↩</a></li>
<li id="fn17">.<a href="#fnref17">↩</a></li>
<li id="fn18">.<a href="#fnref18">↩</a></li>
<li id="fn19">.<a href="#fnref19">↩</a></li>
<li id="fn20">.<a href="#fnref20">↩</a></li>
<li id="fn21">.<a href="#fnref21">↩</a></li>
<li id="fn22">See, e.g., .<a href="#fnref22">↩</a></li>
</ol>
</section>
</body>
</html>
