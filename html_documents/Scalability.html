<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="787">Scalability</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Scalability</h1>
<hr/>

<p><strong><em>Scalability</em></strong> is the ability of a system, network, or process to handle a growing amount of work in a capable manner or its ability to be enlarged to accommodate that growth.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> For example, it can refer to the capability of a system to increase its total output under an increased load when resources (typically hardware) are added. An analogous meaning is implied when the word is used in an <a href="economics" title="wikilink">economic</a> context, where scalability of a company implies that the underlying <a href="business_model" title="wikilink">business model</a> offers the potential for <a href="economic_growth" title="wikilink">economic growth</a> within the company.</p>

<p>Scalability, as a property of systems, is generally difficult to define<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and in any particular case it is necessary to define the specific requirements for scalability on those dimensions that are deemed important. It is a highly significant issue in electronics systems, databases, routers, and networking. A system whose performance improves after adding hardware, proportionally to the capacity added, is said to be a <strong><em>scalable system</em></strong>.</p>

<p>An <a class="uri" href="algorithm" title="wikilink">algorithm</a>, design, <a href="Protocol_(computing)" title="wikilink">networking protocol</a>, <a href="Computer_program" title="wikilink">program</a>, or other system is said to <em>scale</em> if it is suitably <a href="Algorithmic_efficiency" title="wikilink">efficient</a> and practical when applied to large situations (e.g. a large input data set, a large number of outputs or users, or a large number of participating nodes in the case of a distributed system). If the design or system fails when a quantity increases, it <em>does not scale</em>. In practice, if there are a large number of things (

<math display="inline" id="Scalability:0">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

) that affect scaling, then resource requirements (for example, algorithmic time-complexity) must grow less than <mtpl></mtpl> as 

<math display="inline" id="Scalability:1">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 increases. An example is a search engine, that must scale not only for the number of users, but for the number of objects it indexes. Scalability refers to the ability of a site to increase in size as demand warrants.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>The concept of scalability is desirable in technology as well as <a class="uri" href="business" title="wikilink">business</a> settings. The base concept is consistent the ability for a business or technology to accept increased volume without impacting the <a href="contribution_margin" title="wikilink">contribution margin</a> (= <a class="uri" href="revenue" title="wikilink">revenue</a> − <a href="variable_cost" title="wikilink">variable costs</a>). For example, a given piece of equipment may have a capacity for 1–1000 users, while beyond 1000 users additional equipment is needed or performance will decline (variable costs will increase and reduce contribution margin).</p>
<h2 id="measures">Measures</h2>

<p>Scalability can be measured in various dimensions, such as:</p>
<ul>
<li><em>Administrative scalability</em>: The ability for an increasing number of organizations or users to easily share a single distributed system.</li>
<li><em>Functional scalability</em>: The ability to enhance the system by adding new functionality at minimal effort.</li>
<li><em>Geographic scalability</em>: The ability to maintain performance, usefulness, or usability regardless of expansion from concentration in a local area to a more distributed geographic pattern.</li>
<li><em>Load scalability</em>: The ability for a <a href="distributed_system" title="wikilink">distributed system</a> to easily expand and contract its resource pool to accommodate heavier or lighter loads or number of inputs. Alternatively, the ease with which a system or component can be modified, added, or removed, to accommodate changing load.</li>
<li><em>Generation scalability</em> refers to the ability of a system to scale up by using new generations of components. Thereby, <a href="Open_architecture" title="wikilink"><em>heterogeneous scalability</em></a> is the ability to use the components from different vendors.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></li>
</ul>
<h2 id="examples">Examples</h2>
<ul>
<li>A <a href="'''routing'''_protocol" title="wikilink">'''routing''' protocol</a> is considered scalable with respect to network size, if the size of the necessary <a href="routing_table" title="wikilink">routing table</a> on each node grows as <a href="Big_O_notation" title="wikilink">O</a>(log <em>N</em>), where <em>N</em> is the number of nodes in the network.</li>
<li>A scalable <a href="online_transaction_processing" title="wikilink">online transaction processing</a> system or <a href="database_management_system" title="wikilink">database management system</a> is one that can be upgraded to process more transactions by adding new processors, devices and storage, and which can be upgraded easily and transparently without shutting it down.</li>
<li>Some early <a class="uri" href="peer-to-peer" title="wikilink">peer-to-peer</a> (P2P) implementations of <a class="uri" href="Gnutella" title="wikilink">Gnutella</a> had scaling issues. Each node query <a href="Query_flooding" title="wikilink">flooded</a> its requests to all peers. The demand on each peer would increase in proportion to the total number of peers, quickly overrunning the peers' limited capacity. Other P2P systems like <a href="BitTorrent_(protocol)" title="wikilink">BitTorrent</a> scale well because the demand on each peer is independent of the total number of peers. There is no centralized bottleneck, so the system may expand indefinitely without the addition of supporting resources (other than the peers themselves).</li>
<li>The distributed nature of the <a href="Domain_Name_System" title="wikilink">Domain Name System</a> allows it to work efficiently even when all <a href="server_(computing)" title="wikilink">hosts</a> on the worldwide <a class="uri" href="Internet" title="wikilink">Internet</a> are served, so it is said to "scale well".</li>
</ul>
<h2 id="horizontal-and-vertical-scaling">Horizontal and vertical scaling</h2>

<p>Methods of adding more resources for a particular application fall into two broad categories: horizontal and vertical scaling.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<ul>
<li>To <strong>scale horizontally</strong> (or <strong>scale out</strong>) means to add more nodes to a system, such as adding a new computer to a distributed software application. An example might involve scaling out from one Web server system to three. As computer prices have dropped and performance continues to increase, high-performance computing applications such as seismic analysis and biotechnology workloads have adopted low-cost "<a href="commodity_server" title="wikilink">commodity</a>" systems for tasks that once would have required <a href="supercomputer" title="wikilink">supercomputers</a>. System architects may configure hundreds of small computers in a <a href="computer_cluster" title="wikilink">cluster</a> to obtain aggregate computing power that often exceeds that of computers based on a single traditional processor. The development of high-performance interconnects such as <a href="Gigabit_Ethernet" title="wikilink">Gigabit Ethernet</a>, <a class="uri" href="InfiniBand" title="wikilink">InfiniBand</a> and <a class="uri" href="Myrinet" title="wikilink">Myrinet</a> further fueled this model. Such growth has led to demand for software that allows efficient management and maintenance of multiple nodes, as well as hardware such as shared data storage with much higher I/O performance. <em>Size scalability</em> is the maximum number of processors that a system can accommodate.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></li>
</ul>
<ul>
<li>To <strong>scale vertically</strong> (or <strong>scale up</strong>) means to add resources to a single node in a system, typically involving the addition of CPUs or memory to a single computer. Such vertical scaling of existing systems also enables them to use <a href="platform_virtualization" title="wikilink">virtualization</a> technology more effectively, as it provides more resources for the hosted set of <a href="operating_system" title="wikilink">operating system</a> and <a href="application_software" title="wikilink">application</a> modules to share. Taking advantage of such resources can also be called "scaling up", such as expanding the number of <a href="Apache_HTTP_Server" title="wikilink">Apache</a> daemon processes currently running. <em>Application scalability</em> refers to the improved performance of running applications on a scaled-up version of the system.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></li>
</ul>

<p>There are tradeoffs between the two models. Larger numbers of computers means increased management complexity, as well as a more complex programming model and issues such as throughput and latency between nodes; also, <a href="Amdahl's_Law" title="wikilink">some applications do not lend themselves to a distributed computing model</a>. In the past, the price difference between the two models has favored "scale up" computing for those applications that fit its paradigm, but recent advances in virtualization technology have blurred that advantage, since deploying a new virtual system over a <a class="uri" href="hypervisor" title="wikilink">hypervisor</a> (where possible) is almost always less expensive than actually buying and installing a real one. Configuring an existing idle system has always been less expensive than buying, installing, and configuring a new one, regardless of the model.</p>
<h2 id="database-scalability">Database scalability</h2>

<p>A number of different approaches enable <a href="database" title="wikilink">databases</a> to grow to very large size while supporting an ever-increasing rate of <a href="Transactions_Per_Second" title="wikilink">transactions per second</a>. Not to be discounted, of course, is the rapid pace of hardware advances in both the speed and capacity of <a href="mass_storage" title="wikilink">mass storage</a> devices, as well as similar advances in CPU and networking speed.</p>

<p>One technique supported by most of the major <a href="Database_management_system" title="wikilink">database management system (DBMS)</a> products is the <a href="Partition_(database)" title="wikilink">partitioning</a> of large tables, based on ranges of values in a key field. In this manner, the database can be <em>scaled out</em> across a cluster of separate <a href="database_server" title="wikilink">database servers</a>. Also, with the advent of 64-bit <a href="microprocessor" title="wikilink">microprocessors</a>, <a href="Multi-core_(computing)" title="wikilink">multi-core</a> CPUs, and large <a href="Symmetric_multiprocessing" title="wikilink">SMP multiprocessors</a>, DBMS vendors have been at the forefront of supporting <a href="Thread_(computer_science)" title="wikilink">multi-threaded</a> implementations that substantially <em>scale up</em> <a href="transaction_processing" title="wikilink">transaction processing</a> capacity.</p>

<p><a href="Network-attached_storage" title="wikilink">Network-attached storage (NAS)</a> and <a href="Storage_area_network" title="wikilink">Storage area networks (SANs)</a> coupled with fast local area networks and <a href="Fibre_Channel" title="wikilink">Fibre Channel</a> technology enable still larger, more loosely coupled configurations of databases and distributed computing power. The widely supported <a href="X/Open_XA" title="wikilink">X/Open XA</a> standard employs a global transaction monitor to coordinate <a href="distributed_transaction" title="wikilink">distributed transactions</a> among semi-autonomous XA-compliant database resources. <a href="Oracle_RAC" title="wikilink">Oracle RAC</a> uses a different model to achieve scalability, based on a "shared-everything" architecture that relies upon high-speed connections between servers.</p>

<p>While DBMS vendors debate the relative merits of their favored designs, some companies and researchers question the inherent limitations of <a href="relational_database_management_system" title="wikilink">relational database management systems</a>. <a class="uri" href="GigaSpaces" title="wikilink">GigaSpaces</a>, for example, contends that an entirely different model of distributed data access and transaction processing, <a href="Space_based_architecture" title="wikilink">Space based architecture</a>, is required to achieve the highest performance and scalability. On the other hand, <a href="Base_One" title="wikilink">Base One</a> makes the case for extreme scalability without departing from mainstream relational database technology.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> For specialized applications, <a class="uri" href="NoSQL" title="wikilink">NoSQL</a> architectures such as Google's <a class="uri" href="BigTable" title="wikilink">BigTable</a> can further enhance scalability. Google's massively distributed <a href="Spanner_(distributed_database_technology)" title="wikilink">Spanner</a> technology, positioned as a successor to BigTable, supports general-purpose <a href="database_transaction" title="wikilink">database transactions</a> and provides a more conventional <a class="uri" href="SQL" title="wikilink">SQL</a>-based query language.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="strong-versus-eventual-consistency-storage">Strong versus eventual consistency (storage)</h2>

<p>In the context of scale-out <a href="Computer_data_storage" title="wikilink">data storage</a>, scalability is defined as the maximum storage cluster size which guarantees full data consistency, meaning there is only ever one valid version of stored data in the whole cluster, independently from the number of redundant physical data copies. Clusters which provide "lazy" redundancy by updating copies in an asynchronous fashion are called <a href="Eventual_consistency" title="wikilink">'eventually consistent'</a>. This type of scale-out design is suitable when availability and responsiveness are rated higher than consistency, which is true for many web file hosting services or web caches (<em>if you want the latest version, wait some seconds for it to propagate</em>). For all classical transaction-oriented applications, this design should be avoided.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>Many open source and even commercial scale-out storage clusters, especially those built on top of standard PC hardware and networks, provide <a href="eventual_consistency" title="wikilink">eventual consistency</a> only. Idem some NoSQL databases like <a class="uri" href="CouchDB" title="wikilink">CouchDB</a> and others mentioned above. Write operations invalidate other copies, but often don't wait for their acknowledgements. Read operations typically don't check every redundant copy prior to answering, potentially missing the preceding write operation. The large amount of metadata signal traffic would require specialized hardware and short distances to be handled with acceptable performance (i.e. act like a non-clustered storage device or database).</p>

<p>Whenever strong data consistency is expected, look for these indicators:</p>
<ul>
<li>the use of InfiniBand, Fibrechannel or similar low-latency networks to avoid performance degradation with increasing cluster size and number of redundant copies.</li>
<li>short cable lengths and limited physical extent, avoiding signal runtime performance degradation.</li>
<li>majority / quorum mechanisms to guarantee data consistency whenever parts of the cluster become inaccessible.</li>
</ul>

<p>Indicators for <a href="Eventual_consistency" title="wikilink">eventually consistent</a> designs (not suitable for transactional applications!) are:</p>
<ul>
<li>write performance increases linearly with the number of connected devices in the cluster.</li>
<li>while the storage cluster is partitioned, all parts remain responsive. There is a risk of conflicting updates.</li>
</ul>
<h2 id="performance-tuning-versus-hardware-scalability">Performance tuning versus hardware scalability</h2>

<p>It is often advised to focus system design on hardware scalability rather than on capacity. It is typically cheaper to add a new node to a system in order to achieve improved performance than to partake in <a href="performance_tuning" title="wikilink">performance tuning</a> to improve the capacity that each node can handle. But this approach can have diminishing returns (as discussed in <a href="performance_engineering" title="wikilink">performance engineering</a>). For example: suppose 70% of a program can be sped up if parallelized and run on multiple CPUs instead of one. If 

<math display="inline" id="Scalability:2">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 is the fraction of a calculation that is sequential, and 

<math display="inline" id="Scalability:3">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\alpha
  </annotation>
 </semantics>
</math>


 is the fraction that can be parallelized, the maximum <a class="uri" href="speedup" title="wikilink">speedup</a> that can be achieved by using P processors is given according to <a href="Amdahl's_Law" title="wikilink">Amdahl's Law</a>:</p>

<p>

<math display="inline" id="Scalability:4">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <mrow>
    <mi>α</mi>
    <mo>+</mo>
    <mfrac>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>α</mi>
     </mrow>
     <mi>P</mi>
    </mfrac>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <plus></plus>
     <ci>α</ci>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>α</ci>
      </apply>
      <ci>P</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{\alpha+\frac{1-\alpha}{P}}
  </annotation>
 </semantics>
</math>

.</p>

<p>Substituting the value for this example, using 4 processors we get</p>

<p>

<math display="inline" id="Scalability:5">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mn>0.3</mn>
     <mo>+</mo>
     <mfrac>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mn>0.3</mn>
      </mrow>
      <mn>4</mn>
     </mfrac>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mn>2.105</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <plus></plus>
      <cn type="float">0.3</cn>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <cn type="float">0.3</cn>
       </apply>
       <cn type="integer">4</cn>
      </apply>
     </apply>
    </apply>
    <cn type="float">2.105</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{0.3+\frac{1-0.3}{4}}=2.105
  </annotation>
 </semantics>
</math>

.</p>

<p>If we double the compute power to 8 processors we get</p>

<p>

<math display="inline" id="Scalability:6">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mn>0.3</mn>
     <mo>+</mo>
     <mfrac>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mn>0.3</mn>
      </mrow>
      <mn>8</mn>
     </mfrac>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mn>2.581</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <plus></plus>
      <cn type="float">0.3</cn>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <cn type="float">0.3</cn>
       </apply>
       <cn type="integer">8</cn>
      </apply>
     </apply>
    </apply>
    <cn type="float">2.581</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{0.3+\frac{1-0.3}{8}}=2.581
  </annotation>
 </semantics>
</math>

.</p>

<p>Doubling the processing power has only improved the speedup by roughly one-fifth. If the whole problem was parallelizable, we would, of course, expect the speed up to double also. Therefore, throwing in more hardware is not necessarily the optimal approach.</p>
<h2 id="weak-versus-strong-scaling">Weak versus strong scaling</h2>

<p>In the context of <a href="high_performance_computing" title="wikilink">high performance computing</a> there are two common notions of scalability:</p>
<ul>
<li>The first is <em>strong scaling</em>, which is defined as how the solution time varies with the number of processors for a fixed <em>total</em> problem size.</li>
<li>The second is <em>weak scaling</em>, which is defined as how the solution time varies with the number of processors for a fixed problem size <em>per processor</em>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Asymptotic_complexity" title="wikilink">Asymptotic complexity</a></li>
<li><a href="Computational_complexity_theory" title="wikilink">Computational complexity theory</a></li>
<li><a href="Data_Defined_Storage" title="wikilink">Data Defined Storage</a></li>
<li><a class="uri" href="Extensibility" title="wikilink">Extensibility</a></li>
<li><a href="Gustafson's_law" title="wikilink">Gustafson's law</a></li>
<li><a href="List_of_system_quality_attributes" title="wikilink">List of system quality attributes</a></li>
<li><a href="Load_balancing_(computing)" title="wikilink">Load balancing (computing)</a></li>
<li><a href="Lock_(computer_science)" title="wikilink">Lock (computer science)</a></li>
<li><a class="uri" href="NoSQL" title="wikilink">NoSQL</a></li>
<li><a href="Parallel_computing" title="wikilink">Parallel computing</a></li>
<li><a href="Scalable_Video_Coding" title="wikilink">Scalable Video Coding</a> (SVC)</li>
<li><a href="Similitude_(model)" title="wikilink">Similitude (model)</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://today.java.net/pub/a/today/2007/02/13/architecture-of-highly-scalable-nio-server.html">Architecture of a Highly Scalable NIO-Based Server</a> - an article about writing scalable server in Java (java.net).</li>
<li><a href="http://code.google.com/p/memcached/wiki/HowToLearnMoreScalability">Links to diverse learning resources</a> - page curated by the <a class="uri" href="memcached" title="wikilink">memcached</a> project.</li>
<li><a href="http://www.linfo.org/scalable.html">Scalable Definition</a> - by The Linux Information Project (LINFO)</li>
<li><a href="http://go.nuodb.com/rs/nuodb/images/Greenbook_Final.pdf">NuoDB Scale-out Emergent Architecture</a></li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.31.3576">Scale in Distributed Systems</a> B. Clifford Neumann, In: <em>Readings in Distributed Computing Systems</em>, IEEE Computer Society Press, 1994</li>
</ul>

<p>"</p>

<p><a href="Category:Computer_architecture" title="wikilink">Category:Computer architecture</a> <a href="Category:Computational_resources" title="wikilink">Category:Computational resources</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">See for instance,  and <a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
</ol>
</section>
</body>
</html>
