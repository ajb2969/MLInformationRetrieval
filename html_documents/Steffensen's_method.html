<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1820">Steffensen's method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Steffensen's method</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In <a href="numerical_analysis" title="wikilink">numerical analysis</a>, <strong>Steffensen's method</strong> is a <a href="root-finding_method" title="wikilink">root-finding method</a>, similar to <a href="Newton's_method" title="wikilink">Newton's method</a>, named after <a href="Johan_Frederik_Steffensen" title="wikilink">Johan Frederik Steffensen</a>. <strong>Steffensen's method</strong> also achieves <a href="order_of_convergence" title="wikilink">quadratic convergence</a>, but without using <a href="derivative" title="wikilink">derivatives</a> as <a href="Newton's_method" title="wikilink">Newton's method</a> does.</p>
<h2 id="simple-description">Simple description</h2>

<p>The simplest form of the formula for Steffensen's method occurs when it is used to find the zeros, or roots, of a function 

<math display="inline" id="Steffensen's_method:0">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 ; that is: to find the value 

<math display="inline" id="Steffensen's_method:1">
 <semantics>
  <msub>
   <mi>x</mi>
   <mo>⋆</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>normal-⋆</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{\star}
  </annotation>
 </semantics>
</math>

 that satisfies 

<math display="inline" id="Steffensen's_method:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mo>⋆</mo>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>normal-⋆</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{\star})=0
  </annotation>
 </semantics>
</math>

 . Near the solution 

<math display="inline" id="Steffensen's_method:3">
 <semantics>
  <msub>
   <mi>x</mi>
   <mo>⋆</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>normal-⋆</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{\star}
  </annotation>
 </semantics>
</math>


 , the function 

<math display="inline" id="Steffensen's_method:4">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is supposed to approximately satisfy 

<math display="inline" id="Steffensen's_method:5">
 <semantics>
  <mrow>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo><</mo>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mo>⋆</mo>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>normal-⋆</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -1<f^{\prime}(x_{\star})<0
  </annotation>
 </semantics>
</math>

 ; this condition makes the function 

<math display="inline" id="Steffensen's_method:6">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 adequate as a correction for finding its <em>own</em> solution, although it is not required to work efficiently. For some functions, Steffensen's method can work even if this condition is not met, but in such a case, the starting value 

<math display="inline" id="Steffensen's_method:7">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

 must be <em>very</em> close to the actual solution 

<math display="inline" id="Steffensen's_method:8">
 <semantics>
  <msub>
   <mi>x</mi>
   <mo>⋆</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>normal-⋆</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{\star}
  </annotation>
 </semantics>
</math>


 , and convergence to the solution may be slow.</p>

<p>Given an adequate starting value 

<math display="inline" id="Steffensen's_method:9">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

 , a sequence of values 

<math display="inline" id="Steffensen's_method:10">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mo rspace="7.5pt">,</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo rspace="7.5pt">,</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo rspace="7.5pt">,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0},\ x_{1},\ x_{2},\dots,\ x_{n},\dots
  </annotation>
 </semantics>
</math>

 can be generated using the formula below. When it works, each value in the sequence is much closer to the solution 

<math display="inline" id="Steffensen's_method:11">
 <semantics>
  <msub>
   <mi>x</mi>
   <mo>⋆</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>normal-⋆</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{\star}
  </annotation>
 </semantics>
</math>

 than the prior value. The value 

<math display="inline" id="Steffensen's_method:12">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}
  </annotation>
 </semantics>
</math>

 from the current step generates the value 

<math display="inline" id="Steffensen's_method:13">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n+1}
  </annotation>
 </semantics>
</math>


 for the next step, via this formula:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>

<math display="block" id="Steffensen's_method:14">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>g</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n+1}=x_{n}-\frac{f(x_{n})}{g(x_{n})}
  </annotation>
 </semantics>
</math>

</p>

<p>for <em>n</em> = 0, 1, 2, 3, ... , where the slope function 

<math display="inline" id="Steffensen's_method:15">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x_{n})
  </annotation>
 </semantics>
</math>

 is a composite of the original function 

<math display="inline" id="Steffensen's_method:16">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 given by the following formula:</p>

<p>

<math display="block" id="Steffensen's_method:17">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>x</mi>
          <mi>n</mi>
         </msub>
         <mo>+</mo>
         <mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>x</mi>
            <mi>n</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <times></times>
         <ci>f</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x_{n})=\frac{f(x_{n}+f(x_{n}))-f(x_{n})}{f(x_{n})}.
  </annotation>
 </semantics>
</math>

</p>

<p>The function 

<math display="inline" id="Steffensen's_method:18">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>


 is the average value for the slope of the function 

<math display="inline" id="Steffensen's_method:19">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 between the last sequence point 

<math display="inline" id="Steffensen's_method:20">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo rspace="7.5pt">,</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)=(x_{n},\ f(x_{n}))
  </annotation>
 </semantics>
</math>

 and the auxiliary point 

<math display="inline" id="Steffensen's_method:21">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>+</mo>
     <mi>h</mi>
    </mrow>
    <mo rspace="7.5pt">,</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo>+</mo>
       <mi>h</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
    <interval closure="open">
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <ci>h</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
       <ci>h</ci>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)=(x_{n}+h,\ f(x_{n}+h))
  </annotation>
 </semantics>
</math>

 , with the step 

<math display="inline" id="Steffensen's_method:22">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>h</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h=f(x_{n})
  </annotation>
 </semantics>
</math>

 . It is also called the <a href="divided_difference" title="wikilink">first-order divided difference</a> of 

<math display="inline" id="Steffensen's_method:23">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>


 between those two points.</p>

<p>It is only for the purpose of finding 

<math display="inline" id="Steffensen's_method:24">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 for this auxiliary point that the value of the function 

<math display="inline" id="Steffensen's_method:25">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 must be an adequate correction to get closer to its own solution, and for that reason fulfill the requirement that 

<math display="inline" id="Steffensen's_method:26">
 <semantics>
  <mrow>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo><</mo>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mo>⋆</mo>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>normal-⋆</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -1<f^{\prime}(x_{\star})<0
  </annotation>
 </semantics>
</math>

 . For all other parts of the calculation, Steffensen's method only requires the function 

<math display="inline" id="Steffensen's_method:27">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 to be continuous and to actually have a nearby solution. Several modest modifications of the step 

<math display="inline" id="Steffensen's_method:28">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>


 in the slope calculation 

<math display="inline" id="Steffensen's_method:29">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 exist to accommodate functions 

<math display="inline" id="Steffensen's_method:30">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 that do not quite meet the requirement.</p>
<h2 id="advantages-and-drawbacks">Advantages and drawbacks</h2>

<p>The main advantage of Steffensen's method is that it has <a href="quadratic_convergence" title="wikilink">quadratic convergence</a> like <a href="Newton's_method" title="wikilink">Newton's method</a> – that is, both methods find roots to an equation 

<math display="inline" id="Steffensen's_method:31">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 just as ‘quickly’. In this case <em>quickly</em> means that for both methods, the number of correct digits in the answer doubles with each step. But the formula for Newton's method requires a separate function for the derivative; Steffensen's method does not. So Steffensen's method can be programmed for a generic function, as long as that function meets the constraints mentioned above.</p>

<p>The price for the quick convergence is the double function evaluation: both 

<math display="inline" id="Steffensen's_method:32">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{n})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Steffensen's_method:33">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>+</mo>
     <mi>h</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{n}+h)
  </annotation>
 </semantics>
</math>


 must be calculated, which might be time-consuming if 

<math display="inline" id="Steffensen's_method:34">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is a complicated function. For comparison, the <a href="secant_method" title="wikilink">secant method</a> needs only one function evaluation per step, so with two function evaluations the secant method can do two steps, and two steps of the secant method increase the number of correct digits by a factor of 1.6 . The equally time-consuming single step of Steffensen's (or Newton's) method increases the correct digits by a factor of 2 – which is only slightly less.</p>

<p>Similar to <a href="Newton's_method" title="wikilink">Newton's method</a> and most other <a href="Quadratic_convergence" title="wikilink">quadratically convergent</a> algorithms, the crucial weakness in Steffensen's method is the choice of the starting value 

<math display="inline" id="Steffensen's_method:35">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

 . If the value of 

<math display="inline" id="Steffensen's_method:36">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

 is not close ‘enough’ to the actual solution 

<math display="inline" id="Steffensen's_method:37">
 <semantics>
  <msub>
   <mi>x</mi>
   <mo>⋆</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>normal-⋆</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{\star}
  </annotation>
 </semantics>
</math>

 , the method may fail and the sequence of values 

<math display="inline" id="Steffensen's_method:38">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>3</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">3</cn>
    </apply>
    <ci>normal-…</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0},x_{1},x_{2},x_{3},\dots
  </annotation>
 </semantics>
</math>


 may either flip flop between two extremes, or diverge to infinity (possibly both!).</p>
<h2 id="derivation-using-aitkens-delta-squared-process">Derivation using Aitken's delta-squared process</h2>

<p>The version of Steffensen's method implemented in the <a class="uri" href="MATLAB" title="wikilink">MATLAB</a> code shown below can be found using the <a href="Aitken's_delta-squared_process" title="wikilink">Aitken's delta-squared process</a> for accelerating convergence of a sequence. To compare the following formulae to the formulae in the section above, notice that 

<math display="inline" id="Steffensen's_method:39">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <mi>p</mi>
    </mpadded>
    <mo rspace="7.5pt">-</mo>
    <msub>
     <mi>p</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>p</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}=p\ -\ p_{n}
  </annotation>
 </semantics>
</math>

 . This method assumes starting with a linearly convergent sequence and increases the rate of convergence of that sequence. If the signs of 

<math display="inline" id="Steffensen's_method:40">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mi>n</mi>
   </msub>
   <mo rspace="7.5pt">,</mo>
   <msub>
    <mi>p</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo rspace="7.5pt">,</mo>
   <msub>
    <mi>p</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>2</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{n},\ p_{n+1},\ p_{n+2}
  </annotation>
 </semantics>
</math>

 agree and 

<math display="inline" id="Steffensen's_method:41">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{n}
  </annotation>
 </semantics>
</math>

 is sufficiently close to the desired limit of the sequence 

<math display="inline" id="Steffensen's_method:42">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, we can assume the following:</p>

<p>

<math display="block" id="Steffensen's_method:43">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <msub>
      <mi>p</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>-</mo>
     <mi>p</mi>
    </mrow>
    <mrow>
     <msub>
      <mi>p</mi>
      <mi>n</mi>
     </msub>
     <mo>-</mo>
     <mi>p</mi>
    </mrow>
   </mfrac>
   <mo>≈</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>p</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>2</mn>
      </mrow>
     </msub>
     <mo>-</mo>
     <mi>p</mi>
    </mrow>
    <mrow>
     <msub>
      <mi>p</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>-</mo>
     <mi>p</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>p</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
      <ci>p</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>p</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{p_{n+1}-p}{p_{n}-p}\approx\frac{p_{n+2}-p}{p_{n+1}-p}
  </annotation>
 </semantics>
</math>

 then</p>

<p>

<math display="block" id="Steffensen's_method:44">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>p</mi>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo>-</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>≈</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>p</mi>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>2</mn>
       </mrow>
      </msub>
      <mo>-</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>n</mi>
      </msub>
      <mo>-</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>p</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>p</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p_{n+1}-p)^{2}\approx(p_{n+2}-p)(p_{n}-p)
  </annotation>
 </semantics>
</math>

 so</p>

<p>

<math display="block" id="Steffensen's_method:45">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mi>p</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mn>2</mn>
     </msubsup>
     <mo>-</mo>
     <mrow>
      <mn>2</mn>
      <msub>
       <mi>p</mi>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mi>p</mi>
     </mrow>
    </mrow>
    <mo>+</mo>
    <msup>
     <mi>p</mi>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>p</mi>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>2</mn>
       </mrow>
      </msub>
      <msub>
       <mi>p</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>p</mi>
         <mi>n</mi>
        </msub>
        <mo>+</mo>
        <msub>
         <mi>p</mi>
         <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mn>2</mn>
         </mrow>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>p</mi>
     </mrow>
    </mrow>
    <mo>+</mo>
    <msup>
     <mi>p</mi>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>p</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
       <ci>p</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{n+1}^{2}-2p_{n+1}p+p^{2}\approx p_{n+2}p_{n}-(p_{n}+p_{n+2})p+p^{2}
  </annotation>
 </semantics>
</math>

 and hence</p>

<p>

<math display="block" id="Steffensen's_method:46">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>p</mi>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>2</mn>
        </mrow>
       </msub>
       <mo>-</mo>
       <mrow>
        <mn>2</mn>
        <msub>
         <mi>p</mi>
         <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mrow>
      </mrow>
      <mo>+</mo>
      <msub>
       <mi>p</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>p</mi>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>p</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>2</mn>
      </mrow>
     </msub>
     <msub>
      <mi>p</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo>-</mo>
    <msubsup>
     <mi>p</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mn>2</mn>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>p</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p_{n+2}-2p_{n+1}+p_{n})p\approx p_{n+2}p_{n}-p_{n+1}^{2}
  </annotation>
 </semantics>
</math>

 .<br/>
Solving for the desired limit of the sequence 

<math display="inline" id="Steffensen's_method:47">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 gives:<br/>


<math display="block" id="Steffensen's_method:48">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>≈</mo>
   <mfrac>
    <mrow>
     <mrow>
      <msub>
       <mi>p</mi>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>2</mn>
       </mrow>
      </msub>
      <msub>
       <mi>p</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo>-</mo>
     <msubsup>
      <mi>p</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mn>2</mn>
     </msubsup>
    </mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>p</mi>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>2</mn>
       </mrow>
      </msub>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <msub>
        <mi>p</mi>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mrow>
     </mrow>
     <mo>+</mo>
     <msub>
      <mi>p</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>p</ci>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\approx\frac{p_{n+2}p_{n}-p_{n+1}^{2}}{p_{n+2}-2p_{n+1}+p_{n}}
  </annotation>
 </semantics>
</math>

<br/>


<math display="block" id="Steffensen's_method:49">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <msubsup>
       <mi>p</mi>
       <mi>n</mi>
       <mn>2</mn>
      </msubsup>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>p</mi>
        <mi>n</mi>
       </msub>
       <msub>
        <mi>p</mi>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>2</mn>
        </mrow>
       </msub>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mn>2</mn>
       <msub>
        <mi>p</mi>
        <mi>n</mi>
       </msub>
       <msub>
        <mi>p</mi>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mn>2</mn>
      <msub>
       <mi>p</mi>
       <mi>n</mi>
      </msub>
      <msub>
       <mi>p</mi>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
     <mo>-</mo>
     <msubsup>
      <mi>p</mi>
      <mi>n</mi>
      <mn>2</mn>
     </msubsup>
     <mo>-</mo>
     <msubsup>
      <mi>p</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mn>2</mn>
     </msubsup>
    </mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>p</mi>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>2</mn>
       </mrow>
      </msub>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <msub>
        <mi>p</mi>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mrow>
     </mrow>
     <mo>+</mo>
     <msub>
      <mi>p</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>n</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>n</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\frac{p_{n}^{2}+p_{n}p_{n+2}+2p_{n}p_{n+1}-2p_{n}p_{n+1}-p_{n}^{2}-p_{n+1}^{2%
}}{p_{n+2}-2p_{n+1}+p_{n}}
  </annotation>
 </semantics>
</math>

<br/>


<math display="block" id="Steffensen's_method:50">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msubsup>
         <mi>p</mi>
         <mi>n</mi>
         <mn>2</mn>
        </msubsup>
        <mo>+</mo>
        <mrow>
         <msub>
          <mi>p</mi>
          <mi>n</mi>
         </msub>
         <msub>
          <mi>p</mi>
          <mrow>
           <mi>n</mi>
           <mo>+</mo>
           <mn>2</mn>
          </mrow>
         </msub>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mn>2</mn>
        <msub>
         <mi>p</mi>
         <mi>n</mi>
        </msub>
        <msub>
         <mi>p</mi>
         <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msubsup>
         <mi>p</mi>
         <mi>n</mi>
         <mn>2</mn>
        </msubsup>
        <mo>-</mo>
        <mrow>
         <mn>2</mn>
         <msub>
          <mi>p</mi>
          <mi>n</mi>
         </msub>
         <msub>
          <mi>p</mi>
          <mrow>
           <mi>n</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </mrow>
       </mrow>
       <mo>+</mo>
       <msubsup>
        <mi>p</mi>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mn>2</mn>
       </msubsup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>p</mi>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>2</mn>
       </mrow>
      </msub>
      <mo>-</mo>
      <mrow>
       <mn>2</mn>
       <msub>
        <mi>p</mi>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mrow>
     </mrow>
     <mo>+</mo>
     <msub>
      <mi>p</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <minus></minus>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <ci>n</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <ci>n</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <apply>
           <plus></plus>
           <ci>n</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <ci>n</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <ci>n</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <apply>
           <plus></plus>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\frac{(p_{n}^{2}+p_{n}p_{n+2}-2p_{n}p_{n+1})-(p_{n}^{2}-2p_{n}p_{n+1}+p_{n+1}%
^{2})}{p_{n+2}-2p_{n+1}+p_{n}}
  </annotation>
 </semantics>
</math>

<br/>


<math display="block" id="Steffensen's_method:51">
 <semantics>
  <mrow>
   <mrow>
    <mi></mi>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>p</mi>
      <mi>n</mi>
     </msub>
     <mo>-</mo>
     <mfrac>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>p</mi>
          <mrow>
           <mi>n</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>p</mi>
          <mi>n</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mrow>
       <mrow>
        <msub>
         <mi>p</mi>
         <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mn>2</mn>
         </mrow>
        </msub>
        <mo>-</mo>
        <mrow>
         <mn>2</mn>
         <msub>
          <mi>p</mi>
          <mrow>
           <mi>n</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </mrow>
       </mrow>
       <mo>+</mo>
       <msub>
        <mi>p</mi>
        <mi>n</mi>
       </msub>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <apply>
           <plus></plus>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =p_{n}-\frac{(p_{n+1}-p_{n})^{2}}{p_{n+2}-2p_{n+1}+p_{n}},
  </annotation>
 </semantics>
</math>

<br/>
which results in the more rapidly convergent sequence:<br/>
</p>

<p>

<math display="block" id="Steffensen's_method:52">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mo>≈</mo>
    <msub>
     <mi>p</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>3</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>p</mi>
      <mi>n</mi>
     </msub>
     <mo>-</mo>
     <mfrac>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>p</mi>
          <mrow>
           <mi>n</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>p</mi>
          <mi>n</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mrow>
       <mrow>
        <msub>
         <mi>p</mi>
         <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mn>2</mn>
         </mrow>
        </msub>
        <mo>-</mo>
        <mrow>
         <mn>2</mn>
         <msub>
          <mi>p</mi>
          <mrow>
           <mi>n</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </mrow>
       </mrow>
       <mo>+</mo>
       <msub>
        <mi>p</mi>
        <mi>n</mi>
       </msub>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <approx></approx>
     <ci>p</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <apply>
           <plus></plus>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <ci>n</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <apply>
           <plus></plus>
           <ci>n</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>p</ci>
           <apply>
            <plus></plus>
            <ci>n</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\approx p_{n+3}=p_{n}-\frac{(p_{n+1}-p_{n})^{2}}{p_{n+2}-2p_{n+1}+p_{n}}.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="implementation-in-matlab">Implementation in Matlab</h2>

<p>Here is the source for an implementation of Steffensen's Method in <a class="uri" href="MATLAB" title="wikilink">MATLAB</a>.</p>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab">function Steffensen(f,p0,tol)
<span class="co">% This function takes as inputs: a fixed point iteration function, f, </span>
<span class="co">% and initial guess to the fixed point, p0, and a tolerance, tol.</span>
<span class="co">% The fixed point iteration function is assumed to be input as an</span>
<span class="co">% inline function. </span>
<span class="co">% This function will calculate and return the fixed point, p, </span>
<span class="co">% that makes the expression f(x) = p true to within the desired </span>
<span class="co">% tolerance, tol. </span>

format compact <span class="co">% This shortens the output.</span>
format long    <span class="co">% This prints more decimal places. </span>

for i=<span class="fl">1</span>:<span class="fl">1000</span>   <span class="co">% get ready to do a large, but finite, number of iterations.</span>
               <span class="co">% This is so that if the method fails to converge, we won't</span>
               <span class="co">% be stuck in an infinite loop.</span>
    p1=f(p0);  <span class="co">% calculate the next two guesses for the fixed point.</span>
    p2=f(p1);
    p=p0-(p1-p0)^<span class="fl">2</span>/(p2-<span class="fl">2</span>*p1+p0) <span class="co">% use Aitken's delta squared method to</span>
                                <span class="co">% find a better approximation to p0.</span>
    if abs(p-p0)<tol <span="" class="co">%="" abs(p-p0)="" answer.="" are="" are,="" break="" end="" for="" have="" if="" iteration.="" iterations,="" next="" our="" p0="" see="" stop="" test="" the="" to="" tolerance.="" update="" we="" within=""&gt;tol       % If we fail to meet the tolerance, we output a</tol></code></pre></div></body>
<span class="co">% message of failure.</span>
<span class="st">'failed to converge in 1000 iterations.'</span>
end

<h2 id="generalization">Generalization</h2>

<p>Steffensen's method can also be used to find an input 

<math display="inline" id="Steffensen's_method:53">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mo>⋆</mo>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>normal-⋆</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=x_{\star}
  </annotation>
 </semantics>
</math>


 for a different kind of function 

<math display="inline" id="Steffensen's_method:54">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 that produces output the same as its input

<math display="block" id="Steffensen's_method:55">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mo>⋆</mo>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mo>⋆</mo>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>normal-⋆</ci>
    </apply>
    <apply>
     <times></times>
     <ci>F</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>normal-⋆</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{\star}=F(x_{\star})
  </annotation>
 </semantics>
</math>

 for the special value 

<math display="inline" id="Steffensen's_method:56">
 <semantics>
  <msub>
   <mi>x</mi>
   <mo>⋆</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>normal-⋆</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{\star}
  </annotation>
 </semantics>
</math>

 . Solutions like 

<math display="inline" id="Steffensen's_method:57">
 <semantics>
  <msub>
   <mi>x</mi>
   <mo>⋆</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>normal-⋆</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{\star}
  </annotation>
 </semantics>
</math>

 are called <em><a href="fixed_point_(mathematics)" title="wikilink">fixed points</a></em>. Many such functions can be used to find their own solutions by repeatedly recycling the result back as input, but the rate of convergence can be slow, or the function can fail to converge at all, depending on the individual function. Steffensen's method accelerates this convergence, to make it <a href="quadratic_convergence" title="wikilink">quadratic</a>.</p>

<p>This method for finding fixed points of a real-valued function has been generalised for functions 

<math display="inline" id="Steffensen's_method:58">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>:</mo>
   <mrow>
    <mi>X</mi>
    <mo>→</mo>
    <mi>X</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>F</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F:X\to X
  </annotation>
 </semantics>
</math>


 on a <a href="Banach_space" title="wikilink">Banach space</a> 

<math display="inline" id="Steffensen's_method:59">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 . The generalised method assumes that a <a href="Indexed_family" title="wikilink">family</a> of <a href="Bounded_set" title="wikilink">bounded</a> <a href="linear_operators" title="wikilink">linear operators</a> 

<math display="inline" id="Steffensen's_method:60">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
    </mrow>
    <mo>∈</mo>
    <mi>X</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <times></times>
     <ci>L</ci>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
    </apply>
    <apply>
     <in></in>
     <list>
      <ci>u</ci>
      <ci>v</ci>
     </list>
     <ci>X</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{L(u,v):u,v\in X\}
  </annotation>
 </semantics>
</math>

 associated with 

<math display="inline" id="Steffensen's_method:61">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Steffensen's_method:62">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 can be found to satisfy the condition<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>

<math display="block" id="Steffensen's_method:63">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>F</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>F</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>u</mi>
       <mo>-</mo>
       <mi>v</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>u</ci>
     </apply>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>L</ci>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
     <apply>
      <minus></minus>
      <ci>u</ci>
      <ci>v</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(u)-F(v)=L(u,v)\ (u-v).
  </annotation>
 </semantics>
</math>

</p>

<p>In the simple form given in the section above, the function 

<math display="inline" id="Steffensen's_method:64">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 simply takes in and produces real numbers. There, the function 

<math display="inline" id="Steffensen's_method:65">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 is a <em><a href="divided_difference" title="wikilink">divided difference</a></em>. In the generalized form here, the operator 

<math display="inline" id="Steffensen's_method:66">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is the analogue of a divided difference for use in the <a href="Banach_space" title="wikilink">Banach space</a>. The operator 

<math display="inline" id="Steffensen's_method:67">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is equivalent to a <a href="Matrix_(mathematics)" title="wikilink">matrix</a> whose entries are all functions of <a href="vector_(mathematics)" title="wikilink">vector</a> <a href="Argument_of_a_function" title="wikilink">arguments</a> 

<math display="inline" id="Steffensen's_method:68">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Steffensen's_method:69">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

.</p>

<p>Steffensen's method is then very similar to the Newton's method, except that it uses the divided difference

<math display="inline" id="Steffensen's_method:70">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>x</ci>
     </apply>
     <ci>x</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(F(x),x)
  </annotation>
 </semantics>
</math>

 instead of the derivative 

<math display="inline" id="Steffensen's_method:71">
 <semantics>
  <mrow>
   <msup>
    <mi>F</mi>
    <mo>′</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>F</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F^{\prime}(x)
  </annotation>
 </semantics>
</math>

 . It is thus defined by</p>

<p>

<math display="block" id="Steffensen's_method:72">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>+</mo>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mi>I</mi>
         <mo>-</mo>
         <mrow>
          <mi>L</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>F</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <msub>
              <mi>x</mi>
              <mi>n</mi>
             </msub>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo>,</mo>
           <msub>
            <mi>x</mi>
            <mi>n</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>F</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mi>n</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <minus></minus>
         <ci>I</ci>
         <apply>
          <times></times>
          <ci>L</ci>
          <interval closure="open">
           <apply>
            <times></times>
            <ci>F</ci>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <ci>n</ci>
            </apply>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>n</ci>
           </apply>
          </interval>
         </apply>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>F</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n+1}=x_{n}+[I-L(F(x_{n}),x_{n})]^{-1}(F(x_{n})-x_{n}),
  </annotation>
 </semantics>
</math>

</p>

<p>for 

<math display="inline" id="Steffensen's_method:73">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mn>3</mn>
    <mo rspace="7.5pt">,</mo>
    <mi mathvariant="normal">…</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <list>
     <cn type="integer">1</cn>
     <cn type="float">2</cn>
     <cn type="float">3</cn>
     <ci>normal-…</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=1,\ 2,\ 3,\ ...
  </annotation>
 </semantics>
</math>


 , and where 

<math display="inline" id="Steffensen's_method:74">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 is the identity operator.</p>

<p>If the operator 

<math display="inline" id="Steffensen's_method:75">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 satisfies</p>

<p>

<math display="block" id="Steffensen's_method:76">
 <semantics>
  <mrow>
   <mrow>
    <mo>∥</mo>
    <mrow>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo>,</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>∥</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>K</mi>
    <mrow>
     <mo maxsize="120%" minsize="120%">(</mo>
     <mrow>
      <mrow>
       <mo>∥</mo>
       <mrow>
        <mi>u</mi>
        <mo>-</mo>
        <mi>x</mi>
       </mrow>
       <mo>∥</mo>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mo>∥</mo>
       <mrow>
        <mi>v</mi>
        <mo>-</mo>
        <mi>y</mi>
       </mrow>
       <mo>∥</mo>
      </mrow>
     </mrow>
     <mo maxsize="120%" minsize="120%">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>L</ci>
       <interval closure="open">
        <ci>u</ci>
        <ci>v</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>L</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>K</ci>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <ci>u</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <ci>v</ci>
        <ci>y</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|L(u,v)-L(x,y)\|\leq K\big(\|u-x\|+\|v-y\|\big)
  </annotation>
 </semantics>
</math>

</p>

<p>for some constant 

<math display="inline" id="Steffensen's_method:77">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 , then the method converges quadratically to a fixed point of 

<math display="inline" id="Steffensen's_method:78">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>


 if the initial approximation 

<math display="inline" id="Steffensen's_method:79">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}
  </annotation>
 </semantics>
</math>

 is "sufficiently close" to the desired solution 

<math display="inline" id="Steffensen's_method:80">
 <semantics>
  <msub>
   <mi>x</mi>
   <mo>⋆</mo>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>normal-⋆</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{\star}
  </annotation>
 </semantics>
</math>

 , that satisfies 

<math display="inline" id="Steffensen's_method:81">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mo>⋆</mo>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mo>⋆</mo>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>normal-⋆</ci>
    </apply>
    <apply>
     <times></times>
     <ci>F</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>normal-⋆</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{\star}=F(x_{\star})
  </annotation>
 </semantics>
</math>

 .</p>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Root-finding_algorithms" title="wikilink">Category:Root-finding algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="Germund_Dahlquist" title="wikilink">Germund Dahlquist</a>, Åke Björck, tr. Ned Anderson. (1974). <em>Numerical Methods</em>, pp. 230–231. Englewood Cliffs, NJ: Prentice Hall.<a href="#fnref1">↩</a></li>
<li id="fn2">Johnson, L. W. &amp; Scholz, D. R. (1968). On Steffensen's Method. <em>SIAM Journal on Numerical Analysis</em>, <em>5</em> (2), 296–302, (June 1968). Stable URL: <a href="http://links.jstor.org/sici?sici=0036-1429%28196806%295%3A2%3C296%3AOSM%3E2.0.CO%3B2-H">1</a><a href="#fnref2">↩</a></li>
</ol>
</section>


