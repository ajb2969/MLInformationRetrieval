<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="324">IP (complexity)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>IP (complexity)</h1>
<hr>In [[computational complexity theory]], the class '''IP''' (which stands for Interactive Polynomial time) is the class of problems solvable
<p><code>by an </code><a href="interactive_proof_system" title="wikilink"><code>interactive</code> <code>proof</code> <code>system</code></a><code>.  The concept of an interactive proof system was first introduced by </code><a href="Shafi_Goldwasser" title="wikilink"><code>Shafi</code> <code>Goldwasser</code></a><code>, </code><a href="Silvio_Micali" title="wikilink"><code>Silvio</code> <code>Micali</code></a><code>, and </code><a href="Charles_Rackoff" title="wikilink"><code>Charles</code> <code>Rackoff</code></a><code> in 1985. An interactive proof system consists of two machines, a prover, </code><em><code>P</code></em><code>, which presents a proof that a given string </code><em><code>n</code></em><code> is a member of some </code><a href="formal_language" title="wikilink"><code>language</code></a><code>, and a verifier, </code><em><code>V</code></em><code>, that checks that the presented proof is correct. The prover is assumed to be infinite in computation and storage, while the verifier is a probabilistic polynomial-time machine with access to a random bit string whose length is polynomial on the size of </code><em><code>n</code></em><code>. These two machines exchange a polynomial number, </code><em><code>p</code></em><code>(</code><em><code>n</code></em><code>), of messages and once the interaction is completed, the verifier must decide whether or not </code><em><code>n</code></em><code> is in the language, with only a 1/3 chance of error. (So any language in </code><strong><a href="Bounded-error_probabilistic_polynomial" title="wikilink"><code>BPP</code></a></strong><code> is in </code><strong><code>IP</code></strong><code>, since then the verifier could simply ignore the prover and make the decision on its own.)</code></p>
<figure><b>(Figure)</b>
<figcaption>General representation of an interactive proof protocol.</figcaption>
</figure>
<h2 id="definition">Definition</h2>

<p>A language <em>L</em> belongs to <strong>IP</strong> if there exist <em>V</em>, <em>P</em> such that for all <em>Q</em>, <em>w</em>:</p>

<p>

<math display="block" id="IP_(complexity):0">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>∈</mo>
   <mi>L</mi>
   <mo>⇒</mo>
   <mrow>
    <mi>Pr</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>V</mi>
      <mo>↔</mo>
      <mrow>
       <mi>P</mi>
       <mtext>accepts</mtext>
       <mi>w</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mstyle displaystyle="false">
    <mfrac>
     <mn>2</mn>
     <mn>3</mn>
    </mfrac>
   </mstyle>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <ci>w</ci>
     <ci>L</ci>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>Pr</ci>
      <apply>
       <ci>normal-↔</ci>
       <ci>V</ci>
       <apply>
        <times></times>
        <ci>P</ci>
        <mtext>accepts</mtext>
        <ci>w</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\in L\Rightarrow\Pr[V\leftrightarrow P\text{ accepts }w]\geq\tfrac{2}{3}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="IP_(complexity):1">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>∉</mo>
   <mi>L</mi>
   <mo>⇒</mo>
   <mrow>
    <mi>Pr</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>V</mi>
      <mo>↔</mo>
      <mrow>
       <mi>Q</mi>
       <mtext>accepts</mtext>
       <mi>w</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mstyle displaystyle="false">
    <mfrac>
     <mn>1</mn>
     <mn>3</mn>
    </mfrac>
   </mstyle>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <notin></notin>
     <ci>w</ci>
     <ci>L</ci>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>Pr</ci>
      <apply>
       <ci>normal-↔</ci>
       <ci>V</ci>
       <apply>
        <times></times>
        <ci>Q</ci>
        <mtext>accepts</mtext>
        <ci>w</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\not\in L\Rightarrow\Pr[V\leftrightarrow Q\text{ accepts }w]\leq\tfrac{1}{3}
  </annotation>
 </semantics>
</math>

</p>

<p>The <a href="Arthur–Merlin_protocol" title="wikilink">Arthur–Merlin protocol</a>, introduced by <a href="Laszlo_Babai" title="wikilink">Laszlo Babai</a>, is similar in nature, except that the number of rounds of interaction is bounded by a constant rather than a polynomial.</p>

<p>Goldwasser et al. have shown that <em>public-coin</em> protocols, where the random numbers used by the verifier are provided to the prover along with the challenges, are no less powerful than private-coin protocols. At most two additional rounds of interaction are required to replicate the effect of a private-coin protocol. The opposite inclusion is straightforward, because the verifier can always send to the prover the results of their private coin tosses, which proves that the two types of protocols are equivalent.</p>

<p>In the following section we prove that <strong>IP</strong> = <strong>PSPACE</strong>, an important theorem in computational complexity, which demonstrates that an interactive proof system can be used to decide whether a string is a member of a language in polynomial time, even though the traditional <strong><a class="uri" href="PSPACE" title="wikilink">PSPACE</a></strong> proof may be exponentially long.</p>

<p>==Proof of IP = PSPACE== The proof can be divided in two parts, we show that <strong>IP</strong> ⊆ <strong>PSPACE</strong> and <strong>PSPACE</strong> ⊆ <strong>IP</strong>. The intuition in this proof is that polynomials form good <a href="error-correcting_code" title="wikilink">error-correcting codes</a>. Or Meir has shown<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> that this can be made precise: after some work the proof can be modified not to refer to polynomials, but to more abstract, arguably more natural, setting of error-correcting codes.</p>
<h3 id="ip-pspace">IP ⊆ PSPACE</h3>

<p>In order to demonstrate that <strong>IP</strong> ⊆ <strong>PSPACE</strong>, we present a simulation of an interactive proof system by a polynomial space machine. Now, we can define:</p>

<p>

<math display="block" id="IP_(complexity):2">
 <semantics>
  <mrow>
   <mrow>
    <mi>Pr</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>V</mi>
      <mtext>accepts</mtext>
      <mi>w</mi>
      <mtext>starting at</mtext>
      <msub>
       <mi>M</mi>
       <mi>j</mi>
      </msub>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>max</mi>
     <mi>P</mi>
    </msub>
    <mrow>
     <mi>Pr</mi>
     <mrow>
      <mo>[</mo>
      <mrow>
       <mi>V</mi>
       <mo>↔</mo>
       <mrow>
        <mi>P</mi>
        <mtext>accepts</mtext>
        <mi>w</mi>
        <mtext>starting at</mtext>
        <msub>
         <mi>M</mi>
         <mi>j</mi>
        </msub>
       </mrow>
      </mrow>
      <mo>]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>Pr</ci>
     <apply>
      <times></times>
      <ci>V</ci>
      <mtext>accepts</mtext>
      <ci>w</ci>
      <mtext>starting at</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <ci>P</ci>
     </apply>
     <apply>
      <ci>Pr</ci>
      <apply>
       <ci>normal-↔</ci>
       <ci>V</ci>
       <apply>
        <times></times>
        <ci>P</ci>
        <mtext>accepts</mtext>
        <ci>w</ci>
        <mtext>starting at</mtext>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>M</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr[V\text{ accepts }w\text{ starting at }M_{j}]=\max\nolimits_{P}\Pr\left[V%
\leftrightarrow P\text{ accepts }w\text{ starting at }M_{j}\right]
  </annotation>
 </semantics>
</math>

</p>

<p>and for every 0 ≤ <em>j</em> ≤ <em>p</em> and every message history <em>M<sub>j</sub></em>, we inductively define the function <em>N<sub>M<sub>j</sub></sub></em>:</p>

<p>

<math display="block" id="IP_(complexity):3">
 <semantics>
  <mrow>
   <msub>
    <mi>N</mi>
    <msub>
     <mi>M</mi>
     <mi>j</mi>
    </msub>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mrow>
         <mi>p</mi>
         <mtext>and</mtext>
         <msub>
          <mi>m</mi>
          <mi>p</mi>
         </msub>
        </mrow>
        <mo>=</mo>
        <mtext>reject</mtext>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mrow>
         <mi>p</mi>
         <mtext>and</mtext>
         <msub>
          <mi>m</mi>
          <mi>p</mi>
         </msub>
        </mrow>
        <mo>=</mo>
        <mtext>accept</mtext>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <msub>
         <mi>max</mi>
         <msub>
          <mi>m</mi>
          <mrow>
           <mi>j</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </msub>
        <msub>
         <mi>N</mi>
         <msub>
          <mi>M</mi>
          <mrow>
           <mi>j</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </msub>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mi>j</mi>
        <mo><</mo>
        <mrow>
         <mi>p</mi>
         <mtext>and</mtext>
         <mi>j</mi>
         <mtext>is odd</mtext>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <msub>
         <mtext>wt-avg</mtext>
         <msub>
          <mi>m</mi>
          <mrow>
           <mi>j</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </msub>
        <msub>
         <mi>N</mi>
         <msub>
          <mi>M</mi>
          <mrow>
           <mi>j</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </msub>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mi>j</mi>
        <mo><</mo>
        <mrow>
         <mi>p</mi>
         <mtext>and</mtext>
         <mi>j</mi>
         <mtext>is even</mtext>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>N</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <and></and>
      <apply>
       <eq></eq>
       <ci>j</ci>
       <apply>
        <times></times>
        <ci>p</ci>
        <mtext>and</mtext>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <ci>p</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <share href="#.cmml">
       </share>
       <mtext>reject</mtext>
      </apply>
     </apply>
     <cn type="integer">1</cn>
     <apply>
      <and></and>
      <apply>
       <eq></eq>
       <ci>j</ci>
       <apply>
        <times></times>
        <ci>p</ci>
        <mtext>and</mtext>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <ci>p</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <share href="#.cmml">
       </share>
       <mtext>accept</mtext>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <max></max>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <apply>
         <plus></plus>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <apply>
         <plus></plus>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <lt></lt>
      <ci>j</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <mtext>and</mtext>
       <ci>j</ci>
       <mtext>is odd</mtext>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>wt-avg</mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <apply>
         <plus></plus>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <apply>
         <plus></plus>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <lt></lt>
      <ci>j</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <mtext>and</mtext>
       <ci>j</ci>
       <mtext>is even</mtext>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{M_{j}}=\begin{cases}0&j=p\text{ and }m_{p}=\text{reject}\\
1&j=p\text{ and }m_{p}=\text{accept}\\
\max_{m_{j+1}}N_{M_{j+1}}&j<p\text{ and }j\text{ is odd}\\
\text{wt-avg}_{m_{j+1}}N_{M_{j+1}}&j<p\text{ and }j\text{ is even}\\
\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>where:</p>

<p>

<math display="block" id="IP_(complexity):4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mtext>wt-avg</mtext>
     <msub>
      <mi>m</mi>
      <mrow>
       <mi>j</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </msub>
    <msub>
     <mi>N</mi>
     <msub>
      <mi>M</mi>
      <mrow>
       <mi>j</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </msub>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <msub>
      <mi>m</mi>
      <mrow>
       <mi>j</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </msub>
    <mrow>
     <msub>
      <mi>Pr</mi>
      <mi>r</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>V</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>w</mi>
        <mo>,</mo>
        <mi>r</mi>
        <mo>,</mo>
        <msub>
         <mi>M</mi>
         <mi>j</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>wt-avg</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <apply>
        <plus></plus>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <apply>
        <plus></plus>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <apply>
        <plus></plus>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Pr</ci>
       <ci>r</ci>
      </apply>
      <apply>
       <times></times>
       <ci>V</ci>
       <vector>
        <ci>w</ci>
        <ci>r</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>M</ci>
         <ci>j</ci>
        </apply>
       </vector>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{wt-avg}_{m_{j+1}}N_{M_{j+1}}:=\sum\nolimits_{m_{j+1}}\Pr\nolimits_{r}[V(%
w,r,M_{j})]
  </annotation>
 </semantics>
</math>

</p>

<p>where Pr<sub><em>r</em></sub> is the probability taken over the random string <em>r</em> of length <em>p</em>. This expression is the average of <em>N<sub>M<sub>j+1</sub></sub></em>, weighted by the probability that the verifier sent message <em>m<sub>j+1</sub></em>.</p>

<p>Take <em>M</em><sub>0</sub> to be the empty message sequence, here we will show that <em>N<sub>M<sub>0</sub></sub></em> can be computed in polynomial space, and that <em>N<sub>M<sub>0</sub></sub></em> = Pr[<em>V</em> accepts <em>w</em>]. First, to compute <em>N<sub>M<sub>0</sub></sub></em>, an algorithm can recursively calculate the values <em>N<sub>M<sub>j</sub></sub></em> for every <em>j</em> and <em>M<sub>j</sub></em>. Since the depth of the recursion is <em>p</em>, only polynomial space is necessary. The second requirement is that we need <em>N<sub>M<sub>0</sub></sub></em> = Pr[<em>V</em> accepts <em>w</em>], the value needed to determine whether <em>w</em> is in A. We use induction to prove this as follows.</p>

<p>We must show that for every 0 ≤ <em>j</em> ≤ <em>p</em> and every <em>M<sub>j</sub></em>, <em>N<sub>M<sub>j</sub></sub></em> = Pr[<em>V</em> accepts <em>w</em> starting at <em>M<sub>j</sub></em>], and we will do this using induction on <em>j</em>. The base case is to prove for <em>j</em> = <em>p</em>. Then we will use induction to go from <em>p</em> down to 0.</p>

<p>The base case of <em>j</em> = <em>p</em> is fairly simple. Since <em>m<sub>p</sub></em> is either accept or reject, if <em>m<sub>p</sub></em> is accept, <em>N<sub>M<sub>p</sub></sub></em> is defined to be 1 and Pr[<em>V</em> accepts <em>w</em> starting at <em>M<sub>j</sub></em>] = 1 since the message stream indicates acceptance, thus the claim is true. If <em>m<sub>p</sub></em> is reject, the argument is very similar.</p>

<p>For the inductive hypothesis, we assume that for some <em>j</em>+1 ≤ <em>p</em> and any message sequence <em>M<sub>j+1</sub></em>, <em>N<sub>M<sub>j</sub></sub></em> = Pr[<em>V</em> accepts <em>w</em> starting at <em>j</em>+1] and then prove the hypothesis for <em>j</em> and any message sequence <em>M<sub>j</sub></em>.</p>

<p>If <em>j</em> is even, <em>m<sub>j+1</sub></em> is a message from <em>V</em> to <em>P</em>. By the definition of <em>N<sub>M<sub>j</sub></sub></em>,</p>

<p>

<math display="block" id="IP_(complexity):5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>N</mi>
     <msub>
      <mi>M</mi>
      <mi>j</mi>
     </msub>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <msub>
       <mi>m</mi>
       <mrow>
        <mi>j</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </msub>
     <mrow>
      <mrow>
       <msub>
        <mi>Pr</mi>
        <mi>r</mi>
       </msub>
       <mrow>
        <mo>[</mo>
        <mrow>
         <mrow>
          <mi>V</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>w</mi>
           <mo>,</mo>
           <mi>r</mi>
           <mo>,</mo>
           <msub>
            <mi>M</mi>
            <mi>j</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>=</mo>
         <msub>
          <mi>m</mi>
          <mrow>
           <mi>j</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </mrow>
        <mo>]</mo>
       </mrow>
      </mrow>
      <msub>
       <mi>N</mi>
       <msub>
        <mi>M</mi>
        <mrow>
         <mi>j</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>N</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <apply>
        <plus></plus>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Pr</ci>
        <ci>r</ci>
       </apply>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <ci>V</ci>
         <vector>
          <ci>w</ci>
          <ci>r</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>M</ci>
           <ci>j</ci>
          </apply>
         </vector>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <apply>
          <plus></plus>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>N</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <apply>
         <plus></plus>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{M_{j}}=\sum\nolimits_{m_{j+1}}\Pr\nolimits_{r}\left[V(w,r,M_{j})=m_{j+1}%
\right]N_{M_{j+1}}.
  </annotation>
 </semantics>
</math>

</p>

<p>Then, by the inductive hypothesis, we can say this is equal to</p>

<p>

<math display="block" id="IP_(complexity):6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <msub>
      <mi>m</mi>
      <mrow>
       <mi>j</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </msub>
    <mrow>
     <mrow>
      <msub>
       <mi>Pr</mi>
       <mi>r</mi>
      </msub>
      <mrow>
       <mo>[</mo>
       <mrow>
        <mrow>
         <mi>V</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>w</mi>
          <mo>,</mo>
          <mi>r</mi>
          <mo>,</mo>
          <msub>
           <mi>M</mi>
           <mi>j</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>=</mo>
        <msub>
         <mi>m</mi>
         <mrow>
          <mi>j</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mrow>
       <mo>]</mo>
      </mrow>
     </mrow>
     <mo>*</mo>
     <mrow>
      <mi>Pr</mi>
      <mrow>
       <mo>[</mo>
       <mrow>
        <mi>V</mi>
        <mtext>accepts</mtext>
        <mi>w</mi>
        <mtext>starting at</mtext>
        <msub>
         <mi>M</mi>
         <mrow>
          <mi>j</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mrow>
       <mo>]</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <apply>
       <plus></plus>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Pr</ci>
       <ci>r</ci>
      </apply>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <ci>V</ci>
        <vector>
         <ci>w</ci>
         <ci>r</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>M</ci>
          <ci>j</ci>
         </apply>
        </vector>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <apply>
         <plus></plus>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>Pr</ci>
      <apply>
       <times></times>
       <ci>V</ci>
       <mtext>accepts</mtext>
       <ci>w</ci>
       <mtext>starting at</mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <apply>
         <plus></plus>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum\nolimits_{m_{j+1}}\Pr\nolimits_{r}\left[V(w,r,M_{j})=m_{j+1}\right]*\Pr%
\left[V\text{ accepts }w\text{ starting at }M_{j+1}\right].
  </annotation>
 </semantics>
</math>

</p>

<p>Finally, by definition, we can see that this is equal to Pr[<em>V</em> accepts <em>w</em> starting at <em>M<sub>j</sub></em>].</p>

<p>If <em>j</em> is odd, <em>m<sub>j+1</sub></em> is a message from <em>P</em> to <em>V</em>. By definition,</p>

<p>

<math display="block" id="IP_(complexity):7">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>N</mi>
     <msub>
      <mi>M</mi>
      <mi>j</mi>
     </msub>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>max</mi>
      <msub>
       <mi>m</mi>
       <mrow>
        <mi>j</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </msub>
     <msub>
      <mi>N</mi>
      <msub>
       <mi>M</mi>
       <mrow>
        <mi>j</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>N</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <apply>
        <plus></plus>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>N</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <apply>
        <plus></plus>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N_{M_{j}}=\max\nolimits_{m_{j+1}}N_{M_{j+1}}.
  </annotation>
 </semantics>
</math>

</p>

<p>Then, by the inductive hypothesis, this equals</p>

<p>

<math display="block" id="IP_(complexity):8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>max</mi>
     <msub>
      <mi>m</mi>
      <mrow>
       <mi>j</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </msub>
    <mo>*</mo>
    <mrow>
     <mi>Pr</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>V</mi>
       <mtext>accepts</mtext>
       <mi>w</mi>
       <mtext>starting at</mtext>
       <msub>
        <mi>M</mi>
        <mrow>
         <mi>j</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <max></max>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <apply>
       <plus></plus>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>Pr</ci>
     <apply>
      <times></times>
      <ci>V</ci>
      <mtext>accepts</mtext>
      <ci>w</ci>
      <mtext>starting at</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <apply>
        <plus></plus>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max\nolimits_{m_{j+1}}*\Pr[V\text{ accepts }w\text{ starting at }M_{j+1}].
  </annotation>
 </semantics>
</math>

</p>

<p>This is equal to Pr[<em>V</em> accepts <em>w</em> starting at <em>M<sub>j</sub></em>] since:</p>

<p>

<math display="block" id="IP_(complexity):9">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>max</mi>
     <msub>
      <mi>m</mi>
      <mrow>
       <mi>j</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </msub>
    <mrow>
     <mi>Pr</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>V</mi>
       <mtext>accepts</mtext>
       <mi>w</mi>
       <mtext>starting at</mtext>
       <msub>
        <mi>M</mi>
        <mrow>
         <mi>j</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>Pr</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>V</mi>
      <mtext>accepts w starting at</mtext>
      <msub>
       <mi>M</mi>
       <mi>j</mi>
      </msub>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <apply>
        <plus></plus>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>Pr</ci>
      <apply>
       <times></times>
       <ci>V</ci>
       <mtext>accepts</mtext>
       <ci>w</ci>
       <mtext>starting at</mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <apply>
         <plus></plus>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>Pr</ci>
     <apply>
      <times></times>
      <ci>V</ci>
      <mtext>accepts w starting at</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max\nolimits_{m_{j+1}}\Pr[V\text{ accepts }w\text{ starting at }M_{j+1}]\leq%
\Pr[V\text{ accepts w starting at }M_{j}]
  </annotation>
 </semantics>
</math>

</p>

<p>because the prover on the right-hand side could send the message <em>m<sub>j+1</sub></em> to maximize the expression on the left-hand side. And:</p>

<p>

<math display="block" id="IP_(complexity):10">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>max</mi>
     <msub>
      <mi>m</mi>
      <mrow>
       <mi>j</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </msub>
    <mrow>
     <mi>Pr</mi>
     <mrow>
      <mo>[</mo>
      <mrow>
       <mi>V</mi>
       <mtext>accepts</mtext>
       <mi>w</mi>
       <mtext>starting at</mtext>
       <msub>
        <mi>M</mi>
        <mrow>
         <mi>j</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mrow>
      <mo>]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mi>Pr</mi>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mi>V</mi>
      <mtext>accepts</mtext>
      <mi>w</mi>
      <mtext>starting at</mtext>
      <msub>
       <mi>M</mi>
       <mi>j</mi>
      </msub>
     </mrow>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <apply>
        <plus></plus>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>Pr</ci>
      <apply>
       <times></times>
       <ci>V</ci>
       <mtext>accepts</mtext>
       <ci>w</ci>
       <mtext>starting at</mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <apply>
         <plus></plus>
         <ci>j</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>Pr</ci>
     <apply>
      <times></times>
      <ci>V</ci>
      <mtext>accepts</mtext>
      <ci>w</ci>
      <mtext>starting at</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max\nolimits_{m_{j+1}}\Pr\left[V\text{ accepts }w\text{ starting at }M_{j+1}%
\right]\geq\Pr\left[V\text{ accepts }w\text{ starting at }M_{j}\right]
  </annotation>
 </semantics>
</math>

</p>

<p>Since the same Prover cannot do any better than send that same message. Thus, this holds whether <em>i</em> is even or odd and the proof that <strong>IP</strong> ⊆ <strong>PSPACE</strong> is complete.</p>

<p>Here we have constructed a polynomial space machine that uses the best prover <em>P</em> for a particular string <em>w</em> in language <em>A</em>. We use this best prover in place of a prover with random input bits because we are able to try every set of random input bits in polynomial space. Since we have simulated an interactive proof system with a polynomial space machine, we have shown that <strong>IP</strong> ⊆ <strong>PSPACE</strong>, as desired.</p>
<h3 id="pspace-ip">PSPACE ⊆ IP</h3>

<p>In order to illustrate the technique that will be used to prove <strong>PSPACE</strong> ⊆ <strong>IP</strong>, we will first prove a weaker theorem, which was proven by Lund, et al.: #SAT ∈ <strong>IP</strong>. Then using the concepts from this proof we will extend it to show that TQBF ∈ <strong>IP</strong>. Since TQBF ∈ <strong>PSPACE</strong>-complete, and TQBF ∈ <strong>IP</strong> then <strong>PSPACE</strong> ⊆ <strong>IP</strong>.</p>
<h4 id="sat-is-a-member-of-ip">#SAT is a member of IP</h4>

<p>We begin by showing that #SAT is in <strong>IP</strong>, where:</p>

<p>

<math display="block" id="IP_(complexity):11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">#</mi>
     <mtext>SAT</mtext>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>φ</mi>
      <mo>,</mo>
      <mi>k</mi>
      <mo rspace="7.5pt" stretchy="false">⟩</mo>
     </mrow>
     <mo rspace="7.5pt">:</mo>
     <mrow>
      <mi>φ</mi>
      <mtext>is a CNF-formula with exactly</mtext>
      <mi>k</mi>
      <mtext>satisfying assignments</mtext>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-#</ci>
     <mtext>SAT</mtext>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <list>
      <ci>φ</ci>
      <ci>k</ci>
     </list>
     <apply>
      <times></times>
      <ci>φ</ci>
      <mtext>is a CNF-formula with exactly</mtext>
      <ci>k</ci>
      <mtext>satisfying assignments</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \#\text{SAT}=\left\{\langle\varphi,k\rangle\ :\ \varphi\text{ is a CNF-formula%
 with exactly }k\text{ satisfying assignments}\right\}.
  </annotation>
 </semantics>
</math>

</p>

<p>Note that this is different from the normal definition of <a href="Sharp-SAT" title="wikilink">#SAT</a>, in that it is a decision problem, rather than a function.</p>

<p>First we use arithmetization to map the boolean formula with <em>n</em> variables, φ(<em>b</em><sub>1</sub>, ..., <em>b<sub>n</sub></em>) to a polynomial <em>p</em><sub>φ</sub>(<em>x</em><sub>1</sub>, ..., <em>x<sub>n</sub></em>), where <em>p</em><sub>φ</sub> mimics φ in that <em>p</em><sub>φ</sub> is 1 if φ is true and 0 otherwise provided that the variables of <em>p</em><sub>φ</sub> are assigned Boolean values. The Boolean operations ∨, ∧ and ¬ used in φ are simulated in <em>p</em><sub>φ</sub> by replacing the operators in φ as shown in the table below.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>a</em> ∧ <em>b</em></p></td>
<td style="text-align: left;">
<p><em>ab</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>a</em> ∨ <em>b</em></p></td>
<td style="text-align: left;">
<p><em>a</em> ∗ <em>b</em> := 1 − (1 − <em>a</em>)(1 − <em>b</em>)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>¬<em>a</em></p></td>
<td style="text-align: left;">
<p>1 − <em>a</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Arithmetization rules for converting a Boolean formula φ(<em>b</em><sub>1</sub>, ..., <em>b<sub>n</sub></em>) to a polynomial <em>p</em><sub>φ</sub>(<em>x</em><sub>1</sub>, ..., <em>x<sub>n</sub></em>)</p></td>
</tr>
</tbody>
</table>

<p>As an example, φ = <em>a</em> ∧ <em>b</em> ∨ ¬<em>c</em> would be converted into a polynomial as follows:</p>

<p>

<math display="inline" id="IP_(complexity):12">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>φ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle p_{\varphi}
  </annotation>
 </semantics>
</math>


</p>

<p>The operations <em>ab</em> and <em>a</em> ∗ <em>b</em> each result in a polynomial with a degree bounded by the sum of the degrees of the polynomials for <em>a</em> and <em>b</em> and hence, the degree of any variable is at most the length of φ.</p>

<p>Now let <em>F</em> be a finite field with order <em>q</em> &gt; 2<sup><em>n</em></sup>; also demand that q be at least 1000. For each 0 ≤ <em>i</em> ≤ <em>n</em>, define a function <em>f<sub>i</sub></em> on <em>F</em>, having parameters 

<math display="inline" id="IP_(complexity):13">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </list>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1},\dots,a_{i-1}\in F
  </annotation>
 </semantics>
</math>

, and a single variable <em>a<sub>i</sub></em> in <em>F</em>: For 0 ≤ <em>i</em> ≤ <em>n</em> and for 

<math display="inline" id="IP_(complexity):14">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>∈</mo>
   <mi>F</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
    </list>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{1},\dots,a_{i}\in F
  </annotation>
 </semantics>
</math>

 let</p>

<p>

<math display="block" id="IP_(complexity):15">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>a</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>a</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>a</mi>
         <mrow>
          <mi>i</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <msub>
         <mi>a</mi>
         <mi>n</mi>
        </msub>
       </mrow>
       <mo>∈</mo>
       <mrow>
        <mo stretchy="false">{</mo>
        <mn>0</mn>
        <mo>,</mo>
        <mn>1</mn>
        <mo stretchy="false">}</mo>
       </mrow>
      </mrow>
     </msub>
     <mrow>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>a</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>a</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>i</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <list>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <apply>
          <plus></plus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>n</ci>
        </apply>
       </list>
       <set>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
       </set>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>p</ci>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>n</ci>
       </apply>
      </vector>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}(a_{1},\dots,a_{i})=\sum\nolimits_{a_{i+1},\dots,a_{n}\in\{0,1\}}p(a_{1},%
\dots,a_{n}).
  </annotation>
 </semantics>
</math>

 Note that the value of <em>f</em><sub>0</sub> is the number of satisfying assignments of φ. <em>f</em><sub>0</sub> is a void function, with no variables.</p>

<p>Now the protocol for #SAT works as follows:</p>
<ul>
<li><strong>Phase 0</strong>: The prover <em>P</em> chooses a prime <em>q</em> &gt; 2<sup><em>n</em></sup> and computes <em>f</em>, it then sends <em>q</em> and <em>f</em><sub>0</sub> to the verifier <em>V</em>. <em>V</em> checks that <em>q</em> is a prime greater than max(1000, 2<sup><em>n</em></sup>) and that <em>f</em><sub>0</sub>() = <em>k</em>.</li>
<li><strong>Phase 1</strong>: <em>P</em> sends the coefficients of <em>f</em><sub>1</sub>(<em>z</em>) as a polynomial in z. <em>V</em> verifies that the degree of <em>f</em><sub>1</sub> is less than <em>n</em> and that <em>f</em><sub>0</sub> = <em>f</em><sub>1</sub>(0) + <em>f</em><sub>1</sub>(1). (If not <em>V</em> rejects). <em>V</em> now sends a random number <em>r</em><sub>1</sub> from <em>F</em> to <em>P</em>.</li>
<li><strong>Phase i</strong>: <em>P</em> sends the coefficients of 

<math display="inline" id="IP_(complexity):16">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>r</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>r</mi>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>,</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>i</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>z</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}(r_{1},\dots,r_{i-1},z)
  </annotation>
 </semantics>
</math>

 as a polynomial in <em>z</em>. <em>V</em> verifies that the degree of <em>f<sub>i</sub></em> is less than <em>n</em> and that 

<math display="inline" id="IP_(complexity):17">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>r</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>r</mi>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>r</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>r</mi>
       <mrow>
        <mi>i</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo>,</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>r</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>r</mi>
       <mrow>
        <mi>i</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </vector>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>i</ci>
      </apply>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <apply>
         <minus></minus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <cn type="integer">0</cn>
      </vector>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>i</ci>
      </apply>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <apply>
         <minus></minus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <cn type="integer">1</cn>
      </vector>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i-1}(r_{1},\dots,r_{i-1})=f_{i}(r_{1},\dots,r_{i-1},0)+f_{i}(r_{1},\dots,r_%
{i-1},1)
  </annotation>
 </semantics>
</math>

. (If not <em>V</em> rejects). <em>V</em> now sends a random number <em>r<sub>i</sub></em> from <em>F</em> to <em>P</em>.</li>
<li><strong>Phase n+1</strong>: <em>V</em> evaluates 

<math display="inline" id="IP_(complexity):18">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>r</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>r</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(r_{1},\dots,r_{n})
  </annotation>
 </semantics>
</math>

 to compare to the value 

<math display="inline" id="IP_(complexity):19">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>r</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>r</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{n}(r_{1},\dots,r_{n})
  </annotation>
 </semantics>
</math>

. If they are equal <em>V</em> accepts, otherwise <em>V</em> rejects.</li>
</ul>

<p>Note that this is a public-coin algorithm.</p>

<p>If φ has <em>k</em> satisfying assignments, clearly <em>V</em> will accept. If φ does not have <em>k</em> satisfying assignments we assume there is a prover 

<math display="inline" id="IP_(complexity):20">
 <semantics>
  <mover accent="true">
   <mi>P</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{P}
  </annotation>
 </semantics>
</math>

 that tries to convince <em>V</em> that φ does have <em>k</em> satisfying assignments. We show that this can only be done with low probability.</p>

<p>To prevent <em>V</em> from rejecting in phase 0, 

<math display="inline" id="IP_(complexity):21">
 <semantics>
  <mover accent="true">
   <mi>P</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{P}
  </annotation>
 </semantics>
</math>

 has to send an incorrect value 

<math display="inline" id="IP_(complexity):22">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>f</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mn>0</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>f</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <list></list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{f}_{0}()
  </annotation>
 </semantics>
</math>

 to <em>P</em>. Then, in phase 1, 

<math display="inline" id="IP_(complexity):23">
 <semantics>
  <mover accent="true">
   <mi>P</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{P}
  </annotation>
 </semantics>
</math>

 must send an incorrect polynomial 

<math display="inline" id="IP_(complexity):24">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>f</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-~</ci>
     <ci>f</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{f}_{1}
  </annotation>
 </semantics>
</math>

 with the property that 

<math display="inline" id="IP_(complexity):25">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mover accent="true">
       <mi>f</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mover accent="true">
       <mi>f</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>f</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mn>0</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>f</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-~</ci>
        <ci>f</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-~</ci>
       <ci>f</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <list></list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{f}_{1}(0)+\tilde{f}_{1}(1)=\tilde{f}_{0}()
  </annotation>
 </semantics>
</math>

. When <em>V</em> chooses a random <em>r</em><sub>1</sub> to send to <em>P</em>,</p>

<p>

<math display="block" id="IP_(complexity):26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Pr</mi>
     <mrow>
      <mo>[</mo>
      <mrow>
       <mrow>
        <msub>
         <mover accent="true">
          <mi>f</mi>
          <mo stretchy="false">~</mo>
         </mover>
         <mn>1</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>r</mi>
          <mn>1</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mrow>
        <msub>
         <mi>f</mi>
         <mn>1</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>r</mi>
          <mn>1</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>]</mo>
     </mrow>
    </mrow>
    <mo><</mo>
    <mstyle displaystyle="false">
     <mfrac>
      <mn>1</mn>
      <msup>
       <mi>n</mi>
       <mn>2</mn>
      </msup>
     </mfrac>
    </mstyle>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <ci>Pr</ci>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <ci>normal-~</ci>
         <ci>f</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr\left[\tilde{f}_{1}(r_{1})=f_{1}(r_{1})\right]<\tfrac{1}{n^{2}}.
  </annotation>
 </semantics>
</math>

 This is because a polynomial in a single variable of degree at most <em>d</em> can have no more than <em>d</em> roots (unless it always evaluates to 0). So, any two polynomials in a single variable of degree at most <em>d</em> can be equal only in <em>d</em> places. Since |<em>F</em>| &gt; 2<sup><em>n</em></sup> the chances of <em>r</em><sub>1</sub> being one of these values is at most 

<math display="inline" id="IP_(complexity):27">
 <semantics>
  <mrow>
   <mrow>
    <mi>n</mi>
    <mo>/</mo>
    <msup>
     <mn>2</mn>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo><</mo>
   <mrow>
    <mi>n</mi>
    <mo>/</mo>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n/2^{n}<n/n^{3}
  </annotation>
 </semantics>
</math>

 if <em>n</em> &gt; 10, or at most (<em>n</em>/1000) ≤ (<em>n</em>/<em>n</em><sup>3</sup>) if <em>n</em> ≤ 10.</p>

<p>Generalizing this idea for the other phases we have for each 1 ≤ <em>i</em> ≤ <em>n</em> if</p>

<p>

<math display="block" id="IP_(complexity):28">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mover accent="true">
       <mi>f</mi>
       <mo stretchy="false">~</mo>
      </mover>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>r</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>r</mi>
       <mrow>
        <mi>i</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≠</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>r</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>r</mi>
       <mrow>
        <mi>i</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-~</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{f}_{i-1}(r_{1},\dots,r_{i-1})\neq f_{i-1}(r_{1},\dots,r_{i-1}),
  </annotation>
 </semantics>
</math>

 then for <em>r<sub>i</sub></em> chosen randomly from <em>F</em>,</p>

<p>

<math display="block" id="IP_(complexity):29">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Pr</mi>
     <mrow>
      <mo>[</mo>
      <mrow>
       <mrow>
        <mover accent="true">
         <mi>f</mi>
         <mo stretchy="false">~</mo>
        </mover>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>r</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <mi mathvariant="normal">…</mi>
         <mo>,</mo>
         <msub>
          <mi>r</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mrow>
        <msub>
         <mi>f</mi>
         <mi>i</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>r</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <mi mathvariant="normal">…</mi>
         <mo>,</mo>
         <msub>
          <mi>r</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>]</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mstyle displaystyle="false">
     <mfrac>
      <mn>1</mn>
      <msup>
       <mi>n</mi>
       <mn>2</mn>
      </msup>
     </mfrac>
    </mstyle>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <ci>Pr</ci>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <ci>normal-~</ci>
        <ci>f</ci>
       </apply>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>i</ci>
        </apply>
       </vector>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>i</ci>
       </apply>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>i</ci>
        </apply>
       </vector>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pr\left[\tilde{f}(r_{1},\dots,r_{i})=f_{i}(r_{1},\dots,r_{i})\right]\leq%
\tfrac{1}{n^{2}}.
  </annotation>
 </semantics>
</math>

 There are <em>n</em> phases, so the probability that 

<math display="inline" id="IP_(complexity):30">
 <semantics>
  <mover accent="true">
   <mi>P</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{P}
  </annotation>
 </semantics>
</math>

 is lucky because <em>V</em> selects at some stage a convenient <em>r<sub>i</sub></em> is at most 1/<em>n</em>. So, no prover can make the verifier accept with probability greater than 1/<em>n</em>. We can also see from the definition that the verifier <em>V</em> operates in probabilistic polynomial time. Thus, #SAT ∈ <strong>IP</strong>.</p>
<h4 id="tqbf-is-a-member-of-ip">TQBF is a member of IP</h4>

<p>In order to show that <strong>PSPACE</strong> is a subset of <strong>IP</strong>, we need to choose a <strong>PSPACE-complete</strong> problem and show that it is in <strong>IP</strong>. Once we show this, then it clear that <strong>PSPACE</strong> ⊆ <strong>IP</strong>. The proof technique demonstrated here is credited to <a href="Adi_Shamir" title="wikilink">Adi Shamir</a></p>

<p>We know that TQBF is in <strong>PSPACE-Complete</strong>. So let ψ be a quantified boolean expression:</p>

<p>

<math display="block" id="IP_(complexity):31">
 <semantics>
  <mrow>
   <mi>ψ</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>Q</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>Q</mi>
     <mi>m</mi>
    </msub>
    <msub>
     <mi>x</mi>
     <mi>m</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>φ</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ψ</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>φ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi=Q_{1}x_{1}\dots Q_{m}x_{m}[\varphi]
  </annotation>
 </semantics>
</math>

</p>

<p>where φ is a CNF formula. Then <em>Q<sub>i</sub></em> is a quantified, either ∃ or ∀. Now <em>f<sub>i</sub></em> is the same as in the previous proof, but now it also includes quantifiers.</p>

<p>

<math display="block" id="IP_(complexity):32">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <msub>
          <mi>f</mi>
          <mi>i</mi>
         </msub>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>a</mi>
           <mn>1</mn>
          </msub>
          <mo>,</mo>
          <mi mathvariant="normal">…</mi>
          <mo>,</mo>
          <msub>
           <mi>a</mi>
           <mi>m</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <msub>
         <mi>Q</mi>
         <mrow>
          <mi>i</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <msub>
         <mi>x</mi>
         <mrow>
          <mi>i</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mi mathvariant="normal">…</mi>
        <msub>
         <mi>Q</mi>
         <mi>m</mi>
        </msub>
        <msub>
         <mi>x</mi>
         <mi>m</mi>
        </msub>
        <mrow>
         <mo stretchy="false">[</mo>
         <mrow>
          <mi>φ</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>a</mi>
            <mn>1</mn>
           </msub>
           <mo>,</mo>
           <mi mathvariant="normal">…</mi>
           <mo>,</mo>
           <msub>
            <mi>a</mi>
            <mi>i</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo stretchy="false">]</mo>
        </mrow>
        <mtext>is true</mtext>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>i</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>i</ci>
       </apply>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>m</ci>
        </apply>
       </vector>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>φ</ci>
        <vector>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>normal-…</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <ci>i</ci>
         </apply>
        </vector>
       </apply>
      </apply>
      <mtext>is true</mtext>
     </apply>
     <cn type="integer">0</cn>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}(a_{1},\dots,a_{i})=\begin{cases}f_{i}(a_{1},\dots,a_{m})=1&Q_{i+1}x_{i+1%
}\dots Q_{m}x_{m}[\varphi(a_{1},\dots,a_{i})]\text{ is true}\\
0&\text{otherwise}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>Here, φ(<em>a</em><sub>1</sub>, ..., <em>a<sub>i</sub></em>) is φ with <em>a</em><sub>1</sub> to <em>a<sub>i</sub></em> substituted for <em>x</em><sub>1</sub> to <em>x<sub>i</sub></em>. Thus <em>f</em><sub>0</sub> is the <a href="truth_value" title="wikilink">truth value</a> of ψ. In order to arithmetize ψ we must use the following rules:</p>

<p>

<math display="block" id="IP_(complexity):33">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <msub>
           <mi>f</mi>
           <mrow>
            <mi>i</mi>
            <mo>+</mo>
            <mn>1</mn>
           </mrow>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>a</mi>
            <mn>1</mn>
           </msub>
           <mo>,</mo>
           <mi mathvariant="normal">…</mi>
           <mo>,</mo>
           <msub>
            <mi>a</mi>
            <mi>i</mi>
           </msub>
           <mo>,</mo>
           <mn>0</mn>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>⋅</mo>
         <msub>
          <mi>f</mi>
          <mrow>
           <mi>i</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>a</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <mi mathvariant="normal">…</mi>
         <mo>,</mo>
         <msub>
          <mi>a</mi>
          <mi>i</mi>
         </msub>
         <mo>,</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <msub>
         <mi>Q</mi>
         <mrow>
          <mi>i</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mo>=</mo>
        <mo>∀</mo>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <msub>
           <mi>f</mi>
           <mrow>
            <mi>i</mi>
            <mo>+</mo>
            <mn>1</mn>
           </mrow>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>a</mi>
            <mn>1</mn>
           </msub>
           <mo>,</mo>
           <mi mathvariant="normal">…</mi>
           <mo>,</mo>
           <msub>
            <mi>a</mi>
            <mi>i</mi>
           </msub>
           <mo>,</mo>
           <mn>0</mn>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>*</mo>
         <msub>
          <mi>f</mi>
          <mrow>
           <mi>i</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>a</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <mi mathvariant="normal">…</mi>
         <mo>,</mo>
         <msub>
          <mi>a</mi>
          <mi>i</mi>
         </msub>
         <mo>,</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <msub>
         <mi>Q</mi>
         <mrow>
          <mi>i</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mo>=</mo>
        <mo>∃</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>i</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <apply>
          <plus></plus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <vector>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>normal-…</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <ci>i</ci>
         </apply>
         <cn type="integer">0</cn>
        </vector>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <apply>
         <plus></plus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
       <cn type="integer">1</cn>
      </vector>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <csymbol cd="latexml">for-all</csymbol>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <apply>
          <plus></plus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <vector>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>normal-…</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <ci>i</ci>
         </apply>
         <cn type="integer">0</cn>
        </vector>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <apply>
         <plus></plus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
       <cn type="integer">1</cn>
      </vector>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <exists></exists>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}(a_{1},\dots,a_{i})=\begin{cases}f_{i+1}(a_{1},\dots,a_{i},0)\cdot f_{i+1%
}(a_{1},\dots,a_{i},1)&Q_{i+1}=\forall\\
f_{i+1}(a_{1},\dots,a_{i},0)*f_{i+1}(a_{1},\dots,a_{i},1)&Q_{i+1}=\exists\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>where as before we define <em>x</em> ∗ <em>y</em> = 1 − (1 − <em>x</em>)(1 − <em>y</em>).</p>

<p>By using the method described in #SAT, we must face a problem that for any <em>f<sub>i</sub></em> the degree of the resulting polynomial may double with each quantifier. In order to prevent this, we must introduce a new reduction operator <em>R</em> which will reduce the degrees of the polynomial without changing their behavior on Boolean inputs.</p>

<p>So now before we arithmetize 

<math display="inline" id="IP_(complexity):34">
 <semantics>
  <mrow>
   <mi>ψ</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>Q</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>Q</mi>
     <mi>m</mi>
    </msub>
    <msub>
     <mi>x</mi>
     <mi>m</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>φ</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ψ</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>φ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi=Q_{1}x_{1}\dots Q_{m}x_{m}[\varphi]
  </annotation>
 </semantics>
</math>

 we introduce a new expression:</p>

<p>

<math display="block" id="IP_(complexity):35">
 <semantics>
  <mrow>
   <msup>
    <mi>ψ</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>Q</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mi>R</mi>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <msub>
     <mi>Q</mi>
     <mn>2</mn>
    </msub>
    <mi>R</mi>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mi>R</mi>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>Q</mi>
     <mi>m</mi>
    </msub>
    <mi>R</mi>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <mi>R</mi>
    <msub>
     <mi>x</mi>
     <mi>m</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>φ</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ψ</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>R</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>R</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>R</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <ci>m</ci>
     </apply>
     <ci>R</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <ci>R</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>φ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi^{\prime}=Q_{1}x_{1}Rx_{1}Q_{2}Rx_{1}Rx_{2}\dots Q_{m}Rx_{1}\dots Rx_{m}[\varphi]
  </annotation>
 </semantics>
</math>

</p>

<p>r way:</p>

<p>

<math display="block" id="IP_(complexity):36">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>ψ</mi>
     <mo>′</mo>
    </msup>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>S</mi>
      <mn>1</mn>
     </msub>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>S</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>y</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>φ</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <mrow>
     <mrow>
      <mtext>where</mtext>
      <msub>
       <mi>S</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo>∈</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mo>∀</mo>
      <mo>,</mo>
      <mo>∃</mo>
      <mo>,</mo>
      <mi>R</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo rspace="7.5pt">,</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
     <mo>∈</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>m</mi>
      </msub>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ψ</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>φ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <apply>
       <times></times>
       <mtext>where</mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <set>
       <csymbol cd="latexml">for-all</csymbol>
       <exists></exists>
       <ci>R</ci>
      </set>
     </apply>
     <apply>
      <in></in>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
      <set>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>m</ci>
       </apply>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi^{\prime}=S_{1}y_{1}\dots S_{k}y_{k}[\varphi],\qquad\text{ where }S_{i}\in%
\{\forall,\exists,R\},\ y_{i}\in\{x_{1},\dots,x_{m}\}
  </annotation>
 </semantics>
</math>

</p>

<p>Now for every <em>i</em> ≤ <em>k</em> we define the function <em>f<sub>i</sub></em>. We also define 

<math display="inline" id="IP_(complexity):37">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>m</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>k</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>m</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{k}(x_{1},\dots,x_{m})
  </annotation>
 </semantics>
</math>

 to be the polynomial <em>p</em>(<em>x</em><sub>1</sub>, ..., <em>x<sub>m</sub></em>) which is obtained by arithmetizing φ. Now in order to keep the degree of the polynomial low, we define <em>f<sub>i</sub></em> in terms of <em>f<sub>i+1</sub></em>:</p>

<p>

<math display="block" id="IP_(complexity):38">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mtext>If</mtext>
     <msub>
      <mi>S</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo>=</mo>
    <mo>∀</mo>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>a</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>a</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <msub>
        <mi>f</mi>
        <mrow>
         <mi>i</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>a</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <msub>
         <mi>a</mi>
         <mi>i</mi>
        </msub>
        <mo>,</mo>
        <mn>0</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⋅</mo>
      <msub>
       <mi>f</mi>
       <mrow>
        <mi>i</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>a</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>a</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <mtext>If</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <csymbol cd="latexml">for-all</csymbol>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>i</ci>
      </apply>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
      </vector>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <apply>
          <plus></plus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <vector>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>normal-…</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <ci>i</ci>
         </apply>
         <cn type="integer">0</cn>
        </vector>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <apply>
         <plus></plus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
       <cn type="integer">1</cn>
      </vector>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{If }S_{i+1}=\forall,\quad f_{i}(a_{1},\dots,a_{i})=f_{i+1}(a_{1},\dots,a%
_{i},0)\cdot f_{i+1}(a_{1},\dots,a_{i},1)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="IP_(complexity):39">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mtext>If</mtext>
     <msub>
      <mi>S</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo>=</mo>
    <mo>∃</mo>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>a</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>a</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <msub>
        <mi>f</mi>
        <mrow>
         <mi>i</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>a</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <msub>
         <mi>a</mi>
         <mi>i</mi>
        </msub>
        <mo>,</mo>
        <mn>0</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>*</mo>
      <msub>
       <mi>f</mi>
       <mrow>
        <mi>i</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>a</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>a</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <mtext>If</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <exists></exists>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>i</ci>
      </apply>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
      </vector>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <apply>
          <plus></plus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <vector>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>normal-…</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <ci>i</ci>
         </apply>
         <cn type="integer">0</cn>
        </vector>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <apply>
         <plus></plus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
       <cn type="integer">1</cn>
      </vector>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{If }S_{i+1}=\exists,\quad f_{i}(a_{1},\dots,a_{i})=f_{i+1}(a_{1},\dots,a%
_{i},0)*f_{i+1}(a_{1},\dots,a_{i},1)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="IP_(complexity):40">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mtext>If</mtext>
     <msub>
      <mi>S</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo>=</mo>
    <mi>R</mi>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>a</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>a</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mi>a</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>f</mi>
       <mrow>
        <mi>i</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>a</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>a</mi>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>a</mi>
      <msub>
       <mi>f</mi>
       <mrow>
        <mi>i</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>a</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>a</mi>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <mtext>If</mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>R</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>i</ci>
      </apply>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>i</ci>
       </apply>
       <ci>a</ci>
      </vector>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>a</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <apply>
         <plus></plus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>i</ci>
        </apply>
        <cn type="integer">0</cn>
       </vector>
      </apply>
      <apply>
       <times></times>
       <ci>a</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <apply>
         <plus></plus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>i</ci>
        </apply>
        <cn type="integer">1</cn>
       </vector>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{If }S_{i+1}=R,\quad f_{i}(a_{1},\dots,a_{i},a)=(1-a)f_{i+1}(a_{1},\dots,%
a_{i},0)+af_{i+1}(a_{1},\dots,a_{i},1)
  </annotation>
 </semantics>
</math>

</p>

<p>Now we can see that the reduction operation <em>R</em>, doesn't change the degree of the polynomial. Also it is important to see that the <em>R<sub>x</sub></em> operation doesn't change the value of the function on boolean inputs. So <em>f</em><sub>0</sub> is still the truth value of ψ, but the <em>R<sub>x</sub></em> value produces a result that is linear in x. Also after any <em>Q<sub>i</sub>x<sub>i</sub></em> we add 

<math display="inline" id="IP_(complexity):41">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
   </msub>
   <mi mathvariant="normal">…</mi>
   <msub>
    <mi>R</mi>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{x_{1}}\dots R_{x_{i}}
  </annotation>
 </semantics>
</math>

 in ψ′ in order to reduce the degree down to 1 after arithmetizing <em>Q<sub>i</sub></em>.</p>

<p>Now let's describe the protocol. If <em>n</em> is the length of ψ, all arithmetic operations in the protocol are over a field of size at least <em>n</em><sup>4</sup> where <em>n</em> is the length of ψ.</p>
<ul>
<li><strong>Phase 0</strong>: <em>P</em> → <em>V</em>: <em>P</em> sends <em>f</em><sub>0</sub> to <em>V</em>. <em>V</em> checks that <em>f</em><sub>0</sub>= 1 and rejects if not.</li>
<li><strong>Phase 1</strong>: <em>P</em> → <em>V</em>: <em>P</em> sends <em>f</em><sub>1</sub>(<em>z</em>) to <em>V</em>. <em>V</em> uses coefficients to evaluate <em>f</em><sub>1</sub>(0) and <em>f</em><sub>1</sub>(1). Then it checks that the polynomial's degree is at most <em>n</em> and that the following identities are true:</li>
</ul>
<dl>
<dd><dl>
<dd><math>f_{0}() = \begin{cases}
</math></dd>
</dl>
</dd>
</dl>

<p>f_{1}(0)\cdot f_{1}(1) &amp; \text{ if }S = \forall \\ f_{1}(0) * f_{1}(1) &amp; \text{ if }S = \exists. \\ (1-r)f_{1}(0) + rf_{1}(1) &amp; \text{ if }S = R. \end{cases}</p>
<dl>
<dd>If either fails then reject.
</dd>
</dl>
<ul>
<li><strong>Phase i</strong>: <em>P</em> → <em>V</em>: <em>P</em> sends 

<math display="inline" id="IP_(complexity):42">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>r</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>r</mi>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>,</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>i</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>z</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}(r_{1},\dots,r_{i-1},z)
  </annotation>
 </semantics>
</math>

 as a polynomial in <em>z</em>. <em>r</em><sub>1</sub> denotes the previously set random values for 

<math display="inline" id="IP_(complexity):43">
 <semantics>
  <mrow>
   <msub>
    <mi>r</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>r</mi>
    <mrow>
     <mi>i</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <apply>
      <minus></minus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{1},\dots,r_{i-1}
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p><em>V</em> uses coefficients to evaluate 

<math display="inline" id="IP_(complexity):44">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>r</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>r</mi>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>,</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>i</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}(r_{1},\dots,r_{i-1},0)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="IP_(complexity):45">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>r</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>r</mi>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>i</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}(r_{1},\dots,r_{i-1},1)
  </annotation>
 </semantics>
</math>

. Then it checks that the polynomial degree is at most <em>n</em> and that the following identities are true:</p>

<p>

<math display="block" id="IP_(complexity):46">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>r</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>r</mi>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <msub>
           <mi>f</mi>
           <mi>i</mi>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>r</mi>
            <mn>1</mn>
           </msub>
           <mo>,</mo>
           <mi mathvariant="normal">…</mi>
           <mo>,</mo>
           <msub>
            <mi>r</mi>
            <mrow>
             <mi>i</mi>
             <mo>-</mo>
             <mn>1</mn>
            </mrow>
           </msub>
           <mo>,</mo>
           <mn>0</mn>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>⋅</mo>
         <msub>
          <mi>f</mi>
          <mi>i</mi>
         </msub>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>r</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <mi mathvariant="normal">…</mi>
         <mo>,</mo>
         <msub>
          <mi>r</mi>
          <mrow>
           <mi>i</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo>,</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mi>S</mi>
        <mo>=</mo>
        <mo>∀</mo>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <msub>
           <mi>f</mi>
           <mi>i</mi>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>r</mi>
            <mn>1</mn>
           </msub>
           <mo>,</mo>
           <mi mathvariant="normal">…</mi>
           <mo>,</mo>
           <msub>
            <mi>r</mi>
            <mrow>
             <mi>i</mi>
             <mo>-</mo>
             <mn>1</mn>
            </mrow>
           </msub>
           <mo>,</mo>
           <mn>0</mn>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>*</mo>
         <msub>
          <mi>f</mi>
          <mi>i</mi>
         </msub>
        </mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>r</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <mi mathvariant="normal">…</mi>
         <mo>,</mo>
         <msub>
          <mi>r</mi>
          <mrow>
           <mi>i</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo>,</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mi>S</mi>
         <mo>=</mo>
         <mo>∃</mo>
        </mrow>
        <mo>.</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </vector>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>i</ci>
        </apply>
        <vector>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>normal-…</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <apply>
           <minus></minus>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <cn type="integer">0</cn>
        </vector>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <apply>
         <minus></minus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <cn type="integer">1</cn>
      </vector>
     </apply>
     <apply>
      <eq></eq>
      <ci>S</ci>
      <csymbol cd="latexml">for-all</csymbol>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>i</ci>
        </apply>
        <vector>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>normal-…</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <apply>
           <minus></minus>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <cn type="integer">0</cn>
        </vector>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <apply>
         <minus></minus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <cn type="integer">1</cn>
      </vector>
     </apply>
     <apply>
      <eq></eq>
      <ci>S</ci>
      <exists></exists>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i-1}(r_{1},\dots,r_{i-1})=\begin{cases}f_{i}(r_{1},\dots,r_{i-1},0)\cdot f_%
{i}(r_{1},\dots,r_{i-1},1)&S=\forall\\
f_{i}(r_{1},\dots,r_{i-1},0)*f_{i}(r_{1},\dots,r_{i-1},1)&S=\exists.\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="IP_(complexity):47">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>f</mi>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>r</mi>
        <mn>1</mn>
       </msub>
       <mi mathvariant="normal">…</mi>
       <mi>r</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mi>r</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>f</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>r</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>r</mi>
        <mrow>
         <mi>i</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mo>,</mo>
       <mn>0</mn>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>r</mi>
      <msub>
       <mi>f</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>r</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <msub>
        <mi>r</mi>
        <mrow>
         <mi>i</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mo>,</mo>
       <mn>1</mn>
       <mo stretchy="false">)</mo>
      </mrow>
      <mtext>if</mtext>
      <mi>S</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>R</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <ci>r</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>r</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>i</ci>
       </apply>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <apply>
          <minus></minus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <cn type="integer">0</cn>
       </vector>
      </apply>
      <apply>
       <times></times>
       <ci>r</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>i</ci>
       </apply>
       <vector>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <apply>
          <minus></minus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <cn type="integer">1</cn>
       </vector>
       <mtext>if</mtext>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i-1}(r_{1}\dots r)=(1-r)f_{i}(r_{1},\dots,r_{i-1},0)+rf_{i}(r_{1},\dots,r_{%
i-1},1)\text{ if }S=R.
  </annotation>
 </semantics>
</math>

 If either fails then reject.</p>

<p><em>V</em> → <em>P</em>: <em>V</em> picks a random <em>r</em> in <em>F</em> and sends it to P. (If S=R then this <em>r</em> replaces the previous <em>r</em>).</p>

<p>Goto phase <em>i</em> + 1 where <em>P</em> must persuade <em>V</em> that 

<math display="inline" id="IP_(complexity):48">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>r</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>r</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>i</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <ci>r</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}(r_{1},\dots,r)
  </annotation>
 </semantics>
</math>

 is correct.</p>
<ul>
<li><strong>Phase <em>k</em> + 1</strong>: <em>V</em> evaluates 

<math display="inline" id="IP_(complexity):49">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>r</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>r</mi>
     <mi>m</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>m</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(r_{1},\dots,r_{m})
  </annotation>
 </semantics>
</math>

. Then it checks if 

<math display="inline" id="IP_(complexity):50">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>r</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>r</mi>
      <mi>m</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>f</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>r</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>r</mi>
      <mi>m</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>m</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>k</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>m</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(r_{1},\dots,r_{m})=f_{k}(r_{1},\dots,r_{m})
  </annotation>
 </semantics>
</math>

 If they are equal then <em>V</em> accepts, otherwise <em>V</em> rejects.</li>
</ul>

<p>This is the end of the protocol description.</p>

<p>If ψ is true then <em>V</em> will accept when <em>P</em> follows the protocol. Likewise if 

<math display="inline" id="IP_(complexity):51">
 <semantics>
  <mover accent="true">
   <mi>P</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{P}
  </annotation>
 </semantics>
</math>

 is a malicious prover which lies, and if ψ is false, then 

<math display="inline" id="IP_(complexity):52">
 <semantics>
  <mover accent="true">
   <mi>P</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{P}
  </annotation>
 </semantics>
</math>

 will need to lie at phase 0 and send some value for <em>f</em><sub>0</sub>. If at phase <em>i</em>, <em>V</em> has an incorrect value for 

<math display="inline" id="IP_(complexity):53">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mrow>
     <mi>i</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>r</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <apply>
      <minus></minus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i-1}(r_{1},\dots)
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="IP_(complexity):54">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>r</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>i</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <cn type="integer">0</cn>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}(r_{1},\dots,0)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="IP_(complexity):55">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>r</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>i</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <cn type="integer">1</cn>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}(r_{1},\dots,1)
  </annotation>
 </semantics>
</math>

 will likely also be incorrect, and so forth. The probability for 

<math display="inline" id="IP_(complexity):56">
 <semantics>
  <mover accent="true">
   <mi>P</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{P}
  </annotation>
 </semantics>
</math>

 to get lucky on some random <em>r</em> is at most the degree of the polynomial divided by the field size

<math display="block" id="IP_(complexity):57">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>/</mo>
   <msup>
    <mi>n</mi>
    <mn>4</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>n</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n/n^{4}
  </annotation>
 </semantics>
</math>

. The protocol runs through <em>O</em>(<em>n</em><sup>2</sup>) phases, so the probability that 

<math display="inline" id="IP_(complexity):58">
 <semantics>
  <mover accent="true">
   <mi>P</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{P}
  </annotation>
 </semantics>
</math>

 gets lucky at some phase is ≤ 1/<em>n</em>. If 

<math display="inline" id="IP_(complexity):59">
 <semantics>
  <mover accent="true">
   <mi>P</mi>
   <mo stretchy="false">~</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-~</ci>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{P}
  </annotation>
 </semantics>
</math>

 is never lucky, then <em>V</em> will reject at phase <em>k</em>+1.</p>

<p>Since we have now shown that both <strong>IP</strong> ⊆ <strong>PSPACE</strong> and <strong>PSPACE</strong> ⊆ <strong>IP</strong>, we can conclude that <strong>IP</strong> = <strong>PSPACE</strong> as desired. Moreover, we have shown that any <strong>IP</strong> algorithm may be taken to be public-coin, since the reduction from <strong>PSPACE</strong> to <strong>IP</strong> has this property.</p>
<h2 id="variants">Variants</h2>

<p>There are a number of variants of <strong>IP</strong> which slightly modify the definition of the interactive proof system. We summarize some of the better-known ones here.</p>
<h3 id="dip">dIP</h3>

<p>A subset of <strong>IP</strong> is the <strong>deterministic Interactive Proof</strong> class, which is similar to <strong>IP</strong> but has a deterministic verifier (i.e. with no randomness). This class is equal to <strong><a href="NP_(complexity)" title="wikilink">NP</a></strong>.</p>
<h3 id="perfect-completeness">Perfect Completeness</h3>

<p>An <em>equivalent</em> definition of <strong>IP</strong> replaces the condition that the interaction succeeds with high probability on strings in the language with the requirement that it <em>always</em> succeeds:</p>

<p>

<math display="block" id="IP_(complexity):60">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mo>∈</mo>
   <mi>L</mi>
   <mo>⇒</mo>
   <mrow>
    <mi>Pr</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>V</mi>
      <mo>↔</mo>
      <mrow>
       <mi>P</mi>
       <mtext>accepts</mtext>
       <mi>w</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <ci>w</ci>
     <ci>L</ci>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>Pr</ci>
      <apply>
       <ci>normal-↔</ci>
       <ci>V</ci>
       <apply>
        <times></times>
        <ci>P</ci>
        <mtext>accepts</mtext>
        <ci>w</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w\in L\Rightarrow\Pr[V\leftrightarrow P\text{ accepts }w]=1
  </annotation>
 </semantics>
</math>

</p>

<p>This seemingly stronger criterion of "perfect completeness" does not change the complexity class <strong>IP</strong>, since any language with an interactive proof system may be given an interactive proof system with perfect completeness.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h3 id="mip">MIP</h3>

<p>In 1988, Goldwasser et al. created an even more powerful interactive proof system based on <strong>IP</strong> called <strong>MIP</strong> in which there are <em>two</em> independent provers. The two provers cannot communicate once the verifier has begun sending messages to them. Just as it's easier to tell if a criminal is lying if he and his partner are interrogated in separate rooms, it's considerably easier to detect a malicious prover trying to trick the verifier if there is another prover it can double-check with. In fact, this is so helpful that Babai, Fortnow, and Lund were able to show that <strong>MIP</strong> = <strong>NEXPTIME</strong>, the class of all problems solvable by a <a href="nondeterministic_Turing_machine" title="wikilink">nondeterministic</a> machine in <em>exponential time</em>, a very large class. Moreover, all languages in <strong>NP</strong> have zero-knowledge proofs in an <strong>MIP</strong> system, without any additional assumptions; this is only known for <strong>IP</strong> assuming the existence of one-way functions.</p>
<h3 id="ipp">IPP</h3>

<p><strong>IPP</strong> (<em>unbounded IP</em>) is a variant of <strong>IP</strong> where we replace the <strong><a href="Bounded-error_probabilistic_polynomial" title="wikilink">BPP</a></strong> verifier by a <strong><a href="PP_(complexity)" title="wikilink">PP</a></strong> verifier. More precisely, we modify the completeness and soundness conditions as follows:</p>
<ul>
<li><strong>Completeness</strong>: if a string is in the language, the honest verifier will be convinced of this fact by an honest prover with probability at least 1/2.</li>
<li><strong>Soundness</strong>: if the string is not in the language, no prover can convince the honest verifier that it is in the language, except with probability less than 1/2.</li>
</ul>

<p>Although <strong>IPP</strong> also equals <strong>PSPACE</strong>, <strong>IPP</strong> protocols behaves quite differently from <strong>IP</strong> with respect to <a href="oracle_machine" title="wikilink">oracles</a>: <strong>IPP</strong>=<strong>PSPACE</strong> with respect to all oracles, while <strong>IP</strong> ≠ <strong>PSPACE</strong> with respect to almost all oracles.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h3 id="qip">QIP</h3>

<p><strong><a href="Quantum_Interactive_Protocol" title="wikilink">QIP</a></strong> is a version of <strong>IP</strong> replacing the <strong><a href="Bounded-error_probabilistic_polynomial" title="wikilink">BPP</a></strong> verifier by a <strong><a class="uri" href="BQP" title="wikilink">BQP</a></strong> verifier, where <strong>BQP</strong> is the class of problems solvable by <a href="quantum_computer" title="wikilink">quantum computers</a> in polynomial time. The messages are composed of qubits.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> In 2009, Jain, Ji, Upadhyay, and Watrous proved that <strong>QIP</strong> also equals <strong>PSPACE</strong>,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> implying that this change gives no additional power to the protocol. This subsumes a previous result of Kitaev and Watrous that <strong>QIP</strong> is contained in <strong><a class="uri" href="EXPTIME" title="wikilink">EXPTIME</a></strong> because <strong>QIP</strong> = <strong>QIP</strong>[3], so that more than three rounds are never necessary.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h3 id="compip">compIP</h3>

<p>Whereas <strong>IPP</strong> and <strong>QIP</strong> give more power to the verifier, a <strong>compIP</strong> system (<em>competitive IP proof system</em>) weakens the completeness condition in a way that weakens the prover:</p>
<ul>
<li><strong>Completeness</strong>: if a string is in the language <em>L</em>, the honest verifier will be convinced of this fact by an honest prover with probability at least 2/3. Moreover, the prover will do so in probabilistic polynomial time given access to an oracle for the language <em>L</em>.</li>
</ul>

<p>Essentially, this makes the prover a <strong><a href="Bounded-error_probabilistic_polynomial" title="wikilink">BPP</a></strong> machine with access to an oracle for the language, but only in the completeness case, not the soundness case. The concept is that if a language is in <strong>compIP</strong>, then interactively proving it is in some sense as easy as deciding it. With the oracle, the prover can easily solve the problem, but its limited power makes it much more difficult to convince the verifier of anything. In fact, <strong>compIP</strong> isn't even known or believed to contain <strong><a href="NP_(complexity)" title="wikilink">NP</a></strong>.</p>

<p>On the other hand, such a system can solve some problems believed to be hard. Somewhat paradoxically, though such a system is not believed to be able to solve all of <strong>NP</strong>, it can easily solve all <strong><a class="uri" href="NP-complete" title="wikilink">NP-complete</a></strong> problems due to self-reducibility. This stems from the fact that if the language L is not <strong>NP</strong>-hard, the prover is substantially limited in power (as it can no longer decide all <strong>NP</strong> problems with its oracle).</p>

<p>Additionally, the <a href="Graph_isomorphism_problem" title="wikilink">graph nonisomorphism problem</a> (which is a classical problem in <strong>IP</strong>) also is also in <strong>compIP</strong>, since the only hard operation the prover has to do is isomorphism testing, which it can use the oracle to solve. Quadratic non-residuosity and graph isomorphism are also in <strong>compIP</strong>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Note, Quadratic non-residuosity (QNR) is likely an easier problem than graph isomorphism as QNR is in <strong>UP</strong> intersect <strong>co-UP</strong>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li>Babai, L. Trading group theory for randomness. In Proceedings of the 17th ACM Symposium on the Theory of Computation . ACM, New York, 1985, pp. 421–429.</li>
<li><a href="Shafi_Goldwasser" title="wikilink">Shafi Goldwasser</a>, <a href="Silvio_Micali" title="wikilink">Silvio Micali</a>, and <a href="Charles_Rackoff" title="wikilink">Charles Rackoff</a>. <a href="http://portal.acm.org/citation.cfm?id=63434">The Knowledge complexity of interactive proof-systems</a>. <em>Proceedings of 17th ACM Symposium on the Theory of Computation</em>, Providence, Rhode Island. 1985, pp. 291–304. <a href="http://theory.lcs.mit.edu/~cis/pubs/shafi/1985-stoc.pdf">Extended abstract</a></li>
<li>Shafi Goldwasser and Michael Sipser. <a href="http://theory.lcs.mit.edu/~cis/pubs/shafi/1986-stoc.pdf">Private coins versus public coins in interactive proof systems</a>. <em>Proceedings of the 18th Annual ACM Symposium on Theory of Computation</em>. ACM, New York, 1986, pp. 59–68.</li>
<li>Rahul Jain, Zhengfeng Ji, Sarvagya Upadhyay, John Watrous. QIP = PSPACE. <a href="http://arxiv.org/abs/0907.4737">1</a></li>
<li><a href="Carsten_Lund" title="wikilink">Lund, C.</a>, <a href="Lance_Fortnow" title="wikilink">Fortnow, L.</a>, Karloff, H., <a href="Noam_Nisan" title="wikilink">Nisan, N.</a> Algebraic methods for interactive proof systems. In Proceedings of 31st Symposium on the Foundations of Computer Science. IEEE, New York, 1990, pp. 2–90.</li>
<li>Adi Shamir. <a href="http://portal.acm.org/citation.cfm?doid=146585.146609">IP = PSPACE</a>. <em>Journal of the ACM</em>, volume 39, issue 4, p. 869–877. October 1992.</li>
<li>Alexander Shen. <a href="http://doi.acm.org/10.1145/146585.146613">IP=PSpace: Simplified Proof</a>. J.ACM, v. 39(4), pp. 878–880, 1992.</li>
<li>

<p>, <a href="http://complexityzoo.uwaterloo.ca/Complexity_Zoo:M#mip">MIP</a>, <a href="http://complexityzoo.uwaterloo.ca/Complexity_Zoo:I#ipp">IPP</a>, <a href="http://complexityzoo.uwaterloo.ca/Complexity_Zoo:Q#qip">QIP</a>, <a href="http://complexityzoo.uwaterloo.ca/Complexity_Zoo:Q#qip2">QIP(2)</a>, <a href="http://complexityzoo.uwaterloo.ca/Complexity_Zoo:C#compip">compIP</a>, <a href="http://complexityzoo.uwaterloo.ca/Complexity_Zoo:F#frip">frIP</a></p></li>
</ul>

<p>"</p>

<p><a href="Category:Probabilistic_complexity_classes" title="wikilink">Category:Probabilistic complexity classes</a> <a href="Category:Articles_containing_proofs" title="wikilink">Category:Articles containing proofs</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://www.math.ias.edu/~ormeir/papers/ip_pspace.pdf">IP = PSPACE using Error Correcting Codes</a><a href="#fnref1">↩</a></li>
<li id="fn2">Martin Furer, Oded Goldreich, Yishay Mansour, Michael Sipser, Stathis Zachos. <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.9412">On Completeness and Soundness in Interactive Proof Systems</a>. <em>Advances in Computing Research: A Research Annual</em>, 5:429-442. 1989.<a href="#fnref2">↩</a></li>
<li id="fn3">R. Chang, B. Chor, Oded Goldreich, J. Hartmanis, J. Håstad, D. Ranjan, and P. Rohatgi. <a href="http://citeseer.ist.psu.edu/chang97random.html">The random oracle hypothesis is false</a>. <em>Journal of Computer and System Sciences</em>, 49(1):24-39. 1994.<a href="#fnref3">↩</a></li>
<li id="fn4">J. Watrous. <a href="http://citeseer.ist.psu.edu/watrous99pspace.html">PSPACE has constant-round quantum interactive proof systems</a>. <em>Proceedings of IEEE FOCS'99</em>, pp. 112-119. 1999.<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6">A. Kitaev and J. Watrous. <a href="http://www.cpsc.ucalgary.ca/~jwatrous/papers/qip2.ps">Parallelization, amplification, and exponential time simulation of quantum interactive proof systems</a>. <em>Proceedings of ACM STOC'2000</em>, pp. 608-617. 2000.<a href="#fnref6">↩</a></li>
<li id="fn7">Shafi Goldwasser and <a href="Mihir_Bellare" title="wikilink">Mihir Bellare</a>. <a href="http://www.cs.ucsd.edu/users/mihir/papers/compip.pdf">The Complexity of Decision versus Search</a>. <em>SIAM Journal on Computing</em>, Volume 23, No. 1. February 1994.<a href="#fnref7">↩</a></li>
<li id="fn8">Cai JY, Threlfall RA, 2004. "A note on quadratic residuosity and <strong>UP</strong>." <em>Information Processing Letters</em> 92(3): 127-131.<a href="#fnref8">↩</a></li>
</ol>
</section>
</hr></body>
</html>
