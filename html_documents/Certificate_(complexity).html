<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1722">Certificate (complexity)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Certificate (complexity)</h1>
<hr/>

<p>In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, a <strong>certificate</strong> (also called a <strong>witness</strong>) is a string that certifies the answer to a computation, or certifies the membership of some string in a language. A certificate is often thought of as a solution path within a verification process, which is used to check whether a problem gives the answer "Yes" or "No".</p>

<p>In the <a href="decision_tree_model" title="wikilink">decision tree model</a> of computation, certificate complexity is the minimum number of the 

<math display="inline" id="Certificate_(complexity):0">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 input variables of a <a href="decision_tree" title="wikilink">decision tree</a> that need to be assigned a value in order to definitely establish the value of the <a href="Boolean_function" title="wikilink">Boolean function</a> 

<math display="inline" id="Certificate_(complexity):1">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="definition">Definition</h2>

<p>Certificate is generally used to prove semi-decidability as following:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>L ∈ SD iff there is a two-place predicate R ⊆ Σ∗ × Σ∗ such that R is computable, and such that for all x ∈ Σ∗:</p>

<p><code>   x ∈ L ⇔ there exists y such that R(x, y)</code></p>

<p>and to prove NP as following:</p>

<p>L ∈ NP iff there is a <a class="uri" href="polytime" title="wikilink">polytime</a> verifier V such that:</p>

<p><code>   x ∈ L ⇔ there exists y such that |y| </code><code>c</code><code> and V accepts (x, y)</code></p>
<h2 id="example">Example</h2>

<p><code> L = {</code><code>, x, w&gt; | does </code><m><code> accept x in |w| steps?}</code><br/>
<code> Show L ∈ NP.</code><br/>
<code> </code><strong><code>verifier:</code></strong><br/>
<code>   gets string c = </code><m><code>, x, w such that |c| </code><code>3</code><code>)</code><br/>
<code>   if we have a computation of a TM with k steps the total size of the computation string is k</code><sup><code>2</code></sup><br/>
<code>   Thus, </code><code>, x, w&gt; ∈ L ⇔ there exists c </code><code>3</code><code> such that </code><code>, x, w, c&gt; ∈ V ∈ P</code></m></m></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Witness_(mathematics)" title="wikilink">Witness (mathematics)</a>, an analogous concept in mathematical logic</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li><a href="http://www.cs.princeton.edu/theory/complexity/dectreechap.pdf">Computational Complexity: a Modern Approach by Sanjeev Arora and Boaz Barak</a></li>
</ul>

<p>"</p>

<p><a href="Category:Computational_complexity_theory" title="wikilink">Category:Computational complexity theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
