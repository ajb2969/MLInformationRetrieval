<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="654">Monoid</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Monoid</h1>
<hr/>

<p>In <a href="abstract_algebra" title="wikilink">abstract algebra</a>, a branch of <a class="uri" href="mathematics" title="wikilink">mathematics</a>, a <strong>monoid</strong> is an <a href="algebraic_structure" title="wikilink">algebraic structure</a> with a single <a class="uri" href="associative" title="wikilink">associative</a> <a href="binary_operation" title="wikilink">binary operation</a> and an <a href="identity_element" title="wikilink">identity element</a>. Monoids are studied in <a class="uri" href="semigroup" title="wikilink">semigroup</a> theory as they are semigroups with identity. Monoids occur in several branches of mathematics; for instance, they can be regarded as <a href="category_(mathematics)" title="wikilink">categories</a> with a single <a href="object_(category_theory)" title="wikilink">object</a>. Thus, they capture the idea of <a href="function_composition" title="wikilink">function composition</a> within a set. Monoids are also commonly used in <a href="computer_science" title="wikilink">computer science</a>, both in its foundational aspects and in practical programming. The set of <a href="string_(computer_science)" title="wikilink">strings</a> built from a given set of <a href="Character_(computing)" title="wikilink">characters</a> is a <a href="free_monoid" title="wikilink">free monoid</a>. The <a href="transition_monoid" title="wikilink">transition monoid</a> and <a href="syntactic_monoid" title="wikilink">syntactic monoid</a> are used in describing <a href="finite_state_machines" title="wikilink">finite state machines</a>, whereas <a href="trace_monoid" title="wikilink">trace monoids</a> and <a href="history_monoid" title="wikilink">history monoids</a> provide a foundation for <a href="process_calculi" title="wikilink">process calculi</a> and <a href="concurrent_computing" title="wikilink">concurrent computing</a>. Some of the more important results in the study of monoids are the <a href="Krohn–Rhodes_theorem" title="wikilink">Krohn–Rhodes theorem</a> and the <a href="star_height_problem" title="wikilink">star height problem</a>. The history of monoids, as well as a discussion of additional general properties, are found in the article on <a href="semigroup" title="wikilink">semigroups</a>.</p>
<h2 id="definition">Definition</h2>

<p>Suppose that <em>S</em> is a <a href="set_(mathematics)" title="wikilink">set</a> and • is some <a href="binary_operation" title="wikilink">binary operation</a> , then <em>S</em> with • is a <strong>monoid</strong> if it satisfies the following two axioms:</p>
<dl>
<dt>Associativity: For all <em>a</em>, <em>b</em> and <em>c</em> in <em>S</em>, the equation  holds.<br/>
Identity element: There exists an element <em>e</em> in <em>S</em> such that for every element <em>a</em> in <em>S</em>, the equations  hold.</dt>
</dl>

<p>In other words, a monoid is a <a class="uri" href="semigroup" title="wikilink">semigroup</a> with an <a href="identity_element" title="wikilink">identity element</a>. It can also be thought of as a <a href="magma_(algebra)" title="wikilink">magma</a> with associativity and identity. The identity element of a monoid is unique.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> A monoid in which each element has an <a href="inverse_element" title="wikilink">inverse</a> is a <a href="group_(mathematics)" title="wikilink">group</a>.</p>

<p>Depending on the context, the symbol for the binary operation may be omitted, so that the operation is denoted by juxtaposition; for example, the monoid axioms may be written 

<math display="inline" id="Monoid:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>c</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>a</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>b</mi>
      <mi>c</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <apply>
     <times></times>
     <ci>a</ci>
     <apply>
      <times></times>
      <ci>b</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (ab)c=a(bc)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Monoid:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>e</mi>
    <mi>a</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>a</mi>
    <mi>e</mi>
   </mrow>
   <mo>=</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>e</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>e</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ea=ae=a
  </annotation>
 </semantics>
</math>

. This notation does not imply that it is numbers being multiplied.</p>
<h2 id="monoid-structures">Monoid structures</h2>
<h3 id="submonoids">Submonoids</h3>

<p>A <strong>submonoid</strong> of a monoid  is a <a class="uri" href="subset" title="wikilink">subset</a> <em>N</em> of <em>M</em> that is closed under the monoid operation and contains the identity element <em>e</em> of <em>M</em>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Symbolically, <em>N</em> is a submonoid of <em>M</em> if ,  whenever , and . <em>N</em> is thus a monoid under the binary operation inherited from <em>M</em>.</p>
<h3 id="generators">Generators</h3>

<p>A subset <em>S</em> of <em>M</em> is said to be a <strong>generator</strong> of <em>M</em> if <em>M</em> is the smallest set containing <em>S</em> that is closed under the monoid operation, or equivalently <em>M</em> is the result of applying the <a href="finitary_closure_operator" title="wikilink">finitary closure operator</a> to <em>S</em>. If there is a generator of <em>M</em> that has finite cardinality, then <em>M</em> is said to be <strong>finitely generated</strong>. Not every set <em>S</em> will generate a monoid, as the generated structure may lack an identity element.</p>
<h3 id="commutative-monoid">Commutative monoid</h3>

<p>A monoid whose operation is <a class="uri" href="commutative" title="wikilink">commutative</a> is called a <strong>commutative monoid</strong> (or, less commonly, an <strong>abelian monoid</strong>). Commutative monoids are often written additively. Any commutative monoid is endowed with its <strong>algebraic</strong> <a href="preorder" title="wikilink">preordering</a> ≤, defined by  if there exists <em>z</em> such that .<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> An <strong>order-unit</strong> of a commutative monoid <em>M</em> is an element <em>u</em> of <em>M</em> such that for any element <em>x</em> of <em>M</em>, there exists a positive integer <em>n</em> such that . This is often used in case <em>M</em> is the <a href="Ordered_group" title="wikilink">positive cone</a> of a <a href="Partially_ordered_set" title="wikilink">partially ordered</a> <a href="abelian_group" title="wikilink">abelian group</a> <em>G</em>, in which case we say that <em>u</em> is an order-unit of <em>G</em>.</p>
<h3 id="partially-commutative-monoid">Partially commutative monoid</h3>

<p>A monoid for which the operation is commutative for some, but not all elements is a <a href="trace_monoid" title="wikilink">trace monoid</a>; trace monoids commonly occur in the theory of <a href="concurrent_computation" title="wikilink">concurrent computation</a>.</p>
<h2 id="examples">Examples</h2>
<ul>
<li>Out of the 16 possible <a href="truth_table#Truth_table_for_all_binary_logical_operators" title="wikilink">binary Boolean operators</a>, each of the four that has a two sided identity is also commutative and associative and thus makes the set {False, True} a commutative monoid. Under the standard definitions, <a href="Logical_conjunction" title="wikilink">AND</a> and <a href="Logical_biconditional" title="wikilink">XNOR</a> have the identity True while <a href="Exclusive_disjunction" title="wikilink">XOR</a> and <a href="Logical_disjunction" title="wikilink">OR</a> have the identity False. The monoids from AND and OR are also <a class="uri" href="idempotent" title="wikilink">idempotent</a> while those from XOR and XNOR are not.</li>
<li>The <a href="natural_number" title="wikilink">natural numbers</a>, <strong>N</strong>, form a commutative monoid under addition (identity element <a href="0_(number)" title="wikilink">zero</a>), or multiplication (identity element <a href="1_(number)" title="wikilink">one</a>). A submonoid of <strong>N</strong> under addition is called a <a href="numerical_monoid" title="wikilink">numerical monoid</a>.</li>
<li>The <a href="positive_integer" title="wikilink">positive integers</a>, , form a commutative monoid under multiplication (identity element one).</li>
<li>Given a set A, all subsets of A form a commutative monoid under intersection operation (identity element is A itself).</li>
<li>Given a set A, all subsets of A form a commutative monoid under union operation (identity element is the empty set).</li>
<li>Generalizing the previous example, every bounded <a class="uri" href="semilattice" title="wikilink">semilattice</a> is an <a class="uri" href="idempotent" title="wikilink">idempotent</a> commutative monoid.
<ul>
<li>In particular, any bounded <a href="lattice_(order)" title="wikilink">lattice</a> can be endowed with both a <a href="Join_and_meet" title="wikilink">meet</a>- and a <a href="Join_and_meet" title="wikilink">join</a>- monoid structure. The identity elements are the lattice's top and its bottom, respectively. Being lattices, <a href="Heyting_algebra" title="wikilink">Heyting algebras</a> and <a href="Boolean_algebra_(structure)" title="wikilink">Boolean algebras</a> are endowed with these monoid structures.</li>
</ul></li>
<li>Every <a href="singleton_set" title="wikilink">singleton set</a> {<em>x</em>} closed under a binary operation • forms the trivial (one-element) monoid, which is also the <a href="trivial_group" title="wikilink">trivial group</a>.</li>
<li>Every <a href="group_(mathematics)" title="wikilink">group</a> is a monoid and every <a href="abelian_group" title="wikilink">abelian group</a> a commutative monoid.</li>
<li>Any <a class="uri" href="semigroup" title="wikilink">semigroup</a> <em>S</em> may be turned into a monoid simply by adjoining an element <em>e</em> not in <em>S</em> and defining  for all . This conversion of any semigroup to the monoid is done by the <a href="free_functor" title="wikilink">free functor</a> between the <a href="category_of_semigroups" title="wikilink">category of semigroups</a> and the <a href="category_of_monoids" title="wikilink">category of monoids</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a>
<ul>
<li>Thus, an idempotent monoid (sometimes known as <em>find-first</em>) may be formed by adjoining an identity element <em>e</em> to the <a href="left_zero_semigroup" title="wikilink">left zero semigroup</a> over a set <em>S</em>. The opposite monoid (sometimes called <em>find-last</em>) is formed from the <a href="right_zero_semigroup" title="wikilink">right zero semigroup</a> over <em>S</em>.
<ul>
<li>Adjoin an identity <em>e</em> to the left-zero semigroup with two elements {<em>lt</em>; <em>gt</em>}. Then the resulting idempotent monoid  models the <a href="lexicographical_order" title="wikilink">lexicographical order</a> of a sequence given the orders of its elements, with <em>e</em> representing equality.</li>
</ul></li>
</ul></li>
<li>The elements of any <a href="unital_algebra" title="wikilink">unital</a> <a href="ring_(algebra)" title="wikilink">ring</a>, with addition or multiplication as the operation.
<ul>
<li>The <a href="integer" title="wikilink">integers</a>, <a href="rational_number" title="wikilink">rational numbers</a>, <a href="real_number" title="wikilink">real numbers</a> or <a href="complex_number" title="wikilink">complex numbers</a>, with addition or multiplication as operation.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></li>
<li>The set of all <em>n</em> by <em>n</em> <a href="matrix_(mathematics)" title="wikilink">matrices</a> over a given ring, with <a href="matrix_addition" title="wikilink">matrix addition</a> or <a href="matrix_multiplication" title="wikilink">matrix multiplication</a> as the operation.</li>
</ul></li>
<li>The set of all finite <a href="string_(computer_science)" title="wikilink">strings</a> over some fixed alphabet Σ forms a monoid with <a href="string_concatenation" title="wikilink">string concatenation</a> as the operation. The <a href="empty_string" title="wikilink">empty string</a> serves as the identity element. This monoid is denoted Σ<sup>∗</sup> and is called the <strong><a href="free_monoid" title="wikilink">free monoid</a></strong> over Σ.</li>
<li>Given any monoid <em>M</em>, the <em>opposite monoid</em> M<sup>op</sup> has the same carrier set and identity element as <em>M</em>, and its operation is defined by <em>x</em> •<sup>op</sup> . Any <a href="commutative_monoid" title="wikilink">commutative monoid</a> is the opposite monoid of itself.</li>
<li>Given two sets <em>M</em> and <em>N</em> endowed with monoid structure (or, in general, any finite number of monoids, <em>M</em><sub>1</sub>, ..., <em>M<sub>k</sub></em>), their <a href="cartesian_product" title="wikilink">cartesian product</a>  is also a monoid (respectively, <mtpl></mtpl>). The associative operation and the identity element are defined pairwise.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></li>
<li>Fix a monoid <em>M</em>. The set of all functions from a given set to <em>M</em> is also a monoid. The identity element is a <a href="constant_function" title="wikilink">constant function</a> mapping any value to the identity of <em>M</em>; the associative operation is defined <a class="uri" href="pointwise" title="wikilink">pointwise</a>.</li>
<li>Fix a monoid <em>M</em> with the operation • and identity element <em>e</em>, and consider its <a href="power_set" title="wikilink">power set</a> <em>P</em>(<em>M</em>) consisting of all <a href="subset" title="wikilink">subsets</a> of <em>M</em>. A binary operation for such subsets can be defined by . This turns <em>P</em>(<em>M</em>) into a monoid with identity element {<em>e</em>}. In the same way the power set of a group <em>G</em> is a monoid under the <a href="product_of_group_subsets" title="wikilink">product of group subsets</a>.</li>
<li>Let <em>S</em> be a set. The set of all functions  forms a monoid under <a href="function_composition" title="wikilink">function composition</a>. The identity is just the <a href="identity_function" title="wikilink">identity function</a>. It is also called the <strong><a href="full_transformation_monoid" title="wikilink">full transformation monoid</a></strong> of <em>S</em>. If <em>S</em> is finite with <em>n</em> elements, the monoid of functions on <em>S</em> is finite with <em>n</em><sup><em>n</em></sup> elements.</li>
<li>Generalizing the previous example, let <em>C</em> be a <a href="category_(mathematics)" title="wikilink">category</a> and <em>X</em> an object in <em>C</em>. The set of all <a href="endomorphism" title="wikilink">endomorphisms</a> of <em>X</em>, denoted End<sub><em>C</em></sub>(<em>X</em>), forms a monoid under composition of <a href="morphism" title="wikilink">morphisms</a>. For more on the relationship between category theory and monoids see below.</li>
<li>The set of <a class="uri" href="homeomorphism" title="wikilink">homeomorphism</a> <a href="Class_(set_theory)" title="wikilink">classes</a> of <a href="compact_surface" title="wikilink">compact surfaces</a> with the <a href="connected_sum" title="wikilink">connected sum</a>. Its unit element is the class of the ordinary 2-sphere. Furthermore, if <em>a</em> denotes the class of the <a class="uri" href="torus" title="wikilink">torus</a>, and <em>b</em> denotes the class of the projective plane, then every element <em>c</em> of the monoid has a unique expression the form  where <em>n</em> is the integer ≥ 0 and <em>m</em> = 0, 1, or 2. We have .</li>
<li>Let 

<math display="inline" id="Monoid:2">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>f</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-⟨⟩</csymbol>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle f\rangle
  </annotation>
 </semantics>
</math>

 be a cyclic monoid of order <em>n</em>, that is, 

<math display="inline" id="Monoid:3">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>f</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msup>
     <mi>f</mi>
     <mn>0</mn>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>f</mi>
     <mn>1</mn>
    </msup>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msup>
     <mi>f</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">delimited-⟨⟩</csymbol>
     <ci>f</ci>
    </apply>
    <set>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle f\rangle=\{f^{0},f^{1},\dots,f^{n-1}\}
  </annotation>
 </semantics>
</math>

. Then 

<math display="inline" id="Monoid:4">
 <semantics>
  <mrow>
   <msup>
    <mi>f</mi>
    <mi>n</mi>
   </msup>
   <mo>=</mo>
   <msup>
    <mi>f</mi>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{n}=f^{k}
  </annotation>
 </semantics>
</math>

 for some 

<math display="inline" id="Monoid:5">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>≤</mo>
   <mi>k</mi>
   <mo><</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <ci>k</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\leq k<n
  </annotation>
 </semantics>
</math>

. In fact, each such <em>k</em> gives a distinct monoid of order <em>n</em>, and every cyclic monoid is isomorphic to one of these.</li>
</ul>

<p>Moreover, <em>f</em> can be considered as a function on the points 

<math display="inline" id="Monoid:6">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
    <ci>normal-…</ci>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{0,1,2,\dots,n-1\}
  </annotation>
 </semantics>
</math>

 given by</p>

<p>

<math display="block" id="Monoid:7">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="center">
      <mn>0</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>2</mn>
     </mtd>
     <mtd columnalign="center">
      <mi mathvariant="normal">…</mi>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mn>1</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>2</mn>
     </mtd>
     <mtd columnalign="center">
      <mn>3</mn>
     </mtd>
     <mtd columnalign="center">
      <mi mathvariant="normal">…</mi>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mi>k</mi>
     </mtd>
    </mtr>
   </mtable>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>k</ci>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}0&1&2&\dots&n-2&n-1\\
1&2&3&\dots&n-1&k\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>or, equivalently</p>

<p>

<math display="block" id="Monoid:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mi>i</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mn>0</mn>
        </mrow>
        <mo>≤</mo>
        <mi>i</mi>
        <mo><</mo>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>k</mi>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>i</mi>
        </mrow>
        <mo>=</mo>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mn>1.</mn>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <and></and>
      <apply>
       <leq></leq>
       <apply>
        <times></times>
        <mtext>if</mtext>
        <cn type="integer">0</cn>
       </apply>
       <ci>i</ci>
      </apply>
      <apply>
       <lt></lt>
       <share href="#.cmml">
       </share>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>k</ci>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>i</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="float">1.</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(i):=\begin{cases}i+1,&\mbox{if }0\leq i<n-1\\
k,&\mbox{if }i=n-1.\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>Multiplication of elements in 

<math display="inline" id="Monoid:9">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>f</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-⟨⟩</csymbol>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle f\rangle
  </annotation>
 </semantics>
</math>

 is then given by function composition.</p>

<p>Note also that when 

<math display="inline" id="Monoid:10">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=0
  </annotation>
 </semantics>
</math>

 then the function <em>f</em> is a permutation of 

<math display="inline" id="Monoid:11">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
    <ci>normal-…</ci>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{0,1,2,\dots,n-1\}
  </annotation>
 </semantics>
</math>

 and gives the unique <a href="cyclic_group" title="wikilink">cyclic group</a> of order <em>n</em>.</p>
<h2 id="properties">Properties</h2>

<p>In a monoid, one can define positive integer powers of an element <em>x</em> : <em>x</em><sup>1</sup> = <em>x</em>, and <em>x</em><sup>n</sup> = <em>x</em> • ... • <em>x</em> (<em>n</em> times) for <em>n</em> &gt; 1 . The rule of powers <em>x</em><sup><em>n</em> + <em>p</em></sup> = <em>x</em><sup><em>n</em></sup> • <em>x</em><sup><em>p</em></sup> is obvious.</p>

<p>From the definition of a monoid, one can show that the identity element <em>e</em> is unique. Then, for any <em>x</em>, one can set <em>x</em><sup>0</sup> = <em>e</em> and the rule of powers is still true with nonnegative exponents.</p>

<p>It is possible to define <a href="inverse_element" title="wikilink">invertible elements</a>: an element <em>x</em> is called invertible if there exists an element <em>y</em> such that  and . The element <em>y</em> is called the inverse of <em>x</em>. If <em>y</em> and <em>z</em> are inverses of <em>x</em>, then by associativity . Thus inverses, if they exist, are unique.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>If <em>y</em> is the inverse of <em>x</em>, one can define negative powers of <em>x</em> by setting <mtpl></mtpl> and <mtpl></mtpl> (<em>n</em> times) for . And the rule of exponents is still verified for all <em>n</em>, <em>p</em> rational integers. This is why the inverse of <em>x</em> is usually written <em>x</em><sup>−1</sup>. The set of all invertible elements in a monoid <em>M</em>, together with the operation •, forms a <a href="group_(mathematics)" title="wikilink">group</a>. In that sense, every monoid contains a group (possibly only the <a href="trivial_group" title="wikilink">trivial group</a> consisting of only the identity).</p>

<p>However, not every monoid sits inside a group. For instance, it is perfectly possible to have a monoid in which two elements <em>a</em> and <em>b</em> exist such that  holds even though <em>b</em> is not the identity element. Such a monoid cannot be embedded in a group, because in the group we could multiply both sides with the inverse of <em>a</em> and would get that , which isn't true. A monoid  has the <a href="cancellation_property" title="wikilink">cancellation property</a> (or is <a class="uri" href="cancellative" title="wikilink">cancellative</a>) if for all <em>a</em>, <em>b</em> and <em>c</em> in <em>M</em>,  always implies  and  always implies . A commutative monoid with the cancellation property can always be embedded in a group via the <a href="Grothendieck_group" title="wikilink">Grothendieck construction</a>. That is how the additive group of the integers (a group with operation +) is constructed from the additive monoid of natural numbers (a commutative monoid with operation + and cancellation property). However, a non-commutative cancellative monoid need not be embeddable in a group.</p>

<p>If a monoid has the cancellation property and is <em>finite</em>, then it is in fact a group. Proof: Fix an element <em>x</em> in the monoid. Since the monoid is finite, <mtpl></mtpl> for some . But then, by cancellation we have that <mtpl></mtpl> where <em>e</em> is the identity. Therefore <mtpl></mtpl>, so <em>x</em> has an inverse.</p>

<p>The right- and left-cancellative elements of a monoid each in turn form a submonoid (i.e. obviously include the identity and not so obviously are closed under the operation). This means that the cancellative elements of any commutative monoid can be extended to a group.</p>

<p>It turns out that requiring the cancellative property in a monoid is not required to perform the Grothendieck construction – commutativity is sufficient. However, if the original monoid has an <a href="absorbing_element" title="wikilink">absorbing element</a> then its Grothendieck group is the trivial group. Hence the homomorphism is, in general, not injective.</p>

<p>An <strong>inverse monoid</strong> is a monoid where for every <em>a</em> in <em>M</em>, there exists a unique <em>a</em><sup>−1</sup> in <em>M</em> such that <mtpl></mtpl> and <mtpl></mtpl>. If an inverse monoid is cancellative, then it is a group.</p>

<p>In the opposite direction, a <strong><a href="zerosumfree_monoid" title="wikilink">zerosumfree monoid</a></strong> is an additively written monoid in which  implies that  and :<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> equivalently, that no element other than zero has an additive inverse.</p>
<h2 id="acts-and-operator-monoids">Acts and operator monoids</h2>

<p>Let <em>M</em> be a monoid, with the binary operation denoted by • and the identity element denoted by <em>e</em>. Then a (left) <strong><em>M</em>-act</strong> (or left act over <em>M</em>) is a set <em>X</em> together with an operation  which is compatible with the monoid structure as follows:</p>
<ul>
<li>for all <em>x</em> in <em>X</em>: ;</li>
<li>for all <em>a</em>, <em>b</em> in <em>M</em> and <em>x</em> in <em>X</em>: .</li>
</ul>

<p>This is the analogue in monoid theory of a (left) <a href="group_action" title="wikilink">group action</a>. Right <em>M</em>-acts are defined in a similar way. A monoid with an act is also known as an <strong><a href="operator_monoid" title="wikilink">operator monoid</a></strong>. Important examples include <a href="transition_system" title="wikilink">transition systems</a> of <a class="uri" href="semiautomata" title="wikilink">semiautomata</a>. A <a href="transformation_semigroup" title="wikilink">transformation semigroup</a> can be made into an operator monoid by adjoining the identity transformation.</p>
<h2 id="monoid-homomorphisms">Monoid homomorphisms</h2>

<p> A <a class="uri" href="homomorphism" title="wikilink">homomorphism</a> between two monoids  and  is a function  such that</p>
<ul>
<li><em>f</em>(<em>x</em> ∗ <em>y</em>) = <em>f</em>(<em>x</em>) • <em>f</em>(<em>y</em>) for all <em>x</em>, <em>y</em> in <em>M</em></li>
<li><em>f</em>(<em>e</em><sub><em>M</em></sub>) = <em>e</em><sub><em>N</em></sub>,</li>
</ul>

<p>where <em>e</em><sub><em>M</em></sub> and <em>e</em><sub><em>N</em></sub> are the identities on <em>M</em> and <em>N</em> respectively. Monoid homomorphisms are sometimes simply called <strong>monoid morphisms</strong>.</p>

<p>Not every <a href="semigroup_homomorphism" title="wikilink">semigroup homomorphism</a> is a monoid homomorphism, since it may not map the identity to the identity of the target monoid, even though the element it maps the identity to will be an identity of the image of the mapping. In contrast, a semigroup homomorphisms between groups is always a <a href="group_homomorphism" title="wikilink">group homomorphism</a>, as it necessarily preserves the identity. Since for monoids this isn't always true, it is necessary to state this as a separate requirement.</p>

<p>A <a class="uri" href="bijective" title="wikilink">bijective</a> monoid homomorphism is called a monoid <a class="uri" href="isomorphism" title="wikilink">isomorphism</a>. Two monoids are said to be isomorphic if there is a monoid isomorphism between them.</p>
<h2 id="equational-presentation">Equational presentation</h2>

<p>Monoids may be given a <strong>presentation</strong>, much in the same way that groups can be specified by means of a <a href="group_presentation" title="wikilink">group presentation</a>. One does this by specifying a set of generators Σ, and a set of relations on the <a href="free_monoid" title="wikilink">free monoid</a> Σ<sup>∗</sup>. One does this by extending (finite) <a href="binary_relation" title="wikilink">binary relations</a> on Σ<sup>∗</sup> to monoid congruences, and then constructing the quotient monoid, as above.</p>

<p>Given a binary relation <mtpl></mtpl>, one defines its symmetric closure as <mtpl></mtpl>. This can be extended to a symmetric relation <mtpl></mtpl> by defining <mtpl></mtpl> if and only if  and  for some strings <mtpl></mtpl> with <mtpl></mtpl>. Finally, one takes the reflexive and transitive closure of <em>E</em>, which is then a monoid congruence.</p>

<p>In the typical situation, the relation <em>R</em> is simply given as a set of equations, so that 

<math display="inline" id="Monoid:12">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>u</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>v</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>,</mo>
    <msub>
     <mi>u</mi>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>v</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">R</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <cn type="integer">1</cn>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-⋯</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>n</ci>
     </apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=\{u_{1}=v_{1},\cdots,u_{n}=v_{n}\}
  </annotation>
 </semantics>
</math>


. Thus, for example,</p>

<p>

<math display="block" id="Monoid:13">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mrow>
    <mi>p</mi>
    <mo>,</mo>
    <mpadded width="+1.7pt">
     <mi>q</mi>
    </mpadded>
   </mrow>
   <mo rspace="5.3pt" stretchy="false">|</mo>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mi>q</mi>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">inner-product</csymbol>
    <list>
     <ci>p</ci>
     <ci>q</ci>
    </list>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>q</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle p,q\,|\;pq=1\rangle
  </annotation>
 </semantics>
</math>

 is the equational presentation for the <a href="bicyclic_monoid" title="wikilink">bicyclic monoid</a>, and</p>

<p>

<math display="block" id="Monoid:14">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mrow>
    <mi>a</mi>
    <mo>,</mo>
    <mpadded width="+1.7pt">
     <mi>b</mi>
    </mpadded>
   </mrow>
   <mo rspace="5.3pt" stretchy="false">|</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>a</mi>
      <mi>b</mi>
      <mi>a</mi>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>b</mi>
      <mi>a</mi>
      <mi>a</mi>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mi>b</mi>
      <mi>b</mi>
      <mi>a</mi>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>b</mi>
      <mi>a</mi>
      <mi>b</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">inner-product</csymbol>
    <list>
     <ci>a</ci>
     <ci>b</ci>
    </list>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>b</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <times></times>
       <ci>b</ci>
       <ci>a</ci>
       <ci>a</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>b</ci>
       <ci>b</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <times></times>
       <ci>b</ci>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle a,b\,|\;aba=baa,bba=bab\rangle
  </annotation>
 </semantics>
</math>

 is the <a href="plactic_monoid" title="wikilink">plactic monoid</a> of degree 2 (it has infinite order). Elements of this plactic monoid may be written as 

<math display="inline" id="Monoid:15">
 <semantics>
  <mrow>
   <msup>
    <mi>a</mi>
    <mi>i</mi>
   </msup>
   <msup>
    <mi>b</mi>
    <mi>j</mi>
   </msup>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>b</mi>
      <mi>a</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>b</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <times></times>
      <ci>b</ci>
      <ci>a</ci>
     </apply>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{i}b^{j}(ba)^{k}
  </annotation>
 </semantics>
</math>

 for integers <em>i</em>, <em>j</em>, <em>k</em>, as the relations show that <em>ba</em> commutes with both <em>a</em> and <em>b</em>.</p>
<h2 id="relation-to-category-theory">Relation to category theory</h2>

<p>Monoids can be viewed as a special class of <a href="category_theory" title="wikilink">categories</a>. Indeed, the axioms required of a monoid operation are exactly those required of <a class="uri" href="morphism" title="wikilink">morphism</a> composition when restricted to the set of all morphisms whose source and target is a given object.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> That is,</p>
<dl>
<dd><em>A monoid is, essentially, the same thing as a category with a single object.</em>
</dd>
</dl>

<p>More precisely, given a monoid , one can construct a small category with only one object and whose morphisms are the elements of <em>M</em>. The composition of morphisms is given by the monoid operation •.</p>

<p>Likewise, monoid homomorphisms are just <a href="functor" title="wikilink">functors</a> between single object categories.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> So this construction gives an <a href="equivalence_of_categories" title="wikilink">equivalence</a> between the <a href="category_of_monoids" title="wikilink">category of (small) monoids</a> <strong>Mon</strong> and a full subcategory of the category of (small) categories <strong>Cat</strong>. Similarly, the <a href="category_of_groups" title="wikilink">category of groups</a> is equivalent to another full subcategory of <strong>Cat</strong>.</p>

<p>In this sense, category theory can be thought of as an extension of the concept of a monoid. Many definitions and theorems about monoids can be generalised to small categories with more than one object. For example, a quotient of a category with one object is just a quotient monoid.</p>

<p>Monoids, just like other algebraic structures, also form their own category, <strong>Mon</strong>, whose objects are monoids and whose morphisms are monoid homomorphisms.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>There is also a notion of <a href="monoid_(category_theory)" title="wikilink">monoid object</a> which is an abstract definition of what is a monoid in a category. A monoid object in <strong><a href="category_of_sets" title="wikilink">Set</a></strong> is just a monoid.</p>
<h2 id="monoids-in-computer-science">Monoids in computer science</h2>

<p>In computer science, many <a href="abstract_data_types" title="wikilink">abstract data types</a> can be endowed with a monoid structure. In a common pattern, a <a class="uri" href="sequence" title="wikilink">sequence</a> of elements of a monoid is "<a href="fold_(higher-order_function)" title="wikilink">folded</a>" or "accumulated" to produce a final value. For instance, many iterative algorithms need to update some kind of "running total" at each iteration; this pattern may be elegantly expressed by a monoid operation. Alternatively, the associativity of monoid operations ensures that the operation can be <a href="parallelization" title="wikilink">parallelized</a> by employing a <a href="prefix_sum" title="wikilink">prefix sum</a> or similar algorithm, in order to utilize multiple cores or processors efficiently.</p>

<p>Given a sequence of values of type <em>M</em> with identity element 

<math display="inline" id="Monoid:16">
 <semantics>
  <mi>ε</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ε</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

 and associative operation 

<math display="inline" id="Monoid:17">
 <semantics>
  <mo>*</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *
  </annotation>
 </semantics>
</math>


, the <em>fold</em> operation is defined as follows:</p>

<p>

<math display="block" id="Monoid:18">
 <semantics>
  <mrow>
   <mi>fold</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>M</mi>
     <mo>*</mo>
    </msup>
    <mo>→</mo>
    <mi>M</mi>
    <mo>=</mo>
    <mi>l</mi>
    <mo>↦</mo>
    <mrow>
     <mo>{</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="left">
        <mi>ε</mi>
       </mtd>
       <mtd columnalign="left">
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mi>l</mi>
         </mrow>
         <mo>=</mo>
         <mi>nil</mi>
        </mrow>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="left">
        <mrow>
         <mrow>
          <mi>m</mi>
          <mo>*</mo>
          <mpadded width="+1.7pt">
           <mi>fold</mi>
          </mpadded>
         </mrow>
         <msup>
          <mi>l</mi>
          <mo>′</mo>
         </msup>
        </mrow>
       </mtd>
       <mtd columnalign="left">
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mi>l</mi>
         </mrow>
         <mo>=</mo>
         <mrow>
          <mpadded width="+1.7pt">
           <mi>cons</mi>
          </mpadded>
          <mpadded width="+1.7pt">
           <mi>m</mi>
          </mpadded>
          <msup>
           <mi>l</mi>
           <mo>′</mo>
          </msup>
         </mrow>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>fold</ci>
    <apply>
     <and></and>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>M</ci>
       <times></times>
      </apply>
      <ci>M</ci>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <ci>l</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">maps-to</csymbol>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="latexml">cases</csymbol>
       <ci>ε</ci>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <mtext>if</mtext>
         <ci>l</ci>
        </apply>
        <ci>nil</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <times></times>
         <ci>m</ci>
         <ci>fold</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>l</ci>
         <ci>normal-′</ci>
        </apply>
       </apply>
       <apply>
        <eq></eq>
        <apply>
         <times></times>
         <mtext>if</mtext>
         <ci>l</ci>
        </apply>
        <apply>
         <times></times>
         <ci>cons</ci>
         <ci>m</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>l</ci>
          <ci>normal-′</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{fold}:M^{*}\rightarrow M=l\mapsto\begin{cases}\varepsilon&\mbox{if }l=%
\mathrm{nil}\\
m*\mathrm{fold}\,l^{\prime}&\mbox{if }l=\mathrm{cons}\,m\,l^{\prime}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>In addition, any <a href="data_structure" title="wikilink">data structure</a> can be 'folded' in a similar way, given a serialization of its elements. For instance, the result of "folding" a <a href="binary_tree" title="wikilink">binary tree</a> might differ depending on pre-order vs. post-order <a href="tree_traversal" title="wikilink">tree traversal</a>.</p>
<h2 id="complete-monoids">Complete monoids</h2>

<p>A <strong>complete monoid</strong> is a commutative monoid equipped with an <a href="infinitary_sum" title="wikilink">infinitary sum</a> operation 

<math display="inline" id="Monoid:19">
 <semantics>
  <msub>
   <mi mathvariant="normal">Σ</mi>
   <mi>I</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Σ</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{I}
  </annotation>
 </semantics>
</math>

 for any <a href="index_set" title="wikilink">index set</a> <em>I</em> such that:<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> 

<math display="inline" id="Monoid:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>∈</mo>
       <mi mathvariant="normal">∅</mi>
      </mrow>
     </msub>
     <msub>
      <mi>m</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo rspace="12.5pt">;</mo>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>∈</mo>
        <mrow>
         <mo stretchy="false">{</mo>
         <mi>j</mi>
         <mo stretchy="false">}</mo>
        </mrow>
       </mrow>
      </msub>
      <msub>
       <mi>m</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>m</mi>
      <mi>j</mi>
     </msub>
    </mrow>
    <mo rspace="12.5pt">;</mo>
    <mrow>
     <mrow>
      <mrow>
       <msub>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mi>i</mi>
         <mo>∈</mo>
         <mrow>
          <mo stretchy="false">{</mo>
          <mi>j</mi>
          <mo>,</mo>
          <mi>k</mi>
          <mo stretchy="false">}</mo>
         </mrow>
        </mrow>
       </msub>
       <msub>
        <mi>m</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo>=</mo>
      <mrow>
       <msub>
        <mi>m</mi>
        <mi>j</mi>
       </msub>
       <mo>+</mo>
       <msub>
        <mi>m</mi>
        <mi>k</mi>
       </msub>
      </mrow>
     </mrow>
     <mrow>
      <mrow>
       <mpadded width="+2.8pt">
        <mtext>for</mtext>
       </mpadded>
       <mi>j</mi>
      </mrow>
      <mo>≠</mo>
      <mi>k</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>i</ci>
        <emptyset></emptyset>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <in></in>
         <ci>i</ci>
         <set>
          <ci>j</ci>
         </set>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <eq></eq>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <in></in>
          <ci>i</ci>
          <set>
           <ci>j</ci>
           <ci>k</ci>
          </set>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <ci>j</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <neq></neq>
       <apply>
        <times></times>
        <mtext>for</mtext>
        <ci>j</ci>
       </apply>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i\in\emptyset}{m_{i}}=0;\quad\sum_{i\in\{j\}}{m_{i}}=m_{j};\quad\sum_{i%
\in\{j,k\}}{m_{i}}=m_{j}+m_{k}\quad\textrm{for}\;j\neq k
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="inline" id="Monoid:21">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>j</mi>
      <mo>∈</mo>
      <mi>J</mi>
     </mrow>
    </msub>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>∈</mo>
       <msub>
        <mi>I</mi>
        <mi>j</mi>
       </msub>
      </mrow>
     </msub>
     <msub>
      <mi>m</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>∈</mo>
      <mi>I</mi>
     </mrow>
    </msub>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>m</mi>
       <mi>i</mi>
      </msub>
      <mo rspace="5.3pt" stretchy="false">)</mo>
     </mrow>
     <mtext>if</mtext>
     <mrow>
      <msub>
       <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋃</mo>
       <mrow>
        <mi>j</mi>
        <mo>∈</mo>
        <mi>J</mi>
       </mrow>
      </msub>
      <msub>
       <mi>I</mi>
       <mi>j</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mpadded width="+2.8pt">
      <mi>I</mi>
     </mpadded>
     <mpadded width="+2.8pt">
      <mtext>and</mtext>
     </mpadded>
     <msub>
      <mi>I</mi>
      <mi>j</mi>
     </msub>
    </mrow>
    <mo>∩</mo>
    <msub>
     <mi>I</mi>
     <msup>
      <mi>j</mi>
      <mo>′</mo>
     </msup>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mpadded width="+2.8pt">
     <mi mathvariant="normal">∅</mi>
    </mpadded>
    <mpadded width="+2.8pt">
     <mtext>for</mtext>
    </mpadded>
    <mi>j</mi>
   </mrow>
   <mo>≠</mo>
   <msup>
    <mi>j</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>j</ci>
        <ci>J</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <in></in>
         <ci>i</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>I</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <ci>i</ci>
        <ci>I</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <ci>i</ci>
       </apply>
       <mtext>if</mtext>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <union></union>
         <apply>
          <in></in>
          <ci>j</ci>
          <ci>J</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>I</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <intersect></intersect>
      <apply>
       <times></times>
       <ci>I</ci>
       <mtext>and</mtext>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>I</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>j</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <emptyset></emptyset>
      <mtext>for</mtext>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <neq></neq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>j</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{j\in J}{\sum_{i\in I_{j}}{m_{i}}}=\sum_{i\in I}(m_{i})\;\textrm{if}%
\bigcup_{j\in J}I_{j}=I\;\textrm{and}\;I_{j}\cap I_{j^{\prime}}=\emptyset\;%
\textrm{for}\;j\neq j^{\prime}
  </annotation>
 </semantics>
</math>

</p>

<p>A <strong>continuous monoid</strong> is an ordered commutative monoid in which every <a href="directed_set" title="wikilink">directed set</a> has a <a href="least_upper_bound" title="wikilink">least upper bound</a> compatible with the monoid operation:</p>

<p>

<math display="inline" id="Monoid:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mo>+</mo>
     <mrow>
      <mo>sup</mo>
      <mi>S</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>sup</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>a</mi>
       <mo>+</mo>
       <mi>S</mi>
      </mrow>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <ci>a</ci>
     <apply>
      <csymbol cd="latexml">supremum</csymbol>
      <ci>S</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">supremum</csymbol>
     <apply>
      <plus></plus>
      <ci>a</ci>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a+\sup S=\sup(a+S)\ .
  </annotation>
 </semantics>
</math>


</p>

<p>These two concepts are closely related: a continuous monoid is a complete monoid in which the infinitary sum may be defined as</p>

<p>

<math display="block" id="Monoid:23">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mi>I</mi>
    </munder>
    <msub>
     <mi>a</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo movablelimits="false">sup</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>E</mi>
     </munder>
     <msub>
      <mi>a</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>I</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">supremum</csymbol>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>E</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{I}a_{i}=\sup\sum_{E}a_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>where the supremum on the right runs over all finite subsets <em>E</em> of <em>I</em> and each sum on the right is a finite sum in the monoid.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Green's_relations" title="wikilink">Green's relations</a></li>
<li><a href="Monad_(functional_programming)" title="wikilink">Monad (functional programming)</a></li>
<li><a class="uri" href="Semiring" title="wikilink">Semiring</a> and <a href="Kleene_algebra" title="wikilink">Kleene algebra</a></li>
<li><a href="Star_height_problem" title="wikilink">Star height problem</a></li>
<li><a href="Vedic_square" title="wikilink">Vedic square</a></li>
</ul>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Group_(mathematics)" title="wikilink">Group</a></p></td>
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Monoid</p></td>
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a class="uri" href="Semigroup" title="wikilink">Semigroup</a></p></td>
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Magma_(algebra)" title="wikilink">Magma</a></p></td>
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Operation_(mathematics)" title="wikilink">Operation</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Closure_(mathematics)" title="wikilink">Closure</a></p></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a class="uri" href="Associativity" title="wikilink">Associativity</a></p></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Identity_element" title="wikilink">Identity</a></p></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Inverse_element" title="wikilink">Inverses</a></p></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Algebraic_structures" title="wikilink">Category:Algebraic structures</a> <a href="Category:Category_theory" title="wikilink">Category:Category theory</a> <a href="Category:Semigroup_theory" title="wikilink">Category:Semigroup theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">If both <em>e</em><sub>1</sub> and <em>e</em><sub>2</sub> satisfy the above equations, then <em>e</em><sub>1</sub> = <em>e</em><sub>1</sub> • <em>e</em><sub>2</sub> = <em>e</em><sub>2</sub>.<a href="#fnref1">↩</a></li>
<li id="fn2">Jacobson (2009)<a href="#fnref2">↩</a></li>
<li id="fn3">Some authors omit the requirement that a submonoid must contain the identity element from its definition, requiring only that it have <em>an</em> identity element, which can be distinct from that of <em>M</em>.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">.<a href="#fnref5">↩</a></li>
<li id="fn6">Jacobson (2009), p. 29, examples 1, 2, 4 &amp; 5.<a href="#fnref6">↩</a></li>
<li id="fn7">Jacobson (2009), p. 35<a href="#fnref7">↩</a></li>
<li id="fn8">Jacobson, I.5. p. 22<a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13">Droste, M., &amp; Kuich, W. (2009). Semirings and Formal Power Series. <em>Handbook of Weighted Automata</em>, 3–28. , pp. 7-10<a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"></li>
</ol>
</section>
</body>
</html>
