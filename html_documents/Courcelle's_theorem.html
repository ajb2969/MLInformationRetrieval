<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="171">Courcelle's theorem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Courcelle's theorem</h1>
<hr/>

<p>In the study of <a href="graph_theory" title="wikilink">graph</a> <a href="algorithm" title="wikilink">algorithms</a>, <strong>Courcelle's theorem</strong> is the statement that every <a href="graph_property" title="wikilink">graph property</a> definable in <a href="monadic_second-order_logic" title="wikilink">monadic second-order logic</a> can be decided in <a href="linear_time" title="wikilink">linear time</a> on graphs of bounded <a class="uri" href="treewidth" title="wikilink">treewidth</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The result was first proved by <a href="Bruno_Courcelle" title="wikilink">Bruno Courcelle</a> in 1990<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> and independently rediscovered by .<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> It is considered the archetype of algorithmic <a href="meta-theorem" title="wikilink">meta-theorems</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="formulations">Formulations</h2>
<h3 id="vertex-sets">Vertex sets</h3>

<p>In one variation of monadic second-order graph logic known as MSO<sub>1</sub>, the <a href="graph_(mathematics)" title="wikilink">graph</a> is described by a set of vertices <em>V</em> and a binary adjacency relation adj(.,.), and the restriction to monadic logic means that the graph property in question may be defined in terms of sets of vertices of the given graph, but not in terms of sets of edges or of tuples of vertices.</p>

<p>As an example, the property of a graph being <a href="graph_coloring" title="wikilink">colorable</a> with three colors (represented by three sets of vertices <em>R</em>, <em>G</em>, and <em>B</em>) may be defined by the monadic second-order formula</p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>∃<em>R</em>,<em>G</em>,<em>B</em>.</p></td>
<td style="text-align: left;">
<p>(∀<em>v</em>∈<em>V</em>. (<em>v</em>∈<em>R</em> ∨ <em>v</em>∈<em>G</em> ∨ <em>v</em>∈<em>B</em>)) ∧</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>(∀<em>u</em>,<em>v</em>∈<em>V</em>. ((<em>u</em>∈<em>R</em> ∧ <em>v</em>∈<em>R</em>) ∨ (<em>u</em>∈<em>G</em> ∧ <em>v</em>∈<em>G</em>) ∨ (<em>u</em>∈<em>B</em> ∧ <em>v</em>∈<em>B</em>)) → ¬adj(<em>u</em>,<em>v</em>)).</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>The first part of this formula ensures that the three color classes cover all the vertices of the graph, and the second ensures that they each form an <a href="independent_set_(graph_theory)" title="wikilink">independent set</a>. (It would also be possible to add clauses to the formula to ensure that the three color classes are disjoint, but this makes no difference to the result.) Thus, by Courcelle's theorem, 3-colorability of graphs of bounded treewidth may be tested in linear time.</p>

<p>For this variation of graph logic, Courcelle's theorem can be extended from treewidth to <a class="uri" href="clique-width" title="wikilink">clique-width</a>: for every fixed MSO<sub>1</sub> property <em>P</em>, and every fixed bound <em>b</em> on the clique-width of a graph, there is a linear-time algorithm for testing whether a graph of clique-width at most <em>b</em> has property <em>P</em>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h3 id="edge-sets">Edge sets</h3>

<p>Courcelle's theorem may also be used with a stronger variation of monadic second-order logic known as MSO<sub>2</sub>. In this formulation, a graph is represented by a set <em>V</em> of vertices, a set <em>E</em> of edges, and an incidence relation between vertices and edges. This variation allows quantification over sets of vertices or edges, but not over more complex relations on tuples of vertices or edges.</p>

<p>For instance, the property of having a <a href="Hamiltonian_cycle" title="wikilink">Hamiltonian cycle</a> may be expressed in MSO<sub>2</sub> by describing the cycle as a set of edges that includes exactly two edges incident to each vertex, such that every nonempty proper subset of vertices has an edge in the cycle with exactly one endpoint in the subset. However, Hamiltonicity cannot be expressed in MSO<sub>1</sub>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h3 id="modular-congruences">Modular congruences</h3>

<p>Another direction for extending Courcelle's theorem concerns logical formulas that include predicates for counting the size of the test. In this context, it is not possible to perform arbitrary arithmetic operations on set sizes, nor even to test whether two sets have the same size. However, MSO<sub>1</sub> and MSO<sub>2</sub> can be extended to logics called CMSO<sub>1</sub> and CMSO<sub>2</sub>, that include for every two constants <em>q</em> and <em>r</em> a predicate 

<math display="inline" id="Courcelle's_theorem:0">
 <semantics>
  <mrow>
   <msub>
    <mo>card</mo>
    <mrow>
     <mi>q</mi>
     <mo>,</mo>
     <mi>r</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>card</ci>
     <list>
      <ci>q</ci>
      <ci>r</ci>
     </list>
    </apply>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{card}_{q,r}(S)
  </annotation>
 </semantics>
</math>

 which tests whether the <a class="uri" href="cardinality" title="wikilink">cardinality</a> of set <em>S</em> is <a href="Modular_arithmetic" title="wikilink">congruent</a> to <em>r</em> modulo <em>q</em>. Courcelle's theorem can be extended to these logics.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h3 id="space-complexity">Space complexity</h3>

<p>Rather than bounding the <a href="time_complexity" title="wikilink">time complexity</a> of an algorithm that recognizes an MSO property on bounded-treewidth graphs, it is also possible to analyze the <a href="space_complexity" title="wikilink">space complexity</a> of such an algorithm; that is, the amount of memory needed above and beyond the size of the input itself (which is assumed to be represented in a read-only way so that its space requirements cannot be put to other purposes). In particular, it is possible to recognize the graphs of bounded treewidth, and any MSO property on these graphs, by a <a href="deterministic_Turing_machine" title="wikilink">deterministic Turing machine</a> that uses only <a href="L_(complexity)" title="wikilink">logarithmic space</a>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h2 id="proof-strategy">Proof strategy</h2>

<p>The typical approach to proving Courcelle's theorem involves the construction of a finite bottom-up <a href="tree_automaton" title="wikilink">tree automaton</a> that acts on the <a href="tree_decomposition" title="wikilink">tree decompositions</a> of the given graph.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>In more detail, two graphs <em>G</em><sub>1</sub> and <em>G</em><sub>2</sub>, each with a specified subset <em>T</em> of vertices called terminals, may be defined to be equivalent with respect to an MSO formula <em>F</em> if, for all other graphs <em>H</em> whose intersection with <em>G</em><sub>1</sub> and <em>G</em><sub>2</sub> consists only of vertices in <em>T</em>, the two graphs <em>G</em><sub>1</sub> ∪ <em>H</em> and <em>G</em><sub>2</sub> ∪ <em>H</em> behave the same with respect to <em>F</em>: either they both model <em>F</em> or they both do not model <em>F</em>. This is an <a href="equivalence_relation" title="wikilink">equivalence relation</a>, and it can be shown by induction on the length of <em>F</em> that (when the sizes of of <em>T</em> and <em>F</em> are both bounded) it has finitely many <a href="equivalence_class" title="wikilink">equivalence classes</a>.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>A tree decomposition of a given graph <em>G</em> consists of a tree and, for each tree node, a subset of the vertices of <em>G</em> called a bag. It must satisfy two properties: for each vertex <em>v</em> of <em>G</em>, the bags containing <em>v</em> must be associated with a contiguous subtree of the tree, and for each edge <em>uv</em> of <em>G</em>, there must be a bag containing both <em>u</em> and <em>v</em>. The vertices in a bag can be thought of as the terminals of a subgraph of <em>G</em>, represented by the subtree of the tree decomposition descending from that bag. When <em>G</em> has bounded treewidth, it has a tree decomposition in which all bags have bounded size, and such a decomposition can be found in fixed-parameter tractable time.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Moreover, it is possible to choose this tree decomposition so that it forms a <a href="binary_tree" title="wikilink">binary tree</a>, with only two child subtrees per bag. Therefore, it is possible to perform a bottom-up computation on this tree decomposition, computing an identifier for the equivalence class of the subtree rooted at each bag by combining the edges represented within the bag with the two identifiers for the equivalence classes of its two children.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h2 id="satisfiability-and-seeses-theorem">Satisfiability and Seese's theorem</h2>

<p>The <a href="satisfiability_problem" title="wikilink">satisfiability problem</a> for a formula of monadic second-order logic is the problem of determining whether there exists at least one graph (possibly within a restricted family of graphs) for which the formula is true. For arbitrary graph families, and arbitrary formulas, this problem is <a href="undecidable_problem" title="wikilink">undecidable</a>. However, satisfiability of MSO<sub>2</sub> formulas is decidable for the graphs of bounded treewidth, and satisfiability of MSO<sub>1</sub> formulas is decidable for graphs of bounded clique-width. The proof involves building a tree automaton for the formula and then testing whether the automaton has an accepting path.</p>

<p>As a partial converse,  proved that, whenever a family of graphs has a decidable MSO<sub>2</sub> satisfiability problem, the family must have bounded treewidth. The proof is based on a theorem of Robertson and Seymour that the families of graphs with unbounded treewidth have arbitrarily large <a href="grid_graph" title="wikilink">grid</a> <a href="graph_minor" title="wikilink">minors</a>.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> Seese also conjectured that every family of graphs with a decidable MSO<sub>1</sub> satisfiability problem must have bounded clique-width; this has not been proven, but a weakening of the conjecture that replaces MSO<sub>1</sub> by CMSO<sub>1</sub> is true.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<h2 id="applications">Applications</h2>

<p>used Courcelle's theorem to show that computing the <a href="Crossing_number_(graph_theory)" title="wikilink">crossing number</a> of a graph <em>G</em> is <a href="parameterized_complexity" title="wikilink">fixed-parameter tractable</a> with a quadratic dependence on the size of <em>G</em>, improving a cubic-time algorithm based on the <a href="Robertson–Seymour_theorem" title="wikilink">Robertson–Seymour theorem</a>. An additional later improvement to <a href="linear_time" title="wikilink">linear time</a> by  follows the same approach. If the given graph <em>G</em> has small treewidth, Courcelle's theorem can be applied directly to this problem. On the other hand, if <em>G</em> has large treewidth, then it contains a large <a href="grid_graph" title="wikilink">grid</a> <a href="graph_minor" title="wikilink">minor</a>, within which the graph can be simplified while leaving the crossing number unchanged. Grohe's algorithm performs these simplifications until the remaining graph has a small treewidth, and then applies Courcelle's theorem to solve the reduced subproblem.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a>  observed that Courcelle's theorem applies to several problems of finding minimum multi-way <a href="Cut_(graph_theory)" title="wikilink">cuts</a> in a graph, when the structure formed by the graph and the set of cut pairs has bounded treewidth. As a result they obtain a fixed-parameter tractable algorithm for these problems, parameterized by a single parameter, treewidth, improving previous solutions that had combined multiple parameters.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>

<p>In computational topology,  extend Courcelle's theorem from MSO<sub>2</sub> to a form of monadic second-order logic on <a href="simplicial_complex" title="wikilink">simplicial complexes</a> of bounded dimension that allows quantification over simplices of any fixed dimension. As a consequence, they show how to compute certain <a href="quantum_invariants" title="wikilink">quantum invariants</a> of 3-<a href="manifold" title="wikilink">manifolds</a> as well as how to solve certain problems in <a href="discrete_Morse_theory" title="wikilink">discrete Morse theory</a> efficiently, when the manifold has a triangulation (avoiding degenerate simplices) whose <a href="dual_graph" title="wikilink">dual graph</a> has small treewidth.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>

<p>Methods based on Courcelle's theorem have also been applied to <a href="database_theory" title="wikilink">database theory</a>,<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> <a href="knowledge_representation_and_reasoning" title="wikilink">knowledge representation and reasoning</a>,<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> <a href="automata_theory" title="wikilink">automata theory</a>,<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> and <a href="model_checking" title="wikilink">model checking</a>.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a class="uri" href="Category:Metatheorems" title="wikilink">Category:Metatheorems</a> <a href="Category:Graph_algorithms" title="wikilink">Category:Graph algorithms</a> <a href="Category:Graph_minor_theory" title="wikilink">Category:Graph minor theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">.<a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3">.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">.<a href="#fnref5">↩</a></li>
<li id="fn6">.<a href="#fnref6">↩</a></li>
<li id="fn7">.<a href="#fnref7">↩</a></li>
<li id="fn8">.<a href="#fnref8">↩</a></li>
<li id="fn9">, [<a class="uri" href="http://books.google.com/books?id=JpIhAwAAQBAJ&amp;pg">http://books.google.com/books?id=JpIhAwAAQBAJ&amp;pg;</a>;=PA338 Proposition 5.13, p. 338].<a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11">.<a href="#fnref11">↩</a></li>
<li id="fn12"></li>
<li id="fn13">, Theorem 13.1.1, p. 266.<a href="#fnref13">↩</a></li>
<li id="fn14">, Section 10.5: Bodlaender's theorem, pp. 195–203.<a href="#fnref14">↩</a></li>
<li id="fn15">, Section 12.6: Tree automata, pp. 237–247.<a href="#fnref15">↩</a></li>
<li id="fn16">.<a href="#fnref16">↩</a></li>
<li id="fn17">.<a href="#fnref17">↩</a></li>
<li id="fn18">.<a href="#fnref18">↩</a></li>
<li id="fn19">.<a href="#fnref19">↩</a></li>
<li id="fn20">.<a href="#fnref20">↩</a></li>
<li id="fn21">. Short communication, <a href="International_Congress_of_Mathematicians" title="wikilink">International Congress of Mathematicians</a>, 2014.<a href="#fnref21">↩</a></li>
<li id="fn22">.<a href="#fnref22">↩</a></li>
<li id="fn23">.<a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25">.<a href="#fnref25">↩</a></li>
</ol>
</section>
</body>
</html>
