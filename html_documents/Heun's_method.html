<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1649">Heun's method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Heun's method</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a> and <a href="computational_science" title="wikilink">computational science</a>, <strong>Heun's method</strong> may refer to the <strong>improved</strong><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> or <strong>modified Euler's method</strong> (that is, the <strong>explicit trapezoidal rule</strong><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a>), or a similar two-stage <a href="Runge–Kutta_method" title="wikilink">Runge–Kutta method</a>. It is named after <a href="Karl_Heun" title="wikilink">Karl Heun</a> and is a <a href="numerical_analysis" title="wikilink">numerical</a> procedure for solving <a href="ordinary_differential_equation" title="wikilink">ordinary differential equations</a> (ODEs) with a given <a href="Initial_value_problem" title="wikilink">initial value</a>. Both variants can be seen as extensions of the <a href="Euler_method" title="wikilink">Euler method</a> into two-stage second-order Runge–Kutta methods.</p>

<p>The procedure for calculating the numerical solution to the initial value problem via the improved Euler's method is:</p>

<p>

<math display="block" id="Heun's_method:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msup>
       <mi>y</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <mrow>
        <mi>y</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="42.5pt">,</mo>
    <mrow>
     <mrow>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>y</mi>
      <mn>0</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>t</ci>
       <apply>
        <times></times>
        <ci>y</ci>
        <ci>t</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>y</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}(t)=f(t,y(t)),\qquad\qquad y(t_{0})=y_{0},
  </annotation>
 </semantics>
</math>

 by way of Heun's method, is to first calculate the intermediate value 

<math display="inline" id="Heun's_method:1">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>y</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-~</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{y}_{i+1}
  </annotation>
 </semantics>
</math>

 and then the final approximation 

<math display="inline" id="Heun's_method:2">
 <semantics>
  <msub>
   <mi>y</mi>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i+1}
  </annotation>
 </semantics>
</math>

 at the next integration point.</p>

<p>

<math display="block" id="Heun's_method:3">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>y</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi>h</mi>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>t</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-~</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>f</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{y}_{i+1}=y_{i}+hf(t_{i},y_{i})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Heun's_method:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
     <mo>+</mo>
     <mrow>
      <mfrac>
       <mi>h</mi>
       <mn>2</mn>
      </mfrac>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>t</mi>
           <mi>i</mi>
          </msub>
          <mo>,</mo>
          <msub>
           <mi>y</mi>
           <mi>i</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>t</mi>
           <mrow>
            <mi>i</mi>
            <mo>+</mo>
            <mn>1</mn>
           </mrow>
          </msub>
          <mo>,</mo>
          <msub>
           <mover accent="true">
            <mi>y</mi>
            <mo stretchy="false">~</mo>
           </mover>
           <mrow>
            <mi>i</mi>
            <mo>+</mo>
            <mn>1</mn>
           </mrow>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>h</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>f</ci>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>t</ci>
           <ci>i</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>i</ci>
          </apply>
         </interval>
        </apply>
        <apply>
         <times></times>
         <ci>f</ci>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>t</ci>
           <apply>
            <plus></plus>
            <ci>i</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <apply>
            <ci>normal-~</ci>
            <ci>y</ci>
           </apply>
           <apply>
            <plus></plus>
            <ci>i</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i+1}=y_{i}+\frac{h}{2}[f(t_{i},y_{i})+f(t_{i+1},\tilde{y}_{i+1})],
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Heun's_method:5">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 is the step size and 

<math display="inline" id="Heun's_method:6">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>t</mi>
     <mi>i</mi>
    </msub>
    <mo>+</mo>
    <mi>h</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>i</ci>
     </apply>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{i+1}=t_{i}+h
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="description">Description</h2>

<p>Euler’s method is used as the foundation for Heun’s method. Euler's method uses the line tangent to the function at the beginning of the interval as an estimate of the slope of the function over the interval, assuming that if the step size is small, the error will be small. However, even when extremely small step sizes are used, over a large number of steps the error starts to accumulate and the estimate diverges from the actual functional value.</p>

<p>Where the solution curve is concave up, its tangent line will underestimate the vertical coordinate of the next point and vice versa for a concave down solution. The ideal prediction line would hit the curve at its next predicted point. In reality, there is no way to know whether the solution is concave-up or concave-down, and hence if the next predicted point will overestimate or underestimate its vertical value. The concavity of the curve cannot be guaranteed to remain consistent either and the prediction may overestimate and underestimate at different points in the domain of the solution. Heun’s Method addresses this problem by considering the interval spanned by the tangent line segment as a whole. Taking a concave-up example, the left tangent prediction line underestimates the slope of the curve for the entire width of the interval from the current point to the next predicted point. If the tangent line at the right end point is considered (which can be estimated using Euler’s Method), it has the opposite problem <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The points along the tangent line of the left end point have vertical coordinates which all underestimate those that lie on the solution curve, including the right end point of the interval under consideration. The solution is to make the slope greater by some amount. Heun’s Method considers the tangent lines to the solution curve at <em>both</em> ends of the interval, one which <em>overestimates</em>, and one which <em>underestimates</em> the ideal vertical coordinates. A prediction line must be constructed based on the right end point tangent’s slope alone, approximated using Euler's Method. If this slope is passed through the left end point of the interval, the result is evidently too steep to be used as an ideal prediction line and overestimates the ideal point. Therefore, the ideal point lies approximately half way between the erroneous overestimation and underestimation, the average of the two slopes.  Euler’s Method is used to roughly estimate the coordinates of the next point in the solution, and with this knowledge, the original estimate is re-predicted or <em>corrected</em>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Assuming that the quantity 

<math display="inline" id="Heun's_method:7">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle f(x,y)
  </annotation>
 </semantics>
</math>

 on the right hand side of the equation can be thought of as the slope of the solution sought at any point 

<math display="inline" id="Heun's_method:8">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle(x,y)
  </annotation>
 </semantics>
</math>

, this can be combined with the Euler estimate of the next point to give the slope of the tangent line at the right end-point. Next the average of both slopes is used to find the corrected coordinates of the right end interval.</p>
<h2 id="derivation">Derivation</h2>

<p>

<math display="block" id="Heun's_method:9">
 <semantics>
  <mrow>
   <msub>
    <mtext>Slope</mtext>
    <mtext>left</mtext>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <mtext>Slope</mtext>
     <mtext>left</mtext>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\text{Slope}_{\text{left}}=f(x_{i},y_{i})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Heun's_method:10">
 <semantics>
  <mrow>
   <msub>
    <mtext>Slope</mtext>
    <mtext>right</mtext>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo>+</mo>
      <mi>h</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>y</mi>
       <mi>i</mi>
      </msub>
      <mo>+</mo>
      <mrow>
       <mi>h</mi>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>y</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <mtext>Slope</mtext>
     <mtext>right</mtext>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <ci>h</ci>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <times></times>
        <ci>h</ci>
        <ci>f</ci>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>i</ci>
         </apply>
        </interval>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\text{Slope}_{\text{right}}=f(x_{i}+h,y_{i}+hf(x_{i},y_{i}))
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Heun's_method:11">
 <semantics>
  <mrow>
   <msub>
    <mtext>Slope</mtext>
    <mtext>ideal</mtext>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mtext>Slope</mtext>
       <mtext>left</mtext>
      </msub>
      <mo>+</mo>
      <msub>
       <mtext>Slope</mtext>
       <mtext>right</mtext>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <mtext>Slope</mtext>
     <mtext>ideal</mtext>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>Slope</mtext>
       <mtext>left</mtext>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>Slope</mtext>
       <mtext>right</mtext>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\text{Slope}_{\text{ideal}}=(1/2)(\text{Slope}_{\text{left}}+\text{%
Slope}_{\text{right}})
  </annotation>
 </semantics>
</math>

</p>

<p>Using the principle that the slope of a line equates to the rise/run, the coordinates at the end of the interval can be found using the following formula:</p>

<p>

<math display="block" id="Heun's_method:12">
 <semantics>
  <mrow>
   <msub>
    <mtext>Slope</mtext>
    <mtext>ideal</mtext>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi mathvariant="normal">Δ</mi>
      <mi>y</mi>
     </mrow>
     <mo>/</mo>
     <mi>h</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <mtext>Slope</mtext>
     <mtext>ideal</mtext>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>y</ci>
     </apply>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\text{Slope}_{\text{ideal}}=(\Delta y/h)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Heun's_method:13">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mtext>Slope</mtext>
      <mtext>ideal</mtext>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>h</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>Slope</mtext>
      <mtext>ideal</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle\Delta y=h(\text{Slope}_{\text{ideal}})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Heun's_method:14">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mo>+</mo>
    <mi>h</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle x_{i+1}=x_{i}+h
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Heun's_method:15">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>y</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle y_{i+1}=y_{i}+\Delta y
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Heun's_method:16">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi>h</mi>
     <msub>
      <mtext>Slope</mtext>
      <mtext>ideal</mtext>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>Slope</mtext>
       <mtext>ideal</mtext>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textstyle y_{i+1}=y_{i}+h\text{Slope}_{\text{ideal}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Heun's_method:17">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mtext>Slope</mtext>
        <mtext>left</mtext>
       </msub>
       <mo>+</mo>
       <msub>
        <mtext>Slope</mtext>
        <mtext>right</mtext>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <ci>h</ci>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <mtext>Slope</mtext>
        <mtext>left</mtext>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <mtext>Slope</mtext>
        <mtext>right</mtext>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i+1}=y_{i}+\frac{1}{2}h(\text{Slope}_{\text{left}}+\text{Slope}_{\text{%
right}})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Heun's_method:18">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mi>h</mi>
      <mn>2</mn>
     </mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>y</mi>
          <mi>i</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msub>
           <mi>x</mi>
           <mi>i</mi>
          </msub>
          <mo>+</mo>
          <mi>h</mi>
         </mrow>
         <mo>,</mo>
         <mrow>
          <msub>
           <mi>y</mi>
           <mi>i</mi>
          </msub>
          <mo>+</mo>
          <mrow>
           <mi>h</mi>
           <mi>f</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <msub>
             <mi>x</mi>
             <mi>i</mi>
            </msub>
            <mo>,</mo>
            <msub>
             <mi>y</mi>
             <mi>i</mi>
            </msub>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>h</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>f</ci>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>i</ci>
         </apply>
        </interval>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <interval closure="open">
         <apply>
          <plus></plus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>i</ci>
          </apply>
          <ci>h</ci>
         </apply>
         <apply>
          <plus></plus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>i</ci>
          </apply>
          <apply>
           <times></times>
           <ci>h</ci>
           <ci>f</ci>
           <interval closure="open">
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <ci>i</ci>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>y</ci>
             <ci>i</ci>
            </apply>
           </interval>
          </apply>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i+1}=y_{i}+\frac{h}{2}(f(x_{i},y_{i})+f(x_{i}+h,y_{i}+hf(x_{i},y_{i})))
  </annotation>
 </semantics>
</math>

</p>

<p>The accuracy of the Euler method improves only linearly with the step size is decreased, whereas the Heun Method improves accuracy quadratically .<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The scheme can be compared with the <a href="Explicit_and_implicit_methods" title="wikilink">implicit</a> <a href="trapezoidal_method" title="wikilink">trapezoidal method</a>, but with 

<math display="inline" id="Heun's_method:19">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>t</mi>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(t_{i+1},y_{i+1})
  </annotation>
 </semantics>
</math>

 replaced by 

<math display="inline" id="Heun's_method:20">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>t</mi>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>,</mo>
    <msub>
     <mover accent="true">
      <mi>y</mi>
      <mo stretchy="false">~</mo>
     </mover>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-~</ci>
       <ci>y</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(t_{i+1},\tilde{y}_{i+1})
  </annotation>
 </semantics>
</math>

 in order to make it explicit. 

<math display="inline" id="Heun's_method:21">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>y</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-~</ci>
     <ci>y</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{y}_{i+1}
  </annotation>
 </semantics>
</math>

 is the result of one step of <a href="Euler's_method" title="wikilink">Euler's method</a> on the same initial value problem. So, Heun's method is a <a href="predictor-corrector_method" title="wikilink">predictor-corrector method</a> with forward <a href="Euler's_method" title="wikilink">Euler's method</a> as predictor and <a href="trapezoidal_method" title="wikilink">trapezoidal method</a> as corrector.</p>
<h2 id="rungekutta-method">Runge–Kutta method</h2>

<p>The improved Euler's method is a two-stage <a href="Runge–Kutta_method" title="wikilink">Runge–Kutta method</a>, and can be written using the <a href="Butcher_tableau" title="wikilink">Butcher tableau</a> (after <a href="John_C._Butcher" title="wikilink">John C. Butcher</a>):</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>

<p>The other method referred to as Heun's method (also known as Ralston's method) has the Butcher table:<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>2/3</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>

<p>This method minimizes the truncation error.</p>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Numerical_differential_equations" title="wikilink">Category:Numerical differential equations</a> <a href="Category:Runge–Kutta_methods" title="wikilink">Category:Runge–Kutta methods</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">.<a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4">.<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6">.<a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
