<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="974">Stress majorization</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Stress majorization</h1>
<hr/>

<p><strong>Stress majorization</strong> is an <a href="optimization_(mathematics)" title="wikilink">optimization strategy</a> used in <a href="multidimensional_scaling" title="wikilink">multidimensional scaling</a> (MDS) where, for a set of <em>n</em> <em>m</em>-dimensional data items, a configuration <em>X</em> of <em>n</em> points in ''r(\sigma(X)</p>

<p>. Usually <em>r</em> is 2 or 3, i.e. the <em>(r</em> x <em>n)</em> matrix <em>X</em> lists points in 2- or 3-dimensional <a href="Euclidean_space" title="wikilink">Euclidean space</a> so that the result may be visualised (i.e. an MDS plot). The function 

<math display="inline" id="Stress_majorization:0">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 is a cost or <a href="loss_function" title="wikilink">loss function</a> that measures the squared differences between ideal (

<math display="inline" id="Stress_majorization:1">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

-dimensional) distances and actual distances in <em>r</em>-dimensional space. It is defined as:</p>

<p>

<math display="inline" id="Stress_majorization:2">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>i</mi>
   <mo>,</mo>
   <mi>j</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>i</ci>
    <ci>j</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (i,j)
  </annotation>
 </semantics>
</math>

 is a weight for the measurement between a pair of points 

<math display="inline" id="Stress_majorization:3">
 <semantics>
  <mrow>
   <msub>
    <mi>d</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{ij}(X)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Stress_majorization:4">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 is the <a href="euclidean_distance" title="wikilink">euclidean distance</a> between 

<math display="inline" id="Stress_majorization:5">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Stress_majorization:6">
 <semantics>
  <msub>
   <mi>δ</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>δ</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{ij}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Stress_majorization:7">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 is the ideal distance between the points (their separation) in the 

<math display="inline" id="Stress_majorization:8">
 <semantics>
  <msub>
   <mi>w</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{ij}
  </annotation>
 </semantics>
</math>

-dimensional data space. Note that 

<math display="inline" id="Stress_majorization:9">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 can be used to specify a degree of confidence in the similarity between points (e.g. 0 can be specified if there is no information for a particular pair).</p>

<p>A configuration 

<math display="inline" id="Stress_majorization:10">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>σ</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(X)
  </annotation>
 </semantics>
</math>

 which minimizes 

<math display="inline" id="Stress_majorization:11">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 gives a plot in which points that are close together correspond to points that are also close together in the original 

<math display="inline" id="Stress_majorization:12">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>σ</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(X)
  </annotation>
 </semantics>
</math>

-dimensional data space.</p>

<p>There are many ways that 

<math display="inline" id="Stress_majorization:13">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 could be minimized. For example, Kruskal<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> recommended an iterative <a href="steepest_descent" title="wikilink">steepest descent</a> approach. However, a significantly better (in terms of guarantees on, and rate of, convergence) method for minimizing stress was introduced by <a href="Jan_de_Leeuw" title="wikilink">Jan de Leeuw</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> De Leeuw's <em>iterative majorization</em> method at each step minimizes a simple convex function which both bounds 

<math display="inline" id="Stress_majorization:14">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 from above and touches the surface of 

<math display="inline" id="Stress_majorization:15">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

 at a point 

<math display="inline" id="Stress_majorization:16">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

, called the <em>supporting point</em>. In <a href="convex_analysis" title="wikilink">convex analysis</a> such a function is called a <em>majorizing</em> function. This iterative majorization process is also referred to as the SMACOF algorithm ("Scaling by majorizing a convex function").</p>
<h2 id="the-smacof-algorithm">The SMACOF algorithm</h2>

<p>The stress function 

<math display="inline" id="Stress_majorization:17">
 <semantics>
  <mrow>
   <msup>
    <mi>X</mi>
    <mo>′</mo>
   </msup>
   <mi>V</mi>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>V</ci>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{\prime}VX
  </annotation>
 </semantics>
</math>

 can be expanded as follows:</p>

<p>

<math display="block" id="Stress_majorization:18">
 <semantics>
  <mrow>
   <msub>
    <mi>b</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <msub>
       <mi>w</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <msub>
       <mi>δ</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
     </mrow>
     <mrow>
      <msub>
       <mi>d</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Z</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>δ</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>d</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>Z</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{ij}=-\frac{w_{ij}\delta_{ij}}{d_{ij}(Z)}
  </annotation>
 </semantics>
</math>

 and the second term is quadratic in X (i.e. for the <a href="Hessian_matrix" title="wikilink">Hessian matrix</a> V the second term is equivalent to <a href="Matrix_trace" title="wikilink">tr</a>

<math display="inline" id="Stress_majorization:19">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>d</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≠</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>i</mi>
    <mo>≠</mo>
    <mi>j</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <neq></neq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <ci>Z</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <neq></neq>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{ij}(Z)\neq 0,i\neq j
  </annotation>
 </semantics>
</math>

) and therefore relatively easily solved. The third term is bounded by:</p>

<p>

<math display="inline" id="Stress_majorization:20">
 <semantics>
  <mrow>
   <msub>
    <mi>b</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{ij}=0
  </annotation>
 </semantics>
</math>

 has:</p>

<p>

<math display="inline" id="Stress_majorization:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>d</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>i</mi>
    <mo>≠</mo>
    <mi>j</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <ci>Z</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <neq></neq>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{ij}(Z)=0,i\neq j
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Stress_majorization:22">
 <semantics>
  <mrow>
   <msub>
    <mi>b</mi>
    <mrow>
     <mi>i</mi>
     <mi>i</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mrow>
        <mi>j</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>j</mi>
        <mo>≠</mo>
        <mi>i</mi>
       </mrow>
      </mrow>
      <mi>n</mi>
     </msubsup>
     <msub>
      <mi>b</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <csymbol cd="ambiguous">formulae-sequence</csymbol>
         <apply>
          <eq></eq>
          <ci>j</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <neq></neq>
          <ci>j</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{ii}=-\sum_{j=1,j\neq i}^{n}b_{ij}
  </annotation>
 </semantics>
</math>

</p>

<p>and 

<math display="inline" id="Stress_majorization:23">
 <semantics>
  <mrow>
   <mi>τ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>X</mi>
    <mo>,</mo>
    <mi>Z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>τ</ci>
    <interval closure="open">
     <ci>X</ci>
     <ci>Z</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau(X,Z)
  </annotation>
 </semantics>
</math>

 for 

<math display="block" id="Stress_majorization:24">
 <semantics>
  <mrow>
   <mrow>
    <mi>σ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>C</mi>
     <mo rspace="4.2pt">+</mo>
     <mrow>
      <mo rspace="4.2pt">tr</mo>
      <mrow>
       <msup>
        <mi>X</mi>
        <mo>′</mo>
       </msup>
       <mi>V</mi>
       <mi>X</mi>
      </mrow>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mn>2</mn>
     </mpadded>
     <mrow>
      <mo rspace="4.2pt">tr</mo>
      <mrow>
       <msup>
        <mi>X</mi>
        <mo>′</mo>
       </msup>
       <mi>B</mi>
      </mrow>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>X</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>σ</ci>
     <ci>X</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <ci>C</ci>
      <apply>
       <ci>tr</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>X</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>V</ci>
        <ci>X</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <ci>tr</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>X</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>B</ci>
       </apply>
      </apply>
      <ci>X</ci>
      <ci>X</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(X)=C+\,\operatorname{tr}\,X^{\prime}VX-2\,\operatorname{tr}\,X^{\prime}%
B(X)X
  </annotation>
 </semantics>
</math>

</p>

<p>and 

<math display="block" id="Stress_majorization:25">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mi>C</mi>
     <mo rspace="4.2pt">+</mo>
     <mrow>
      <mo rspace="4.2pt">tr</mo>
      <mrow>
       <msup>
        <mi>X</mi>
        <mo>′</mo>
       </msup>
       <mi>V</mi>
       <mi>X</mi>
      </mrow>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mpadded width="+1.7pt">
      <mn>2</mn>
     </mpadded>
     <mrow>
      <mo rspace="4.2pt">tr</mo>
      <mrow>
       <msup>
        <mi>X</mi>
        <mo>′</mo>
       </msup>
       <mi>B</mi>
      </mrow>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>Z</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>τ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mi>Z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <ci>C</ci>
       <apply>
        <ci>tr</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>X</ci>
          <ci>normal-′</ci>
         </apply>
         <ci>V</ci>
         <ci>X</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <ci>tr</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>X</ci>
          <ci>normal-′</ci>
         </apply>
         <ci>B</ci>
        </apply>
       </apply>
       <ci>Z</ci>
       <ci>Z</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>τ</ci>
      <interval closure="open">
       <ci>X</ci>
       <ci>Z</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq C+\,\operatorname{tr}\,X^{\prime}VX-2\,\operatorname{tr}\,X^{\prime}B(Z)Z%
=\tau(X,Z)
  </annotation>
 </semantics>
</math>

.</p>

<p>Proof of this inequality is by the <a class="uri" href="Cauchy-Schwarz" title="wikilink">Cauchy-Schwarz</a> inequality, see Borg<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> (pp. 152–153).</p>

<p>Thus, we have a simple quadratic function 

<math display="inline" id="Stress_majorization:26">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>←</mo>
   <msup>
    <mi>X</mi>
    <mrow>
     <mi>k</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <ci>Z</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <apply>
      <minus></minus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z\leftarrow X^{k-1}
  </annotation>
 </semantics>
</math>

 that majorizes stress:</p>

<p>

<math display="inline" id="Stress_majorization:27">
 <semantics>
  <mrow>
   <msup>
    <mi>X</mi>
    <mi>k</mi>
   </msup>
   <mo>←</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>min</mi>
      <mi>X</mi>
     </msub>
     <mi>τ</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>,</mo>
     <mi>Z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>X</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <min></min>
       <ci>X</ci>
      </apply>
      <ci>τ</ci>
     </apply>
     <interval closure="open">
      <ci>X</ci>
      <ci>Z</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{k}\leftarrow\min_{X}\tau(X,Z)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Stress_majorization:28">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>σ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>X</mi>
       <mrow>
        <mi>k</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>σ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>X</mi>
       <mi>k</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo><</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>σ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>X</ci>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>σ</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>X</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma(X^{k-1})-\sigma(X^{k})<\epsilon
  </annotation>
 </semantics>
</math>

</p>

<p>The iterative minimization procedure is then:</p>
<ul>
<li>at the k<sup>th</sup> step we set 

<math display="inline" id="Stress_majorization:29">
 <semantics>
  <msub>
   <mi>δ</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>δ</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{ij}
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Stress_majorization:30">
 <semantics>
  <msub>
   <mi>w</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{ij}
  </annotation>
 </semantics>
</math>

</li>
<li>stop if 

<math display="inline" id="Stress_majorization:31">
 <semantics>
  <msubsup>
   <mi>δ</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
   <mrow>
    <mo>-</mo>
    <mi>α</mi>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>δ</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta_{ij}^{-\alpha}
  </annotation>
 </semantics>
</math>

 otherwise repeat.</li>
</ul>

<p>This algorithm has been shown to decrease stress monotonically (see de Leeuw<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a>).</p>
<h2 id="use-in-graph-drawing">Use in graph drawing</h2>

<p>Stress majorization and algorithms similar to SMACOF also have application in the field of <a href="graph_drawing" title="wikilink">graph drawing</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> That is, one can find a reasonably aesthetically appealing layout for a network or graph by minimizing a stress function over the positions of the nodes in the graph. In this case, the 

<math display="inline" id="Stress_majorization:32">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 are usually set to the graph-theoretic distances between nodes <em>i</em> and <em>j</em> and the weights 

<math display="inline" id="Stress_majorization:33">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>α</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha=2
  </annotation>
 </semantics>
</math>

 are taken to be <span class="LaTeX">$\delta_{ij}^{-\alpha}$</span>. Here, <span class="LaTeX">$\alpha$</span> is chosen as a trade-off between preserving long- or short-range ideal distances. Good results have been shown for <span class="LaTeX">$\alpha=2$</span>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Graph_drawing" title="wikilink">Category:Graph drawing</a> <a href="Category:Multivariate_statistics" title="wikilink">Category:Multivariate statistics</a> <a href="Category:Mathematical_optimization" title="wikilink">Category:Mathematical optimization</a> <a href="Category:Mathematical_analysis" title="wikilink">Category:Mathematical analysis</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">.<a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3">.<a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5">.<a href="#fnref5">↩</a></li>
<li id="fn6">.<a href="#fnref6">↩</a></li>
<li id="fn7">.<a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
