<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1679">Covariance and contravariance (computer science)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Covariance and contravariance (computer science)</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>Many <a href="programming_language" title="wikilink">programming language</a> <a href="type_system" title="wikilink">type systems</a> support <a class="uri" href="subtyping" title="wikilink">subtyping</a>. For instance, if  is subtype of , then an expression of type  can be used whenever an expression of type  could. <strong>Variance</strong> refers to how subtyping between more complex types (list of s versus list of s, function returning  versus function returning , ...) relates to subtyping between their components. Depending on the variance of the <a href="type_constructor" title="wikilink">type constructor</a>, the subtyping relation may be either preserved, reversed, or ignored. For example, in <a href="C_Sharp_(programming_language)" title="wikilink">C#</a>:</p>
<ul>
<li><mtpl></mtpl> is a subtype of <mtpl></mtpl>. The subtyping is preserved because <mtpl></mtpl> is <strong>covariant</strong> on .</li>
<li><mtpl></mtpl> is a subtype of <mtpl></mtpl>. The subtyping is reversed because <mtpl></mtpl> is <strong>contravariant</strong> on .</li>
<li>Neither <mtpl></mtpl> nor <mtpl></mtpl> is a subtype of the other, because <mtpl></mtpl> is <strong>invariant</strong> on .</li>
</ul>

<p>The variance of a C# interface is determined by / annotations on its type parameters; the above interfaces are declared as <mtpl></mtpl>, <mtpl></mtpl>, and <mtpl></mtpl>. Types with more than one type parameter may specify different variances on each type parameter. For example, the delegate type <mtpl></mtpl> represents a function with a <strong>contravariant</strong> input parameter of type  and a <strong>covariant</strong> return value of type .<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The <a href="#Interfaces" title="wikilink">typing rules for interface variance</a> ensure type safety. For example, an <mtpl></mtpl> represents a first-class function expecting an argument of type , and a function which can handle any type of animal can always be used instead of one which can only handle cats.</p>

<p>A programming language designer will consider variance when devising typing rules for e.g. arrays, inheritance, and generic datatypes. By making type constructors covariant or contravariant instead of invariant, more programs will be accepted as well-typed. On the other hand, programmers often find contravariance unintuitive, and accurately tracking variance to avoid runtime type errors can lead to complex typing rules. In order to keep the type system simple and allow useful programs, a language may treat a type constructor as invariant even if it would be safe to consider it variant, or treat it as covariant even when that can violate type safety.</p>
<h2 id="formal-definition">Formal definition</h2>

<p>Within the <a href="type_system" title="wikilink">type system</a> of a <a href="programming_language" title="wikilink">programming language</a>, a typing rule or a type constructor is:</p>
<ul>
<li><strong>covariant</strong> if it preserves the <a href="subtype" title="wikilink">ordering of types (≤)</a>, which orders types from more specific to more generic;</li>
<li><strong>contravariant</strong> if it reverses this ordering;</li>
<li><strong>bivariant</strong> if both of these apply (i.e., both <mtpl></mtpl> ≤ <mtpl></mtpl> and <mtpl></mtpl> ≤ <mtpl></mtpl> at the same time);</li>
<li><strong>invariant</strong> or <strong>nonvariant</strong> if neither of these applies.</li>
</ul>

<p>In the rest of the article, we will consider how this applies to some common type constructors.</p>
<h2 id="arrays">Arrays</h2>

<p>First consider the <a href="array_data_type" title="wikilink">array type</a> constructor: from the type  we can make the type  ("array of animals"). Should we treat this as</p>
<ul>
<li>Covariant: a  is an </li>
<li>Contravariant: an  is a </li>
<li>Invariant: an  is not a  and a  is not an </li>
</ul>

<p>If we wish to avoid type errors, and the array supports both reading and writing elements, then only the third choice is safe. Clearly, not every  can be treated as if it were a , since a client reading from the array will expect a , but an  may contain e.g. a . So the contravariant rule is not safe.</p>

<p>Conversely, a  can not be treated as an . It should always be possible to put a  into an . With covariant arrays this can not be guaranteed to be safe, since the backing store might actually be an array of cats. So the covariant rule is also not safe—the array constructor should be <strong>invariant</strong>. Note that this is only an issue for mutable arrays; the covariant rule is safe for immutable (read-only) arrays.</p>

<p>This illustrates a general phenomenon. Read-only data types (sources) can be covariant; write-only data types (sinks) can be contravariant. Mutable data types which act as both sources and sinks should be invariant.</p>
<h3 id="covariant-arrays-in-java-and-c">Covariant arrays in Java and C#</h3>

<p>Early versions of Java and C# did not include generics (a.k.a. <a href="parametric_polymorphism" title="wikilink">parametric polymorphism</a>). In such a setting, making arrays invariant rules out useful polymorphic programs.</p>

<p>For example, consider writing a function to shuffle an array, or a function that tests two arrays for equality using the . method on the elements. The implementation does not depend on the exact type of element stored in the array, so it should be possible to write a single function that works on all types of arrays. It is easy to implement functions of type</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    <span class="dt">boolean</span> <span class="fu">equalArrays</span>(Object[] a1, Object[] a2);
    <span class="dt">void</span> <span class="fu">shuffleArray</span>(Object[] a);</code></pre></div>

<p>However, if array types were treated as invariant, it would only be possible to call these functions on an array of exactly the type . One could not, for example, shuffle an array of strings.</p>

<p>Therefore, both Java and C# treat array types covariantly. For instance, in C#  is a subtype of , and in Java  is a subtype of .</p>

<p>As discussed above, covariant arrays lead to problems with writes into the array. Java and C# deal with this by marking each array object with a type when it is created. Each time a value is stored into an array, the execution environment will check that the run-time type of the value is equal to the run-time type of the array. If there is a mismatch, an  (Java) or  (C#) is thrown:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    <span class="co">// a is a single-element array of String</span>
    String[] a = <span class="kw">new</span> String[<span class="dv">1</span>];

    <span class="co">// b is an array of Object</span>
    Object[] b = a;

    <span class="co">// Assign an Integer to b. This would be possible if b really were</span>
    <span class="co">// an array of Object, but since it really is an array of String,</span>
    <span class="co">// we will get a java.lang.ArrayStoreException.</span>
    b[<span class="dv">0</span>] = <span class="dv">1</span>;</code></pre></div>

<p>In the above example you can <strong>read</strong> from b safely. It is only trying to <strong>write</strong> to the array that can lead to trouble.</p>

<p>One drawback of this approach is that it leaves the possibility of a run-time error which a stricter type system could have caught at compile-time. Also, it hurts performance because each write into an array requires an additional runtime check.</p>

<p>With the addition of generics, Java and C# now offer ways to write this kind of polymorphic functions without relying on covariance. The array comparison and shuffling functions can be given the parameterized types</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><t> <span class="dt">boolean</span> <span class="fu">equalArrays</span>(T[] a1, T[] a2);
    <t> <span class="dt">void</span> <span class="fu">shuffleArray</span>(T[] a);
</t></t></code></pre></div>

<p>Alternatively, to enforce that a C# method accesses a collection in a read-only way, one can use the interface <mtpl></mtpl> instead of passing it an array .</p>
<h2 id="function-types">Function types</h2>

<p>Languages with <a href="first-class_functions" title="wikilink">first-class functions</a> have <a href="function_type" title="wikilink">function types</a> like "a function expecting a Cat and returning an Animal" (written  in <a class="uri" href="OCaml" title="wikilink">OCaml</a> syntax or <mtpl></mtpl> in <a href="C_Sharp_(programming_language)" title="wikilink">C#</a> syntax).</p>

<p>Those languages also need to specify when one function type is a subtype of another—that is, when it is safe to use a function of one type in a context that expects a function of a different type. It is safe to substitute a function <em>f</em> instead of a function <em>g</em> if <em>f</em> accepts a more general type of arguments and returns a more specific type than <em>g</em>. For example, a function of type  can safely be used wherever a  was expected, and likewise a function of type  can be used wherever a  was expected. (One can compare this to the <a href="robustness_principle" title="wikilink">robustness principle</a> of communication: "be liberal in what you accept and conservative in what you produce"). The general rule is</p>
<blockquote>

<p>S<sub>1</sub> → S<sub>2</sub> ≤ T<sub>1</sub> → T<sub>2</sub> if T<sub>1</sub> ≤ S<sub>1</sub> and S<sub>2</sub> ≤ T<sub>2</sub>.</p>
</blockquote>

<p>In other words, the → type constructor is <strong>contravariant in the input type</strong> and <strong>covariant in the output type</strong>. This rule was first stated formally by <a href="John_C._Reynolds" title="wikilink">John Reynolds</a>,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and further popularized in a paper by Luca Cardelli.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>When dealing with <a href="higher-order_function" title="wikilink">functions that take functions as arguments</a>, this rule can be applied several times. For example, by applying the rule twice, we see that (A'→B)→B ≤ (A→B)→B if A'≤A. In other words, the type (A→B)→B is <em>covariant</em> in the A position. For complicated types it can be confusing to mentally trace why a given type specialization is or isn't type-safe, but it is easy to calculate which positions are co- and contravariant: a position is covariant if it is on the left side of an even number of arrows.</p>
<h2 id="inheritance-in-object-oriented-languages">Inheritance in object oriented languages</h2>

<p>When a subclass <a href="Method_overriding" title="wikilink">overrides</a> a method in a superclass, the compiler must check that the overriding method has the right type. While some languages require that the type exactly matches the type in the superclass (invariance), it is also type safe to allow the overriding method to have a "better" type. By the usual subtyping rule for function types, this means that the overriding method should return a more specific type (return type covariance), and accept a more general argument (argument type contravariance). In <a href="Unified_Modeling_Language" title="wikilink">UML</a> notation, the possibilities are as follows:</p>

<p>Image:Vererbung T.svg|Subtyping of the argument/return type of the method. Image:Inheritance_invariant.svg|<strong>Invariance</strong>. The signature of the overrriding method is unchanged. Image:Inheritance_covariant_return.svg|<strong>Covariant return type</strong>. The subtyping relation is in the same direction as the relation between ClassA and ClassB. Image:Inheritance_contravariant_argument.svg|<strong>Contravariant argument type</strong>. The subtyping relation is in the opposite direction to the relation between ClassA and ClassB. Image:Inheritance_covariant_argument.svg|<strong>Covariant argument type</strong>. Not type safe.</p>

<p>For a concrete example, suppose we are writing a class to model an <a href="animal_shelter" title="wikilink">animal shelter</a>. We assume that  is a subclass of , and that we have a base class (using Java syntax)</p>
<figure><b>(Figure)</b>
<figcaption>AnimalShelter.svg</figcaption>
</figure>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    <span class="kw">class</span> AnimalShelter {
        Animal <span class="fu">getAnimalForAdoption</span>() {
          ...
        }
    
        <span class="dt">void</span> <span class="fu">putAnimal</span>(Animal animal) {
          ...
        }
    }</code></pre></div>

<p>Now the question is: if we subclass , what types are we allowed to give to  and ?</p>
<h3 id="covariant-method-return-type">Covariant method return type</h3>

<p>In a language which allows covariant return types, a derived class can override the  method to return a more specific type:</p>
<figure><b>(Figure)</b>
<figcaption>Inheritance covariant return animalshelter.svg</figcaption>
</figure>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    <span class="kw">class</span> CatShelter <span class="kw">extends</span> AnimalShelter {
        Cat <span class="fu">getAnimalForAdoption</span>() {
            <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Cat</span>();
        }
    }</code></pre></div>

<p>Among mainstream OO languages, <a href="Java_(Programming_language)" title="wikilink">Java</a> and <a class="uri" href="C++" title="wikilink">C++</a> support covariant return types, while <a href="C_Sharp_(programming_language)" title="wikilink">C#</a> does not. Adding the covariant return type was one of the first modifications of the C++ language approved by the standards committee in 1998.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> <a href="Scala_(programming_language)" title="wikilink">Scala</a> and <a href="D_(programming_language)" title="wikilink">D</a> also support covariant return types.</p>
<h3 id="contravariant-method-argument-type">Contravariant method argument type</h3>

<p>Similarly, it is type safe to allow an overriding method to accept a more general argument than the method in the base class:</p>
<figure><b>(Figure)</b>
<figcaption>Inheritance contravariant argument animalshelter.svg</figcaption>
</figure>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    <span class="kw">class</span> CatShelter <span class="kw">extends</span> AnimalShelter {
        <span class="dt">void</span> <span class="fu">putAnimal</span>(Object animal) {
           ...
        }
    }</code></pre></div>

<p>Not many object oriented languages actually allow this—C++ and Java would interpret this as an unrelated method with an <a href="Function_overloading" title="wikilink">overloaded</a> name.</p>

<p>However, <a class="uri" href="Sather" title="wikilink">Sather</a> supports both covariance and contravariance. Calling convention for overridden methods are covariant with <em>out</em> arguments and return values, and contravariant with normal arguments (with the mode <em>in</em>).</p>
<h3 id="covariant-method-argument-type">Covariant method argument type</h3>

<p>Uniquely among mainstream languages, <a href="Eiffel_(programming_language)" title="wikilink">Eiffel</a> allows the arguments of an overriding method to have a <em>more</em> specific type than the method in the superclass (argument type covariance). Thus, the Eiffel version of the following code would type check, with  overriding the method in the base class:</p>
<figure><b>(Figure)</b>
<figcaption>Inheritance covariant argument animalshelter.svg</figcaption>
</figure>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    <span class="kw">class</span> CatShelter <span class="kw">extends</span> AnimalShelter {
        <span class="dt">void</span> <span class="fu">putAnimal</span>(Cat animal) {
           ...
        }
    }</code></pre></div>

<p>This is not type safe. By up-casting a  to an , one can place a dog in a cat shelter. The lack of type safety (known as the "catcall problem" in the Eiffel community) has been a long-standing issue. Over the years, various combinations of global static analysis, local static analysis, and new language features have been proposed to remedy it,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> and these have been implemented in some Eiffel compilers.</p>

<p>Despite the type safety problem, the Eiffel designers consider covariant argument types crucial for modeling real world requirements.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> The cat shelter illustrates a common phenomenon: it is <em>a kind of</em> animal shelter but has <em>additional restrictions</em>, and it seems reasonable to use inheritance and restricted argument types to model this. In proposing this use of inheritance, the Eiffel designers reject the <a href="Liskov_substitution_principle" title="wikilink">Liskov substitution principle</a>, which states that objects of subclasses should always be less restricted than objects of their superclass.</p>

<p>Another example where covariant arguments seem helpful is so-called binary methods, i.e. methods where the argument is expected to be of the same type as the object the method is called on. An example is the  method:  checks whether  comes before or after  in some ordering, but the way to compare, say, two rational numbers will be different from the way to compare two strings. Other common examples of binary methods include equality tests, arithmetic operations, and set operations like subset and union.</p>

<p>In older versions of Java, the comparison method was specified as an interface :</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    <span class="kw">interface</span> Comparable {
        <span class="dt">int</span> <span class="fu">compareTo</span>(Object o);
    }</code></pre></div>

<p>The drawback of this is that the method is specified to take an argument of type . A typical implementation would first down-cast this argument (throwing an error if it is not of the expected type):</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    <span class="kw">class</span> RationalNumber <span class="kw">implements</span> Comparable {
        <span class="dt">int</span> numerator;
        <span class="dt">int</span> denominator;
    
        ...
        
        <span class="kw">public</span> <span class="dt">int</span> <span class="fu">compareTo</span>(Object other) {
            RationalNumber otherNum = (RationalNumber)other;
            <span class="kw">return</span> Integer.<span class="fu">compare</span>(numerator*otherNum.<span class="fu">denominator</span>,
                                   otherNum.<span class="fu">numerator</span>*denominator);
        }
    }</code></pre></div>

<p>In a language with covariant arguments, the argument to compareTo could be directly given the desired type , hiding the typecast. (Of course, this would still give a runtime error if  was then called on e.g. a ).</p>
<h3 id="avoiding-the-need-for-covariant-argument-types">Avoiding the need for covariant argument types</h3>

<p>Other language features can provide the apparent benefits of covariant arguments while preserving Liskov substitutability.</p>

<p>In a language with <strong>generics</strong> (a.k.a. <a href="parametric_polymorphism" title="wikilink">parametric polymorphism</a>) and <a href="bounded_quantification" title="wikilink">bounded quantification</a>, the previous examples can be written in a type-safe way .<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Instead of defining , we define a parameterized class <mtpl></mtpl>. (One drawback of this is that the implementer of the base class needs to foresee which types will need to be specialized in the subclasses).</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    <span class="kw">class</span> Shelter<t animal="&lt;span" class="st">""</t></code></pre></div></body> <span class="kw">extends</span>=<span class="st">""</span>&gt; {
        T <span class="fu">getAnimalForAdoption</span>() {
          ...
        }
    
        <span class="dt">void</span> <span class="fu">putAnimal</span>(T animal) {
          ...
        }
    }
    
    
    <span class="kw">class</span> CatShelter <span class="kw">extends</span> Shelter<cat> {
        Cat <span class="fu">getAnimalForAdoption</span>() {
          ...
        }
    
        <span class="dt">void</span> <span class="fu">putAnimal</span>(Cat animal) {
          ...
        }
    }
</cat>

<p>Similarly, in recent versions of Java the  interface has been parameterized, which allows the downcast to be omitted in a type-safe way:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    <span class="kw">class</span> RationalNumber <span class="kw">implements</span> Comparable<rationalnumber> {
        <span class="dt">int</span> numerator;
        <span class="dt">int</span> denominator;
      
        ...
         
        <span class="kw">public</span> <span class="dt">int</span> <span class="fu">compareTo</span>(RationalNumber otherNum) {
            <span class="kw">return</span> Integer.<span class="fu">compare</span>(numerator*otherNum.<span class="fu">denominator</span>, 
                                   otherNum.<span class="fu">numerator</span>*denominator);
        }
    }
</rationalnumber></code></pre></div>

<p>Another language feature that can help is <strong>multiple dispatch</strong>. One reason that binary methods are awkward to write is that in a call like , selecting the correct implementation of  really depends on the type of both  and , but in a conventional OO language only the type of  is taken into account. In a language with <a href="Common_Lisp_Object_System" title="wikilink">CLOS</a>-style <a href="multiple_dispatch" title="wikilink">multiple dispatch</a>, the comparison method could be written as a generic function where both arguments are used for method selection.</p>

<p>Giuseppe Castagna<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> observed that in a typed language with multiple dispatch, a generic function can have some arguments which control dispatch and some "left-over" arguments which do not. Because the method selection rule chooses the most specific applicable method, if a method overrides another method, then the overriding method will have more specific types for the controlling arguments. On the other hand, to ensure type safety the language still must require the left-over arguments to be at least as general. Using the previous terminology, types used for runtime method selection are covariant while types not used for runtime method selection of the method are contravariant. Conventional single-dispatch languages like Java also obey this rule: there only one argument is used for method selection (the receiver object, passed along to a method as the hidden argument ), and indeed the type of  is more specialized inside overriding methods than in the superclass.</p>

<p>Castagna suggests that examples where you want covariant argument types, in particular binary methods, should be handled using multiple dispatch which is naturally covariant. Unfortunately, most programming languages do not support multiple dispatch.</p>
<h3 id="summary-of-variance-and-inheritance">Summary of variance and inheritance</h3>

<p>The following table summarizes the rules for overriding methods in the languages discussed above.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">
<p>Argument type</p></th>
<th style="text-align: left;">
<p>Return type</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="C++_(programming_language)" title="wikilink">C++</a> (since 1998), <a href="Java_(programming_language)" title="wikilink">Java</a> (since <a href="Java_Platform,_Standard_Edition" title="wikilink">J2SE 5.0</a>), <a href="Scala_(programming_language)" title="wikilink">Scala</a>, <a href="D_(programming_language)" title="wikilink">D</a></p></td>
<td style="text-align: left;">
<p>Invariant</p></td>
<td style="text-align: left;">
<p>Covariant</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="C_Sharp_(programming_language)" title="wikilink">C#</a></p></td>
<td style="text-align: left;">
<p>Invariant</p></td>
<td style="text-align: left;">
<p>Invariant</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><a class="uri" href="Sather" title="wikilink">Sather</a></p></td>
<td style="text-align: left;">
<p>Contravariant</p></td>
<td style="text-align: left;">
<p>Covariant</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Eiffel_(programming_language)" title="wikilink">Eiffel</a></p></td>
<td style="text-align: left;">
<p>Covariant</p></td>
<td style="text-align: left;">
<p>Covariant</p></td>
</tr>
</tbody>
</table>
<h2 id="generic-types">Generic types</h2>

<p>In programming languages that support generics (a.k.a. <a href="parametric_polymorphism" title="wikilink">parametric polymorphism</a>), the programmer can extend the type system with new constructors. For example, a C# interface like <mtpl></mtpl> makes it possible to construct new types like <mtpl></mtpl> or <mtpl></mtpl>. The question then arises what the variance of these type constructors should be.</p>

<p>There are two main approaches. In languages with <strong>declaration-site variance annotations</strong> (e.g. <a href="C_Sharp_(programming_language)" title="wikilink">C#</a>), the programmer annotates the definition of a generic type with the intended variance of its type parameters. With <strong>use-site variance annotations</strong> (e.g. <a href="Java_(programming_language)" title="wikilink">Java</a>), the programmer instead annotates the places where a generic type is instantiated.</p>
<h3 id="declaration-site-variance-annotations">Declaration-site variance annotations</h3>

<p>The most popular languages with declaration-site variance annotations are <a href="C_Sharp_(programming_language)" title="wikilink">C#</a> (using the keywords  and ), and <a href="Scala_(programming_language)" title="wikilink">Scala</a> and <a class="uri" href="OCaml" title="wikilink">OCaml</a> (using the keywords  and ). C# only allows variance annotations for interface types, while Scala and OCaml allows them for both interface types and concrete data types.</p>
<h4 id="interfaces">Interfaces</h4>

<p>In C#, each type parameter of a generic interface can be marked covariant (), contravariant (), or invariant (no annotation). For example, we can define an interface <mtpl></mtpl> of read-only iterators, and declare it to be covariant (out) in its type parameter.</p>
<pre class="csharp"><code>    interface IEnumerator<out t="">
    {
        T Current { get; }
        bool MoveNext();
    }
</out></code></pre>

<p>With this declaration,  will be treated as covariant in its type argument, e.g. <mtpl></mtpl> is a subtype of <mtpl></mtpl>.</p>

<p>The typechecker enforces that each method declaration in an interface only mentions the type parameters in a way consistent with the / annotations. That is, a parameter that was declared covariant must not occur in any contravariant positions (where a position is contravariant if it occurs under an odd number of contravariant type constructors). The precise rule<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> is that the return types of all methods in the interface must be <em>valid covariantly</em> and all the method argument types must be <em>valid contravariantly</em>, where <em>valid S-ly</em> is defined as follows:</p>
<ul>
<li>Non-generic types (classes, structs, enums, etc.) are valid both co- and contravariantly.</li>
<li>A type argument  is valid covariantly if it was not marked , and valid contravariantly if it was not marked </li>
<li>An array type  is valid S-ly if  is. (This is because C# has covariant arrays).</li>
<li>A generic type <mtpl></mtpl> is valid S-ly if for each argument ,
<ul>
<li>Ai is valid S-ly, and the <em>i</em>th parameter to  is declared covariant, or</li>
<li>Ai is valid (not S)-ly, and the <em>i</em>th parameter to  is declared contravariant, or</li>
<li>Ai is valid both covariantly and contravariantly, and the <em>i</em>th parameter to  is declared invariant.</li>
</ul></li>
</ul>

<p>As an example of how these rules apply, consider the <mtpl></mtpl> interface.</p>
<pre class="csharp"><code>    interface IList<t>
    {
    void Insert(int index, T item);
    IEnumerator<t> GetEnumerator();
    }
</t></t></code></pre>

<p>The argument type  of  must be valid contravariantly, i.e. the type parameter  must not be tagged . Similarly, the result type <mtpl></mtpl> of  must be valid covariantly, i.e. (since  is a covariant interface) the type  must be valid covariantly, i.e. the type parameter  must not be tagged . This shows that the interface  is not allowed to be marked either co- or contravariant.</p>

<p>In the common case of a generic data structure such as , these restrictions mean that an  parameter can only be used for methods getting data out of the structure, and an  parameter can only be used for methods putting data into the structure, hence the choice of keywords.</p>
<h4 id="data">Data</h4>

<p>C# allows variance annotations on the parameters of interfaces, but not the parameters of classes. Because fields in C# classes are always mutable, variantly parameterized classes in C# would not be very useful. But languages which emphasize immutable data can make good use of covariant data types. For example, both in <a href="Scala_(programming_language)" title="wikilink">Scala</a> and <a class="uri" href="OCaml" title="wikilink">OCaml</a> the immutable list type is covariant:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">List[Cat]</code></pre></div>

<p>is a subtype of</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">List[Animal]</code></pre></div>

<p>.</p>

<p>Scala's rules for checking variance annotations are essentially the same as C#'s. However, there are some idioms that apply to immutable datastructures in particular. They are illustrated by the following (excerpt from the) definition of the</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">List[A]</code></pre></div>

<p>class.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">abstract</span> <span class="kw">class</span> List[+A] <span class="kw">extends</span> AbstractSeq[A] {
  <span class="kw">def</span> head: A
  <span class="kw">def</span> tail: List[A]

  <span class="co">/** Adds an element at the beginning of this list. */</span>
  <span class="kw">def</span> ::[B &gt;: A] (x: B): List[B] =
    <span class="kw">new</span> scala.<span class="fu">collection</span>.<span class="fu">immutable</span>.::(x, <span class="kw">this</span>)

  ...
}</code></pre></div>

<p>First, class members that have a variant type must be immutable. Here,</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">head</code></pre></div>

<p>has the type</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">A</code></pre></div>

<p>, which was declared covariant (</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">+</code></pre></div>

<p>), and indeed</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">head</code></pre></div>

<p>was declared as a method (</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span></code></pre></div>

<p>). Trying to declare it as a mutable field (</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">var</span></code></pre></div>

<p>) would be rejected as type error.</p>

<p>Second, even if a data structure is immutable, it will often have methods where the parameter type occurs contravariantly. For example, consider the method</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">::</code></pre></div>

<p>which adds an element to the front of a list. (The implementation works by creating a new object of the similarly-named <em>class</em></p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">::</code></pre></div>

<p>, the class of nonempty lists). The most obvious type to give it would be</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">  <span class="kw">def</span> :: (x: A): List[A]</code></pre></div>

<p>However, this would be a type error, because the covariant parameter</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">A</code></pre></div>

<p>appears in a contravariant position (as a function argument). But there is a trick to get around this problem. We give</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">::</code></pre></div>

<p>a more general type, which allows adding an element of any type</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">B</code></pre></div>

<p>as long as</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">B</code></pre></div>

<p>is a supertype of</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">A</code></pre></div>

<p>. Note that this relies on</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">List</code></pre></div>

<p>being covariant, since</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">this</span></code></pre></div>

<p>has type</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">List[A]</code></pre></div>

<p>and we treat it as having type</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">List[B]</code></pre></div>

<p>. At first glance it may not be obvious that the generalized type is sound, but if the programmer starts out with the simpler type declaration, the type errors will point out the place that needs to be generalized.</p>
<h4 id="inferring-variance">Inferring Variance</h4>

<p>It is possible to design a type system where the compiler automatically infers the best possible variance annotations for all datatype parameters.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> However, the analysis can get complex for several reasons. First, the analysis is nonlocal since the variance of an interface  depends the variance of all interfaces that  mentions. Second, in order to get unique best solutions the type system must allow <em>bivariant</em> parameters (which are simultaneously co- and contravariant). And finally, the variance of type parameters should arguably be a deliberate choice by the designer of an interface, not something that just happens.</p>

<p>For these reasons<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> most languages do very little variance inference. C# and Scala do not infer any variance annotations at all. OCaml can infer the variance of parameterized concrete datatypes, but the programmer must explicitly specify the variance of abstract types (interfaces).</p>

<p>For example, consider an OCaml datatype  which wraps a function</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> ('a, 'b) t = <span class="dt">T</span> <span class="kw">of</span> ('a -&gt; 'b) </code></pre></div>

<p>The compiler will automatically infer that  is contravariant in the first parameter, and covariant in the second. The programmer can also provide explicit annotations, which the compiler will check are satisfied. Thus the following declaration is equivalent to the previous one:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> (-'a, +'b) t = <span class="dt">T</span> <span class="kw">of</span> ('a -&gt; 'b) </code></pre></div>

<p>Explicit annotations in OCaml become useful when specifying interfaces. For example, the standard library interface  for association tables include an annotation saying that the map type constructor is covariant in the result type.</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="ot">module</span> <span class="kw">type</span> <span class="dt">S</span> =
  <span class="kw">sig</span>
    <span class="kw">type</span> key
    <span class="kw">type</span> (+'a) t
    <span class="kw">val</span> empty: 'a t
    <span class="kw">val</span> mem: key -&gt; 'a t -&gt; <span class="dt">bool</span>
    ...
  <span class="kw">end</span></code></pre></div>

<p>This ensures that e.g.  is a subtype of .</p>
<h3 id="use-site-variance-annotations-wildcards">Use-site variance annotations (Wildcards)</h3>

<p>One drawback of the declaration-site approach is that many interface types must be made invariant. For example, we saw above that  needed to be invariant, because it contained both  and . In order to expose more variance, the API designer could provide additional interfaces which provide subsets of the available methods (e.g. an "insert-only list" which only provides ). However this quickly becomes unwieldy.</p>

<p>Use-site variance annotations aim to give users of a class more opportunities for subtyping without requiring the designer of the class to define multiple interfaces with different variance. Instead, each time a class or interface is used in a type declaration, the programmer can indicate that only a subset of the methods will be used. In effect, each definition of a class also makes available interfaces for the covariant and contravariant "parts" of that class. Therefore the designer of the class no longer needs to take variance into account, increasing re-usability.</p>

<p>Java provides use-site variance annotations through <a href="Wildcard_(Java)" title="wikilink">wildcards</a>, a restricted form of <a href="bounded_quantification" title="wikilink">bounded</a> <a href="existential_type" title="wikilink">existential types</a>. A parameterized type can be instantiated by a wildcard  together with an upper or lower bound, e.g. <mtpl></mtpl> or <mtpl></mtpl>. (A an unbounded wildcard like <mtpl></mtpl> is equivalent to <mtpl></mtpl>). Such a type represents <mtpl></mtpl> for some unknown type  which satisfies the bound. For example, if  has type <mtpl></mtpl>, then the typechecker will accept</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    Animal a = l.<span class="fu">get</span>(<span class="dv">3</span>);</code></pre></div>

<p>because the type  is known to be a subtype of , but</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">    l.<span class="fu">add</span>(<span class="kw">new</span> <span class="fu">Animal</span>())</code></pre></div>

<p>will be rejected as a type error since an  is not necessarily an . In general, given some interface <mtpl></mtpl>, a reference to a <mtpl></mtpl> forbids using methods from the interface where  occurs contravariantly in the type of the method. Conversely, if  had type <mtpl></mtpl> one could call  but not .</p>
<figure><b>(Figure)</b>
<figcaption>Wildcard subtyping in Java can be visualized as a cube.</figcaption>
</figure>

<p>While plain generic types in Java are invariant (e.g. there is no subtyping relationship between <mtpl></mtpl> and <mtpl></mtpl>), wildcard types can be made more specific by specifying a tighter bound, for example <mtpl></mtpl> is a subtype of <mtpl></mtpl>. This shows that wildcard types are <strong>covariant in their upper bounds</strong> (and also <strong>contravariant in their lower bounds</strong>). In total, given a wildcard type like <mtpl></mtpl>, there are three ways to form a subtype: by specializing the class , by specifying a tighter bound , or by replacing the wildcard  by a specific type (see figure).</p>

<p>By combining two steps of subtyping, it is therefore possible to e.g. pass an argument of type <mtpl></mtpl> to a method expecting a <mtpl></mtpl>. This is exactly the kind of programs that covariant interface types allow. The type <mtpl></mtpl> acts as an interface type containing only the covariant methods of <mtpl></mtpl>, but the implementer of <mtpl></mtpl> did not have to define it ahead of time. This is use-site variance.</p>

<p>In the common case of a generic data structure , covariant parameters are used for methods getting data out of the structure, and contravariant parameters for methods putting data into the structure. The mnemonics PECS (Producer Extends, Consumer Super) from the book <strong>Effective Java</strong> by <a href="Joshua_Bloch" title="wikilink">Joshua Bloch</a> gives an easy way to remember when to use covariance and contravariance.</p>

<p>Wildcards are flexible, but there is a drawback. While use-site variance means that API designers need not consider variance of type parameters to interfaces, they must often instead use more complicated method signatures. A common example involves the  interface. Suppose we want to write a function that finds the biggest element in a collection. The elements need to implement the  method, so a first try might be</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><t class="st" comparable<t="&lt;span">""</t></code></pre></div> <span class="kw">extends</span>=<span class="st">""</span>&gt;&gt;  T <span class="fu">max</span>(Collection<t> coll);
</t>

<p>However, this type is not general enough—one can find the max of a <mtpl></mtpl>, but not a <mtpl></mtpl>. The problem is that  does not implement <mtpl></mtpl>, but instead the (better) interface <mtpl></mtpl>. In Java, unlike in C#, <mtpl></mtpl> is not considered a subtype of <mtpl></mtpl>. Instead the type of  has to be modified:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><t class="st" comparable<?="&lt;span">""</t></code></pre></div> <span class="kw">extends</span>=<span class="st">""</span> <span class="kw">super</span>=<span class="st">""</span> t=<span class="st">""</span>&gt;&gt;  T <span class="fu">max</span>(Collection<t> coll);
</t>

<p>The bounded wildcard  conveys the information that  calls only contravariant methods from the  interface. This particular example is frustrating because <em>all</em> the methods in  are contravariant, so that condition is trivially true. A declaration-site system could handle this example with less clutter by annotating only the definition of .</p>
<h3 id="comparing-declaration-site-and-use-site-annotations">Comparing Declaration-site and Use-site annotations</h3>

<p>Use-site variance annotations provide additional flexibility, allowing more programs to type-check. However, they have been criticized for the complexity they add to the language, leading to complicated type signatures and error messages.</p>

<p>One way to assess whether the extra flexibility is useful is to see if it is used in existing programs. A survey of a large set of Java libraries<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> found that 39% of wildcard annotations could have been directly replaced by a declaration-site annotations. Thus the remaining 61% is an indication on places where Java benefits from having the use-site system available.</p>

<p>In a declaration-site language, libraries must either expose less variance, or define more interfaces. For example, the Scala Collections library defines three separate interfaces for classes which employ covariance: a covariant base interface containing common methods, an invariant mutable version which adds side-effecting methods, and a covariant immutable version which may specialize the inherited implementations to exploit structural sharing.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> This design works well with declaration-site annotations, but the large number of interfaces carry a complexity cost for clients of the library. And modifying the library interface may not be an option—in particular, one goal when adding generics to Java was to maintain binary backwards compatibility.</p>

<p>On the other hand, Java wildcards are themselves complex. In a conference presentation<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> <a href="Joshua_Bloch" title="wikilink">Joshua Bloch</a> criticized them as being too hard to understand and use, stating that when adding support for <a href="Closure_(computer_science)" title="wikilink">closures</a> "we simply cannot afford another <em>wildcards</em>". Early versions of Scala used use-site variance annotations but programmers found them difficult to use in practice, while declaration-site annotations were found to be very helpful when designing classes.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> Later versions of Scala added Java-style existential types and wildcards; however, according to <a href="Martin_Odersky" title="wikilink">Martin Odersky</a>, if there were no need for interoperability with Java then these would probably not have been included.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>

<p>Ross Tate argues<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> that part of the complexity of Java wildcards is due to the decision to encode use-site variance using a form of existential types. The original proposals<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> <a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> used special-purpose syntax for variance annotations, writing  instead of Java's more verbose <mtpl></mtpl>.</p>

<p>Since wildcards are a form of existential types they can be used for more things than just variance. A type like <mtpl></mtpl> ("some type of list") lets objects be passed to methods or stored in fields without exactly specifying their type parameters. This is particularly valuable for classes such as  where most of the methods do not mention the type parameter.</p>

<p>However, type inference for existential types is a difficult problem. For the compiler implementer, Java wildcards raise issues with type checker termination, type argument inference, and ambiguous programs.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> For the programmer, it leads to complicated type error messages. Java typechecks wildcard types by replacing the wildcards with fresh type variables (so-called <em>capture conversion</em>). This can make error messages harder to read, because they refer to type variables that the programmer did not directly write. For example, trying to add a  to a <mtpl></mtpl> will give an error like</p>

<p><code>method List.add(capture#1) is not applicable</code><br/>
<code>  (actual argument Cat cannot be converted to capture#1 by method invocation conversion)</code><br/>
<code>where capture#1 is a fresh type-variable:</code><br/>
<code>  capture#1 extends Animal from capture of ? extends Animal</code></p>

<p>Since both declaration-site and use-site annotations can be useful, some type system provide both.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a><a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>
<h3 id="covariant-generics-in-dart">Covariant generics in Dart</h3>

<p>The <a href="Dart_(programming_language)" title="wikilink">Dart</a> programming language does not track variance, and instead treats all parameterized types as covariant. The language specification<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> states</p>
<blockquote>

<p>The type system is unsound, due to the covariance of generic types. This is a deliberate choice (and undoubtedly controversial). Experience has shown that sound type rules for generics fly in the face of programmer intuition. It is easy for tools to provide a sound type analysis if they choose, which may be useful for tasks like refactoring.</p>
</blockquote>
<h2 id="origin-of-the-term-covariance">Origin of the term "covariance"</h2>

<p>These terms come from the notion of <a href="covariance_and_contravariance_of_functors" title="wikilink">covariant and contravariant functors</a> in <a href="category_theory" title="wikilink">category theory</a>. Consider the category 

<math display="inline" id="Covariance_and_contravariance_(computer_science):0">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 whose objects are types and whose morphisms represent the subtype relationship ≤. (This is an example of how any partially ordered set can be considered as a category). Then for example the function type constructor takes two types <em>p</em> and <em>r</em> and creates a new type <em>p</em> → <em>r</em>; so it takes objects in 

<math display="inline" id="Covariance_and_contravariance_(computer_science):1">
 <semantics>
  <msup>
   <mi>C</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>C</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{2}
  </annotation>
 </semantics>
</math>

 to objects in 

<math display="inline" id="Covariance_and_contravariance_(computer_science):2">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

. By the subtyping rule for function types this operation reverses ≤ for the first argument and preserves it for the second, so it is a contravariant functor in the first argument and a covariant functor in the second.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Polymorphism_(computer_science)" title="wikilink">Polymorphism (computer science)</a></li>
<li><a href="Inheritance_(computer_science)" title="wikilink">Inheritance (computer science)</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://blogs.msdn.com/ericlippert/archive/tags/Covariance+and+Contravariance/default.aspx">Fabulous Adventures in Coding</a>: An article series about implementation concerns surrounding co/contravariance in C#</li>
<li><a href="http://c2.com/cgi/wiki?ContraVsCoVariance">Contra Vs Co Variance</a> (note this article is not updated about C++)</li>
<li><a href="http://www.javac.info/closures-v05.html">Closures for the Java 7 Programming Language (v0.5)</a></li>
</ul>

<p>"</p>

<p><a href="Category:Object-oriented_programming" title="wikilink">Category:Object-oriented programming</a> <a href="Category:Type_theory" title="wikilink">Category:Type theory</a> <a href="Category:Polymorphism_(computer_science)" title="wikilink">Category:Polymorphism (computer science)</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://msdn.microsoft.com/en-us/library/bb549151.aspx">Func<t tresult=""> Delegate</t></a> - MSDN Documentation<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">(Longer version in Information and Computation, 76(2/3): 138-164, February 1988.)<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9">Giuseppe Castagna, [<a class="uri" href="http://portal.acm.org/citation.cfm?id=203096&amp;dl">http://portal.acm.org/citation.cfm?id=203096&amp;dl;</a>;=ACM&amp;coll;=&amp;CFID;=15151515&amp;CFTOKEN;=6184618 Covariance and contravariance: conflict without a cause], ACM Transactions on Programming Languages and Systems (TOPLAS), Volume 17, Issue 3, May 1995, pages 431-447.<a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11">Section II.9.7 in <cite>ECMA International Standard ECMA-335 Common Language Infrastructure (CLI) 6th edition (June 2012)</cite>; <a href="http://www.ecma-international.org/publications/standards/Ecma-335.htm">available online</a><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"></li>
<li id="fn24"></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
</ol>
</section>


