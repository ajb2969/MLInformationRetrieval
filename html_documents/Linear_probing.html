<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1605">Linear probing</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Linear probing</h1>
<hr/>

<p>'''Linear probing ''' is a scheme in <a href="computer_programming" title="wikilink">computer programming</a> for resolving <a href="hash_collision" title="wikilink">hash collisions</a> of values of <a href="hash_function" title="wikilink">hash functions</a> by sequentially searching the <a href="hash_table" title="wikilink">hash table</a> for a free location.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="algorithm">Algorithm</h2>

<p>Linear probing is accomplished using two values - one as a starting value and one as an interval between successive values in <a href="modular_arithmetic" title="wikilink">modular arithmetic</a>. The second value, which is the same for all keys and known as the <em>stepsize</em>, is repeatedly added to the starting value until a free space is found, or the entire table is traversed. (In order to traverse the entire table the stepsize should be <a href="relatively_prime" title="wikilink">relatively prime</a> to the arraysize, which is why the array size is often chosen to be a prime number.)</p>
<dl>
<dd><dl>
<dd>newLocation = (startingValue + stepSize) % arraySize
</dd>
</dl>
</dd>
</dl>

<p>Given an ordinary hash function <em>H(x)</em>, a linear probing function (<em>H(x, i)</em>) would be:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Linear_probing:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>H</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>i</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>H</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mi>i</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>H</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>i</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>H</ci>
       <ci>x</ci>
      </apply>
      <ci>i</ci>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(x,i)=(H(x)+i)\;\;(\mathop{{\rm mod}}n).\,
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Here <em>H(x)</em> is the starting value, <em>n</em> the size of the hash table, and the <em>stepsize</em> is <em>i</em> in this case.</p>

<p>Often, the step size is one; that is, the array cells that are probed are consecutive in the hash table. <a href="Double_hashing" title="wikilink">Double hashing</a> is a variant of the same method in which the step size is itself computed by a hash function.</p>
<h2 id="properties">Properties</h2>

<p>This algorithm, which is used in open-addressed <a href="hash_table" title="wikilink">hash tables</a>, provides good memory caching (if stepsize is equal to one), through good locality of reference, but also results in clustering, an unfortunately high <a class="uri" href="probability" title="wikilink">probability</a> that where there has been one collision there will be more. The performance of linear probing is also more sensitive to input distribution when compared to <a href="double_hashing" title="wikilink">double hashing</a>, where the stepsize is determined by another hash function applied to the value instead of a fixed stepsize as in linear probing.</p>
<h2 id="dictionary-operation-in-constant-time">Dictionary operation in constant time</h2>

<p>Using linear probing, dictionary operation can be implemented in constant time. In other words, insert, remove and search operations can be implemented in O(1), as long as the <a href="load_factor_(computer_science)" title="wikilink">load factor</a> of the hash table is a constant strictly less than one.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> This analysis makes the (unrealistic) assumption that the hash function is completely random, but can be extended also to <a href="K-independent_hashing" title="wikilink">5-independent hash functions</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Weaker properties, such as <a href="universal_hashing" title="wikilink">universal hashing</a>, are not strong enough to ensure the constant-time operation of linear probing,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> but one practical method of hash function generation, <a href="tabulation_hashing" title="wikilink">tabulation hashing</a>, again leads to a guaranteed constant expected time performance despite not being 5-independent.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Quadratic_probing" title="wikilink">Quadratic probing</a></li>
<li><a href="Hash_table#Collision_resolution" title="wikilink">Collision resolution</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.siam.org/meetings/alenex05/papers/13gheileman.pdf">How Caching Affects Hashing</a> by Gregory L. Heileman and Wenbin Luo 2005.</li>
<li><a href="http://opendatastructures.org/versions/edition-0.1e/ods-java/5_2_LinearHashTable_Linear_.html">Open Data Structures - Section 5.2 - LinearHashTable: Linear Probing</a></li>
</ul>

<p>"</p>

<p><a href="Category:Search_algorithms" title="wikilink">Category:Search algorithms</a> <a class="uri" href="Category:Hashing" title="wikilink">Category:Hashing</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
