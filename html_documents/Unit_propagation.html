<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1194">Unit propagation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Unit propagation</h1>
<hr/>

<p><strong>Unit propagation</strong> (<strong>UP</strong>) or <strong>Boolean Constraint propagation</strong> or the <strong>one-literal rule</strong> (<strong>OLR</strong>) is a <a href="Algorithm" title="wikilink">procedure</a> of <a href="automated_theorem_proving" title="wikilink">automated theorem proving</a> that can simplify a set of (usually <a href="propositional_logic" title="wikilink">propositional</a>) <a href="Clause_(logic)" title="wikilink">clauses</a>.</p>
<h2 id="definition">Definition</h2>

<p>The procedure is based on <strong>unit clauses</strong>, i.e. clauses that are composed of a single <a href="literal_(mathematical_logic)" title="wikilink">literal</a>. Because each clause needs to be satisfied, we know that this literal must be true. If a set of clauses contains the unit clause 

<math display="inline" id="Unit_propagation:0">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

, the other clauses are simplified by the application of the two following rules:</p>
<ol>
<li>every clause (other than the unit clause itself) containing 

<math display="inline" id="Unit_propagation:1">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

 is removed (the clause is satisfied if 

<math display="inline" id="Unit_propagation:2">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

 is);</li>
<li>in every clause that contains 

<math display="inline" id="Unit_propagation:3">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>l</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg l
  </annotation>
 </semantics>
</math>

 this literal is deleted (

<math display="inline" id="Unit_propagation:4">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

 can not contribute to it being satisfied).</li>
</ol>

<p>The application of these two rules lead to a new set of clauses that is equivalent to the old one.</p>

<p>For example, the following set of clauses can be simplified by unit propagation because it contains the unit clause 

<math display="inline" id="Unit_propagation:5">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="block" id="Unit_propagation:6">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mi>a</mi>
    <mo>∨</mo>
    <mi>b</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>a</mi>
    </mrow>
    <mo>∨</mo>
    <mi>c</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>c</mi>
    </mrow>
    <mo>∨</mo>
    <mi>d</mi>
   </mrow>
   <mo>,</mo>
   <mi>a</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <or></or>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <or></or>
     <apply>
      <times></times>
      <not></not>
      <ci>a</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <apply>
     <or></or>
     <apply>
      <times></times>
      <not></not>
      <ci>c</ci>
     </apply>
     <ci>d</ci>
    </apply>
    <ci>a</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{a\vee b,\neg a\vee c,\neg c\vee d,a\}
  </annotation>
 </semantics>
</math>

</p>

<p>Since 

<math display="inline" id="Unit_propagation:7">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∨</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\vee b
  </annotation>
 </semantics>
</math>

 contains the literal 

<math display="inline" id="Unit_propagation:8">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

, this clause can be removed altogether. Since 

<math display="inline" id="Unit_propagation:9">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>a</mi>
   </mrow>
   <mo>∨</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <apply>
     <times></times>
     <not></not>
     <ci>a</ci>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg a\vee c
  </annotation>
 </semantics>
</math>

 contains the negation of the literal in the unit clause, this literal can be removed from the clause. The unit clause 

<math display="inline" id="Unit_propagation:10">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is not removed; this would make the resulting set not equivalent to the original one; this clause can be removed if already stored in some other form (see section "Using a partial model"). The effect of unit propagation can be summarized as follows.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Unit_propagation:11">
 <semantics>
  <mo stretchy="false">{</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-{</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Unit_propagation:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>∨</mo>
    <mi>b</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\vee b,
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Unit_propagation:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>a</mi>
    </mrow>
    <mo>∨</mo>
    <mi>c</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <apply>
     <times></times>
     <not></not>
     <ci>a</ci>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg a\vee c,
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Unit_propagation:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>c</mi>
    </mrow>
    <mo>∨</mo>
    <mi>d</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <apply>
     <times></times>
     <not></not>
     <ci>c</ci>
    </apply>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg c\vee d,
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Unit_propagation:15">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Unit_propagation:16">
 <semantics>
  <mo stretchy="false">}</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-}</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>(removed)</p></td>
<td style="text-align: left;">
<p>(

<math display="inline" id="Unit_propagation:17">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg a
  </annotation>
 </semantics>
</math>

 deleted)</p></td>
<td style="text-align: left;">
<p>(unchanged)</p></td>
<td style="text-align: left;">
<p>(unchanged)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Unit_propagation:18">
 <semantics>
  <mo stretchy="false">{</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-{</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p> </p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Unit_propagation:19">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c,
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Unit_propagation:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>c</mi>
    </mrow>
    <mo>∨</mo>
    <mi>d</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <apply>
     <times></times>
     <not></not>
     <ci>c</ci>
    </apply>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg c\vee d,
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Unit_propagation:21">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Unit_propagation:22">
 <semantics>
  <mo stretchy="false">}</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-}</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>The resulting set of clauses 

<math display="inline" id="Unit_propagation:23">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>c</mi>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>c</mi>
    </mrow>
    <mo>∨</mo>
    <mi>d</mi>
   </mrow>
   <mo>,</mo>
   <mi>a</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>c</ci>
    <apply>
     <or></or>
     <apply>
      <times></times>
      <not></not>
      <ci>c</ci>
     </apply>
     <ci>d</ci>
    </apply>
    <ci>a</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{c,\neg c\vee d,a\}
  </annotation>
 </semantics>
</math>

 is equivalent to the above one. The new unit clause 

<math display="inline" id="Unit_propagation:24">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 that results from unit propagation can be used for a further application of unit propagation, which would transform 

<math display="inline" id="Unit_propagation:25">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>c</mi>
   </mrow>
   <mo>∨</mo>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <apply>
     <times></times>
     <not></not>
     <ci>c</ci>
    </apply>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg c\vee d
  </annotation>
 </semantics>
</math>

 into 

<math display="inline" id="Unit_propagation:26">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="unit-propagation-and-resolution">Unit propagation and resolution</h2>

<p>The second rule of unit propagation can be seen as a restricted form of <a href="Resolution_(logic)" title="wikilink">resolution</a>, in which one of the two resolvents must always be a unit clause. As for resolution, unit propagation is a correct inference rule, in that it never produces a new clause that was not entailed by the old ones. The difference between unit propagation and resolution are:</p>
<ol>
<li>resolution is a complete refutation procedure while unit propagation is not; in other words, even if a set of clause is contradictory, unit propagation may not generate an inconsistency;</li>
<li>the two clauses that are resolved cannot in general be removed after the generated clause is added to the set; on the contrary, the non-unit clause involved in a unit propagation can be removed when its simplification is added to the set;</li>
<li>resolution does not in general include the first rule used in unit propagation.</li>
</ol>

<p>Resolution calculi that include <a class="uri" href="subsumption" title="wikilink">subsumption</a> can model rule one by subsumption and rule two by a unit resolution step, followed by subsumption.</p>

<p>Unit propagation, applied repeatedly as new unit clauses are generated, is a complete satisfiability algorithm for sets of propositional <a href="Horn_clause" title="wikilink">Horn clauses</a>; it also generates a minimal model for the set if satisfiable: see <a class="uri" href="Horn-satisfiability" title="wikilink">Horn-satisfiability</a>.</p>
<h2 id="using-a-partial-model">Using a partial model</h2>

<p>The unit clauses that are present in a set of clauses or can be derived from it can be stored in form of a partial model (this partial model may also contain other literals, depending on the application). In this case, unit propagation is performed based on the literals of the partial model, and unit clauses are removed if their literal is in the model. In the example above, the unit clause 

<math display="inline" id="Unit_propagation:27">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 would be added to the partial model; the simplification of the set of clause would then proceed as above with the difference that the unit clause 

<math display="inline" id="Unit_propagation:28">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is now removed from the set. The resulting set of clauses is equivalent to the original one under the assumption of validity of the literals in the partial model.</p>
<h2 id="complexity">Complexity</h2>

<p>The direct implementation of unit propagation takes time <a href="quadratic_growth" title="wikilink">quadratic</a> in the total size of the set to check, which is defined to be the sum of the size of all clauses, where the size of each clause is the number of literals it contains.</p>

<p>Unit propagation can however be done in linear time by storing, for each variable, the list of clauses in which each literal is contained. For example, the set above can be represented by numbering each clause as follows:</p>

<p>

<math display="block" id="Unit_propagation:29">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mn>1</mn>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>a</mi>
      <mo>∨</mo>
      <mi>b</mi>
     </mrow>
     <mo>,</mo>
     <mn>2</mn>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>a</mi>
      </mrow>
      <mo>∨</mo>
      <mi>c</mi>
     </mrow>
     <mo>,</mo>
     <mn>3</mn>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi mathvariant="normal">¬</mi>
       <mi>c</mi>
      </mrow>
      <mo>∨</mo>
      <mi>d</mi>
     </mrow>
     <mo>,</mo>
     <mn>4</mn>
    </mrow>
    <mo>:</mo>
    <mi>a</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <cn type="integer">1</cn>
    <apply>
     <and></and>
     <apply>
      <ci>normal-:</ci>
      <list>
       <apply>
        <or></or>
        <ci>a</ci>
        <ci>b</ci>
       </apply>
       <cn type="integer">2</cn>
      </list>
      <list>
       <apply>
        <or></or>
        <apply>
         <times></times>
         <not></not>
         <ci>a</ci>
        </apply>
        <ci>c</ci>
       </apply>
       <cn type="integer">3</cn>
      </list>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <share href="#.cmml">
      </share>
      <list>
       <apply>
        <or></or>
        <apply>
         <times></times>
         <not></not>
         <ci>c</ci>
        </apply>
        <ci>d</ci>
       </apply>
       <cn type="integer">4</cn>
      </list>
     </apply>
     <apply>
      <ci>normal-:</ci>
      <share href="#.cmml">
      </share>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{1:a\vee b,2:\neg a\vee c,3:\neg c\vee d,4:a\}
  </annotation>
 </semantics>
</math>

</p>

<p>and then storing, for each variable, the list of clauses containing the variable or its negation:</p>

<p>

<math display="block" id="Unit_propagation:30">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>:</mo>
   <mn>1 2 4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>a</ci>
    <cn type="float">1 2 4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a:1\ 2\ 4
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Unit_propagation:31">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>:</mo>
   <mpadded width="+1.7pt">
    <mn>1</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>b</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b:1\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Unit_propagation:32">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>:</mo>
   <mn>2 3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>c</ci>
    <cn type="float">2 3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c:2\ 3
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Unit_propagation:33">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>:</mo>
   <mpadded width="+1.7pt">
    <mn>3</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>d</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d:3\,
  </annotation>
 </semantics>
</math>

</p>

<p>This simple data structure can be built in time linear in the size of the set, and allows finding all clauses containing a variable very easily. Unit propagation of a literal can be performed efficiently by scanning only the list of clauses containing the variable of the literal. More precisely, the total running time for doing unit propagation for all unit clauses is linear in the size of the set of clauses.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Horn-satisfiability" title="wikilink">Horn satisfiability</a></li>
<li><a href="Horn_clause" title="wikilink">Horn clause</a></li>
<li><a href="Automated_theorem_proving" title="wikilink">Automated theorem proving</a></li>
<li><a href="DPLL_algorithm" title="wikilink">DPLL algorithm</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>W. Dowling and J. Gallier (1984). Linear-time algorithms for testing the satisfiability of propositional Horn formulae. <em>Journal of Logic Programming</em>, 1(3):267–284.</li>
</ul>
<ul>
<li>H. Zhang and M. Stickel (1996). An efficient algorithm for unit-propagation. In <em>Proceedings of the Fourth International Symposium on Artificial Intelligence and Mathematics</em>.</li>
</ul>

<p>"</p>

<p><a href="Category:Automated_theorem_proving" title="wikilink">Category:Automated theorem proving</a></p>
</body>
</html>
