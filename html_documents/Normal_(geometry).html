<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="663">Normal (geometry)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Normal (geometry)</h1>
<hr/>

<p>  In <a class="uri" href="geometry" title="wikilink">geometry</a>, a <strong>normal</strong> is an object such as a line or vector that is <a class="uri" href="perpendicular" title="wikilink">perpendicular</a> to a given object. For example, in the two-dimensional case, the <strong>normal line</strong> to a curve at a given point is the line perpendicular to the <a href="tangent_line" title="wikilink">tangent line</a> to the curve at the point.</p>

<p>In the three-dimensional case a <strong>surface normal</strong>, or simply <strong>normal</strong>, to a <a class="uri" href="surface" title="wikilink">surface</a> at a point <em>P</em> is a <a href="vector_(geometry)" title="wikilink">vector</a> that is <a class="uri" href="perpendicular" title="wikilink">perpendicular</a> to the <a href="Tangent_space" title="wikilink">tangent plane</a> to that surface at <em>P</em>. The word "normal" is also used as an adjective: a <a href="line_(geometry)" title="wikilink">line</a> normal to a <a href="plane_(geometry)" title="wikilink">plane</a>, the normal component of a <a class="uri" href="force" title="wikilink">force</a>, the <strong>normal vector</strong>, etc. The concept of <strong>normality</strong> generalizes to <a class="uri" href="orthogonality" title="wikilink">orthogonality</a>.</p>

<p>The concept has been generalized to <a href="differentiable_manifold" title="wikilink">differentiable manifolds</a> of arbitrary dimension embedded in a <a href="Euclidean_space" title="wikilink">Euclidean space</a>. The <strong>normal vector space</strong> or <strong>normal space</strong> of a manifold at a point <em>P</em> is the set of the vectors which are <a class="uri" href="orthogonal" title="wikilink">orthogonal</a> to the <a href="tangent_space" title="wikilink">tangent space</a> at <em>P</em>. In the case of <a href="differential_geometry_of_curves" title="wikilink">differential curves</a>, the <a href="curvature_vector" title="wikilink">curvature vector</a> is a normal vector of special interest.</p>

<p>The <strong>normal</strong> is often used in <a href="computer_graphics" title="wikilink">computer graphics</a> to determine a surface's orientation toward a light source for <a href="flat_shading" title="wikilink">flat shading</a>, or the orientation of each of the corners (<a href="vertex_(geometry)" title="wikilink">vertices</a>) to mimic a curved surface with <a href="Phong_shading" title="wikilink">Phong shading</a>.</p>
<h2 id="normal-to-surfaces-in-3d-space">Normal to surfaces in 3D space</h2>
<h3 id="calculating-a-surface-normal">Calculating a surface normal</h3>

<p>For a <a href="Convex_set" title="wikilink">convex</a> <a class="uri" href="polygon" title="wikilink">polygon</a> (such as a <a class="uri" href="triangle" title="wikilink">triangle</a>), a surface normal can be calculated as the vector <a href="cross_product" title="wikilink">cross product</a> of two (non-parallel) edges of the polygon.</p>

<p>For a <a href="Plane_(mathematics)" title="wikilink">plane</a> given by the equation 

<math display="inline" id="Normal_(geometry):0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>b</mi>
     <mi>y</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>c</mi>
     <mi>z</mi>
    </mrow>
    <mo>+</mo>
    <mi>d</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>b</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>z</ci>
     </apply>
     <ci>d</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ax+by+cz+d=0
  </annotation>
 </semantics>
</math>

, the vector 

<math display="inline" id="Normal_(geometry):1">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo>,</mo>
   <mi>c</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>a</ci>
    <ci>b</ci>
    <ci>c</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,b,c)
  </annotation>
 </semantics>
</math>

 is a normal.</p>

<p>For a plane given by the equation</p>

<p>

<math display="block" id="Normal_(geometry):2">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐫</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>α</mi>
     <mo>,</mo>
     <mi>β</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>𝐚</mi>
    <mo>+</mo>
    <mrow>
     <mi>α</mi>
     <mi>𝐛</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>β</mi>
     <mi>𝐜</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝐫</ci>
     <interval closure="open">
      <ci>α</ci>
      <ci>β</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <ci>𝐚</ci>
     <apply>
      <times></times>
      <ci>α</ci>
      <ci>𝐛</ci>
     </apply>
     <apply>
      <times></times>
      <ci>β</ci>
      <ci>𝐜</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r}(\alpha,\beta)=\mathbf{a}+\alpha\mathbf{b}+\beta\mathbf{c}
  </annotation>
 </semantics>
</math>

, i.e., <strong>a</strong> is a point on the plane and <strong>b</strong> and <strong>c</strong> are (non-parallel) vectors lying on the plane, the normal to the plane is a vector normal to both <strong>b</strong> and <strong>c</strong> which can be found as the <a href="cross_product" title="wikilink">cross product</a> 

<math display="inline" id="Normal_(geometry):3">
 <semantics>
  <mrow>
   <mi>𝐛</mi>
   <mo>×</mo>
   <mi>𝐜</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐛</ci>
    <ci>𝐜</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{b}\times\mathbf{c}
  </annotation>
 </semantics>
</math>

.</p>

<p>For a <a class="uri" href="hyperplane" title="wikilink">hyperplane</a> in <em>n</em>+1 dimensions, given by the equation</p>

<p>

<math display="block" id="Normal_(geometry):4">
 <semantics>
  <mrow>
   <mi>𝐫</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐚</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>α</mi>
      <mn>1</mn>
     </msub>
     <msub>
      <mi>𝐚</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>α</mi>
      <mi>n</mi>
     </msub>
     <msub>
      <mi>𝐚</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐫</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐚</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐚</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐚</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r}=\mathbf{a}_{0}+\alpha_{1}\mathbf{a}_{1}+\cdots+\alpha_{n}\mathbf{a}%
_{n}
  </annotation>
 </semantics>
</math>

, where <strong>a</strong><sub>0</sub> is a point on the hyperplane and <strong>a</strong><sub><em>i</em></sub> for <em>i</em> = 1, ..., <em>n</em> are non-parallel vectors lying on the hyperplane, a normal to the hyperplane is any vector in the <a href="null_space" title="wikilink">null space</a> of <em>A</em> where <em>A</em> is given by</p>

<p>

<math display="block" id="Normal_(geometry):5">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <msub>
      <mi>𝐚</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>𝐚</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐚</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐚</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=[\mathbf{a}_{1}\dots\mathbf{a}_{n}]
  </annotation>
 </semantics>
</math>

. That is, any vector orthogonal to all in-plane vectors is by definition a surface normal.</p>

<p>If a (possibly non-flat) surface <em>S</em> is <a href="Coordinate_system" title="wikilink">parameterized</a> by a system of <a href="curvilinear_coordinates" title="wikilink">curvilinear coordinates</a> <strong>x</strong>(<em>s</em>, <em>t</em>), with <em>s</em> and <em>t</em> <a href="real_number" title="wikilink">real</a> variables, then a normal is given by the cross product of the <a href="partial_derivative" title="wikilink">partial derivatives</a></p>

<p>

<math display="block" id="Normal_(geometry):6">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <mo>∂</mo>
      <mi>𝐱</mi>
     </mrow>
     <mrow>
      <mo>∂</mo>
      <mi>s</mi>
     </mrow>
    </mfrac>
    <mo>×</mo>
    <mfrac>
     <mrow>
      <mo>∂</mo>
      <mi>𝐱</mi>
     </mrow>
     <mrow>
      <mo>∂</mo>
      <mi>t</mi>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <ci>𝐱</ci>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <ci>s</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <ci>𝐱</ci>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\partial\mathbf{x}\over\partial s}\times{\partial\mathbf{x}\over\partial t}.
  </annotation>
 </semantics>
</math>

</p>

<p>If a surface <em>S</em> is given <a href="Implicit_function" title="wikilink">implicitly</a> as the set of points 

<math display="inline" id="Normal_(geometry):7">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo>,</mo>
   <mi>z</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>x</ci>
    <ci>y</ci>
    <ci>z</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y,z)
  </annotation>
 </semantics>
</math>

 satisfying 

<math display="inline" id="Normal_(geometry):8">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>z</ci>
     </vector>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(x,y,z)=0
  </annotation>
 </semantics>
</math>

, then, a normal at a point 

<math display="inline" id="Normal_(geometry):9">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo>,</mo>
   <mi>z</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>x</ci>
    <ci>y</ci>
    <ci>z</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y,z)
  </annotation>
 </semantics>
</math>

 on the surface is given by the <a class="uri" href="gradient" title="wikilink">gradient</a></p>

<p>

<math display="block" id="Normal_(geometry):10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∇</mo>
     <mi>F</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-∇</ci>
     <ci>F</ci>
    </apply>
    <vector>
     <ci>x</ci>
     <ci>y</ci>
     <ci>z</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla F(x,y,z).
  </annotation>
 </semantics>
</math>

 since <a href="Level_set#Level_sets_versus_the_gradient" title="wikilink">the gradient at any point is perpendicular to the level set</a>, and 

<math display="inline" id="Normal_(geometry):11">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>z</ci>
     </vector>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(x,y,z)=0
  </annotation>
 </semantics>
</math>

 (the surface) is a level set of 

<math display="inline" id="Normal_(geometry):12">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

.</p>

<p>For a surface <em>S</em> given <a href="Explicit_function" title="wikilink">explicitly</a> as a <a href="Function_(mathematics)" title="wikilink">function</a> 

<math display="inline" id="Normal_(geometry):13">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)
  </annotation>
 </semantics>
</math>

 of the independent variables 

<math display="inline" id="Normal_(geometry):14">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>x</ci>
    <ci>y</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,y
  </annotation>
 </semantics>
</math>

 (e.g., 

<math display="inline" id="Normal_(geometry):15">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>00</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>01</mn>
     </msub>
     <mi>y</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>10</mn>
     </msub>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mn>11</mn>
     </msub>
     <mi>x</mi>
     <mi>y</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">00</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">01</cn>
      </apply>
      <ci>y</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">10</cn>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <cn type="integer">11</cn>
      </apply>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)=a_{00}+a_{01}y+a_{10}x+a_{11}xy
  </annotation>
 </semantics>
</math>

), its normal can be found in at least two equivalent ways. The first one is obtaining its implicit form 

<math display="inline" id="Normal_(geometry):16">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>z</mi>
    <mo>-</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>F</ci>
      <vector>
       <ci>x</ci>
       <ci>y</ci>
       <ci>z</ci>
      </vector>
     </apply>
     <apply>
      <minus></minus>
      <ci>z</ci>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(x,y,z)=z-f(x,y)=0
  </annotation>
 </semantics>
</math>

, from which the normal follows readily as the <a class="uri" href="gradient" title="wikilink">gradient</a></p>

<p>

<math display="block" id="Normal_(geometry):17">
 <semantics>
  <mrow>
   <mrow>
    <mo>∇</mo>
    <mi>F</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-∇</ci>
     <ci>F</ci>
    </apply>
    <vector>
     <ci>x</ci>
     <ci>y</ci>
     <ci>z</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla F(x,y,z)
  </annotation>
 </semantics>
</math>

. (Notice that the implicit form could be defined alternatively as</p>

<p>

<math display="block" id="Normal_(geometry):18">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mi>z</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>z</ci>
     </vector>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(x,y,z)=f(x,y)-z
  </annotation>
 </semantics>
</math>

; these two forms correspond to the interpretation of the surface being <a href="Orientability" title="wikilink">oriented</a> upwards or downwards, respectively, as a consequence of the difference in the sign of the partial derivative 

<math display="inline" id="Normal_(geometry):19">
 <semantics>
  <mrow>
   <mrow>
    <mo>∂</mo>
    <mi>F</mi>
   </mrow>
   <mo>/</mo>
   <mrow>
    <mo>∂</mo>
    <mi>z</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <partialdiff></partialdiff>
     <ci>F</ci>
    </apply>
    <apply>
     <partialdiff></partialdiff>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial{F}/\partial{z}
  </annotation>
 </semantics>
</math>

.) The second way of obtaining the normal follows directly from the gradient of the explicit form,</p>

<p>

<math display="block" id="Normal_(geometry):20">
 <semantics>
  <mrow>
   <mrow>
    <mo>∇</mo>
    <mi>f</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-∇</ci>
     <ci>f</ci>
    </apply>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla f(x,y)
  </annotation>
 </semantics>
</math>

; <a href="by_inspection" title="wikilink">by inspection</a>,</p>

<p>

<math display="block" id="Normal_(geometry):21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∇</mo>
     <mi>F</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mover accent="true">
     <mi>𝐤</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo>-</mo>
    <mrow>
     <mrow>
      <mo>∇</mo>
      <mi>f</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-∇</ci>
      <ci>F</ci>
     </apply>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>z</ci>
     </vector>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <ci>normal-^</ci>
      <ci>𝐤</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-∇</ci>
       <ci>f</ci>
      </apply>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla F(x,y,z)=\hat{\mathbf{k}}-\nabla f(x,y)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Normal_(geometry):22">
 <semantics>
  <mover accent="true">
   <mi>𝐤</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>𝐤</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbf{k}}
  </annotation>
 </semantics>
</math>

 is the upward <a href="unit_vector" title="wikilink">unit vector</a>. Note that this is equal to 

<math display="inline" id="Normal_(geometry):23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∇</mo>
     <mi>F</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mover accent="true">
     <mi>𝐤</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mo>-</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mrow>
        <mo>∂</mo>
        <mi>f</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <mi>x</mi>
      </mrow>
     </mfrac>
     <mover accent="true">
      <mi>𝐢</mi>
      <mo stretchy="false">^</mo>
     </mover>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mrow>
        <mo>∂</mo>
        <mi>f</mi>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo>,</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <mi>y</mi>
      </mrow>
     </mfrac>
     <mover accent="true">
      <mi>𝐣</mi>
      <mo stretchy="false">^</mo>
     </mover>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-∇</ci>
      <ci>F</ci>
     </apply>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>z</ci>
     </vector>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <ci>normal-^</ci>
      <ci>𝐤</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <partialdiff></partialdiff>
         <ci>f</ci>
        </apply>
        <interval closure="open">
         <ci>x</ci>
         <ci>y</ci>
        </interval>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <ci>normal-^</ci>
       <ci>𝐢</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <partialdiff></partialdiff>
         <ci>f</ci>
        </apply>
        <interval closure="open">
         <ci>x</ci>
         <ci>y</ci>
        </interval>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>y</ci>
       </apply>
      </apply>
      <apply>
       <ci>normal-^</ci>
       <ci>𝐣</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla F(x,y,z)=\hat{\mathbf{k}}-\frac{\partial{f(x,y)}}{\partial{x}}\hat{%
\mathbf{i}}-\frac{\partial{f(x,y)}}{\partial{y}}\hat{\mathbf{j}}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Normal_(geometry):24">
 <semantics>
  <mover accent="true">
   <mi>𝐢</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>𝐢</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbf{i}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Normal_(geometry):25">
 <semantics>
  <mover accent="true">
   <mi>𝐣</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>𝐣</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbf{j}}
  </annotation>
 </semantics>
</math>

 are the x and y unit vectors.</p>

<p>If a surface does not have a tangent plane at a point, it does not have a normal at that point either. For example, a <a href="cone_(geometry)" title="wikilink">cone</a> does not have a normal at its tip nor does it have a normal along the edge of its base. However, the normal to the cone is defined <a href="almost_everywhere" title="wikilink">almost everywhere</a>. In general, it is possible to define a normal almost everywhere for a surface that is <a href="Lipschitz_continuous" title="wikilink">Lipschitz continuous</a>.</p>
<h3 id="uniqueness-of-the-normal">Uniqueness of the normal</h3>

<p> A normal to a surface does not have a unique direction; the vector pointing in the opposite direction of a surface normal is also a surface normal. For a surface which is the <a href="boundary_(topology)" title="wikilink">topological boundary</a> of a set in three dimensions, one can distinguish between the <strong>inward-pointing normal</strong> and <strong>outer-pointing normal</strong>, which can help define the normal in a unique way. For an <a href="Orientability" title="wikilink">oriented surface</a>, the surface normal is usually determined by the <a href="right-hand_rule" title="wikilink">right-hand rule</a>. If the normal is constructed as the cross product of tangent vectors (as described in the text above), it is a <a class="uri" href="pseudovector" title="wikilink">pseudovector</a>.</p>
<h3 id="transforming-normals">Transforming normals</h3>

<p>(NOTE: in this section we only use the upper 3x3 matrix, as translation is irrelevant to the calculation)</p>

<p>When applying a transform to a surface it is often useful to derive normals for the resulting surface from the original normals.</p>

<p>Specifically, given a 3x3 transformation matrix <strong>M</strong>, we can determine the matrix <strong>W</strong> that transforms a vector <strong>n</strong> perpendicular to the tangent plane <strong>t</strong> into a vector <strong>n′</strong> perpendicular to the transformed tangent plane <strong>M t</strong>, by the following logic:</p>

<p>Write <strong>n′</strong> as <strong>W n</strong>. We must find <strong>W</strong>.</p>

<p><strong>W n</strong> perpendicular to <strong>M t</strong></p>

<p>

<math display="block" id="Normal_(geometry):26">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⇔</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>W</mi>
       <mi>n</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>⋅</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>M</mi>
       <mi>t</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <times></times>
       <ci>W</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>M</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \iff(Wn)\cdot(Mt)=0
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Normal_(geometry):27">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⇔</mo>
   <mrow>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>W</mi>
        <mi>n</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>T</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>M</mi>
       <mi>t</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <ci>W</ci>
        <ci>n</ci>
       </apply>
       <ci>T</ci>
      </apply>
      <apply>
       <times></times>
       <ci>M</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \iff(Wn)^{T}(Mt)=0
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Normal_(geometry):28">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⇔</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>n</mi>
        <mi>T</mi>
       </msup>
       <msup>
        <mi>W</mi>
        <mi>T</mi>
       </msup>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>M</mi>
       <mi>t</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <ci>T</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>W</ci>
        <ci>T</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>M</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \iff(n^{T}W^{T})(Mt)=0
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Normal_(geometry):29">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⇔</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>n</mi>
      <mi>T</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>W</mi>
        <mi>T</mi>
       </msup>
       <mi>M</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>t</mi>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <ci>T</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>W</ci>
        <ci>T</ci>
       </apply>
       <ci>M</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \iff n^{T}(W^{T}M)t=0
  </annotation>
 </semantics>
</math>

</p>

<p>Clearly choosing <strong>W</strong> s.t. 

<math display="inline" id="Normal_(geometry):30">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>W</mi>
     <mi>T</mi>
    </msup>
    <mi>M</mi>
   </mrow>
   <mo>=</mo>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>W</ci>
      <ci>T</ci>
     </apply>
     <ci>M</ci>
    </apply>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{T}M=I
  </annotation>
 </semantics>
</math>

, or 

<math display="inline" id="Normal_(geometry):31">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mo>=</mo>
   <mmultiscripts>
    <mi>M</mi>
    <none></none>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <none></none>
    <mi>T</mi>
   </mmultiscripts>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>W</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>M</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W={M^{-1}}^{T}
  </annotation>
 </semantics>
</math>

 will satisfy the above equation, giving a 

<math display="inline" id="Normal_(geometry):32">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>W</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Wn
  </annotation>
 </semantics>
</math>

 perpendicular to 

<math display="inline" id="Normal_(geometry):33">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>M</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Mt
  </annotation>
 </semantics>
</math>

, or an <strong>n′</strong> perpendicular to <strong>t′</strong>, as required.</p>

<p>So use the inverse transpose of the linear transformation when transforming surface normals. Also note that the inverse transpose is equal to the original matrix if the matrix is orthonormal, i.e. purely rotational with no scaling or shearing.</p>
<h2 id="hypersurfaces-in-n-dimensional-space">Hypersurfaces in <em>n</em>-dimensional space</h2>

<p>The definition of a normal to a surface in three-dimensional space can be extended to 

<math display="inline" id="Normal_(geometry):34">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n-1)
  </annotation>
 </semantics>
</math>

-dimensional <a href="hypersurface" title="wikilink">hypersurfaces</a> in a 

<math display="inline" id="Normal_(geometry):35">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

-dimensional space. A <em>hypersurface</em> may be <a href="Local_property" title="wikilink">locally</a> defined implicitly as the set of points 

<math display="inline" id="Normal_(geometry):36">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle(x_{1},x_{2},\ldots,x_{n})
  </annotation>
 </semantics>
</math>

 satisfying an equation 

<math display="inline" id="Normal_(geometry):37">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle F(x_{1},x_{2},\ldots,x_{n})=0
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Normal_(geometry):38">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is a given <a href="Scalar_field" title="wikilink">scalar function</a>. If 

<math display="inline" id="Normal_(geometry):39">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is <a href="continuously_differentiable" title="wikilink">continuously differentiable</a> then the hypersurface is a <a href="differentiable_manifold" title="wikilink">differentiable manifold</a> in the <a class="uri" href="neighbourhood" title="wikilink">neighbourhood</a> of the points where the <a class="uri" href="gradient" title="wikilink">gradient</a> is not null. At these points the <strong>normal vector space</strong> has dimension one and is generated by the gradient</p>

<p>

<math display="block" id="Normal_(geometry):40">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>∇</mo>
      <mi>F</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mstyle displaystyle="false">
      <mfrac>
       <mrow>
        <mo>∂</mo>
        <mi>F</mi>
       </mrow>
       <mrow>
        <mo>∂</mo>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
       </mrow>
      </mfrac>
     </mstyle>
     <mo>,</mo>
     <mstyle displaystyle="false">
      <mfrac>
       <mrow>
        <mo>∂</mo>
        <mi>F</mi>
       </mrow>
       <mrow>
        <mo>∂</mo>
        <msub>
         <mi>x</mi>
         <mn>2</mn>
        </msub>
       </mrow>
      </mfrac>
     </mstyle>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mstyle displaystyle="false">
      <mfrac>
       <mrow>
        <mo>∂</mo>
        <mi>F</mi>
       </mrow>
       <mrow>
        <mo>∂</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
       </mrow>
      </mfrac>
     </mstyle>
     <mo rspace="4.2pt">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-∇</ci>
      <ci>F</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <vector>
     <apply>
      <divide></divide>
      <apply>
       <partialdiff></partialdiff>
       <ci>F</ci>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <partialdiff></partialdiff>
       <ci>F</ci>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <divide></divide>
      <apply>
       <partialdiff></partialdiff>
       <ci>F</ci>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla F(x_{1},x_{2},\ldots,x_{n})=\left(\tfrac{\partial F}{\partial x_{1}},%
\tfrac{\partial F}{\partial x_{2}},\ldots,\tfrac{\partial F}{\partial x_{n}}%
\right)\,.
  </annotation>
 </semantics>
</math>

</p>

<p>The <strong>normal line</strong> at a point of the hypersurface is defined only if the gradient is not null. It is the line passing through the point and having the gradient as direction.</p>
<h2 id="varieties-defined-by-implicit-equations-in-n-dimensional-space">Varieties defined by implicit equations in <em>n</em>-dimensional space</h2>

<p>A <strong><a href="analytic_variety" title="wikilink">differential variety</a></strong> defined by implicit equations in the <em>n</em>-dimensional space is the set of the common zeros of a finite set of differential functions in <em>n</em> variables</p>

<p>

<math display="block" id="Normal_(geometry):41">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>f</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">1</cn>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>k</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{1}(x_{1},\ldots,x_{n}),\ldots,f_{k}(x_{1},\ldots,x_{n}).
  </annotation>
 </semantics>
</math>

 The <a href="Jacobian_matrix" title="wikilink">Jacobian matrix</a> of the variety is the <em>k</em>×<em>n</em> matrix whose <em>i</em>-th row is the gradient of <em>f</em><sub><em>i</em></sub>. By <a href="implicit_function_theorem" title="wikilink">implicit function theorem</a>, the variety is a <a class="uri" href="manifold" title="wikilink">manifold</a> in the neighborhood of a point of it where the Jacobian matrix has rank <em>k</em>. At such a point <em>P</em>, the <strong>normal vector space</strong> is the vector space generated by the values at <em>P</em> of the gradient vectors of the <em>f</em><sub><em>i</em></sub>.</p>

<p>In other words, a variety is defined as the intersection of <em>k</em> hypersurfaces, and the normal vector space at a point is the vector space generated by the normal vectors of the hypersurfaces at the point.</p>

<p>The <strong>normal (affine) space</strong> at a point <em>P</em> of the variety is the <a href="affine_subspace" title="wikilink">affine subspace</a> passing through <em>P</em> and generated by the normal vector space at <em>P</em>.</p>

<p>These definitions may be extended <em>verbatim</em> to the points where the variety is not a manifold.</p>
<h3 id="example">Example</h3>

<p>Let <em>V</em> be the variety defined in the 3-dimensional space by the equations</p>

<p>

<math display="block" id="Normal_(geometry):42">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mpadded width="+1.7pt">
      <mi>x</mi>
     </mpadded>
     <mi>y</mi>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mi>z</mi>
    <mo>=</mo>
    <mn>0 .</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <eq></eq>
     <ci>z</ci>
     <cn type="float">0 .</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\,y=0,\quad z=0\,.
  </annotation>
 </semantics>
</math>

 This variety is the union of the <em>x</em>-axis and the <em>y</em>-axis.</p>

<p>At a point (<em>a</em>, 0, 0) where <em>a</em>≠0, the rows of the Jacobian matrix are (0, 0, 1) and (0, <em>a</em>, 0). Thus the normal affine space is the plane of equation <em>x</em>=<em>a</em>. Similarly, if <em>b</em>≠0, the normal plane at (0, <em>b</em>, 0) is the plane of equation <em>y</em>=<em>b</em>.</p>

<p>At the point (0, 0, 0) the rows of the Jacobian matrix are (0, 0, 1) and (0,0,0). Thus the normal vector space and the normal affine space have dimension 1 and the normal affine space is the <em>z</em>-axis.</p>
<h2 id="uses">Uses</h2>
<ul>
<li>Surface normals are essential in defining <a href="surface_integral" title="wikilink">surface integrals</a> of <a href="vector_field" title="wikilink">vector fields</a>.</li>
<li>Surface normals are commonly used in <a href="3D_computer_graphics" title="wikilink">3D computer graphics</a> for <a class="uri" href="lighting" title="wikilink">lighting</a> calculations; see <a href="Lambert's_cosine_law" title="wikilink">Lambert's cosine law</a>.</li>
<li>Surface normals are often adjusted in <a href="3D_computer_graphics" title="wikilink">3D computer graphics</a> by <a href="normal_mapping" title="wikilink">normal mapping</a>.</li>
<li><a href="Render_layers" title="wikilink">Render layers</a> containing surface normal information may be used in <a href="Digital_compositing" title="wikilink">Digital compositing</a> to change the apparent lighting of rendered elements.</li>
</ul>
<h2 id="normal-in-geometric-optics">Normal in geometric optics</h2>
<figure><b>(Figure)</b>
<figcaption>Diagram of specular reflection</figcaption>
</figure>

<p>The <strong>normal</strong> is the line <a class="uri" href="perpendicular" title="wikilink">perpendicular</a> to the surface of an <a href="optical_medium" title="wikilink">optical medium</a> at a given point.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> In <a href="reflection_of_light" title="wikilink">reflection of light</a>, the <a href="angle_of_incidence" title="wikilink">angle of incidence</a> and the <a href="angle_of_reflection" title="wikilink">angle of reflection</a> are respectively the angle between the normal and the <a href="incident_ray" title="wikilink">incident ray</a> (on the <a href="plane_of_incidence" title="wikilink">plane of incidence</a>) and the angle between the normal and the <a href="reflected_ray" title="wikilink">reflected ray</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Pseudovector" title="wikilink">Pseudovector</a></li>
<li><a href="Dual_space" title="wikilink">Dual space</a></li>
<li><a href="Vertex_normal" title="wikilink">Vertex normal</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li>An <a href="http://msdn.microsoft.com/en-us/library/bb324491(VS.85).aspx">explanation of normal vectors</a> from Microsoft's MSDN</li>
<li>Clear pseudocode for <a href="http://www.opengl.org/wiki/Calculating_a_Surface_Normal">calculating a surface normal</a> from either a triangle or polygon.</li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Surfaces" title="wikilink">Category:Surfaces</a> <a href="Category:Vector_calculus" title="wikilink">Category:Vector calculus</a> <a href="Category:3D_computer_graphics" title="wikilink">Category:3D computer graphics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
