<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="712">K-trivial set</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>K-trivial set</h1>
<hr/>

<p></p>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, a set of natural numbers is called a <strong>K-trivial set</strong> if its <a href="Upper_set" title="wikilink">initial segments</a> viewed as binary strings are easy to describe: the prefix-free <a href="Kolmogorov_complexity" title="wikilink">Kolmogorov complexity</a> is as low as possible, close to that of a <a href="recursive_set" title="wikilink">computable set</a>. Solovay proved in 1975 that a set can be K-trivial without being computable.</p>

<p>The <a href="Schnorr–Levin_theorem" title="wikilink">Schnorr–Levin theorem</a> says that random sets have a high initial segment complexity. Thus the K-trivials are far from random. This is why these sets are studied in the field of <a href="Algorithmically_random_sequence" title="wikilink">algorithmic randomness</a>, which is a subfield of <a href="Computability_theory" title="wikilink">Computability theory</a> and related to <a href="algorithmic_information_theory" title="wikilink">algorithmic information theory</a> in <a href="computer_science" title="wikilink">computer science</a>.</p>

<p>At the same time, K-trivial sets are close to computable. For instance, they are all <a class="uri" href="superlow" title="wikilink">superlow</a>, i.e. sets whose <a href="Turing_jump" title="wikilink">Turing jump</a> is computable from the <a href="Halting_problem" title="wikilink">Halting problem</a>, and form a <a href="Turing_ideal" title="wikilink">Turing ideal</a>, i.e. class of sets closed under <a href="Turing_join" title="wikilink">Turing join</a> and closed downward under <a href="Turing_reduction" title="wikilink">Turing reduction</a>.</p>
<h2 id="definition">Definition</h2>

<p>Let K be the prefix-free <a href="Kolmogorov_Complexity" title="wikilink">Kolmogorov Complexity</a>, i.e. given a string x, K(x) outputs the least length of the input string under a <a href="prefix-free_universal_machine" title="wikilink">prefix-free universal machine</a>. Such a machine, intuitively, represents a universal programming language with the property that no valid program can be obtained as a proper extension of another valid program. For more background of K, see e.g. <a href="Chaitin's_constant" title="wikilink">Chaitin's constant</a>.</p>

<p>We say a set A of the <a href="natural_numbers" title="wikilink">natural numbers</a> is K-trivial via a constant b ∈ ℕ if</p>

<p>

<math display="block" id="K-trivial_set:0">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>n</mi>
   <mi>K</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>↾</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≤</mo>
   <mi>K</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <csymbol cd="unknown">K</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-↾</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <leq></leq>
    <csymbol cd="unknown">K</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <csymbol cd="unknown">b</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall nK(A\upharpoonright n)\leq K(n)+b
  </annotation>
 </semantics>
</math>

.</p>

<p>A set is K-trivial if it is K-trivial via some constant.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="brief-history-and-development">Brief history and development</h2>

<p>In the early days of the development of K-triviality, attention was paid to separation of K-trivial sets and <a href="Recursive_set" title="wikilink">computable sets</a>.</p>

<p>Chaitin in his 1976 paper <ref>Gregory J. Chaitin (1976),</ref></p>

<p><code>   "Information-Theoretic Characterizations of Recursive Infinite Strings",</code><br/>
<code>   Theoretical Computer Science</code></p>

<p>Volume 2, Issue 1, June 1976, Pages 45–48 mainly studied sets such that there exists b ∈ℕ with</p>

<p>

<math display="block" id="K-trivial_set:1">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>n</mi>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>↾</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≤</mo>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-↾</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <leq></leq>
    <csymbol cd="unknown">C</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <csymbol cd="unknown">b</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall nC(A\upharpoonright n)\leq C(n)+b
  </annotation>
 </semantics>
</math>

</p>

<p>where C denotes the plain <a href="Kolmogorov_complexity" title="wikilink">Kolmogorov complexity</a>. These sets are known as C-trivial sets. Chaitin showed they coincide with the computable sets. He also showed that the K-trivials are computable in the <a href="halting_problem" title="wikilink">halting problem</a>. This class of sets is commonly known as 

<math display="inline" id="K-trivial_set:2">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Δ</mi>
   <mn>2</mn>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Δ</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta_{2}^{0}
  </annotation>
 </semantics>
</math>

 sets in <a href="arithmetical_hierarchy" title="wikilink">arithmetical hierarchy</a>.</p>

<p><a href="Robert_M._Solovay" title="wikilink">Robert M. Solovay</a> was the first to construct a noncomputable K-trivial set, while construction of a computably enumerable such A was attempted by <a href="Cristian_S._Calude" title="wikilink">Calude</a>, Coles <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and other unpublished constructions by Kummer of a K-trivial, and Muchnik junior of a low for K set.</p>
<h3 id="developments-19992008">Developments 1999–2008</h3>

<p>In the context of computability theory, a cost function is a computable function</p>

<p>

<math display="block" id="K-trivial_set:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mi>ℕ</mi>
      <mo>×</mo>
      <mi>ℕ</mi>
     </mrow>
     <mo>→</mo>
     <msup>
      <mi>ℚ</mi>
      <mrow>
       <mi></mi>
       <mo>≥</mo>
       <mn>0</mn>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>c</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>ℕ</ci>
      <ci>ℕ</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℚ</ci>
      <apply>
       <geq></geq>
       <csymbol cd="latexml">absent</csymbol>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c:\mathbb{N}\times\mathbb{N}\to\mathbb{Q}^{\geq 0}.
  </annotation>
 </semantics>
</math>

</p>

<p>For a computable approximation 

<math display="inline" id="K-trivial_set:4">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <msub>
    <mi>A</mi>
    <mi>s</mi>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-⟨⟩</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle A_{s}\rangle
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="K-trivial_set:5">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Δ</mi>
   <mn>2</mn>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Δ</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta_{2}^{0}
  </annotation>
 </semantics>
</math>

 set <em>A</em>, such a function measures the cost <em>c</em>(<em>n</em>,<em>s</em>) of changing the approximation to A(n) at stage s. The first <a href="cost_function" title="wikilink">cost function</a> construction was due to Kučera and Terwijn.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> They built a <a href="computably_enumerable" title="wikilink">computably enumerable</a> set that is low for Martin-Löf-randomness but not computable. Their cost function was adaptive, in that the definition of the cost function depends on the computable approximation of the 

<math display="inline" id="K-trivial_set:6">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Δ</mi>
   <mn>2</mn>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Δ</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta_{2}^{0}
  </annotation>
 </semantics>
</math>

 set being built.</p>

<p>A cost function construction of a K-trivial <a href="computably_enumerable" title="wikilink">computably enumerable</a> noncomputable set first appeared in Downey et al.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>We say a 

<math display="inline" id="K-trivial_set:7">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Δ</mi>
   <mn>2</mn>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Δ</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta_{2}^{0}
  </annotation>
 </semantics>
</math>

 set <em>A</em> obeys a cost function <em>c</em> if there exists a computable approximation of A, 

<math display="inline" id="K-trivial_set:8">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mrow>
    <msub>
     <mi>A</mi>
     <mi>s</mi>
    </msub>
    <mo>:</mo>
    <mrow>
     <mi>s</mi>
     <mo>∈</mo>
     <mi>ω</mi>
    </mrow>
   </mrow>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-⟨⟩</csymbol>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <in></in>
      <ci>s</ci>
      <ci>ω</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle A_{s}:s\in\omega\rangle
  </annotation>
 </semantics>
</math>


 

<math display="inline" id="K-trivial_set:9">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>K</mi>
     <mi>s</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>σ</mi>
       <mo stretchy="false">|</mo>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>𝕌</mi>
         <mi>s</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>σ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>=</mo>
       <mi>x</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <ci>s</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <min></min>
     <apply>
      <ci>normal-:</ci>
      <apply>
       <abs></abs>
       <ci>σ</ci>
      </apply>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝕌</ci>
         <ci>s</ci>
        </apply>
        <ci>σ</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{s}(x)=\min\{|\sigma|:\mathbb{U}_{s}(\sigma)=x\}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="K-trivial_set:10">
 <semantics>
  <msub>
   <mi>𝕌</mi>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝕌</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{U}_{s}
  </annotation>
 </semantics>
</math>

</p>

<p>and 

<math display="inline" id="K-trivial_set:11">
 <semantics>
  <mi>𝕌</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝕌</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{U}
  </annotation>
 </semantics>
</math>

 is the <em>s</em>-th step in a computable approximation of a fixed universal prefix-free machine 

<math display="block" id="K-trivial_set:12">
 <semantics>
  <mrow>
   <mi>P</mi>
   <msub>
    <mi>S</mi>
    <mi>e</mi>
   </msub>
   <mo>:</mo>
   <mo stretchy="false">|</mo>
   <msub>
    <mi>W</mi>
    <mi>e</mi>
   </msub>
   <mo stretchy="false">|</mo>
   <mo>=</mo>
   <mi mathvariant="normal">∞</mi>
   <mo>⇒</mo>
   <mo>∃</mo>
   <mi>s</mi>
   <mo>∃</mo>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <msub>
     <mi>W</mi>
     <mrow>
      <mi>e</mi>
      <mo>,</mo>
      <mi>s</mi>
     </mrow>
    </msub>
    <mo>\</mo>
    <msub>
     <mi>W</mi>
     <mrow>
      <mi>e</mi>
      <mo>,</mo>
      <mrow>
       <mi>s</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </mrow>
    </msub>
    <mo>∧</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <msub>
     <mi>A</mi>
     <mi>s</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>e</ci>
    </apply>
    <ci>normal-:</ci>
    <ci>normal-|</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <ci>e</ci>
    </apply>
    <ci>normal-|</ci>
    <eq></eq>
    <infinity></infinity>
    <ci>normal-⇒</ci>
    <exists></exists>
    <csymbol cd="unknown">s</csymbol>
    <exists></exists>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <list>
       <ci>e</ci>
       <ci>s</ci>
      </list>
     </apply>
     <ci>normal-\</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <list>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <ci>s</ci>
        <cn type="integer">1</cn>
       </apply>
      </list>
     </apply>
     <and></and>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>s</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   PS_{e}:|W_{e}|=\infty\Rightarrow\exists s\exists x[x\in W_{e,s}\backslash W_{e%
,s-1}\wedge x\in A_{s}]
  </annotation>
 </semantics>
</math>

.</p>
<h4 id="sketch-of-the-construction-of-a-non-computable-k-trivial-set">Sketch of the construction of a non-computable K-trivial set</h4>

<p>In fact the set can be made <a href="promptly_simple" title="wikilink">promptly simple</a>. The idea is to meet the prompt simplicity requirements,</p>

<p>

<math display="block" id="K-trivial_set:13">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo movablelimits="false">lim</mo>
     <mi>x</mi>
    </munder>
    <mrow>
     <munder>
      <mo movablelimits="false">sup</mo>
      <mrow>
       <mi>s</mi>
       <mo>></mo>
       <mi>x</mi>
      </mrow>
     </munder>
     <mrow>
      <mi>c</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <ci>x</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">supremum</csymbol>
       <apply>
        <gt></gt>
        <ci>s</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>c</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>s</ci>
       </interval>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lim_{x}\sup_{s>x}c(x,s)=0
  </annotation>
 </semantics>
</math>

</p>

<p>as well as to keep the costs low. We need the cost function to satisfy the <strong>limit condition</strong></p>

<p>

<math display="inline" id="K-trivial_set:14">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

</p>

<p>namely the supremum over stages of the cost for x goes to 0 as x increases. For instance, the <a href="standard_cost_function" title="wikilink">standard cost function</a> has this property. The construction essentially waits until the cost is low before putting numbers into 

<math display="inline" id="K-trivial_set:15">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mrow>
    <msub>
     <mi>A</mi>
     <mi>s</mi>
    </msub>
    <mo>:</mo>
    <mrow>
     <mi>s</mi>
     <mo>∈</mo>
     <mi>ω</mi>
    </mrow>
   </mrow>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-⟨⟩</csymbol>
    <apply>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <in></in>
      <ci>s</ci>
      <ci>ω</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle A_{s}:s\in\omega\rangle
  </annotation>
 </semantics>
</math>

 to meet the promptly simple requirements. We define a computable enumeration 

<math display="inline" id="K-trivial_set:16">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mi mathvariant="normal">∅</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <cn type="integer">0</cn>
    </apply>
    <emptyset></emptyset>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{0}=\emptyset
  </annotation>
 </semantics>
</math>

 such that</p>

<p>

<math display="inline" id="K-trivial_set:17">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mrow>
    <msub>
     <mi>W</mi>
     <mrow>
      <mi>e</mi>
      <mo>,</mo>
      <mi>s</mi>
     </mrow>
    </msub>
    <mo>\</mo>
    <msub>
     <mi>W</mi>
     <mrow>
      <mi>e</mi>
      <mo>,</mo>
      <mrow>
       <mi>s</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <ci>normal-\</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <list>
       <ci>e</ci>
       <ci>s</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <list>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <ci>s</ci>
        <cn type="integer">1</cn>
       </apply>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in W_{e,s}\backslash W_{e,s-1}
  </annotation>
 </semantics>
</math>

. At stage <em>s</em>&gt; 0 , for each <em>e</em> PS_e has not been met yet and there exists <em>x</em> ≥ 2<em>e</em> such that 

<math display="inline" id="K-trivial_set:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo>-</mo>
     <mi>e</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>c</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>s</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(x,s)\leq 2^{-e}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="K-trivial_set:19">
 <semantics>
  <msub>
   <mi>A</mi>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>A</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{s}
  </annotation>
 </semantics>
</math>

, then we put <em>x</em> into 

<math display="inline" id="K-trivial_set:20">
 <semantics>
  <mrow>
   <mi>P</mi>
   <msub>
    <mi>S</mi>
    <mi>e</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   PS_{e}
  </annotation>
 </semantics>
</math>

 and declare that 

<math display="block" id="K-trivial_set:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi mathvariant="normal">Σ</mi>
      <mi>e</mi>
     </msub>
     <msup>
      <mn>2</mn>
      <mrow>
       <mo>-</mo>
       <mi>e</mi>
      </mrow>
     </msup>
    </mrow>
    <mo><</mo>
    <mi mathvariant="normal">∞</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <ci>e</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <ci>e</ci>
      </apply>
     </apply>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{e}2^{-e}<\infty.
  </annotation>
 </semantics>
</math>

 is met. End of construction.</p>

<p>To verify that the construction works, note first that <em>A</em> obeys the cost function since at most one number enters <em>A</em> for the sake of each requirement. The sum <em>S</em> is therefore at most</p>

<p>

<math display="inline" id="K-trivial_set:22">
 <semantics>
  <msub>
   <mi>W</mi>
   <mi>e</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>W</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{e}
  </annotation>
 </semantics>
</math>

</p>

<p>Secondly, each requirement is met: if 

<math display="block" id="K-trivial_set:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>∀</mo>
      <mrow>
       <mi>n</mi>
       <msup>
        <mi>K</mi>
        <mi>A</mi>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mi>b</mi>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <mi>K</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <ci>n</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>K</ci>
        <ci>A</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>b</ci>
    </apply>
    <apply>
     <times></times>
     <ci>K</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall nK^{A}(n)+b\geq K(n).
  </annotation>
 </semantics>
</math>

 is infinite, by the fact that the cost function satisfies the limit condition, some number will eventually be enumerated into A to meet the requirement.</p>
<h4 id="equivalent-characterizations">Equivalent characterizations</h4>

<p>K-triviality turns out to coincide with some computational lowness notions, saying that a set is close to computable. The following notions capture the same class of sets. <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h5 id="lowness-for-k">Lowness for <em>K</em></h5>

<p>We say that <em>A</em> is low for <em>K</em> if there is <em>b</em> ∈ ℕ such that</p>

<p>

<math display="inline" id="K-trivial_set:24">
 <semantics>
  <msup>
   <mi>K</mi>
   <mi>A</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>K</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K^{A}
  </annotation>
 </semantics>
</math>

</p>

<p>Here 

<math display="inline" id="K-trivial_set:25">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is prefix-free <a href="Kolmogorov_complexity" title="wikilink">Kolmogorov complexity</a> relative to oracle <span class="LaTeX">$A$</span>.</p>
<h5 id="lowness-for-martin-löf-randomness">Lowness for Martin-Löf-randomness</h5>

<p>A is low for Martin-Löf-randomness<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> if whenever Z is <a href="Algorithmically_random_sequence" title="wikilink">Martin-Löf random</a>, it is already <a href="Algorithmically_random_sequence" title="wikilink">Martin-Löf random</a> relative to <em>A</em>.</p>
<h5 id="base-for-martin-löf-randomness">Base for Martin-Löf-randomness</h5>

<p><em>A</em> is a base for Martin-Löf-randomness if <em>A</em> is <a href="Turing_reduction" title="wikilink">Turing reducible</a> to <em>Z</em> for some set <em>Z</em> that is <a href="Algorithmically_random_sequence" title="wikilink">Martin-Löf random</a> relative to <em>A</em>.</p>

<p><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>More equivalent characterizations of K-triviality have been studied, such as:</p>
<ol>
<li>Lowness for weakly-2-randomness;</li>
<li>Lowness for difference-left-c.e. reals (notice here no randomness is mentioned).</li>
</ol>
<h3 id="developments-after-2008">Developments after 2008</h3>

<p>From 2009 on, concepts from analysis entered the stage. This helped solving some notorious problems.</p>

<p>One says that a set Y is a positive density point if every effectively closed class containing Y has positive lower Lebesgue density at Y. Bienvenu Hölzl Miller and Nies <a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> showed that a ML-random is Turing incomplete iff it is a positive density point. Day and Miller (2012) <a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> used this for an affirmative answer to the ML-cupping problem:<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> A is K-trivial iff for every Martin-Löf random set Z such that A⊕Z compute the <a href="halting_problem" title="wikilink">halting problem</a>, already Z by itself computes the <a href="halting_problem" title="wikilink">halting problem</a>.</p>

<p>One says that a set Y is a density-one point if every effectively closed class containing Y has Lebesgue density 1 at Y. Any Martin-Löf random set that is not a density-one point computes every K trivial set by Bienvenu et al.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> Day and Miller (2012) showed that there is Martin-Löf random set which is a positive density point but not a density one point. Thus there is an incomplete such Martin-Löf random set which computes every K-trivial set. This affirmatively answered the <a href="covering_problem" title="wikilink">covering problem</a> first asked by Stephan and then published by Miller and Nies.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> For a summary see L. Bienvenu, A. Day, N. Greenberg, A. Kucera, J. Miller, A. Nies, and D. Turetsky <a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Variants of K-triviality have been studied: <a href="Schnorr_trivial_sets" title="wikilink">Schnorr trivial sets</a> where the machines have domain with computable measure; <a href="strongly_jump_traceable_sets" title="wikilink">strongly jump traceable sets</a>, a lowness property of sets far inside K-triviality.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Computability_theory" title="wikilink">Category:Computability theory</a> <a href="Category:Algorithmic_information_theory" title="wikilink">Category:Algorithmic information theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">A. Nies (2009). Computability and Randomness, Oxford Science Publications, ISBN 978-0199230761<a href="#fnref1">↩</a></li>
<li id="fn2">Downey, Rodney G., Hirschfeldt, Denis R. (2010), "Algorithmic Randomness and Complexity", ISBN 978-0-387-68441-3<a href="#fnref2">↩</a></li>
<li id="fn3">Cristian Calude, Richard J. Coles, Program-Size Complexity of Initial Segments and Domination Reducibility, (1999), proceeding of: Jewels are Forever, Contributions on Theoretical Computer Science in Honor of Arto Salomaa<a href="#fnref3">↩</a></li>
<li id="fn4">Antonin Kučera and Sebastiaan A. Terwijn (1999), "Lowness for the Class of Random Sets", The Journal of Symbolic Logic Vol. 64, No. 4 (Dec., 1999), pp. 1396–1402<a href="#fnref4">↩</a></li>
<li id="fn5">Rod G. Downey, Denis R. Hirschfeldt, Andr ́e Nies, Frank Stephan, "Trivial Reals", Electronic Notes in Theoretical Computer Science 66 No. 1 (2002), URL: <a class="uri" href="http://www.elsevier.nl/locate/entcs/volume66.html">http://www.elsevier.nl/locate/entcs/volume66.html</a><a href="#fnref5">↩</a></li>
<li id="fn6">André Nies, (2005), "Lowness properties and randomness", Advances in Mathematics Volume 197, Issue 1, 20 October 2005, Pages 274–305<a href="#fnref6">↩</a></li>
<li id="fn7">Antonin Kučera and Sebastiaan A. Terwijn (1999), "Lowness for the Class of Random Sets", <em>The Journal of Symbolic Logic</em>, Vol. 64, No. 4 (Dec., 1999), pp. 1396–1402<a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9">Laurent Bienvenu, Rupert Hölzl, Joseph S. Miller, and André Nies, (2012), "The Denjoy alternative for computable functions", Proceedings of the 29th International Symposium on Theoretical Aspects of Computer Science (STACS 2012), volume 14 of Leibniz International Proceedings in Informatics, pages 543–554. Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik, 2012.<a href="#fnref9">↩</a></li>
<li id="fn10">J. Miller, A. Day. (2012) "Cupping with random sets", To appear in the Proceedings of the American Mathematical Society<a href="#fnref10">↩</a></li>
<li id="fn11">Miller and Nies, Randomness and computability: Open questions. Bull. Symb. Logic. 12 no 3 (2006) 390-410<a href="#fnref11">↩</a></li>
<li id="fn12">Bienvenu, Greenberg, Kucera, Nies and Turetsky, "K-Triviality, Oberwolfach Randomness, and Differentiability", Mathematisches Forschungsinstitut Oberwolfach, Oberwolfach Preprints (OWP), ISSN 1864-7596<a href="#fnref12">↩</a></li>
<li id="fn13">Miller and Nies, Randomness and computability: Open questions. Bull. Symb. Logic. 12 no 3 (2006) 390–410<a href="#fnref13">↩</a></li>
<li id="fn14">Computing K-trivial sets by incomplete random sets. Bull. Symbolic Logic. 20, March 2014, pp 80-90.<a href="#fnref14">↩</a></li>
</ol>
</section>
</body>
</html>
