<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="232">Series acceleration</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Series acceleration</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, <strong>series acceleration</strong> is one of a collection of <a href="sequence_transformation" title="wikilink">sequence transformations</a> for improving the <a href="rate_of_convergence" title="wikilink">rate of convergence</a> of a <a href="series_(mathematics)" title="wikilink">series</a>. Techniques for series acceleration are often applied in <a href="numerical_analysis" title="wikilink">numerical analysis</a>, where they are used to improve the speed of <a href="numerical_integration" title="wikilink">numerical integration</a>. Series acceleration techniques may also be used, for example, to obtain a variety of identities on <a href="special_functions" title="wikilink">special functions</a>. Thus, the <a href="Euler_transform" title="wikilink">Euler transform</a> applied to the <a href="hypergeometric_series" title="wikilink">hypergeometric series</a> gives some of the classic, well-known hypergeometric series identities.</p>
<h2 id="definition">Definition</h2>

<p>Given a sequence</p>

<p>

<math display="block" id="Series_acceleration:0">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">{</mo>
     <msub>
      <mi>s</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mo>‚àà</mo>
     <mi class="ltx_font_mathcaligraphic">ùí©</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>n</ci>
      </apply>
     </set>
     <apply>
      <in></in>
      <ci>n</ci>
      <ci>ùí©</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\{s_{n}\}_{n\in\mathcal{N}}
  </annotation>
 </semantics>
</math>

</p>

<p>having a limit</p>

<p>

<math display="block" id="Series_acceleration:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munder>
      <mo movablelimits="false">lim</mo>
      <mrow>
       <mi>n</mi>
       <mo>‚Üí</mo>
       <mi mathvariant="normal">‚àû</mi>
      </mrow>
     </munder>
     <msub>
      <mi>s</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mi mathvariant="normal">‚Ñì</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-‚Üí</ci>
       <ci>n</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <ci>normal-‚Ñì</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lim_{n\to\infty}s_{n}=\ell,
  </annotation>
 </semantics>
</math>

</p>

<p>an accelerated series is a second sequence</p>

<p>

<math display="block" id="Series_acceleration:2">
 <semantics>
  <mrow>
   <msup>
    <mi>S</mi>
    <mo>‚Ä≤</mo>
   </msup>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">{</mo>
     <msubsup>
      <mi>s</mi>
      <mi>n</mi>
      <mo>‚Ä≤</mo>
     </msubsup>
     <mo stretchy="false">}</mo>
    </mrow>
    <mrow>
     <mi>n</mi>
     <mo>‚àà</mo>
     <mi class="ltx_font_mathcaligraphic">ùí©</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>normal-‚Ä≤</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>s</ci>
        <ci>normal-‚Ä≤</ci>
       </apply>
       <ci>n</ci>
      </apply>
     </set>
     <apply>
      <in></in>
      <ci>n</ci>
      <ci>ùí©</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{\prime}=\{s^{\prime}_{n}\}_{n\in\mathcal{N}}
  </annotation>
 </semantics>
</math>

</p>

<p>which <strong>converges faster</strong> to 

<math display="inline" id="Series_acceleration:3">
 <semantics>
  <mi mathvariant="normal">‚Ñì</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-‚Ñì</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell
  </annotation>
 </semantics>
</math>

 than the original sequence, in the sense that</p>

<p>

<math display="block" id="Series_acceleration:4">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mo movablelimits="false">lim</mo>
     <mrow>
      <mi>n</mi>
      <mo>‚Üí</mo>
      <mi mathvariant="normal">‚àû</mi>
     </mrow>
    </munder>
    <mfrac>
     <mrow>
      <msubsup>
       <mi>s</mi>
       <mi>n</mi>
       <mo>‚Ä≤</mo>
      </msubsup>
      <mo>-</mo>
      <mi mathvariant="normal">‚Ñì</mi>
     </mrow>
     <mrow>
      <msub>
       <mi>s</mi>
       <mi>n</mi>
      </msub>
      <mo>-</mo>
      <mi mathvariant="normal">‚Ñì</mi>
     </mrow>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-‚Üí</ci>
       <ci>n</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>s</ci>
         <ci>normal-‚Ä≤</ci>
        </apply>
        <ci>n</ci>
       </apply>
       <ci>normal-‚Ñì</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>s</ci>
        <ci>n</ci>
       </apply>
       <ci>normal-‚Ñì</ci>
      </apply>
     </apply>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lim_{n\to\infty}\frac{s^{\prime}_{n}-\ell}{s_{n}-\ell}=0.
  </annotation>
 </semantics>
</math>

</p>

<p>If the original sequence is <a href="Divergent_series" title="wikilink">divergent</a>, the <a href="sequence_transformation" title="wikilink">sequence transformation</a> acts as an <a href="extrapolation_method" title="wikilink">extrapolation method</a> to the <a class="uri" href="antilimit" title="wikilink">antilimit</a> 

<math display="inline" id="Series_acceleration:5">
 <semantics>
  <mi mathvariant="normal">‚Ñì</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-‚Ñì</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ell
  </annotation>
 </semantics>
</math>

.</p>

<p>The mappings from the original to the transformed series may be linear (as defined in the article <a href="sequence_transformation" title="wikilink">sequence transformations</a>), or non-linear. In general, the non-linear sequence transformations tend to be more powerful.</p>
<h2 id="overview">Overview</h2>

<p>Two classical techniques for series acceleration are <a href="Euler's_transformation_of_series" title="wikilink">Euler's transformation of series</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and <a href="Kummer's_transformation_of_series" title="wikilink">Kummer's transformation of series</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> A variety of much more rapidly convergent and special-case tools have been developed in the 20th century, including <a href="Richardson_extrapolation" title="wikilink">Richardson extrapolation</a>, introduced by <a href="Lewis_Fry_Richardson" title="wikilink">Lewis Fry Richardson</a> in the early 20th century but also known and used by <a href="Takebe_Kenko" title="wikilink">Katahiro Takebe</a> in 1722, the <a href="Aitken_delta-squared_process" title="wikilink">Aitken delta-squared process</a>, introduced by <a href="Alexander_Aitken" title="wikilink">Alexander Aitken</a> in 1926 but also known and used by <a href="Takakazu_Seki" title="wikilink">Takakazu Seki</a> in the 18th century, the <a href="epsilon_algorithm" title="wikilink">epsilon algorithm</a> given by <a href="Peter_Wynn_(mathematician)" title="wikilink">Peter Wynn</a> in 1956, the <a href="Levin_u-transform" title="wikilink">Levin u-transform</a>, and the <a href="Wilf-Zeilberger-Ekhad_method" title="wikilink">Wilf-Zeilberger-Ekhad method</a> or <a href="WZ_theory" title="wikilink">WZ method</a>.</p>

<p>For alternating series, several powerful techniques, offering convergence rates from 

<math display="inline" id="Series_acceleration:6">
 <semantics>
  <msup>
   <mn>5.828</mn>
   <mrow>
    <mo>-</mo>
    <mi>n</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="float">5.828</cn>
    <apply>
     <minus></minus>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   5.828^{-n}
  </annotation>
 </semantics>
</math>

 all the way to 

<math display="inline" id="Series_acceleration:7">
 <semantics>
  <msup>
   <mn>17.93</mn>
   <mrow>
    <mo>-</mo>
    <mi>n</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="float">17.93</cn>
    <apply>
     <minus></minus>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   17.93^{-n}
  </annotation>
 </semantics>
</math>

 for a summation of 

<math display="inline" id="Series_acceleration:8">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 terms, are described by Cohen <em>et al.</em>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="eulers-transform">Euler's transform</h2>

<p>A basic example of a <a href="linear_sequence_transformation" title="wikilink">linear sequence transformation</a>, offering improved convergence, is Euler's transform. It is intended to be applied to an alternating series; it is given by</p>

<p>

<math display="block" id="Series_acceleration:9">
 <semantics>
  <mrow>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi mathvariant="normal">‚àû</mi>
    </munderover>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>n</mi>
     </msup>
     <msub>
      <mi>a</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi mathvariant="normal">‚àû</mi>
    </munderover>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>n</mi>
     </msup>
     <mfrac>
      <mrow>
       <msup>
        <mi mathvariant="normal">Œî</mi>
        <mi>n</mi>
       </msup>
       <msub>
        <mi>a</mi>
        <mn>0</mn>
       </msub>
      </mrow>
      <msup>
       <mn>2</mn>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-Œî</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{n=0}^{\infty}(-1)^{n}a_{n}=\sum_{n=0}^{\infty}(-1)^{n}\frac{\Delta^{n}a_%
{0}}{2^{n+1}}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Series_acceleration:10">
 <semantics>
  <mi mathvariant="normal">Œî</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Œî</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>

 is the <a href="forward_difference_operator" title="wikilink">forward difference operator</a>:</p>

<p>

<math display="block" id="Series_acceleration:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi mathvariant="normal">Œî</mi>
      <mi>n</mi>
     </msup>
     <msub>
      <mi>a</mi>
      <mn>0</mn>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>k</mi>
      </msup>
      <mrow>
       <mo>(</mo>
       <mtable columnspacing="0.4em" rowspacing="0.2ex">
        <mtr>
         <mtd>
          <mi>n</mi>
         </mtd>
        </mtr>
        <mtr>
         <mtd>
          <mi>k</mi>
         </mtd>
        </mtr>
       </mtable>
       <mo>)</mo>
      </mrow>
      <msub>
       <mi>a</mi>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mi>k</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Œî</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">binomial</csymbol>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta^{n}a_{0}=\sum_{k=0}^{n}(-1)^{k}{n\choose k}a_{n-k}.
  </annotation>
 </semantics>
</math>

</p>

<p>If the original series, on the left hand side, is only slowly converging, the forward differences will tend to become small quite rapidly; the additional power of two further improves the rate at which the right hand side converges.</p>

<p>A particularly efficient numerical implementation of the Euler transform is the <a href="van_Wijngaarden_transformation" title="wikilink">van Wijngaarden transformation</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="conformal-mappings">Conformal mappings</h2>

<p>A series</p>
<dl>
<dd>S = 

<math display="inline" id="Series_acceleration:12">
 <semantics>
  <mrow>
   <msubsup>
    <mo largeop="true" symmetric="true">‚àë</mo>
    <mrow>
     <mi>n</mi>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mi mathvariant="normal">‚àû</mi>
   </msubsup>
   <msub>
    <mi>a</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{n=0}^{\infty}a_{n}
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>can be written as f(1), where the function f(z) is defined as</p>

<p>

<math display="block" id="Series_acceleration:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">‚àë</mo>
     <mrow>
      <mi>n</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi mathvariant="normal">‚àû</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>n</mi>
     </msub>
     <msup>
      <mi>z</mi>
      <mi>n</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>z</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(z)=\sum_{n=0}^{\infty}a_{n}z^{n}
  </annotation>
 </semantics>
</math>

</p>

<p>The function f(z) can have singularities in the complex plane (branch point singularities, poles or essential singularities), which limit the radius of convergence of the series. If the point z = 1 is close to or on the boundary of the disk of convergence, the series for S will converge very slowly. One can then improve the convergence of the series by means of a conformal mapping that moves the singularities such that the point that is mapped to z = 1, ends up deeper in the new disk of convergence.</p>

<p>The conformal transform 

<math display="inline" id="Series_acceleration:14">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Œ¶</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>z</ci>
    <apply>
     <times></times>
     <ci>normal-Œ¶</ci>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z=\Phi(w)
  </annotation>
 </semantics>
</math>

 needs to be chosen such that 

<math display="inline" id="Series_acceleration:15">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Œ¶</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Œ¶</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(0)=0
  </annotation>
 </semantics>
</math>

, and one usually chooses a function that has a finite derivative at w = 0. One can assume that 

<math display="inline" id="Series_acceleration:16">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Œ¶</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Œ¶</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(1)=1
  </annotation>
 </semantics>
</math>

 without loss of generality, as one can always rescale w to redefine 

<math display="inline" id="Series_acceleration:17">
 <semantics>
  <mi mathvariant="normal">Œ¶</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Œ¶</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

. We then consider the function</p>

<p>

<math display="block" id="Series_acceleration:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi mathvariant="normal">Œ¶</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>w</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>w</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>normal-Œ¶</ci>
      <ci>w</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(w)=f\left(\Phi(w)\right)
  </annotation>
 </semantics>
</math>

</p>

<p>Since 

<math display="inline" id="Series_acceleration:19">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Œ¶</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Œ¶</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(1)=1
  </annotation>
 </semantics>
</math>

, we have f(1) = g(1). We can obtain the series expansion of g(w) by putting 

<math display="inline" id="Series_acceleration:20">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Œ¶</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>z</ci>
    <apply>
     <times></times>
     <ci>normal-Œ¶</ci>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z=\Phi(w)
  </annotation>
 </semantics>
</math>

 in the series expansion of f(z) because 

<math display="inline" id="Series_acceleration:21">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Œ¶</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Œ¶</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(0)=0
  </annotation>
 </semantics>
</math>

; the first n terms of the series expansion for f(z) will yield the first n terms of the series expansion for g(w) if 

<math display="inline" id="Series_acceleration:22">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi mathvariant="normal">Œ¶</mi>
     <mo>‚Ä≤</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚â†</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Œ¶</ci>
      <ci>normal-‚Ä≤</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi^{\prime}(0)\neq 0
  </annotation>
 </semantics>
</math>

. Putting w = 1 in that series expansion will thus yield a series such that if it converges, it will converge to the same value as the original series.</p>
<h2 id="non-linear-sequence-transformations">Non-linear sequence transformations</h2>

<p>Examples of such nonlinear sequence transformations are <a href="Pad√©_approximant" title="wikilink">Pad√© approximants</a>, the <a href="Shanks_transformation" title="wikilink">Shanks transformation</a>, and <a href="Levin-type_sequence_transformation" title="wikilink">Levin-type sequence transformations</a>.</p>

<p>Especially nonlinear sequence transformations often provide powerful numerical methods for the <a class="uri" href="summation" title="wikilink">summation</a> of <a href="divergent_series" title="wikilink">divergent series</a> or <a href="asymptotic_series" title="wikilink">asymptotic series</a> that arise for instance in <a href="perturbation_theory" title="wikilink">perturbation theory</a>, and may be used as highly effective <a href="extrapolation_method" title="wikilink">extrapolation methods</a>.</p>
<h3 id="aitken-method">Aitken method</h3>
<dl>
<dd><dl>
<dd><em>Main article: <a href="Aitken's_delta-squared_process" title="wikilink">Aitken's delta-squared process</a></em>
</dd>
</dl>
</dd>
</dl>

<p>A simple nonlinear sequence transformation is the Aitken extrapolation or delta-squared method,</p>

<p>

<math display="block" id="Series_acceleration:23">
 <semantics>
  <mrow>
   <mi>ùî∏</mi>
   <mo>:</mo>
   <mrow>
    <mi>S</mi>
    <mo>‚Üí</mo>
    <msup>
     <mi>S</mi>
     <mo>‚Ä≤</mo>
    </msup>
    <mo>=</mo>
    <mrow>
     <mi>ùî∏</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msubsup>
       <mi>s</mi>
       <mi>n</mi>
       <mo>‚Ä≤</mo>
      </msubsup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi>n</mi>
      <mo>‚àà</mo>
      <mi class="ltx_font_mathcaligraphic">ùí©</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>ùî∏</ci>
    <apply>
     <and></and>
     <apply>
      <ci>normal-‚Üí</ci>
      <ci>S</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>S</ci>
       <ci>normal-‚Ä≤</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <ci>ùî∏</ci>
       <ci>S</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>s</ci>
         <ci>normal-‚Ä≤</ci>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <in></in>
        <ci>n</ci>
        <ci>ùí©</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{A}:S\to S^{\prime}=\mathbb{A}(S)={(s^{\prime}_{n})}_{n\in\mathcal{N}}
  </annotation>
 </semantics>
</math>

</p>

<p>defined by</p>

<p>

<math display="block" id="Series_acceleration:24">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>s</mi>
     <mi>n</mi>
     <mo>‚Ä≤</mo>
    </msubsup>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>s</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>2</mn>
      </mrow>
     </msub>
     <mo>-</mo>
     <mfrac>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>s</mi>
          <mrow>
           <mi>n</mi>
           <mo>+</mo>
           <mn>2</mn>
          </mrow>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>s</mi>
          <mrow>
           <mi>n</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mrow>
       <mrow>
        <msub>
         <mi>s</mi>
         <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mn>2</mn>
         </mrow>
        </msub>
        <mo>-</mo>
        <mrow>
         <mn>2</mn>
         <msub>
          <mi>s</mi>
          <mrow>
           <mi>n</mi>
           <mo>+</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </mrow>
       </mrow>
       <mo>+</mo>
       <msub>
        <mi>s</mi>
        <mi>n</mi>
       </msub>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-‚Ä≤</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>s</ci>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>s</ci>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>s</ci>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>s</ci>
          <apply>
           <plus></plus>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>s</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{\prime}_{n}=s_{n+2}-\frac{(s_{n+2}-s_{n+1})^{2}}{s_{n+2}-2s_{n+1}+s_{n}}.
  </annotation>
 </semantics>
</math>

</p>

<p>This transformation is commonly used to improve the <a href="rate_of_convergence" title="wikilink">rate of convergence</a> of a slowly converging sequence; heuristically, it eliminates the largest part of the <a href="absolute_error" title="wikilink">absolute error</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Minimum_polynomial_extrapolation" title="wikilink">Minimum polynomial extrapolation</a></li>
<li><a href="Van_Wijngaarden_transformation" title="wikilink">Van Wijngaarden transformation</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<ul>
<li>C. Brezinski and M. Redivo Zaglia, <em>Extrapolation Methods. Theory and Practice</em>, North-Holland, 1991.</li>
<li>G. A. Baker, Jr. and P. Graves-Morris, <em>Pad√© Approximants</em>, Cambridge U.P., 1996.</li>
<li></li>
<li>Herbert H. H. Homeier, <em>Scalar Levin-Type Sequence Transformations</em>, Journal of Computational and Applied Mathematics, vol. 122, no. 1-2, p 81 (2000). , .</li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_analysis" title="wikilink">Category:Numerical analysis</a> <a href="Category:Asymptotic_analysis" title="wikilink">Category:Asymptotic analysis</a> <a href="Category:Summability_methods" title="wikilink">Category:Summability methods</a> <a href="Category:Perturbation_theory" title="wikilink">Category:Perturbation theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">‚Ü©</a></li>
<li id="fn2"><a href="#fnref2">‚Ü©</a></li>
<li id="fn3"><a href="Henri_Cohen_(number_theorist)" title="wikilink">Henri Cohen</a>, Fernando Rodriguez Villegas, and <a href="Don_Zagier" title="wikilink">Don Zagier</a>, "<a href="http://www.math.utexas.edu/~villegas/publications/conv-accel.pdf">Convergence Acceleration of Alternating Series</a>", <em>Experimental Mathematics</em>, <strong>9</strong>:1 (2000) page 3.<a href="#fnref3">‚Ü©</a></li>
<li id="fn4">William H. Press, <em>et al.</em>, <em>Numerical Recipes in C</em>, (1987) Cambridge University Press, ISBN 0-521-43108-5 (See section 5.1).<a href="#fnref4">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
