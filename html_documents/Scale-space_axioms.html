<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="333">Scale-space axioms</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Scale-space axioms</h1>
<hr/>

<p>In <a href="image_processing" title="wikilink">image processing</a> and <a href="computer_vision" title="wikilink">computer vision</a>, a <a href="scale_space" title="wikilink">scale space</a> framework can be used to represent an image as a family of gradually smoothed images. This framework is very general and a variety of <a href="scale_space_representation" title="wikilink">scale space representations</a> exist. A typical approach for choosing a particular type of <a href="scale_space_representation" title="wikilink">scale space representation</a> is to establish a set of <strong>scale-space axioms</strong>, describing basic properties of the desired scale-space representation and often chosen so as to make the representation useful in practical applications. Once established, the axioms narrow the possible scale-space representations to a smaller class, typically with only a few free parameters.</p>

<p>A set of standard scale space axioms, discussed below, leads to the linear Gaussian scale-space, which is the most common type of scale space used in image processing and computer vision.</p>
<h2 id="scale-space-axioms-for-the-linear-scale-space-representation">Scale space axioms for the linear scale-space representation</h2>

<p>The linear <a href="scale_space" title="wikilink">scale space</a> representation 

<math display="inline" id="Scale-space_axioms:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>T</mi>
       <mi>t</mi>
      </msub>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo>,</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>*</mo>
     <mi>f</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>L</ci>
      <vector>
       <ci>x</ci>
       <ci>y</ci>
       <ci>t</ci>
      </vector>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <ci>t</ci>
       </apply>
       <ci>f</ci>
      </apply>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <apply>
        <times></times>
        <ci>g</ci>
        <vector>
         <ci>x</ci>
         <ci>y</ci>
         <ci>t</ci>
        </vector>
       </apply>
       <ci>f</ci>
      </apply>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(x,y,t)=(T_{t}f)(x,y)=g(x,y,t)*f(x,y)
  </annotation>
 </semantics>
</math>

 of signal 

<math display="inline" id="Scale-space_axioms:1">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)
  </annotation>
 </semantics>
</math>

 obtained by smoothing with the Gaussian kernel 

<math display="inline" id="Scale-space_axioms:2">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <vector>
     <ci>x</ci>
     <ci>y</ci>
     <ci>t</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x,y,t)
  </annotation>
 </semantics>
</math>

 satisfies a number of properties <strong>'scale-space axioms</strong>' that make it a special form of multi-scale representation:</p>
<blockquote>
<ul>
<li><em>linearity</em></li>
</ul>

<p>

<math display="block" id="Scale-space_axioms:3">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>T</mi>
     <mi>t</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>a</mi>
       <mi>f</mi>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>b</mi>
       <mi>h</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>a</mi>
     <msub>
      <mi>T</mi>
      <mi>t</mi>
     </msub>
     <mi>f</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>b</mi>
     <msub>
      <mi>T</mi>
      <mi>t</mi>
     </msub>
     <mi>h</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <times></times>
       <ci>b</ci>
       <ci>h</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <ci>t</ci>
      </apply>
      <ci>f</ci>
     </apply>
     <apply>
      <times></times>
      <ci>b</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <ci>t</ci>
      </apply>
      <ci>h</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{t}(af+bh)=aT_{t}f+bT_{t}h
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Scale-space_axioms:4">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Scale-space_axioms:5">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 are signals while 

<math display="inline" id="Scale-space_axioms:6">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Scale-space_axioms:7">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 are constants,</p>
<ul>
<li><em>shift invariance</em></li>
</ul>

<p>

<math display="block" id="Scale-space_axioms:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>T</mi>
     <mi>t</mi>
    </msub>
    <msub>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>x</mi>
      </mrow>
      <mo>,</mo>
      <msub>
       <mi mathvariant="normal">Δ</mi>
       <mi>y</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
    <mi>f</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>x</mi>
      </mrow>
      <mo>,</mo>
      <msub>
       <mi mathvariant="normal">Δ</mi>
       <mi>y</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </msub>
    <msub>
     <mi>T</mi>
     <mi>t</mi>
    </msub>
    <mi>f</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Δ</ci>
        <ci>y</ci>
       </apply>
      </interval>
     </apply>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Δ</ci>
        <ci>y</ci>
       </apply>
      </interval>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>t</ci>
     </apply>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{t}S_{(\Delta x,\Delta_{y})}f=S_{(\Delta x,\Delta_{y})}T_{t}f
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Scale-space_axioms:9">
 <semantics>
  <msub>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mi>x</mi>
    </mrow>
    <mo>,</mo>
    <msub>
     <mi mathvariant="normal">Δ</mi>
     <mi>y</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Δ</ci>
      <ci>y</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{(\Delta x,\Delta_{y})}
  </annotation>
 </semantics>
</math>

 denotes the shift (translation) operator 

<math display="inline" id="Scale-space_axioms:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>S</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi mathvariant="normal">Δ</mi>
         <mi>x</mi>
        </mrow>
        <mo>,</mo>
        <msub>
         <mi mathvariant="normal">Δ</mi>
         <mi>y</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </msub>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>x</mi>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>y</mi>
      <mo>-</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>y</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <interval closure="open">
        <apply>
         <times></times>
         <ci>normal-Δ</ci>
         <ci>x</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-Δ</ci>
         <ci>y</ci>
        </apply>
       </interval>
      </apply>
      <ci>f</ci>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <apply>
       <minus></minus>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>y</ci>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>y</ci>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S_{(\Delta x,\Delta_{y})}f)(x,y)=f(x-\Delta x,y-\Delta y)
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>the ''semi-group structure</li>
</ul>

<p>

<math display="block" id="Scale-space_axioms:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo>,</mo>
       <msub>
        <mi>t</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>*</mo>
     <mi>g</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <msub>
      <mi>t</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>t</mi>
       <mn>1</mn>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>t</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>g</ci>
       <vector>
        <ci>x</ci>
        <ci>y</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </apply>
       </vector>
      </apply>
      <ci>g</ci>
     </apply>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">2</cn>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x,y,t_{1})*g(x,y,t_{2})=g(x,y,t_{1}+t_{2})
  </annotation>
 </semantics>
</math>

 with the associated <em>cascade smoothing property</em></p>

<p>

<math display="block" id="Scale-space_axioms:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <msub>
      <mi>t</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo>,</mo>
       <mrow>
        <msub>
         <mi>t</mi>
         <mn>2</mn>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>t</mi>
         <mn>1</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>*</mo>
     <mi>L</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <msub>
      <mi>t</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">2</cn>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>g</ci>
       <vector>
        <ci>x</ci>
        <ci>y</ci>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>t</ci>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>t</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </vector>
      </apply>
      <ci>L</ci>
     </apply>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(x,y,t_{2})=g(x,y,t_{2}-t_{1})*L(x,y,t_{1})
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>existence of an <em>infinitesimal generator</em> 

<math display="inline" id="Scale-space_axioms:13">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>

<math display="block" id="Scale-space_axioms:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo>∂</mo>
      <mi>t</mi>
     </msub>
     <mi>L</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>A</mi>
      <mi>L</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <partialdiff></partialdiff>
       <ci>t</ci>
      </apply>
      <ci>L</ci>
     </apply>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>t</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>L</ci>
     </apply>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>t</ci>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial_{t}L(x,y,t)=(AL)(x,y,t)
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li><em>non-creation of local extrema</em> (zero-crossings) in one dimension,</li>
<li><em>non-enhancement of local extrema</em> in any number of dimensions</li>
</ul>

<p>

<math display="block" id="Scale-space_axioms:15">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo>∂</mo>
      <mi>t</mi>
     </msub>
     <mi>L</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <partialdiff></partialdiff>
       <ci>t</ci>
      </apply>
      <ci>L</ci>
     </apply>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>t</ci>
     </vector>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial_{t}L(x,y,t)\leq 0
  </annotation>
 </semantics>
</math>

 at spatial maxima and 

<math display="inline" id="Scale-space_axioms:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mo>∂</mo>
      <mi>t</mi>
     </msub>
     <mi>L</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <partialdiff></partialdiff>
       <ci>t</ci>
      </apply>
      <ci>L</ci>
     </apply>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>t</ci>
     </vector>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial_{t}L(x,y,t)\geq 0
  </annotation>
 </semantics>
</math>

 at spatial minima,</p>
<ul>
<li><em>rotational symmetry</em></li>
</ul>

<p>

<math display="block" id="Scale-space_axioms:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
      <mo>+</mo>
      <msup>
       <mi>y</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>t</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>h</ci>
     <interval closure="open">
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>t</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x,y,t)=h(x^{2}+y^{2},t)
  </annotation>
 </semantics>
</math>

 for some function 

<math display="inline" id="Scale-space_axioms:18">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

,</p>
<ul>
<li>''scale invariance</li>
</ul>

<p>

<math display="block" id="Scale-space_axioms:19">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>g</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ω</mi>
      <mi>x</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>ω</mi>
      <mi>y</mi>
     </msub>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mover accent="true">
     <mi>h</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mfrac>
      <msub>
       <mi>ω</mi>
       <mi>x</mi>
      </msub>
      <mrow>
       <mi>φ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
     <mo>,</mo>
     <mfrac>
      <msub>
       <mi>ω</mi>
       <mi>x</mi>
      </msub>
      <mrow>
       <mi>φ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>g</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <ci>y</ci>
      </apply>
      <ci>t</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>h</ci>
     </apply>
     <interval closure="open">
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <times></times>
        <ci>φ</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <times></times>
        <ci>φ</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{g}(\omega_{x},\omega_{y},t)=\hat{h}(\frac{\omega_{x}}{\varphi(t)},\frac{%
\omega_{x}}{\varphi(t)})
  </annotation>
 </semantics>
</math>

 for some functions 

<math display="inline" id="Scale-space_axioms:20">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Scale-space_axioms:21">
 <semantics>
  <mover accent="true">
   <mi>h</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{h}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Scale-space_axioms:22">
 <semantics>
  <mover accent="true">
   <mi>g</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>g</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{g}
  </annotation>
 </semantics>
</math>

 denotes the Fourier transform of 

<math display="inline" id="Scale-space_axioms:23">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

,</p>
<ul>
<li><em>positivity</em>:</li>
</ul>

<p>

<math display="block" id="Scale-space_axioms:24">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>g</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>t</ci>
     </vector>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x,y,t)\geq 0
  </annotation>
 </semantics>
</math>

,</p>
<ul>
<li><em>normalization</em>:</li>
</ul>

<p>

<math display="block" id="Scale-space_axioms:25">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mi>x</mi>
      <mo>=</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mi>y</mi>
       <mo>=</mo>
       <mrow>
        <mo>-</mo>
        <mi mathvariant="normal">∞</mi>
       </mrow>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo>,</mo>
       <mi>t</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mpadded width="+1.7pt">
       <mi>x</mi>
      </mpadded>
      <mi>d</mi>
      <mi>y</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <eq></eq>
        <ci>x</ci>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <eq></eq>
         <ci>y</ci>
         <apply>
          <minus></minus>
          <infinity></infinity>
         </apply>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <ci>g</ci>
       <vector>
        <ci>x</ci>
        <ci>y</ci>
        <ci>t</ci>
       </vector>
       <ci>d</ci>
       <ci>x</ci>
       <ci>d</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{x=-\infty}^{\infty}\int_{y=-\infty}^{\infty}g(x,y,t)\,dx\,dy=1
  </annotation>
 </semantics>
</math>

.</p>
</blockquote>

<p>In fact, it can be shown that the Gaussian kernel is a <em>unique choice</em> given several different combinations of subsets of these scale-space axioms:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> most of the axioms (linearity, shift-invariance, semigroup) correspond to scaling being a semigroup of shift-invariant linear operator, which is satisfied by a number of families <a href="integral_transforms" title="wikilink">integral transforms</a>, while "non-creation of local extrema"<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> for one-dimensional signals or "non-enhancement of local extrema"<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> for higher-dimensional signals are the crucial axioms which relate scale-spaces to smoothing (formally, <a href="parabolic_partial_differential_equation" title="wikilink">parabolic partial differential equations</a>), and hence select for the Gaussian.</p>

<p>The Gaussian kernel is also separable in Cartesian coordinates, i.e. 

<math display="inline" id="Scale-space_axioms:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>t</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>t</ci>
     </interval>
     <ci>g</ci>
     <interval closure="open">
      <ci>y</ci>
      <ci>t</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x,y,t)=g(x,t)\,g(y,t)
  </annotation>
 </semantics>
</math>

. Separability is, however, not counted as a scale-space axiom, since it is a coordinate dependent property related to issues of implementation. In addition, the requirement of separability in combination with rotational symmetry per se fixates the smoothing kernel to be a Gaussian.</p>

<p>There exists a generalization of the Gaussian scale-space theory to more general affine and spatio-temporal scale-spaces.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> In addition to variabilities over scale, which original scale-space theory was designed to handle, this <em>generalized scale-space theory</em> also comprises other types of variabilities, including image deformations caused by viewing variations, approximated by local affine transformations, and relative motions between objects in the world and the observer, approximated by local Galilean transformations. In this theory, rotational symmetry is not imposed as a necessary scale-space axiom and is instead replaced by requirements of affine and/or Galilean covariance. The generalized scale-space theory leads to predictions about receptive field profiles in good qualitative agreement with receptive field profiles measured by cell recordings in biological vision.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p>In the <a href="computer_vision" title="wikilink">computer vision</a>, <a href="image_processing" title="wikilink">image processing</a> and <a href="signal_processing" title="wikilink">signal processing</a> literature there are many other multi-scale approaches, using <a class="uri" href="wavelets" title="wikilink">wavelets</a> and a variety of other kernels, that do not exploit or require the same requirements as <a href="scale_space" title="wikilink">scale space</a> descriptions do; please see the article on related <a href="multi-scale_approaches" title="wikilink">multi-scale approaches</a>. There has also been work on discrete scale-space concepts that carry the scale-space properties over to the discrete domain; see the article on <a href="scale_space_implementation" title="wikilink">scale space implementation</a> for examples and references.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="scale_space" title="wikilink">scale space</a></li>
<li><a href="scale_space_implementation" title="wikilink">scale space implementation</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Image_processing" title="wikilink">Category:Image processing</a> <a href="Category:Computer_vision" title="wikilink">Category:Computer vision</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Koenderink, Jan "The structure of images", Biological Cybernetics, 50:363–370, 1984<a href="#fnref1">↩</a></li>
<li id="fn2">[<a class="uri" href="http://portal.acm.org/citation.cfm?id=11298&amp;dl">http://portal.acm.org/citation.cfm?id=11298&amp;dl;</a>;=GUIDE&amp;coll;=GUIDE J. Babaud, A. P. Witkin, M. Baudin, and R. O. Duda, Uniqueness of the Gaussian kernel for scale-space filtering. IEEE Trans. Pattern Anal. Machine Intell. 8(1), 26–33, 1986.]<a href="#fnref2">↩</a></li>
<li id="fn3">[<a class="uri" href="http://portal.acm.org/citation.cfm?id=11297&amp;dl">http://portal.acm.org/citation.cfm?id=11297&amp;dl;</a>;=ACM&amp;coll;=ACM A. Yuille, T.A. Poggio: Scaling theorems for zero crossings. IEEE Trans. Pattern Analysis &amp; Machine Intelligence, Vol. PAMI-8, no. 1, pp. 15–25, Jan. 1986.]<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="http://www.nada.kth.se/~tony/abstracts/Lin90-PAMI.html">Lindeberg, T., "Scale-space for discrete signals," PAMI(12), No. 3, March 1990, pp. 234–254.</a><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="http://www.nada.kth.se/~tony/book.html">Lindeberg, Tony, Scale-Space Theory in Computer Vision, Kluwer, 1994</a>,<a href="#fnref5">↩</a></li>
<li id="fn6">[<a class="uri" href="http://portal.acm.org/citation.cfm?coll=GUIDE&amp;dl">http://portal.acm.org/citation.cfm?coll=GUIDE&amp;dl;</a>;=GUIDE&amp;id;=628701 Pauwels, E., van Gool, L., Fiddelaers, P. and Moons, T.: An extended class of scale-invariant and recursive scale space filters, IEEE Transactions on Pattern Analysis and Machine Intelligence, Vol. 17, No. 7, pp. 691–701, 1995.]<a href="#fnref6">↩</a></li>
<li id="fn7"><a href="ftp://ftp.nada.kth.se/CVAP/reports/cvap159.pdf">Lindeberg, T.: On the axiomatic foundations of linear scale-space: Combining semi-group structure with causailty vs. scale invariance. In: J. Sporring et al. (eds.) Gaussian Scale-Space Theory: Proc. PhD School on Scale-Space Theory , (Copenhagen, Denmark, May 1996), pages 75–98, Kluwer Academic Publishers, 1997.</a><a href="#fnref7">↩</a></li>
<li id="fn8">Florack, Luc, Image Structure, Kluwer Academic Publishers, 1997.<a href="#fnref8">↩</a></li>
<li id="fn9">[<a class="uri" href="http://portal.acm.org/citation.cfm?id=607668&amp;dl">http://portal.acm.org/citation.cfm?id=607668&amp;dl;</a>;=ACM&amp;coll;=ACM Weickert, J. Linear scale space has first been proposed in Japan. Journal of Mathematical Imaging and Vision, 10(3):237–252, 1999.]<a href="#fnref9">↩</a></li>
<li id="fn10"><a href="http://www.csc.kth.se/~tony/abstracts/Lin10-GenGaussScSp.html">Lindeberg, T. Generalized Gaussian scale-space axiomatics comprising linear scale-space, affine scale-space and spatio-temporal scale-space, Journal of Mathematical Imaging and Vision, Volume 40, Number 1, 36-81, 2011.</a><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="http://dx.doi.org/10.1016/B978-0-12-407701-0.00001-7">Lindeberg, T. Generalized axiomatic scale-space theory'', Advances in Imaging and Electron Physics, Elsevier, volume 178, pages 1-96, 2013.</a><a href="#fnref11">↩</a></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"><a href="http://dx.doi.org/10.1007/s00422-013-0569-z">Lindeberg, T. A computational theory of visual receptive fields, Biological Cybernetics, 107(6): 589-635, 2013.</a><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="http://dx.doi.org/10.1371/journal.pone.0066990">Lindeberg, T. Invariance of visual operations at the level of receptive fields, PLoS ONE 8(7):e66990, 2013</a><a href="#fnref19">↩</a></li>
</ol>
</section>
</body>
</html>
