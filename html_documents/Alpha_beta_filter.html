<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="215">Alpha beta filter</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Alpha beta filter</h1>
<hr/>

<p>An <strong>alpha beta filter</strong> (also called alpha-beta filter, f-g filter or g-h filter <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a>) is a simplified form of <a href="State_observer" title="wikilink">observer</a> for estimation, data smoothing and control applications. It is closely related to <a href="Kalman_filter" title="wikilink">Kalman filters</a> and to linear state observers used in <a href="control_theory" title="wikilink">control theory</a>. Its principal advantage is that it does not require a detailed system model.</p>
<h2 id="filter-equations">Filter equations</h2>

<p>An alpha beta filter presumes that a system is adequately approximated by a model having two internal states, where the first state is obtained by integrating the value of the second state over time. Measured system output values correspond to observations of the first model state, plus disturbances. This very low order approximation is adequate for many simple systems, for example, mechanical systems where position is obtained as the time integral of velocity. Based on a mechanical system analogy, the two states can be called <em>position x</em> and <em>velocity v</em>. Assuming that velocity remains approximately constant over the small time interval <em>ΔT</em> between measurements, the position state is projected forward to predict its value at the next sampling time using equation 1.</p>

<p>

<math display="block" id="Alpha_beta_filter:0">
 <semantics>
  <mrow>
   <mrow>
    <mtext>(1)</mtext>
    <msub>
     <mover accent="true">
      <mtext>𝐱</mtext>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>k</mi>
    </msub>
   </mrow>
   <mo>←</mo>
   <mrow>
    <msub>
     <mover accent="true">
      <mtext>𝐱</mtext>
      <mo stretchy="false">^</mo>
     </mover>
     <mrow>
      <mi>k</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mpadded width="+5pt">
      <mtext>T</mtext>
     </mpadded>
     <mtext mathvariant="bold"></mtext>
     <msub>
      <mover accent="true">
       <mtext>𝐯</mtext>
       <mo stretchy="false">^</mo>
      </mover>
      <mrow>
       <mi>k</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <list>
     <mtext>(1)</mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <mtext>x</mtext>
      </apply>
      <ci>k</ci>
     </apply>
    </list>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <mtext>x</mtext>
      </apply>
      <apply>
       <minus></minus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>normal-Δ</ci>
      <mtext>T</mtext>
      <mtext></mtext>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <mtext>v</mtext>
       </apply>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{(1)}\quad\hat{\textbf{x}}_{k}\leftarrow\hat{\textbf{x}}_{k-1}+\Delta%
\textrm{T}\ \textbf{ }\hat{\textbf{v}}_{k-1}
  </annotation>
 </semantics>
</math>

</p>

<p>Since velocity variable <em>v</em> is presumed constant, so its projected value at the next sampling time equals the current value.</p>

<p>

<math display="block" id="Alpha_beta_filter:1">
 <semantics>
  <mrow>
   <mrow>
    <mtext>(2)</mtext>
    <msub>
     <mover accent="true">
      <mtext>𝐯</mtext>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>k</mi>
    </msub>
   </mrow>
   <mo>←</mo>
   <msub>
    <mover accent="true">
     <mtext>𝐯</mtext>
     <mo stretchy="false">^</mo>
    </mover>
    <mrow>
     <mi>k</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <list>
     <mtext>(2)</mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <mtext>v</mtext>
      </apply>
      <ci>k</ci>
     </apply>
    </list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <mtext>v</mtext>
     </apply>
     <apply>
      <minus></minus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{(2)}\quad\hat{\textbf{v}}_{k}\leftarrow\hat{\textbf{v}}_{k-1}
  </annotation>
 </semantics>
</math>

</p>

<p>If additional information is known about how a driving function will change the <em>v</em> state during each time interval, equation 2 can be modified to include it.</p>

<p>The output measurement is expected to deviate from the prediction because of noise and dynamic effects not included in the simplified dynamic model. This prediction error <em>r</em> is also called the <em>residual</em> or <em>innovation</em>, based on statistical or Kalman filtering interpretations</p>

<p>

<math display="block" id="Alpha_beta_filter:2">
 <semantics>
  <mrow>
   <mrow>
    <mtext mathvariant="bold">(3)</mtext>
    <msub>
     <mover accent="true">
      <mtext>𝐫</mtext>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>k</mi>
    </msub>
   </mrow>
   <mo>←</mo>
   <mrow>
    <msub>
     <mtext>𝐱</mtext>
     <mi>k</mi>
    </msub>
    <mo>-</mo>
    <msub>
     <mover accent="true">
      <mtext>𝐱</mtext>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <list>
     <mtext>(3)</mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <mtext>r</mtext>
      </apply>
      <ci>k</ci>
     </apply>
    </list>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>x</mtext>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <mtext>x</mtext>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\textbf{(3)}}\quad\hat{\textbf{r}}_{k}\leftarrow\textbf{x}_{k}-\hat{\textbf{x%
}}_{k}
  </annotation>
 </semantics>
</math>

</p>

<p>Suppose that residual <em>r</em> is positive. This could result because the previous <em>x</em> estimate was low, the previous <em>v</em> was low, or some combination of the two. The alpha beta filter takes selected <em>alpha</em> and <em>beta</em> constants (from which the filter gets its name), uses <em>alpha</em> times the deviation <em>r</em> to correct the position estimate, and uses <em>beta</em> times the deviation <em>r</em> to correct the velocity estimate. An extra <em>ΔT</em> factor conventionally serves to normalize magnitudes of the multipliers.</p>

<p>

<math display="block" id="Alpha_beta_filter:3">
 <semantics>
  <mrow>
   <mrow>
    <mtext mathvariant="bold">(4)</mtext>
    <msub>
     <mover accent="true">
      <mtext>𝐱</mtext>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>k</mi>
    </msub>
   </mrow>
   <mo>←</mo>
   <mrow>
    <msub>
     <mover accent="true">
      <mtext>𝐱</mtext>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>k</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>α</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <msub>
      <mover accent="true">
       <mtext>𝐫</mtext>
       <mo stretchy="false">^</mo>
      </mover>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <list>
     <mtext>(4)</mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <mtext>x</mtext>
      </apply>
      <ci>k</ci>
     </apply>
    </list>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <mtext>x</mtext>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <ci>α</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <mtext>r</mtext>
       </apply>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{(4)}\quad\hat{\textbf{x}}_{k}\leftarrow\hat{\textbf{x}}_{k}+(\alpha)\ %
\hat{\textbf{r}}_{k}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Alpha_beta_filter:4">
 <semantics>
  <mrow>
   <mrow>
    <mtext mathvariant="bold">(5)</mtext>
    <msub>
     <mover accent="true">
      <mtext>𝐯</mtext>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>k</mi>
    </msub>
   </mrow>
   <mo>←</mo>
   <mrow>
    <msub>
     <mover accent="true">
      <mtext>𝐯</mtext>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>k</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>β</mi>
       <mo>/</mo>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mi mathvariant="normal">Δ</mi>
         <mtext>T</mtext>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <msub>
      <mover accent="true">
       <mtext>𝐫</mtext>
       <mo stretchy="false">^</mo>
      </mover>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <list>
     <mtext>(5)</mtext>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <mtext>v</mtext>
      </apply>
      <ci>k</ci>
     </apply>
    </list>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <mtext>v</mtext>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>β</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <ci>normal-Δ</ci>
         <mtext>T</mtext>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <mtext>r</mtext>
       </apply>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textbf{(5)}\quad\hat{\textbf{v}}_{k}\leftarrow\hat{\textbf{v}}_{k}+(\beta/[%
\Delta\textrm{T}])\ \hat{\textbf{r}}_{k}
  </annotation>
 </semantics>
</math>

</p>

<p>The corrections can be considered small steps along an estimate of the gradient direction. As these adjustments accumulate, error in the state estimates is reduced. For convergence and stability, the values of the <em>alpha</em> and <em>beta</em> multipliers should be positive and small:<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>

<math display="block" id="Alpha_beta_filter:5">
 <semantics>
  <mrow>
   <mpadded lspace="10pt" width="+10pt">
    <mn>0</mn>
   </mpadded>
   <mo><</mo>
   <mi>α</mi>
   <mo><</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <cn type="integer">0</cn>
     <ci>α</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \quad 0<\alpha<1
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Alpha_beta_filter:6">
 <semantics>
  <mrow>
   <mpadded lspace="10pt" width="+10pt">
    <mn>0</mn>
   </mpadded>
   <mo><</mo>
   <mi>β</mi>
   <mo>≤</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <cn type="integer">0</cn>
     <ci>β</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \quad 0<\beta\leq 2
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Alpha_beta_filter:7">
 <semantics>
  <mrow>
   <mpadded lspace="10pt" width="+10pt">
    <mn>0</mn>
   </mpadded>
   <mo><</mo>
   <mrow>
    <mn>4</mn>
    <mo>-</mo>
    <mrow>
     <mn>2</mn>
     <mi>α</mi>
    </mrow>
    <mo>-</mo>
    <mi>β</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <cn type="integer">0</cn>
    <apply>
     <minus></minus>
     <cn type="integer">4</cn>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>α</ci>
     </apply>
     <ci>β</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \quad 0<4-2\alpha-\beta
  </annotation>
 </semantics>
</math>

</p>

<p>Noise is suppressed only if 

<math display="inline" id="Alpha_beta_filter:8">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo><</mo>
   <mi>β</mi>
   <mo><</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <cn type="integer">0</cn>
     <ci>β</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0<\beta<1
  </annotation>
 </semantics>
</math>


, otherwise the noise is amplified.</p>

<p>Values of <em>alpha</em> and <em>beta</em> typically are adjusted experimentally. In general, larger <em>alpha</em> and <em>beta</em> gains tend to produce faster response for tracking transient changes, while smaller <em>alpha</em> and <em>beta</em> gains reduce the level of noise in the state estimates. If a good balance between accurate tracking and noise reduction is found, and the algorithm is effective, filtered estimates are more accurate than the direct measurements. This motivates calling the alpha-beta process a <em>filter</em>.</p>
<h3 id="algorithm-summary">Algorithm Summary</h3>

<p><strong>Initialize.</strong></p>
<ul>
<li>Set the initial values of state estimates <em>x</em> and <em>v</em>, using prior information or additional measurements; otherwise, set the initial state values to zero.</li>
<li>Select values of the <em>alpha</em> and <em>beta</em> correction gains.</li>
</ul>

<p><strong>Update.</strong> Repeat for each time step ΔT:</p>
<pre><code>  Project state estimates x and v using equations 1 and 2
  Obtain a current measurement of the output value
  Compute the residual r using equation 3
  Correct the state estimates using equations 4 and 5
  Send updated x and optionally v as the filter outputs</code></pre>
<h2 id="sample-program">Sample Program</h2>

<p>Alpha Beta filter can be implemented in <a href="C_(programming_language)" title="wikilink">C</a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> as follows:</p>
<pre><code>#include<stdio.h>
#include<stdlib.h>

int main()
{
    float dt = 0.5;
    float xk_1 = 0, vk_1 = 0, a = 0.85, b = 0.005;

    float xk, vk, rk;
    float xm;

    while( 1 )
    {
        xm = rand() % 100;// input signal

        xk = xk_1 + ( vk_1 * dt );
        vk = vk_1;

        rk = xm - xk;

        xk += a * rk;
        vk += ( b * rk ) / dt;

        xk_1 = xk;
        vk_1 = vk;

        printf( "%f \t %f\n", xm, xk_1 );
        sleep( 1 );
    }
} 
</stdlib.h></stdio.h></code></pre>
<h3 id="result">Result</h3>

<p>The following images depict the outcome of the above program in graphical format. In each image, the blue trace is the input signal; the output is red in the first image, yellow in the second, and green in the third. For the first two images, the output signal is visibly smoother than the input signal and lacks extreme spikes seen in the input. Also, the output moves in an estimate of <a class="uri" href="gradient" title="wikilink">gradient</a> direction of input.</p>

<p>The higher the alpha parameter, the higher is the effect of input x and the less damping is seen. A low value of beta is effective in controlling sudden surges in velocity. Also, as alpha increases beyond unity, the output becomes rougher and more uneven than the input.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Results for alpha = 0.85 and beta = 0.005</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Results for alpha = 0.5 and beta = 0.1</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Results for alpha = 1.5 and beta = 0.5</figcaption>
</figure></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="relationship-to-general-state-observers">Relationship to general state observers</h2>

<p>More general state observers, such as the <a href="State_observer" title="wikilink">Luenberger observer</a> for linear control systems, use a rigorous system model. Linear observers use a gain matrix to determine state estimate corrections from multiple deviations between measured variables and predicted outputs that are linear combinations of state variables. In the case of alpha beta filters, this gain matrix reduces to two terms. There is no general theory for determining the best observer gain terms, and typically gains are adjusted experimentally for both.</p>

<p>The linear Luenberger <a href="state_observer" title="wikilink">observer equations</a> reduce to the alpha beta filter by applying the following specializations and simplifications.</p>
<ul>
<li>The discrete state transition matrix <strong>A</strong> is a square matrix of dimension 2, with all main diagonal terms equal to 1, and the first super-diagonal terms equal to <em>ΔT</em>.</li>
</ul>
<ul>
<li>The observation equation matrix <strong>C</strong> has one row that selects the value of the first state variable for output.</li>
</ul>
<ul>
<li>The filter correction gain matrix <strong>L</strong> has one column containing the alpha and beta gain values.</li>
</ul>
<ul>
<li>Any known driving signal for the second state term is represented as part of the input signal vector <strong>u</strong>, otherwise the <strong>u</strong> vector is set to zero.</li>
</ul>
<ul>
<li>Input coupling matrix <strong>B</strong> has a non-zero gain term as its last element if vector <strong>u</strong> is non-zero.</li>
</ul>
<h2 id="relationship-to-kalman-filters">Relationship to Kalman Filters</h2>

<p>A <a href="Kalman_filter" title="wikilink">Kalman filter</a> estimates the values of state variables and corrects them in a manner similar to an alpha beta filter or a state observer. However, a Kalman filter does this in a much more formal and rigorous manner. The principal differences between Kalman filters and alpha beta filters are the following.</p>
<ul>
<li>Like state observers, Kalman filters use a detailed dynamic system model that is not restricted to two states.</li>
</ul>
<ul>
<li>Like state observers, Kalman filters in general use multiple observed variables to correct state variable estimates, and these do not have to be direct measurements of individual system states.</li>
</ul>
<ul>
<li>A Kalman filter uses covariance noise models for states and observations. Using these, a time-dependent estimate of state covariance is updated automatically, and from this the <a href="Kalman_Filter" title="wikilink">Kalman gain</a> matrix terms are calculated. Alpha beta filter gains are manually selected and static.</li>
</ul>
<ul>
<li>For certain classes of problems, a Kalman filter is <a href="Wiener_filter" title="wikilink">Wiener optimal</a>, while alpha beta filtering is in general suboptimal.</li>
</ul>

<p>A Kalman filter designed to track a moving object using a constant-velocity target dynamics (process) model (i.e., constant velocity between measurement updates) with process noise covariance and measurement covariance held constant will converge to the same structure as an alpha-beta filter. However, a Kalman filter's gain is computed recursively at each time step using the assumed process and measurement error statistics, whereas the alpha-beta's gain is computed ad hoc.</p>
<h2 id="choice-of-parameters">Choice of Parameters</h2>

<p>The alpha-beta filter becomes a steady-state Kalman filter if filter parameters are calculated from the sampling interval 

<math display="inline" id="Alpha_beta_filter:9">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

, the process variance 

<math display="inline" id="Alpha_beta_filter:10">
 <semantics>
  <msubsup>
   <mi>σ</mi>
   <mi>w</mi>
   <mn>2</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>w</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{w}^{2}
  </annotation>
 </semantics>
</math>

 and the noise variance 

<math display="inline" id="Alpha_beta_filter:11">
 <semantics>
  <msubsup>
   <mi>σ</mi>
   <mi>v</mi>
   <mn>2</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>v</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{v}^{2}
  </annotation>
 </semantics>
</math>

 like this</p>
<dl>
<dd><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a>
</dd>
</dl>

<p>

<math display="block" id="Alpha_beta_filter:12">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>σ</mi>
      <mi>w</mi>
     </msub>
     <msup>
      <mi>T</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <msub>
     <mi>σ</mi>
     <mi>v</mi>
    </msub>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>λ</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>w</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>T</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>σ</ci>
      <ci>v</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda=\frac{\sigma_{w}T^{2}}{\sigma_{v}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Alpha_beta_filter:13">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mn>4</mn>
      <mo>+</mo>
      <mi>λ</mi>
     </mrow>
     <mo>-</mo>
     <msqrt>
      <mrow>
       <mrow>
        <mn>8</mn>
        <mi>λ</mi>
       </mrow>
       <mo>+</mo>
       <msup>
        <mi>λ</mi>
        <mn>2</mn>
       </msup>
      </mrow>
     </msqrt>
    </mrow>
    <mn>4</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>r</ci>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <cn type="integer">4</cn>
       <ci>λ</ci>
      </apply>
      <apply>
       <root></root>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <cn type="integer">8</cn>
         <ci>λ</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>λ</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=\frac{4+\lambda-\sqrt{8\lambda+\lambda^{2}}}{4}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Alpha_beta_filter:14">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <msup>
     <mi>r</mi>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>α</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>r</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha=1-r^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Alpha_beta_filter:15">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mn>2</mn>
       <mo>-</mo>
       <mi>α</mi>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mn>4</mn>
     <msqrt>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>α</mi>
      </mrow>
     </msqrt>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>β</ci>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <cn type="integer">2</cn>
       <ci>α</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">4</cn>
      <apply>
       <root></root>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>α</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta=2\left(2-\alpha\right)-4\sqrt{1-\alpha}
  </annotation>
 </semantics>
</math>

</p>

<p>This choice of filter parameters minimizes the mean square error.</p>
<h2 id="the-alpha-beta-gamma-extension">The Alpha Beta Gamma extension</h2>

<p>When the second state variable varies quickly, i.e. when the acceleration of the first state is large, it can be useful to extend states the alpha beta filter one level. In this extension, the second state variable <em>v</em> is obtained from integrating a third <em>acceleration</em> state, analogous to the way that the first state is obtained by integrating the second. An equation for the <em>a</em> state is added to the equation system. A third multiplier, <em>gamma</em>, is selected for applying corrections to the new <em>a</em> state estimates. This yields the <em>alpha beta gamma</em> update equations.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>

<math display="block" id="Alpha_beta_filter:16">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mtext>𝐱</mtext>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>k</mi>
   </msub>
   <mo>←</mo>
   <mrow>
    <msub>
     <mover accent="true">
      <mtext>𝐱</mtext>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>k</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>α</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <msub>
      <mtext>𝐫</mtext>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <mtext>x</mtext>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <mtext>x</mtext>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <ci>α</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>r</mtext>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\textbf{x}}_{k}\leftarrow\hat{\textbf{x}}_{k}+(\alpha)\ \textbf{r}_{k}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Alpha_beta_filter:17">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mtext>𝐯</mtext>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>k</mi>
   </msub>
   <mo>←</mo>
   <mrow>
    <msub>
     <mover accent="true">
      <mtext>𝐯</mtext>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>k</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>β</mi>
       <mo>/</mo>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mi mathvariant="normal">Δ</mi>
         <mtext>T</mtext>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <msub>
      <mtext>𝐫</mtext>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <mtext>v</mtext>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <mtext>v</mtext>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>β</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <ci>normal-Δ</ci>
         <mtext>T</mtext>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>r</mtext>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\textbf{v}}_{k}\leftarrow\hat{\textbf{v}}_{k}+(\beta/[\Delta\textrm{T}])%
\ \textbf{r}_{k}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Alpha_beta_filter:18">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mtext>𝐚</mtext>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>k</mi>
   </msub>
   <mo>←</mo>
   <mrow>
    <msub>
     <mover accent="true">
      <mtext>𝐚</mtext>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>k</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>γ</mi>
        <mn>2</mn>
       </mrow>
       <mo>/</mo>
       <msup>
        <mrow>
         <mo stretchy="false">[</mo>
         <mrow>
          <mi mathvariant="normal">Δ</mi>
          <mtext>T</mtext>
         </mrow>
         <mo stretchy="false">]</mo>
        </mrow>
        <mtext>2</mtext>
       </msup>
      </mrow>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <msub>
      <mtext>𝐫</mtext>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <mtext>a</mtext>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <mtext>a</mtext>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>γ</ci>
        <cn type="float">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <times></times>
          <ci>normal-Δ</ci>
          <mtext>T</mtext>
         </apply>
        </apply>
        <mtext>2</mtext>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <mtext>r</mtext>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\textbf{a}}_{k}\leftarrow\hat{\textbf{a}}_{k}+(\gamma\ 2/[\Delta\textrm{T%
}]^{\textrm{2}})\ \textbf{r}_{k}
  </annotation>
 </semantics>
</math>

</p>

<p>Similar extensions to additional higher orders are possible, but most systems of higher order tend to have significant interactions among the multiple states,  so approximating the system dynamics as a simple integrator chain is less likely to prove useful.</p>

<p>Calculating optimal parameters for the alpha-beta-gamma filter is a bit more involved than for the alpha-beta filter:<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>

<math display="inline" id="Alpha_beta_filter:19">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\lambda
  </annotation>
 </semantics>
</math>


</p>
<h2 id="the-alpha-filter">The alpha filter</h2>

<p>A simpler member of this family of filters is the alpha filter which observes only one state:</p>

<p>

<math display="block" id="Alpha_beta_filter:20">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mtext>𝐱</mtext>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>k</mi>
   </msub>
   <mo>←</mo>
   <mrow>
    <msub>
     <mover accent="true">
      <mtext>𝐱</mtext>
      <mo stretchy="false">^</mo>
     </mover>
     <mi>k</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>α</mi>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
     <msub>
      <mover accent="true">
       <mtext>𝐫</mtext>
       <mo stretchy="false">^</mo>
      </mover>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <mtext>x</mtext>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-^</ci>
       <mtext>x</mtext>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <ci>α</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-^</ci>
        <mtext>r</mtext>
       </apply>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\textbf{x}}_{k}\leftarrow\hat{\textbf{x}}_{k}+(\alpha)\ \hat{\textbf{r}}_%
{k}
  </annotation>
 </semantics>
</math>

</p>

<p>with the optimal parameter calculated like this:<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>

<math display="inline" id="Alpha_beta_filter:21">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\lambda
  </annotation>
 </semantics>
</math>


</p>

<p>This calculation is identical for a <a href="moving_average" title="wikilink">moving average</a> and a <a href="low-pass_filter" title="wikilink">low-pass filter</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Kalman_filter" title="wikilink">Kalman filter</a></li>
<li><a href="Control_theory" title="wikilink">Control theory</a></li>
<li><a href="State_space_(controls)" title="wikilink">State space (controls)</a></li>
<li><a href="Moving_average" title="wikilink">Moving average</a></li>
</ul>
<h3 id="references">References</h3>

<p><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> <a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> <a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> <a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> <a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> <a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> <a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<h2 id="references-1">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://adrianboeing.blogspot.com/2010/03/alpha-beta-filters.html">Alpha-Beta C source code sample</a></li>
<li><a href="http://www.advsolned.com/example_radar_tracking.html">Tracking performance of the alpha-beta tracker versus the Kalman filter</a></li>
</ul>

<p>"</p>

<p><a href="Category:Filter_theory" title="wikilink">Category:Filter theory</a> <a href="Category:Signal_processing" title="wikilink">Category:Signal processing</a> <a href="Category:Statistical_approximations" title="wikilink">Category:Statistical approximations</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Eli Brookner: Tracking and Kalman Filtering Made Easy. Wiley-Interscience, 1st edition, 4 1998.<a href="#fnref1">↩</a></li>
<li id="fn2">C. Frank Asquith: Weight selection in first-order linear filters. Technical report, Army Intertial Guidance and Control Laboratory Center, Redstone Arsenal, Alabama, 1969.<a href="#fnref2">↩</a></li>
<li id="fn3">Tremor Cancellation in Handheld Microsurgical Devices, TC83 by Gaurav Mittal, Deepansh Sehgal and Harsimran Jit Singh, <a href="Punjab_Engineering_College" title="wikilink">Punjab Engineering College</a><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5">Paul R. Kalata: The tracking index: A generalized parameter for α-β and α-β-γ target trackers. IEEE Transactions on Aerospace and Electronic Systems, AES-20(2):174–181, mar 1984.<a href="#fnref5">↩</a></li>
<li id="fn6">J. E. Gray and W. J. Murray: A derivation of an analytic expression for the tracking index for the alpha-beta-gamma filter. IEEE Trans. on Aerospace and Electronic Systems, 29:1064–1065, 1993.<a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"><a href="http://www.drdobbs.com/184402735;jsessionid=SN0GKRCTQYCCHQE1GHRSKHWATMY32JVN?pgno=10">"The Alpha-Beta Filter", Penoyer, Robert; C Users Journal, July 1993</a><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="http://www.mstarlabs.com/control/engspeed.html">"Engine Speed Monitoring: The Alpha-Beta Filter", Microstar Laboratories</a><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="http://ieeexplore.ieee.org/Xplore/login.jsp?url=/iel4/7/2265/00062250.pdf?arnumber=62250">"Reconciling steady-state Kalman and alpha-beta filter design", by Painter, J.H.; Kerstetter, D.; Jowers, S. IEEE Transactions on Aerospace and Electronic Systems, Volume 26, Issue 6, Nov 1990 Page(s):986 - 991</a><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="http://ieeexplore.ieee.org/Xplore/login.jsp?url=/iel5/7/30189/01386894.pdf?temp=x">Fixed-lag alpha-beta filter for target trajectory smoothing Ogle, T.L.; Blair, W.D. Aerospace and Electronic Systems, IEEE Transactions on Volume 40, Issue 4, Oct. 2004 Page(s): 1417 - 1421</a><a href="#fnref13">↩</a></li>
<li id="fn14">[<a class="uri" href="http://oai.dtic.mil/oai/oai?verb=getRecord&amp;metadataPrefix">http://oai.dtic.mil/oai/oai?verb=getRecord&amp;metadataPrefix;</a>;=html&amp;identifier;=AD0759011 "Description of an alpha-beta Filter in Cartesian Coordinates", by Cantrell, Ben H., NAVAL RESEARCH LAB WASHINGTON DC, March 21, 1973]<a href="#fnref14">↩</a></li>
<li id="fn15">[<a class="uri" href="http://oai.dtic.mil/oai/oai?verb=getRecord&amp;metadataPrefix">http://oai.dtic.mil/oai/oai?verb=getRecord&amp;metadataPrefix;</a>;=html&amp;identifier;=ADA329021 "Comparison of Four Filtering Options for a Radar Tracking Problem", by Lawton, John A. ; Jesionowski, Robert J. ; Zarchan, Paul. NAVAL SURFACE WARFARE CENTER DAHLGREN DIV VA, 1979.]<a href="#fnref15">↩</a></li>
<li id="fn16">[<a class="uri" href="http://books.google.com/books?id=HxjDMcJWLYwC&amp;pg">http://books.google.com/books?id=HxjDMcJWLYwC&amp;pg;</a>;=PA160&amp;lpg;=PA160&amp;dq;=alpha+beta+filter&amp;source;=web&amp;ots;=kabAY3rfso&amp;sig;=7vyxtbBzxrE0cYYAcZTg_gtnP78&amp;hl;=en#PPA160,M1 "Mathematical Techniques in Multisensor Data Fusion", By David Lee Hall, Sonya A. H., Artech House, 2004, ISBN 1-58053-335-3, section 4.4.4]<a href="#fnref16">↩</a></li>
</ol>
</section>
</body>
</html>
