<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="516">Block cipher mode of operation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Block cipher mode of operation</h1>
<hr/>

<p>In <a class="uri" href="cryptography" title="wikilink">cryptography</a>, a <strong>mode of operation</strong> is an algorithm that uses a <a href="block_cipher" title="wikilink">block cipher</a> to provide an <a href="information_security" title="wikilink">information service</a> such as <a class="uri" href="confidentiality" title="wikilink">confidentiality</a> or <a href="authentication" title="wikilink">authenticity</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> A block cipher by itself is only suitable for the secure cryptographic transformation (encryption or decryption) of one fixed-length group of <a href="bit" title="wikilink">bits</a> called a <a href="Block_(data_storage)" title="wikilink">block</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> A mode of operation describes how to repeatedly apply a cipher's single-block operation to securely transform amounts of data larger than a block.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>Most modes require a unique binary sequence, often called an <a href="initialization_vector" title="wikilink">initialization vector</a> (IV), for each encryption operation. The IV has to be non-repeating and, for some modes, random as well. The initialization vector is used to ensure distinct <a href="ciphertext" title="wikilink">ciphertexts</a> are produced even when the same <a class="uri" href="plaintext" title="wikilink">plaintext</a> is encrypted multiple times independently with the same <a href="Key_(cryptography)" title="wikilink">key</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Block ciphers have one or more <a href="Block_size_(cryptography)" title="wikilink">block size</a>(s), but during transformation the block size is always fixed. Block cipher modes operate on whole blocks and require that the last part of the data be <a href="Padding_(cryptography)" title="wikilink">padded</a> to a full block if it is smaller than the current block size.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> There are, however, modes that do not require padding because they effectively use a block cipher as a <a href="stream_cipher" title="wikilink">stream cipher</a>.</p>

<p>Historically, encryption modes have been studied extensively in regard to their error propagation properties under various scenarios of data modification. Later development regarded <a href="integrity_protection" title="wikilink">integrity protection</a> as an entirely separate cryptographic goal. Some modern modes of operation combine <a class="uri" href="confidentiality" title="wikilink">confidentiality</a> and <a href="authentication" title="wikilink">authenticity</a> in an efficient way, and are known as <a href="authenticated_encryption" title="wikilink">authenticated encryption</a> modes.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="history-and-standardization">History and standardization</h2>

<p>The earliest modes of operation, ECB, CBC, OFB, and CFB (see below for all), date back to 1981 and were specified in <a href="http://csrc.nist.gov/publications/fips/fips81/fips81.htm">FIPS 81</a>, <em>DES Modes of Operation</em>. In 2001, the US <a href="National_Institute_of_Standards_and_Technology" title="wikilink">National Institute of Standards and Technology</a> (NIST) revised its list of approved modes of operation by including <a href="Advanced_Encryption_Standard" title="wikilink">AES</a> as a block cipher and adding CTR mode in <a href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">SP800-38A</a>, <em>Recommendation for Block Cipher Modes of Operation</em>. Finally, in January, 2010, NIST added <a class="uri" href="XTS-AES" title="wikilink">XTS-AES</a> in <a href="http://csrc.nist.gov/publications/nistpubs/800-38E/nist-sp-800-38E.pdf">SP800-38E</a>, <em>Recommendation for Block Cipher Modes of Operation: The XTS-AES Mode for Confidentiality on Storage Devices</em>. Other confidentiality modes exist which have not been approved by NIST. For example, CTS is <a href="ciphertext_stealing" title="wikilink">ciphertext stealing</a> mode and available in many popular cryptographic libraries.</p>

<p>The block cipher modes ECB, CBC, OFB, CFB, CTR, and <a href="XTS_mode" title="wikilink">XTS</a> provide confidentiality, but they do not protect against accidental modification or malicious tampering. Modification or tampering can be detected with a separate <a href="message_authentication_code" title="wikilink">message authentication code</a> such as <a class="uri" href="CBC-MAC" title="wikilink">CBC-MAC</a>, or a <a href="digital_signature" title="wikilink">digital signature</a>. The cryptographic community recognized the need for dedicated integrity assurances and NIST responded with HMAC, CMAC, and GMAC. <a class="uri" href="HMAC" title="wikilink">HMAC</a> was approved in 2002 as <a href="http://csrc.nist.gov/publications/fips/fips198/fips-198a.pdf">FIPS 198</a>, <em>The Keyed-Hash Message Authentication Code (HMAC)</em>, <a class="uri" href="CMAC" title="wikilink">CMAC</a> was released in 2005 under <a href="http://csrc.nist.gov/publications/nistpubs/800-38B/SP_800-38B.pdf">SP800-38B</a>, <em>Recommendation for Block Cipher Modes of Operation: The CMAC Mode for Authentication</em>, and <a href="Galois/Counter_Mode" title="wikilink">GMAC</a> was formalized in 2007 under <a href="http://csrc.nist.gov/publications/nistpubs/800-38D/SP-800-38D.pdf">SP800-38D</a>, <em>Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC</em>.</p>

<p>After observing that compositing a confidentiality mode with an authenticity mode could be difficult and error prone, the cryptographic community began to supply modes which combined confidentiality and data integrity into a single cryptographic primitive. The modes are referred to as <a href="authenticated_encryption" title="wikilink">authenticated encryption</a>, AE or "authenc". Examples of AE modes are <a href="CCM_mode" title="wikilink">CCM</a> (<a href="http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C_updated-July20_2007.pdf">SP800-38C</a>), <a href="GCM_mode" title="wikilink">GCM</a> (<a href="http://csrc.nist.gov/publications/nistpubs/800-38D/SP-800-38D.pdf">SP800-38D</a>), <a href="CWC_mode" title="wikilink">CWC</a>, <a href="EAX_mode" title="wikilink">EAX</a>, <a href="IAPM_mode" title="wikilink">IAPM</a>, and <a href="OCB_mode" title="wikilink">OCB</a>.</p>

<p>Modes of operation are nowadays defined by a number of national and internationally recognized standards bodies. Notable standards organizations include <a class="uri" href="NIST" title="wikilink">NIST</a>, <a href="International_Organization_for_Standardization" title="wikilink">ISO</a> (with ISO/IEC 10116<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a>), the <a href="International_Electrotechnical_Commission" title="wikilink">IEC</a>, the <a class="uri" href="IEEE" title="wikilink">IEEE</a>, the national <a class="uri" href="ANSI" title="wikilink">ANSI</a>, and the <a class="uri" href="IETF" title="wikilink">IETF</a>.</p>
<h2 id="initialization-vector-iv">Initialization vector (IV)</h2>

<p>An initialization vector (IV) or starting variable (SV)<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> is a block of bits that is used by several modes to randomize the encryption and hence to produce distinct ciphertexts even if the same plaintext is encrypted multiple times, without the need for a slower re-keying process.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>An initialization vector has different security requirements than a key, so the IV usually does not need to be secret. However, in most cases, it is important that an initialization vector is never reused under the same key. For CBC and CFB, reusing an IV leaks some information about the first block of plaintext, and about any common prefix shared by the two messages. For OFB and CTR, reusing an IV completely destroys security.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> This can be seen because both modes effectively create a bitstream that is XORed with the plaintext, and this bitstream is dependent on the password and IV only. Reusing a bitstream destroys security.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> In CBC mode, the IV must, in addition, be unpredictable at encryption time; in particular, the (previously) common practice of re-using the last ciphertext block of a message as the IV for the next message is insecure (for example, this method was used by SSL 2.0). If an attacker knows the IV (or the previous block of ciphertext) before he specifies the next plaintext, he can check his guess about plaintext of some block that was encrypted with the same key before (this is known as the TLS CBC IV attack).<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="padding">Padding</h2>

<p>A <a href="block_cipher" title="wikilink">block cipher</a> works on units of a fixed <a href="block_size_(cryptography)" title="wikilink">size</a> (known as a <em>block size</em>), but messages come in a variety of lengths. So some modes (namely <a href="Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29" title="wikilink">ECB</a> and <a href="Cipher_block_chaining" title="wikilink">CBC</a>) require that the final block be padded before encryption. Several <a href="padding_(cryptography)" title="wikilink">padding</a> schemes exist. The simplest is to add <a href="Null_character" title="wikilink">null bytes</a> to the <a class="uri" href="plaintext" title="wikilink">plaintext</a> to bring its length up to a multiple of the block size, but care must be taken that the original length of the plaintext can be recovered; this is trivial, for example, if the plaintext is a <a href="C_(programming_language)" title="wikilink">C</a> style <a href="Literal_string" title="wikilink">string</a> which contains no null bytes except at the end. Slightly more complex is the original <a href="Data_Encryption_Standard" title="wikilink">DES</a> method, which is to add a single one <a class="uri" href="bit" title="wikilink">bit</a>, followed by enough zero <a href="bit" title="wikilink">bits</a> to fill out the block; if the message ends on a block boundary, a whole padding block will be added. Most sophisticated are CBC-specific schemes such as <a href="ciphertext_stealing" title="wikilink">ciphertext stealing</a> or <a href="residual_block_termination" title="wikilink">residual block termination</a>, which do not cause any extra ciphertext, at the expense of some additional complexity. <a href="Bruce_Schneier" title="wikilink">Schneier</a> and <a href="Niels_Ferguson" title="wikilink">Ferguson</a> suggest two possibilities, both simple: append a byte with value 128 (hex 80), followed by as many zero bytes as needed to fill the last block, or pad the last block with <em>n</em> bytes all with value <em>n</em>.</p>

<p>CFB, OFB and CTR modes do not require any special measures to handle messages whose lengths are not multiples of the block size, since the modes work by XORing the plaintext with the output of the block cipher. The last partial block of plaintext is XORed with the first few bytes of the last <a class="uri" href="keystream" title="wikilink">keystream</a> block, producing a final ciphertext block that is the same size as the final partial plaintext block. This characteristic of stream ciphers makes them suitable for applications that require the encrypted ciphertext data to be the same size as the original plaintext data, and for applications that transmit data in streaming form where it is inconvenient to add padding bytes.</p>
<h2 id="common-modes">Common modes</h2>

<p>Many modes of operation have been defined. Some of these are described below.</p>
<h3 id="electronic-codebook-ecb">Electronic Codebook (ECB)</h3>

<p>The simplest of the encryption modes is the <strong>Electronic Codebook</strong> (ECB) mode. The message is divided into blocks, and each block is encrypted separately.</p>
<figure><b>(Figure)</b>
<figcaption>ECB encryption.svg</figcaption>
</figure>
<figure><b>(Figure)</b>
<figcaption>ECB decryption.svg</figcaption>
</figure>

<p>The disadvantage of this method is that identical <a class="uri" href="plaintext" title="wikilink">plaintext</a> blocks are encrypted into identical <a class="uri" href="ciphertext" title="wikilink">ciphertext</a> blocks; thus, it does not hide data patterns well. In some senses, it doesn't provide serious message confidentiality, and it is not recommended for use in cryptographic protocols at all.</p>

<p>A striking example of the degree to which ECB can leave plaintext data patterns in the ciphertext can be seen when ECB mode is used to encrypt a <a href="bitmap_image" title="wikilink">bitmap image</a> which uses large areas of uniform colour. While the colour of each individual <a class="uri" href="pixel" title="wikilink">pixel</a> is encrypted, the overall image may still be discerned as the pattern of identically coloured pixels in the original remains in the encrypted version.</p>

<p>ECB mode can also make protocols without integrity protection even more susceptible to <a href="replay_attack" title="wikilink">replay attacks</a>, since each block gets decrypted in exactly the same way.</p>
<h3 id="cipher-block-chaining-cbc">Cipher Block Chaining (CBC)</h3>

<p>IBM invented the Cipher Block Chaining (CBC) mode of operation in 1976.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> In CBC mode, each block of plaintext is <a href="XOR" title="wikilink">XORed</a> with the previous ciphertext block before being encrypted. This way, each ciphertext block depends on all plaintext blocks processed up to that point. To make each message unique, an <a href="initialization_vector" title="wikilink">initialization vector</a> must be used in the first block.</p>
<figure><b>(Figure)</b>
<figcaption>CBC encryption.svg</figcaption>
</figure>
<figure><b>(Figure)</b>
<figcaption>CBC decryption.svg</figcaption>
</figure>

<p>If the first block has index 1, the mathematical formula for CBC encryption is</p>

<p>

<math display="block" id="Block_cipher_mode_of_operation:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>C</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>E</mi>
      <mi>K</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>P</mi>
        <mi>i</mi>
       </msub>
       <mo>⊕</mo>
       <msub>
        <mi>C</mi>
        <mrow>
         <mi>i</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>C</mi>
     <mn>0</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>I</mi>
     <mi>V</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>K</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">direct-sum</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <apply>
         <minus></minus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <ci>I</ci>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i}=E_{K}(P_{i}\oplus C_{i-1}),C_{0}=IV
  </annotation>
 </semantics>
</math>

</p>

<p>while the mathematical formula for CBC decryption is</p>

<p>

<math display="block" id="Block_cipher_mode_of_operation:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>P</mi>
      <mi>i</mi>
     </msub>
     <mo>=</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>D</mi>
        <mi>K</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>C</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⊕</mo>
      <msub>
       <mi>C</mi>
       <mrow>
        <mi>i</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>C</mi>
      <mn>0</mn>
     </msub>
     <mo>=</mo>
     <mrow>
      <mi>I</mi>
      <mi>V</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>D</ci>
        <ci>K</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <ci>I</ci>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}=D_{K}(C_{i})\oplus C_{i-1},C_{0}=IV.
  </annotation>
 </semantics>
</math>

</p>

<p>CBC has been the most commonly used mode of operation. Its main drawbacks are that encryption is sequential (i.e., it cannot be parallelized), and that the message must be padded to a multiple of the cipher block size. One way to handle this last issue is through the method known as <a href="ciphertext_stealing" title="wikilink">ciphertext stealing</a>. Note that a one-bit change in a plaintext or IV affects all following ciphertext blocks.</p>

<p>Decrypting with the incorrect IV causes the first block of plaintext to be corrupt but subsequent plaintext blocks will be correct. This is because a plaintext block can be recovered from two adjacent blocks of ciphertext. As a consequence, decryption <em>can</em> be parallelized. Note that a one-bit change to the ciphertext causes complete corruption of the corresponding block of plaintext, and inverts the corresponding bit in the following block of plaintext, but the rest of the blocks remain intact. This peculiarity is exploited in different <a href="padding_oracle_attack" title="wikilink">padding oracle attacks</a>, such as <a class="uri" href="POODLE" title="wikilink">POODLE</a>.</p>

<p><em>Explicit Initialization Vectors</em><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> takes advantage of this property by prepending a single random block to the plaintext. Encryption is done as normal, except the IV does not need to be communicated to the decryption routine. Whatever IV decryption uses, only the random block is "corrupted". It can be safely discarded and the rest of the decryption is the original plaintext.</p>
<h4 id="propagating-cipher-block-chaining-pcbc">Propagating Cipher Block Chaining (PCBC)</h4>

<p>The Propagating Cipher Block Chaining<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> or plaintext cipher-block chaining<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> mode was designed to cause small changes in the ciphertext to propagate indefinitely when decrypting, as well as when encrypting.</p>
<figure><b>(Figure)</b>
<figcaption>PCBC encryption.svg</figcaption>
</figure>
<figure><b>(Figure)</b>
<figcaption>PCBC decryption.svg</figcaption>
</figure>

<p>Encryption and decryption algorithms are as follows:</p>

<p>

<math display="block" id="Block_cipher_mode_of_operation:2">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>C</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>E</mi>
      <mi>K</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>P</mi>
        <mi>i</mi>
       </msub>
       <mo>⊕</mo>
       <msub>
        <mi>P</mi>
        <mrow>
         <mi>i</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mo>⊕</mo>
       <msub>
        <mi>C</mi>
        <mrow>
         <mi>i</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>P</mi>
      <mn>0</mn>
     </msub>
     <mo>⊕</mo>
     <msub>
      <mi>C</mi>
      <mn>0</mn>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>I</mi>
     <mi>V</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>K</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">direct-sum</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <apply>
         <minus></minus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <apply>
         <minus></minus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>I</ci>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i}=E_{K}(P_{i}\oplus P_{i-1}\oplus C_{i-1}),P_{0}\oplus C_{0}=IV
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Block_cipher_mode_of_operation:3">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>P</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>D</mi>
       <mi>K</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>C</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⊕</mo>
     <msub>
      <mi>P</mi>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>⊕</mo>
     <msub>
      <mi>C</mi>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>P</mi>
      <mn>0</mn>
     </msub>
     <mo>⊕</mo>
     <msub>
      <mi>C</mi>
      <mn>0</mn>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>I</mi>
     <mi>V</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>D</ci>
        <ci>K</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>I</ci>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}=D_{K}(C_{i})\oplus P_{i-1}\oplus C_{i-1},P_{0}\oplus C_{0}=IV
  </annotation>
 </semantics>
</math>

</p>

<p>PCBC is used in <a href="Kerberos_(protocol)" title="wikilink">Kerberos v4</a> and <a class="uri" href="WASTE" title="wikilink">WASTE</a>, most notably, but otherwise is not common. On a message encrypted in PCBC mode, if two adjacent ciphertext blocks are exchanged, this does not affect the decryption of subsequent blocks.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> For this reason, PCBC is not used in Kerberos v5.</p>
<h3 id="cipher-feedback-cfb">Cipher Feedback (CFB)</h3>

<p>The <em>Cipher Feedback</em> (CFB) mode, a close relative of CBC, makes a block cipher into a self-synchronizing <a href="stream_cipher" title="wikilink">stream cipher</a>. Operation is very similar; in particular, CFB decryption is almost identical to CBC encryption performed in reverse:</p>

<p>

<math display="block" id="Block_cipher_mode_of_operation:4">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>E</mi>
      <mi>K</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>C</mi>
       <mrow>
        <mi>i</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊕</mo>
    <msub>
     <mi>P</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>K</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i}=E_{K}(C_{i-1})\oplus P_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Block_cipher_mode_of_operation:5">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>E</mi>
      <mi>K</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>C</mi>
       <mrow>
        <mi>i</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊕</mo>
    <msub>
     <mi>C</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>K</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}=E_{K}(C_{i-1})\oplus C_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Block_cipher_mode_of_operation:6">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mn>0</mn>
   </msub>
   <mo rspace="7.5pt">=</mo>
   <mtext>IV</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">0</cn>
    </apply>
    <mtext>IV</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{0}=\ \mbox{IV}
  </annotation>
 </semantics>
</math>

</p>
<figure><b>(Figure)</b>
<figcaption>CFB encryption.svg</figcaption>
</figure>
<figure><b>(Figure)</b>
<figcaption>CFB decryption.svg</figcaption>
</figure>

<p>By definition of self-synchronising cipher, if part of the ciphertext is lost (e.g. due to transmission errors), then receiver will lose only some part of the original message (garbled content), and should be able to continue correct decryption after processing some amount of input data. This simplest way of using CFB described above is not any more self-synchronizing than other cipher modes like CBC. Only if a whole blocksize of ciphertext is lost both CBC and CFB will synchronize, but losing only a single byte or bit will permanently throw off decryption. To be able to synchronize after the loss of only a single byte or bit, a single byte or bit must be encrypted at a time. CFB can be used this way when combined with a <a href="shift_register" title="wikilink">shift register</a> as the input for the block cipher.</p>

<p>To use CFB to make a self-synchronizing stream cipher that will synchronize for any multiple of x bits lost, start by initializing a shift register the size of the block size with the initialization vector. This is encrypted with the block cipher, and the highest x bits of the result are XOR'ed with x bits of the plaintext to produce x bits of ciphertext. These x bits of output are shifted into the shift register, and the process repeats with the next x bits of plaintext. Decryption is similar, start with the initialization vector, encrypt, and XOR the high bits of the result with x bits of the ciphertext to produce x bits of plaintext. Then shift the x bits of the ciphertext into the shift register. This way of proceeding is known as CFB-8 or CFB-1 (according to the size of the shifting).<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>

<p>In notation, where S<sub>i</sub> is the ith state of the shift register, a C_i = \mbox{head}(E_K (S_{i-1}), x) \oplus P_i</p>

<p>

<math display="block" id="Block_cipher_mode_of_operation:7">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mtext>head</mtext>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>E</mi>
        <mi>K</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>S</mi>
         <mrow>
          <mi>i</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⊕</mo>
    <msub>
     <mi>C</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <times></times>
      <mtext>head</mtext>
      <interval closure="open">
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>E</ci>
         <ci>K</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>S</ci>
         <apply>
          <minus></minus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <ci>x</ci>
      </interval>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}=\mbox{head}(E_{K}(S_{i-1}),x)\oplus C_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Block_cipher_mode_of_operation:8">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mi>i</mi>
   </msub>
   <mo rspace="7.5pt">=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>S</mi>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>≪</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>+</mo>
    <msub>
     <mi>C</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mtext>mod</mtext>
   <msup>
    <mn>2</mn>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>i</ci>
    </apply>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <csymbol cd="latexml">much-less-than</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <mtext>mod</mtext>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{i}=\ ((S_{i-1}<<x)+C_{i})\mbox{ mod }2^{n}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Block_cipher_mode_of_operation:9">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mn>0</mn>
   </msub>
   <mo rspace="7.5pt">=</mo>
   <mtext>IV</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <cn type="integer">0</cn>
    </apply>
    <mtext>IV</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{0}=\ \mbox{IV}
  </annotation>
 </semantics>
</math>

</p>

<p>If x bits are lost from the ciphertext, the cipher will output incorrect plaintext until the shift register once again equals a state it held while encrypting, at which point the cipher has resynchronized. This will result in at most one blocksize of output being garbled.</p>

<p>Like CBC mode, changes in the plaintext propagate forever in the ciphertext, and encryption cannot be parallelized. Also like CBC, decryption can be parallelized. When decrypting, a one-bit change in the ciphertext affects two plaintext blocks: a one-bit change in the corresponding plaintext block, and complete corruption of the following plaintext block. Later plaintext blocks are decrypted normally.</p>

<p>CFB shares two advantages over CBC mode with the stream cipher modes OFB and CTR: the block cipher is only ever used in the encrypting direction, and the message does not need to be padded to a multiple of the cipher block size (though <a href="ciphertext_stealing" title="wikilink">ciphertext stealing</a> can also be used to make padding unnecessary).</p>
<h3 id="output-feedback-ofb">Output Feedback (OFB)</h3>

<p>The <em>Output Feedback</em> (OFB) mode makes a block cipher into a synchronous <a href="stream_cipher" title="wikilink">stream cipher</a>. It generates <a class="uri" href="keystream" title="wikilink">keystream</a> blocks, which are then <a href="XOR" title="wikilink">XORed</a> with the plaintext blocks to get the ciphertext. Just as with other stream ciphers, flipping a bit in the ciphertext produces a flipped bit in the plaintext at the same location. This property allows many <a href="Error-correcting_code" title="wikilink">error correcting codes</a> to function normally even when applied before encryption.</p>

<p>Because of the symmetry of the XOR operation, encryption and decryption are exactly the same:</p>

<p>

<math display="block" id="Block_cipher_mode_of_operation:10">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>j</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>P</mi>
     <mi>j</mi>
    </msub>
    <mo>⊕</mo>
    <msub>
     <mi>O</mi>
     <mi>j</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>O</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{j}=P_{j}\oplus O_{j}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Block_cipher_mode_of_operation:11">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>j</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>C</mi>
     <mi>j</mi>
    </msub>
    <mo>⊕</mo>
    <msub>
     <mi>O</mi>
     <mi>j</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>O</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{j}=C_{j}\oplus O_{j}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Block_cipher_mode_of_operation:12">
 <semantics>
  <mrow>
   <msub>
    <mi>O</mi>
    <mi>j</mi>
   </msub>
   <mo rspace="7.5pt">=</mo>
   <mrow>
    <msub>
     <mi>E</mi>
     <mi>K</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>I</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>O</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>K</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O_{j}=\ E_{K}(I_{j})
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Block_cipher_mode_of_operation:13">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mi>j</mi>
   </msub>
   <mo rspace="7.5pt">=</mo>
   <msub>
    <mi>O</mi>
    <mrow>
     <mi>j</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>O</ci>
     <apply>
      <minus></minus>
      <ci>j</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{j}=\ O_{j-1}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Block_cipher_mode_of_operation:14">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mn>0</mn>
   </msub>
   <mo rspace="7.5pt">=</mo>
   <mtext>IV</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <cn type="integer">0</cn>
    </apply>
    <mtext>IV</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{0}=\ \mbox{IV}
  </annotation>
 </semantics>
</math>

</p>
<figure><b>(Figure)</b>
<figcaption>OFB encryption.svg</figcaption>
</figure>
<figure><b>(Figure)</b>
<figcaption>OFB decryption.svg</figcaption>
</figure>

<p>Each output feedback block cipher operation depends on all previous ones, and so cannot be performed in parallel. However, because the plaintext or ciphertext is only used for the final XOR, the block cipher operations may be performed in advance, allowing the final step to be performed in parallel once the plaintext or ciphertext is available.</p>

<p>It is possible to obtain an OFB mode keystream by using CBC mode with a constant string of zeroes as input. This can be useful, because it allows the usage of fast hardware implementations of CBC mode for OFB mode encryption.</p>

<p>Using OFB mode with a partial block as feedback like CFB mode reduces the average cycle length by a factor of 

<math display="inline" id="Block_cipher_mode_of_operation:15">
 <semantics>
  <msup>
   <mn>2</mn>
   <mn>32</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <cn type="integer">32</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{32}
  </annotation>
 </semantics>
</math>

 or more. A mathematical model proposed by Davies and Parkin and substantiated by experimental results showed that only with full feedback an average cycle length near to the obtainable maximum can be achieved. For this reason, support for truncated feedback was removed from the specification of OFB.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a><a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>
<h3 id="counter-ctr">Counter (CTR)</h3>
<dl>
<dd>''Note: CTR mode (CM) is also known as <em>integer counter mode</em> (ICM) and <em>segmented integer counter</em> (SIC) mode''
</dd>
</dl>

<p>Like OFB, Counter mode turns a <a href="block_cipher" title="wikilink">block cipher</a> into a <a href="stream_cipher" title="wikilink">stream cipher</a>. It generates the next <a class="uri" href="keystream" title="wikilink">keystream</a> block by encrypting successive values of a "counter". The counter can be any function which produces a sequence which is guaranteed not to repeat for a long time, although an actual increment-by-one counter is the simplest and most popular. The usage of a simple deterministic input function used to be controversial; critics argued that "deliberately exposing a cryptosystem to a known systematic input represents an unnecessary risk."<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> However, today CTR mode is widely accepted and any problems are considered a weakness of the underlying block cipher, which is expected to be secure regardless of systemic bias in its input.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> Along with CBC, CTR mode is one of two block cipher modes recommended by Niels Ferguson and Bruce Schneier.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></p>

<p>CTR mode has similar characteristics to OFB, but also allows a random access property during decryption. CTR mode is well suited to operate on a multi-processor machine where blocks can be encrypted in parallel. Furthermore, it does not suffer from the short-cycle problem that can affect OFB.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>

<p>If the IV/nonce is random, then they can be combined together with the counter using any lossless operation (concatenation, addition, or XOR) to produce the actual unique counter block for encryption. In case of a non-random nonce (such as a packet counter), the nonce and counter should be concatenated (e.g. storing nonce in upper 64-bit and the counter in lower 64-bit). Simply adding or XORing the nonce and counter into a single value would completely break the security under a chosen-plaintext attack.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>

<p>Note that the <a href="cryptographic_nonce" title="wikilink">nonce</a> in this diagram is equivalent to the <a href="initialization_vector" title="wikilink">initialization vector</a> (IV) in the other diagrams.</p>
<figure><b>(Figure)</b>
<figcaption>CTR encryption 2.svg</figcaption>
</figure>
<figure><b>(Figure)</b>
<figcaption>CTR decryption 2.svg</figcaption>
</figure>
<h2 id="error-propagation">Error propagation</h2>

<p>Before the widespread use of <a href="message_authentication_codes" title="wikilink">message authentication codes</a> and <a href="authenticated_encryption" title="wikilink">authenticated encryption</a>, it was common to discuss the "error propagation" properties as a selection criterion for a mode of operation. It might be observed, for example, that a one-block error in the transmitted ciphertext would result in a one-block error in the reconstructed plaintext for ECB mode encryption, while in CBC mode such an error would affect two blocks.</p>

<p>Some felt that such resilience was desirable in the face of random errors (e.g., line noise), while others argued that error correcting increased the scope for attackers to maliciously tamper with a message.</p>

<p>However, when proper integrity protection is used, such an error will result (with high probability) in the entire message being rejected. If resistance to random error is desirable, <a href="error-correcting_code" title="wikilink">error-correcting codes</a> should be applied to the ciphertext before transmission.</p>
<h2 id="authenticated-encryption">Authenticated encryption</h2>

<p>A number of modes of operation have been designed to combine <a class="uri" href="secrecy" title="wikilink">secrecy</a> and <a class="uri" href="authentication" title="wikilink">authentication</a> in a single cryptographic primitive. Examples of such modes are <a href="XCBC_mode" title="wikilink">XCBC</a>,<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> <a href="IACBC_mode" title="wikilink">IACBC</a>, <a href="IAPM_mode" title="wikilink">IAPM</a>,<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> <a href="OCB_mode" title="wikilink">OCB</a>, <a href="EAX_mode" title="wikilink">EAX</a>, <a href="CWC_mode" title="wikilink">CWC</a>, <a href="CCM_mode" title="wikilink">CCM</a>, and <a href="Galois/Counter_Mode" title="wikilink">GCM</a>. <a href="Authenticated_encryption" title="wikilink">Authenticated encryption</a> modes are classified as single pass modes or double pass modes. Unfortunately for the cryptographic user community, many of the single pass <a href="authenticated_encryption" title="wikilink">authenticated encryption</a> algorithms (such as <a href="OCB_mode" title="wikilink">OCB mode</a>) are patent encumbered.</p>

<p>In addition, some modes also allow for the authentication of unencrypted associated data, and these are called <a href="AEAD_block_cipher_modes_of_operation" title="wikilink">AEAD</a> (Authenticated-Encryption with Associated-Data) schemes. For example, EAX mode is a double pass AEAD scheme while OCB mode is single pass.</p>
<h2 id="other-modes-and-other-cryptographic-primitives">Other modes and other cryptographic primitives</h2>

<p>Many more modes of operation for block ciphers have been suggested. Some have been accepted, fully described (even standardized), and are in use. Others have been found insecure, and should never be used. Still others don't categorize as confidentiality, authenticity, or authenticated encryption - for example <a href="key_feedback_mode" title="wikilink">key feedback mode</a> and <a href="One-way_compression_function#Davies.E2.80.93Meyer" title="wikilink">Davies-Meyer</a> hashing.</p>

<p><a class="uri" href="NIST" title="wikilink">NIST</a> maintains a list of proposed modes for block ciphers at <a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html">Modes Development</a>.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a><a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p>

<p>Disk encryption often uses special purpose modes specifically designed for the application. Tweakable narrow-block encryption modes (<a class="uri" href="LRW" title="wikilink">LRW</a>, <a href="disk_encryption_theory#Xor-encrypt-xor_(XEX)" title="wikilink">XEX</a>, and <a href="XTS_mode" title="wikilink">XTS</a>) and wide-block encryption modes (<a href="Disk_encryption_theory#CBC-mask-CBC_(CMC)_and_ECB-mask-ECB_(EME)" title="wikilink">CMC</a> and <a href="Disk_encryption_theory#CBC-mask-CBC_(CMC)_and_ECB-mask-ECB_(EME)" title="wikilink">EME</a>) are designed to securely encrypt sectors of a disk. (See <a href="disk_encryption_theory" title="wikilink">disk encryption theory</a>)</p>

<p>Block ciphers can also be used in other <a href="cryptographic_protocol" title="wikilink">cryptographic protocols</a>. They are generally used in modes of operation similar to the block modes described here. As with all protocols, to be cryptographically secure, care must be taken to build them correctly.</p>

<p>There are several schemes which use a block cipher to build a <a href="cryptographic_hash_function" title="wikilink">cryptographic hash function</a>. See <a href="one-way_compression_function" title="wikilink">one-way compression function</a> for descriptions of several such methods.</p>

<p><a href="Cryptographically_secure_pseudorandom_number_generator" title="wikilink">Cryptographically secure pseudorandom number generators</a> (CSPRNGs) can also be built using block ciphers.</p>

<p><a href="Message_authentication_code" title="wikilink">Message authentication codes</a> (MACs) are often built from block ciphers. <a class="uri" href="CBC-MAC" title="wikilink">CBC-MAC</a>, <a href="One-key_MAC" title="wikilink">OMAC</a> and <a href="PMAC_(cryptography)" title="wikilink">PMAC</a> are examples.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Disk_encryption" title="wikilink">Disk encryption</a></li>
<li><a href="Message_authentication_code" title="wikilink">Message authentication code</a></li>
<li><a href="Authenticated_encryption" title="wikilink">Authenticated encryption</a></li>
<li><a href="One-way_compression_function" title="wikilink">One-way compression function</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Block_cipher_modes_of_operation" title="wikilink"> </a> <a href="Category:Cryptographic_algorithms" title="wikilink">Category:Cryptographic algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15">William F. Ehrsam, Carl H. W. Meyer, John L. Smith, Walter L. Tuchman, "Message verification and transmission error detection by block chaining", US Patent 4074066, 1976<a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a class="uri" href="http://www.iks-jena.de/mitarb/lutz/security/cryptfaq/q84.html">http://www.iks-jena.de/mitarb/lutz/security/cryptfaq/q84.html</a><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">NIST: Recommendation for Block Cipher Modes of Operation</a><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a class="uri" href="http://www.crypto.rub.de/its_seminar_ws0809.html">http://www.crypto.rub.de/its_seminar_ws0809.html</a><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24">Helger Lipmaa, Phillip Rogaway, and David Wagner. Comments to NIST concerning AES modes of operation: CTR-mode encryption. 2000<a href="#fnref24">↩</a></li>
<li id="fn25">Niels Ferguson, Bruce Schneier, Tadayoshi Kohno, Cryptography Engineering, page 71, 2010<a href="#fnref25">↩</a></li>
<li id="fn26"><a class="uri" href="http://www.quadibloc.com/crypto/co040601.htm">http://www.quadibloc.com/crypto/co040601.htm</a><a href="#fnref26">↩</a></li>
<li id="fn27"><a class="uri" href="https://class.coursera.org/crypto-010/lecture/21">https://class.coursera.org/crypto-010/lecture/21</a><a href="#fnref27">↩</a></li>
<li id="fn28"><a href="Virgil_D._Gligor" title="wikilink">Virgil D. Gligor</a>, Pompiliu Donescu, "Fast Encryption and Authentication: XCBC Encryption and XECB Authentication Modes". Proc. Fast Software Encryption, 2001: 92-108.<a href="#fnref28">↩</a></li>
<li id="fn29">Charanjit S. Jutla, "Encryption Modes with Almost Free Message Integrity", Proc. Eurocrypt 2001, LNCS 2045, May 2001.<a href="#fnref29">↩</a></li>
<li id="fn30"></li>
<li id="fn31"><a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/modes_development.html">NIST: Modes Development</a><a href="#fnref31">↩</a></li>
</ol>
</section>
</body>
</html>
