<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="634">Topological data analysis</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Topological data analysis</h1>
<hr/>

<p><strong>Topological data analysis</strong> (<strong>TDA</strong>) is a new area of study aimed at having applications in areas such as <a href="data_mining" title="wikilink">data mining</a> and <a href="computer_vision" title="wikilink">computer vision</a>. The main problems are:</p>
<ol>
<li>how one infers high-dimensional structure from low-dimensional representations; and</li>
<li>how one assembles discrete points into global structure.</li>
</ol>

<p>The human brain can easily extract global structure from representations in a strictly lower dimension, e.g. we infer a 3D environment from a 2D image from each eye. The inference of global structure also occurs when converting discrete data into continuous images, e.g. <a href="Dot_matrix_printing" title="wikilink">dot-matrix printers</a> and televisions communicate images via arrays of discrete points.</p>

<p>The main method used by topological data analysis is:</p>
<ol>
<li>Replace a set of data points with a family of <a href="simplicial_complex" title="wikilink">simplicial complexes</a>, indexed by a proximity parameter.</li>
<li>Analyse these topological complexes via <a href="algebraic_topology" title="wikilink">algebraic topology</a> — specifically, via the theory of <a href="persistent_homology" title="wikilink">persistent homology</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></li>
<li>Encode the persistent homology of a data set in the form of a parameterized version of a <a href="Betti_number" title="wikilink">Betti number</a> which is called a <strong>persistence diagram</strong> or <strong>barcode</strong>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></li>
</ol>
<h2 id="point-cloud-data">Point cloud data</h2>

<p>Data is often represented as points in a <a href="Euclidean_space" title="wikilink">Euclidean <em>n</em>-dimensional space</a> E<sub><em>n</em></sub>. The global <em>shape</em> of the data may provide information about the phenomena that the data represent.</p>

<p>One type of data set for which global features are certainly present is the so-called <strong><a href="point_cloud" title="wikilink">point cloud</a> data</strong> coming from physical objects in 3D. E.g. a laser can scan an object at a set of discrete points and the cloud of such points can be used in a computer representation of the object. <strong>Point cloud data</strong> is any collection of points in <em>E</em><sub><em>n</em></sub> or a (perhaps noisy) sample of points on a lower-dimensional subset.</p>

<p>For point clouds in low-dimensional spaces there are numerous approaches for inferring features based on planar projections in the fields of <a href="computer_graphics" title="wikilink">computer graphics</a> and <a class="uri" href="statistics" title="wikilink">statistics</a>. Topological data analysis is needed when the spaces are high-dimensional or too twisted to allow planar projections to faithfully represent the features of the point cloud.</p>

<p>To convert a point cloud in a <a href="metric_space" title="wikilink">metric space</a> into a global object, use the point cloud as the vertices of a <a href="Graph_(mathematics)" title="wikilink">graph</a> whose edges are determined by proximity, then turn the graph into a <a href="simplicial_complex" title="wikilink">simplicial complex</a> and use algebraic topology to study it. An alternative approach is the <a href="minimum_spanning_tree" title="wikilink">minimum spanning tree</a>-based method in the geometric data clustering.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> If a group of data points forms a cluster, then the geometry of this point cloud can be determined.</p>
<h2 id="background">Background</h2>
<ol>
<li><a class="uri" href="Topology" title="wikilink">Topology</a></li>
<li><a href="Simplicial_complex" title="wikilink">Simplicial complex</a></li>
<li><a href="Nerve_of_a_covering" title="wikilink">Nerve and cover</a></li>
</ol>

<p>Topological data analysis includes different methods and representations whose purpose is to cluster variegated data via a point cloud stated above. The following are various methods to do so.</p>
<h2 id="combinatorial-representations">Combinatorial representations</h2>
<ol>
<li><strong>Cech complex.</strong> The <a href="Cech_cohomology" title="wikilink">Cech complex</a> 

<math display="inline" id="Topological_data_analysis:0">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>ε</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>ε</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{\varepsilon}
  </annotation>
 </semantics>
</math>

 is the <a href="nerve_of_a_covering" title="wikilink"><em>nerve</em> of the <em>cover</em></a> of balls of radius 

<math display="inline" id="Topological_data_analysis:1">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 around each point in a set. Since balls are convex and convex sets are contractible, its nerve captures the topology of the cover. The Cech complex is not computed in practice due to its computational complexity. The uniform ball radii imply an assumption of uniform sampling on the input, which is not valid in a real world dataset. Non-uniform radii methods can also be used, such as in the case of the <em>alpha simplex</em>.</li>
<li><strong>Alpha complex.</strong> The <a href="Voronoi_diagram" title="wikilink">Voronoi diagram</a> is the set of all Voronoi regions for the points in 

<math display="inline" id="Topological_data_analysis:2">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⊆</mo>
   <mi>Y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <ci>Y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subseteq Y
  </annotation>
 </semantics>
</math>

. This diagram is considered a closed cover for 

<math display="inline" id="Topological_data_analysis:3">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

. The <a href="Delaunay_triangulation" title="wikilink">Delaunay complex</a> is the nerve of the Voronoi diagram. The Voronoi cover and its nerve are fundamental geometric objects and have been extensively studied within computational geometry. Alpha complexes are constructed by first building the Delaunay complex. For each simplex of the Delaunay complex, we compute the minimum scale at which each simplex enters the alpha complex. Then the simplices are sorted by their minimum scale to get a partial order of simplices. The alpha complex is not formed with any scale 

<math display="inline" id="Topological_data_analysis:4">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 using this ordering. Efficient algorithms and software exist for computing Delaunay complexes, and in turn, alpha complexes in 2 and 3 dimensions. However, the construction of the Delaunay complex is difficult in higher dimensions.</li>
<li><a href="Vietoris–Rips_complex" title="wikilink">Vietoris–Rips complex</a></li>
</ol>
<h2 id="topological-invariants">Topological invariants</h2>
<ol>
<li><strong>Definition.</strong> <a href="Topological_property" title="wikilink">Topological invariants</a></li>
<li><a href="Euler_characteristic" title="wikilink">Euler characteristic</a></li>
<li><a href="Simplicial_homology" title="wikilink">Simplicial homology</a></li>
</ol>
<h2 id="multiscale-invariants">Multiscale invariants</h2>
<ol>
<li><strong>Multifiltration model</strong>. <a href="Morse_theory" title="wikilink">Morse theory</a> enables one to analyze the topology of a manifold by studying differentiable functions on that manifold. According to the basic insights of Marston Morse, a typical differentiable function on a manifold will reflect the topology quite directly. Morse theory allows one to find CW structures and handle decompositions on manifolds and to obtain substantial information about their homology.</li>
<li><strong>Persistent homology</strong>. <em>See <a href="homology_(mathematics)" title="wikilink">homology</a> for an introduction to the notation.</em></li>
</ol>

<p>Persistent homology essentially calculates homology groups at different spatial resolutions to see which features persist over a wide range of length scales. It is assumed that important features and structures are the ones that persist. We define persistent homology as follows: Let 

<math display="inline" id="Topological_data_analysis:5">
 <semantics>
  <msup>
   <mi>K</mi>
   <mi>l</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>K</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K^{l}
  </annotation>
 </semantics>
</math>

 be a <a href="filtration_(mathematics)" title="wikilink">filtration</a>. The <strong>p-persistent kth homology group</strong> of 

<math display="inline" id="Topological_data_analysis:6">
 <semantics>
  <msup>
   <mi>K</mi>
   <mi>l</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>K</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K^{l}
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Topological_data_analysis:7">
 <semantics>
  <mrow>
   <msubsup>
    <mi>H</mi>
    <mi>k</mi>
    <mrow>
     <mi>l</mi>
     <mo>,</mo>
     <mi>p</mi>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>Z</mi>
     <mi>k</mi>
     <mi>l</mi>
    </msubsup>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msubsup>
       <mi>B</mi>
       <mi>k</mi>
       <mrow>
        <mi>l</mi>
        <mo>+</mo>
        <mi>p</mi>
       </mrow>
      </msubsup>
      <mo>∩</mo>
      <msubsup>
       <mi>Z</mi>
       <mi>k</mi>
       <mi>l</mi>
      </msubsup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>k</ci>
     </apply>
     <list>
      <ci>l</ci>
      <ci>p</ci>
     </list>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Z</ci>
       <ci>k</ci>
      </apply>
      <ci>l</ci>
     </apply>
     <apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <plus></plus>
        <ci>l</ci>
        <ci>p</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Z</ci>
        <ci>k</ci>
       </apply>
       <ci>l</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{k}^{l,p}=Z_{k}^{l}/(B_{k}^{l+p}\cap Z_{k}^{l})
  </annotation>
 </semantics>
</math>

.</p>

<p>Let 

<math display="inline" id="Topological_data_analysis:8">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 be a nonbounding 

<math display="inline" id="Topological_data_analysis:9">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-cycle created at time 

<math display="inline" id="Topological_data_analysis:10">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 by simplex 

<math display="inline" id="Topological_data_analysis:11">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 and let 

<math display="inline" id="Topological_data_analysis:12">
 <semantics>
  <mrow>
   <msup>
    <mi>z</mi>
    <mo>′</mo>
   </msup>
   <mo>∼</mo>
   <mi>z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>z</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z^{\prime}\sim z
  </annotation>
 </semantics>
</math>

 be a homologous 

<math display="inline" id="Topological_data_analysis:13">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-cycle that becomes a boundary cycle at time 

<math display="inline" id="Topological_data_analysis:14">
 <semantics>
  <mi>J</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>J</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J
  </annotation>
 </semantics>
</math>

 by simplex 

<math display="inline" id="Topological_data_analysis:15">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

. Then we can define the <strong>persistence interval</strong> associated to 

<math display="inline" id="Topological_data_analysis:16">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Topological_data_analysis:17">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>I</mi>
   <mo>,</mo>
   <mi>J</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>I</ci>
    <ci>J</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (I,J)
  </annotation>
 </semantics>
</math>

. We call 

<math display="inline" id="Topological_data_analysis:18">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 the <strong>creator</strong> of 

<math display="inline" id="Topological_data_analysis:19">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Topological_data_analysis:20">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau
  </annotation>
 </semantics>
</math>

 the <strong>destroyer</strong> of 

<math display="inline" id="Topological_data_analysis:21">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Topological_data_analysis:22">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 does not have a destroyer, its persistence is 

<math display="inline" id="Topological_data_analysis:23">
 <semantics>
  <mi mathvariant="normal">∞</mi>
  <annotation-xml encoding="MathML-Content">
   <infinity></infinity>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \infty
  </annotation>
 </semantics>
</math>

. Instead of using an index-based filtration, we can use a time-based filtration. Let 

<math display="inline" id="Topological_data_analysis:24">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 be a <a href="simplicial_complex" title="wikilink">simplicial complex</a> and 

<math display="inline" id="Topological_data_analysis:25">
 <semantics>
  <mrow>
   <msup>
    <mi>K</mi>
    <mi>ρ</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <msup>
      <mi>σ</mi>
      <mi>i</mi>
     </msup>
     <mo>∈</mo>
     <mi>K</mi>
    </mrow>
    <mo>∣</mo>
    <mrow>
     <mrow>
      <mi>ρ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>σ</mi>
        <mi>i</mi>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>≤</mo>
     <mi>ρ</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>K</ci>
     <ci>ρ</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>σ</ci>
       <ci>i</ci>
      </apply>
      <ci>K</ci>
     </apply>
     <apply>
      <leq></leq>
      <apply>
       <times></times>
       <ci>ρ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>σ</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <ci>ρ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K^{\rho}=\{\sigma^{i}\in K\mid\rho(\sigma^{i})\leq\rho\}
  </annotation>
 </semantics>
</math>

 be a filtration defined for an associated map 

<math display="inline" id="Topological_data_analysis:26">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>K</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>→</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>ρ</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>S</ci>
      <ci>K</ci>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho:S(K)\rightarrow\mathbb{R}
  </annotation>
 </semantics>
</math>

 that maps simplices in the final complex to real numbers. Then for all real numbers 

<math display="inline" id="Topological_data_analysis:27">
 <semantics>
  <mrow>
   <mi>π</mi>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>π</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi\geq 0
  </annotation>
 </semantics>
</math>

, the <strong>

<math display="inline" id="Topological_data_analysis:28">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

-persistent kth homology group</strong> of 

<math display="inline" id="Topological_data_analysis:29">
 <semantics>
  <msup>
   <mi>K</mi>
   <mi>ρ</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>K</ci>
    <ci>ρ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K^{\rho}
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Topological_data_analysis:30">
 <semantics>
  <mrow>
   <msubsup>
    <mi>H</mi>
    <mi>k</mi>
    <mrow>
     <mi>ρ</mi>
     <mo>,</mo>
     <mi>π</mi>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>Z</mi>
     <mi>k</mi>
     <mi>ρ</mi>
    </msubsup>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msubsup>
       <mi>B</mi>
       <mi>k</mi>
       <mrow>
        <mi>ρ</mi>
        <mo>+</mo>
        <mi>π</mi>
       </mrow>
      </msubsup>
      <mo>∩</mo>
      <msubsup>
       <mi>Z</mi>
       <mi>k</mi>
       <mi>ρ</mi>
      </msubsup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>k</ci>
     </apply>
     <list>
      <ci>ρ</ci>
      <ci>π</ci>
     </list>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Z</ci>
       <ci>k</ci>
      </apply>
      <ci>ρ</ci>
     </apply>
     <apply>
      <intersect></intersect>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <plus></plus>
        <ci>ρ</ci>
        <ci>π</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Z</ci>
        <ci>k</ci>
       </apply>
       <ci>ρ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{k}^{\rho,\pi}=Z_{k}^{\rho}/(B_{k}^{\rho+\pi}\cap Z_{k}^{\rho})
  </annotation>
 </semantics>
</math>

. The persistence of a 

<math display="inline" id="Topological_data_analysis:31">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-cycle created at time 

<math display="inline" id="Topological_data_analysis:32">
 <semantics>
  <msub>
   <mi>ρ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ρ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{i}
  </annotation>
 </semantics>
</math>

 and destroyed at 

<math display="inline" id="Topological_data_analysis:33">
 <semantics>
  <msub>
   <mi>ρ</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ρ</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{j}
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Topological_data_analysis:34">
 <semantics>
  <mrow>
   <msub>
    <mi>ρ</mi>
    <mi>j</mi>
   </msub>
   <mo>-</mo>
   <msub>
    <mi>ρ</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ρ</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ρ</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho_{j}-\rho_{i}
  </annotation>
 </semantics>
</math>

. <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>There are various software packages for computing persistence intervals of a finite filtration, such as <a href="http://code.google.com/p/javaplex/">javaPlex</a>, <a href="http://www.mrzv.org/software/dionysus/">Dionysus</a>, <a href="http://www.sas.upenn.edu/~vnanda/perseus/index.html">Perseus</a> (which uses <a href="discrete_Morse_theory" title="wikilink">discrete Morse theory</a> to simplify the matrix algebra), <a href="http://phat.googlecode.com/">PHAT</a>, and <a href="https://project.inria.fr/gudhi/software/">Gudhi</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Dimensionality_reduction" title="wikilink">Dimensionality reduction</a></li>
<li><a href="Data_mining" title="wikilink">Data mining</a></li>
<li><a href="Computer_vision" title="wikilink">Computer vision</a></li>
<li><a href="Computational_topology" title="wikilink">Computational topology</a></li>
<li><a href="Digital_topology" title="wikilink">Digital topology</a></li>
<li><a href="Digital_Morse_theory" title="wikilink">Digital Morse theory</a></li>
<li><a href="Shape_analysis_(digital_geometry)" title="wikilink">Shape analysis</a></li>
<li><a href="Size_theory" title="wikilink">Size theory</a></li>
<li><a href="Structured_data_analysis_(statistics)" title="wikilink">Structured data analysis (statistics)</a></li>
<li><a href="Self-organizing_map" title="wikilink">Self-organizing map</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Robert Ghrist, <a href="http://www.math.upenn.edu/~ghrist/notes.html">Elementary Applied Topology</a> (2014).</li>
<li><a href="http://comptop.stanford.edu/">Topological Methods in Scientific Computing, Statistics and Computer Science</a> Stanford group</li>
<li><a href="http://www.ams.org/bull/2008-45-01/S0273-0979-07-01191-3/S0273-0979-07-01191-3.pdf">BARCODES: THE PERSISTENT TOPOLOGY OF DATA</a></li>
<li><a href="http://www.bangor.ac.uk/~mas013/TDA/TDA.html">Topological Data Analysis: the algebraic topology of point data clouds?</a></li>
<li></li>
<li><a href="https://www.ima.umn.edu/topology/">Applied algebraic topology research network</a> at the Institute for Mathematics and its Applications.</li>
<li><a href="http://www.ams.org/bull/2009-46-02/S0273-0979-09-01249-X/S0273-0979-09-01249-X.pdf">TOPOLOGY AND DATA</a>, GUNNAR CARLSSON, BULLETIN (New Series) OF THE AMERICAN MATHEMATICAL SOCIETY, Volume 46, Number 2, April 2009, Pages 255–308, Article electronically published on January 29, 2009</li>
<li><a href="http://books.google.com/books?id=MDXa6gFRZuIC">Computational Topology: An Introduction</a>, Herbert Edelsbrunner, John L. Harer, AMS Bookstore, 2010, ISBN 978-0-8218-4925-5</li>
<li><a href="http://link.springer.com/chapter/10.1007%2F978-3-642-40193-0_6">Simplicial Models and Topological Inference in Biological Systems</a> Vidit Nanda and Radmila Sazdanovic, Discrete and Topological Models in Molecular Biology, pp 109-141, 2014</li>
<li><a href="http://books.google.com/books?id=88lCsF_dmIkC">Topological Methods in Data Analysis and Visualization: Theory, Algorithms, and Applications</a>, Editors Valerio Pascucci, Hans Hagen, Xavier Tricoche, Julien Tierny, Springer, 2010, ISBN 978-3-642-15013-5</li>
<li>

<p>.</p></li>
<li><a href="http://www.ayasdi.com/resources">Ayasdi Resources on Topological Data Analysis for Big Data</a></li>
<li>Software packages for computing persistent homology: <a href="http://code.google.com/p/javaplex/">javaplex</a> and <a href="http://www.sas.upenn.edu/~vnanda/perseus">Perseus</a>.</li>
<li><a href="http://www.sas.upenn.edu/~vnanda/ats">Seminar</a> on applied topology and TDA at UPenn.</li>
</ul>

<p>"</p>

<p><a href="Category:Computational_topology" title="wikilink">Category:Computational topology</a> <a href="Category:Data_analysis" title="wikilink">Category:Data analysis</a> <a href="Category:Homology_theory" title="wikilink">Category:Homology theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3">C. T. Zahn (1971): <a href="http://web.cse.msu.edu/~cse802/Papers/zahn.pdf">"Graph-theoretical methods for detecting and describing gestalt clusters"</a>, <em>IEEE Transactions on Computers</em>, pp. 68–86, Vol. 20, No. 1<a href="#fnref3">↩</a></li>
<li id="fn4">Afra J. Zomorodian (2005): <em>Topology for Computing</em>. Cambridge Monographs on Applied and Computational Mathematics.<a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
