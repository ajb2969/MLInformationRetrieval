<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="233">FM-index</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>FM-index</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, an <strong>FM-index</strong> is a compressed full-text <a href="substring_index" title="wikilink">substring index</a> based on the <a href="Burrows-Wheeler_transform" title="wikilink">Burrows-Wheeler transform</a>, with some similarities to the <a href="suffix_array" title="wikilink">suffix array</a>. It was created by Paolo Ferragina and Giovanni Manzini,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> who describe it as an opportunistic data structure as it allows compression of the input text while still permitting fast substring queries. The name stands for Full-text index in Minute space.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>It can be used to efficiently find the number of occurrences of a pattern within the compressed text, as well as locate the position of each occurrence. Both the query time and storage space requirements are sublinear with respect to the size of the input data.</p>

<p>The original authors have devised improvements to their original approach and dubbed it "FM-Index version 2".<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> A further improvement, the alphabet-friendly FM-index, combines the use of compression boosting and <a href="Wavelet_Tree" title="wikilink">wavelet trees</a> <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> to significantly reduce the space usage for large alphabets.</p>

<p>The FM-index has found use in, among other places, <a class="uri" href="bioinformatics" title="wikilink">bioinformatics</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="background">Background</h2>

<p>Using an index is a common strategy to efficiently search a large body of text. When the text is larger than what reasonably fits within a computer's main memory, there is a need to compress not only the text but also the index. When the FM-index was introduced, there were several suggested solutions that were based on traditional compression methods and tried to solve the compressed matching problem. In contrast, the FM-index is a compressed self-index, which means that it compresses the data and indexes it at the same time.</p>
<h2 id="fm-index-data-structure">FM-index data structure</h2>

<p>An FM-index is created by first taking the <a href="Burrows-Wheeler_transform" title="wikilink">Burrows-Wheeler transform</a> (BWT) of the input text. For example, the BWT of the string 

<math display="inline" id="FM-index:0">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>T</ci>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=
  </annotation>
 </semantics>
</math>

"abracadabra" is "ard$rcaaaabb", and here it is represented by the matrix 

<math display="inline" id="FM-index:1">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 where each row is a rotation of the text, and the rows have been sorted lexicographically. The transform corresponds to the last column labeled 

<math display="inline" id="FM-index:2">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>

<math display="inline" id="FM-index:3">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="FM-index:4">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;"></th>
<th style="text-align: left;">
<p>

<math display="inline" id="FM-index:5">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p><code>$</code></p></td>
<td style="text-align: left;">
<p><code>abracadabr</code></p></td>
<td style="text-align: left;">
<p><code>a</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p><code>a</code></p></td>
<td style="text-align: left;">
<p><code>$abracadab</code></p></td>
<td style="text-align: left;">
<p><code>r</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p><code>a</code></p></td>
<td style="text-align: left;">
<p><code>bra$abraca</code></p></td>
<td style="text-align: left;">
<p><code>d</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p><code>a</code></p></td>
<td style="text-align: left;">
<p><code>bracadabra</code></p></td>
<td style="text-align: left;">
<p><code>$</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p><code>a</code></p></td>
<td style="text-align: left;">
<p><code>cadabra$ab</code></p></td>
<td style="text-align: left;">
<p><code>r</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;">
<p><code>a</code></p></td>
<td style="text-align: left;">
<p><code>dabra$abra</code></p></td>
<td style="text-align: left;">
<p><code>c</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p><code>b</code></p></td>
<td style="text-align: left;">
<p><code>ra$abracad</code></p></td>
<td style="text-align: left;">
<p><code>a</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>8</p></td>
<td style="text-align: left;">
<p><code>b</code></p></td>
<td style="text-align: left;">
<p><code>racadabra$</code></p></td>
<td style="text-align: left;">
<p><code>a</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>9</p></td>
<td style="text-align: left;">
<p><code>c</code></p></td>
<td style="text-align: left;">
<p><code>adabra$abr</code></p></td>
<td style="text-align: left;">
<p><code>a</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>10</p></td>
<td style="text-align: left;">
<p><code>d</code></p></td>
<td style="text-align: left;">
<p><code>abra$abrac</code></p></td>
<td style="text-align: left;">
<p><code>a</code></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>11</p></td>
<td style="text-align: left;">
<p><code>r</code></p></td>
<td style="text-align: left;">
<p><code>a$abracada</code></p></td>
<td style="text-align: left;">
<p><code>b</code></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>12</p></td>
<td style="text-align: left;">
<p><code>r</code></p></td>
<td style="text-align: left;">
<p><code>acadabra$a</code></p></td>
<td style="text-align: left;">
<p><code>b</code></p></td>
</tr>
</tbody>
</table>

<p>The BWT in itself allows for some compression with, for instance, <a href="move_to_front" title="wikilink">move to front</a> and <a href="Huffman_encoding" title="wikilink">Huffman encoding</a>, but the transform has even more uses. The rows in the matrix are essentially the sorted suffixes of the text and the first column F of the matrix shares similarities with <a href="suffix_array" title="wikilink">suffix arrays</a>. How the suffix array relates to the BWT lies at the heart of the FM-index.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>It is possible to make a last-to-first column mapping 

<math display="inline" id="FM-index:6">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>F</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   LF(i)
  </annotation>
 </semantics>
</math>

 from a an index 

<math display="inline" id="FM-index:7">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 to an index 

<math display="inline" id="FM-index:8">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

, such that 

<math display="inline" id="FM-index:9">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mi>j</mi>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>j</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Fjj
  </annotation>
 </semantics>
</math>

 = 

<math display="inline" id="FM-index:10">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mi>i</mi>
   <mi>i</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>i</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Lii
  </annotation>
 </semantics>
</math>

, with the help of a table 

<math display="inline" id="FM-index:11">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mi>c</mi>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>c</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ccc
  </annotation>
 </semantics>
</math>

 and a function 

<math display="inline" id="FM-index:12">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>c</mi>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>c</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>c</ci>
    <ci>c</ci>
    <interval closure="open">
     <ci>c</ci>
     <ci>k</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Occ(c,k)
  </annotation>
 </semantics>
</math>

.</p>
<ul>
<li>

<math display="inline" id="FM-index:13">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mi>c</mi>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>c</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ccc
  </annotation>
 </semantics>
</math>

 is a table that, for each character 

<math display="inline" id="FM-index:14">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 in the alphabet, contains the number of occurrences of lexically smaller characters in the text.</li>
<li>The function 

<math display="inline" id="FM-index:15">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>c</mi>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>c</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>c</ci>
    <ci>c</ci>
    <interval closure="open">
     <ci>c</ci>
     <ci>k</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Occ(c,k)
  </annotation>
 </semantics>
</math>

 is the number of occurrences of character 

<math display="inline" id="FM-index:16">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 in the prefix 

<math display="inline" id="FM-index:17">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mn>1..</mn>
   <mi>k</mi>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <cn type="float">1..</cn>
    <ci>k</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L1..kk
  </annotation>
 </semantics>
</math>

. Ferragina and Manzini showed<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> that it is possible to compute 

<math display="inline" id="FM-index:18">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>c</mi>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>c</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>c</ci>
    <ci>c</ci>
    <interval closure="open">
     <ci>c</ci>
     <ci>k</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Occ(c,k)
  </annotation>
 </semantics>
</math>

 in constant time.</li>
</ul></td>
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="FM-index:19">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mi>c</mi>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>c</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ccc
  </annotation>
 </semantics>
</math>

 of "ard$rcaaaabb"</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="FM-index:20">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>$</p></td>
<td style="text-align: left;">
<p>a</p></td>
<td style="text-align: left;">
<p>b</p></td>
<td style="text-align: left;">
<p>c</p></td>
<td style="text-align: left;">
<p>d</p></td>
<td style="text-align: left;">
<p>r</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="FM-index:21">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mi>c</mi>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>c</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ccc
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;">
<p>8</p></td>
<td style="text-align: left;">
<p>9</p></td>
<td style="text-align: left;">
<p>10</p></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>The last-to-first mapping can now be defined as 

<math display="inline" id="FM-index:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>C</mi>
    <mi>L</mi>
    <mi>L</mi>
    <mi>i</mi>
    <mi>i</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>F</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>L</ci>
     <ci>L</ci>
     <ci>i</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   LF(i)=CLLii
  </annotation>
 </semantics>
</math>

. For instance, on row 9, 

<math display="inline" id="FM-index:23">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="FM-index:24">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and the same 

<math display="inline" id="FM-index:25">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 can be found on row 5 in the first column 

<math display="inline" id="FM-index:26">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

, so 

<math display="inline" id="FM-index:27">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>9</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>F</ci>
    <cn type="integer">9</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   LF(9)
  </annotation>
 </semantics>
</math>

 should be 5 and 

<math display="inline" id="FM-index:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>9</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>C</mi>
     <mi>a</mi>
     <mi>a</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>O</mi>
     <mi>c</mi>
     <mi>c</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mn>9</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>L</ci>
      <ci>F</ci>
      <cn type="integer">9</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>C</ci>
       <ci>a</ci>
       <ci>a</ci>
      </apply>
      <apply>
       <times></times>
       <ci>O</ci>
       <ci>c</ci>
       <ci>c</ci>
       <interval closure="open">
        <ci>a</ci>
        <cn type="integer">9</cn>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">5</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   LF(9)=Caa+Occ(a,9)=5
  </annotation>
 </semantics>
</math>

. For any row 

<math display="inline" id="FM-index:29">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 of the matrix, the character in the last column 

<math display="inline" id="FM-index:30">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mi>i</mi>
   <mi>i</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>i</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Lii
  </annotation>
 </semantics>
</math>

 precedes the character in the first column 

<math display="inline" id="FM-index:31">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mi>i</mi>
   <mi>i</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>i</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Fii
  </annotation>
 </semantics>
</math>

 also in T. Finally, if 

<math display="inline" id="FM-index:32">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mi>i</mi>
    <mi>i</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>T</mi>
    <mi>k</mi>
    <mi>k</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>i</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>k</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Lii=Tkk
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="FM-index:33">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mi>L</mi>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
   <mo>=</mo>
   <mi>T</mi>
   <mi>k</mi>
   <mo>-</mo>
   <mn>11</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">L</csymbol>
    <csymbol cd="unknown">L</csymbol>
    <csymbol cd="unknown">F</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
    <eq></eq>
    <csymbol cd="unknown">T</csymbol>
    <csymbol cd="unknown">k</csymbol>
    <minus></minus>
    <cn type="integer">11</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   LLF(i))=Tk-11
  </annotation>
 </semantics>
</math>

, and using the equality it is possible to extract a string of 

<math display="inline" id="FM-index:34">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="FM-index:35">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

. The FM-index itself is a compression of the string 

<math display="inline" id="FM-index:36">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 together with 

<math display="inline" id="FM-index:37">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="FM-index:38">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>c</mi>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>c</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Occ
  </annotation>
 </semantics>
</math>

 in some form, as well as information that maps a selection of indices in 

<math display="inline" id="FM-index:39">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 to positions in the original string 

<math display="inline" id="FM-index:40">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

.</p></td>
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="FM-index:41">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>c</mi>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>c</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>c</ci>
    <ci>c</ci>
    <interval closure="open">
     <ci>c</ci>
     <ci>k</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Occ(c,k)
  </annotation>
 </semantics>
</math>

 of "ard$rcaaaabb"</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>a</p></td>
<td style="text-align: left;">
<p>r</p></td>
<td style="text-align: left;">
<p>d</p></td>
<td style="text-align: left;">
<p>$</p></td>
<td style="text-align: left;">
<p>r</p></td>
<td style="text-align: left;">
<p>c</p></td>
<td style="text-align: left;">
<p>a</p></td>
<td style="text-align: left;">
<p>a</p></td>
<td style="text-align: left;">
<p>a</p></td>
<td style="text-align: left;">
<p>a</p></td>
<td style="text-align: left;">
<p>b</p></td>
<td style="text-align: left;">
<p>b</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>8</p></td>
<td style="text-align: left;">
<p>9</p></td>
<td style="text-align: left;">
<p>10</p></td>
<td style="text-align: left;">
<p>11</p></td>
<td style="text-align: left;">
<p>12</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>$</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>a</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>5</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>b</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>2</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>c</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>d</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>r</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>2</p></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table>
<h2 id="count">Count</h2>

<p>The operation <em>count</em> takes a pattern 

<math display="inline" id="FM-index:42">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mn>1..</mn>
   <mi>p</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <cn type="float">1..</cn>
    <ci>p</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P1..pp
  </annotation>
 </semantics>
</math>

 and returns the number of occurrences of that pattern in the original text 

<math display="inline" id="FM-index:43">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

. Since the rows of matrix 

<math display="inline" id="FM-index:44">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 are sorted, and it contains every suffix of 

<math display="inline" id="FM-index:45">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

, the occurrences of pattern 

<math display="inline" id="FM-index:46">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 will be next to each other in a single continuous range. The operation iterates backwards over the pattern. For every character in the pattern, the range that has the character as a suffix is found. For example, the count of the pattern "bra" in "abracadabra" follows these steps:</p>
<ol>
<li>The first character we look for is 

<math display="inline" id="FM-index:47">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

, the last character in the pattern. The initial range is set to 

<math display="inline" id="FM-index:48">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>C</mi>
     <mi>C</mi>
     <mi>a</mi>
     <mi>a</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>1..</mn>
     <mi>C</mi>
     <mi>C</mi>
     <mi>a</mi>
    </mrow>
    <mo>+</mo>
    <mn>11</mn>
   </mrow>
   <mo>=</mo>
   <mn>2..66</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>C</ci>
      <ci>C</ci>
      <ci>a</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="float">1..</cn>
      <ci>C</ci>
      <ci>C</ci>
      <ci>a</ci>
     </apply>
     <cn type="integer">11</cn>
    </apply>
    <cn type="float">2..66</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   CCaa+1..CCa+11=2..66
  </annotation>
 </semantics>
</math>

. This range over 

<math display="inline" id="FM-index:49">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 represents every character of 

<math display="inline" id="FM-index:50">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 that has a suffix beginning with <em>a</em>.</li>
<li>The next character to look for is 

<math display="inline" id="FM-index:51">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

. The new range is 

<math display="inline" id="FM-index:52">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mi>C</mi>
   <mi>r</mi>
   <mi>r</mi>
   <mo>+</mo>
   <mi>O</mi>
   <mi>c</mi>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mi>t</mi>
    <mi>a</mi>
    <mi>r</mi>
    <mi>t</mi>
    <mo>-</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mn>1..</mn>
   <mi>C</mi>
   <mi>C</mi>
   <mi>r</mi>
   <mi>r</mi>
   <mo>+</mo>
   <mi>O</mi>
   <mi>c</mi>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>r</mi>
    <mo>,</mo>
    <mi>e</mi>
    <mi>n</mi>
    <mi>d</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
   <mo>=</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <plus></plus>
    <csymbol cd="unknown">O</csymbol>
    <csymbol cd="unknown">c</csymbol>
    <csymbol cd="unknown">c</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">s</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">r</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <cn type="float">1..</cn>
    <csymbol cd="unknown">C</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <plus></plus>
    <csymbol cd="unknown">O</csymbol>
    <csymbol cd="unknown">c</csymbol>
    <csymbol cd="unknown">c</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">r</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">e</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <csymbol cd="unknown">d</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
    <eq></eq>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   CCrr+Occ(r,start-1)+1..CCrr+Occ(r,end))=
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="FM-index:53">
 <semantics>
  <mrow>
   <mrow>
    <mn>10</mn>
    <mo>+</mo>
    <mn>0</mn>
    <mo>+</mo>
    <mn>1..10</mn>
    <mo>+</mo>
    <mn>22</mn>
   </mrow>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <cn type="integer">10</cn>
     <cn type="integer">0</cn>
     <cn type="float">1..10</cn>
     <cn type="integer">22</cn>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   10+0+1..10+22=
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="FM-index:54">
 <semantics>
  <mn>11..122</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="float">11..122</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   11..122
  </annotation>
 </semantics>
</math>

, if 

<math display="inline" id="FM-index:55">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mi>t</mi>
   <mi>a</mi>
   <mi>r</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>t</ci>
    <ci>a</ci>
    <ci>r</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   start
  </annotation>
 </semantics>
</math>

 is the index of the beginning of the range and 

<math display="inline" id="FM-index:56">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mi>n</mi>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>e</ci>
    <ci>n</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   end
  </annotation>
 </semantics>
</math>

 is the end. This range over 

<math display="inline" id="FM-index:57">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is all the characters of 

<math display="inline" id="FM-index:58">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 that have suffixes beginning with <em>ra</em>.</li>
<li>The last character to look at is 

<math display="inline" id="FM-index:59">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

. The new range is 

<math display="inline" id="FM-index:60">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mi>C</mi>
   <mi>b</mi>
   <mi>b</mi>
   <mo>+</mo>
   <mi>O</mi>
   <mi>c</mi>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mi>t</mi>
    <mi>a</mi>
    <mi>r</mi>
    <mi>t</mi>
    <mo>-</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mn>1..</mn>
   <mi>C</mi>
   <mi>C</mi>
   <mi>b</mi>
   <mi>b</mi>
   <mo>+</mo>
   <mi>O</mi>
   <mi>c</mi>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo>,</mo>
    <mi>e</mi>
    <mi>n</mi>
    <mi>d</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
   <mo>=</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <csymbol cd="unknown">b</csymbol>
    <csymbol cd="unknown">b</csymbol>
    <plus></plus>
    <csymbol cd="unknown">O</csymbol>
    <csymbol cd="unknown">c</csymbol>
    <csymbol cd="unknown">c</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">s</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">r</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <cn type="float">1..</cn>
    <csymbol cd="unknown">C</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <csymbol cd="unknown">b</csymbol>
    <csymbol cd="unknown">b</csymbol>
    <plus></plus>
    <csymbol cd="unknown">O</csymbol>
    <csymbol cd="unknown">c</csymbol>
    <csymbol cd="unknown">c</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">e</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <csymbol cd="unknown">d</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
    <eq></eq>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   CCbb+Occ(b,start-1)+1..CCbb+Occ(b,end))=
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="FM-index:61">
 <semantics>
  <mrow>
   <mrow>
    <mn>6</mn>
    <mo>+</mo>
    <mn>0</mn>
    <mo>+</mo>
    <mn>1..6</mn>
    <mo>+</mo>
    <mn>22</mn>
   </mrow>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <cn type="integer">6</cn>
     <cn type="integer">0</cn>
     <cn type="float">1..6</cn>
     <cn type="integer">22</cn>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   6+0+1..6+22=
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="FM-index:62">
 <semantics>
  <mn>7..88</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="float">7..88</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   7..88
  </annotation>
 </semantics>
</math>

. This range over 

<math display="inline" id="FM-index:63">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is all the characters that have a suffix that begins with <em>bra</em>. Now that the whole pattern has been processed, the count is the same as the size of the range: 

<math display="inline" id="FM-index:64">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mn>8</mn>
     <mo>-</mo>
     <mn>7</mn>
    </mrow>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <cn type="integer">8</cn>
      <cn type="integer">7</cn>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   8-7+1=2
  </annotation>
 </semantics>
</math>

.</li>
</ol>

<p>If the range at becomes empty or the range boundaries cross each other before the whole pattern has been looked up, the pattern does not occur in 

<math display="inline" id="FM-index:65">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

. Because 

<math display="inline" id="FM-index:66">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>c</mi>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>c</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>c</ci>
    <ci>c</ci>
    <interval closure="open">
     <ci>c</ci>
     <ci>k</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Occ(c,k)
  </annotation>
 </semantics>
</math>

 can be performed in constant time, count can complete in linear time in the length of the pattern: 

<math display="inline" id="FM-index:67">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(p)
  </annotation>
 </semantics>
</math>

 time.</p>
<h2 id="locate">Locate</h2>

<p>The operation <em>locate</em> takes as input an index of a character in 

<math display="inline" id="FM-index:68">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 and returns its position 

<math display="inline" id="FM-index:69">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="FM-index:70">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

. For instance 

<math display="inline" id="FM-index:71">
 <semantics>
  <mrow>
   <mrow>
    <mi>l</mi>
    <mi>o</mi>
    <mi>c</mi>
    <mi>a</mi>
    <mi>t</mi>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>7</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>8</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <ci>c</ci>
     <ci>a</ci>
     <ci>t</ci>
     <ci>e</ci>
     <cn type="integer">7</cn>
    </apply>
    <cn type="integer">8</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   locate(7)=8
  </annotation>
 </semantics>
</math>

. To locate every occurrence of a pattern, first the range of character is found whose suffix is the pattern in the same way the <em>count</em> operation found the range. Then the position of every character in the range can be located.</p>

<p>To map an index in 

<math display="inline" id="FM-index:72">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 to one in 

<math display="inline" id="FM-index:73">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

, a subset of the indices in 

<math display="inline" id="FM-index:74">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 are associated with a position in 

<math display="inline" id="FM-index:75">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="FM-index:76">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mi>j</mi>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>j</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ljj
  </annotation>
 </semantics>
</math>

 has a position associated with it, 

<math display="inline" id="FM-index:77">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mi>o</mi>
   <mi>c</mi>
   <mi>a</mi>
   <mi>t</mi>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>j</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <ci>o</ci>
    <ci>c</ci>
    <ci>a</ci>
    <ci>t</ci>
    <ci>e</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   locate(j)
  </annotation>
 </semantics>
</math>

 is trivial. If it's not associated, the string is followed with 

<math display="inline" id="FM-index:78">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <ci>F</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   LF(i)
  </annotation>
 </semantics>
</math>

 until an associated index is found. By associating a suitable number of indices, an upper bound can be found. <em>Locate</em> can be implemented to find <em>occ</em> occurrences of a pattern 

<math display="inline" id="FM-index:79">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mn>1..</mn>
   <mi>p</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <cn type="float">1..</cn>
    <ci>p</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P1..pp
  </annotation>
 </semantics>
</math>

 in a text 

<math display="inline" id="FM-index:80">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mn>1..</mn>
   <mi>u</mi>
   <mi>u</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <cn type="float">1..</cn>
    <ci>u</ci>
    <ci>u</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T1..uu
  </annotation>
 </semantics>
</math>

 in <mtpl></mtpl> time with 

<math display="inline" id="FM-index:81">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>H</mi>
       <mi>k</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>T</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mfrac>
      <mrow>
       <mi>log</mi>
       <mrow>
        <mi>log</mi>
        <mi>u</mi>
       </mrow>
      </mrow>
      <mrow>
       <msup>
        <mi>log</mi>
        <mi>ϵ</mi>
       </msup>
       <mi>u</mi>
      </mrow>
     </mfrac>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>H</ci>
       <ci>k</ci>
      </apply>
      <ci>T</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <log></log>
       <apply>
        <log></log>
        <ci>u</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <log></log>
        <ci>ϵ</ci>
       </apply>
       <ci>u</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(H_{k}(T)+{{\log\log u}\over{\log^{\epsilon}u}})
  </annotation>
 </semantics>
</math>

 bits per input symbol for any 

<math display="inline" id="FM-index:82">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mi mathvariant="normal">≥</mi>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>k</ci>
    <ci>normal-≥</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k≥0
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="applications">Applications</h2>
<h3 id="dna-read-mapping">DNA read mapping</h3>

<p>FM index with Backtracking has been successfully (&gt;2000 citations) applied to approximate string matching/sequence alignment, See Bowtie <a class="uri" href="http://bowtie-bio.sourceforge.net/index.shtml">http://bowtie-bio.sourceforge.net/index.shtml</a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Burrows–Wheeler_transform" title="wikilink">Burrows–Wheeler transform</a></li>
<li><a href="Suffix_array" title="wikilink">Suffix array</a></li>
<li><a href="Compressed_suffix_array" title="wikilink">Compressed suffix array</a></li>
<li><a href="Sequence_alignment" title="wikilink">Sequence alignment</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Substring_indices" title="wikilink">Category:Substring indices</a> <a href="Category:String_data_structures" title="wikilink">Category:String data structures</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Paolo Ferragina and Giovanni Manzini (2000). "Opportunistic Data Structures with Applications". Proceedings of the 41st Annual Symposium on Foundations of Computer Science. p.390.<a href="#fnref1">↩</a></li>
<li id="fn2">Paolo Ferragina and Giovanni Manzini (2005). "Indexing Compressed Text". Journal of the ACM (JACM), 52, 4 (Jul. 2005). p. 553<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="http://www.di.unipi.it/~ferragin/Libraries/fmindexV2/index.html">Paolo Ferragina and Rossano Venturini "FM-Index version 2"</a><a href="#fnref3">↩</a></li>
<li id="fn4">P. Ferragina, G. Manzini, V. Mäkinen and G. Navarro. An Alphabet-Friendly FM-index. <em>In Proc. SPIRE'04</em>, pages 150-160. LNCS 3246.<a href="#fnref4">↩</a></li>
<li id="fn5">Simpson, Jared T. and Durbin, Richard (2010). "Efficient construction of an assembly string graph using the FM-index". Bioinformatics, 26, 12 (Jun. 17). p. i367<a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
</ol>
</section>
</body>
</html>
