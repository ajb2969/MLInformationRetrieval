<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="37">MAX-3SAT</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>MAX-3SAT</h1>
<hr/>

<p><strong>MAX-3SAT</strong> is a problem in the <a href="Computational_complexity_theory" title="wikilink">computational complexity</a> subfield of <a href="computer_science" title="wikilink">computer science</a>. It generalises the <a href="Boolean_satisfiability_problem" title="wikilink">Boolean satisfiability problem</a> (SAT) which is a <a href="decision_problem" title="wikilink">decision problem</a> considered in <a href="computational_complexity_theory" title="wikilink">complexity theory</a>. It is defined as:</p>

<p><em>Given a <a class="uri" href="3-CNF" title="wikilink">3-CNF</a> formula Φ (i.e. with at most 3 variables per clause), find an assignment that satisfies the largest number of clauses.</em></p>

<p><strong>MAX-3SAT</strong> is a canonical <a href="complete_(complexity)" title="wikilink">complete</a> problem for the complexity class <a class="uri" href="MAXSNP" title="wikilink">MAXSNP</a> (shown complete in Papadimitriou pg. 314).</p>
<h2 id="approximability">Approximability</h2>

<p>The decision version of <strong>MAX-3SAT</strong> is <a class="uri" href="NP-complete" title="wikilink">NP-complete</a>. Therefore, a <a class="uri" href="polynomial-time" title="wikilink">polynomial-time</a> solution can only be achieved if <a href="P_=_NP" title="wikilink">P = NP</a>. An approximation within a factor of 2 can be achieved with this simple algorithm, however:</p>
<ul>
<li>Output the solution in which most clauses are satisfied, when either all variables = TRUE or all variables = FALSE.</li>
<li>Every clause is satisfied by one of the two solutions, therefore one solution satisfies at least half of the clauses.</li>
</ul>

<p>The <a href="Karloff-Zwick_algorithm" title="wikilink">Karloff-Zwick algorithm</a> runs in <a class="uri" href="polynomial-time" title="wikilink">polynomial-time</a> and satisfies ≥ 7/8 of the clauses.</p>
<h2 id="theorem-1-inapproximability">Theorem 1 (inapproximability)</h2>

<p>The <a href="PCP_theorem" title="wikilink">PCP theorem</a> implies that there exists an ε &gt; 0 such that (1-ε)-approximation of <strong>MAX-3SAT</strong> is <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>.</p>

<p>Proof:</p>

<p>Any <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> problem <em>L</em> ∈ <em>PCP(O(log (n)), O(1))</em> by the <a href="PCP_theorem" title="wikilink">PCP theorem</a>. For x ∈ <em>L</em>, a <a class="uri" href="3-CNF" title="wikilink">3-CNF</a> formula Ψ<sub>x</sub> is constructed so that</p>
<ul>
<li><em>x</em> ∈ <em>L</em> ⇒ Ψ<sub>x</sub> is satisfiable</li>
<li><em>x</em> ∉ <em>L</em> ⇒ no more than (1-ε)m clauses of Ψ<sub>x</sub> are satisfiable.</li>
</ul>

<p>The Verifier <em>V</em> reads all required bits at once i.e. makes non-adaptive queries. This is valid because the number of queries remains constant.</p>
<ul>
<li>Let <em>q</em> be the number of queries.</li>
<li>Enumerating all random strings <em>R</em><sub>i</sub> ∈ <em>V</em>, we obtain <em>poly(x)</em> strings since the length of each string <em>r(x) = O(log |x|)</em>.</li>
<li>For each <em>R</em><sub>i</sub>
<ul>
<li><em>V</em> chooses <em>q</em> positions <em>i</em><sub>1</sub>,...,<em>i</em><sub>q</sub> and a Boolean function <em>f</em><sub>R</sub>: {0,1}<sup>q</sup>-&gt;{0,1} and accepts if and only if <em>f</em><sub>R</sub>(π(i<sub>1</sub>,...,i<sub>q</sub>)). Here π refers to the proof obtained from the Oracle.</li>
</ul></li>
</ul>

<p>Next we try to find a <a href="Boolean_logic" title="wikilink">Boolean</a> formula to simulate this. We introduce Boolean variables <em>x</em><sub>1</sub>,...,<em>x</em><sub>l</sub>, where <em>l</em> is the length of the proof. To demonstrate that the Verifier runs in <a class="uri" href="Probabilistic" title="wikilink">Probabilistic</a> <a class="uri" href="polynomial-time" title="wikilink">polynomial-time</a>, we need a correspondence between the number of satisfiable clauses and the probability the Verifier accepts.</p>
<ul>
<li>For every <em>R</em>, add clauses representing <em>f</em><sub>R</sub>(<em>x</em><sub>i1</sub>,...,<em>x</em><sub>iq</sub>) using 2<sup>q</sup> <a class="uri" href="SAT" title="wikilink">SAT</a> clauses. Clauses of length <em>q</em> are converted to length 3 by adding new (auxiliary) variables e.g. <em>x</em><sub>2</sub> ∨ <em>x</em><sub>10</sub> ∨ <em>x</em><sub>11</sub> ∨ <em>x</em><sub>12</sub> = ( <em>x</em><sub>2</sub> ∨ <em>x</em><sub>10</sub> ∨ <em>y</em><sub>R</sub>) ∧ ( 

<math display="inline" id="MAX-3SAT:0">
 <semantics>
  <mover accent="true">
   <msub>
    <mi>y</mi>
    <mi>R</mi>
   </msub>
   <mo stretchy="false">¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bar{y_{R}}
  </annotation>
 </semantics>
</math>

 ∨ <em>x</em><sub>11</sub> ∨ <em>x</em><sub>12</sub>). This requires a maximum of <em>q</em>2<sup>q</sup> <a class="uri" href="3-SAT" title="wikilink">3-SAT</a> clauses.</li>
<li>If <em>z</em> ∈ <em>L</em> then
<ul>
<li>there is a proof π such that <em>V</em><sup>π</sup> (<em>z</em>) accepts for every <em>R</em><sub>i</sub>.</li>
<li>All clauses are satisfied if <em>x</em><sub><em>i</em></sub> = π(<em>i</em>) and the auxiliary variables are added correctly.</li>
</ul></li>
<li>If input <em>z</em> ∉ <em>L</em> then
<ul>
<li>For every assignment to <em>x</em><sub>1</sub>,...,<em>x</em><sub>l</sub> and <em>y</em><sub>R</sub>'s, the corresponding proof π(<em>i</em>) = <em>x</em><sub>i</sub> causes the Verifier to reject for half of all <em>R</em> ∈ {0,1}<sup><em>r</em>(|<em>z</em>|)</sup>.
<ul>
<li>For each <em>R</em>, one clause representing <em>f</em><sub>R</sub> fails.</li>
<li>Therefore a fraction 

<math display="inline" id="MAX-3SAT:1">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi>q</mi>
     <msup>
      <mn>2</mn>
      <mi>q</mi>
     </msup>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>q</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{2}\frac{1}{q2^{q}}
  </annotation>
 </semantics>
</math>

 of clauses fails.</li>
</ul></li>
</ul></li>
</ul>

<p>It can be concluded that if this holds for every <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> problem then the <a href="PCP_theorem" title="wikilink">PCP theorem</a> must be true.</p>
<h2 id="theorem-2">Theorem 2</h2>

<p>Håstad <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> demonstrates a tighter result than Theorem 1 i.e. the best known value for ε.</p>

<p>He constructs a PCP Verifier for <a class="uri" href="3-SAT" title="wikilink">3-SAT</a> that reads only 3 bits from the Proof.</p>

<p><em>For every ε &gt; 0, there is a PCP-verifier M for <a class="uri" href="3-SAT" title="wikilink">3-SAT</a> that reads a random string r of length O(log(n)) and computes query positions i<sub>r</sub>, j<sub>r</sub>, k<sub>r</sub> in the proof π and a bit b<sub>r</sub>. It accepts if and only if</em></p>

<p><em>π(i<sub>r</sub>) ⊕ π(j<sub>r</sub>) ⊕ π(k<sub>r</sub>) ⊕ = b<sub>r</sub>.</em></p>

<p>The Verifier has <em>completeness</em> (1-ε) and <em>soundness</em> 1/2 + ε (refer to <a href="PCP_(complexity)" title="wikilink">PCP (complexity)</a>). The Verifier satisfies</p>

<p>

<math display="inline" id="MAX-3SAT:2">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>∈</mo>
   <mi>L</mi>
   <mo>⟹</mo>
   <mo>∃</mo>
   <mi>π</mi>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msup>
     <mi>V</mi>
     <mi>π</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≥</mo>
   <mn>1</mn>
   <mo>-</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">z</csymbol>
    <in></in>
    <csymbol cd="unknown">L</csymbol>
    <implies></implies>
    <exists></exists>
    <csymbol cd="unknown">π</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <ci>π</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-]</ci>
    </cerror>
    <geq></geq>
    <cn type="integer">1</cn>
    <minus></minus>
    <csymbol cd="unknown">ϵ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z\in L\implies\exists\pi Pr[V^{\pi}(x)=1]\geq 1-\epsilon
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="MAX-3SAT:3">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>∉</mo>
   <mi>L</mi>
   <mo>⟹</mo>
   <mo>∀</mo>
   <mi>π</mi>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msup>
     <mi>V</mi>
     <mi>π</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>≤</mo>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
   <mo>+</mo>
   <mi>ϵ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">z</csymbol>
    <notin></notin>
    <csymbol cd="unknown">L</csymbol>
    <implies></implies>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">π</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <ci>π</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-]</ci>
    </cerror>
    <leq></leq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
    <plus></plus>
    <csymbol cd="unknown">ϵ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z\not\in L\implies\forall\pi Pr[V^{\pi}(x)=1]\leq\frac{1}{2}+\epsilon
  </annotation>
 </semantics>
</math>


</p>

<p>If the first of these two equations were equated to "=1" as usual, one could find a proof π by solving a system of linear equations (see <a class="uri" href="MAX-3LIN-EQN" title="wikilink">MAX-3LIN-EQN</a>) implying <a href="P_=_NP" title="wikilink">P = NP</a>.</p>
<ul>
<li>If z ∈ <em>L</em>, a fraction ≥ (1- ε) of clauses are satisfied.</li>
<li>If z ∉ <em>L</em>, then for a (1/2- ε) fraction of <em>R</em>, 1/4 clauses are contradicted.</li>
</ul>

<p>This is enough to prove the hardness of approximation ratio</p>

<p>

<math display="inline" id="MAX-3SAT:4">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mn>4</mn>
      </mfrac>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mfrac>
         <mn>1</mn>
         <mn>2</mn>
        </mfrac>
        <mo>-</mo>
        <mi>ϵ</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mi>ϵ</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>7</mn>
     <mn>8</mn>
    </mfrac>
    <mo>+</mo>
    <msup>
     <mi>ϵ</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">4</cn>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
        <ci>ϵ</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>ϵ</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <divide></divide>
      <cn type="integer">7</cn>
      <cn type="integer">8</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ϵ</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1-\frac{1}{4}(\frac{1}{2}-\epsilon)}{1-\epsilon}=\frac{7}{8}+\epsilon^{\prime}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="related-problems">Related problems</h2>

<p><strong>MAX-3SAT(B)</strong> is the restricted special case of <strong>MAX-3SAT</strong> where every variable occurs in at most <em>B</em> clauses. Before the <a href="PCP_theorem" title="wikilink">PCP theorem</a> was proven, Papadimitriou and Yannakakis<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> showed that for some fixed constant <em>B,</em> this problem is MAX SNP-hard. Consequently with the PCP theorem, it is also APX-hard. This is useful because <strong>MAX-3SAT(B)</strong> can often be used to obtain a PTAS-preserving reduction in a way that <strong>MAX-3SAT</strong> cannot. Proofs for explicit values of <em>B</em> include: all <em>B ≥ 13</em>,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> and all <em>B ≥ 3</em><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> (which is best possible).</p>

<p>Moreover, although the decision problem <a class="uri" href="2SAT" title="wikilink">2SAT</a> is solvable in polynomial time, <strong><a class="uri" href="MAX-2SAT" title="wikilink">MAX-2SAT</a>(3)</strong> is also APX-hard.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>The best possible approximation ratio for <strong>MAX-3SAT(B),</strong> as a function of <em>B,</em> is at least 

<math display="inline" id="MAX-3SAT:5">
 <semantics>
  <mrow>
   <mrow>
    <mn>7</mn>
    <mo>/</mo>
    <mn>8</mn>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi mathvariant="normal">Ω</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <divide></divide>
     <cn type="integer">7</cn>
     <cn type="integer">8</cn>
    </apply>
    <apply>
     <times></times>
     <ci>normal-Ω</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   7/8+\Omega(1/B)
  </annotation>
 </semantics>
</math>

 and at most 

<math display="inline" id="MAX-3SAT:6">
 <semantics>
  <mrow>
   <mrow>
    <mn>7</mn>
    <mo>/</mo>
    <mn>8</mn>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <msqrt>
       <mi>B</mi>
      </msqrt>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <divide></divide>
     <cn type="integer">7</cn>
     <cn type="integer">8</cn>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   7/8+O(1/\sqrt{B})
  </annotation>
 </semantics>
</math>

,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> unless <strong>NP</strong>=<strong>RP</strong>. Some explicit bounds on the approximability constants for certain values of <em>B</em> are known.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> <a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> <a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> Berman, Karpinski and Scott proved that for the "critical" instances of <strong>MAX-3SAT</strong> in which each literal occurs exactly twice, and each clause is exactly of size 3, the problem is approximation hard for some constant factor.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p><a href="MAXEkSAT" title="wikilink">MAX-EkSAT</a> is a parameterized version of <strong>MAX-3SAT</strong> where every clause has <em>exactly</em> 

<math display="inline" id="MAX-3SAT:7">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 literals, for <em>k</em> ≥ 3. It can be efficiently approximated with approximation ratio 

<math display="inline" id="MAX-3SAT:8">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-(1/2)^{k}
  </annotation>
 </semantics>
</math>


 using ideas from <a href="error_correcting_codes" title="wikilink">coding theory</a>.</p>

<p>It has been proved that random instances of <strong>MAX-3SAT</strong> can be approximated to within factor 9/8.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h2 id="references">References</h2>

<p><a href="http://www.cs.berkeley.edu/~luca/notes/">Lecture Notes from University of California, Berkeley</a> <a href="http://www.cse.buffalo.edu/~atri/courses/coding-theory/">Coding theory notes at University at Buffalo</a></p>

<p>"</p>

<p><a href="Category:Satisfiability_problems" title="wikilink">Category:Satisfiability problems</a> <a href="Category:NP-hard_problems" title="wikilink">Category:NP-hard problems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">Christos Papadimitriou and Mihalis Yannakakis, Optimization, approximation, and complexity classes, Proceedings of the twentieth annual ACM symposium on Theory of computing, p.229-234, May 02–04, 1988.<a href="#fnref2">↩</a></li>
<li id="fn3">Rudich et al., "Computational Complexity Theory," IAS/Park City Mathematics Series, 2004 page 108 ISBN 0-8218-2872-X<a href="#fnref3">↩</a></li>
<li id="fn4">Sanjeev Arora, "<a href="http://www.cs.princeton.edu/~arora/pubs/thesis.pdf">Probabilistic Checking of Proofs and Hardness of Approximation Problems</a>," Revised version of a dissertation submitted at CS Division, U C Berkeley, in August 1994. CS-TR-476-94. Section 7.2.<a href="#fnref4">↩</a></li>
<li id="fn5">Ausiello, G., Crescenzi, P., Gambosi, G., Kann, V., Marchetti Spaccamela, A., and Protasi, M. (1999), Complexity and Approximation. Combinatorial Optimization Problems and their Approximability Properties, Springer-Verlag, Berlin. Section 8.4.<a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7">Luca Trevisan. 2001. Non-approximability results for optimization problems on bounded degree instances. In Proceedings of the thirty-third annual ACM symposium on Theory of computing (STOC '01). ACM, New York, NY, USA, 453-461. DOI=10.1145/380752.380839 <a class="uri" href="http://doi.acm.org/10.1145/380752.380839">http://doi.acm.org/10.1145/380752.380839</a><a href="#fnref7">↩</a></li>
<li id="fn8">On some tighter inapproximability results, Piotr Berman and Marek Karpinski, Proc. ICALP 1999, pages 200--209.<a href="#fnref8">↩</a></li>
<li id="fn9">P. Berman and M. Karpinski, Improved Approximation Lower Bounds on Small Occurrence Optimization, <a href="http://eccc.hpi-web.de/report/2003/008/">ECCC TR 03-008 (2003)</a><a href="#fnref9">↩</a></li>
<li id="fn10">P. Berman, M. Karpinski and A. D. Scott, Approximation Hardness and Satisfiability of Bounded Occurrence Instances of SAT, <a href="http://eccc.hpi-web.de/report/2003/022/">ECCC TR 03-022 (2003)</a>.<a href="#fnref10">↩</a></li>
<li id="fn11">P. Berman, M. Karpinski and A. D. Scott, Approximation Hardness of Short Symmetric Instances of MAX-3SAT, <a href="http://eccc.hpi-web.de/report/2003/049/">ECCC TR 03-049 (2003).</a><a href="#fnref11">↩</a></li>
<li id="fn12">W.F.de la Vega and M.Karpinski, 9/8-Approximation Algorithm for Random MAX-3SAT, <a href="http://eccc.hpi-web.de/report/2002/070/">ECCC TR 02-070 (2002)</a>;RAIRO-Operations Research 41(2007),pp.95-107]<a href="#fnref12">↩</a></li>
</ol>
</section>
</body>
</html>
