<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="476">Homomorphism</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Homomorphism</h1>
<hr/>

<p>In <a href="abstract_algebra" title="wikilink">abstract algebra</a>, a <strong>homomorphism</strong> is a <a href="morphism" title="wikilink">structure-preserving</a> <a href="map_(mathematics)" title="wikilink">map</a> between two <a href="algebraic_structure" title="wikilink">algebraic structures</a> (such as <a href="group_(mathematics)" title="wikilink">groups</a>, <a href="ring_(mathematics)" title="wikilink">rings</a>, or <a href="vector_space" title="wikilink">vector spaces</a>). The word <em>homomorphism</em> comes from the <a href="ancient_Greek_language" title="wikilink">ancient Greek language</a>: <em><a href="wikt:ὁμός" title="wikilink">ὁμός</a> (homos)</em> meaning "same" and <em><a href="wikt:μορφή" title="wikilink">μορφή</a> (morphe)</em> meaning "form" or "shape". <a href="Isomorphism" title="wikilink">Isomorphisms</a>, <a href="automorphism" title="wikilink">automorphisms</a>, and <a href="endomorphism" title="wikilink">endomorphisms</a> are special types of homomorphisms.</p>
<h2 id="definition-and-illustration">Definition and illustration</h2>
<h3 id="definition">Definition</h3>

<p>A homomorphism is a map that preserves selected structure between two <a href="algebraic_structure" title="wikilink">algebraic structures</a>, with the structure to be preserved being given by the naming of the homomorphism.</p>

<p>Particular definitions of homomorphism include the following:</p>
<ul>
<li>A <a href="semigroup_homomorphism" title="wikilink">semigroup homomorphism</a> is a map that preserves an <a class="uri" href="associative" title="wikilink">associative</a> <a href="binary_operation" title="wikilink">binary operation</a>.</li>
<li>A <a href="monoid_homomorphism" title="wikilink">monoid homomorphism</a> is a semigroup homomorphism that maps the identity element to the identity of the codomain.</li>
<li>A <a href="group_homomorphism" title="wikilink">group homomorphism</a> is a homomorphism that preserves the group structure. It may equivalently be defined as a semigroup homomorphism between groups.</li>
<li>A <a href="ring_homomorphism" title="wikilink">ring homomorphism</a> is a homomorphism that preserves the ring structure. Whether the multiplicative identity is to be preserved depends upon the definition of <em>ring</em> in use.</li>
<li>A <a href="linear_map" title="wikilink">linear map</a> is a homomorphism that preserves the vector space structure, namely the abelian group structure and scalar multiplication. The scalar type must further be specified to specify the homomorphism, e.g. every <strong>R</strong>-linear map is a <strong>Z</strong>-linear map, but not vice versa.</li>
<li>A <a href="module_homomorphism" title="wikilink">module homomorphism</a> is a map that preserves module structures.</li>
<li>An <a href="algebra_homomorphism" title="wikilink">algebra homomorphism</a> is a homomorphism that preserves the <a href="algebra_over_a_field" title="wikilink">algebra</a> structure.</li>
<li>A <a class="uri" href="functor" title="wikilink">functor</a> is a homomorphism between two <a href="category_(mathematics)" title="wikilink">categories</a>.</li>
</ul>

<p>Not all structure that an object possesses need be preserved by a homomorphism. For example, one may have a semigroup homomorphism between two monoids, and this will not be a monoid homomorphism if it does not map the identity of the <a href="domain_of_a_function" title="wikilink">domain</a> to that of the <a class="uri" href="codomain" title="wikilink">codomain</a>.</p>

<p>For example, a group is an algebraic object consisting of a <a href="set_(mathematics)" title="wikilink">set</a> together with a single binary operation, satisfying certain axioms. If  and  are groups, a <strong>homomorphism</strong> from  to  is a function  such that <mtpl></mtpl> for all elements <mtpl></mtpl>. Since inverses exist in <em>G</em> and <em>H</em>, one can show that the identity of <em>G</em> maps to the identity of <em>H</em> and that inverses are preserved.</p>

<p>The algebraic structure to be preserved may include more than one operation, and a homomorphism is required to preserve each operation. For example, a ring has both addition and multiplication, and a homomorphism from the ring  to the ring  is a function such that ,  and  for any elements <em>r</em> and <em>s</em> of the domain ring. If rings are not required to be unital, the last condition is omitted. In addition, if defining structures of (e.g. 0 and additive inverses in the case of a ring) were not necessarily preserved by the above, preserving these would be added requirements.</p>

<p>The notion of a homomorphism can be given a formal definition in the context of <a href="universal_algebra" title="wikilink">universal algebra</a>, a field which studies ideas common to all algebraic structures. In this setting, a homomorphism  is a function between two algebraic structures of the same type such that</p>
<dl>
<dd><em>f</em>(μ<sub><em>A</em></sub>(<em>a</em><sub>1</sub>, ..., <em>a</em><sub><em>n</em></sub>)) = μ<sub><em>B</em></sub>(<em>f</em>(<em>a</em><sub>1</sub>), ..., <em>f</em>(<em>a</em><sub><em>n</em></sub>))
</dd>
</dl>

<p>for each <em>n</em>-ary operation <em>μ</em> and for all elements <mtpl></mtpl>.</p>
<h3 id="basic-examples">Basic examples</h3>

<p> The <a href="real_number" title="wikilink">real numbers</a> are a <a href="ring_(mathematics)" title="wikilink">ring</a>, having both addition and multiplication. The set of all 2 × 2 <a href="matrix_(mathematics)" title="wikilink">matrices</a> is also a ring, under <a href="matrix_addition" title="wikilink">matrix addition</a> and <a href="matrix_multiplication" title="wikilink">matrix multiplication</a>. If we define a function between these rings as follows:</p>

<p>

<math display="block" id="Homomorphism:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>r</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mi>r</mi>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mi>r</mi>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>r</ci>
    </apply>
    <matrix>
     <matrixrow>
      <ci>r</ci>
      <cn type="integer">0</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">0</cn>
      <ci>r</ci>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(r)=\begin{pmatrix}r&0\\
0&r\end{pmatrix}
  </annotation>
 </semantics>
</math>

 where <em>r</em> is a real number, then <em>f</em> is a homomorphism of rings, since <em>f</em> preserves both addition:</p>

<p>

<math display="block" id="Homomorphism:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>r</mi>
      <mo>+</mo>
      <mi>s</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi>r</mi>
        <mo>+</mo>
        <mi>s</mi>
       </mrow>
      </mtd>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="center">
       <mrow>
        <mi>r</mi>
        <mo>+</mo>
        <mi>s</mi>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mi>r</mi>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mi>r</mi>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mi>s</mi>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mi>s</mi>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>r</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <plus></plus>
       <ci>r</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <matrix>
      <matrixrow>
       <apply>
        <plus></plus>
        <ci>r</ci>
        <ci>s</ci>
       </apply>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <apply>
        <plus></plus>
        <ci>r</ci>
        <ci>s</ci>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <matrix>
       <matrixrow>
        <ci>r</ci>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <ci>r</ci>
       </matrixrow>
      </matrix>
      <matrix>
       <matrixrow>
        <ci>s</ci>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <ci>s</ci>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>r</ci>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(r+s)=\begin{pmatrix}r+s&0\\
0&r+s\end{pmatrix}=\begin{pmatrix}r&0\\
0&r\end{pmatrix}+\begin{pmatrix}s&0\\
0&s\end{pmatrix}=f(r)+f(s)
  </annotation>
 </semantics>
</math>

 and multiplication:</p>

<p>

<math display="block" id="Homomorphism:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>r</mi>
       <mi>s</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mi>r</mi>
         <mi>s</mi>
        </mrow>
       </mtd>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
       <mtd columnalign="center">
        <mrow>
         <mi>r</mi>
         <mi>s</mi>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mi>r</mi>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mi>r</mi>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mi>s</mi>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
        <mtd columnalign="center">
         <mi>s</mi>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>r</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>r</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <matrix>
      <matrixrow>
       <apply>
        <times></times>
        <ci>r</ci>
        <ci>s</ci>
       </apply>
       <cn type="integer">0</cn>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
       <apply>
        <times></times>
        <ci>r</ci>
        <ci>s</ci>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <matrix>
       <matrixrow>
        <ci>r</ci>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <ci>r</ci>
       </matrixrow>
      </matrix>
      <matrix>
       <matrixrow>
        <ci>s</ci>
        <cn type="integer">0</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
        <ci>s</ci>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>r</ci>
      <ci>f</ci>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(rs)=\begin{pmatrix}rs&0\\
0&rs\end{pmatrix}=\begin{pmatrix}r&0\\
0&r\end{pmatrix}\begin{pmatrix}s&0\\
0&s\end{pmatrix}=f(r)\,f(s).
  </annotation>
 </semantics>
</math>

</p>

<p>For another example, the nonzero <a href="complex_number" title="wikilink">complex numbers</a> form a <a href="group_(mathematics)" title="wikilink">group</a> under the operation of multiplication, as do the nonzero real numbers. (Zero must be excluded from both groups since it does not have a <a href="multiplicative_inverse" title="wikilink">multiplicative inverse</a>, which is required for elements of a group.) Define a function <em>f</em> from the nonzero complex numbers to the nonzero real numbers by</p>
<dl>
<dd><em>f</em>(<em>z</em>) = |<em>z</em>|.
</dd>
</dl>

<p>That is, <em>ƒ</em>(<em>z</em>) is the <a href="absolute_value" title="wikilink">absolute value</a> (or modulus) of the complex number <em>z</em>. Then <em>f</em> is a homomorphism of groups, since it preserves multiplication:</p>
<dl>
<dd><em>f</em>(<em>z</em><sub>1</sub> <em>z</em><sub>2</sub>) = |<em>z</em><sub>1</sub> <em>z</em><sub>2</sub>| = |<em>z</em><sub>1</sub>| |<em>z</em><sub>2</sub>| = f(<em>z</em><sub>1</sub>) f(<em>z</em><sub>2</sub>).
</dd>
</dl>

<p>Note that <em>ƒ</em> cannot be extended to a homomorphism of rings (from the complex numbers to the real numbers), since it does not preserve addition:</p>
<dl>
<dd>|<em>z</em><sub>1</sub> + <em>z</em><sub>2</sub>| ≠ |<em>z</em><sub>1</sub>| + |<em>z</em><sub>2</sub>|.
</dd>
</dl>

<p>As another example, the picture shows a <a class="uri" href="monoid" title="wikilink">monoid</a> homomorphism <em>f</em> from the monoid  to the monoid . Due to the different names of corresponding operations, the structure preservation properties satisfied by <em>f</em> amount to  and .</p>
<h2 id="informal-discussion">Informal discussion</h2>

<p>Because abstract algebra studies <a href="Set_(mathematics)" title="wikilink">sets</a> endowed with <a href="Operation_(mathematics)" title="wikilink">operations</a> that generate interesting structure or properties on the set, <a href="function_(mathematics)" title="wikilink">functions</a> which preserve the operations are especially important. These functions are known as <em>homomorphisms</em>.</p>

<p>For example, consider the <a href="natural_number" title="wikilink">natural numbers</a> with addition as the operation. A function which preserves addition should have this property: . For example,  is one such homomorphism, since . Note that this homomorphism maps the natural numbers back into themselves.</p>

<p>Homomorphisms do not have to map between sets which have the same operations. For example, operation-preserving functions exist between the set of <a href="real_numbers" title="wikilink">real numbers</a> ℝ with addition and the <a href="positive_real_numbers" title="wikilink">positive real numbers</a> ℝ<sup>+</sup> with multiplication. A function which preserves operation should have this property: , since addition is the operation in the first set and multiplication is the operation in the second. Given the laws of <a href="exponent" title="wikilink">exponents</a>, <mtpl></mtpl> satisfies this condition:  translates into <mtpl></mtpl>.</p>

<p>If we are considering multiple operations on a set, then all operations must be preserved for a function to be considered as a homomorphism. Even though the set may be the same, the same function might be a group homomorphism, (a single binary operation, an inverse operation, being a unary operation, and identity, being a nullary operation) but not a ring isomorphism (two binary operations, the additive inverse and the identity elements), because it may fail to preserve the additional monoid structure required by the definition of a ring.</p>
<h2 id="specific-kinds-of-homomorphisms">Specific kinds of homomorphisms</h2>
<figure><b>(Figure)</b>
<figcaption>Relationships between different kinds of homomorphisms.<br/>
<em>Hom</em> = set of Homomorphisms,<br/>
<em>Mon</em> = set of Monomorphisms,<br/>
<em>Epi</em> = set of Epimorphisms,<br/>
<em>Iso</em> = set of Isomorphisms,<br/>
<em>End</em> = set of Endomorphism,<br/>
<em>Aut</em> = set of Automorphisms.<br/>
 Notice that: , .<br/>
The sets  and  contain only homomorphisms from some infinite structures to themselves.</figcaption>
</figure>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>[Proof 1]</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>For each <em>n</em>-ary operation <em>μ</em> and all <em>b</em><sub>1</sub>,...,<em>b</em><sub><em>n</em></sub> ∈ <em>B</em>:</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>=</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>=</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>=</p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="even">
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>[Proof 2]</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>If <em>g</em> is a left inverse of <em>f</em>,</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>and <em>f</em>(<em>g</em><sub>1</sub>(<em>b</em>)) = <em>f</em>(<em>g</em><sub>2</sub>(<em>b</em>)), then</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>=</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>=</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>=</p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>[Proof 3]</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>If <em>g</em> is a right inverse of <em>f</em>,</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>and <em>g</em><sub>1</sub>(<em>f</em>(<em>a</em>)) = <em>g</em><sub>2</sub>(<em>f</em>(<em>a</em>)) for each <em>a</em> ∈ <em>A</em>, then</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>=</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>=</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>=</p></td>
</tr>
</tbody>
</table></td>
</tr>
</tbody>
</table>

<p>In abstract algebra, several specific kinds of homomorphisms are defined as follows:</p>
<ul>
<li>An <strong><a class="uri" href="isomorphism" title="wikilink">isomorphism</a></strong> is a <a class="uri" href="bijective" title="wikilink">bijective</a> homomorphism.</li>
<li>An <strong><a class="uri" href="epimorphism" title="wikilink">epimorphism</a></strong> (sometimes called a <a href="cover_(algebra)" title="wikilink">cover</a>) is a <a class="uri" href="surjective" title="wikilink">surjective</a> homomorphism. Equivalently, <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> <em>f</em>: <em>A</em> → <em>B</em> is an epimorphism if it has a right inverse <em>g</em>: <em>B</em> → <em>A</em>, i.e. if <em>f</em>(<em>g</em>(<em>b</em>)) = <em>b</em> for all <em>b</em> ∈ <em>B</em>.</li>
<li>A <strong><a class="uri" href="monomorphism" title="wikilink">monomorphism</a></strong> (sometimes called an <a class="uri" href="embedding" title="wikilink">embedding</a> or <a href="extension_(model_theory)" title="wikilink">extension</a>) is an <a class="uri" href="injective" title="wikilink">injective</a> homomorphism. Equivalently, <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> <em>f</em>: <em>A</em> → <em>B</em> is a monomorphism if it has a left inverse <em>g</em>: <em>B</em> → <em>A</em>, i.e. if <em>g</em>(<em>f</em>(<em>a</em>)) = <em>a</em> for all <em>a</em> ∈ <em>A</em>.</li>
<li>An <strong><a class="uri" href="endomorphism" title="wikilink">endomorphism</a></strong> is a homomorphism from an algebraic structure to itself.</li>
<li>An <strong><a class="uri" href="automorphism" title="wikilink">automorphism</a></strong> is an endomorphism which is also an isomorphism, i.e., an isomorphism from an algebraic structure to itself.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></li>
<li>The <strong>trivial homomorphism</strong> between unital magmas is the <a href="constant_map" title="wikilink">constant map</a> onto the identity element of the codomain.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></li>
</ul>

<p>These descriptions may be used in order to derive several properties. For instance, since a function is bijective if and only if it is both injective and surjective, in abstract algebra a homomorphism is an isomorphism if and only if it is both a monomorphism and an epimorphism. An isomorphism always has an inverse <em>f</em><sup>−1</sup>, which is a homomorphism, too (cf. Proof 1). If there is an isomorphism between two algebraic structures, they are completely indistinguishable as far as the structure in question is concerned; in this case, they are said to be <em>isomorphic</em>.</p>
<h3 id="relation-to-category-theory">Relation to category theory</h3>

<p>Since homomorphisms are <a href="morphism" title="wikilink">morphisms</a> in an appropriate category, we may consider the analogous <a href="Morphism#Some_specific_morphisms" title="wikilink">specific kinds of morphisms</a> defined in any category. However, the definitions in <a href="category_theory" title="wikilink">category theory</a> are somewhat different. For endomorphisms and automorphisms, the descriptions above coincide with the category theoretic definitions; the first three descriptions do not. In category theory, a morphism <em>f</em> : <em>A</em> → <em>B</em> is called:</p>
<ul>
<li><strong>monomorphism</strong> if <mtpl></mtpl> implies <mtpl></mtpl> for all morphisms <mtpl></mtpl>, where "∘" denotes function composition corresponding to e.g. <mtpl></mtpl> in abstract algebra. (A sufficient condition for this is <em>f</em> having a left inverse, cf. Proof 2.)</li>
<li><strong>epimorphism</strong> if <mtpl></mtpl> implies <mtpl></mtpl> for all morphisms <mtpl></mtpl>. (A sufficient condition for this is <em>f</em> having a right inverse, cf. Proof 3.)</li>
<li><strong>isomorphism</strong> if there exists a morphism  such that <mtpl></mtpl> and <mtpl></mtpl>, where "1<sub><em>X</em></sub>" denotes the identity morphism on the object <em>X</em>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
</ul>

<p>For instance, the inclusion <a href="ring_homomorphism" title="wikilink">ring homomorphism</a> of <a href="Integer" title="wikilink"><strong>Z</strong></a> as a (unitary) subring of <a href="rational_number" title="wikilink"><strong>Q</strong></a> is not surjective (i.e. not epi in the set-theoretic sense), but an epimorphic in the sense of category theory.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> This inclusion thus also is an example of a ring homomorphism which is (in the sense of category theory) both mono and epi, but not iso.</p>
<h2 id="kernel-of-a-homomorphism">Kernel of a homomorphism</h2>

<p>Any homomorphism  defines an <a href="equivalence_relation" title="wikilink">equivalence relation</a> ~ on <em>X</em> by  if and only if . The relation ~ is called the <strong>kernel</strong> of <em>f</em>. It is a <a href="congruence_relation" title="wikilink">congruence relation</a> on <em>X</em>. The <a href="quotient_set" title="wikilink">quotient set</a>  can then be given an object-structure in a natural way, i.e. . In that case the image of <em>X</em> in <em>Y</em> under the homomorphism <em>f</em> is necessarily <a class="uri" href="isomorphic" title="wikilink">isomorphic</a> to ; this fact is one of the <a href="isomorphism_theorem" title="wikilink">isomorphism theorems</a>. Note in some cases (e.g. <a href="group_(mathematics)" title="wikilink">groups</a> or <a href="ring_(algebra)" title="wikilink">rings</a>), a single <a href="equivalence_class" title="wikilink">equivalence class</a> <em>K</em> suffices to specify the structure of the quotient, in which case we can write it <em>X</em>/<em>K</em>. (<em>X</em>/<em>K</em> is usually read as "<em>X</em> <a href="Ideal_(ring_theory)" title="wikilink">mod</a> <em>K</em>".) Also in these cases, it is <em>K</em>, rather than ~, that is called the <a href="kernel_(algebra)" title="wikilink">kernel</a> of <em>f</em> (cf. <a href="normal_subgroup" title="wikilink">normal subgroup</a>).</p>
<h2 id="homomorphisms-of-relational-structures">Homomorphisms of relational structures</h2>

<p>In <a href="model_theory" title="wikilink">model theory</a>, the notion of an algebraic structure is generalized to structures involving both operations and relations. Let <em>L</em> be a signature consisting of function and relation symbols, and <em>A</em>, <em>B</em> be two <em>L</em>-structures. Then a <strong>homomorphism</strong> from <em>A</em> to <em>B</em> is a mapping <em>h</em> from the domain of <em>A</em> to the domain of <em>B</em> such that</p>
<ul>
<li><em>h</em>(<em>F</em><sup><em>A</em></sup>(<em>a</em><sub>1</sub>,…,<em>a</em><sub><em>n</em></sub>)) = <em>F</em><sup><em>B</em></sup>(<em>h</em>(<em>a</em><sub>1</sub>),…,<em>h</em>(<em>a</em><sub><em>n</em></sub>)) for each <em>n</em>-ary function symbol <em>F</em> in <em>L</em>,</li>
<li><em>R</em><sup><em>A</em></sup>(<em>a</em><sub>1</sub>,…,<em>a</em><sub><em>n</em></sub>) implies <em>R</em><sup><em>B</em></sup>(<em>h</em>(<em>a</em><sub>1</sub>),…,<em>h</em>(<em>a</em><sub><em>n</em></sub>)) for each <em>n</em>-ary relation symbol <em>R</em> in <em>L</em>.</li>
</ul>

<p>In the special case with just one binary relation, we obtain the notion of a <a href="graph_homomorphism" title="wikilink">graph homomorphism</a>. For a detailed discussion of relational homomorphisms and isomorphisms see.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="homomorphisms-and-e-free-homomorphisms-in-formal-language-theory">Homomorphisms and e-free homomorphisms in formal language theory</h2>

<p>Homomorphisms are also used in the study of <a href="formal_language" title="wikilink">formal languages</a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> (although within this context, often they are briefly referred to as morphisms<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a>). Given alphabets Σ<sub>1</sub> and Σ<sub>2</sub>, a function <mtpl></mtpl> such that  for all <em>u</em> and <em>v</em> in Σ<sub>1</sub><sup>∗</sup> is called a <em>homomorphism</em> (or simply <em>morphism</em>) on Σ<sub>1</sub><sup>∗</sup>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> Let <em>e</em> denote the empty word. If <em>h</em> is a homomorphism on Σ<sub>1</sub><sup>∗</sup> and  for all  in Σ<sub>1</sub><sup>∗</sup>, then <em>h</em> is called an <em>e-free homomorphism</em>.</p>

<p>This type of homomorphism can be thought of as (and is equivalent to) a monoid homomorphism where Σ<sup>∗</sup> the set of all words over a finite alphabet Σ is a monoid (in fact it is the <a href="free_monoid" title="wikilink">free monoid</a> on Σ) with operation concatenation and the empty word as the identity.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="continuous_function" title="wikilink">continuous function</a></li>
<li><a class="uri" href="diffeomorphism" title="wikilink">diffeomorphism</a></li>
<li><a href="homomorphic_encryption" title="wikilink">homomorphic encryption</a></li>
<li><a href="homomorphic_secret_sharing" title="wikilink">homomorphic secret sharing</a> – a simplistic decentralized voting protocol</li>
<li><a class="uri" href="morphism" title="wikilink">morphism</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<references>
</references>

<p>A monograph available free online:</p>
<ul>
<li>Burris, Stanley N., and H.P. Sankappanavar, H. P., 1981. <em><a href="http://www.thoralf.uwaterloo.ca/htdocs/ualg.html">A Course in Universal Algebra.</a></em> Springer-Verlag. ISBN 3-540-90578-2.</li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Morphisms" title="wikilink">Category:Morphisms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">tacitly assuming the <a href="axiom_of_choice" title="wikilink">axiom of choice</a> and a <a href="constructive_mathematics" title="wikilink">nonconstructive setting</a><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"> Here: Sect.VI.3, p.134<a href="#fnref3">↩</a></li>
<li id="fn4">Bourbaki, <em>Algebra</em>, ch. I §2.1, p. 13<a href="#fnref4">↩</a></li>
<li id="fn5">The notion of "object" and "morphism" in category theory generalizes the notion of "algebraic structure" and "homomorphism", respectively.<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8">Section 17.4, in <a href="Gunther_Schmidt" title="wikilink">Gunther Schmidt</a>, 2010. <em>Relational Mathematics</em>. Cambridge University Press, ISBN 978-0-521-76268-7<a href="#fnref8">↩</a></li>
<li id="fn9"><a href="Seymour_Ginsburg" title="wikilink">Seymour Ginsburg</a>, <em>Algebraic and automata theoretic properties of formal languages</em>, North-Holland, 1975, ISBN 0-7204-2506-9.<a href="#fnref9">↩</a></li>
<li id="fn10">T. Harju, J. Karhumӓki, Morphisms in <em>Handbook of Formal Languages</em>, Volume I, edited by G. Rozenberg, A. Salomaa, Springer, 1997, ISBN 3-540-61486-9.<a href="#fnref10">↩</a></li>
<li id="fn11">In homomorphisms on formal languages, the ∗ operation is the <a href="Kleene_star" title="wikilink">Kleene star</a> operation. The ⋅ and ∘ are both <a class="uri" href="concatenation" title="wikilink">concatenation</a>, commonly denoted by juxtaposition.<a href="#fnref11">↩</a></li>
</ol>
</section>
</body>
</html>
