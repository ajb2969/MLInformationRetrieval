<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="128">Incomplete LU factorization</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Incomplete LU factorization</h1>
<hr/>

<p>In <a href="numerical_linear_algebra" title="wikilink">numerical linear algebra</a>, an <strong>incomplete LU factorization</strong> of a <a href="matrix_(mathematics)" title="wikilink">matrix</a> is a <a href="sparse_matrix" title="wikilink">sparse</a> approximation of the <a href="LU_factorization" title="wikilink">LU factorization</a> often used as a <a class="uri" href="preconditioner" title="wikilink">preconditioner</a>.</p>

<p>Consider a sparse linear system 

<math display="inline" id="Incomplete_LU_factorization:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>x</ci>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ax=b
  </annotation>
 </semantics>
</math>

. These are often solved by computing the factorization 

<math display="inline" id="Incomplete_LU_factorization:1">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mi>L</mi>
    <mi>U</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>U</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=LU
  </annotation>
 </semantics>
</math>


, with <em>L</em> unit-lower triangular and <em>U</em> upper triangular. One then solves 

<math display="inline" id="Incomplete_LU_factorization:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>y</ci>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ly=b
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Incomplete_LU_factorization:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>U</mi>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>U</ci>
     <ci>x</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ux=y
  </annotation>
 </semantics>
</math>

, which can be done quickly because the matrices are triangular.</p>

<p>For a typical sparse matrix, the LU factors can be much less sparse than the original matrix. The memory requirements for using a direct solver can then become a bottleneck in solving linear systems. One can combat this problem by using fill-reducing reorderings of the matrix's unknowns, such as the <a href="Cuthill-McKee_algorithm" title="wikilink">Cuthill-McKee ordering</a>.</p>

<p>An incomplete factorization instead seeks triangular matrices <em>L</em>, <em>U</em> such that 

<math display="inline" id="Incomplete_LU_factorization:4">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>â‰ˆ</mo>
   <mrow>
    <mi>L</mi>
    <mi>U</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>U</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\approx LU
  </annotation>
 </semantics>
</math>

 rather than 

<math display="inline" id="Incomplete_LU_factorization:5">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mi>L</mi>
    <mi>U</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>U</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=LU
  </annotation>
 </semantics>
</math>

. Solving for 

<math display="inline" id="Incomplete_LU_factorization:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mi>U</mi>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>U</ci>
     <ci>x</ci>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   LUx=b
  </annotation>
 </semantics>
</math>


 can be done quickly but does not yield the exact solution to 

<math display="inline" id="Incomplete_LU_factorization:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi>x</mi>
   </mrow>
   <mo>=</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>x</ci>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ax=b
  </annotation>
 </semantics>
</math>

. So, we instead use the matrix 

<math display="inline" id="Incomplete_LU_factorization:8">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mrow>
    <mi>L</mi>
    <mi>U</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>U</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=LU
  </annotation>
 </semantics>
</math>

 as a preconditioner in another iterative solution algorithm such as the <a href="conjugate_gradient_method" title="wikilink">conjugate gradient method</a> or <a class="uri" href="GMRES" title="wikilink">GMRES</a>.</p>

<p>The sparsity pattern of <em>L</em> and <em>U</em> is often chosen to be the same as the sparsity pattern of the original matrix <em>A</em>. If the underlying matrix structure can be referenced by pointers instead of copied, the only extra memory required is for the entries of <em>L</em> and <em>U</em>. This preconditioner is called ILU(0).</p>

<p>One can obtain a more accurate preconditioner by allowing some level of extra fill in the factorization. A common choice is to use the sparsity pattern of <em>A<sup>2</sup></em> instead of <em>A</em>; this matrix is appreciably more dense than <em>A</em>, but still sparse over all. This preconditioner is called ILU(1). One can then generalize this procedure; the ILU(k) preconditioner of a matrix <em>A</em> is the incomplete LU factorization with the sparsity pattern of the matrix <em>A<sup>k+1</sup></em>.</p>

<p>More accurate ILU preconditioners require more memory, to such an extent that eventually the running time of the algorithm increases even though the total number of iterations decreases. Consequently, there is a cost/accuracy trade-off that users must evaluate, typically on a case-by-case basis depending on the family of linear systems to be solved.</p>
<h2 id="references">References</h2>
<ul>
<li>

<p>. See Section 10.3 and further.</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cfd-online.com/Wiki/Incomplete_LU_factorization_-_ILU">Incomplete LU Factorization on CFD Wiki</a></li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_linear_algebra" title="wikilink">Category:Numerical linear algebra</a></p>
</body>
</html>
