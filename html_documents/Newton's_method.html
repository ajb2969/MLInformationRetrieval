<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="734">Newton's method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Newton's method</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In <a href="numerical_analysis" title="wikilink">numerical analysis</a>, <strong>Newton's method</strong> (also known as the <strong>Newton–Raphson method</strong>), named after <a href="Isaac_Newton" title="wikilink">Isaac Newton</a> and <a href="Joseph_Raphson" title="wikilink">Joseph Raphson</a>, is a method for finding successively better approximations to the <a href="root_of_a_function" title="wikilink">roots</a> (or zeroes) of a <a href="Real_number" title="wikilink">real</a>-valued <a href="function_(mathematics)" title="wikilink">function</a>.</p>

<p>

<math display="block" id="Newton's_method:0">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0 .</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>x</ci>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
     <cn type="float">0 .</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x:f(x)=0\,.
  </annotation>
 </semantics>
</math>

</p>

<p>The Newton–Raphson method in one variable is implemented as follows:</p>

<p>Given a function <em>ƒ</em> defined over the reals <em>x</em>, and its <a class="uri" href="derivative" title="wikilink">derivative</a> <em>ƒ</em>', we begin with a first guess <em>x</em><sub>0</sub> for a root of the function <em>f</em>. Provided the function satisfies all the assumptions made in the derivation of the formula, a better approximation <em>x</em><sub>1</sub> is</p>

<p>

<math display="block" id="Newton's_method:1">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <mo>-</mo>
     <mpadded width="+1.7pt">
      <mfrac>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mn>0</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <msup>
         <mi>f</mi>
         <mo>′</mo>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mn>0</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
     </mpadded>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}=x_{0}-\frac{f(x_{0})}{f^{\prime}(x_{0})}\,.
  </annotation>
 </semantics>
</math>

</p>

<p>Geometrically, (<em>x</em><sub>1</sub>, 0) is the intersection with the <em>x</em>-axis of the <a class="uri" href="tangent" title="wikilink">tangent</a> to the <a href="graph_of_a_function" title="wikilink">graph</a> of <em>f</em> at (<em>x</em><sub>0</sub>, <em>f</em> (<em>x</em><sub>0</sub>)).</p>

<p>The process is repeated as</p>

<p>

<math display="block" id="Newton's_method:2">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo>-</mo>
    <mpadded width="+1.7pt">
     <mfrac>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <msup>
        <mi>f</mi>
        <mo>′</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n+1}=x_{n}-\frac{f(x_{n})}{f^{\prime}(x_{n})}\,
  </annotation>
 </semantics>
</math>

</p>

<p>until a sufficiently accurate value is reached.</p>

<p>This algorithm is first in the class of <a href="Householder's_method" title="wikilink">Householder's methods</a>, succeeded by <a href="Halley's_method" title="wikilink">Halley's method</a>. The method can also be extended to complex functions and to systems of equations.</p>
<h2 id="description">Description</h2>
<figure><b>(Figure)</b>
<figcaption>alt Illustration of Newton's method|thumb|right|300px|The function <em>ƒ</em> is shown in blue and the tangent line is in red. We see that <em>x</em><sub><em>n</em>+1</sub> is a better approximation than <em>x</em><sub><em>n</em></sub> for the root <em>x</em> of the function <em>f</em>.</figcaption>
</figure>

<p>The idea of the method is as follows: one starts with an initial guess which is reasonably close to the true root, then the function is approximated by its <a href="tangent_line" title="wikilink">tangent line</a> (which can be computed using the tools of <a class="uri" href="calculus" title="wikilink">calculus</a>), and one computes the <em>x</em>-intercept of this tangent line (which is easily done with elementary algebra). This <em>x</em>-intercept will typically be a better approximation to the function's root than the original guess, and the method can be <a href="iterative_method" title="wikilink">iterated</a>.</p>

<p>Suppose <em>ƒ</em> : [<em>a</em>, <em>b</em>] → <strong>R</strong> is a <a href="derivative" title="wikilink">differentiable</a> function defined on the <a href="interval_(mathematics)" title="wikilink">interval</a> [<em>a</em>, <em>b</em>] with values in the <a href="real_number" title="wikilink">real numbers</a> <strong>R</strong>. The formula for converging on the root can be easily derived. Suppose we have some current approximation <em>x</em><sub><em>n</em></sub>. Then we can derive the formula for a better approximation, <em>x</em><sub><em>n</em>+1</sub> by referring to the diagram on the right. The equation of the <a href="tangent_line" title="wikilink">tangent line</a> to the curve <em>y</em> = <em>ƒ</em>(<em>x</em>) at the point <em>x=x</em><sub><em>n</em></sub> is</p>

<p>

<math display="block" id="Newton's_method:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>f</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=f^{\prime}(x_{n})\,(x-x_{n})+f(x_{n}),
  </annotation>
 </semantics>
</math>

</p>

<p>where, <em>ƒ</em>' denotes the <a class="uri" href="derivative" title="wikilink">derivative</a> of the function <em>ƒ</em>.</p>

<p>The <em>x</em>-intercept of this line (the value of <em>x</em> such that <em>y</em>=0) is then used as the next approximation to the root, <em>x</em><sub><em>n</em>+1</sub>. In other words, setting <em>y</em> to zero and <em>x</em> to <em>x</em><sub><em>n</em>+1</sub> gives</p>

<p>

<math display="block" id="Newton's_method:4">
 <semantics>
  <mrow>
   <mrow>
    <mn>0</mn>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>f</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mrow>
          <mi>n</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <cn type="integer">0</cn>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0=f^{\prime}(x_{n})\,(x_{n+1}-x_{n})+f(x_{n}).
  </annotation>
 </semantics>
</math>

</p>

<p>Solving for <em>x</em><sub><em>n</em>+1</sub> gives</p>

<p>

<math display="block" id="Newton's_method:5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <msup>
        <mi>f</mi>
        <mo>′</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n+1}=x_{n}-\frac{f(x_{n})}{f^{\prime}(x_{n})}.\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>We start the process off with some arbitrary initial value <em>x</em><sub>0</sub>. (The closer to the zero, the better. But, in the absence of any intuition about where the zero might lie, a "guess and check" method might narrow the possibilities to a reasonably small interval by appealing to the <a href="intermediate_value_theorem" title="wikilink">intermediate value theorem</a>.) The method will usually converge, provided this initial guess is close enough to the unknown zero, and that <em>ƒ</em>'(<em>x</em><sub>0</sub>) ≠ 0. Furthermore, for a zero of <a href="Multiplicity_(mathematics)" title="wikilink">multiplicity</a> 1, the convergence is at least quadratic (see <a href="rate_of_convergence" title="wikilink">rate of convergence</a>) in a <a href="neighbourhood_(mathematics)" title="wikilink">neighbourhood</a> of the zero, which intuitively means that the number of correct digits roughly at least doubles in every step. More details can be found in the <a href="#Analysis" title="wikilink">analysis section</a> below.</p>

<p>The <a href="Householder's_method" title="wikilink">Householder's methods</a> are similar but have higher order for even faster convergence. However, the extra computations required for each step can slow down the overall performance relative to Newton's method, particularly if <em>f</em> or its derivatives are computationally expensive to evaluate.</p>
<h2 id="history">History</h2>

<p>The name "Newton's method" is derived from <a href="Isaac_Newton" title="wikilink">Isaac Newton</a>'s description of a special case of the method in <em><a href="De_analysi_per_aequationes_numero_terminorum_infinitas" title="wikilink">De analysi per aequationes numero terminorum infinitas</a></em> (written in 1669, published in 1711 by <a href="William_Jones_(mathematician)" title="wikilink">William Jones</a>) and in <em>De metodis fluxionum et serierum infinitarum</em> (written in 1671, translated and published as <em><a href="Method_of_Fluxions" title="wikilink">Method of Fluxions</a></em> in 1736 by <a href="John_Colson" title="wikilink">John Colson</a>). However, his method differs substantially from the modern method given above: Newton applies the method only to polynomials. He does not compute the successive approximations 

<math display="inline" id="Newton's_method:6">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}
  </annotation>
 </semantics>
</math>

, but computes a sequence of polynomials, and only at the end arrives at an approximation for the root <em>x</em>. Finally, Newton views the method as purely algebraic and makes no mention of the connection with calculus. Newton may have derived his method from a similar but less precise method by <a href="Franciscus_Vieta" title="wikilink">Vieta</a>. The essence of Vieta's method can be found in the work of the <a href="Mathematics_in_medieval_Islam" title="wikilink">Persian mathematician</a> <a href="Sharaf_al-Din_al-Tusi" title="wikilink">Sharaf al-Din al-Tusi</a>, while his successor <a href="Jamshīd_al-Kāshī" title="wikilink">Jamshīd al-Kāshī</a> used a form of Newton's method to solve 

<math display="inline" id="Newton's_method:7">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>x</mi>
     <mi>P</mi>
    </msup>
    <mo>-</mo>
    <mi>N</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>P</ci>
     </apply>
     <ci>N</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{P}-N=0
  </annotation>
 </semantics>
</math>

 to find roots of <em>N</em> (Ypma 1995). A special case of Newton's method for calculating square roots was known much earlier and is often called the <a href="Babylonian_method" title="wikilink">Babylonian method</a>.</p>

<p>Newton's method was used by 17th-century Japanese mathematician <a href="Seki_Kōwa" title="wikilink">Seki Kōwa</a> to solve single-variable equations, though the connection with calculus was missing.</p>

<p>Newton's method was first published in 1685 in <em>A Treatise of Algebra both Historical and Practical</em> by <a href="John_Wallis" title="wikilink">John Wallis</a>. In 1690, <a href="Joseph_Raphson" title="wikilink">Joseph Raphson</a> published a simplified description in <em>Analysis aequationum universalis</em>. Raphson again viewed Newton's method purely as an algebraic method and restricted its use to polynomials, but he describes the method in terms of the successive approximations <em>x</em><sub><em>n</em></sub> instead of the more complicated sequence of polynomials used by Newton. Finally, in 1740, <a href="Thomas_Simpson" title="wikilink">Thomas Simpson</a> described Newton's method as an iterative method for solving general nonlinear equations using calculus, essentially giving the description above. In the same publication, Simpson also gives the generalization to systems of two equations and notes that Newton's method can be used for solving optimization problems by setting the gradient to zero.</p>

<p><a href="Arthur_Cayley" title="wikilink">Arthur Cayley</a> in 1879 in <em>The Newton-Fourier imaginary problem</em> was the first to notice the difficulties in generalizing Newton's method to complex roots of polynomials with degree greater than 2 and complex initial values. This opened the way to the study of the theory of iterations of rational functions.</p>
<h2 id="practical-considerations">Practical considerations</h2>

<p>Newton's method is an extremely powerful technique—in general the <a href="rate_of_convergence" title="wikilink">convergence</a> is quadratic: as the method converges on the root, the difference between the root and the approximation is squared (the number of accurate digits roughly doubles) at each step. However, there are some difficulties with the method.</p>
<h3 id="difficulty-in-calculating-derivative-of-a-function">Difficulty in calculating derivative of a function</h3>

<p>Newton's method requires that the derivative be calculated directly. An analytical expression for the derivative may not be easily obtainable and could be expensive to evaluate. In these situations, it may be appropriate to approximate the derivative by using the slope of a line through two nearby points on the function. Using this approximation would result in something like the <a href="secant_method" title="wikilink">secant method</a> whose convergence is slower than that of Newton's method.</p>
<h3 id="failure-of-the-method-to-converge-to-the-root">Failure of the method to converge to the root</h3>

<p>It is important to review the <a href="#Proof_of_quadratic_convergence_for_Newton's_iterative_method" title="wikilink">proof of quadratic convergence</a> of Newton's Method before implementing it. Specifically, one should review the assumptions made in the proof. For <a href="#Failure_analysis" title="wikilink">situations where the method fails to converge</a>, it is because the assumptions made in this proof are not met.</p>
<h4 id="overshoot">Overshoot</h4>

<p>If the first derivative is not well behaved in the neighborhood of a particular root, the method may overshoot, and diverge from that root. An example of a function with one root, for which the derivative is not well behaved in the neighborhood of the root, is</p>

<p>

<math display="block" id="Newton's_method:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>x</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mi>a</mi>
    </msup>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mn>0</mn>
    <mo><</mo>
    <mi>a</mi>
    <mo><</mo>
    <mstyle displaystyle="false">
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
    </mstyle>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <ci>x</ci>
      </apply>
      <ci>a</ci>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <lt></lt>
      <cn type="integer">0</cn>
      <ci>a</ci>
     </apply>
     <apply>
      <lt></lt>
      <share href="#.cmml">
      </share>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=|x|^{a},\quad 0<a<\tfrac{1}{2}
  </annotation>
 </semantics>
</math>

</p>

<p>for which the root will be overshot and the sequence of 

<math display="inline" id="Newton's_method:9">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 will diverge. For 

<math display="inline" id="Newton's_method:10">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=1/2
  </annotation>
 </semantics>
</math>

, the root will still be overshot, but the sequence will oscillate between two values. For 

<math display="inline" id="Newton's_method:11">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi mathvariant="normal">≥</mi>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>normal-≥</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a≥1
  </annotation>
 </semantics>
</math>

</p>

<p>In some cases, Newton's method can be stabilized by using <a href="successive_over-relaxation#Other_applications_of_the_method" title="wikilink">successive over-relaxation</a>, or the speed of convergence can be increased by using the same method.</p>
<h4 id="stationary-point">Stationary point</h4>

<p>If a <a href="stationary_point" title="wikilink">stationary point</a> of the function is encountered, the derivative is zero and the method will terminate due to <a href="division_by_zero" title="wikilink">division by zero</a>.</p>
<h4 id="poor-initial-estimate">Poor initial estimate</h4>

<p>A large error in the initial estimate can contribute to non-convergence of the algorithm.</p>
<h4 id="mitigation-of-non-convergence">Mitigation of non-convergence</h4>

<p>In a robust implementation of Newton's method, it is common to place limits on the number of iterations, bound the solution to an interval known to contain the root, and combine the method with a more robust root finding method.</p>
<h3 id="slow-convergence-for-roots-of-multiplicity-1">Slow convergence for roots of multiplicity &gt; 1</h3>

<p>If the root being sought has <a href="Multiplicity_(mathematics)#Multiplicity_of_a_root_of_a_polynomial" title="wikilink">multiplicity</a> greater than one, the convergence rate is merely linear (errors reduced by a constant factor at each step) unless special steps are taken. When there are two or more roots that are close together then it may take many iterations before the iterates get close enough to one of them for the quadratic convergence to be apparent. However, if the multiplicity 

<math display="block" id="Newton's_method:13">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>-</mo>
     <mrow>
      <mi>m</mi>
      <mfrac>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>n</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <msup>
         <mi>f</mi>
         <mo>′</mo>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>n</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <ci>m</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n+1}=x_{n}-m\frac{f(x_{n})}{f^{\prime}(x_{n})}.\,\!
  </annotation>
 </semantics>
</math>

 of the root is known, one can use the following modified algorithm that preserves the quadratic convergence rate:</p>

<p>

<math display="inline" id="Newton's_method:14">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>This is equivalent to using <a href="successive_over-relaxation#Other_applications_of_the_method" title="wikilink">successive over-relaxation</a>. On the other hand, if the multiplicity 

<math display="inline" id="Newton's_method:15">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 of the root is not known, it is possible to estimate 

<math display="block" id="Newton's_method:16">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mfrac>
       <mrow>
        <msup>
         <mi>f</mi>
         <mi>′′</mi>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>α</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mn>2</mn>
        <msup>
         <mi>f</mi>
         <mo>′</mo>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>α</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi mathvariant="normal">Δ</mi>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>O</mi>
      <mpadded width="+1.7pt">
       <msup>
        <mrow>
         <mo stretchy="false">[</mo>
         <mrow>
          <mi mathvariant="normal">Δ</mi>
          <msub>
           <mi>x</mi>
           <mi>i</mi>
          </msub>
         </mrow>
         <mo stretchy="false">]</mo>
        </mrow>
        <mn>3</mn>
       </msup>
      </mpadded>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>′′</ci>
        </apply>
        <ci>α</ci>
       </apply>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>α</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <ci>normal-Δ</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta x_{i+1}=\frac{f^{\prime\prime}(\alpha)}{2f^{\prime}(\alpha)}(\Delta x_{%
i})^{2}+O[\Delta x_{i}]^{3}\,,
  </annotation>
 </semantics>
</math>

 after carrying out one or two iterations, and then use that value to increase the rate of convergence.</p>
<h2 id="analysis">Analysis</h2>

<p>Suppose that the function <em>ƒ</em> has a zero at α, i.e., <em>ƒ</em>(α) = 0, and <em>ƒ</em> is differentiable in a <a href="topological_neighborhood" title="wikilink">neighborhood</a> of α.</p>

<p>If <em>f</em>  is continuously differentiable and its derivative is nonzero at α, then there exists a <a href="topological_neighborhood" title="wikilink">neighborhood</a> of α such that for all starting values <em>x</em><sub>0</sub> in that neighborhood, the <a class="uri" href="sequence" title="wikilink">sequence</a> {<em>x</em><sub><em>n</em></sub>} will <a href="limit_of_a_sequence" title="wikilink">converge</a> to α.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>If the function is continuously differentiable and its derivative is not 0 at α and it has a <a href="second_derivative" title="wikilink">second derivative</a> at α then the convergence is quadratic or faster. If the second derivative is not 0 at α then the convergence is merely quadratic. If the third derivative exists and is bounded in a neighborhood of α, then:</p>

<p>

<math display="inline" id="Newton's_method:17">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo>≜</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo>-</mo>
     <mpadded width="+1.7pt">
      <mi>α</mi>
     </mpadded>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-≜</ci>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta x_{i}\triangleq x_{i}-\alpha\,.
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Newton's_method:18">
 <semantics>
  <mrow>
   <msup>
    <mi>f</mi>
    <mo>′</mo>
   </msup>
   <mo>≠</mo>
   <mpadded width="-1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <ci>normal-′</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}\neq 0\!
  </annotation>
 </semantics>
</math>


</p>

<p>If the derivative is 0 at α, then the convergence is usually only linear. Specifically, if <em>ƒ</em> is twice continuously differentiable, <em>ƒ</em> '(<em>α</em>) = 0 and <em>ƒ</em> ''(<em>α</em>) ≠ 0, then there exists a neighborhood of α such that for all starting values <em>x</em><sub>0</sub> in that neighborhood, the sequence of iterates converges linearly, with <a href="rate_of_convergence" title="wikilink">rate</a> log<sub>10</sub> 2 (Süli &amp; Mayers, Exercise 1.6). Alternatively if <em>ƒ</em> '(<em>α</em>) = 0 and <em>ƒ</em> '(<em>x</em>) ≠ 0 for <em>x</em> ≠ α, <em>x</em> in a <a href="topological_neighborhood" title="wikilink">neighborhood</a> <em>U</em> of α, α being a zero of <a href="Multiplicity_(mathematics)" title="wikilink">multiplicity</a> <em>r</em>, and if <em>ƒ</em> ∈ <em>C</em><sup><em>r</em></sup>(<em>U</em>) then there exists a neighborhood of α such that for all starting values <em>x</em><sub>0</sub> in that neighborhood, the sequence of iterates converges linearly.</p>

<p>However, even linear convergence is not guaranteed in pathological situations.</p>

<p>In practice these results are local, and the neighborhood of convergence is not known in advance. But there are also some results on global convergence: for instance, given a right neighborhood <em>U<sub>+</sub></em> of α, if <em>f</em> is twice differentiable in <em>U<sub>+</sub></em> and if 

<math display="inline" id="Newton's_method:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mo>⋅</mo>
    <msup>
     <mi>f</mi>
     <mi>′′</mi>
    </msup>
   </mrow>
   <mo>></mo>
   <mpadded width="-1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <ci>normal-⋅</ci>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>′′</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\cdot f^{\prime\prime}>0\!
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Newton's_method:20">
 <semantics>
  <mpadded width="+1.7pt">
   <mrow>
    <mi>α</mi>
    <mo>.</mo>
   </mrow>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\,.
  </annotation>
 </semantics>
</math>

 in <em>U<sub>+</sub></em>, then, for each <em>x</em><sub>0</sub> in <em>U</em><sub>+</sub> the sequence <em>x<sub>k</sub></em> is monotonically decreasing to α.</p>
<h3 id="proof-of-quadratic-convergence-for-newtons-iterative-method">Proof of quadratic convergence for Newton's iterative method</h3>

<p>According to <a href="Taylor's_theorem" title="wikilink">Taylor's theorem</a>, any function <em>f</em>(<em>x</em>) which has a continuous second derivative can be represented by an expansion about a point that is close to a root of f(x). Suppose this root is 

<math display="block" id="Newton's_method:21">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>R</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mn>2</mn>
       <mo lspace="0pt" rspace="3.5pt">!</mo>
      </mrow>
     </mfrac>
     <msup>
      <mi>f</mi>
      <mi>′′</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>ξ</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mpadded width="+1.7pt">
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>α</mi>
         <mo>-</mo>
         <msub>
          <mi>x</mi>
          <mi>n</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mpadded>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <factorial></factorial>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>′′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ξ</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <ci>α</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{1}=\frac{1}{2!}f^{\prime\prime}(\xi_{n})(\alpha-x_{n})^{2}\,,
  </annotation>
 </semantics>
</math>

 Then the expansion of f(α) about <em>x</em><sub><em>n</em></sub> is: <mtpl></mtpl></p>

<p>where the <a href="Lagrange_remainder" title="wikilink">Lagrange form of the Taylor series expansion remainder</a> is</p>

<p>

<math display="inline" id="Newton's_method:22">
 <semantics>
  <mpadded width="+1.7pt">
   <mrow>
    <mi>α</mi>
    <mo>.</mo>
   </mrow>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\,.
  </annotation>
 </semantics>
</math>

</p>

<p>where ξ<sub><em>n</em></sub> is in between <em>x</em><sub><em>n</em></sub> and 

<math display="inline" id="Newton's_method:23">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>α</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\,
  </annotation>
 </semantics>
</math>


</p>

<p>Since 

<math display="inline" id="Newton's_method:24">
 <semantics>
  <mrow>
   <msup>
    <mi>f</mi>
    <mo>′</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(x_{n})\,
  </annotation>
 </semantics>
</math>

 is the root, () becomes: </p>

<p>Dividing equation () by 

<math display="block" id="Newton's_method:25">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <munder accentunder="true">
      <mrow>
       <mi>α</mi>
       <mo movablelimits="false">-</mo>
       <msub>
        <mi>x</mi>
        <mrow>
         <mi>n</mi>
         <mo movablelimits="false">+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mrow>
      <mo movablelimits="false">⏟</mo>
     </munder>
     <msub>
      <mi>ϵ</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </munder>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mo>-</mo>
       <mrow>
        <msup>
         <mi>f</mi>
         <mi>′′</mi>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>ξ</mi>
          <mi>n</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mrow>
       <mn>2</mn>
       <msup>
        <mi>f</mi>
        <mo>′</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
     <mpadded width="+1.7pt">
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <munder>
         <munder accentunder="true">
          <mrow>
           <mi>α</mi>
           <mo movablelimits="false">-</mo>
           <msub>
            <mi>x</mi>
            <mi>n</mi>
           </msub>
          </mrow>
          <mo movablelimits="false">⏟</mo>
         </munder>
         <msub>
          <mi>ϵ</mi>
          <mi>n</mi>
         </msub>
        </munder>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mpadded>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-⏟</ci>
      <apply>
       <minus></minus>
       <ci>α</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϵ</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>′′</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ξ</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-⏟</ci>
        <apply>
         <minus></minus>
         <ci>α</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ϵ</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \underbrace{\alpha-x_{n+1}}_{\epsilon_{n+1}}=\frac{-f^{\prime\prime}(\xi_{n})}%
{2f^{\prime}(x_{n})}(\underbrace{\alpha-x_{n}}_{\epsilon_{n}})^{2}\,.
  </annotation>
 </semantics>
</math>

 and rearranging gives </p>

<p>Remembering that <em>x</em><sub><em>n</em>+1</sub> is defined by </p>

<p>one finds that</p>

<p>

<math display="inline" id="Newton's_method:26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msup>
       <mi>f</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>≠</mo>
     <mn>0</mn>
    </mrow>
    <mo>;</mo>
    <mrow>
     <mrow>
      <mo>∀</mo>
      <mi>x</mi>
     </mrow>
     <mo>∈</mo>
     <mrow>
      <mi>I</mi>
      <mtext>, where</mtext>
      <mi>I</mi>
      <mtext>is the interval</mtext>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>α</mi>
        <mo>-</mo>
        <mi>r</mi>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>α</mi>
        <mo>+</mo>
        <mi>r</mi>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
      <mtext>for some</mtext>
      <mi>r</mi>
     </mrow>
     <mo>≥</mo>
     <mrow>
      <mo>|</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>α</mi>
        <mo>-</mo>
        <msub>
         <mi>x</mi>
         <mn>0</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>|</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>;</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <neq></neq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <and></and>
     <apply>
      <in></in>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>I</ci>
       <mtext>, where</mtext>
       <ci>I</ci>
       <mtext>is the interval</mtext>
       <interval closure="closed">
        <apply>
         <minus></minus>
         <ci>α</ci>
         <ci>r</ci>
        </apply>
        <apply>
         <plus></plus>
         <ci>α</ci>
         <ci>r</ci>
        </apply>
       </interval>
       <mtext>for some</mtext>
       <ci>r</ci>
      </apply>
     </apply>
     <apply>
      <geq></geq>
      <share href="#.cmml">
      </share>
      <apply>
       <abs></abs>
       <apply>
        <minus></minus>
        <ci>α</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(x)\neq 0;\forall x\in I\text{, where }I\text{ is the interval }[%
\alpha-r,\alpha+r]\text{ for some }r\geq\left|(\alpha-x_{0})\right|;\,
  </annotation>
 </semantics>
</math>

</p>

<p>That is, </p>

<p>Taking absolute value of both sides gives \right| = \frac {\left| f^{\prime\prime} (\xi_n) \right| }{2 \left| f^\prime(x_n) \right|} \, {\epsilon_n}^2 \,  |<mtpl><eqref>6<eqref></eqref></eqref></mtpl>}}</p>

<p>Equation () shows that the <a href="rate_of_convergence" title="wikilink">rate of convergence</a> is quadratic if the following conditions are satisfied:</p>
<ol>
<li>

<math display="inline" id="Newton's_method:27">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msup>
       <mi>f</mi>
       <mi>′′</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mtext>is finite</mtext>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>∀</mo>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mi>I</mi>
   </mrow>
   <mo>;</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>′′</ci>
      </apply>
      <ci>x</ci>
      <mtext>is finite</mtext>
     </apply>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>x</ci>
     </apply>
    </list>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime\prime}(x)\text{ is finite },\forall x\in I;\,
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Newton's_method:28">
 <semantics>
  <mpadded width="+1.7pt">
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}\,
  </annotation>
 </semantics>
</math>


</li>
<li>

<math display="inline" id="Newton's_method:29">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>α</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\,
  </annotation>
 </semantics>
</math>

 <em>sufficiently</em> close to the root 

<math display="block" id="Newton's_method:30">
 <semantics>
  <mrow>
   <mrow>
    <mo>|</mo>
    <msub>
     <mi>ϵ</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>M</mi>
    <mpadded width="+1.7pt">
     <mmultiscripts>
      <mi>ϵ</mi>
      <mi>n</mi>
      <none></none>
      <none></none>
      <mn>2</mn>
     </mmultiscripts>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϵ</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>M</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϵ</ci>
       <ci>n</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left|{\epsilon_{n+1}}\right|\leq M{{\epsilon}_{n}}^{2}\,
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>The term <em>sufficiently</em> close in this context means the following:</p>

<p>(a) Taylor approximation is accurate enough such that we can ignore higher order terms,</p>

<p>(b) 

<math display="inline" id="Newton's_method:31">
 <semantics>
  <mpadded width="+1.7pt">
   <mmultiscripts>
    <mi>ϵ</mi>
    <mi>n</mi>
    <none></none>
    <none></none>
    <mn>2</mn>
   </mmultiscripts>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϵ</ci>
     <ci>n</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\epsilon_{n}}^{2}\,
  </annotation>
 </semantics>
</math>

</p>

<p>Finally, () can be expressed in the following way:</p>

<p>

<math display="inline" id="Newton's_method:32">
 <semantics>
  <mpadded width="+1.7pt">
   <mi>I</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I\,
  </annotation>
 </semantics>
</math>

 where M is the <a href="w:supremum" title="wikilink">supremum</a> of the variable coefficient of 

<math display="block" id="Newton's_method:33">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo movablelimits="false">sup</mo>
      <mrow>
       <mi>x</mi>
       <mo>∈</mo>
       <mi>I</mi>
      </mrow>
     </munder>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
      <mrow>
       <mo>|</mo>
       <mfrac>
        <mrow>
         <msup>
          <mi>f</mi>
          <mi>′′</mi>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mrow>
         <msup>
          <mi>f</mi>
          <mo>′</mo>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mfrac>
       <mo>|</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">supremum</csymbol>
      <apply>
       <in></in>
       <ci>x</ci>
       <ci>I</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>f</ci>
          <ci>′′</ci>
         </apply>
         <ci>x</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>f</ci>
          <ci>normal-′</ci>
         </apply>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=\sup_{x\in I}\frac{1}{2}\left|{\frac{f^{\prime\prime}(x)}{f^{\prime}(x)}}%
\right|.\,
  </annotation>
 </semantics>
</math>

 on the interval 

<math display="inline" id="Newton's_method:34">
 <semantics>
  <mpadded width="+1.7pt">
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}\,
  </annotation>
 </semantics>
</math>

 defined in the condition 1, that is:</p>

<p>

<math display="inline" id="Newton's_method:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mrow>
     <mo>|</mo>
     <msub>
      <mi>ϵ</mi>
      <mn>0</mn>
     </msub>
     <mo>|</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mpadded width="+1.7pt">
    <mn>1.</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>M</ci>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ϵ</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <cn type="float">1.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\left|\epsilon_{0}\right|<1.\,
  </annotation>
 </semantics>
</math>

</p>

<p>The initial point 

<math display="inline" id="Newton's_method:36">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>x</mi>
      <mn>3</mn>
     </msup>
     <mo>-</mo>
     <mrow>
      <mn>2</mn>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mn>11</mn>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>12</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">11</cn>
       <ci>x</ci>
      </apply>
     </apply>
     <cn type="integer">12</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=x^{3}-2x^{2}-11x+12
  </annotation>
 </semantics>
</math>

 has to be chosen such that conditions 1 through 3 are satisfied, where the third condition requires that 

<math display="inline" id="Newton's_method:37">
 <semantics>
  <mi mathvariant="normal">∞</mi>
  <annotation-xml encoding="MathML-Content">
   <infinity></infinity>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \infty
  </annotation>
 </semantics>
</math>

</p>
<h3 id="basins-of-attraction">Basins of attraction</h3>

<p>The <a href="basin_of_attraction" title="wikilink">basins of attraction</a>—the regions of the real number line such that within each region iteration from any point leads to one particular root—can be infinite in number and arbitrarily small. For example,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> for the function 

<math display="inline" id="Newton's_method:38">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\infty
  </annotation>
 </semantics>
</math>


, the following initial conditions are in successive basins of attraction:</p>
<dl>
<dd>2.35287527 converges to 4;
</dd>
<dd>2.35284172 converges to −3;
</dd>
<dd>2.35283735 converges to 4;
</dd>
<dd>2.352836327 converges to −3;
</dd>
<dd>2.352836323 converges to 1.
</dd>
</dl>
<h2 id="failure-analysis">Failure analysis</h2>

<p>Newton's method is only guaranteed to converge if certain conditions are satisfied. If the assumptions made in the proof of quadratic convergence are met, the method will converge. For the following subsections, failure of the method to converge indicates that the assumptions made in the proof were not met.</p>
<h3 id="bad-starting-points">Bad starting points</h3>

<p>In some cases the conditions on the function that are necessary for convergence are satisfied, but the point chosen as the initial point is not in the interval where the method converges. This can happen, for example, if the function whose root is sought approaches zero asymptotically as <em>x</em> goes to 

<math display="block" id="Newton's_method:39">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=1-x^{2}.\!
  </annotation>
 </semantics>
</math>

 or 

<math display="block" id="Newton's_method:40">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mn>0</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <msup>
        <mi>f</mi>
        <mo>′</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mn>0</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>0</mn>
     <mo>-</mo>
     <mfrac>
      <mn>1</mn>
      <mn>0</mn>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <cn type="integer">0</cn>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}=x_{0}-\frac{f(x_{0})}{f^{\prime}(x_{0})}=0-\frac{1}{0}.
  </annotation>
 </semantics>
</math>

. In such cases a different method, such as <a href="Bisection_method" title="wikilink">bisection</a>, should be used to obtain a better estimate for the zero to use as an initial point.</p>
<h4 id="iteration-point-is-stationary">Iteration point is stationary</h4>

<p>Consider the function:</p>

<p>

<math display="block" id="Newton's_method:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>x</mi>
      <mn>3</mn>
     </msup>
     <mo>-</mo>
     <mrow>
      <mn>2</mn>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mpadded width="-1.7pt">
     <mn>2</mn>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>x</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=x^{3}-2x+2\!
  </annotation>
 </semantics>
</math>

</p>

<p>It has a maximum at <em>x</em> = 0 and solutions of <em>f</em>(<em>x</em>) = 0 at <em>x</em> = ±1. If we start iterating from the <a href="stationary_point" title="wikilink">stationary point</a> <em>x</em><sub>0</sub> = 0 (where the derivative is zero), <em>x</em><sub>1</sub> will be undefined, since the tangent at (0,1) is parallel to the <em>x</em>-axis:</p>

<p>

<math display="block" id="Newton's_method:42">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mroot>
     <mi>x</mi>
     <mn>3</mn>
    </mroot>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <root></root>
     <degree>
      <cn type="integer">3</cn>
     </degree>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=\sqrt[3]{x}.
  </annotation>
 </semantics>
</math>

</p>

<p>The same issue occurs if, instead of the starting point, any iteration point is stationary. Even if the derivative is small but not zero, the next iteration will be a far worse approximation.</p>
<h4 id="starting-point-enters-a-cycle">Starting point enters a cycle</h4>

<p> For some functions, some starting points may enter an infinite cycle, preventing convergence. Let</p>

<p>

<math display="block" id="Newton's_method:43">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <msup>
        <mi>f</mi>
        <mo>′</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>-</mo>
     <mfrac>
      <mmultiscripts>
       <mi>x</mi>
       <mi>n</mi>
       <none></none>
       <none></none>
       <mfrac>
        <mn>1</mn>
        <mn>3</mn>
       </mfrac>
      </mmultiscripts>
      <mrow>
       <mpadded width="+1.7pt">
        <mfrac>
         <mn>1</mn>
         <mn>3</mn>
        </mfrac>
       </mpadded>
       <mmultiscripts>
        <mi>x</mi>
        <mi>n</mi>
        <none></none>
        <none></none>
        <mrow>
         <mfrac>
          <mn>1</mn>
          <mn>3</mn>
         </mfrac>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </mmultiscripts>
      </mrow>
     </mfrac>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>-</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mn>3</mn>
      </mpadded>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mn>2</mn>
      </mpadded>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">3</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">3</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>n</ci>
         </apply>
         <apply>
          <minus></minus>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <cn type="integer">3</cn>
          </apply>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n+1}=x_{n}-\frac{f(x_{n})}{f^{\prime}(x_{n})}=x_{n}-\frac{{x_{n}}^{\frac{1}%
{3}}}{\frac{1}{3}\,{x_{n}}^{\frac{1}{3}-1}}=x_{n}-3\,x_{n}=-2\,x_{n}.
  </annotation>
 </semantics>
</math>

</p>

<p>and take 0 as the starting point. The first iteration produces 1 and the second iteration returns to 0 so the sequence will alternate between the two without converging to a root. In fact, this 2-cycle is stable: there are neighborhoods around 0 and around 1 from which all points iterate asymptotically to the 2-cycle (and hence not to the root of the function). In general, the behavior of the sequence can be very complex (see <a href="Newton_fractal" title="wikilink">Newton fractal</a>).</p>
<h3 id="derivative-issues">Derivative issues</h3>

<p>If the function is not continuously differentiable in a neighborhood of the root then it is possible that Newton's method will always diverge and fail, unless the solution is guessed on the first try.</p>
<h4 id="derivative-does-not-exist-at-root">Derivative does not exist at root</h4>

<p>A simple example of a function where Newton's method diverges is the cube root, which is continuous and infinitely differentiable, except for <em>x</em> = 0, where its derivative is undefined (this, however, does not affect the algorithm, since it will never require the derivative if the solution is already found):</p>

<p>

<math display="inline" id="Newton's_method:44">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>x</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mi>α</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <ci>x</ci>
     </apply>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=|x|^{\alpha}
  </annotation>
 </semantics>
</math>

</p>

<p>For any iteration point <em>x<sub>n</sub></em>, the next iteration point will be:</p>

<p>

<math display="inline" id="Newton's_method:45">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo><</mo>
   <mi>α</mi>
   <mo><</mo>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <cn type="integer">0</cn>
     <ci>α</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0<\alpha<\tfrac{1}{2}
  </annotation>
 </semantics>
</math>

</p>

<p>The algorithm overshoots the solution and lands on the other side of the <em>y</em>-axis, farther away than it initially was; applying Newton's method actually doubles the distances from the solution at each iteration.</p>

<p>In fact, the iterations diverge to infinity for every 

<math display="inline" id="Newton's_method:46">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>α</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha=\tfrac{1}{2}
  </annotation>
 </semantics>
</math>

, where 

<math display="block" id="Newton's_method:47">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mn>0</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mi>x</mi>
         </mrow>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>x</mi>
        <mo>+</mo>
        <mrow>
         <msup>
          <mi>x</mi>
          <mn>2</mn>
         </msup>
         <mrow>
          <mi>sin</mi>
          <mrow>
           <mo>(</mo>
           <mstyle displaystyle="false">
            <mfrac>
             <mn>2</mn>
             <mi>x</mi>
            </mfrac>
           </mstyle>
           <mo>)</mo>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>x</mi>
        </mrow>
        <mo>≠</mo>
        <mn>0.</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <cn type="integer">0</cn>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>x</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <plus></plus>
      <ci>x</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <sin></sin>
        <apply>
         <divide></divide>
         <cn type="integer">2</cn>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <neq></neq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>x</ci>
      </apply>
      <cn type="float">0.</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=\begin{cases}0&\text{if }x=0,\\
x+x^{2}\sin\left(\frac{2}{x}\right)&\text{if }x\neq 0.\end{cases}
  </annotation>
 </semantics>
</math>

. In the limiting case of 

<math display="block" id="Newton's_method:48">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mi>x</mi>
         </mrow>
         <mo>=</mo>
         <mn>0</mn>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mn>1</mn>
         <mo>+</mo>
         <mrow>
          <mpadded width="+1.7pt">
           <mn>2</mn>
          </mpadded>
          <mpadded width="+1.7pt">
           <mi>x</mi>
          </mpadded>
          <mrow>
           <mi>sin</mi>
           <mrow>
            <mo>(</mo>
            <mstyle displaystyle="false">
             <mfrac>
              <mn>2</mn>
              <mi>x</mi>
             </mfrac>
            </mstyle>
            <mo>)</mo>
           </mrow>
          </mrow>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mpadded width="+1.7pt">
          <mn>2</mn>
         </mpadded>
         <mrow>
          <mi>cos</mi>
          <mrow>
           <mo>(</mo>
           <mstyle displaystyle="false">
            <mfrac>
             <mn>2</mn>
             <mi>x</mi>
            </mfrac>
           </mstyle>
           <mo>)</mo>
          </mrow>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>x</mi>
        </mrow>
        <mo>≠</mo>
        <mn>0.</mn>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>x</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>x</ci>
        <apply>
         <sin></sin>
         <apply>
          <divide></divide>
          <cn type="integer">2</cn>
          <ci>x</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <cos></cos>
        <apply>
         <divide></divide>
         <cn type="integer">2</cn>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <neq></neq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>x</ci>
      </apply>
      <cn type="float">0.</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(x)=\begin{cases}1&\text{if }x=0,\\
1+2\,x\,\sin\left(\frac{2}{x}\right)-2\,\cos\left(\frac{2}{x}\right)&\text{if %
}x\neq 0.\end{cases}
  </annotation>
 </semantics>
</math>

 (square root), the iterations will alternate indefinitely between points <em>x</em><sub>0</sub> and −<em>x</em><sub>0</sub>, so they do not converge in this case either.</p>
<h4 id="discontinuous-derivative">Discontinuous derivative</h4>

<p>If the derivative is not continuous at the root, then convergence may fail to occur in any neighborhood of the root. Consider the function</p>

<p>

<math display="block" id="Newton's_method:49">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="-1.7pt">
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=x^{2}\!
  </annotation>
 </semantics>
</math>

</p>

<p>Its derivative is:</p>

<p>

<math display="inline" id="Newton's_method:50">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mpadded width="-1.7pt">
     <mi>x</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(x)=2x\!
  </annotation>
 </semantics>
</math>

</p>

<p>Within any neighborhood of the root, this derivative keeps changing sign as <em>x</em> approaches 0 from the right (or from the left) while <em>f</em>(<em>x</em>) ≥ <em>x</em> − <em>x</em><sup>2</sup> &gt; 0 for 0 '(<em>x</em>) is unbounded near the root, and Newton's method will diverge almost everywhere in any neighborhood of it, even though:</p>
<ul>
<li>the function is differentiable (and thus continuous) everywhere;</li>
<li>the derivative at the root is nonzero;</li>
<li><em>f</em> is infinitely differentiable except at the root; and</li>
<li>the derivative is bounded in a neighborhood of the root (unlike <em>f</em>(<em>x</em>)/<em>f</em>'(<em>x</em>)).</li>
</ul>
<h3 id="non-quadratic-convergence">Non-quadratic convergence</h3>

<p>In some cases the iterates converge but do not converge as quickly as promised. In these cases simpler methods converge just as quickly as Newton's method.</p>
<h4 id="zero-derivative">Zero derivative</h4>

<p>If the first derivative is zero at the root, then convergence will not be quadratic. Indeed, let</p>

<p>

<math display="inline" id="Newton's_method:51">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>-</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>/</mo>
      <msup>
       <mi>f</mi>
       <mo>′</mo>
      </msup>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mo>/</mo>
    <mpadded width="-1.7pt">
     <mn>2</mn>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <ci>x</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x-f(x)/f^{\prime}(x)=x/2\!
  </annotation>
 </semantics>
</math>

</p>

<p>then 

<math display="block" id="Newton's_method:52">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>x</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <mn>1000</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mpadded width="-1.7pt">
     <mn>1.</mn>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <cn type="integer">1000</cn>
      </apply>
     </apply>
     <cn type="float">1.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=x^{2}(x-1000)+1.\!
  </annotation>
 </semantics>
</math>

 and consequently 

<math display="block" id="Newton's_method:53">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>x</mi>
     <mo>+</mo>
     <msup>
      <mi>x</mi>
      <mfrac>
       <mn>4</mn>
       <mn>3</mn>
      </mfrac>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <apply>
       <divide></divide>
       <cn type="integer">4</cn>
       <cn type="integer">3</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=x+x^{\frac{4}{3}}.\!
  </annotation>
 </semantics>
</math>

. So convergence is not quadratic, even though the function is infinitely differentiable everywhere.</p>

<p>Similar problems occur even when the root is only "nearly" double. For example, let</p>

<p>

<math display="block" id="Newton's_method:54">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>f</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <mfrac>
       <mn>4</mn>
       <mn>3</mn>
      </mfrac>
      <msup>
       <mi>x</mi>
       <mfrac>
        <mn>1</mn>
        <mn>3</mn>
       </mfrac>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">4</cn>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(x)=1+\frac{4}{3}x^{\frac{1}{3}}.\!
  </annotation>
 </semantics>
</math>

</p>

<p>Then the first few iterates starting at <em>x</em><sub>0</sub> = 1 are 1, 0.500250376, 0.251062828, 0.127507934, 0.067671976, 0.041224176, 0.032741218, 0.031642362; it takes six iterations to reach a point where the convergence appears to be quadratic.</p>
<h4 id="no-second-derivative">No second derivative</h4>

<p>If there is no second derivative at the root, then convergence may fail to be quadratic. Indeed, let</p>

<p>

<math display="block" id="Newton's_method:55">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mi>′′</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>4</mn>
     <mn>9</mn>
    </mfrac>
    <mpadded width="-1.7pt">
     <msup>
      <mi>x</mi>
      <mrow>
       <mo>-</mo>
       <mfrac>
        <mn>2</mn>
        <mn>3</mn>
       </mfrac>
      </mrow>
     </msup>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>′′</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">4</cn>
      <cn type="integer">9</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <cn type="integer">2</cn>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime\prime}(x)=\frac{4}{9}x^{-\frac{2}{3}}\!
  </annotation>
 </semantics>
</math>

 Then</p>

<p>

<math display="inline" id="Newton's_method:56">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mpadded width="-1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=0\!
  </annotation>
 </semantics>
</math>

 And</p>

<p>

<math display="inline" id="Newton's_method:57">
 <semantics>
  <mpadded width="-1.7pt">
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}\!
  </annotation>
 </semantics>
</math>

 except when 

<math display="block" id="Newton's_method:58">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <msup>
       <mi>f</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mpadded width="-1.7pt">
    <mfrac>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mn>3</mn>
      </mfrac>
      <mmultiscripts>
       <mi>x</mi>
       <mi>n</mi>
       <none></none>
       <none></none>
       <mfrac>
        <mn>4</mn>
        <mn>3</mn>
       </mfrac>
      </mmultiscripts>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mrow>
        <mfrac>
         <mn>4</mn>
         <mn>3</mn>
        </mfrac>
        <mmultiscripts>
         <mi>x</mi>
         <mi>n</mi>
         <none></none>
         <none></none>
         <mfrac>
          <mn>1</mn>
          <mn>3</mn>
         </mfrac>
        </mmultiscripts>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mfrac>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">3</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <divide></divide>
         <cn type="integer">4</cn>
         <cn type="integer">3</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">4</cn>
         <cn type="integer">3</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>n</ci>
         </apply>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <cn type="integer">3</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n+1}=x_{n}-\frac{f(x_{n})}{f^{\prime}(x_{n})}=\frac{\frac{1}{3}{x_{n}}^{%
\frac{4}{3}}}{(1+\frac{4}{3}{x_{n}}^{\frac{1}{3}})}\!
  </annotation>
 </semantics>
</math>

 where it is undefined. Given 

<math display="inline" id="Newton's_method:59">
 <semantics>
  <mpadded width="-1.7pt">
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}\!
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="inline" id="Newton's_method:60">
 <semantics>
  <mpadded width="-1.7pt">
   <mi>f</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\!
  </annotation>
 </semantics>
</math>

</p>

<p>which has approximately 4/3 times as many bits of precision as 

<math display="inline" id="Newton's_method:61">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>2</mn>
   </msup>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}+1
  </annotation>
 </semantics>
</math>

 has. This is less than the 2 times as many which would be required for quadratic convergence. So the convergence of Newton's method (in this case) is not quadratic, even though: the function is continuously differentiable everywhere; the derivative is not zero at the root; and 

<math display="block" id="Newton's_method:62">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>J</mi>
     <mi>F</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>J</ci>
      <ci>F</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>F</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J_{F}(x_{n})(x_{n+1}-x_{n})=-F(x_{n})\,\!
  </annotation>
 </semantics>
</math>

 is infinitely differentiable except at the desired root.</p>
<h2 id="generalizations">Generalizations</h2>
<h3 id="complex-functions">Complex functions</h3>

<p><a href="image:newtroot_1_0_0_0_0_m1.png" title="wikilink">thumb|Basins of attraction for x<sup>5</sup> - 1 = 0; darker means more iterations to converge.</a>  When dealing with <a href="complex_analysis" title="wikilink">complex functions</a>, Newton's method can be directly applied to find their zeroes. Each zero has a <a href="basin_of_attraction" title="wikilink">basin of attraction</a> in the complex plane, the set of all starting values that cause the method to converge to that particular zero. These sets can be mapped as in the image shown. For many complex functions, the boundaries of the basins of attraction are <a href="fractal" title="wikilink">fractals</a>.</p>

<p>In some cases there are regions in the complex plane which are not in any of these basins of attraction, meaning the iterates do not converge. For example,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> if one uses a real initial condition to seek a root of 

<math display="block" id="Newton's_method:63">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>X</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>X</mi>
      <mi>n</mi>
     </msub>
     <mo>-</mo>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <msup>
          <mi>F</mi>
          <mo>′</mo>
         </msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>X</mi>
           <mi>n</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mi>F</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>X</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>F</ci>
          <ci>normal-′</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>X</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>F</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{n+1}=X_{n}-[F^{\prime}(X_{n})]^{-1}F(X_{n}),\,
  </annotation>
 </semantics>
</math>

, all subsequent iterates will be real numbers and so the iterations cannot converge to either root, since both roots are non-real. In this case <a href="almost_all" title="wikilink">almost all</a> real initial conditions lead to <a href="chaos_theory" title="wikilink">chaotic behavior</a>, while some initial conditions iterate either to infinity or to repeating cycles of any finite length.</p>

<p>Curt McMullen has shown that for any possible purely iterative algorithm similar to Newton's Method, the algorithm will diverge on some open regions of the complex plane when applied to some polynomial of degree d ≥ 4. However, McMullen gave a generally convergent algorithm for polynomials of degree d = 3.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h3 id="nonlinear-systems-of-equations">Nonlinear systems of equations</h3>
<h4 id="k-variables-k-functions">k variables, k functions</h4>

<p>One may also use Newton's method to solve systems of <em>k</em> (non-linear) equations, which amounts to finding the zeroes of continuously differentiable functions <em>F</em> : <strong>R</strong><sup><em>k</em></sup> <code>→</code> <strong>R</strong><sup><em>k</em></sup>. In the formulation given above, one then has to left multiply with the inverse of the <em>k</em>-by-<em>k</em> <a href="Jacobian_matrix" title="wikilink">Jacobian matrix</a> <em>J</em><sub><em>F</em></sub>(<em>x</em><sub><em>n</em></sub>) instead of dividing by <em>f</em> '(<em>x</em><sub><em>n</em></sub>).</p>

<p>Rather than actually computing the inverse of this matrix, one can save time by solving the <a href="system_of_linear_equations" title="wikilink">system of linear equations</a></p>

<p>

<math display="inline" id="Newton's_method:64">
 <semantics>
  <mrow>
   <msup>
    <mi>F</mi>
    <mo>′</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>F</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F^{\prime}(X_{n})
  </annotation>
 </semantics>
</math>

</p>

<p>for the unknown <em>x</em><sub><em>n</em>+1</sub> − <em>x</em><sub><em>n</em></sub>.</p>
<h4 id="k-variables-m-equations-with-m-k">k variables, m equations, with m &gt; k</h4>

<p>The k-dimensional Newton's method can be used to solve systems of <em>&gt;k</em> (non-linear) equations as well if the algorithm uses the <a href="generalized_inverse" title="wikilink">generalized inverse</a> of the non-square <a href="Jacobian_matrix_and_determinant" title="wikilink">Jacobian</a> matrix J<sup>+</sup> = ((J<sup>T</sup>J)<sup>−1</sup>)J<sup>T</sup> instead of the inverse of J. If the nonlinear system has no solution, the method attempts to find a solution in the <a href="non-linear_least_squares" title="wikilink">non-linear least squares</a> sense. See <a href="Gauss–Newton_algorithm" title="wikilink">Gauss–Newton algorithm</a> for more information.</p>
<h3 id="nonlinear-equations-in-a-banach-space">Nonlinear equations in a Banach space</h3>

<p>Another generalization is Newton's method to find a root of a <a href="Functional_(mathematics)" title="wikilink">functional</a> <em>F</em> defined in a <a href="Banach_space" title="wikilink">Banach space</a>. In this case the formulation is</p>

<p>

<math display="inline" id="Newton's_method:65">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{n}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Newton's_method:66">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{n}
  </annotation>
 </semantics>
</math>

 is the <a href="Fréchet_derivative" title="wikilink">Fréchet derivative</a> computed at 

<math display="inline" id="Newton's_method:67">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

. One needs the Fréchet derivative to be boundedly invertible at each 

<math display="inline" id="Newton's_method:68">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <ci>a</ci>
    <ci>b</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [a,b]
  </annotation>
 </semantics>
</math>

 in order for the method to be applicable. A condition for existence of and convergence to a root is given by the <a href="Kantorovich_theorem" title="wikilink">Newton–Kantorovich theorem</a>.</p>
<h3 id="nonlinear-equations-over-p-adic-numbers">Nonlinear equations over <em>p</em>-adic numbers</h3>

<p>In <em>p</em>-adic analysis, the standard method to show a polynomial equation in one variable has a <em>p</em>-adic root is <a href="Hensel's_lemma" title="wikilink">Hensel's lemma</a>, which uses the recursion from Newton's method on the <em>p</em>-adic numbers. Because of the more stable behavior of addition and multiplication in the <em>p</em>-adic numbers compared to the real numbers (specifically, the unit ball in the <em>p</em>-adics is a ring), convergence in Hensel's lemma can be guaranteed under much simpler hypotheses than in the classical Newton's method on the real line.</p>
<h3 id="newton-fourier-method">Newton-Fourier method</h3>

<p>The Newton-Fourier method is <a href="Joseph_Fourier" title="wikilink">Joseph Fourier</a>'s extension of Newton's method to provide bounds on the absolute error of the root approximation, while still providing quadratic convergence.</p>

<p>Assume that 

<math display="inline" id="Newton's_method:69">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is twice continuously differentiable on 

<math display="inline" id="Newton's_method:70">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msup>
     <mi>f</mi>
     <mi>′′</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>′′</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(x)f^{\prime\prime}(x)\neq 0
  </annotation>
 </semantics>
</math>

 and that 

<math display="inline" id="Newton's_method:71">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>a</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(a)<0
  </annotation>
 </semantics>
</math>

 contains a root in this interval. Assume that 

<math display="inline" id="Newton's_method:72">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>b</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(b)>0
  </annotation>
 </semantics>
</math>

 on this interval (this is the case for instance if 

<math display="inline" id="Newton's_method:73">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(x)>0
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Newton's_method:74">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mi>′′</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>′′</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime\prime}(x)>0
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Newton's_method:75">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Newton's_method:76">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 on this interval). This guarantees that there is a unique root on this interval, call it 

<math display="inline" id="Newton's_method:77">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -f(x)
  </annotation>
 </semantics>
</math>

. If it is concave down instead of concave up then replace 

<math display="inline" id="Newton's_method:78">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}=b
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Newton's_method:79">
 <semantics>
  <mrow>
   <msub>
    <mi>z</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{0}=a
  </annotation>
 </semantics>
</math>

 since they have the same roots.</p>

<p>Let 

<math display="inline" id="Newton's_method:80">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}
  </annotation>
 </semantics>
</math>

 be the right endpoint of the interval and let 

<math display="inline" id="Newton's_method:81">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <msup>
       <mi>f</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n+1}=x_{n}-\frac{f(x_{n})}{f^{\prime}(x_{n})}
  </annotation>
 </semantics>
</math>

 be the left endpoint of the interval. Given 

<math display="inline" id="Newton's_method:82">
 <semantics>
  <mrow>
   <msub>
    <mi>z</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>z</mi>
     <mi>n</mi>
    </msub>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>z</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <msup>
       <mi>f</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{n+1}=z_{n}-\frac{f(z_{n})}{f^{\prime}(x_{n})}
  </annotation>
 </semantics>
</math>

, define 

<math display="inline" id="Newton's_method:83">
 <semantics>
  <mrow>
   <msup>
    <mi>f</mi>
    <mo>′</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(x_{n})
  </annotation>
 </semantics>
</math>

, which is just Newton's method as before. Then define 

<math display="inline" id="Newton's_method:84">
 <semantics>
  <mrow>
   <msup>
    <mi>f</mi>
    <mo>′</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>z</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>z</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(z_{n})
  </annotation>
 </semantics>
</math>

 and note that the denominator has 

<math display="inline" id="Newton's_method:85">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}
  </annotation>
 </semantics>
</math>

 and not 

<math display="inline" id="Newton's_method:86">
 <semantics>
  <msub>
   <mi>z</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>z</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{n}
  </annotation>
 </semantics>
</math>

. The iterates 

<math display="inline" id="Newton's_method:87">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mo>lim</mo>
     <mrow>
      <mi>n</mi>
      <mo>→</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msub>
    <mfrac>
     <mrow>
      <msub>
       <mi>x</mi>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>z</mi>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>z</mi>
         <mi>n</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msup>
      <mi>f</mi>
      <mi>′′</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>α</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mn>2</mn>
     <msup>
      <mi>f</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>α</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-→</ci>
       <ci>n</ci>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>′′</ci>
      </apply>
      <ci>α</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>α</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lim_{n\to\infty}\frac{x_{n+1}-z_{n+1}}{(x_{n}-z_{n})^{2}}=\frac{f^{\prime%
\prime}(\alpha)}{2f^{\prime}(\alpha)}
  </annotation>
 </semantics>
</math>

 will be strictly decreasing to the root while the iterates 

<math display="inline" id="Newton's_method:88">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n}
  </annotation>
 </semantics>
</math>

 will be strictly increasing to the root. Also, 

<math display="inline" id="Newton's_method:89">
 <semantics>
  <msub>
   <mi>z</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>z</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{n}
  </annotation>
 </semantics>
</math>

 so that distance between 

<math display="block" id="Newton's_method:90">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <msup>
        <mi>f</mi>
        <mo>′</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <msup>
        <mi>f</mi>
        <mi>′′</mi>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>′′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{n+1}=x_{n}-\frac{f^{\prime}(x_{n})}{f^{\prime\prime}(x_{n})}.\,\!
  </annotation>
 </semantics>
</math>

 and 

<math display="block" id="Newton's_method:91">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>a</mi>
    <mo>-</mo>
    <mfrac>
     <mn>1</mn>
     <mi>x</mi>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>a</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=a-\frac{1}{x}
  </annotation>
 </semantics>
</math>

 decreases quadratically.</p>
<h3 id="quasi-newton-methods">Quasi-Newton methods</h3>

<p>When the Jacobian is unavailable or too expensive to compute at every iteration, a <a href="Quasi-Newton_method" title="wikilink">Quasi-Newton method</a> can be used.</p>
<h2 id="applications">Applications</h2>
<h3 id="minimization-and-maximization-problems">Minimization and maximization problems</h3>

<p>Newton's method can be used to find a minimum or maximum of a function. The derivative is zero at a minimum or maximum, so minima and maxima can be found by applying Newton's method to the derivative. The iteration becomes:</p>

<p>

<math display="inline" id="Newton's_method:92">
 <semantics>
  <msub>
   <mi>x</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle x_{n+1}
  </annotation>
 </semantics>
</math>


</p>
<h3 id="multiplicative-inverses-of-numbers-and-power-series">Multiplicative inverses of numbers and power series</h3>

<p>An important application is <a href="Division_algorithm#Newton–Raphson_division" title="wikilink">Newton–Raphson division</a>, which can be used to quickly find the <a href="Multiplicative_inverse" title="wikilink">reciprocal</a> of a number, using only multiplication and subtraction.</p>

<p>Finding the reciprocal of <em>a</em> amounts to finding the root of the function</p>

<p>

<math display="block" id="Newton's_method:93">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>h</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)=h(x),\,\!
  </annotation>
 </semantics>
</math>

 Newton's iteration is</p>

<p>

<math display="block" id="Newton's_method:94">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=g(x)-h(x).\,\!
  </annotation>
 </semantics>
</math>

 Therefore, Newton's iteration needs only two multiplications and one subtraction.</p>

<p>This method is also very efficient to compute the multiplicative inverse of a <a href="power_series" title="wikilink">power series</a>.</p>
<h3 id="solving-transcendental-equations">Solving transcendental equations</h3>

<p>Many <a href="transcendental_equation" title="wikilink">transcendental equations</a> can be solved using Newton's method. Given the equation</p>

<p>

<math display="block" id="Newton's_method:95">
 <semantics>
  <mrow>
   <msup>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi>x</mi>
    </mpadded>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mn>612</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">612</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,x^{2}=612
  </annotation>
 </semantics>
</math>

 with <em>g(x)</em> and/or <em>h(x)</em> a <a href="transcendental_function" title="wikilink">transcendental function</a>, one writes</p>

<p>

<math display="block" id="Newton's_method:96">
 <semantics>
  <mrow>
   <mrow>
    <mpadded lspace="1.7pt" width="+1.7pt">
     <mi>f</mi>
    </mpadded>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mo>-</mo>
    <mn>612</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">612</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \,f(x)=x^{2}-612
  </annotation>
 </semantics>
</math>

 The values of <em>x</em> that solves the original equation are then the roots of <em>f(x)</em>, which may be found via Newton's method.</p>
<h2 id="examples">Examples</h2>
<h3 id="square-root-of-a-number">Square root of a number</h3>

<p>Consider the problem of finding the square root of a number. Newton's method is one of many <a href="methods_of_computing_square_roots" title="wikilink">methods of computing square roots</a>.</p>

<p>For example, if one wishes to find the square root of 612, this is equivalent to finding the solution to</p>

<p>

<math display="block" id="Newton's_method:97">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>f</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>2</mn>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(x)=2x.\,
  </annotation>
 </semantics>
</math>

</p>

<p>The function to use in Newton's method is then,</p>

<p>

<math display="block" id="Newton's_method:98">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="center">
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>0</mn>
      </msub>
      <mo>-</mo>
      <mfrac>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mn>0</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <msup>
         <mi>f</mi>
         <mo>′</mo>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mn>0</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mn>10</mn>
      <mo>-</mo>
      <mfrac>
       <mrow>
        <msup>
         <mn>10</mn>
         <mn>2</mn>
        </msup>
        <mo>-</mo>
        <mn>612</mn>
       </mrow>
       <mrow>
        <mn>2</mn>
        <mo>⋅</mo>
        <mn>10</mn>
       </mrow>
      </mfrac>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mn>35.6</mn>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>-</mo>
      <mfrac>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mn>1</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <msup>
         <mi>f</mi>
         <mo>′</mo>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mn>1</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mn>35.6</mn>
      <mo>-</mo>
      <mfrac>
       <mrow>
        <msup>
         <mn>35.6</mn>
         <mn>2</mn>
        </msup>
        <mo>-</mo>
        <mn>612</mn>
       </mrow>
       <mrow>
        <mn>2</mn>
        <mo>⋅</mo>
        <mn>35.6</mn>
       </mrow>
      </mfrac>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <munder accentunder="true">
       <mn>2</mn>
       <mo>¯</mo>
      </munder>
      <mn>6.395505617978</mn>
      <mi mathvariant="normal">…</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <msub>
      <mi>x</mi>
      <mn>3</mn>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mi mathvariant="normal">⋮</mi>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mi mathvariant="normal">⋮</mi>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <munder accentunder="true">
       <mn>24.7</mn>
       <mo>¯</mo>
      </munder>
      <mn>90635492455</mn>
      <mi mathvariant="normal">…</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <msub>
      <mi>x</mi>
      <mn>4</mn>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mi mathvariant="normal">⋮</mi>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mi mathvariant="normal">⋮</mi>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <munder accentunder="true">
       <mn>24.7386</mn>
       <mo>¯</mo>
      </munder>
      <mn>88294075</mn>
      <mi mathvariant="normal">…</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <msub>
      <mi>x</mi>
      <mn>5</mn>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mi mathvariant="normal">⋮</mi>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mi mathvariant="normal">⋮</mi>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <munder accentunder="true">
       <mn>24.7386337537</mn>
       <mo>¯</mo>
      </munder>
      <mn>67</mn>
      <mi mathvariant="normal">…</mi>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <cn type="integer">10</cn>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">10</cn>
         <cn type="integer">2</cn>
        </apply>
        <cn type="integer">612</cn>
       </apply>
       <apply>
        <ci>normal-⋅</ci>
        <cn type="integer">2</cn>
        <cn type="integer">10</cn>
       </apply>
      </apply>
     </apply>
     <eq></eq>
     <cn type="float">35.6</cn>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <cn type="float">35.6</cn>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="float">35.6</cn>
         <cn type="integer">2</cn>
        </apply>
        <cn type="integer">612</cn>
       </apply>
       <apply>
        <ci>normal-⋅</ci>
        <cn type="integer">2</cn>
        <cn type="float">35.6</cn>
       </apply>
      </apply>
     </apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-¯</ci>
       <cn type="integer">2</cn>
      </apply>
      <cn type="float">6.395505617978</cn>
      <ci>normal-…</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
     <eq></eq>
     <ci>normal-⋮</ci>
     <eq></eq>
     <ci>normal-⋮</ci>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-¯</ci>
       <cn type="float">24.7</cn>
      </apply>
      <cn type="integer">90635492455</cn>
      <ci>normal-…</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">4</cn>
     </apply>
     <eq></eq>
     <ci>normal-⋮</ci>
     <eq></eq>
     <ci>normal-⋮</ci>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-¯</ci>
       <cn type="float">24.7386</cn>
      </apply>
      <cn type="integer">88294075</cn>
      <ci>normal-…</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">5</cn>
     </apply>
     <eq></eq>
     <ci>normal-⋮</ci>
     <eq></eq>
     <ci>normal-⋮</ci>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-¯</ci>
       <cn type="float">24.7386337537</cn>
      </apply>
      <cn type="integer">67</cn>
      <ci>normal-…</ci>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{matrix}x_{1}&=&x_{0}-\dfrac{f(x_{0})}{f^{\prime}(x_{0})}&=&10-\dfrac{10%
^{2}-612}{2\cdot 10}&=&35.6\\
x_{2}&=&x_{1}-\dfrac{f(x_{1})}{f^{\prime}(x_{1})}&=&35.6-\dfrac{35.6^{2}-612}{%
2\cdot 35.6}&=&\underline{2}6.395505617978\dots\\
x_{3}&=&\vdots&=&\vdots&=&\underline{24.7}90635492455\dots\\
x_{4}&=&\vdots&=&\vdots&=&\underline{24.7386}88294075\dots\\
x_{5}&=&\vdots&=&\vdots&=&\underline{24.7386337537}67\dots\end{matrix}
  </annotation>
 </semantics>
</math>

</p>

<p>with derivative,</p>

<p>

<math display="block" id="Newton's_method:99">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="center">
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>0</mn>
      </msub>
      <mo>-</mo>
      <mfrac>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mn>0</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <msup>
         <mi>f</mi>
         <mo>′</mo>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mn>0</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <mn>0.5</mn>
      <mo>-</mo>
      <mfrac>
       <mrow>
        <mrow>
         <mi>cos</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>0.5</mn>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>0.5</mn>
          <mo stretchy="false">)</mo>
         </mrow>
         <mn>3</mn>
        </msup>
       </mrow>
       <mrow>
        <mrow>
         <mo>-</mo>
         <mrow>
          <mi>sin</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mn>0.5</mn>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mn>3</mn>
         <msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mn>0.5</mn>
           <mo stretchy="false">)</mo>
          </mrow>
          <mn>2</mn>
         </msup>
        </mrow>
       </mrow>
      </mfrac>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mn>1.112141637097</mn>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>-</mo>
      <mfrac>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mn>1</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <msup>
         <mi>f</mi>
         <mo>′</mo>
        </msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mn>1</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mi mathvariant="normal">⋮</mi>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <munder accentunder="true">
       <mn>0.</mn>
       <mo>¯</mo>
      </munder>
      <mn>909672693736</mn>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <msub>
      <mi>x</mi>
      <mn>3</mn>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mi mathvariant="normal">⋮</mi>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mi mathvariant="normal">⋮</mi>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <munder accentunder="true">
       <mn>0.86</mn>
       <mo>¯</mo>
      </munder>
      <mn>7263818209</mn>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <msub>
      <mi>x</mi>
      <mn>4</mn>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mi mathvariant="normal">⋮</mi>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mi mathvariant="normal">⋮</mi>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <munder accentunder="true">
       <mn>0.86547</mn>
       <mo>¯</mo>
      </munder>
      <mn>7135298</mn>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <msub>
      <mi>x</mi>
      <mn>5</mn>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mi mathvariant="normal">⋮</mi>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mi mathvariant="normal">⋮</mi>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mrow>
      <munder accentunder="true">
       <mn>0.8654740331</mn>
       <mo>¯</mo>
      </munder>
      <mn>11</mn>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="center">
     <msub>
      <mi>x</mi>
      <mn>6</mn>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mi mathvariant="normal">⋮</mi>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <mi mathvariant="normal">⋮</mi>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="center">
     <munder accentunder="true">
      <mn>0.865474033102</mn>
      <mo>¯</mo>
     </munder>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <cn type="float">0.5</cn>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <cos></cos>
         <cn type="float">0.5</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="float">0.5</cn>
         <cn type="integer">3</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <minus></minus>
         <apply>
          <sin></sin>
          <cn type="float">0.5</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">3</cn>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <cn type="float">0.5</cn>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <eq></eq>
     <cn type="float">1.112141637097</cn>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <eq></eq>
     <ci>normal-⋮</ci>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-¯</ci>
       <cn type="float">0.</cn>
      </apply>
      <cn type="integer">909672693736</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
     <eq></eq>
     <ci>normal-⋮</ci>
     <eq></eq>
     <ci>normal-⋮</ci>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-¯</ci>
       <cn type="float">0.86</cn>
      </apply>
      <cn type="integer">7263818209</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">4</cn>
     </apply>
     <eq></eq>
     <ci>normal-⋮</ci>
     <eq></eq>
     <ci>normal-⋮</ci>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-¯</ci>
       <cn type="float">0.86547</cn>
      </apply>
      <cn type="integer">7135298</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">5</cn>
     </apply>
     <eq></eq>
     <ci>normal-⋮</ci>
     <eq></eq>
     <ci>normal-⋮</ci>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-¯</ci>
       <cn type="float">0.8654740331</cn>
      </apply>
      <cn type="integer">11</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">6</cn>
     </apply>
     <eq></eq>
     <ci>normal-⋮</ci>
     <eq></eq>
     <ci>normal-⋮</ci>
     <eq></eq>
     <apply>
      <ci>normal-¯</ci>
      <cn type="float">0.865474033102</cn>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{matrix}x_{1}&=&x_{0}-\dfrac{f(x_{0})}{f^{\prime}(x_{0})}&=&0.5-\dfrac{%
\cos(0.5)-(0.5)^{3}}{-\sin(0.5)-3(0.5)^{2}}&=&1.112141637097\\
x_{2}&=&x_{1}-\dfrac{f(x_{1})}{f^{\prime}(x_{1})}&=&\vdots&=&\underline{0.}909%
672693736\\
x_{3}&=&\vdots&=&\vdots&=&\underline{0.86}7263818209\\
x_{4}&=&\vdots&=&\vdots&=&\underline{0.86547}7135298\\
x_{5}&=&\vdots&=&\vdots&=&\underline{0.8654740331}11\\
x_{6}&=&\vdots&=&\vdots&=&\underline{0.865474033102}\end{matrix}
  </annotation>
 </semantics>
</math>

</p>

<p>With an initial guess of 10, the sequence given by Newton's method is</p>

<p>

<math display="inline" id="Newton's_method:100">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}=1
  </annotation>
 </semantics>
</math>

</p>

<p>where the correct digits are underlined. With only a few iterations one can obtain a solution accurate to many decimal places.</p>

<p>=== Solution of cos(<em>x</em>) = <em>x</em><sup>3</sup> === Consider the problem of finding the positive number <em>x</em> with cos(<em>x</em>) = <em>x</em><sup>3</sup>. We can rephrase that as finding the zero of <em>f</em>(<em>x</em>) = cos(<em>x</em>) − <em>x</em><sup>3</sup>. We have <em>f</em>'(<em>x</em>) = −sin(<em>x</em>) − 3<em>x</em><sup>2</sup>. Since cos(<em>x</em>) ≤ 1 for all <em>x</em> and <em>x</em><sup>3</sup> &gt; 1 for <em>x</em> &gt; 1, we know that our solution lies between 0 and 1. We try a starting value of <em>x</em><sub>0</sub> = 0.5. (Note that a starting value of 0 will lead to an undefined result, showing the importance of using a starting point that is close to the solution.)</p>

<p>

<math display="inline" id="Newton's_method:101">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=x^{2}-2
  </annotation>
 </semantics>
</math>

</p>

<p>The correct digits are underlined in the above example. In particular, <em>x</em><sub>6</sub> is correct to the number of decimal places given. We see that the number of correct digits after the decimal point increases from 2 (for <em>x</em><sub>3</sub>) to 5 and 10, illustrating the quadratic convergence.</p>
<h2 id="pseudocode">Pseudocode</h2>

<p>The following is an example of using the Newton's Method to help find a root of a function <code>f</code> which has derivative <code>fprime</code>.</p>

<p>The initial guess will be 

<math display="inline" id="Newton's_method:102">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(x)=2x
  </annotation>
 </semantics>
</math>

 and the function will be 

<math display="inline" id="Newton's_method:103">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(x_{n})\approx 0
  </annotation>
 </semantics>
</math>

 so that <span class="LaTeX">$f'(x) = 2x$</span>.</p>

<p>Each new iterative of Newton's method will be denoted by <code>x1</code>. We will check during the computation whether the denominator (<code>yprime</code>) becomes too small (smaller than <code>epsilon</code>), which would be the case if <span class="LaTeX">$f'(x_n) \approx 0$</span>, since otherwise a large amount of error could be introduced.</p>
<div class="sourceCode"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span class="co">%These choices depend on the problem being solved</span>
x0 = <span class="fl">1</span>                      <span class="co">%The initial value</span>
f = @(x) x^<span class="fl">2</span> - <span class="fl">2</span>            <span class="co">%The function whose root we are trying to find</span>
fprime = @(x) <span class="fl">2</span>*x           <span class="co">%The derivative of f(x)</span>
tolerance = <span class="fl">10</span>^(-<span class="fl">7</span>)         <span class="co">%7 digit accuracy is desired</span>
epsilon = <span class="fl">10</span>^(-<span class="fl">14</span>)          <span class="co">%Don't want to divide by a number smaller than this</span>

maxIterations = <span class="fl">20</span>          <span class="co">%Don't allow the iterations to continue indefinitely</span>
haveWeFoundSolution = false <span class="co">%Have not converged to a solution yet</span>

for i = <span class="fl">1</span> : maxIterations 

    y = f(x0)
    yprime = fprime(x0)

    if(abs(yprime) &lt; epsilon)                         <span class="co">%Don't want to divide by too small of a number</span>
        <span class="co">% denominator is too small</span>
        break;                                        <span class="co">%Leave the loop</span>
    end

    x1 = x0 - y/yprime                                <span class="co">%Do Newton's computation</span>
    
    if(abs(x1 - x0)/abs(x1) &lt; tolerance)              <span class="co">%If the result is within the desired tolerance</span>
        haveWeFoundSolution = true
        break;                                        <span class="co">%Done, so leave the loop</span>
    end

    x0 = x1                                           <span class="co">%Update x0 to start the process again                  </span>
    
end

if (haveWeFoundSolution)
   ... <span class="co">% x1 is a solution within tolerance and maximum number of iterations</span>
else 
   ... <span class="co">% did not converge</span>
end</code></pre></div>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Aitken's_delta-squared_process" title="wikilink">Aitken's delta-squared process</a></li>
<li><a href="Bisection_method" title="wikilink">Bisection method</a></li>
<li><a href="Euler_method" title="wikilink">Euler method</a></li>
<li><a href="Fast_inverse_square_root" title="wikilink">Fast inverse square root</a></li>
<li><a href="Scoring_algorithm#Fisher_scoring" title="wikilink">Fisher scoring</a></li>
<li><a href="Gradient_descent" title="wikilink">Gradient descent</a></li>
<li><a href="Integer_square_root" title="wikilink">Integer square root</a></li>
<li><a href="Laguerre's_method" title="wikilink">Laguerre's method</a></li>
<li><a href="Leonid_Kantorovich" title="wikilink">Leonid Kantorovich</a>, who initiated the convergence analysis of Newton's method in Banach spaces.</li>
<li><a href="Methods_of_computing_square_roots" title="wikilink">Methods of computing square roots</a></li>
<li><a href="Newton's_method_in_optimization" title="wikilink">Newton's method in optimization</a></li>
<li><a href="Richardson_extrapolation" title="wikilink">Richardson extrapolation</a></li>
<li><a href="Root-finding_algorithm" title="wikilink">Root-finding algorithm</a></li>
<li><a href="Secant_method" title="wikilink">Secant method</a></li>
<li><a href="Steffensen's_method" title="wikilink">Steffensen's method</a></li>
<li><a href="Subgradient_method" title="wikilink">Subgradient method</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li></li>
</ul>
<ul>
<li>Kendall E. Atkinson, <em>An Introduction to Numerical Analysis</em>, (1989) John Wiley &amp; Sons, Inc, ISBN 0-471-62489-6</li>
<li>Tjalling J. Ypma, Historical development of the Newton-Raphson method, <em>SIAM Review</em> <strong>37</strong> (4), 531–551, 1995. .</li>
<li></li>
<li>P. Deuflhard, <em>Newton Methods for Nonlinear Problems. Affine Invariance and Adaptive Algorithms.</em> Springer Series in Computational Mathematics, Vol. 35. Springer, Berlin, 2004. ISBN 3-540-21099-7.</li>
<li>C. T. Kelley, <em>Solving Nonlinear Equations with Newton's Method</em>, no 1 in Fundamentals of Algorithms, SIAM, 2003. ISBN 0-89871-546-6.</li>
<li>J. M. Ortega, W. C. Rheinboldt, <em>Iterative Solution of Nonlinear Equations in Several Variables.</em> Classics in Applied Mathematics, SIAM, 2000. ISBN 0-89871-461-3.</li>
<li>

<p>. See especially Sections <a href="http://apps.nrbook.com/empanel/index.html#pg=456">9.4</a>, <a href="http://apps.nrbook.com/empanel/index.html#pg=473">9.6</a>, and <a href="http://apps.nrbook.com/empanel/index.html#pg=477">9.7</a>.</p></li>
<li><a href="Endre_Süli" title="wikilink">Endre Süli</a> and David Mayers, <em>An Introduction to Numerical Analysis</em>, Cambridge University Press, 2003. ISBN 0-521-00794-1.</li>
<li>

<p>.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Optimization_algorithms_and_methods" title="wikilink">Category:Optimization algorithms and methods</a> <a href="Category:Root-finding_algorithms" title="wikilink">Category:Root-finding algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3">Dence, Thomas, "Cubics, chaos and Newton's method", <em><a href="Mathematical_Gazette" title="wikilink">Mathematical Gazette</a></em> 81, November 1997, 403-408.<a href="#fnref3">↩</a></li>
<li id="fn4">Strang, Gilbert, "A chaotic search for <em>i</em>", '<em>'<a href="The_College_Mathematics_Journal" title="wikilink">The College Mathematics Journal</a></em> 22, January 1991, pp. 3-12 (esp. p. 6).<a href="#fnref4">↩</a></li>
<li id="fn5">McMullen, Curt, "Families of rational maps and iterative root-finding algorithms", <em>Ann. of Math. (2)</em> 125 (1987), no. 3, 467–493.<a href="#fnref5">↩</a></li>
</ol>
</section>
</body>

