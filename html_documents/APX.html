<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1972">APX</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>APX</h1>
<hr/>

<p>In <a href="computational_complexity_theory" title="wikilink">complexity theory</a> the class <strong>APX</strong> (an abbreviation of "approximable") is the set of <strong><a href="NP_(complexity)" title="wikilink">NP</a></strong> <a href="optimization_problem" title="wikilink">optimization problems</a> that allow <a class="uri" href="polynomial-time" title="wikilink">polynomial-time</a> <a href="approximation_algorithm" title="wikilink">approximation algorithms</a> with approximation ratio bounded by a constant (or <strong>constant-factor approximation algorithms</strong> for short). In simple terms, problems in this class have efficient <a href="algorithm" title="wikilink">algorithms</a> that can find an answer within some fixed multiplicative factor of the optimal answer. The class APX is also sometimes known as <strong>MaxSNP</strong> because the basis of its definition is formed by <a href="SNP_(complexity)" title="wikilink">SNP</a>.</p>

<p>An approximation algorithm is called a 

<math display="inline" id="APX:0">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)
  </annotation>
 </semantics>
</math>

-approximation algorithm for input size 

<math display="inline" id="APX:1">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 if it can be proven that the solution that the algorithm finds is at most a multiplicative factor of 

<math display="inline" id="APX:2">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)
  </annotation>
 </semantics>
</math>

 times worse than the optimal solution. Here, 

<math display="inline" id="APX:3">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)
  </annotation>
 </semantics>
</math>


 is called the <em>approximation ratio</em>. Problems in APX are those with algorithms for which the approximation ratio 

<math display="inline" id="APX:4">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)
  </annotation>
 </semantics>
</math>

 is a constant 

<math display="inline" id="APX:5">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

. The approximation ratio is conventionally stated greater than 1. In the case of minimization problems, 

<math display="inline" id="APX:6">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)
  </annotation>
 </semantics>
</math>

 is the found solution's score divided by the optimum solution's score, while for maximization problems the reverse is the case. For maximization problems, where an inferior solution has a smaller score, 

<math display="inline" id="APX:7">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)
  </annotation>
 </semantics>
</math>

 is sometimes stated as less than 1; in such cases, the reciprocal of 

<math display="inline" id="APX:8">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)
  </annotation>
 </semantics>
</math>


 is the ratio of the score of the found solution to the score of the optimum solution.</p>

<p>If there is a polynomial-time algorithm to solve a problem to within <em>every</em> multiplicative factor of the optimum other than 1, then the problem is said to have a <a href="Polynomial-time_approximation_scheme" title="wikilink">polynomial-time approximation scheme (<strong>PTAS</strong>)</a>. Unless <a href="P_=_NP_problem" title="wikilink">P=NP</a> there exist problems that are in APX but without a PTAS, so the class of problems with a PTAS is strictly contained in APX. One such problem is the <a href="bin_packing_problem" title="wikilink">bin packing problem</a>.</p>
<h2 id="apx-hardness-and-apx-completeness">APX-Hardness and APX-Completeness</h2>

<p>A problem is said to be <strong>APX-hard</strong> if there is a <a href="PTAS_reduction" title="wikilink">PTAS reduction</a> from every problem in APX to that problem, and to be <strong>APX-complete</strong> if the problem is APX-hard and also in APX. As a consequence of P ≠ NP ⇒ PTAS ≠ APX, P ≠ NP implies no APX-hard problem has a PTAS. In practice, reducing one problem to another to demonstrate APX-completeness is often done using other reduction schemes, such as <a href="L-reduction" title="wikilink">L-reductions</a>, which imply PTAS reductions.</p>
<h3 id="examples">Examples</h3>

<p>One of the simplest APX-complete problems is <a href="MAX-3SAT" title="wikilink">MAX-3SAT-3</a>, a variation of the <a href="boolean_satisfiability_problem" title="wikilink">boolean satisfiability problem</a>. In this problem, we have a boolean formula in <a href="conjunctive_normal_form" title="wikilink">conjunctive normal form</a> where each variable appears at most 3 times, and we wish to know the maximum number of clauses that can be simultaneously satisfied by a single assignment of true/false values to the variables.</p>

<p>Other APX-complete problems include:</p>
<ul>
<li><a href="Independent_set_(graph_theory)#Approximation_algorithms" title="wikilink">Max Independent Set</a> in bounded-degree graphs (here, the approximation ratio depends on the maximum degree of the graph, but is constant if the max degree is fixed).</li>
</ul>
<ul>
<li><a href="Vertex_cover#Approximate_evaluation" title="wikilink">Min Vertex Cover</a>. The complement of any maximal independent set must be a vertex cover.</li>
</ul>
<ul>
<li><a href="Dominating_set#Algorithms_and_computational_complexity" title="wikilink">Min Dominating Set</a> in bounded-degree graphs.</li>
</ul>
<ul>
<li>The <a href="Travelling_salesman_problem#Complexity_of_approximation" title="wikilink">travelling salesman problem</a> when the distances in the graph satisfy the conditions of a <a href="Metric_(mathematics)" title="wikilink">metric</a>. TSP is <a href="Optimization_problem#NP_optimization_problem" title="wikilink">NPO-complete</a> in the general case.</li>
</ul>
<ul>
<li>The <a href="Token_reconfiguration" title="wikilink">Token reconfiguration</a> problem, via <a class="uri" href="L-reduction" title="wikilink">L-reduction</a> from set cover.</li>
</ul>
<h2 id="related-complexity-classes">Related complexity classes</h2>
<h3 id="ptas">PTAS</h3>

<p>PTAS (<em>Polynomial Time Approximation Scheme</em>) consists of problems that can be approximated to within any constant factor besides 1 in time that is polynomial given that constant factor. This class is a subset of APX.</p>
<h3 id="apx-intermediate">APX-Intermediate</h3>

<p>Unless <a href="P_=_NP_problem" title="wikilink">P = NP</a>, there exist problems in APX that are neither in PTAS nor APX-complete. Such problems can be thought of as having a hardness between PTAS problems and APX-complete problems, and may be called <strong>APX-intermediate</strong>. The <a href="bin_packing_problem" title="wikilink">bin packing problem</a> is thought to be APX-intermediate. Despite not having a known PTAS, the bin packing problem has several "asymptotic PTAS" algorithms, which behave like a PTAS when the optimum solution is large, so intuitively it may be easier than problems that are APX-hard.</p>

<p>One other example of a potentially APX-intermediate problem is <a href="Edge_coloring#Algorithms_that_use_more_than_the_optimal_number_of_colors" title="wikilink">Min Edge Coloring</a>.</p>
<h3 id="fn-apx">f(n)-APX</h3>

<p>One can also define a family of complexity classes 

<math display="inline" id="APX:9">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)
  </annotation>
 </semantics>
</math>

-APX, where 

<math display="inline" id="APX:10">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)
  </annotation>
 </semantics>
</math>

-APX contains problems with a polynomial time approximation algorithm with a 

<math display="inline" id="APX:11">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(f(n))
  </annotation>
 </semantics>
</math>

 approximation ratio. One can analogously define 

<math display="inline" id="APX:12">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n)
  </annotation>
 </semantics>
</math>

-APX-complete classes; some such classes contain well-known optimization problems. Log-APX-completeness and Poly-APX-completeness are defined in terms of <a href="Approximation-preserving_reduction#AP-reduction" title="wikilink">AP-reductions</a> rather than PTAS-reductions; this is because PTAS-reductions are not strong enough to preserve membership in Log-APX and Poly-APX, even though they suffice for APX.</p>

<p>Log-APX-complete, consisting of the hardest problems that can be approximated efficiently to within a factor logarithmic in the input size, includes <a href="Dominating_set#Algorithms_and_computational_complexity" title="wikilink">Min Dominating Set</a> when degree is unbounded.</p>

<p>Poly-APX-complete, consisting of the hardest problems that can be approximated efficiently to within a factor polynomial in the input size, includes <a href="Independent_set_(graph_theory)#Approximation_algorithms" title="wikilink">Max Independent Set</a> in the general case.</p>

<p>There also exist problems that are Exp-APX-complete, where the approximation ratio is exponential in the input size. This may occur when the approximation is dependent on the value of numbers within the problem instance; these numbers may be expressed in space logarithmic in their value, hence the exponential factor.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Approximation-preserving_reduction" title="wikilink">Approximation-preserving reduction</a></li>
<li><a href="Complexity_class" title="wikilink">Complexity class</a></li>
<li><a href="Approximation_algorithm" title="wikilink">Approximation algorithm</a></li>
<li><a href="Max/min_CSP/Ones_classification_theorems" title="wikilink">Max/min CSP/Ones classification theorems</a> - a set of theorems that enable mechanical classification of problems about boolean relations into approximability complexity classes</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li>C. Papadimitriou and M. Yannakakis. Optimization, approximation and complexity classes. Journal of Computer and System Sciences, 43:425–440, 1991.</li>
<li>Pierluigi Crescenzi, Viggo Kann, Magnús Halldórsson, <a href="Marek_Karpinski" title="wikilink">Marek Karpinski</a> and Gerhard Woeginger. <a href="http://www.nada.kth.se/~viggo/wwwcompendium/node225.html">Maximum Satisfiability</a>. <a href="http://www.nada.kth.se/%7Eviggo/wwwcompendium/"><em>A compendium of NP optimization problems</em></a>. Last updated March 20, 2000.</li>
</ul>

<p>"</p>

<p><a href="Category:Complexity_classes" title="wikilink">Category:Complexity classes</a> <a href="Category:Approximation_algorithms" title="wikilink">Category:Approximation algorithms</a></p>
</body>
</html>
