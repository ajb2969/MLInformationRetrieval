<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="963">Polynomial interpolation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Polynomial interpolation</h1>
<hr/>

<p>In <a href="numerical_analysis" title="wikilink">numerical analysis</a>, <strong>polynomial interpolation</strong> is the <a class="uri" href="interpolation" title="wikilink">interpolation</a> of a given <a href="data_set" title="wikilink">data set</a> by a <a class="uri" href="polynomial" title="wikilink">polynomial</a>: given some <a href="Point_(geometry)#Points_in_Euclidean_geometry" title="wikilink">points</a>, find a polynomial which goes exactly through these points.</p>
<h2 id="applications">Applications</h2>

<p>Polynomials can be used to approximate complicated curves, for example, the shapes of letters in <a class="uri" href="typography" title="wikilink">typography</a>, given a few points. A relevant application is the evaluation of the <a href="natural_logarithm" title="wikilink">natural logarithm</a> and <a href="trigonometric_function" title="wikilink">trigonometric functions</a>: pick a few known data points, create a <a href="lookup_table" title="wikilink">lookup table</a>, and interpolate between those data points. This results in significantly faster computations. Polynomial interpolation also forms the basis for algorithms in <a href="numerical_quadrature" title="wikilink">numerical quadrature</a> and <a href="numerical_ordinary_differential_equations" title="wikilink">numerical ordinary differential equations</a>.</p>

<p>Polynomial interpolation is also essential to perform sub-quadratic multiplication and squaring such as <a href="Karatsuba_multiplication" title="wikilink">Karatsuba multiplication</a> and <a href="Toom‚ÄìCook_multiplication" title="wikilink">Toom‚ÄìCook multiplication</a>, where an interpolation through points on a polynomial which defines the product yields the product itself. For example, given <em>a</em> = <em>f</em>(<em>x</em>) = <em>a</em><sub>0</sub><em>x</em><sup>0</sup> + <em>a</em><sub>1</sub><em>x</em><sup>1</sup> + ... and <em>b</em> = <em>g</em>(<em>x</em>) = <em>b</em><sub>0</sub><em>x</em><sup>0</sup> + <em>b</em><sub>1</sub><em>x</em><sup>1</sup> + ..., the product <em>ab</em> is equivalent to <em>W</em>(<em>x</em>) = <em>f</em>(<em>x</em>)<em>g</em>(<em>x</em>). Finding points along <em>W</em>(<em>x</em>) by substituting <em>x</em> for small values in <em>f</em>(<em>x</em>) and <em>g</em>(<em>x</em>) yields points on the curve. Interpolation based on those points will yield the terms of <em>W</em>(<em>x</em>) and subsequently the product <em>ab</em>. In the case of Karatsuba multiplication this technique is substantially faster than quadratic multiplication, even for modest-sized inputs. This is especially true when implemented in parallel hardware.</p>
<h2 id="definition">Definition</h2>

<p>Given a set of 

<math display="inline" id="Polynomial_interpolation:0">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n+1
  </annotation>
 </semantics>
</math>

 data points <mtpl></mtpl> where no two <mtpl></mtpl> are the same, one is looking for a polynomial 

<math display="inline" id="Polynomial_interpolation:1">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 of degree at most 

<math display="inline" id="Polynomial_interpolation:2">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 with the property</p>

<p>

<math display="block" id="Polynomial_interpolation:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo rspace="22.5pt">,</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mrow>
      <mn>0</mn>
      <mo>,</mo>
      <mi mathvariant="normal">‚Ä¶</mi>
      <mo>,</mo>
      <mi>n</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>p</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>i</ci>
     <list>
      <cn type="integer">0</cn>
      <ci>normal-‚Ä¶</ci>
      <ci>n</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x_{i})=y_{i},\qquad i=0,\ldots,n.
  </annotation>
 </semantics>
</math>

</p>

<p>The <a href="Unisolvent_functions" title="wikilink">unisolvence</a> theorem  states that such a polynomial <em>p</em> exists and is unique, and can be proved by the <a href="Vandermonde_matrix" title="wikilink">Vandermonde matrix</a>, as described below.</p>

<p>The theorem states that for 

<math display="inline" id="Polynomial_interpolation:4">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n+1
  </annotation>
 </semantics>
</math>

 interpolation nodes <mtpl></mtpl>, polynomial interpolation defines a linear <a class="uri" href="bijection" title="wikilink">bijection</a></p>

<p>

<math display="block" id="Polynomial_interpolation:5">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mi>n</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>ùïÇ</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mo>‚Üí</mo>
    <msub>
     <mi mathvariant="normal">Œ†</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <ci>normal-‚Üí</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ùïÇ</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Œ†</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{n}:\mathbb{K}^{n+1}\to\Pi_{n}
  </annotation>
 </semantics>
</math>

</p>

<p>where Œ†<sub><em>n</em></sub> is the <a href="vector_space" title="wikilink">vector space</a> of polynomials (defined on any interval containing the nodes) of degree at most 

<math display="inline" id="Polynomial_interpolation:6">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="constructing-the-interpolation-polynomial">Constructing the interpolation polynomial</h2>

<p> Suppose that the interpolation polynomial is in the form</p>

<p>

<math display="block" id="Polynomial_interpolation:7">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>a</mi>
    <mi>n</mi>
   </msub>
   <msup>
    <mi>x</mi>
    <mi>n</mi>
   </msup>
   <mo>+</mo>
   <msub>
    <mi>a</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <msup>
    <mi>x</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>+</mo>
   <mi mathvariant="normal">‚ãØ</mi>
   <mo>+</mo>
   <msub>
    <mi>a</mi>
    <mn>2</mn>
   </msub>
   <msup>
    <mi>x</mi>
    <mn>2</mn>
   </msup>
   <mo>+</mo>
   <msub>
    <mi>a</mi>
    <mn>1</mn>
   </msub>
   <mi>x</mi>
   <mo>+</mo>
   <msub>
    <mi>a</mi>
    <mn>0</mn>
   </msub>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <plus></plus>
    <ci>normal-‚ãØ</ci>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
    <csymbol cd="unknown">x</csymbol>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>normal-.</ci>
    <ci>italic-</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)=a_{n}x^{n}+a_{n-1}x^{n-1}+\cdots+a_{2}x^{2}+a_{1}x+a_{0}.\qquad(1)
  </annotation>
 </semantics>
</math>

 The statement that <em>p</em> interpolates the data points means that</p>

<p>

<math display="block" id="Polynomial_interpolation:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mrow>
     <mrow>
      <mtext>for all</mtext>
      <mi>i</mi>
     </mrow>
     <mo>‚àà</mo>
     <mrow>
      <mo>{</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo>,</mo>
      <mi mathvariant="normal">‚Ä¶</mi>
      <mo>,</mo>
      <mi>n</mi>
      <mo>}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>p</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <mtext>for all</mtext>
      <ci>i</ci>
     </apply>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
      <ci>normal-‚Ä¶</ci>
      <ci>n</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x_{i})=y_{i}\qquad\mbox{for all }i\in\left\{0,1,\dots,n\right\}.
  </annotation>
 </semantics>
</math>

 If we substitute equation (1) in here, we get a <a href="system_of_linear_equations" title="wikilink">system of linear equations</a> in the coefficients <mtpl></mtpl>. The system in matrix-vector form reads</p>

<p>

<math display="block" id="Polynomial_interpolation:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <msubsup>
          <mi>x</mi>
          <mn>0</mn>
          <mi>n</mi>
         </msubsup>
        </mtd>
        <mtd columnalign="center">
         <msubsup>
          <mi>x</mi>
          <mn>0</mn>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msubsup>
        </mtd>
        <mtd columnalign="center">
         <msubsup>
          <mi>x</mi>
          <mn>0</mn>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>2</mn>
          </mrow>
         </msubsup>
        </mtd>
        <mtd columnalign="center">
         <mi mathvariant="normal">‚Ä¶</mi>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>x</mi>
          <mn>0</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <msubsup>
          <mi>x</mi>
          <mn>1</mn>
          <mi>n</mi>
         </msubsup>
        </mtd>
        <mtd columnalign="center">
         <msubsup>
          <mi>x</mi>
          <mn>1</mn>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msubsup>
        </mtd>
        <mtd columnalign="center">
         <msubsup>
          <mi>x</mi>
          <mn>1</mn>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>2</mn>
          </mrow>
         </msubsup>
        </mtd>
        <mtd columnalign="center">
         <mi mathvariant="normal">‚Ä¶</mi>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>x</mi>
          <mn>1</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mi mathvariant="normal">‚ãÆ</mi>
        </mtd>
        <mtd columnalign="center">
         <mi mathvariant="normal">‚ãÆ</mi>
        </mtd>
        <mtd columnalign="center">
         <mi mathvariant="normal">‚ãÆ</mi>
        </mtd>
        <mtd columnalign="center">
         <mi></mi>
        </mtd>
        <mtd columnalign="center">
         <mi mathvariant="normal">‚ãÆ</mi>
        </mtd>
        <mtd columnalign="center">
         <mi mathvariant="normal">‚ãÆ</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <msubsup>
          <mi>x</mi>
          <mi>n</mi>
          <mi>n</mi>
         </msubsup>
        </mtd>
        <mtd columnalign="center">
         <msubsup>
          <mi>x</mi>
          <mi>n</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msubsup>
        </mtd>
        <mtd columnalign="center">
         <msubsup>
          <mi>x</mi>
          <mi>n</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>2</mn>
          </mrow>
         </msubsup>
        </mtd>
        <mtd columnalign="center">
         <mi mathvariant="normal">‚Ä¶</mi>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>x</mi>
          <mi>n</mi>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
     <mrow>
      <mo>[</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>a</mi>
          <mi>n</mi>
         </msub>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>a</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mi mathvariant="normal">‚ãÆ</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>a</mi>
          <mn>0</mn>
         </msub>
        </mtd>
       </mtr>
      </mtable>
      <mo>]</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>[</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>y</mi>
         <mn>0</mn>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>y</mi>
         <mn>1</mn>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi mathvariant="normal">‚ãÆ</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>y</mi>
         <mi>n</mi>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>normal-‚Ä¶</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">0</cn>
       </apply>
       <cn type="integer">1</cn>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>normal-‚Ä¶</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">1</cn>
      </matrixrow>
      <matrixrow>
       <ci>normal-‚ãÆ</ci>
       <ci>normal-‚ãÆ</ci>
       <ci>normal-‚ãÆ</ci>
       <csymbol cd="latexml">absent</csymbol>
       <ci>normal-‚ãÆ</ci>
       <ci>normal-‚ãÆ</ci>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>normal-‚Ä¶</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
       <cn type="integer">1</cn>
      </matrixrow>
     </matrix>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>n</ci>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </matrixrow>
      <matrixrow>
       <ci>normal-‚ãÆ</ci>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">0</cn>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <matrix>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">0</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
     </matrixrow>
     <matrixrow>
      <ci>normal-‚ãÆ</ci>
     </matrixrow>
     <matrixrow>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}x_{0}^{n}&x_{0}^{n-1}&x_{0}^{n-2}&\ldots&x_{0}&1\\
x_{1}^{n}&x_{1}^{n-1}&x_{1}^{n-2}&\ldots&x_{1}&1\\
\vdots&\vdots&\vdots&&\vdots&\vdots\\
x_{n}^{n}&x_{n}^{n-1}&x_{n}^{n-2}&\ldots&x_{n}&1\end{bmatrix}\begin{bmatrix}a_%
{n}\\
a_{n-1}\\
\vdots\\
a_{0}\end{bmatrix}=\begin{bmatrix}y_{0}\\
y_{1}\\
\vdots\\
y_{n}\end{bmatrix}.
  </annotation>
 </semantics>
</math>

</p>

<p>We have to solve this system for <mtpl></mtpl> to construct the interpolant <em>p</em>(<em>x</em>). The matrix on the left is commonly referred to as a <a href="Vandermonde_matrix" title="wikilink">Vandermonde matrix</a>.</p>

<p>The <a href="condition_number" title="wikilink">condition number</a> of the Vandermonde matrix may be large,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> causing large errors when computing the coefficients <mtpl></mtpl> if the system of equations is solved using <a href="Gaussian_elimination" title="wikilink">Gaussian elimination</a>.</p>

<p>Several authors have therefore proposed algorithms which exploit the structure of the Vandermonde matrix to compute numerically stable solutions in O(<em>n</em><sup>2</sup>) operations instead of the O(<em>n</em><sup>3</sup>) required by Gaussian elimination.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> These methods rely on constructing first a <a href="Newton_polynomial" title="wikilink">Newton interpolation</a> of the polynomial and then converting it to the monomial form above.</p>

<p>Alternatively, we may write down the polynomial immediately in terms of <a href="Lagrange_polynomial" title="wikilink">Lagrange polynomials</a>:</p>

<p>

<math display="inline" id="Polynomial_interpolation:10">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle p(x)
  </annotation>
 </semantics>
</math>


</p>

<p>For matrix arguments, this formula is called <a href="Sylvester's_formula" title="wikilink">Sylvester's formula</a> and the matrix-valued Lagrange polynomials are the <a href="Frobenius_covariant" title="wikilink">Frobenius covariants</a>.</p>
<h2 id="uniqueness-of-the-interpolating-polynomial">Uniqueness of the interpolating polynomial</h2>
<h3 id="proof-1">Proof 1</h3>

<p>Suppose we interpolate through 

<math display="inline" id="Polynomial_interpolation:11">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n+1
  </annotation>
 </semantics>
</math>


 data points with an at-most 

<math display="inline" id="Polynomial_interpolation:12">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 degree polynomial <em>p</em>(<em>x</em>) (we need at least 

<math display="inline" id="Polynomial_interpolation:13">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n+1
  </annotation>
 </semantics>
</math>

 datapoints or else the polynomial cannot be fully solved for). Suppose also another polynomial exists also of degree at most 

<math display="inline" id="Polynomial_interpolation:14">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 that also interpolates the 

<math display="inline" id="Polynomial_interpolation:15">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n+1
  </annotation>
 </semantics>
</math>

 points; call it <em>q</em>(<em>x</em>).</p>

<p>Consider 

<math display="inline" id="Polynomial_interpolation:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>q</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(x)=p(x)-q(x)
  </annotation>
 </semantics>
</math>


. We know,</p>
<ol>
<li><em>r</em>(<em>x</em>) is a polynomial</li>
<li><em>r</em>(<em>x</em>) has degree at most 

<math display="inline" id="Polynomial_interpolation:17">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, since <em>p</em>(<em>x</em>) and <em>q</em>(<em>x</em>) are no higher than this and we are just subtracting them.</li>
<li>At the 

<math display="inline" id="Polynomial_interpolation:18">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n+1
  </annotation>
 </semantics>
</math>

 data points, 

<math display="inline" id="Polynomial_interpolation:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>r</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>p</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>q</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(x_{i})=p(x_{i})-q(x_{i})=y_{i}-y_{i}=0
  </annotation>
 </semantics>
</math>

. Therefore <em>r</em>(<em>x</em>) has 

<math display="inline" id="Polynomial_interpolation:20">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n+1
  </annotation>
 </semantics>
</math>

 roots.</li>
</ol>

<p>But <em>r</em>(<em>x</em>) is an polynomial of degree 

<math display="inline" id="Polynomial_interpolation:21">
 <semantics>
  <mrow>
   <mi mathvariant="normal">‚â§</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-‚â§</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ‚â§n
  </annotation>
 </semantics>
</math>


. It has one root too many. Formally, if <em>r</em>(<em>x</em>) is any non-zero polynomial, it must be writable as 

<math display="inline" id="Polynomial_interpolation:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <msub>
       <mi>x</mi>
       <mn>0</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi mathvariant="normal">‚ãØ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>A</ci>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-‚ãØ</ci>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(x)=A(x-x_{0})(x-x_{1})\cdots(x-x_{n})
  </annotation>
 </semantics>
</math>

, for some constant <em>A</em>. By distributivity, the 

<math display="inline" id="Polynomial_interpolation:23">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n+1
  </annotation>
 </semantics>
</math>

 <em>x</em>'s multiply together to give leading term 

<math display="inline" id="Polynomial_interpolation:24">
 <semantics>
  <mrow>
   <mi>A</mi>
   <msup>
    <mi>x</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Ax^{n+1}
  </annotation>
 </semantics>
</math>

, i.e. one degree higher than the maximum we set. So the only way <em>r</em>(<em>x</em>) can exist is if 

<math display="inline" id="Polynomial_interpolation:25">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=0
  </annotation>
 </semantics>
</math>

, or equivalently, 

<math display="inline" id="Polynomial_interpolation:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>r</ci>
     <ci>x</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(x)=0
  </annotation>
 </semantics>
</math>


.</p>

<p>

<math display="block" id="Polynomial_interpolation:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>‚üπ</mo>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>x</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>q</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <implies></implies>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>q</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(x)=0=p(x)-q(x)\implies p(x)=q(x)
  </annotation>
 </semantics>
</math>

</p>

<p>So <em>q</em>(<em>x</em>) (which could be any polynomial, so long as it interpolates the points) is identical with <em>p</em>(<em>x</em>), and <em>p</em>(<em>x</em>) is unique.</p>
<h3 id="proof-2">Proof 2</h3>

<p>Given the Vandermonde matrix used above to construct the interpolant, we can set up the system</p>

<p>

<math display="block" id="Polynomial_interpolation:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mi>a</mi>
   </mrow>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>a</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Va=y
  </annotation>
 </semantics>
</math>

</p>

<p>To prove that V is <a href="Invertible_matrix" title="wikilink">nonsingular</a> we use the Vandermonde determinant formula:</p>

<p>

<math display="inline" id="Polynomial_interpolation:29">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n+1
  </annotation>
 </semantics>
</math>

 is never zero, therefore <em>V</em> is nonsingular and the system has a unique solution.</p>

<p>Either way this means that no matter what method we use to do our interpolation: direct, <a href="Lagrange_polynomial" title="wikilink">Lagrange</a> etc., (assuming we can do all our calculations perfectly) we will always get the same polynomial.</p>
<h2 id="non-vandermonde-solutions">Non-Vandermonde solutions</h2>

<p>We are trying to construct our unique interpolation polynomial in the vector space Œ†<sub><em>n</em></sub> of polynomials of degree 

<math display="inline" id="Polynomial_interpolation:31">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


. When using a <a href="monomial_basis" title="wikilink">monomial basis</a> for Œ†<sub><em>n</em></sub> we have to solve the Vandermonde matrix to construct the coefficients <mtpl></mtpl> for the interpolation polynomial. This can be a very costly operation (as counted in clock cycles of a computer trying to do the job). By choosing another basis for Œ†<sub><em>n</em></sub> we can simplify the calculation of the coefficients but then we have to do additional calculations when we want to express the interpolation polynomial in terms of a <a href="monomial_basis" title="wikilink">monomial basis</a>.</p>

<p>One method is to write the interpolation polynomial in the <a href="Newton_form" title="wikilink">Newton form</a> and use the method of <a href="divided_differences" title="wikilink">divided differences</a> to construct the coefficients, e.g. <a href="Neville's_algorithm" title="wikilink">Neville's algorithm</a>. The cost is <a href="Big_O_notation" title="wikilink">O(<em>n</em><sup>2</sup>)</a> operations, while Gaussian elimination costs O(<em>n</em><sup>3</sup>) operations. Furthermore, you only need to do O(<em>n</em>) extra work if an extra point is added to the data set, while for the other methods, you have to redo the whole computation.</p>

<p>Another method is to use the <a href="Lagrange_form" title="wikilink">Lagrange form</a> of the interpolation polynomial. The resulting formula immediately shows that the interpolation polynomial exists under the conditions stated in the above theorem. Lagrange formula is to be preferred to Vandermonde formula when we are not interested in computing the coefficients of the polynomial, but in computing the value of <em>p</em>(<em>x</em>) in a given <em>x</em> not in the original data set. In this case, we can reduce complexity to O(<em>n</em><sup>2</sup>).<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>The <a href="Bernstein_form" title="wikilink">Bernstein form</a> was used in a constructive proof of the <a href="Weierstrass_approximation_theorem" title="wikilink">Weierstrass approximation theorem</a> by <a href="Sergei_Natanovich_Bernstein" title="wikilink">Bernstein</a> and has nowadays gained great importance in computer graphics in the form of <a href="B√©zier_curve" title="wikilink">B√©zier curves</a>.</p>
<h2 id="interpolation-error">Interpolation error</h2>

<p>When interpolating a given function <em>f</em> by a polynomial of degree 

<math display="block" id="Polynomial_interpolation:32">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>p</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">‚Ä¶</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>,</mo>
     <mi>x</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àè</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>normal-‚Ä¶</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
     </list>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)-p_{n}(x)=f[x_{0},\ldots,x_{n},x]\prod_{i=0}^{n}(x-x_{i})
  </annotation>
 </semantics>
</math>

 at the nodes <em>x</em><sub>0</sub>,...,<em>x</em><sub><em>n</em></sub> we get the error</p>

<p>

<math display="block" id="Polynomial_interpolation:33">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo>,</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <ci>x</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f[x_{0},\ldots,x_{n},x]
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="inline" id="Polynomial_interpolation:34">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n+1
  </annotation>
 </semantics>
</math>

</p>

<p>is the notation for <a href="divided_differences" title="wikilink">divided differences</a>.</p>

<p>If <em>f</em> is 

<math display="inline" id="Polynomial_interpolation:35">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>n</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{n}(x)
  </annotation>
 </semantics>
</math>

 times continuously differentiable on a closed interval <em>I</em> and 

<math display="inline" id="Polynomial_interpolation:36">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


 be a polynomial of degree at most 

<math display="inline" id="Polynomial_interpolation:37">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n+1
  </annotation>
 </semantics>
</math>

 that interpolates <em>f</em> at 

<math display="inline" id="Polynomial_interpolation:38">
 <semantics>
  <mi>Œæ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œæ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Œæ
  </annotation>
 </semantics>
</math>

 distinct points {<em>x</em><sub><em>i</em></sub>} (<em>i</em>=0,1,...,n) in that interval. Then for each x in the interval there exists 

<math display="block" id="Polynomial_interpolation:39">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>p</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <msup>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Œæ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àè</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>Œæ</ci>
      </apply>
      <apply>
       <factorial></factorial>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)-p_{n}(x)=\frac{f^{(n+1)}(\xi)}{(n+1)!}\prod_{i=0}^{n}(x-x_{i})
  </annotation>
 </semantics>
</math>

 in that interval such that</p>

<p>

<math display="block" id="Polynomial_interpolation:40">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>R</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>p</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>n</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{n}(x)=f(x)-p_{n}(x)
  </annotation>
 </semantics>
</math>

</p>
<h3 id="proof">Proof</h3>

<p>Set the error term as</p>

<p>

<math display="block" id="Polynomial_interpolation:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>Y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>R</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mfrac>
      <mrow>
       <msub>
        <mi>R</mi>
        <mi>n</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mi>W</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
     <mi>W</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Y</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>n</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <ci>n</ci>
        </apply>
        <ci>x</ci>
       </apply>
       <apply>
        <times></times>
        <ci>W</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <ci>W</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y(t)=R_{n}(t)-\frac{R_{n}(x)}{W(x)}W(t)
  </annotation>
 </semantics>
</math>

</p>

<p>and set up an auxiliary function:</p>

<p>

<math display="block" id="Polynomial_interpolation:42">
 <semantics>
  <mrow>
   <mrow>
    <mi>W</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">‚àè</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>n</mi>
    </munderover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>u</mi>
      <mo>-</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>W</ci>
     <ci>u</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">product</csymbol>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>u</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W(u)=\prod_{i=0}^{n}(u-x_{i})
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="inline" id="Polynomial_interpolation:43">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

</p>

<p>Since <mtpl></mtpl> are roots of 

<math display="inline" id="Polynomial_interpolation:44">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{n}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Polynomial_interpolation:45">
 <semantics>
  <mi>Y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y
  </annotation>
 </semantics>
</math>

, we have <mtpl> <em>Y</em>(<em>x<sub>i</sub></em>) {{=}} 0}}</mtpl>, which means 

<math display="inline" id="Polynomial_interpolation:46">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>+</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n+2
  </annotation>
 </semantics>
</math>


 has 

<math display="inline" id="Polynomial_interpolation:47">
 <semantics>
  <mrow>
   <msup>
    <mi>Y</mi>
    <mo>‚Ä≤</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Y</ci>
     <ci>normal-‚Ä≤</ci>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y^{\prime}(t)
  </annotation>
 </semantics>
</math>

 roots. From <a href="Rolle's_theorem" title="wikilink">Rolle's theorem</a>, 

<math display="inline" id="Polynomial_interpolation:48">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n+1
  </annotation>
 </semantics>
</math>

 has 

<math display="inline" id="Polynomial_interpolation:49">
 <semantics>
  <mrow>
   <msup>
    <mi>Y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Y</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y^{(n+1)}(t)
  </annotation>
 </semantics>
</math>

 roots, then 

<math display="inline" id="Polynomial_interpolation:50">
 <semantics>
  <mi>Œæ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œæ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Œæ
  </annotation>
 </semantics>
</math>

 has one root 

<math display="inline" id="Polynomial_interpolation:51">
 <semantics>
  <mi>Œæ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œæ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Œæ
  </annotation>
 </semantics>
</math>


, where 

<math display="inline" id="Polynomial_interpolation:52">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 is in the interval 

<math display="block" id="Polynomial_interpolation:53">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>Y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msubsup>
      <mi>R</mi>
      <mi>n</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mpadded width="+5pt">
      <mfrac>
       <mrow>
        <msub>
         <mi>R</mi>
         <mi>n</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mi>W</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
     </mpadded>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Y</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <ci>n</ci>
        </apply>
        <ci>x</ci>
       </apply>
       <apply>
        <times></times>
        <ci>W</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <factorial></factorial>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y^{(n+1)}(t)=R_{n}^{(n+1)}(t)-\frac{R_{n}(x)}{W(x)}\ (n+1)!
  </annotation>
 </semantics>
</math>

.</p>

<p>So we can get</p>

<p>

<math display="inline" id="Polynomial_interpolation:54">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>n</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{n}(x)
  </annotation>
 </semantics>
</math>

</p>

<p>Since 

<math display="inline" id="Polynomial_interpolation:55">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is a polynomial of degree at most 

<math display="block" id="Polynomial_interpolation:56">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>R</mi>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{n}^{(n+1)}(t)=f^{(n+1)}(t)
  </annotation>
 </semantics>
</math>

, then</p>

<p>

<math display="block" id="Polynomial_interpolation:57">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>Y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mpadded width="+5pt">
      <mfrac>
       <mrow>
        <msub>
         <mi>R</mi>
         <mi>n</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mi>W</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
     </mpadded>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Y</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>f</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <ci>n</ci>
        </apply>
        <ci>x</ci>
       </apply>
       <apply>
        <times></times>
        <ci>W</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <factorial></factorial>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y^{(n+1)}(t)=f^{(n+1)}(t)-\frac{R_{n}(x)}{W(x)}\ (n+1)!
  </annotation>
 </semantics>
</math>

</p>

<p>Thus</p>

<p>

<math display="inline" id="Polynomial_interpolation:58">
 <semantics>
  <mi>Œæ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œæ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Œæ
  </annotation>
 </semantics>
</math>

</p>

<p>Since 

<math display="inline" id="Polynomial_interpolation:59">
 <semantics>
  <mrow>
   <msup>
    <mi>Y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Y</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y^{(n+1)}(t)
  </annotation>
 </semantics>
</math>

 is the root of 

<math display="block" id="Polynomial_interpolation:60">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>Y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Œæ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>Œæ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mpadded width="+5pt">
      <mfrac>
       <mrow>
        <msub>
         <mi>R</mi>
         <mi>n</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mi>W</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
     </mpadded>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Y</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>Œæ</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>Œæ</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>R</ci>
          <ci>n</ci>
         </apply>
         <ci>x</ci>
        </apply>
        <apply>
         <times></times>
         <ci>W</ci>
         <ci>x</ci>
        </apply>
       </apply>
       <apply>
        <factorial></factorial>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y^{(n+1)}(\xi)=f^{(n+1)}(\xi)-\frac{R_{n}(x)}{W(x)}\ (n+1)!=0
  </annotation>
 </semantics>
</math>

, so</p>

<p>

<math display="block" id="Polynomial_interpolation:61">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>R</mi>
     <mi>n</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>p</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <msup>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>Œæ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">‚àè</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi>n</mi>
     </munderover>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>n</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>n</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <apply>
          <plus></plus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>Œæ</ci>
       </apply>
       <apply>
        <factorial></factorial>
        <apply>
         <plus></plus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <csymbol cd="latexml">product</csymbol>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{n}(x)=f(x)-p_{n}(x)=\frac{f^{(n+1)}(\xi)}{(n+1)!}\prod_{i=0}^{n}(x-x_{i})
  </annotation>
 </semantics>
</math>

</p>

<p>Therefore</p>

<p>

<math display="inline" id="Polynomial_interpolation:62">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi>i</mi>
     <mi>h</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>h</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}=x_{0}+ih
  </annotation>
 </semantics>
</math>

.</p>

<p>Thus the remainder term in the Lagrange form of the <a href="Taylor's_theorem" title="wikilink">Taylor theorem</a> is a special case of interpolation error when all interpolation nodes <mtpl></mtpl> are identical.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>In the case of equally spaced interpolation nodes 

<math display="inline" id="Polynomial_interpolation:63">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msup>
    <mi>h</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>h</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (h^{n+1})
  </annotation>
 </semantics>
</math>

, it follows that the interpolation error is O

<math display="inline" id="Polynomial_interpolation:64">
 <semantics>
  <mrow>
   <msup>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Œæ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>f</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>Œæ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{(n+1)}(\xi)
  </annotation>
 </semantics>
</math>

. However, this assumes that 

<math display="inline" id="Polynomial_interpolation:65">
 <semantics>
  <msup>
   <mi>h</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>h</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h^{n+1}
  </annotation>
 </semantics>
</math>

 is dominated by 

<math display="inline" id="Polynomial_interpolation:66">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Œæ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msup>
     <mi>h</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
   <mo>‚â™</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">much-less-than</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>Œæ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>h</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{(n+1)}(\xi)h^{n+1}<<1
  </annotation>
 </semantics>
</math>


, i.e. 

<math display="inline" id="Polynomial_interpolation:67">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">‚Üí</mi>
   <mi mathvariant="normal">‚àû</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-‚Üí</ci>
    <ci>normal-‚àû</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n‚Üí‚àû
  </annotation>
 </semantics>
</math>

. In several cases, this is not true and the error actually increases as 

<math display="block" id="Polynomial_interpolation:68">
 <semantics>
  <mrow>
   <mrow>
    <mo>|</mo>
    <mrow>
     <mo largeop="true" movablelimits="false" symmetric="true">‚àè</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>|</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <apply>
     <csymbol cd="latexml">product</csymbol>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left|\prod(x-x_{i})\right|,
  </annotation>
 </semantics>
</math>

 (see <a href="Runge's_phenomenon" title="wikilink">Runge's phenomenon</a>). That question is treated in the <a href="#Convergence_properties" title="wikilink">section <em>Convergence properties</em></a>.</p>

<p>The above error bound suggests choosing the interpolation points <mtpl></mtpl> such that the product</p>

<p>

<math display="block" id="Polynomial_interpolation:69">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>‚à•</mo>
     <mrow>
      <mi>f</mi>
      <mo>-</mo>
      <mrow>
       <mi>X</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>f</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>‚à•</mo>
    </mrow>
    <mo>‚â§</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>L</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>‚à•</mo>
      <mrow>
       <mi>f</mi>
       <mo>-</mo>
       <msup>
        <mi>p</mi>
        <mo>*</mo>
       </msup>
      </mrow>
      <mo>‚à•</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <minus></minus>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <ci>L</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>p</ci>
        <times></times>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|f-X(f)\|\leq(L+1)\|f-p^{*}\|.
  </annotation>
 </semantics>
</math>

</p>

<p>is as small as possible. The <a href="Chebyshev_nodes" title="wikilink">Chebyshev nodes</a> achieve this.</p>
<h2 id="lebesgue-constants">Lebesgue constants</h2>
<dl>
<dd><em>See the main article: <a href="Lebesgue_constant_(interpolation)" title="wikilink">Lebesgue constant</a>.</em>
</dd>
</dl>

<p>We fix the interpolation nodes <em>x</em><sub>0</sub>, ..., <em>x</em><sub><em>n</em></sub> and an interval [<em>a</em>, <em>b</em>] containing all the interpolation nodes. The process of interpolation maps the function <em>f</em> to a polynomial <em>p</em>. This defines a mapping <em>X</em> from the space <em>C</em>([<em>a</em>, <em>b</em>]) of all continuous functions on [<em>a</em>, <em>b</em>] to itself. The map <em>X</em> is linear and it is a <a href="projection_(linear_algebra)" title="wikilink">projection</a> on the subspace Œ†<sub><em>n</em></sub> of polynomials of degree <em>n</em> or less.</p>

<p>The Lebesgue constant <em>L</em> is defined as the <a href="operator_norm" title="wikilink">operator norm</a> of <em>X</em>. One has (a special case of <a href="Lebesgue's_lemma" title="wikilink">Lebesgue's lemma</a>):</p>

<p>

<math display="block" id="Polynomial_interpolation:70">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>‚â§</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mn>2</mn>
      <mi>œÄ</mi>
     </mfrac>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>1.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>L</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">2</cn>
       <ci>œÄ</ci>
      </apply>
      <apply>
       <log></log>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <cn type="float">1.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\leq\frac{2}{\pi}\log(n+1)+1.
  </annotation>
 </semantics>
</math>

</p>

<p>In other words, the interpolation polynomial is at most a factor (<em>L</em>¬†+¬†1) worse than the best possible approximation. This suggests that we look for a set of interpolation nodes that makes <em>L</em> small. In particular, we have for <a href="Chebyshev_nodes" title="wikilink">Chebyshev nodes</a>:</p>

<p>

<math display="inline" id="Polynomial_interpolation:71">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">‚Üí</mi>
   <mi mathvariant="normal">‚àû</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-‚Üí</ci>
    <ci>normal-‚àû</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n‚Üí‚àû
  </annotation>
 </semantics>
</math>


</p>

<p>We conclude again that Chebyshev nodes are a very good choice for polynomial interpolation, as the growth in <em>n</em> is exponential for equidistant nodes. However, those nodes are not optimal.</p>
<h2 id="convergence-properties">Convergence properties</h2>

<p>It is natural to ask, for which classes of functions and for which interpolation nodes the sequence of interpolating polynomials converges to the interpolated function as 

<math display="inline" id="Polynomial_interpolation:72">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">‚àí</mi>
    <mn>5</mn>
   </mrow>
   <mo>,</mo>
   <mn>55</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>normal-‚àí</ci>
     <cn type="integer">5</cn>
    </apply>
    <cn type="integer">55</cn>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ‚àí5,55
  </annotation>
 </semantics>
</math>

? Convergence may be understood in different ways, e.g. pointwise, uniform or in some integral norm.</p>

<p>The situation is rather bad for equidistant nodes, in that uniform convergence is not even guaranteed for infinitely differentiable functions. One <a href="Runge's_phenomenon" title="wikilink">classical example, due to Carl Runge</a>, is the function <em>f</em>(<em>x</em>) = 1 / (1 + <em>x</em><sup>2</sup>) on the interval 

<math display="inline" id="Polynomial_interpolation:73">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi mathvariant="normal">‚Üí</mi>
   <mi mathvariant="normal">‚àû</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>normal-‚Üí</ci>
    <ci>normal-‚àû</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n‚Üí‚àû
  </annotation>
 </semantics>
</math>

. The interpolation error <mtpl>¬†<em>f</em> ‚àí <em>p<sub>n</sub></em>{{!!}}<sub>‚àû</sub>}}</mtpl> grows without bound as 

<math display="inline" id="Polynomial_interpolation:74">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">‚àí</mi>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mn>11</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>normal-‚àí</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">11</cn>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ‚àí1,11
  </annotation>
 </semantics>
</math>

. Another example is the function <em>f</em>(<em>x</em>) = |<em>x</em>| on the interval 

<math display="inline" id="Polynomial_interpolation:75">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>n</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{n}(x)
  </annotation>
 </semantics>
</math>

, for which the interpolating polynomials do not even converge pointwise except at the three points <em>x</em> = ¬±1, 0.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>One might think that better convergence properties may be obtained by choosing different interpolation nodes. The following result seems to give a rather encouraging answer:</p>
<dl>
<dd><strong>Theorem.</strong> For any function <em>f</em>(<em>x</em>) continuous on an interval [<em>a</em>,<em>b</em>] there exists a table of nodes for which the sequence of interpolating polynomials 

<math display="inline" id="Polynomial_interpolation:76">
 <semantics>
  <mrow>
   <msubsup>
    <mi>p</mi>
    <mi>n</mi>
    <mo>*</mo>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <times></times>
     </apply>
     <ci>n</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{*}_{n}(x)
  </annotation>
 </semantics>
</math>


 converges to <em>f</em>(<em>x</em>) uniformly on [<em>a</em>,<em>b</em>].
</dd>
</dl>

<p><strong>Proof</strong>. It's clear that the sequence of polynomials of best approximation 

<math display="inline" id="Polynomial_interpolation:77">
 <semantics>
  <mrow>
   <msubsup>
    <mi>p</mi>
    <mi>n</mi>
    <mo>*</mo>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <times></times>
     </apply>
     <ci>n</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{*}_{n}(x)
  </annotation>
 </semantics>
</math>

 converges to <em>f</em>(<em>x</em>) uniformly (due to <a href="Weierstrass_approximation_theorem" title="wikilink">Weierstrass approximation theorem</a>). Now we have only to show that each 

<math display="inline" id="Polynomial_interpolation:78">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n+1
  </annotation>
 </semantics>
</math>

 may be obtained by means of interpolation on certain nodes. But this is true due to a special property of polynomials of best approximation known from the <a href="Chebyshev_alternation_theorem" title="wikilink">Chebyshev alternation theorem</a>. Specifically, we know that such polynomials should intersect <em>f</em>(<em>x</em>) at least 

<math display="block" id="Polynomial_interpolation:79">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <munder>
       <mo movablelimits="false">lim</mo>
       <mrow>
        <mi>n</mi>
        <mo>‚Üí</mo>
        <mi mathvariant="normal">‚àû</mi>
       </mrow>
      </munder>
      <mrow>
       <msub>
        <mi>X</mi>
        <mi>n</mi>
       </msub>
       <mi>f</mi>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mi>f</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mtext>for every</mtext>
      <mi>f</mi>
     </mrow>
     <mo>‚àà</mo>
     <mrow>
      <mi>C</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo stretchy="false">[</mo>
        <mi>a</mi>
        <mo>,</mo>
        <mi>b</mi>
        <mo stretchy="false">]</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <limit></limit>
       <apply>
        <ci>normal-‚Üí</ci>
        <ci>n</ci>
        <infinity></infinity>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <ci>n</ci>
       </apply>
       <ci>f</ci>
      </apply>
     </apply>
     <ci>f</ci>
    </apply>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <mtext>for every</mtext>
      <ci>f</ci>
     </apply>
     <apply>
      <times></times>
      <ci>C</ci>
      <interval closure="closed">
       <ci>a</ci>
       <ci>b</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lim_{n\to\infty}X_{n}f=f,\text{ for every }f\in C([a,b]).
  </annotation>
 </semantics>
</math>

 times. Choosing the points of intersection as interpolation nodes we obtain the interpolating polynomial coinciding with the best approximation polynomial.</p>

<p>The defect of this method, however, is that interpolation nodes should be calculated anew for each new function <em>f</em>(<em>x</em>), but the algorithm is hard to be implemented numerically. Does there exist a single table of nodes for which the sequence of interpolating polynomials converge to any continuous function <em>f</em>(<em>x</em>)? The answer is unfortunately negative:</p>
<dl>
<dd><strong>Theorem.</strong> For any table of nodes there is a continuous function <em>f</em>(<em>x</em>) on an interval [<em>a</em>, <em>b</em>] for which the sequence of interpolating polynomials diverges on [<em>a</em>,<em>b</em>].<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a>
</dd>
</dl>

<p>The proof essentially uses the lower bound estimation of the Lebesgue constant, which we defined above to be the operator norm of <em>X</em><sub><em>n</em></sub> (where <em>X</em><sub><em>n</em></sub> is the projection operator on Œ†<sub><em>n</em></sub>). Now we seek a table of nodes for which</p>

<p>

<math display="block" id="Polynomial_interpolation:80">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>‚à•</mo>
     <msub>
      <mi>X</mi>
      <mi>n</mi>
     </msub>
     <mo>‚à•</mo>
    </mrow>
    <mo>‚â•</mo>
    <mrow>
     <mrow>
      <mstyle displaystyle="false">
       <mfrac>
        <mn>2</mn>
        <mi>œÄ</mi>
       </mfrac>
      </mstyle>
      <mrow>
       <mi>log</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mi>C</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">2</cn>
       <ci>œÄ</ci>
      </apply>
      <apply>
       <log></log>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>C</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|X_{n}\|\geq\tfrac{2}{\pi}\log(n+1)+C.
  </annotation>
 </semantics>
</math>

</p>

<p>Due to the <a href="Banach‚ÄìSteinhaus_theorem" title="wikilink">Banach‚ÄìSteinhaus theorem</a>, this is only possible when norms of <em>X</em><sub><em>n</em></sub> are uniformly bounded, which cannot be true since we know that</p>

<p>

<math display="inline" id="Polynomial_interpolation:81">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">‚àí</mi>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mn>11</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>normal-‚àí</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">11</cn>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ‚àí1,11
  </annotation>
 </semantics>
</math>


</p>

<p>For example, if equidistant points are chosen as interpolation nodes, the function from <a href="Runge's_phenomenon" title="wikilink">Runge's phenomenon</a> demonstrates divergence of such interpolation. Note that this function is not only continuous but even infinitely times differentiable on 

<math display="inline" id="Polynomial_interpolation:82">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">‚àí</mi>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mn>11</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>normal-‚àí</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">11</cn>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ‚àí1,11
  </annotation>
 </semantics>
</math>

. For better <a href="Chebyshev_nodes" title="wikilink">Chebyshev nodes</a>, however, such an example is much harder to find due to the following result:</p>
<dl>
<dd><strong>Theorem.</strong> For every <a href="absolute_continuity" title="wikilink">absolutely continuous</a> function on 

<math display="inline" id="Polynomial_interpolation:83">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 the sequence of interpolating polynomials constructed on Chebyshev nodes converges to¬†<em>f</em>(<em>x</em>) uniformly.
</dd>
</dl>
<h2 id="related-concepts">Related concepts</h2>

<p><a href="Runge's_phenomenon" title="wikilink">Runge's phenomenon</a> shows that for high values of <span class="LaTeX">$n$</span>, the interpolation polynomial may oscillate wildly between the data points. This problem is commonly resolved by the use of <a href="spline_interpolation" title="wikilink">spline interpolation</a>. Here, the interpolant is not a polynomial but a <a href="spline_(mathematics)" title="wikilink">spline</a>: a chain of several polynomials of a lower degree.</p>

<p>Interpolation of <a href="periodic_function" title="wikilink">periodic functions</a> by <a href="harmonic_analysis" title="wikilink">harmonic</a> functions is accomplished by <a href="Fourier_transform" title="wikilink">Fourier transform</a>. This can be seen as a form of polynomial interpolation with harmonic base functions, see <a href="trigonometric_interpolation" title="wikilink">trigonometric interpolation</a> and <a href="trigonometric_polynomial" title="wikilink">trigonometric polynomial</a>.</p>

<p><a href="Hermite_interpolation" title="wikilink">Hermite interpolation</a> problems are those where not only the values of the polynomial <em>p</em> at the nodes are given, but also all derivatives up to a given order. This turns out to be equivalent to a system of simultaneous polynomial congruences, and may be solved by means of the <a href="Chinese_remainder_theorem" title="wikilink">Chinese remainder theorem</a> for polynomials. <a href="Birkhoff_interpolation" title="wikilink">Birkhoff interpolation</a> is a further generalization where only derivatives of some orders are prescribed, not necessarily all orders from 0 to a <em>k</em>.</p>

<p><a href="Collocation_method" title="wikilink">Collocation methods</a> for the solution of differential and integral equations are based on polynomial interpolation.</p>

<p>The technique of <a href="rational_function_modeling" title="wikilink">rational function modeling</a> is a generalization that considers ratios of polynomial functions.</p>

<p>At last, <a href="multivariate_interpolation" title="wikilink">multivariate interpolation</a> for higher dimensions.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Newton_series" title="wikilink">Newton series</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li><a href="http://www.alglib.net/interpolation/polynomial.php">ALGLIB</a> has an implementations in C++ / C# / VBA / Pascal.</li>
<li><a href="http://www.gnu.org/software/gsl/">GSL</a> has a polynomial interpolation code in C</li>
<li><a href="http://demonstrations.wolfram.com/InterpolatingPolynomial/">Interpolating Polynomial</a> by <a href="Stephen_Wolfram" title="wikilink">Stephen Wolfram</a>, the <a href="Wolfram_Demonstrations_Project" title="wikilink">Wolfram Demonstrations Project</a>.</li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Interpolation" title="wikilink">Category:Interpolation</a> <a class="uri" href="Category:Polynomials" title="wikilink">Category:Polynomials</a> <a href="Category:Articles_containing_proofs" title="wikilink">Category:Articles containing proofs</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">‚Ü©</a></li>
<li id="fn2"><a href="#fnref2">‚Ü©</a></li>
<li id="fn3"><a href="#fnref3">‚Ü©</a></li>
<li id="fn4"><a href="#fnref4">‚Ü©</a></li>
<li id="fn5">R.Bevilaqua, D. Bini, M.Capovani and O. Menchi (2003). <em>Appunti di Calcolo Numerico</em>. Chapter 5, p. 89. Servizio Editoriale Universitario Pisa - Azienda Regionale Diritto allo Studio Universitario.<a href="#fnref5">‚Ü©</a></li>
<li id="fn6"><a href="#fnref6">‚Ü©</a></li>
<li id="fn7"> attributes the last example to .<a href="#fnref7">‚Ü©</a></li>
<li id="fn8"> attributes this theorem to .<a href="#fnref8">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
