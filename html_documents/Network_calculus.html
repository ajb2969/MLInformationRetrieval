<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="217">Network calculus</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Network calculus</h1>
<hr/>

<p><strong>Network calculus</strong> is "a set of mathematical results which give insights into man-made systems such as <a href="concurrent_program" title="wikilink">concurrent programs</a>, <a href="digital_circuit" title="wikilink">digital circuits</a> and <a href="communication_network" title="wikilink">communication networks</a>."<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Network calculus gives a theoretical framework for analysing performance guarantees in <a href="computer_network" title="wikilink">computer networks</a>. As traffic flows through a network it is subject to <a href="Constraint_(mathematics)" title="wikilink">constraints</a> imposed by the system components, for example:</p>
<ul>
<li><a href="data_link" title="wikilink">link</a> capacity</li>
<li>traffic shapers (<a href="leaky_bucket" title="wikilink">leaky buckets</a>)</li>
<li><a href="congestion_control" title="wikilink">congestion control</a></li>
<li>background traffic</li>
</ul>

<p>These constraints can be expressed and analysed with network calculus methods. Constraint curves can be <em>combined</em> using <a class="uri" href="convolution" title="wikilink">convolution</a> under <a href="min-plus_algebra" title="wikilink">min-plus algebra</a>. Network calculus can also be used to express traffic arrival and departure functions as well as service curves.</p>

<p>The calculus uses "alternate algebras ... to transform complex non-linear network systems into analytically tractable linear systems."<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Currently, there exists two branches in network calculus: one handling deterministic bounded, and one handling stochastic bounds .<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> This article is only about deterministic network calculus.</p>
<h2 id="system-modelling">System modelling</h2>
<h3 id="modelling-flow-and-server">Modelling flow and server</h3>

<p>In network calculus, a flow is modelled as cumulative functions 

<math display="inline" id="Network_calculus:0">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Network_calculus:1">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(t)
  </annotation>
 </semantics>
</math>

 represents the amount of data (number of bits for example) send by the flow in the interval 

<math display="inline" id="Network_calculus:2">
 <semantics>
  <mrow>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <cn type="integer">0</cn>
     <ci>normal-,</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0,t))
  </annotation>
 </semantics>
</math>

. Such functions are non-negative and non-decreasing. The time domain is often the set of non negative reals.</p>
<figure><b>(Figure)</b>
<figcaption>Arrival and departure curve at ingress and egress of a server.</figcaption>
</figure>

<p>

<math display="inline" id="Network_calculus:3">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi>ℝ</mi>
     <mo>+</mo>
    </msup>
    <mo>→</mo>
    <msup>
     <mi>ℝ</mi>
     <mo>+</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>A</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <plus></plus>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <plus></plus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A:\mathbb{R}^{+}\rightarrow\mathbb{R}^{+}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Network_calculus:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo>∀</mo>
      <mi>u</mi>
     </mrow>
     <mo>,</mo>
     <mi>t</mi>
    </mrow>
    <mo>∈</mo>
    <msup>
     <mi>ℝ</mi>
     <mo>+</mo>
    </msup>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>u</mi>
    <mo><</mo>
    <mi>t</mi>
    <mo>⟹</mo>
    <mrow>
     <mi>A</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mi>A</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <in></in>
     <list>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <ci>u</ci>
      </apply>
      <ci>t</ci>
     </list>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <plus></plus>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <lt></lt>
      <ci>u</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <implies></implies>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>u</ci>
      </apply>
     </apply>
     <apply>
      <leq></leq>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall u,t\in\mathbb{R}^{+}:u<t\implies A(u)\leq A(t)
  </annotation>
 </semantics>
</math>

</p>

<p>A server can be a link, a scheduler, a traffic shaper, or a whole network. It is simply modelled as a relation between some arrival cumulative curve 

<math display="inline" id="Network_calculus:5">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and some departure cumulative curve 

<math display="inline" id="Network_calculus:6">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

. It is required that 

<math display="inline" id="Network_calculus:7">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mi mathvariant="normal">≥</mi>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>normal-≥</ci>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A≥D
  </annotation>
 </semantics>
</math>

, to model the fact that the departure of some data can not occur before its arrival.</p>
<h3 id="modelling-backlog-and-delay">Modelling backlog and delay</h3>

<p>Given some arrival and departure curve 

<math display="inline" id="Network_calculus:8">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Network_calculus:9">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

, the <em>backlog</em> at any instant 

<math display="inline" id="Network_calculus:10">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, denoted 

<math display="inline" id="Network_calculus:11">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>b</ci>
    <vector>
     <ci>A</ci>
     <ci>D</ci>
     <ci>t</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b(A,D,t)
  </annotation>
 </semantics>
</math>

 can be defined as the difference between 

<math display="inline" id="Network_calculus:12">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Network_calculus:13">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

. The delay at 

<math display="inline" id="Network_calculus:14">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Network_calculus:15">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <vector>
     <ci>A</ci>
     <ci>D</ci>
     <ci>t</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(A,D,t)
  </annotation>
 </semantics>
</math>

 is defined as the minimal amount of time such that the departure function reached the arrival function. When considering the whole flows, the <a class="uri" href="supremum" title="wikilink">supremum</a> of these values is used.</p>

<p><a href="File:Horizontal_and_vertical_deviation.svg" title="wikilink">upright=3|center|thumb|Horizontal and vertical deviation between arrival and departure cumulative curves</a></p>

<p>

<math display="inline" id="Network_calculus:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>b</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>,</mo>
     <mi>D</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>D</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>b</ci>
     <vector>
      <ci>A</ci>
      <ci>D</ci>
      <ci>t</ci>
     </vector>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>D</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b(A,D,t):=A(t)-D(t)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Network_calculus:17">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>:=</mo>
   <mo>inf</mo>
   <mrow>
    <mo>{</mo>
    <mi>d</mi>
    <mo>∈</mo>
    <mpadded width="+3.3pt">
     <msup>
      <mi>ℝ</mi>
      <mo>+</mo>
     </msup>
    </mpadded>
    <mi>s</mi>
    <mo>.</mo>
    <mi>t</mi>
    <mo rspace="5.8pt">.</mo>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo>+</mo>
     <mi>d</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>≥</mo>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">d</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">assign</csymbol>
    <csymbol cd="latexml">infimum</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">d</csymbol>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℝ</ci>
      <plus></plus>
     </apply>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">D</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <plus></plus>
      <csymbol cd="unknown">d</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <geq></geq>
     <csymbol cd="unknown">A</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(A,D,t):=\inf\left\{d\in\mathbb{R}^{+}~{}s.t.~{}D(t+d)\geq A(t)\right\}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Network_calculus:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>b</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>,</mo>
     <mi>D</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <msub>
     <mo>sup</mo>
     <mrow>
      <mi>t</mi>
      <mo>≥</mo>
      <mn>0</mn>
     </mrow>
    </msub>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mrow>
       <mi>A</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>D</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>b</ci>
     <interval closure="open">
      <ci>A</ci>
      <ci>D</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">supremum</csymbol>
      <apply>
       <geq></geq>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <set>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <times></times>
        <ci>D</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b(A,D):=\sup_{t\geq 0}\left\{A(t)-D(t)\right\}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Network_calculus:19">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>:=</mo>
   <msub>
    <mo>sup</mo>
    <mrow>
     <mi>t</mi>
     <mo>≥</mo>
     <mn>0</mn>
    </mrow>
   </msub>
   <mrow>
    <mo>{</mo>
    <mo>inf</mo>
    <mrow>
     <mo>{</mo>
     <mi>d</mi>
     <mo>∈</mo>
     <mpadded width="+3.3pt">
      <msup>
       <mi>ℝ</mi>
       <mo>+</mo>
      </msup>
     </mpadded>
     <mi>s</mi>
     <mo>.</mo>
     <mi>t</mi>
     <mo rspace="5.8pt">.</mo>
     <mi>D</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo>+</mo>
      <mi>d</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>≥</mo>
     <mi>A</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>}</mo>
    </mrow>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">d</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">supremum</csymbol>
     <apply>
      <geq></geq>
      <ci>t</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="latexml">infimum</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <csymbol cd="unknown">d</csymbol>
      <in></in>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ℝ</ci>
       <plus></plus>
      </apply>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-.</ci>
      <csymbol cd="unknown">D</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">t</csymbol>
       <plus></plus>
       <csymbol cd="unknown">d</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <geq></geq>
      <csymbol cd="unknown">A</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">t</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(A,D):=\sup_{t\geq 0}\left\{\inf\left\{d\in\mathbb{R}^{+}~{}s.t.~{}D(t+d)\geq
A%
(t)\right\}\right\}
  </annotation>
 </semantics>
</math>

</p>

<p>In general, the flows are not exactly known, and only some constraints on flows and servers are known (like the maximal number of packet sent on some period, the maximal size of packets, the minimal link bandwidth). The aim of network calculus is to compute upper bounds on delay and backlog, based on these constraints. To do so, network calculus uses the min-plus algebra.</p>
<h2 id="min-plus-algebra">Min-plus algebra</h2>

<p>In filter theory respectively linear systems theory the <a class="uri" href="convolution" title="wikilink">convolution</a> of two functions 

<math display="inline" id="Network_calculus:20">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Network_calculus:21">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 is defined as</p>

<p>

<math display="inline" id="Network_calculus:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mo>∗</mo>
      <mi>g</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mn>0</mn>
     <mi>τ</mi>
    </msubsup>
    <mrow>
     <mrow>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>τ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⋅</mo>
      <mi>g</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mi>τ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>τ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <apply>
      <ci>normal-∗</ci>
      <ci>f</ci>
      <ci>g</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <ci>τ</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>τ</ci>
       </apply>
       <ci>g</ci>
      </apply>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <ci>τ</ci>
      </apply>
      <ci>d</ci>
      <ci>τ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f\ast g)(t):=\int_{0}^{\tau}f(\tau)\cdot g(t-\tau)d\tau
  </annotation>
 </semantics>
</math>

</p>

<p>In <strong>min-plus algebra</strong> the <em>sum</em> is replaced by the minimum respectively <em><a class="uri" href="infimum" title="wikilink">infimum</a></em> operator and the <em>product</em> is replaced by the <em>sum</em>. So the min-plus convolution of two functions 

<math display="inline" id="Network_calculus:23">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Network_calculus:24">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 becomes</p>

<p>

<math display="inline" id="Network_calculus:25">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mo>⊗</mo>
      <mi>g</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <msub>
     <mo>inf</mo>
     <mrow>
      <mn>0</mn>
      <mo>≤</mo>
      <mi>τ</mi>
      <mo>≤</mo>
      <mi>t</mi>
     </mrow>
    </msub>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>τ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>g</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>t</mi>
         <mo>-</mo>
         <mi>τ</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>f</ci>
      <ci>g</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">infimum</csymbol>
      <apply>
       <and></and>
       <apply>
        <leq></leq>
        <cn type="integer">0</cn>
        <ci>τ</ci>
       </apply>
       <apply>
        <leq></leq>
        <share href="#.cmml">
        </share>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <set>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>τ</ci>
       </apply>
       <apply>
        <times></times>
        <ci>g</ci>
        <apply>
         <minus></minus>
         <ci>t</ci>
         <ci>τ</ci>
        </apply>
       </apply>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f\otimes g)(t):=\inf_{0\leq\tau\leq t}\left\{f(\tau)+g(t-\tau)\right\}
  </annotation>
 </semantics>
</math>

</p>

<p>e.g. see the definition of service curves. Convolution and min-plus convolution share many algebraic properties. In particular both are commutative and associative.</p>

<p>A so-called min-plus de-convolution operation is defined as</p>

<p>

<math display="inline" id="Network_calculus:26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mo>⊘</mo>
      <mi>g</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <msub>
     <mo>sup</mo>
     <mrow>
      <mi>τ</mi>
      <mo>≥</mo>
      <mn>0</mn>
     </mrow>
    </msub>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>t</mi>
         <mo>+</mo>
         <mi>τ</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>g</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>τ</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⊘</ci>
      <ci>f</ci>
      <ci>g</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">supremum</csymbol>
      <apply>
       <geq></geq>
       <ci>τ</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <set>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <plus></plus>
         <ci>t</ci>
         <ci>τ</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>g</ci>
        <ci>τ</ci>
       </apply>
      </apply>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (f\oslash g)(t):=\sup_{\tau\geq 0}\left\{f(t+\tau)-g(\tau)\right\}
  </annotation>
 </semantics>
</math>

</p>

<p>e.g. as used in the definition of traffic envelopes.</p>

<p>The vertical and horizontal deviations can be expressed in terms of min-plus operators.</p>

<p>

<math display="inline" id="Network_calculus:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>b</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo>,</mo>
     <mi>g</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>f</mi>
      <mo>⊘</mo>
      <mi>g</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>b</ci>
     <interval closure="open">
      <ci>f</ci>
      <ci>g</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-⊘</ci>
      <ci>f</ci>
      <ci>g</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b(f,g)=(f\oslash g)(0)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Network_calculus:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo>,</mo>
     <mi>g</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>inf</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>w</mi>
     <mo>:</mo>
     <mrow>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>f</mi>
         <mo>⊘</mo>
         <mi>g</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo>-</mo>
         <mi>w</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>≤</mo>
      <mn>0</mn>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>d</ci>
     <interval closure="open">
      <ci>f</ci>
      <ci>g</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">infimum</csymbol>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <ci>w</ci>
      <apply>
       <leq></leq>
       <apply>
        <times></times>
        <apply>
         <ci>normal-⊘</ci>
         <ci>f</ci>
         <ci>g</ci>
        </apply>
        <apply>
         <minus></minus>
         <ci>w</ci>
        </apply>
       </apply>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(f,g)=\inf\{w:(f\oslash g)(-w)\leq 0\}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="traffic-envelopes">Traffic envelopes</h2>

<p>Cumulative curves are real behaviours, unknown at design time. What is known is some constraint. Network calculus uses the notion of traffic envelope, also known as arrival curves.</p>

<p>A cumulative function 

<math display="inline" id="Network_calculus:29">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is said to conform to an envelope (or arrival curve) 

<math display="inline" id="Network_calculus:30">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

, iff for all 

<math display="inline" id="Network_calculus:31">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 it holds that</p>

<p>

<math display="inline" id="Network_calculus:32">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <msub>
      <mo>sup</mo>
      <mrow>
       <mi>τ</mi>
       <mo>≥</mo>
       <mn>0</mn>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mrow>
        <mi>A</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>t</mi>
          <mo>+</mo>
          <mi>τ</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>A</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>τ</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mo>⊘</mo>
       <mi>A</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <geq></geq>
     <apply>
      <times></times>
      <ci>E</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">supremum</csymbol>
       <apply>
        <geq></geq>
        <ci>τ</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <set>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>A</ci>
         <apply>
          <plus></plus>
          <ci>t</ci>
          <ci>τ</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>A</ci>
         <ci>τ</ci>
        </apply>
       </apply>
      </set>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⊘</ci>
       <ci>A</ci>
       <ci>A</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(t)\geq\sup_{\tau\geq 0}\{A(t+\tau)-A(\tau)\}=(A\oslash A)(t).
  </annotation>
 </semantics>
</math>

</p>

<p>Two equivalent definitions can be given  

<math display="inline" id="Network_calculus:33">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>≤</mo>
   <mrow>
    <mi>A</mi>
    <mo>⊗</mo>
    <mi>E</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>A</ci>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>A</ci>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\leq A\otimes E
  </annotation>
 </semantics>
</math>

</p>

<p>Thus, 

<math display="inline" id="Network_calculus:34">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 places an upper constraint on flow 

<math display="inline" id="Network_calculus:35">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

. Such function 

<math display="inline" id="Network_calculus:36">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

 can be seen as an envelope that specifies an upper bound on the number of bits of flow seen in any interval of length 

<math display="inline" id="Network_calculus:37">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 starting at an arbitrary 

<math display="inline" id="Network_calculus:38">
 <semantics>
  <mi>τ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>τ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   τ
  </annotation>
 </semantics>
</math>

, cf. eq. ().</p>
<h2 id="service-curves">Service curves</h2>

<p>In order to provide performance guarantees to traffic flows it is necessary to specify some minimal performance of the server (depending on reservations in the network, or scheduling policy, etc.). Service curves provide a means of expressing resource availability. Several kinds of service curves exists, like weakly strict, variable capacity node, etc. See <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> for an overview.</p>
<h3 id="minimal-service">Minimal service</h3>

<p>Let 

<math display="inline" id="Network_calculus:39">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 be an arrival flow, arriving at the ingress of a server, and 

<math display="inline" id="Network_calculus:40">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 be the flow departing at the egress. The system is said to provide a <em>simple minimal service curve</em> 

<math display="inline" id="Network_calculus:41">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 to the pair 

<math display="inline" id="Network_calculus:42">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>A</mi>
   <mo>,</mo>
   <mi>B</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>A</ci>
    <ci>B</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A,B)
  </annotation>
 </semantics>
</math>

, if for all 

<math display="inline" id="Network_calculus:43">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 it holds that 

<math display="inline" id="Network_calculus:44">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>D</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mo>⊗</mo>
       <mi>S</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>A</ci>
      <ci>S</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(t)\geq(A\otimes S)(t).
  </annotation>
 </semantics>
</math>

</p>
<h3 id="strict-minimal-service">Strict minimal service</h3>

<p>Let 

<math display="inline" id="Network_calculus:45">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 be an arrival flow, arriving at the ingress of a server, and 

<math display="inline" id="Network_calculus:46">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 be the flow departing at the egress. A <em>backlog period</em> is an interval 

<math display="inline" id="Network_calculus:47">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 such that, on any 

<math display="inline" id="Network_calculus:48">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mi mathvariant="normal">∈</mi>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>normal-∈</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t∈I
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Network_calculus:49">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mrow>
    <mi>D</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>D</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(t)>D(t)
  </annotation>
 </semantics>
</math>

.</p>

<p>The system is said to provide a <em>strict minimal service curve</em> 

<math display="inline" id="Network_calculus:50">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 to the pair 

<math display="inline" id="Network_calculus:51">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>A</mi>
   <mo>,</mo>
   <mi>B</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>A</ci>
    <ci>B</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A,B)
  </annotation>
 </semantics>
</math>

 iff, 

<math display="inline" id="Network_calculus:52">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>s</mi>
    </mrow>
    <mo>,</mo>
    <mi>t</mi>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>ℝ</mi>
    <mo>+</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>s</ci>
     </apply>
     <ci>t</ci>
    </list>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℝ</ci>
     <plus></plus>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall s,t\in\mathbb{R}^{+}
  </annotation>
 </semantics>
</math>

, such that 

<math display="inline" id="Network_calculus:53">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>≤</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>s</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\leq t
  </annotation>
 </semantics>
</math>

, if 

<math display="inline" id="Network_calculus:54">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>s</mi>
   <mo>,</mo>
   <mi>t</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open-closed">
    <ci>s</ci>
    <ci>t</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s,t]
  </annotation>
 </semantics>
</math>

 is a backlog period, then 

<math display="inline" id="Network_calculus:55">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>D</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>D</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mi>s</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>D</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>D</ci>
      <ci>s</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <minus></minus>
      <ci>t</ci>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D(t)-D(s)\geq S(t-s)
  </annotation>
 </semantics>
</math>

.</p>

<p>If a server offers a strict minimal service of curve 

<math display="inline" id="Network_calculus:56">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, it also offers a simple minimal service of curve 

<math display="inline" id="Network_calculus:57">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="basic-results-performance-bounds-and-envelope-propagation">Basic results: Performance bounds and envelope propagation</h2>

<p>From traffic envelope and service curves, some bounds on the delay and backlog, and an envelope on the departure flow can be computed.</p>

<p>Let 

<math display="inline" id="Network_calculus:58">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 be an arrival flow, arriving at the ingress of a server, and 

<math display="inline" id="Network_calculus:59">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 be the flow departing at the egress. If the flow as a traffic envelope 

<math display="inline" id="Network_calculus:60">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

, and the server provides a minimal service of curve 

<math display="inline" id="Network_calculus:61">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, then the backlog and delay can be bounded:</p>

<p>

<math display="inline" id="Network_calculus:62">
 <semantics>
  <mrow>
   <mrow>
    <mi>b</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>,</mo>
     <mi>D</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>b</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>E</mi>
     <mo>,</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>b</ci>
     <interval closure="open">
      <ci>A</ci>
      <ci>D</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>b</ci>
     <interval closure="open">
      <ci>E</ci>
      <ci>S</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b(A,D)\leq b(E,S)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Network_calculus:63">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>,</mo>
     <mi>D</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>E</mi>
     <mo>,</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>d</ci>
     <interval closure="open">
      <ci>A</ci>
      <ci>D</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>d</ci>
     <interval closure="open">
      <ci>E</ci>
      <ci>S</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(A,D)\leq d(E,S)
  </annotation>
 </semantics>
</math>

</p>

<p>Moreover, the departure curve has envelope 

<math display="inline" id="Network_calculus:64">
 <semantics>
  <mrow>
   <msup>
    <mi>E</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mo>⊘</mo>
    <mi>S</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>E</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <ci>normal-⊘</ci>
     <ci>E</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E^{\prime}=E\oslash S
  </annotation>
 </semantics>
</math>

.</p>

<p>Moreover, these bounds are <em>tight</em> i.e. given some 

<math display="inline" id="Network_calculus:65">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Network_calculus:66">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, one may build an arrival and departure such that 

<math display="inline" id="Network_calculus:67">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>b</ci>
    <interval closure="open">
     <ci>A</ci>
     <ci>D</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b(A,D)
  </annotation>
 </semantics>
</math>

 = 

<math display="inline" id="Network_calculus:68">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo>,</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>b</ci>
    <interval closure="open">
     <ci>E</ci>
     <ci>S</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b(E,S)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Network_calculus:69">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>v</ci>
    <interval closure="open">
     <ci>A</ci>
     <ci>D</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v(A,D)
  </annotation>
 </semantics>
</math>

=

<math display="inline" id="Network_calculus:70">
 <semantics>
  <mrow>
   <mi>v</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo>,</mo>
    <mi>S</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>v</ci>
    <interval closure="open">
     <ci>E</ci>
     <ci>S</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v(E,S)
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="concatenation-pboo">Concatenation / PBOO</h2>

<p>Consider a sequence of two servers, when the output of the first one is the input of the second one. This sequence can be seen as a new server, build as the concatenation of the two others ones.</p>

<p>Then, if the first (resp. second) server servers offers a simple minimal service 

<math display="inline" id="Network_calculus:71">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{1}
  </annotation>
 </semantics>
</math>

 (resp. 

<math display="inline" id="Network_calculus:72">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{2}
  </annotation>
 </semantics>
</math>

), then, the concatenation of both offers a simple minimal service 

<math display="inline" id="Network_calculus:73">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mrow>
     <mi>e</mi>
     <mn>2</mn>
     <mi>e</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>S</mi>
     <mn>1</mn>
    </msub>
    <mo>⊗</mo>
    <msub>
     <mi>S</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <apply>
      <times></times>
      <ci>e</ci>
      <cn type="integer">2</cn>
      <ci>e</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{e2e}=S_{1}\otimes S_{2}
  </annotation>
 </semantics>
</math>

.</p>
<figure><b>(Figure)</b>
<figcaption>Sequence of two servers</figcaption>
</figure>

<p>The proof does iterative application of the definition of service curves 

<math display="inline" id="Network_calculus:74">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>≥</mo>
   <mrow>
    <mi>A</mi>
    <mo>⊗</mo>
    <msub>
     <mi>S</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>X</ci>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X\geq A\otimes S_{1}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Network_calculus:75">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>≥</mo>
   <mrow>
    <mi>X</mi>
    <mo>⊗</mo>
    <msub>
     <mi>S</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>D</ci>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>X</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D\geq X\otimes S_{2}
  </annotation>
 </semantics>
</math>

 and some properties of convolution, isotonicity (

<math display="inline" id="Network_calculus:76">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>≥</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>X</mi>
      <mo>⊗</mo>
      <msub>
       <mi>S</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⊗</mo>
    <msub>
     <mi>S</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>D</ci>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <ci>X</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D\geq(X\otimes S_{2})\otimes S_{1}
  </annotation>
 </semantics>
</math>

), and associativity (

<math display="inline" id="Network_calculus:77">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>≥</mo>
   <mrow>
    <mi>X</mi>
    <mo>⊗</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>S</mi>
       <mn>2</mn>
      </msub>
      <mo>⊗</mo>
      <msub>
       <mi>S</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>D</ci>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <ci>X</ci>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D\geq X\otimes(S_{2}\otimes S_{1})
  </annotation>
 </semantics>
</math>

).</p>

<p>The interest of this result is that the end-to-end delay bound is not greater than the sum of local delays: 

<math display="inline" id="Network_calculus:78">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>E</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>S</mi>
       <mn>2</mn>
      </msub>
      <mo>⊗</mo>
      <msub>
       <mi>S</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>E</mi>
      <mo>,</mo>
      <msub>
       <mi>S</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>E</mi>
       <mo>⊘</mo>
       <msub>
        <mi>S</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo>,</mo>
      <msub>
       <mi>S</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>d</ci>
     <interval closure="open">
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>d</ci>
      <interval closure="open">
       <ci>E</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <cn type="integer">1</cn>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <interval closure="open">
       <apply>
        <ci>normal-⊘</ci>
        <ci>E</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>S</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <cn type="integer">2</cn>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(E,S_{2}\otimes S_{1})\leq d(E,S_{1})+d(E\oslash S_{1},S_{2})
  </annotation>
 </semantics>
</math>

.</p>

<p>This result is known as <em>Pay burst only once</em> (PBOO).</p>
<h2 id="tools">Tools</h2>

<p>There are several tools based on network calculus.</p>
<ul>
<li>The <a href="http://disco.informatik.uni-kl.de/index.php/projects/disco-dnc">DiscoDNC</a> is an academic Java implementation of the network calculus framework.<ref></ref></li>
</ul>

<p></p>
<ul>
<li>The <a href="http://www.mpa.ethz.ch/Rtctoolbox">RTC Toolbox</a> is an academic Java/<a class="uri" href="MATLAB" title="wikilink">MATLAB</a> implementation of the Real-Time calculus framework, a theory quasi equivalent to network calculus.<ref <ref="" name="SC-TR"></ref></li>
<li>The <a href="http://www.control.auc.dk/~henrik/CyNC/CyNC">CyNC</a> tool is an academic <a class="uri" href="MATLAB" title="wikilink">MATLAB</a>/Symulink toolbox. The project seems to be frozen (the last update on <a href="http://www.control.auc.dk/~henrik/CyNC/CyNC">its web page</a> is from July 2005).</li>
<li>The <a href="http://www.realtimeatwork.com/software/rtaw-pegase">RTaW-PEGASE</a> is an industrial tool devoted to timing analysis tool of switched Ethernet network (AFDX, industrial and automotive Ethernet), based on network calculus.<ref></ref></li>
</ul>

<p></p>
<ul>
<li>The <a href="http://websites.isae.fr/wopanets/">WOPANets</a> is an academic tool combining network calculus based analysis and optimization analysis.<ref></ref></li>
</ul>

<p></p>
<ul>
<li>The DelayLyzer is an industrial tool designed to compute bounds for Profinet networks.<ref></ref></li>
</ul>

<p></p>
<h2 id="references">References</h2>

<p>Books, Surveys, and Tutorials on Network Calculus</p>
<ul>
<li>C.-S. Chang: <em>Performance Guarantees in Communications Networks</em>, Springer, 2000.</li>
<li>J.-Y. Le Boudec and P. Thiran: <em><a href="http://ica1www.epfl.ch/PS_files/NetCal.htm">Network Calculus: A Theory of Deterministic Queuing Systems for the Internet</a></em>, Springer, LNCS, 2001.</li>
<li>Y. Jiang and Y. Liu: <em>Stochastic Network Calculus</em>, Springer, 2008.</li>
<li>A. Kumar, D. Manjunath, and J. Kuri: <em>Communication Networking: An Analytical Approach</em>, Elsevier, 2004.</li>
<li>S. Mao and S. Panwar: <em>A survey of envelope processes and their applications in quality of service provisioning</em>, IEEE Communications Surveys and Tutorials, 8(3):2-20, July 2006.</li>
<li>M. Fidler: <em>[<a class="uri" href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp</a>=&amp;arnumber;=5415864 Survey of deterministic and stochastic service curve models in the network calculus]</em>, IEEE Communications Surveys and Tutorials, 12(1):59-86, January 2010.</li>
<li>M. Fidler and A. Rizk: <em>[<a class="uri" href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp</a>=&amp;arnumber;=6868978 A guide to the stochastic network calculus]</em>, IEEE Communications Surveys and Tutorials, 17(1):92-105, March 2015.</li>
</ul>

<p>Related books on the max-plus algebra or on <a href="convex_minimization" title="wikilink">convex minimization</a></p>
<ul>
<li><a href="R._T._Rockafellar" title="wikilink">R. T. Rockafellar</a>: <em><a href="Convex_analysis" title="wikilink">Convex analysis</a></em>, Princeton University Press, 1972.</li>
<li>F. Baccelli, G. Cohen, G. J. Olsder, and J.-P. Quadrat: <em>Synchronization and Linearity: An Algebra for Discrete Event Systems</em>, Wiley, 1992.</li>
<li>V. N. Kolokol'tsov, Victor P. Maslov: <em>Idempotent Analysis and Its Applications</em>, Springer, 1997. ISBN 0792345096.</li>
</ul>

<p>Deterministic network calculus</p>
<ul>
<li>R. L. Cruz:  and , IEEE Transactions on Information Theory, 37(1):114-141, Jan. 1991.</li>
<li>A. K. Parekh and R. G. Gallager: <em>A Generalized Processor Sharing Approach to Flow Control : The Multiple Node Case</em>, IEEE Transactions on Networking, 2 (2):137-150, April 1994.</li>
<li>C.-S. Chang: <em>Stability, Queue Length and Delay of Deterministic and Stochastic Queueing Networks</em>, IEEE Transactions on Automatic Control, 39(5):913-931, May 1994.</li>
<li>D. E. Wrege, E. W. Knightly, H. Zhang, and J. Liebeherr: <em>Deterministic delay bounds for VBR video in packet-switching networks: Fundamental limits and practical tradeoffs</em>, IEEE/ACM Transactions on Networking, 4(3):352-362, Jun. 1996.</li>
<li>R. L. Cruz: <em>SCED+: Efficient Management of Quality of Service Guarantees</em>, IEEE INFOCOM, pp. 625–634, Mar. 1998.</li>
<li>J.-Y. Le Boudec: <em>Application of Network Calculus to Guaranteed Service Networks</em>, IEEE Transactions on Information Theory, 44(3):1087-1096, May 1998.</li>
<li>C.-S. Chang: <em>On Deterministic Traffic Regulation and Service Guarantees: A Systematic Approach by Filtering</em>, IEEE Transactions on Information Theory, 44(3):1097-1110, May 1998.</li>
<li>R. Agrawal, R. L. Cruz, C. Okino, and R. Rajan: <em>Performance Bounds for Flow Control Protocols</em>, IEEE/ACM Transactions on Networking, 7(3):310-323, Jun. 1999.</li>
<li>J.-Y. Le Boudec: <em>Some properties of variable length packet shapers</em>, IEEE/ACM Transactions on Networking, 10(3):329-337, Jun. 2002.</li>
<li>C.-S. Chang, R. L. Cruz, J.-Y. Le Boudec, and P. Thiran: <em>A Min, + System Theory for Constrained Traffic Regulation and Dynamic Service Guarantees</em>, IEEE/ACM Transactions on Networking, 10(6):805-817, Dec. 2002.</li>
<li>M. Fidler and S. Recker: <em>Conjugate network calculus: A dual approach applying the Legendre transform</em>, Computer Networks, 50(8):1026-1039, Jun. 2006.</li>
<li>Eitan Altman, Kostya Avrachenkov, and Chadi Barakat: <em>TCP network calculus: The case of large bandwidth-delay product</em>, In proceedings of IEEE INFOCOM, NY, June 2002.</li>
</ul>

<p>Network topologies, feed-forward networks</p>
<ul>
<li>A. Charny and J.-Y. Le Boudec: <em>Delay Bounds in a Network with Aggregate Scheduling</em>, QoFIS, pp. 1–13, Sep. 2000.</li>
<li>D. Starobinski, M. Karpovsky, and L. Zakrevski: <em>Application of Network Calculus to General Topologies using Turn-Prohibition</em>, IEEE/ACM Transactions on Networking, 11(3):411-421, Jun. 2003.</li>
<li>M. Fidler: <em>A parameter based admission control for differentiated services networks</em>, Computer Networks, 44(4):463-479, March 2004.</li>
<li>L. Lenzini, L. Martorini, E. Mingozzi, and G. Stea: <em>Tight end-to-end per-flow delay bounds in FIFO multiplexing sink-tree networks</em>, Performance Evaluation, 63(9-10):956-987, October 2006.</li>
<li>J. Schmitt, F. Zdarsky, and M. Fidler: <em>Delay bounds under arbitrary multiplexing: when network calculus leaves you in the lurch ...</em>, Prof. IEEE Infocom, April 2008.</li>
<li>A. Bouillard, L. Jouhet, and E. Thierry: <em>Tight performance bounds in the worst-case analysis of feed-forward networks</em>, Proc. IEEE Infocom, April 2010.</li>
</ul>

<p>Measurement-based system identification</p>
<ul>
<li>C. Cetinkaya, V. Kanodia, and E.W. Knightly: <em>Scalable services via egress admission control</em>, IEEE Transactions on Multimedia, 3(1):69-81, March 2001.</li>
<li>S. Valaee, and B. Li: <em>Distributed call admission control for ad hoc networks</em>, Proc. of IEEE VTC, pp. 1244–1248, 2002.</li>
<li>J. Liebeherr, M. Fidler, and S. Valaee: <em>A system-theoretic approach to bandwidth estimation</em>, IEEE Transactions on Networking, 18(4):1040-1053, August 2010.</li>
<li>M. Bredel, Z. Bozakov, and Y. Jiang: <em>Analyzing router performance using network calculus with external measurements</em>, Proc. IEEE IWQoS, June 2010.</li>
<li>R. Lubben, M. Fidler, and J. Liebeherr: <em>Stochastic bandwidth estimation in networks with random service</em>, IEEE Transactions on Networking, 22(2):484-497, April 2014.</li>
</ul>

<p>Stochastic network calculus</p>
<ul>
<li>O. Yaron and M. Sidi: <em>Performance and Stability of Communication Networks via Robust Exponential Bounds</em>, IEEE/ACM Transactions on Networking, 1(3):372-385, Jun. 1993.</li>
<li>D. Starobinski and M. Sidi: <em>Stochastically Bounded Burstiness for Communication Networks</em>, IEEE Transactions on Information Theory, 46(1):206-212, Jan. 2000.</li>
<li>C.-S. Chang: <em>Stability, Queue Length and Delay of Deterministic and Stochastic Queueing Networks</em>, IEEE Transactions on Automatic Control, 39(5):913-931, May 1994.</li>
<li>R.-R. Boorstyn, A. Burchard, J. Liebeherr, and C. Oottamakorn: <em>Statistical Service Assurances for Traffic Scheduling Algorithms</em>, IEEE Journal on Selected Areas in Communications, 18(12):2651-2664, Dec. 2000.</li>
<li>Q. Yin, Y. Jiang, S. Jiang, and P. Y. Kong: <em>Analysis of Generalized Stochastically Bounded Bursty Traffic for Communication Networks</em>, IEEE LCN, pp. 141–149, Nov. 2002.</li>
<li>C. Li, A. Burchard, and J. Liebeherr: <em>A Network Calculus with Effective Bandwidth</em>, University of Virginia, Technical Report CS-2003-20, Nov. 2003.</li>
<li>A. Burchard, J. Liebeherr, and S. D. Patek: <em>A Min-Plus Calculus for End-to-end Statistical Service Guarantees</em>, IEEE Transactions on Information Theory, 52(9):4105–4114, Sep. 2006.</li>
<li>F. Ciucu, A. Burchard, and J. Liebeherr: <em>A Network Service Curve Approach for the Stochastic Analysis of Networks</em>, IEEE/ACM Transactions on Networking, 52(6):2300–2312, Jun. 2006.</li>
<li>M. Fidler: <em>An End-to-End Probabilistic Network Calculus with Moment Generating Functions</em>, IEEE IWQoS, Jun. 2006.</li>
</ul>

<p>Wireless network calculus</p>
<ul>
<li>M. Fidler: <em>A Network Calculus Approach to Probabilistic Quality of Service Analysis of Fading Channels</em>, Proc. IEEE Globecom, November 2006.</li>
<li>K. Mahmood and A. Rizk: <em>On the Flow-Level Delay of a Spatial Multiplexing MIMO Wireless Channel</em>, Proc. IEEE ICC, June 2011.</li>
<li>H. Al-Zubaidy, J. Liebeherr, and A. Burchard: <em>A (min, ×) network calculus for multi-hop fading channels</em>, Proc. IEEE Infocom, pp. 1833–1841, April 2013.</li>
<li>M. Fidler, R. Lubben, and N. Becker: <em>[<a class="uri" href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp</a>=&amp;arnumber;=6940302 Capacity–Delay–Error Boundaries: A Composable Model of Sources and Systems]</em>, Transactions on Wireless Communications, 14(3):1280-1294, March 2015.</li>
</ul>

<p>"</p>

<p><a href="Category:Network_performance" title="wikilink">Category:Network performance</a> <a href="Category:Computer_network_analysis" title="wikilink">Category:Computer network analysis</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
