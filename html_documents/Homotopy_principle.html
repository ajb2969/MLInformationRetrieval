<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1184">Homotopy principle</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Homotopy principle</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>The homotopy principle generalizes such results as Smale's proof of <a href="sphere_eversion" title="wikilink">sphere eversion</a>.</figcaption>
</figure>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, the <strong>homotopy principle</strong> (or <strong>h-principle</strong>) is a very general way to solve <a href="partial_differential_equation" title="wikilink">partial differential equations</a> (PDEs), and more generally <a href="partial_differential_relation" title="wikilink">partial differential relations</a> (PDRs). The h-principle is good for <a href="underdetermined_system" title="wikilink">underdetermined</a> PDEs or PDRs, such as occur in the <a href="immersion_problem" title="wikilink">immersion problem</a>, <a href="isometric_immersion_problem" title="wikilink">isometric immersion problem</a>, and other areas.</p>

<p>The theory was started by <a href="Yakov_Eliashberg" title="wikilink">Yakov Eliashberg</a>, <a href="Mikhail_Gromov_(mathematician)" title="wikilink">Mikhail Gromov</a> and <a href="Anthony_V._Phillips" title="wikilink">Anthony V. Phillips</a>. It was based on earlier results that reduced partial differential relations to homotopy, particularly for immersions. The first evidence of h-principle appeared in the <a href="Whitney–Graustein_theorem" title="wikilink">Whitney–Graustein theorem</a>. This was followed by the Nash-Kuiper Isometric 

<math display="inline" id="Homotopy_principle:0">
 <semantics>
  <msup>
   <mi>C</mi>
   <mn>1</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>C</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{1}
  </annotation>
 </semantics>
</math>

 embedding theorem and the Smale-Hirsch Immersion theorem.</p>
<h2 id="rough-idea">Rough idea</h2>

<p>Assume we want to find a function <em>ƒ</em> on <strong>R</strong><sup><em>m</em></sup> which satisfies a partial differential equation of degree <em>k</em>, in co-ordinates 

<math display="inline" id="Homotopy_principle:1">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>u</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>u</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>u</mi>
    <mi>m</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>m</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (u_{1},u_{2},\dots,u_{m})
  </annotation>
 </semantics>
</math>

. One can rewrite it as</p>

<p>

<math display="block" id="Homotopy_principle:2">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Ψ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>u</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>u</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>u</mi>
      <mi>m</mi>
     </msub>
     <mo>,</mo>
     <msubsup>
      <mi>J</mi>
      <mi>f</mi>
      <mi>k</mi>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Ψ</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>J</ci>
        <ci>k</ci>
       </apply>
       <ci>f</ci>
      </apply>
     </vector>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi(u_{1},u_{2},\dots,u_{m},J^{k}_{f})=0\!\,
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Homotopy_principle:3">
 <semantics>
  <msubsup>
   <mi>J</mi>
   <mi>f</mi>
   <mi>k</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>J</ci>
     <ci>k</ci>
    </apply>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J^{k}_{f}
  </annotation>
 </semantics>
</math>

 stands for all partial derivatives of <em>ƒ</em> up to order <em>k</em>. Let us exchange every variable in 

<math display="inline" id="Homotopy_principle:4">
 <semantics>
  <msubsup>
   <mi>J</mi>
   <mi>f</mi>
   <mi>k</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>J</ci>
     <ci>k</ci>
    </apply>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J^{k}_{f}
  </annotation>
 </semantics>
</math>

 for new independent variables 

<math display="inline" id="Homotopy_principle:5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mi>N</mi>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>N</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{1},y_{2},\dots,y_{N}.
  </annotation>
 </semantics>
</math>

 Then our original equation can be thought as a system of</p>

<p>

<math display="block" id="Homotopy_principle:6">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Ψ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>u</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>u</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>u</mi>
      <mi>m</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mi>N</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Ψ</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>N</ci>
      </apply>
     </vector>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi(u_{1},u_{2},\dots,u_{m},y_{1},y_{2},\dots,y_{N})=0\!\,
  </annotation>
 </semantics>
</math>

</p>

<p>and some number of equations of the following type</p>

<p>

<math display="block" id="Homotopy_principle:7">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>j</mi>
    </msub>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <msup>
       <mo>∂</mo>
       <mi>k</mi>
      </msup>
      <mi>f</mi>
     </mrow>
     <mrow>
      <mrow>
       <mo>∂</mo>
       <mrow>
        <msub>
         <mi>u</mi>
         <msub>
          <mi>i</mi>
          <mn>1</mn>
         </msub>
        </msub>
        <mi mathvariant="normal">…</mi>
       </mrow>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <msub>
        <mi>u</mi>
        <msub>
         <mi>i</mi>
         <mi>k</mi>
        </msub>
       </msub>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <partialdiff></partialdiff>
       <ci>k</ci>
      </apply>
      <ci>f</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <partialdiff></partialdiff>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>normal-…</ci>
       </apply>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>i</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{j}={\partial^{k}f\over\partial u_{i_{1}}\ldots\partial u_{i_{k}}}.\!\,
  </annotation>
 </semantics>
</math>

</p>

<p>A solution of</p>

<p>

<math display="block" id="Homotopy_principle:8">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Ψ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>u</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>u</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>u</mi>
      <mi>m</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mi>N</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Ψ</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>N</ci>
      </apply>
     </vector>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi(u_{1},u_{2},\dots,u_{m},y_{1},y_{2},\dots,y_{N})=0\!\,
  </annotation>
 </semantics>
</math>

</p>

<p>is called a <strong>non-holonomic solution</strong>, and a solution of the system (which is a solution of our original PDE) is called a <strong>holonomic solution</strong>.</p>

<p>In order to check whether a solution exists, first check if there is a non-holonomic solution (usually it is quite easy and if not then our original equation did not have any solutions).</p>

<p>A PDE <em>satisfies the h-principle</em> if any non-holonomic solution can be <a href="homotopy" title="wikilink">deformed</a> into a holonomic one in the class of non-holonomic solutions. Thus in the presence of h-principle, a differential topological problem reduces to an algebraic topological problem. More explicitly this means that apart from the topological obstruction there is no other obstruction to the existence of a holonomic solution. The topological problem of finding a <em>non-holonomic solution</em> is much easier to handle and can be addressed with the obstruction theory for topological bundles.</p>

<p>Many underdetermined partial differential equations satisfy the h-principle. However, the falsity of an h-principle is also an interesting statement, intuitively this means the objects being studied have non-trivial geometry that cannot be reduced to topology. As an example, embedded <a href="Lagrangian_submanifold" title="wikilink">Lagrangians</a> in a symplectic manifold do not satisfy an h-principle, to prove this one needs to find invariants coming from <a href="Pseudoholomorphic_curve" title="wikilink">pseudo-holomorphic curves</a>.</p>
<h2 id="simple-examples">Simple examples</h2>
<h3 id="monotone-functions">Monotone functions</h3>

<p>Perhaps the simplest partial differential relation is for the derivative to not vanish

<math display="block" id="Homotopy_principle:9">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>f</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≠</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>f</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f^{\prime}(x)\neq 0.
  </annotation>
 </semantics>
</math>

 Properly, this is an <em>ordinary</em> differential relation, as this is a function in one variable. These are the strictly monotone differentiable functions, either increasing or decreasing, and one may ask the homotopy type of this space, as compared with spaces without this restriction. The space of (differentiable, strictly) monotone functions on the real line consists of two disjoint <a href="convex_set" title="wikilink">convex sets</a>: the increasing ones and the decreasing ones, and has the homotopy type of two points. The space of all functions on the real line is a convex set, and has the homotopy type of one point. This does not appear promising – they have not even the same components – but closer examination reveals that this is the only problem: all of the higher homotopy groups agree. If instead one restricts to all maps with given endpoint values

<math display="block" id="Homotopy_principle:10">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>→</mo>
    <mi>𝐑</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <interval closure="closed">
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </interval>
     <ci>𝐑</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\colon[0,1]\to\mathbf{R}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Homotopy_principle:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(0)=a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Homotopy_principle:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>b</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(1)=b,
  </annotation>
 </semantics>
</math>

, then for 

<math display="inline" id="Homotopy_principle:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>≠</mo>
    <mi>b</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\neq b,
  </annotation>
 </semantics>
</math>

 the inclusion of functions with non-vanishing derivative in all continuous functions is a homotopy equivalence – both the spaces are convex, and in fact the monotone functions are a convex subset. Further, there is a natural base point, namely the linear function 

<math display="inline" id="Homotopy_principle:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>a</mi>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>b</mi>
       <mo>-</mo>
       <mi>a</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>t</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>a</ci>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <ci>b</ci>
       <ci>a</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(t)=a+(b-a)t
  </annotation>
 </semantics>
</math>

 – this is the function with shortest path length in this space.</p>

<p>While this is a very simple example, it illustrates some of the general aspects of h-principles:</p>
<ul>
<li>The lowest homotopy groups – showing that the inclusion is 0-connected or 1-connected – is hardest;</li>
<li>h-principles are largely about showing that <em>higher</em> homotopy groups agree (rather, that the inclusion is an isomorphism on these groups) – showing that, once an inclusion has been shown to be 1-connected, it is in fact <a href="n-connected" title="wikilink"><em>n</em>-connected</a>, possibly for all <em>n;</em></li>
<li>h-principles can sometimes be shown by <a href="calculus_of_variations" title="wikilink">variational methods</a>, as in the above length example.</li>
</ul>

<p> This example also extends to significant results: extending this to immersions of a circle into itself classifies them by order (or <a href="winding_number" title="wikilink">winding number</a>), by lifting the map to the <a href="universal_covering_space" title="wikilink">universal covering space</a> and applying the above analysis to the resulting monotone map – the linear map corresponds to multiplying angle

<math display="block" id="Homotopy_principle:15">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mo>↦</mo>
   <mrow>
    <mi>n</mi>
    <mi>θ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>θ</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>θ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta\mapsto n\theta
  </annotation>
 </semantics>
</math>

 (

<math display="inline" id="Homotopy_principle:16">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>↦</mo>
   <msup>
    <mi>z</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>z</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>z</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z\mapsto z^{n}
  </annotation>
 </semantics>
</math>

 in complex numbers). Note that here there are no immersions of order 0, as those would need to turn back on themselves. Extending this to circles immersed in the plane – the immersion condition is precisely the condition that the derivative does not vanish – the <a href="Whitney–Graustein_theorem" title="wikilink">Whitney–Graustein theorem</a> classified these by <a href="turning_number" title="wikilink">turning number</a> by considering the homotopy class of the <a href="Gauss_map" title="wikilink">Gauss map</a> and showing that this satisfies an h-principle; here again order 0 is more complicated.</p>

<p>Smale's classification of immersions of spheres as the homotopy groups of <a href="Stiefel_manifold" title="wikilink">Stiefel manifolds</a>, and Hirsch's generalization of this to immersions of manifolds being classified as homotopy classes of maps of <a href="frame_bundle" title="wikilink">frame bundles</a> are much further-reaching generalizations, and much more involved, but similar in principle – immersion requires the derivative to have rank <em>k,</em> which requires the partial derivatives in each direction to not vanish and to be linearly independent, and the resulting analog of the Gauss map is a map to the Stiefel manifold, or more generally between frame bundles.</p>
<h3 id="a-car-in-the-plane">A car in the plane</h3>

<p>As another simple example, consider a car moving in the plane. The position of a car in the plane is determined by three parameters: two coordinates 

<math display="inline" id="Homotopy_principle:17">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Homotopy_principle:18">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 for the location (a good choice is the location of the midpoint between the back wheels) and an angle 

<math display="inline" id="Homotopy_principle:19">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 which describes the orientation of the car. The motion of the car satisfies the equation</p>

<p>

<math display="block" id="Homotopy_principle:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi>x</mi>
      <mo>˙</mo>
     </mover>
     <mrow>
      <mi>sin</mi>
      <mi>α</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mover accent="true">
      <mi>y</mi>
      <mo>˙</mo>
     </mover>
     <mrow>
      <mi>cos</mi>
      <mi>α</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-˙</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <sin></sin>
      <ci>α</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-˙</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <cos></cos>
      <ci>α</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{x}\sin\alpha=\dot{y}\cos\alpha.\,
  </annotation>
 </semantics>
</math>

 since a non-skidding car must move in the direction of its wheels. In <a class="uri" href="robotics" title="wikilink">robotics</a> terms, not all paths in the task space are <a href="holonomic_(robotics)" title="wikilink">holonomic</a>.</p>

<p>A non-holonomic solution in this case, roughly speaking, corresponds to a motion of the car by sliding in the plane. In this case the non-holonomic solutions are not only <a class="uri" href="homotopic" title="wikilink">homotopic</a> to holonomic ones but also can be arbitrarily well approximated by the holonomic ones (by going back and forth, like parallel parking in a limited space) – note that this approximates both the position and the angle of the car arbitrarily closely. This implies that, theoretically, it is possible to parallel park in any space longer than the length of your car. It also implies that, in a contact 3 manifold, any curve is 

<math display="inline" id="Homotopy_principle:21">
 <semantics>
  <msup>
   <mi>C</mi>
   <mn>0</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>C</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{0}
  </annotation>
 </semantics>
</math>

-close to a <a href="Legendrian_knot" title="wikilink">Legendrian</a> curve. This last property is stronger than the general h-principle; it is called the 

<math display="inline" id="Homotopy_principle:22">
 <semantics>
  <msup>
   <mi>C</mi>
   <mn>0</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>C</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{0}
  </annotation>
 </semantics>
</math>

-<strong>dense h-principle</strong>.</p>

<p>While this example is simple, compare to the <a href="Nash_embedding_theorem" title="wikilink">Nash embedding theorem</a>, specifically the <a href="Nash–Kuiper_theorem" title="wikilink">Nash–Kuiper theorem</a>, which says that any <a href="short_map" title="wikilink">short</a> smooth (

<math display="inline" id="Homotopy_principle:23">
 <semantics>
  <msup>
   <mi>C</mi>
   <mi mathvariant="normal">∞</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>C</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{\infty}
  </annotation>
 </semantics>
</math>

) embedding or immersion of 

<math display="inline" id="Homotopy_principle:24">
 <semantics>
  <msup>
   <mi>M</mi>
   <mi>m</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>M</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M^{m}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Homotopy_principle:25">
 <semantics>
  <msup>
   <mi>𝐑</mi>
   <mrow>
    <mi>m</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝐑</ci>
    <apply>
     <plus></plus>
     <ci>m</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{R}^{m+1}
  </annotation>
 </semantics>
</math>

 or larger can be arbitrarily well approximated by an isometric 

<math display="inline" id="Homotopy_principle:26">
 <semantics>
  <msup>
   <mi>C</mi>
   <mn>1</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>C</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{1}
  </annotation>
 </semantics>
</math>

-embedding (respectively, immersion). This is also a dense h-principle, and can be proven by an essentially similar "wrinkling" – or rather, circling – technique to the car in the plane, though it is much more involved.</p>
<h2 id="ways-to-prove-the-h-principle">Ways to prove the h-principle</h2>
<ul>
<li><a href="Removal_of_Singularities" title="wikilink">Removal of Singularities</a> technique developed by Gromov and Eliashberg</li>
<li><a href="Sheaf_technique" title="wikilink">Sheaf technique</a> based on the work of Smale and Hirsch.</li>
<li><a href="Convex_integration" title="wikilink">Convex integration</a> based on the work of Nash and Kuiper</li>
</ul>
<h2 id="some-paradoxes">Some paradoxes</h2>

<p>Here we list a few counter-intuitive results which can be proved by applying the h-principle:</p>
<ul>
<li><strong>Cone Eversion</strong>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Let us consider functions <em>f</em> on <strong>R</strong><sup>2</sup> without origin <em>f</em>(<em>x</em>) = |<em>x</em>|. Then there is a continuous one-parameter family of functions 

<math display="inline" id="Homotopy_principle:27">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{t}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Homotopy_principle:28">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mi>f</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{0}=f
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Homotopy_principle:29">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mi>f</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <minus></minus>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{1}=-f
  </annotation>
 </semantics>
</math>

 and for any 

<math display="inline" id="Homotopy_principle:30">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Homotopy_principle:31">
 <semantics>
  <mrow>
   <mo>grad</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>f</mi>
     <mi>t</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>grad</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{grad}(f_{t})
  </annotation>
 </semantics>
</math>

 is not zero at any point.</li>
</ul>
<ul>
<li>Any open manifold admits a (non-complete) Riemannian metric of positive (or negative) curvature.</li>
</ul>
<ul>
<li><a href="Sphere_eversion" title="wikilink">Sphere eversion</a> without creasing or tearing can be done using 

<math display="inline" id="Homotopy_principle:32">
 <semantics>
  <msup>
   <mi>C</mi>
   <mn>1</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>C</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{1}
  </annotation>
 </semantics>
</math>

 isometric embedding of 

<math display="inline" id="Homotopy_principle:33">
 <semantics>
  <msup>
   <mi>S</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>S</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{2}
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li><a href="Nash_embedding_theorem" title="wikilink">Nash embedding theorem</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Masahisa Adachi, <a href="http://books.google.com/books?id=JcMwHWSBSB4C">Embeddings and immersions</a>, translation Kiki Hudson</li>
<li>Y. Eliashberg, N. Mishachev, <a href="http://books.google.com/books?id=1YVLmDG55XEC">Introduction to the h-principle</a></li>
<li></li>
<li>M. W. Hirsch, Immersions of manifold. Trans. Amer. Math. Soc. 93 (1959)</li>
<li>N. Kuiper, On 

<math display="inline" id="Homotopy_principle:34">
 <semantics>
  <msup>
   <mi>C</mi>
   <mn>1</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>C</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{1}
  </annotation>
 </semantics>
</math>

 Isometric Imbeddings I, II. Nederl. Acad. Wetensch. Proc. Ser A 58 (1955)</li>
<li>John Nash, 

<math display="inline" id="Homotopy_principle:35">
 <semantics>
  <msup>
   <mi>C</mi>
   <mn>1</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>C</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{1}
  </annotation>
 </semantics>
</math>

 Isometric Imbedding. Ann. of Math(2) 60 (1954)</li>
<li>S. Smale, The classification of immersions of spheres in Euclidean spaces. Ann. of Math(2) 69 (1959)</li>
<li>David Spring, Convex integration theory - solutions to the h-principle in geometry and topology, Monographs in Mathematics 92, Birkhauser-Verlag, 1998</li>
</ul>
<references>
</references>

<p>"</p>

<p><a href="Category:Partial_differential_equations" title="wikilink">Category:Partial differential equations</a> <a href="Category:Mathematical_principles" title="wikilink">Category:Mathematical principles</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">D. Fuchs, S. Tabachnikov, <em>Mathematical Omnibus: Thirty Lectures on Classic Mathematics</em><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
