<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="574">Sequential dynamical system</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Sequential dynamical system</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Phase space of the sequential dynamical system</figcaption>
</figure>

<p><strong>Sequential dynamical systems (SDSs)</strong> are a class of <a href="graph_dynamical_system" title="wikilink">graph dynamical systems</a>. They are discrete <a href="dynamical_systems" title="wikilink">dynamical systems</a> which generalize many aspects of for example classical <a href="cellular_automata" title="wikilink">cellular automata</a>, and they provide a framework for studying asynchronous processes over <a href="graph_theory" title="wikilink">graphs</a>. The analysis of SDSs uses techniques from <a class="uri" href="combinatorics" title="wikilink">combinatorics</a>, <a href="abstract_algebra" title="wikilink">abstract algebra</a>, <a href="graph_theory" title="wikilink">graph theory</a>, <a href="dynamical_system" title="wikilink">dynamical systems</a> and <a href="probability_theory" title="wikilink">probability theory</a>.</p>
<h2 id="definition">Definition</h2>

<p>An SDS is constructed from the following components:</p>
<blockquote>
<ul>
<li>A finite <em>graph</em> <em>Y</em> with vertex set v[<em>Y</em>] = {1,2, ... , n}. Depending on the context the graph can be directed or undirected.</li>
</ul>
<ul>
<li>A state <em>x<sub>v</sub></em> for each vertex <em>i</em> of <em>Y</em> taken from a finite set <em>K</em>. The <em>system state</em> is the <em>n</em>-tuple <em>x</em> = (<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ... , <em>x<sub>n</sub></em>), and <em>x</em>[<em>i</em>] is the <a class="uri" href="tuple" title="wikilink">tuple</a> consisting of the states associated to the vertices in the 1-neighborhood of <em>i</em> in <em>Y</em> (in some fixed order).</li>
</ul>
<ul>
<li>A <em>vertex function</em> <em>f<sub>i</sub></em> for each vertex <em>i</em>. The vertex function maps the state of vertex <em>i</em> at time <em>t</em> to the vertex state at time <em>t</em> + 1 based on the states associated to the 1-neighborhood of <em>i</em> in <em>Y</em>.</li>
</ul>
<ul>
<li>A word <em>w</em> = (<em>w</em><sub>1</sub>, <em>w</em><sub>2</sub>, ... , <em>w<sub>m</sub></em>) over <em>v</em>[<em>Y</em>].</li>
</ul>
</blockquote>

<p>It is convenient to introduce the <em>Y</em>-local maps <em>F<sub>i</sub></em> constructed from the vertex functions by</p>

<p>

<math display="block" id="Sequential_dynamical_system:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>F</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>f</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mrow>
         <mo stretchy="false">[</mo>
         <mi>i</mi>
         <mo stretchy="false">]</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>i</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo rspace="5.3pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>i</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <ci>x</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{i}(x)=(x_{1},x_{2},\ldots,x_{i-1},f_{i}(x[i]),x_{i+1},\ldots,x_{n})\;.
  </annotation>
 </semantics>
</math>

</p>

<p>The word <em>w</em> specifies the sequence in which the <em>Y</em>-local maps are composed to derive the sequential dynamical system map <em>F</em>: <em>K<sup>n</sup> → K<sup>n</sup></em> as</p>

<p>

<math display="block" id="Sequential_dynamical_system:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>F</mi>
      <mi>Y</mi>
     </msub>
     <mo>,</mo>
     <mi>w</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>F</mi>
      <mrow>
       <mi>w</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>m</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msub>
     <mo>∘</mo>
     <msub>
      <mi>F</mi>
      <mrow>
       <mi>w</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>m</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msub>
     <mo>∘</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>∘</mo>
     <msub>
      <mi>F</mi>
      <mrow>
       <mi>w</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>2</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msub>
     <mo>∘</mo>
     <mpadded width="+2.8pt">
      <msub>
       <mi>F</mi>
       <mrow>
        <mi>w</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>1</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </msub>
     </mpadded>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="closed">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>Y</ci>
     </apply>
     <ci>w</ci>
    </interval>
    <apply>
     <compose></compose>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <apply>
       <times></times>
       <ci>w</ci>
       <ci>m</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <apply>
       <times></times>
       <ci>w</ci>
       <apply>
        <minus></minus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <apply>
       <times></times>
       <ci>w</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <apply>
       <times></times>
       <ci>w</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [F_{Y},w]=F_{w(m)}\circ F_{w(m-1)}\circ\cdots\circ F_{w(2)}\circ F_{w(1)}\;.
  </annotation>
 </semantics>
</math>

</p>

<p>If the update sequence is a permutation one frequently speaks of a <em>permutation SDS</em> to emphasize this point. The <em>phase space</em> associated to a sequential dynamical system with map <em>F</em>: <em>K<sup>n</sup> → K<sup>n</sup></em> is the finite directed graph with vertex set <em>K<sup>n</sup></em> and directed edges (<em>x</em>, <em>F</em>(<em>x</em>)). The structure of the phase space is governed by the properties of the graph <em>Y</em>, the vertex functions (<em>f<sub>i</sub></em>)<em><sub>i</sub></em>, and the update sequence <em>w</em>. A large part of SDS research seeks to infer phase space properties based on the structure of the system constituents.</p>
<h2 id="example">Example</h2>

<p>Consider the case where <em>Y</em> is the graph with vertex set {1,2,3} and undirected edges {1,2}, {1,3} and {2,3} (a triangle or 3-circle) with vertex states from <em>K</em> = {0,1}. For vertex functions use the symmetric, boolean function nor : <em>K<sup>3</sup> → K</em> defined by nor(<em>x</em>,<em>y</em>,<em>z</em>) = (1+<em>x</em>)(1+<em>y</em>)(1+<em>z</em>) with boolean arithmetic. Thus, the only case in which the function nor returns the value 1 is when all the arguments are 0. Pick <em>w</em> = (1,2,3) as update sequence. Starting from the initial system state (0,0,0) at time <em>t</em> = 0 one computes the state of vertex 1 at time <em>t</em>=1 as nor(0,0,0) = 1. The state of vertex 2 at time <em>t</em>=1 is nor(1,0,0) = 0. Note that the state of vertex 1 at time <em>t</em>=1 is used immediately. Next one obtains the state of vertex 3 at time <em>t</em>=1 as nor(1,0,0) = 0. This completes the update sequence, and one concludes that the Nor-SDS map sends the system state (0,0,0) to (1,0,0). The system state (1,0,0) is in turned mapped to (0,1,0) by an application of the SDS map.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Graph_dynamical_system" title="wikilink">Graph dynamical system</a></li>
<li><a href="Boolean_network" title="wikilink">Boolean network</a></li>
<li><a href="Gene_regulatory_network" title="wikilink">Gene regulatory network</a></li>
<li><a href="Dynamic_Bayesian_network" title="wikilink">Dynamic Bayesian network</a></li>
<li><a href="Petri_net" title="wikilink">Petri net</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li><a href="http://www.emis.de/journals/DMTCS/pdfpapers/dmAB0106.pdf">Predecessor and Permutation Existence Problems for Sequential Dynamical Systems</a></li>
<li><a href="http://arxiv.org/pdf/math.DS/0603370">Genetic Sequential Dynamical Systems</a></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Combinatorics" title="wikilink">Category:Combinatorics</a> <a href="Category:Graph_theory" title="wikilink">Category:Graph theory</a> <a class="uri" href="Category:Networks" title="wikilink">Category:Networks</a> <a href="Category:Abstract_algebra" title="wikilink">Category:Abstract algebra</a> <a href="Category:Dynamical_systems" title="wikilink">Category:Dynamical systems</a></p>
</body>
</html>
