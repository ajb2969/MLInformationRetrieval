<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="351">Spectral clustering</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Spectral clustering</h1>
<hr/>

<p>In <a href="multivariate_statistics" title="wikilink">multivariate statistics</a> and the <a href="cluster_analysis" title="wikilink">clustering</a> of data, <strong>spectral clustering</strong> techniques make use of the <a href="Spectrum_of_a_matrix" title="wikilink">spectrum</a> (<a class="uri" href="eigenvalues" title="wikilink">eigenvalues</a>) of the <a href="similarity_matrix" title="wikilink">similarity matrix</a> of the data to perform <a href="dimensionality_reduction" title="wikilink">dimensionality reduction</a> before clustering in fewer dimensions. The similarity matrix is provided as an input and consists of a quantitative assessment of the relative similarity of each pair of points in the dataset.</p>

<p>In application to image segmentation, spectral clustering is known as <a href="segmentation-based_object_categorization" title="wikilink">segmentation-based object categorization</a>.</p>
<h2 id="algorithms">Algorithms</h2>

<p>Given an enumerated set of data points, the <a href="similarity_matrix" title="wikilink">similarity matrix</a> may be defined as a symmetric matrix 

<math display="inline" id="Spectral_clustering:0">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Spectral_clustering:1">
 <semantics>
  <mrow>
   <msub>
    <mi>A</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>A</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{ij}\geq 0
  </annotation>
 </semantics>
</math>

 represents a measure of the similarity between data points with indexes 

<math display="inline" id="Spectral_clustering:2">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Spectral_clustering:3">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

.</p>

<p>One spectral clustering technique is the <strong><a href="Segmentation_based_object_categorization#Normalized_cuts" title="wikilink">normalized cuts algorithm</a></strong> or <em>Shi–Malik algorithm</em> introduced by Jianbo Shi and Jitendra Malik,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> commonly used for <a href="segmentation_(image_processing)" title="wikilink">image segmentation</a>. It partitions points into two sets 

<math display="inline" id="Spectral_clustering:4">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>B</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>B</mi>
    <mn>2</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <cn type="integer">2</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (B_{1},B_{2})
  </annotation>
 </semantics>
</math>

 based on the <a class="uri" href="eigenvector" title="wikilink">eigenvector</a> 

<math display="inline" id="Spectral_clustering:5">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 corresponding to the second-smallest <a class="uri" href="eigenvalue" title="wikilink">eigenvalue</a> of the <a href="Laplacian_matrix#Symmetric_normalized_Laplacian" title="wikilink">symmetric normalized Laplacian</a> defined as</p>

<p>

<math display="block" id="Spectral_clustering:6">
 <semantics>
  <mrow>
   <msup>
    <mi>L</mi>
    <mrow>
     <mi>n</mi>
     <mi>o</mi>
     <mi>r</mi>
     <mi>m</mi>
    </mrow>
   </msup>
   <mo>:=</mo>
   <mrow>
    <mi>I</mi>
    <mo>-</mo>
    <mrow>
     <msup>
      <mi>D</mi>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
     </msup>
     <mi>A</mi>
     <msup>
      <mi>D</mi>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>L</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>o</ci>
      <ci>r</ci>
      <ci>m</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <ci>I</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>D</ci>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <ci>A</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>D</ci>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{norm}:=I-D^{-1/2}AD^{-1/2}
  </annotation>
 </semantics>
</math>

,</p>

<p>where 

<math display="inline" id="Spectral_clustering:7">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 is the diagonal matrix</p>

<p>

<math display="block" id="Spectral_clustering:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>D</mi>
     <mrow>
      <mi>i</mi>
      <mi>i</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mi>j</mi>
     </munder>
     <msub>
      <mi>A</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <ci>j</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{ii}=\sum_{j}A_{ij}.
  </annotation>
 </semantics>
</math>

</p>

<p>A mathematically equivalent algorithm <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> takes the <a class="uri" href="eigenvector" title="wikilink">eigenvector</a> corresponding to the largest <a class="uri" href="eigenvalue" title="wikilink">eigenvalue</a> of the <a href="Laplacian_matrix#Random_walk_normalized_Laplacian" title="wikilink">random walk normalized Laplacian</a> matrix 

<math display="inline" id="Spectral_clustering:9">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>D</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>P</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>D</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P=D^{-1}A
  </annotation>
 </semantics>
</math>

.</p>

<p>Another possibility is to use the <a href="Laplacian_matrix" title="wikilink">Laplacian matrix</a> defined as</p>

<p>

<math display="block" id="Spectral_clustering:10">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>:=</mo>
   <mrow>
    <mi>D</mi>
    <mo>-</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>L</ci>
    <apply>
     <minus></minus>
     <ci>D</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L:=D-A
  </annotation>
 </semantics>
</math>

 rather than the <a href="Laplacian_matrix#Symmetric_normalized_Laplacian" title="wikilink">symmetric normalized Laplacian</a> matrix.</p>

<p>Partitioning may be done in various ways, such as by computing the median 

<math display="inline" id="Spectral_clustering:11">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 of the components of the second smallest eigenvector 

<math display="inline" id="Spectral_clustering:12">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

, and placing all points whose component in 

<math display="inline" id="Spectral_clustering:13">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 is greater than 

<math display="inline" id="Spectral_clustering:14">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Spectral_clustering:15">
 <semantics>
  <msub>
   <mi>B</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{1}
  </annotation>
 </semantics>
</math>

, and the rest in 

<math display="inline" id="Spectral_clustering:16">
 <semantics>
  <msub>
   <mi>B</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{2}
  </annotation>
 </semantics>
</math>

. The algorithm can be used for hierarchical clustering by repeatedly partitioning the subsets in this fashion.</p>

<p>Alternatively to computing just one eigenvector, <em>k</em> <a href="eigenvector" title="wikilink">eigenvectors</a> for some <em>k</em>, are computed, and then another algorithm (e.g. <a href="k-means_clustering" title="wikilink">k-means clustering</a>) is used to cluster points by their respective <em>k</em> components in these eigenvectors.</p>

<p>The efficiency of spectral clustering may be improved if the solution to the corresponding eigenvalue problem is performed in a <a href="Matrix-free_methods" title="wikilink">matrix-free fashion</a>, i.e., without explicitly manipulating or even computing the similarity matrix, as, e.g., in the <a href="Lanczos_algorithm" title="wikilink">Lanczos algorithm</a>.</p>

<p>For large-sized graphs, the second eigenvalue of the (normalized) graph <a href="Laplacian_matrix" title="wikilink">Laplacian matrix</a> is often <a class="uri" href="ill-conditioned" title="wikilink">ill-conditioned</a>, leading to slow convergence of iterative eigenvalue solvers. <a href="Preconditioner#Preconditioning_for_eigenvalue_problems" title="wikilink">Preconditioning</a> is a key technology accelerating the convergence, e.g., in the matrix-free <a class="uri" href="LOBPCG" title="wikilink">LOBPCG</a> method. Spectral clustering has been successfully applied on large graphs by first identifying their <a href="community_structure" title="wikilink">community structure</a>, and then clustering communities.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>Spectral clustering is closely related to <a href="Nonlinear_dimensionality_reduction" title="wikilink">Nonlinear dimensionality reduction</a>, and dimension reduction techniques such as locally-linear embedding can be used to reduce errors from noise or outliers.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="relationship-with-k-means">Relationship with <em>k</em>-means</h2>

<p>The kernel <em>k</em>-means problem is an extension of the <em>k</em>-means problem where the input data points are mapped non-linearly into a higher-dimensional feature space via a kernel function 

<math display="inline" id="Spectral_clustering:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>k</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>ϕ</mi>
     <mi>T</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>k</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>j</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ϕ</ci>
      <ci>T</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <ci>ϕ</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k(x_{i},x_{j})=\phi^{T}(x_{i})\phi(x_{j})
  </annotation>
 </semantics>
</math>

. The weighted kernel <em>k</em>-means problem further extends this problem by defining a weight 

<math display="inline" id="Spectral_clustering:18">
 <semantics>
  <msub>
   <mi>w</mi>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>w</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{r}
  </annotation>
 </semantics>
</math>

 for each cluster as the reciprocal of the number of elements in the cluster,</p>

<p>

<math display="block" id="Spectral_clustering:19">
 <semantics>
  <mrow>
   <mrow>
    <munder>
     <mi>max</mi>
     <mrow>
      <mo stretchy="false">{</mo>
      <msub>
       <mi>C</mi>
       <mi>s</mi>
      </msub>
      <mo stretchy="false">}</mo>
     </mrow>
    </munder>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>r</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>k</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>w</mi>
       <mi>r</mi>
      </msub>
      <mrow>
       <munder>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mrow>
          <msub>
           <mi>x</mi>
           <mi>i</mi>
          </msub>
          <mo>,</mo>
          <msub>
           <mi>x</mi>
           <mi>j</mi>
          </msub>
         </mrow>
         <mo>∈</mo>
         <msub>
          <mi>C</mi>
          <mi>r</mi>
         </msub>
        </mrow>
       </munder>
       <mrow>
        <mi>k</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>x</mi>
          <mi>j</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <max></max>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>s</ci>
      </apply>
     </set>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>r</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>r</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <in></in>
         <list>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>i</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>j</ci>
          </apply>
         </list>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>C</ci>
          <ci>r</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>k</ci>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>j</ci>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max_{\{C_{s}\}}\sum_{r=1}^{k}w_{r}\sum_{x_{i},x_{j}\in C_{r}}k(x_{i},x_{j}).
  </annotation>
 </semantics>
</math>

 Suppose 

<math display="inline" id="Spectral_clustering:20">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 is a matrix of the normalizing coefficients for each point for each cluster 

<math display="inline" id="Spectral_clustering:21">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>w</mi>
    <mi>r</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>w</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{ij}=w_{r}
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Spectral_clustering:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
   </mrow>
   <mo>∈</mo>
   <msub>
    <mi>C</mi>
    <mi>r</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>i</ci>
     <ci>j</ci>
    </list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i,j\in C_{r}
  </annotation>
 </semantics>
</math>

 and zero otherwise. Suppose 

<math display="inline" id="Spectral_clustering:23">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 is the kernel matrix for all points. The weighted kernel <em>k</em>-means problem with n points and k clusters is given as,</p>

<p>

<math display="block" id="Spectral_clustering:24">
 <semantics>
  <mrow>
   <munder>
    <mi>max</mi>
    <mi>F</mi>
   </munder>
   <mrow>
    <mo>trace</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>K</mi>
      <mi>F</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <max></max>
     <ci>F</ci>
    </apply>
    <apply>
     <ci>trace</ci>
     <apply>
      <times></times>
      <ci>K</ci>
      <ci>F</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max_{F}\operatorname{trace}\left(KF\right)
  </annotation>
 </semantics>
</math>

 such that,</p>

<p>

<math display="block" id="Spectral_clustering:25">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>G</mi>
     <mrow>
      <mi>n</mi>
      <mo>×</mo>
      <mi>k</mi>
     </mrow>
    </msub>
    <msubsup>
     <mi>G</mi>
     <mrow>
      <mi>n</mi>
      <mo>×</mo>
      <mi>k</mi>
     </mrow>
     <mi>T</mi>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>F</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>G</ci>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F=G_{n\times k}G_{n\times k}^{T}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Spectral_clustering:26">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>G</mi>
     <mi>T</mi>
    </msup>
    <mi>G</mi>
   </mrow>
   <mo>=</mo>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>G</ci>
      <ci>T</ci>
     </apply>
     <ci>G</ci>
    </apply>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{T}G=I
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Spectral_clustering:27">
 <semantics>
  <mrow>
   <mrow>
    <mtext>rank</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>k</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>rank</mtext>
     <ci>G</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{rank}(G)=k
  </annotation>
 </semantics>
</math>

. In addition, there are identity constrains on 

<math display="inline" id="Spectral_clustering:28">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 given by,</p>

<p>

<math display="block" id="Spectral_clustering:29">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mo>⋅</mo>
    <mi>𝕀</mi>
   </mrow>
   <mo>=</mo>
   <mi>𝕀</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <ci>F</ci>
     <ci>𝕀</ci>
    </apply>
    <ci>𝕀</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F\cdot\mathbb{I}=\mathbb{I}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Spectral_clustering:30">
 <semantics>
  <mi>𝕀</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝕀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{I}
  </annotation>
 </semantics>
</math>

 represents a vector of ones.</p>

<p>

<math display="block" id="Spectral_clustering:31">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>F</mi>
     <mi>T</mi>
    </msup>
    <mi>𝕀</mi>
   </mrow>
   <mo>=</mo>
   <mi>𝕀</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <ci>T</ci>
     </apply>
     <ci>𝕀</ci>
    </apply>
    <ci>𝕀</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F^{T}\mathbb{I}=\mathbb{I}
  </annotation>
 </semantics>
</math>

 This problem can be recast as,</p>

<p>

<math display="block" id="Spectral_clustering:32">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munder>
      <mi>max</mi>
      <mi>G</mi>
     </munder>
     <mtext>trace</mtext>
    </mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <msup>
       <mi>G</mi>
       <mi>T</mi>
      </msup>
      <mi>G</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <max></max>
      <ci>G</ci>
     </apply>
     <mtext>trace</mtext>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>G</ci>
      <ci>T</ci>
     </apply>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max_{G}\text{ trace }\left(G^{T}G\right).
  </annotation>
 </semantics>
</math>

 This problem is equivalent to the spectral clustering problem when the identity constraints on 

<math display="inline" id="Spectral_clustering:33">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 are relaxed. In particular, the weighted kernel <em>k</em>-means problem can be reformulated as a spectral clustering (graph partitioning) problem and vice versa. The output of the algorithms are eigenvectors which do not satisfy the identity requirements for indicator variables defined by 

<math display="inline" id="Spectral_clustering:34">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

. Hence, post-processing of the eigenvectors is required for the equivalence between the problems.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Transforming the spectral clustering problem into a weighted kernel <em>k</em>-means problem greatly reduces the computational burden.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Affinity_propagation" title="wikilink">Affinity propagation</a></li>
<li><a href="Kernel_principal_component_analysis" title="wikilink">Kernel principal component analysis</a></li>
<li><a href="Cluster_analysis" title="wikilink">Cluster analysis</a></li>
<li><a href="Spectral_graph_theory" title="wikilink">Spectral graph theory</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Data_clustering_algorithms" title="wikilink">Category:Data clustering algorithms</a> <a href="Category:Algebraic_graph_theory" title="wikilink">Category:Algebraic graph theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Jianbo Shi and Jitendra Malik, <a href="http://www.cs.berkeley.edu/~malik/papers/SM-ncut.pdf">"Normalized Cuts and Image Segmentation"</a>, IEEE Transactions on PAMI, Vol. 22, No. 8, Aug 2000.<a href="#fnref1">↩</a></li>
<li id="fn2">Marina Meilă &amp; Jianbo Shi, "<a href="http://www.citeulike.org/user/mpotamias/article/498897">Learning Segmentation by Random Walks</a>", Neural Information Processing Systems 13 (NIPS 2000), 2001, pp. 873–879.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
