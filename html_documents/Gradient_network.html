<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="106">Gradient network</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Gradient network</h1>
<hr/>

<p>A <strong>gradient network</strong> is a directed <a class="uri" href="subnetwork" title="wikilink">subnetwork</a> of an undirected "substrate" <a href="computer_network" title="wikilink">network</a> in which each <a href="node_(networking)" title="wikilink">node</a> has an associated scalar potential and one out-link that point to the node with the smallest (or largest) potential in its neighborhood, defined as the reunion of itself and its nearest neighbors on the substrate networks.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Let us consider that transport takes place on a fixed network <em>G</em> = <em>G</em>(<em>V</em>,<em>E</em>) called the substrate graph. It has N nodes, V = {0, 1, ...,N − 1} and the set of edges <em>E</em> = { (<em>i</em>,<em>j</em>) | <em>i</em>,<em>j</em> ∈ <em>V</em>}. Given a node <em>i</em>, we can define its set of neighbors in G by S<sub>i</sub><sup>(1)</sup> = {j ∈ V | (i,j)∈ E}. </p>

<p>Let us also consider a scalar field, <em>h</em> = {<em>h</em><sub>0</sub>, .., <em>h</em><sub><em>N</em>−1</sub>} defined on the set of nodes V, so that every node i has a scalar value <em>h</em><sub><em>i</em></sub> associated to it.</p>

<p><strong>Gradient ∇<em>h</em><sub><em>i</em></sub> on a network</strong>: <strong>∇h</strong><em><sub>i</sub><strong>

<math display="inline" id="Gradient_network:0">
 <semantics>
  <mo>=</mo>
  <annotation-xml encoding="MathML-Content">
   <eq></eq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =
  </annotation>
 </semantics>
</math>

(i, μ(i))</strong></em> i.e. the directed edge from <em>i</em> to <em>μ(i)</em>, where <em>μ</em>(<em>i</em>) ∈ S<sub>i</sub><sup>(1)</sup> ∪ {i}, and h<sub>μ</sub> has the maximum value in 

<math display="inline" id="Gradient_network:1">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mi>j</mi>
   </msub>
   <mo stretchy="false">|</mo>
   <mi>j</mi>
   <mo>∈</mo>
   <msubsup>
    <mi>S</mi>
    <mi>i</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo>∪</mo>
   <mi>i</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>j</ci>
    </apply>
    <ci>normal-|</ci>
    <csymbol cd="unknown">j</csymbol>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <ci>i</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <union></union>
    <csymbol cd="unknown">i</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {h_{j}|j\in S_{i}^{(1)}\cup{i}}
  </annotation>
 </semantics>
</math>

.</p>

<p><strong><em>Gradient network</em></strong> : <strong><em>∇

<math display="inline" id="Gradient_network:2">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=
  </annotation>
 </semantics>
</math>

 ∇

<math display="inline" id="Gradient_network:3">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Gradient_network:4">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>V</mi>
   <mo>,</mo>
   <mi>F</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>V</ci>
    <ci>F</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (V,F)
  </annotation>
 </semantics>
</math>

</em></strong> where <em>F</em> is the set of gradient edges on <em>G</em>.</p>

<p>In general, the scalar field depends on time, due to the flow, external sources and sinks on the network. Therefore, the gradient network ∇

<math display="inline" id="Gradient_network:5">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 will be dynamic.</p>
<h2 id="motivation">Motivation</h2>

<p>Real-world networks evolve to fulfill a main function, which is often to transport entities such as information, cars, power, water, etc. All these large-scale networks mentioned above are non-globally designed. They evolve and grow through local changes, through a natural selection-like dynamics. For example, if a <a href="Router_(computing)" title="wikilink">router</a> on the Internet is frequently congested and packets are lost or delayed due to that, it will get replaced by several interconnected new routers. Recent research investigate the connection between <a href="network_topology" title="wikilink">network topology</a> and the flow efficiency of the transportation.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>The flow is often generated or influenced by local gradients of a scalar, for example: electric current driven by a gradient of electric potential; in the information networks, properties of nodes will generate a bias in the way of information is transmitted from a node to its neighbors. This idea motivated the approach through gradient networks which studies flow efficiency on the network when the flow is driven by gradients of a <a href="scalar_field" title="wikilink">scalar field</a> distributed on the network<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<figure><b>(Figure)</b>
<figcaption>Fig.2. The gradient at node i is a directed edge pointing towards the largest increase of the scalar potential in the node's neighborhood.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></figcaption>
</figure>
<h2 id="in-degree-distribution-of-gradient-networks">In-degree distribution of gradient networks</h2>

<p>In a gradient network, <em>in-degree</em> of a node i, <em>k<sub>i</sub> <sup>(in)</sup></em> is the number of gradient edges pointing into i, and the in-degree distribution <em><em>'

<math display="inline" id="Gradient_network:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>l</ci>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(l)=P
  </annotation>
 </semantics>
</math>

</em>{</em>k<sub>i</sub> <sup>(in)</sup>

<math display="inline" id="Gradient_network:7">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>=</mo>
   <mi>l</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =l
  </annotation>
 </semantics>
</math>

<em>}</em> <em>'</em>  When the substrate G is random graph, and each pair of nodes is connected with probability <em>P</em>, the scalars '' h<sub>i</sub>'' are i.i.d. (independent identically distributed) the exact expression for <strong><em>R(l)</em></strong> is given by</p>
<center>

<p>

<math display="inline" id="Gradient_network:8">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>l</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mi>N</mi>
   </mfrac>
   <msubsup>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>n</mi>
     <mo>=</mo>
     <mn>0</mn>
    </mrow>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msubsup>
   <msubsup>
    <mi mathvariant="normal">C</mi>
    <mi>l</mi>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
     <mo>-</mo>
     <mi>n</mi>
    </mrow>
   </msubsup>
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>1</mn>
     <mo>-</mo>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo>-</mo>
      <mi>p</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mrow>
     <mi>N</mi>
     <mo>-</mo>
     <mn>1</mn>
     <mo>-</mo>
     <mi>n</mi>
     <mo>-</mo>
     <mi>l</mi>
    </mrow>
   </msup>
   <msup>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>p</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mn>1</mn>
       <mo>-</mo>
       <mi>p</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>n</mi>
     </msup>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>l</mi>
   </msup>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">R</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">l</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>N</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>n</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-C</ci>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <cn type="integer">1</cn>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>l</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <cn type="integer">1</cn>
      <minus></minus>
      <csymbol cd="unknown">p</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <cn type="integer">1</cn>
       <minus></minus>
       <csymbol cd="unknown">p</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-]</ci>
     </cerror>
     <apply>
      <minus></minus>
      <ci>N</ci>
      <cn type="integer">1</cn>
      <ci>n</ci>
      <ci>l</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">p</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <cn type="integer">1</cn>
        <minus></minus>
        <csymbol cd="unknown">p</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>n</ci>
      </apply>
      <ci>normal-]</ci>
     </cerror>
     <ci>l</ci>
    </apply>
    <ci>normal-]</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(l)=\frac{1}{N}\sum_{n=0}^{N-1}\mathrm{C}^{N-1-n}_{l}[1-p(1-p)]^{N-1-n-l}[p(1%
-p)^{n}]^{l}]
  </annotation>
 </semantics>
</math>

</p>
</center>

<p>In the limit <em>'</em> N →∞ <em>'</em> and <strong><em>P → 0</em></strong>, the degree distribution becomes the power law</p>
<center>

<p>

<math display="inline" id="Gradient_network:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <msup>
    <mi>l</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>R</ci>
     <ci>l</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>l</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(l)\approx l^{-1}
  </annotation>
 </semantics>
</math>

</p>
</center>

<p>This shows in this limit, the gradient network of random network is scale-free. If the subtstrate network G is scale-free, like BA model, then the gradient network also follow the power-law with the same exponent as those of G.</p>
<h2 id="the-congestion-on-networks">The congestion on networks</h2>

<p>The fact that topology of substrate network influence the level of congestion can be illustrated by simple example(Fig.6.) as following: if the network has a star-like structure, then at the central node, the flow would congeste because the central node should handle all flow from others nodes. On the contrary, if the network has a ring-like structure, since every node take same role for transportation there is no traffic jam of flow. </p>

<p>Under assumption that the flow is generated by gradients in the network, characterize efficiency of flow on networks can be characterized through the jamming factor(or congestion factor) defined as:</p>

<p>

<math display="block" id="Gradient_network:10">
 <semantics>
  <mrow>
   <mi>J</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <msub>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <msub>
       <mrow>
        <mo stretchy="false">⟨</mo>
        <mfrac>
         <msub>
          <mi>N</mi>
          <mtext>receive</mtext>
         </msub>
         <msub>
          <mi>N</mi>
          <mtext>send</mtext>
         </msub>
        </mfrac>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mi>h</mi>
      </msub>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mtext>network</mtext>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>R</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>J</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="latexml">delimited-⟨⟩</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="latexml">delimited-⟨⟩</csymbol>
          <apply>
           <divide></divide>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>N</ci>
            <mtext>receive</mtext>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>N</ci>
            <mtext>send</mtext>
           </apply>
          </apply>
         </apply>
         <ci>h</ci>
        </apply>
       </apply>
       <mtext>network</mtext>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>R</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J=1-\langle\langle\frac{N_{\text{receive}}}{N_{\text{send}}}\rangle_{h}\rangle%
_{\text{network}}=R(0)
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>N</em><sub>receive</sub> is the number of nodes that receive gradient flow and N<sub>send</sub> is the number of nodes that send the flow. The value of <em>J</em> is in the range between 0 and 1. <em>J</em> = 0 means no congestion, and <em>J</em> = 1 corresponds to maximal congestion. In the limit N → ∞,and the probability with which two arbitrary nodes are connected is constant, for random network, the congestion factor becomes</p>

<p>

<math display="block" id="Gradient_network:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>J</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo>,</mo>
     <mi>P</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mi>ln</mi>
       <mi>N</mi>
      </mrow>
      <mrow>
       <mi>N</mi>
       <mrow>
        <mi>ln</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mfrac>
          <mn>1</mn>
          <mrow>
           <mn>1</mn>
           <mo>-</mo>
           <mi>P</mi>
          </mrow>
         </mfrac>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mfrac>
     <mrow>
      <mo>[</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mrow>
        <mi>O</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mfrac>
          <mn>1</mn>
          <mi>N</mi>
         </mfrac>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mn>1.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>J</ci>
      <interval closure="open">
       <ci>N</ci>
       <ci>P</ci>
      </interval>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <ln></ln>
         <ci>N</ci>
        </apply>
        <apply>
         <times></times>
         <ci>N</ci>
         <apply>
          <ln></ln>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <apply>
            <minus></minus>
            <cn type="integer">1</cn>
            <ci>P</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <plus></plus>
         <cn type="integer">1</cn>
         <apply>
          <times></times>
          <ci>O</ci>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <ci>N</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <cn type="float">1.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J(N,P)=1-\frac{\ln N}{N\ln(\frac{1}{1-P})}\left[1+O(\frac{1}{N})\right]%
\rightarrow 1.
  </annotation>
 </semantics>
</math>

</p>

<p>This result show that random networks are maximally congested in that limit. On the contrary, for scale-free network, J is always a constant for any N. This conclusion means scale-free networks are not prone to maximal jamming.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> </p>
<h2 id="an-efficient-approach-to-control-congestion">An efficient approach to control congestion</h2>

<p>A key problem in communication networks is to understand how to control congestion and maintain a normal and efficient functioning of the networks.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Zonghua Liu et al. studied the <a href="network_congestion" title="wikilink">network congestion</a> and get the result that congestions are more likely to take place at the nodes with high degrees in networks (See Fig. 8), and an efficient approach of selectively enhancing the message-process capability of a small fraction(e.g. 3%) of nodes is shown to perform just as well as enhancing the capability of all nodes.(See Fig. 9) </p>
<figure><b>(Figure)</b>
<figcaption>Fig. 9 The comparison between the efficient approach (circles) with the capability of top 3% degree nodes enhanced and the normal approach (stars) with the capability of all nodes enhanced. (a) packet-processing capability equals to 0.05, (b) packet-processing capability equals to 0.1. <n> is the average packet number as a function of degree.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></n></figcaption>
</figure>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a class="uri" href="Category:Networks" title="wikilink">Category:Networks</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Bogdan Danila, Congestion-gradient driven transport on complex networks, PHYSICAL REVIEW E 74, 046114(2006)<a href="#fnref1">↩</a></li>
<li id="fn2"><a class="uri" href="http://cnls.lanl.gov/External/people/highlights/Toroczkai_net.pdf">http://cnls.lanl.gov/External/people/highlights/Toroczkai_net.pdf</a><a href="#fnref2">↩</a></li>
<li id="fn3">Z. Toroczkai, B. Kozma, K.E. Bassler, N.W. Hengartner and G. Korniss. Gradient Networks, cond-mat/0408262.<a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5">Z. Toroczkai, K.E. Bassler, Nature, 428, 716 (2004)<a href="#fnref5">↩</a></li>
<li id="fn6">Zonghua Liua, Weichuan Mab, Huan Zhanga, Yin Suna and P.M. Hui, an efficient approach of controlling traffic congestion in scale-free networks, Physica A, Volume 370, Issue 2，2006, Pages 843-853<a href="#fnref6">↩</a></li>
<li id="fn7"></li>
</ol>
</section>
</body>
</html>
