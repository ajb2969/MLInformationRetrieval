<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1059">Monoidal t-norm logic</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Monoidal t-norm logic</h1>
<hr/>

<p><strong>Monoidal t-norm based logic</strong> (or shortly <strong>MTL</strong>), the logic of left-continuous <a href="t-norm" title="wikilink">t-norms</a>, is one of <a href="t-norm_fuzzy_logic" title="wikilink">t-norm fuzzy logics</a>. It belongs to the broader class of <a href="substructural_logic" title="wikilink">substructural logics</a>, or logics of <a href="residuated_lattice" title="wikilink">residuated lattices</a>;<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> it extends the logic of commutative bounded integral residuated lattices (known as Höhle's <a href="monoidal_logic" title="wikilink">monoidal logic</a>, Ono's FL<sub>ew</sub>, or intuitionistic logic without contraction) by the axiom of prelinearity.</p>
<h2 id="motivation">Motivation</h2>

<p><a href="T-norm" title="wikilink">T-norms</a> are binary functions on the real unit interval [0, 1] which are often used to represent a conjunction connective in <a href="fuzzy_logic" title="wikilink">fuzzy logic</a>. Every <em>left-continuous</em> t-norm 

<math display="inline" id="Monoidal_t-norm_logic:0">
 <semantics>
  <mo>*</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *
  </annotation>
 </semantics>
</math>

 has a unique <a href="t-norm#Residuum" title="wikilink">residuum</a>, that is, a function 

<math display="inline" id="Monoidal_t-norm_logic:1">
 <semantics>
  <mo>⇒</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⇒</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Rightarrow
  </annotation>
 </semantics>
</math>

 such that for all <em>x</em>, <em>y</em>, and <em>z</em>,</p>

<p>

<math display="block" id="Monoidal_t-norm_logic:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>*</mo>
    <mi>y</mi>
   </mrow>
   <mo>≤</mo>
   <mi>z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x*y\leq z
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Monoidal_t-norm_logic:3">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≤</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>⇒</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <leq></leq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\leq(y\Rightarrow z).
  </annotation>
 </semantics>
</math>

 The residuum of a left-continuous t-norm can explicitly be defined as</p>

<p>

<math display="block" id="Monoidal_t-norm_logic:4">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>⇒</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mo movablelimits="false">sup</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>z</mi>
    <mo>∣</mo>
    <mi>z</mi>
    <mo>*</mo>
    <mi>x</mi>
    <mo>≤</mo>
    <mi>y</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="latexml">supremum</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">z</csymbol>
     <times></times>
     <csymbol cd="unknown">x</csymbol>
     <leq></leq>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-}</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x\Rightarrow y)=\sup\{z\mid z*x\leq y\}.
  </annotation>
 </semantics>
</math>

 This ensures that the residuum is the largest function such that for all <em>x</em> and <em>y</em>,</p>

<p>

<math display="block" id="Monoidal_t-norm_logic:5">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>*</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>⇒</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≤</mo>
   <mi>y</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <times></times>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <leq></leq>
    <csymbol cd="unknown">y</csymbol>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x*(x\Rightarrow y)\leq y.
  </annotation>
 </semantics>
</math>

 The latter can be interpreted as a fuzzy version of the <a href="modus_ponens" title="wikilink">modus ponens</a> rule of inference. The residuum of a left-continuous t-norm thus can be characterized as the weakest function that makes the fuzzy modus ponens valid, which makes it a suitable truth function for implication in fuzzy logic. Left-continuity of the t-norm is the necessary and sufficient condition for this relationship between a t-norm conjunction and its residual implication to hold.</p>

<p>Truth functions of further propositional connectives can be defined by means of the t-norm and its residuum, for instance the residual negation 

<math display="inline" id="Monoidal_t-norm_logic:6">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>⇒</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <not></not>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-⇒</ci>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg x=(x\Rightarrow 0).
  </annotation>
 </semantics>
</math>

 In this way, the left-continuous t-norm, its residuum, and the truth functions of additional propositional connectives (see the section <em><a href="#Standard_semantics" title="wikilink">Standard semantics</a></em> below) determine the <a href="truth_value" title="wikilink">truth values</a> of complex <a href="propositional_formula" title="wikilink">propositional formulae</a> in [0, 1]. Formulae that always evaluate to 1 are then called <em><a href="tautology_(logic)" title="wikilink">tautologies</a></em> with respect to the given left-continuous t-norm 

<math display="inline" id="Monoidal_t-norm_logic:7">
 <semantics>
  <mrow>
   <mo>*</mo>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *,
  </annotation>
 </semantics>
</math>

 or <em>

<math display="inline" id="Monoidal_t-norm_logic:8">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>*</mo>
   <mtext>-</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <csymbol cd="latexml">absent</csymbol>
    <mtext>-</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *\mbox{-}
  </annotation>
 </semantics>
</math>

tautologies.</em> The set of all 

<math display="inline" id="Monoidal_t-norm_logic:9">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>*</mo>
   <mtext>-</mtext>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <csymbol cd="latexml">absent</csymbol>
    <mtext>-</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *\mbox{-}
  </annotation>
 </semantics>
</math>

tautologies is called the <em>logic</em> of the t-norm 

<math display="inline" id="Monoidal_t-norm_logic:10">
 <semantics>
  <mrow>
   <mo>*</mo>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *,
  </annotation>
 </semantics>
</math>

 since these formulae represent the laws of fuzzy logic (determined by the t-norm) which hold (to degree 1) regardless of the truth degrees of <a href="atomic_formula" title="wikilink">atomic formulae</a>. Some formulae are tautologies with respect to <em>all</em> left-continuous t-norms: they represent general laws of propositional fuzzy logic which are independent of the choice of a particular left-continuous t-norm. These formulae form the logic MTL, which can thus be characterized as the <em>logic of left-continuous t-norms.</em><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="syntax">Syntax</h2>
<h3 id="language">Language</h3>

<p>The language of the propositional logic MTL consists of <a href="countable" title="wikilink">countably</a> many <a href="propositional_variable" title="wikilink">propositional variables</a> and the following primitive <a href="logical_connective" title="wikilink">logical connectives</a>:</p>
<ul>
<li><strong>Implication</strong> 

<math display="inline" id="Monoidal_t-norm_logic:11">
 <semantics>
  <mo>→</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-→</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rightarrow
  </annotation>
 </semantics>
</math>

 (<a href="arity" title="wikilink">binary</a>)</li>
<li><strong>Strong conjunction</strong> 

<math display="inline" id="Monoidal_t-norm_logic:12">
 <semantics>
  <mo>⊗</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">tensor-product</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \otimes
  </annotation>
 </semantics>
</math>

 (binary). The sign &amp; is a more traditional notation for strong conjunction in the literature on fuzzy logic, while the notation 

<math display="inline" id="Monoidal_t-norm_logic:13">
 <semantics>
  <mo>⊗</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">tensor-product</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \otimes
  </annotation>
 </semantics>
</math>

 follows the tradition of substructural logics.</li>
<li><strong>Weak conjunction</strong> 

<math display="inline" id="Monoidal_t-norm_logic:14">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge
  </annotation>
 </semantics>
</math>

 (binary), also called <strong>lattice conjunction</strong> (as it is always realized by the <a href="lattice_(order)" title="wikilink">lattice</a> operation of <a href="meet_(mathematics)" title="wikilink">meet</a> in algebraic semantics). Unlike <a href="basic_fuzzy_logic" title="wikilink">BL</a> and stronger fuzzy logics, weak conjunction is not definable in MTL and has to be included among primitive connectives.</li>
<li><strong>Bottom</strong> 

<math display="inline" id="Monoidal_t-norm_logic:15">
 <semantics>
  <mo>⊥</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">bottom</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bot
  </annotation>
 </semantics>
</math>

 (<a class="uri" href="nullary" title="wikilink">nullary</a> — a <a href="propositional_constant" title="wikilink">propositional constant</a>); 

<math display="inline" id="Monoidal_t-norm_logic:16">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 or 

<math display="inline" id="Monoidal_t-norm_logic:17">
 <semantics>
  <mover accent="true">
   <mn>0</mn>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{0}
  </annotation>
 </semantics>
</math>

 are common alternative signs and <strong>zero</strong> a common alternative name for the propositional constant (as the constants bottom and zero of substructural logics coincide in MTL).</li>
</ul>

<p>The following are the most common defined logical connectives:</p>
<ul>
<li><strong>Negation</strong> 

<math display="inline" id="Monoidal_t-norm_logic:18">
 <semantics>
  <mi mathvariant="normal">¬</mi>
  <annotation-xml encoding="MathML-Content">
   <not></not>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg
  </annotation>
 </semantics>
</math>

 (<a href="unary_operation" title="wikilink">unary</a>), defined as</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Monoidal_t-norm_logic:19">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>A</mi>
   </mrow>
   <mo>≡</mo>
   <mi>A</mi>
   <mo>→</mo>
   <mo>⊥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <times></times>
      <not></not>
      <ci>A</ci>
     </apply>
     <ci>A</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <csymbol cd="latexml">bottom</csymbol>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg A\equiv A\rightarrow\bot
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<ul>
<li><strong>Equivalence</strong> 

<math display="inline" id="Monoidal_t-norm_logic:20">
 <semantics>
  <mo>↔</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftrightarrow
  </annotation>
 </semantics>
</math>

 (binary), defined as</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Monoidal_t-norm_logic:21">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>↔</mo>
   <mi>B</mi>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>→</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-↔</ci>
    <csymbol cd="unknown">B</csymbol>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\leftrightarrow B\equiv(A\rightarrow B)\wedge(B\rightarrow A)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>In MTL, the definition is equivalent to 

<math display="inline" id="Monoidal_t-norm_logic:22">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>⊗</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>→</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">tensor-product</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (A\rightarrow B)\otimes(B\rightarrow A).
  </annotation>
 </semantics>
</math>


</dd>
</dl>
<ul>
<li><strong>(Weak) disjunction</strong> 

<math display="inline" id="Monoidal_t-norm_logic:23">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vee
  </annotation>
 </semantics>
</math>

 (binary), also called <strong>lattice disjunction</strong> (as it is always realized by the <a href="lattice_(order)" title="wikilink">lattice</a> operation of <a href="join_(mathematics)" title="wikilink">join</a> in algebraic semantics), defined as</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Monoidal_t-norm_logic:24">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∨</mo>
   <mi>B</mi>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>→</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo>→</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">A</csymbol>
    <or></or>
    <csymbol cd="unknown">B</csymbol>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\vee B\equiv((A\rightarrow B)\rightarrow B)\wedge((B\rightarrow A)\rightarrow
A)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<ul>
<li><strong>Top</strong> 

<math display="inline" id="Monoidal_t-norm_logic:25">
 <semantics>
  <mo>⊤</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">top</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \top
  </annotation>
 </semantics>
</math>

 (nullary), also called <strong>one</strong> and denoted by 

<math display="inline" id="Monoidal_t-norm_logic:26">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Monoidal_t-norm_logic:27">
 <semantics>
  <mover accent="true">
   <mn>1</mn>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{1}
  </annotation>
 </semantics>
</math>

 (as the constants top and zero of substructural logics coincide in MTL), defined as</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Monoidal_t-norm_logic:28">
 <semantics>
  <mrow>
   <mo>⊤</mo>
   <mo>≡</mo>
   <mo>⊥</mo>
   <mo>→</mo>
   <mo>⊥</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <csymbol cd="latexml">top</csymbol>
    <equivalent></equivalent>
    <csymbol cd="latexml">bottom</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="latexml">bottom</csymbol>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \top\equiv\bot\rightarrow\bot
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p><a href="Well-formed_formula" title="wikilink">Well-formed formulae</a> of MTL are defined as usual in <a href="propositional_logic" title="wikilink">propositional logics</a>. In order to save parentheses, it is common to use the following order of precedence:</p>
<ul>
<li>Unary connectives (bind most closely)</li>
<li>Binary connectives other than implication and equivalence</li>
<li>Implication and equivalence (bind most loosely)</li>
</ul>
<h3 id="axioms">Axioms</h3>

<p>A <a href="Hilbert-style_deduction_system" title="wikilink">Hilbert-style deduction system</a> for MTL has been introduced by Esteva and Godo (2001). Its single derivation rule is <a href="modus_ponens" title="wikilink">modus ponens</a>:</p>
<dl>
<dd>from 

<math display="inline" id="Monoidal_t-norm_logic:29">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Monoidal_t-norm_logic:30">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>→</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\rightarrow B
  </annotation>
 </semantics>
</math>

 derive 

<math display="inline" id="Monoidal_t-norm_logic:31">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B.
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>The following are its <a href="axiom_scheme" title="wikilink">axiom schemata</a>:</p>

<p>

<math display="block" id="Monoidal_t-norm_logic:32">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>MTL1</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo>→</mo>
       <mi>B</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>→</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>B</mi>
        <mo>→</mo>
        <mi>C</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>→</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo>→</mo>
        <mi>C</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>MTL2</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mi>A</mi>
       <mo>⊗</mo>
       <mi>B</mi>
      </mrow>
      <mo>→</mo>
      <mi>A</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>MTL3</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mi>A</mi>
       <mo>⊗</mo>
       <mi>B</mi>
      </mrow>
      <mo>→</mo>
      <mrow>
       <mi>B</mi>
       <mo>⊗</mo>
       <mi>A</mi>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>MTL4a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mi>A</mi>
       <mo>∧</mo>
       <mi>B</mi>
      </mrow>
      <mo>→</mo>
      <mi>A</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>MTL4b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mi>A</mi>
       <mo>∧</mo>
       <mi>B</mi>
      </mrow>
      <mo>→</mo>
      <mrow>
       <mi>B</mi>
       <mo>∧</mo>
       <mi>A</mi>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>MTL4c</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mi>A</mi>
      <mo>⊗</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo>→</mo>
       <mi>B</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>→</mo>
      <mi>A</mi>
      <mo>∧</mo>
      <mi>B</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>MTL5a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo>→</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>B</mi>
        <mo>→</mo>
        <mi>C</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>→</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo>⊗</mo>
       <mi>B</mi>
       <mo>→</mo>
       <mi>C</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>MTL5b</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo>⊗</mo>
       <mi>B</mi>
       <mo>→</mo>
       <mi>C</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>→</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo>→</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>B</mi>
        <mo>→</mo>
        <mi>C</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>MTL6</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo>→</mo>
        <mi>B</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>→</mo>
       <mi>C</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>→</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>B</mi>
         <mo>→</mo>
         <mi>A</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo>→</mo>
        <mi>C</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>→</mo>
       <mi>C</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>MTL7</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>:</mo>
      <mi></mi>
     </mrow>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mo>⊥</mo>
      <mo>→</mo>
      <mi>A</mi>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <ci>MTL1</ci>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-→</ci>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">B</csymbol>
        <ci>normal-→</ci>
        <csymbol cd="unknown">C</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-→</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">A</csymbol>
        <ci>normal-→</ci>
        <csymbol cd="unknown">C</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <ci>MTL2</ci>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
      <ci>A</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <ci>MTL3</ci>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>B</ci>
       <ci>A</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <ci>MTL4a</ci>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <and></and>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
      <ci>A</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <ci>MTL4b</ci>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <and></and>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
      <apply>
       <and></and>
       <ci>B</ci>
       <ci>A</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <ci>MTL4c</ci>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">A</csymbol>
      <csymbol cd="latexml">tensor-product</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-→</ci>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <csymbol cd="unknown">A</csymbol>
      <and></and>
      <csymbol cd="unknown">B</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <ci>MTL5a</ci>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-→</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">B</csymbol>
        <ci>normal-→</ci>
        <csymbol cd="unknown">C</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">A</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-→</ci>
       <csymbol cd="unknown">C</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <ci>MTL5b</ci>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">A</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-→</ci>
       <csymbol cd="unknown">C</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-→</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">B</csymbol>
        <ci>normal-→</ci>
        <csymbol cd="unknown">C</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <ci>MTL6</ci>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">A</csymbol>
        <ci>normal-→</ci>
        <csymbol cd="unknown">B</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-→</ci>
       <csymbol cd="unknown">C</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <cerror>
         <csymbol cd="ambiguous">fragments</csymbol>
         <ci>normal-(</ci>
         <csymbol cd="unknown">B</csymbol>
         <ci>normal-→</ci>
         <csymbol cd="unknown">A</csymbol>
         <ci>normal-)</ci>
        </cerror>
        <ci>normal-→</ci>
        <csymbol cd="unknown">C</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-→</ci>
       <csymbol cd="unknown">C</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <ci>normal-:</ci>
      <ci>MTL7</ci>
      <csymbol cd="latexml">absent</csymbol>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="latexml">bottom</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">A</csymbol>
     </cerror>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{ll}{\rm(MTL1)}\colon&(A\rightarrow B)\rightarrow((B\rightarrow
C%
)\rightarrow(A\rightarrow C))\\
{\rm(MTL2)}\colon&A\otimes B\rightarrow A\\
{\rm(MTL3)}\colon&A\otimes B\rightarrow B\otimes A\\
{\rm(MTL4a)}\colon&A\wedge B\rightarrow A\\
{\rm(MTL4b)}\colon&A\wedge B\rightarrow B\wedge A\\
{\rm(MTL4c)}\colon&A\otimes(A\rightarrow B)\rightarrow A\wedge B\\
{\rm(MTL5a)}\colon&(A\rightarrow(B\rightarrow C))\rightarrow(A\otimes B%
\rightarrow C)\\
{\rm(MTL5b)}\colon&(A\otimes B\rightarrow C)\rightarrow(A\rightarrow(B%
\rightarrow C))\\
{\rm(MTL6)}\colon&((A\rightarrow B)\rightarrow C)\rightarrow(((B\rightarrow A)%
\rightarrow C)\rightarrow C)\\
{\rm(MTL7)}\colon&\bot\rightarrow A\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>The traditional numbering of axioms, given in the left column, is derived from the numbering of axioms of Hájek's <a href="basic_fuzzy_logic" title="wikilink">basic fuzzy logic</a> BL.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The axioms (MTL4a)–(MTL4c) replace the axiom of <em>divisibility</em> (BL4) of BL. The axioms (MTL5a) and (MTL5b) express the law of <a href="residuated_lattice" title="wikilink">residuation</a> and the axiom (MTL6) corresponds to the condition of <a class="uri" href="prelinearity" title="wikilink">prelinearity</a>. The axioms (MTL2) and (MTL3) of the original axiomatic system were shown to be redundant (Chvalovský, 2012) and (Cintula, 2005). All the other axioms were shown to be independent (Chvalovský, 2012).</p>
<h2 id="semantics">Semantics</h2>

<p>Like in other propositional <a href="t-norm_fuzzy_logics" title="wikilink">t-norm fuzzy logics</a>, <a href="algebraic_semantics_(mathematical_logic)" title="wikilink">algebraic semantics</a> is predominantly used for MTL, with three main classes of <a href="algebraic_structure" title="wikilink">algebras</a> with respect to which the logic is <a href="completeness_(logic)" title="wikilink">complete</a>:</p>
<ul>
<li><strong>General semantics</strong>, formed of all <em>MTL-algebras</em> — that is, all algebras for which the logic is <a href="Soundness_theorem" title="wikilink">sound</a></li>
<li><strong>Linear semantics</strong>, formed of all <em>linear</em> MTL-algebras — that is, all MTL-algebras whose <a href="lattice_(order)" title="wikilink">lattice</a> order is <a href="total_order" title="wikilink">linear</a></li>
<li><strong>Standard semantics</strong>, formed of all <em>standard</em> MTL-algebras — that is, all MTL-algebras whose lattice reduct is the real unit interval [0, 1] with the usual order; they are uniquely determined by the function that interprets strong conjunction, which can be any left-continuous <a class="uri" href="t-norm" title="wikilink">t-norm</a></li>
</ul>
<h3 id="general-semantics">General semantics</h3>
<h4 id="mtl-algebras">MTL-algebras</h4>

<p>Algebras for which the logic MTL is sound are called <em>MTL-algebras.</em> They can be characterized as <em>prelinear commutative bounded integral residuated lattices.</em> In more detail, an algebraic structure 

<math display="inline" id="Monoidal_t-norm_logic:33">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>L</mi>
   <mo>,</mo>
   <mo>∧</mo>
   <mo>,</mo>
   <mo>∨</mo>
   <mo>,</mo>
   <mo>∗</mo>
   <mo>,</mo>
   <mo>⇒</mo>
   <mo>,</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>L</ci>
    <and></and>
    <or></or>
    <ci>normal-∗</ci>
    <ci>normal-⇒</ci>
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (L,\wedge,\vee,\ast,\Rightarrow,0,1)
  </annotation>
 </semantics>
</math>

 is an MTL-algebra if</p>
<ul>
<li>

<math display="inline" id="Monoidal_t-norm_logic:34">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>L</mi>
   <mo>,</mo>
   <mo>∧</mo>
   <mo>,</mo>
   <mo>∨</mo>
   <mo>,</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>L</ci>
    <and></and>
    <or></or>
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (L,\wedge,\vee,0,1)
  </annotation>
 </semantics>
</math>

 is a <a href="lattice_(order)" title="wikilink">bounded lattice</a> with the top element 0 and bottom element 1</li>
<li>

<math display="inline" id="Monoidal_t-norm_logic:35">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>L</mi>
   <mo>,</mo>
   <mo>∗</mo>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>L</ci>
    <ci>normal-∗</ci>
    <cn type="integer">1</cn>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (L,\ast,1)
  </annotation>
 </semantics>
</math>

 is a <a href="Commutativity" title="wikilink">commutative</a> <a class="uri" href="monoid" title="wikilink">monoid</a></li>
<li>

<math display="inline" id="Monoidal_t-norm_logic:36">
 <semantics>
  <mo>∗</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-∗</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ast
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Monoidal_t-norm_logic:37">
 <semantics>
  <mo>⇒</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⇒</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Rightarrow
  </annotation>
 </semantics>
</math>


 form an <a href="Galois_connection" title="wikilink">adjoint pair</a>, that is, 

<math display="inline" id="Monoidal_t-norm_logic:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>z</mi>
    <mo>*</mo>
    <mi>x</mi>
   </mrow>
   <mo>≤</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>z</ci>
     <ci>x</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z*x\leq y
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Monoidal_t-norm_logic:39">
 <semantics>
  <mrow>
   <mrow>
    <mi>z</mi>
    <mo>≤</mo>
    <mi>x</mi>
    <mo>⇒</mo>
    <mi>y</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <ci>z</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z\leq x\Rightarrow y,
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Monoidal_t-norm_logic:40">
 <semantics>
  <mo>≤</mo>
  <annotation-xml encoding="MathML-Content">
   <leq></leq>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq
  </annotation>
 </semantics>
</math>

 is the lattice order of 

<math display="inline" id="Monoidal_t-norm_logic:41">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>L</mi>
    <mo>,</mo>
    <mo>∧</mo>
    <mo>,</mo>
    <mo>∨</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>L</ci>
    <and></and>
    <or></or>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (L,\wedge,\vee),
  </annotation>
 </semantics>
</math>

 for all <em>x</em>, <em>y</em>, and <em>z</em> in 

<math display="inline" id="Monoidal_t-norm_logic:42">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>


, (the <em>residuation</em> condition)</li>
<li>

<math display="inline" id="Monoidal_t-norm_logic:43">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>⇒</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∨</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>⇒</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <or></or>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">1</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x\Rightarrow y)\vee(y\Rightarrow x)=1
  </annotation>
 </semantics>
</math>

 holds for all <em>x</em> and <em>y</em> in <em>L</em> (the <em>prelinearity</em> condition)</li>
</ul>

<p>Important examples of MTL algebras are <em>standard</em> MTL-algebras on the real unit interval [0, 1]. Further examples include all <a href="Boolean_algebra_(structure)" title="wikilink">Boolean algebras</a>, all linear <a href="Heyting_algebra" title="wikilink">Heyting algebras</a> (both with 

<math display="inline" id="Monoidal_t-norm_logic:44">
 <semantics>
  <mrow>
   <mo>∗</mo>
   <mo>=</mo>
   <mo>∧</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>normal-∗</ci>
    <eq></eq>
    <and></and>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ast=\wedge
  </annotation>
 </semantics>
</math>

), all <a href="MV-algebra" title="wikilink">MV-algebras</a>, all <a href="BL_(logic)" title="wikilink">BL</a>-algebras, etc. Since the residuation condition can equivalently be expressed by identities,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> MTL-algebras form a <a href="variety_(universal_algebra)" title="wikilink">variety</a>.</p>
<h4 id="interpretation-of-the-logic-mtl-in-mtl-algebras">Interpretation of the logic MTL in MTL-algebras</h4>

<p>The connectives of MTL are interpreted in MTL-algebras as follows:</p>
<ul>
<li>Strong conjunction by the monoidal operation 

<math display="inline" id="Monoidal_t-norm_logic:45">
 <semantics>
  <mo>∗</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-∗</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ast
  </annotation>
 </semantics>
</math>

</li>
<li>Implication by the operation 

<math display="inline" id="Monoidal_t-norm_logic:46">
 <semantics>
  <mo>⇒</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⇒</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Rightarrow
  </annotation>
 </semantics>
</math>

 (which is called the <em>residuum</em> of 

<math display="inline" id="Monoidal_t-norm_logic:47">
 <semantics>
  <mo>∗</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-∗</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ast
  </annotation>
 </semantics>
</math>


)</li>
<li>Weak conjunction and weak disjunction by the lattice operations 

<math display="inline" id="Monoidal_t-norm_logic:48">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Monoidal_t-norm_logic:49">
 <semantics>
  <mrow>
   <mo>∨</mo>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vee,
  </annotation>
 </semantics>
</math>

 respectively (usually denoted by the same symbols as the connectives, if no confusion can arise)</li>
<li>The truth constants zero (top) and one (bottom) by the constants 0 and 1</li>
<li>The equivalence connective is interpreted by the operation 

<math display="inline" id="Monoidal_t-norm_logic:50">
 <semantics>
  <mo>⇔</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⇔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Leftrightarrow
  </annotation>
 </semantics>
</math>

 defined as</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Monoidal_t-norm_logic:51">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>⇔</mo>
   <mi>y</mi>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>⇒</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>⇒</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-⇔</ci>
    <csymbol cd="unknown">y</csymbol>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\Leftrightarrow y\equiv(x\Rightarrow y)\wedge(y\Rightarrow x)
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
<dd>Due to the prelinearity condition, this definition is equivalent to one that uses 

<math display="inline" id="Monoidal_t-norm_logic:52">
 <semantics>
  <mo>∗</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-∗</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ast
  </annotation>
 </semantics>
</math>


 instead of 

<math display="inline" id="Monoidal_t-norm_logic:53">
 <semantics>
  <mrow>
   <mo>∧</mo>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge,
  </annotation>
 </semantics>
</math>

 thus

<p>

<math display="block" id="Monoidal_t-norm_logic:54">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>⇔</mo>
   <mi>y</mi>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>⇒</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∗</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo>⇒</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-⇔</ci>
    <csymbol cd="unknown">y</csymbol>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-∗</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\Leftrightarrow y\equiv(x\Rightarrow y)\ast(y\Rightarrow x)
  </annotation>
 </semantics>
</math>

</p>
</dd>
</dl>
<ul>
<li>Negation is interpreted by the definable operation 

<math display="inline" id="Monoidal_t-norm_logic:55">
 <semantics>
  <mrow>
   <mrow>
    <mo>-</mo>
    <mi>x</mi>
   </mrow>
   <mo>≡</mo>
   <mi>x</mi>
   <mo>⇒</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <minus></minus>
      <ci>x</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -x\equiv x\Rightarrow 0
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>With this interpretation of connectives, any evaluation <em>e</em><sub>v</sub> of propositional variables in <em>L</em> uniquely extends to an evaluation <em>e</em> of all well-formed formulae of MTL, by the following inductive definition (which generalizes <a href="Semantic_theory_of_truth" title="wikilink">Tarski's truth conditions</a>), for any formulae <em>A</em>, <em>B</em>, and any propositional variable <em>p</em>:</p>

<p>

<math display="block" id="Monoidal_t-norm_logic:56">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mi>e</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>p</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <msub>
       <mi>e</mi>
       <mi mathvariant="normal">v</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>p</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mi>e</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mo>⊥</mo>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mn>0</mn>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mi>e</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mo>⊤</mo>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mn>1</mn>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mi>e</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>A</mi>
        <mo>⊗</mo>
        <mi>B</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mrow>
        <mi>e</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>A</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>∗</mo>
       <mi>e</mi>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>B</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mi>e</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo>→</mo>
       <mi>B</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mi>e</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⇒</mo>
      <mrow>
       <mi>e</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>B</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mi>e</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>A</mi>
        <mo>∧</mo>
        <mi>B</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mi>e</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>∧</mo>
      <mrow>
       <mi>e</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>B</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mi>e</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>A</mi>
        <mo>∨</mo>
        <mi>B</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mi>e</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>∨</mo>
      <mrow>
       <mi>e</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>B</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mi>e</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>A</mi>
       <mo>↔</mo>
       <mi>B</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mi>e</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⇔</mo>
      <mrow>
       <mi>e</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>B</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mi>e</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi mathvariant="normal">¬</mi>
        <mi>A</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>=</mo>
    </mtd>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mi>e</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⇒</mo>
      <mn>0</mn>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <times></times>
      <ci>e</ci>
      <ci>p</ci>
     </apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>normal-v</ci>
      </apply>
      <ci>p</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <times></times>
      <ci>e</ci>
      <csymbol cd="latexml">bottom</csymbol>
     </apply>
     <eq></eq>
     <cn type="integer">0</cn>
    </matrixrow>
    <matrixrow>
     <apply>
      <times></times>
      <ci>e</ci>
      <csymbol cd="latexml">top</csymbol>
     </apply>
     <eq></eq>
     <cn type="integer">1</cn>
    </matrixrow>
    <matrixrow>
     <apply>
      <times></times>
      <ci>e</ci>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <ci>normal-∗</ci>
       <apply>
        <times></times>
        <ci>e</ci>
        <ci>A</ci>
       </apply>
       <ci>e</ci>
      </apply>
      <ci>B</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">e</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-→</ci>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <eq></eq>
     <apply>
      <ci>normal-⇒</ci>
      <apply>
       <times></times>
       <ci>e</ci>
       <ci>A</ci>
      </apply>
      <apply>
       <times></times>
       <ci>e</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <times></times>
      <ci>e</ci>
      <apply>
       <and></and>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <eq></eq>
     <apply>
      <and></and>
      <apply>
       <times></times>
       <ci>e</ci>
       <ci>A</ci>
      </apply>
      <apply>
       <times></times>
       <ci>e</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <times></times>
      <ci>e</ci>
      <apply>
       <or></or>
       <ci>A</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <eq></eq>
     <apply>
      <or></or>
      <apply>
       <times></times>
       <ci>e</ci>
       <ci>A</ci>
      </apply>
      <apply>
       <times></times>
       <ci>e</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <csymbol cd="unknown">e</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">A</csymbol>
       <ci>normal-↔</ci>
       <csymbol cd="unknown">B</csymbol>
       <ci>normal-)</ci>
      </cerror>
     </cerror>
     <eq></eq>
     <apply>
      <ci>normal-⇔</ci>
      <apply>
       <times></times>
       <ci>e</ci>
       <ci>A</ci>
      </apply>
      <apply>
       <times></times>
       <ci>e</ci>
       <ci>B</ci>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <times></times>
      <ci>e</ci>
      <apply>
       <times></times>
       <not></not>
       <ci>A</ci>
      </apply>
     </apply>
     <eq></eq>
     <apply>
      <ci>normal-⇒</ci>
      <apply>
       <times></times>
       <ci>e</ci>
       <ci>A</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{rcl}e(p)&=&e_{\mathrm{v}}(p)\\
e(\bot)&=&0\\
e(\top)&=&1\\
e(A\otimes B)&=&e(A)\ast e(B)\\
e(A\rightarrow B)&=&e(A)\Rightarrow e(B)\\
e(A\wedge B)&=&e(A)\wedge e(B)\\
e(A\vee B)&=&e(A)\vee e(B)\\
e(A\leftrightarrow B)&=&e(A)\Leftrightarrow e(B)\\
e(\neg A)&=&e(A)\Rightarrow 0\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>Informally, the truth value 1 represents full truth and the truth value 0 represents full falsity; intermediate truth values represent intermediate degrees of truth. Thus a formula is considered fully true under an evaluation <em>e</em> if <em>e</em>(<em>A</em>) = 1. A formula <em>A</em> is said to be <em>valid</em> in an MTL-algebra <em>L</em> if it is fully true under all evaluations in <em>L</em>, that is, if <em>e</em>(<em>A</em>) = 1 for all evaluations <em>e</em> in <em>L</em>. Some formulae (for instance, <em>p</em> → <em>p</em>) are valid in any MTL-algebra; these are called <em>tautologies</em> of MTL.</p>

<p>The notion of global <a class="uri" href="entailment" title="wikilink">entailment</a> (or: global <a href="consequence_relation" title="wikilink">consequence</a>) is defined for MTL as follows: a set of formulae Γ entails a formula <em>A</em> (or: <em>A</em> is a global consequence of Γ), in symbols 

<math display="inline" id="Monoidal_t-norm_logic:57">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Γ</mi>
    <mo>⊧</mo>
    <mi>A</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">models</csymbol>
    <ci>normal-Γ</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Gamma\models A,
  </annotation>
 </semantics>
</math>

 if for any evaluation <em>e</em> in any MTL-algebra, whenever <em>e</em>(<em>B</em>) = 1 for all formulae <em>B</em> in Γ, then also <em>e</em>(<em>A</em>) = 1. Informally, the global consequence relation represents the transmission of full truth in any MTL-algebra of truth values.</p>
<h4 id="general-soundness-and-completeness-theorems">General soundness and completeness theorems</h4>

<p>The logic MTL is <a href="soundness_theorem" title="wikilink">sound</a> and <a href="completeness_(logic)" title="wikilink">complete</a> with respect to the class of all MTL-algebras (Esteva &amp; Godo, 2001):</p>
<dl>
<dd>A formula is provable in MTL if and only if it is valid in all MTL-algebras.
</dd>
</dl>

<p>The notion of MTL-algebra is in fact so defined that MTL-algebras form the class of <em>all</em> algebras for which the logic MTL is sound. Furthermore, the <em>strong completeness theorem</em> holds:<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<dl>
<dd>A formula <em>A</em> is a global consequence in MTL of a set of formulae Γ if and only if <em>A</em> is derivable from Γ in MTL.
</dd>
</dl>
<h3 id="linear-semantics">Linear semantics</h3>

<p>Like algebras for other fuzzy logics,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> MTL-algebras enjoy the following <em>linear subdirect decomposition property</em>:</p>
<dl>
<dd>Every MTL-algebra is a subdirect product of linearly ordered MTL-algebras.
</dd>
</dl>

<p>(A <em>subdirect product</em> is a subalgebra of the <a href="direct_product" title="wikilink">direct product</a> such that all <a href="projection_(mathematics)" title="wikilink">projection maps</a> are <a href="surjective_function" title="wikilink">surjective</a>. An MTL-algebra is <em>linearly ordered</em> if its <a href="lattice_(order)" title="wikilink">lattice order</a> is <a href="total_order" title="wikilink">linear</a>.)</p>

<p>In consequence of the linear subdirect decomposition property of all MTL-algebras, the <em>completeness theorem with respect to linear MTL-algebras</em> (Esteva &amp; Godo, 2001) holds:</p>
<ul>
<li>A formula is provable in MTL if and only if it is valid in all <em>linear</em> MTL-algebras.</li>
<li>A formula <em>A</em> is derivable in MTL from a set of formulae Γ if and only if <em>A</em> is a global consequence in all <em>linear</em> MTL-algebras of Γ.</li>
</ul>
<h3 id="standard-semantics">Standard semantics</h3>

<p><em>Standard</em> are called those MTL-algebras whose lattice reduct is the real unit interval [0, 1]. They are uniquely determined by the real-valued function that interprets strong conjunction, which can be any left-continuous <a class="uri" href="t-norm" title="wikilink">t-norm</a> 

<math display="inline" id="Monoidal_t-norm_logic:58">
 <semantics>
  <mo>∗</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-∗</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ast
  </annotation>
 </semantics>
</math>

. The standard MTL-algebra determined by a left-continuous t-norm 

<math display="inline" id="Monoidal_t-norm_logic:59">
 <semantics>
  <mo>∗</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-∗</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ast
  </annotation>
 </semantics>
</math>

 is usually denoted by 

<math display="inline" id="Monoidal_t-norm_logic:60">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>∗</mo>
   </msub>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
    <ci>normal-∗</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [0,1]_{\ast}.
  </annotation>
 </semantics>
</math>


 In 

<math display="inline" id="Monoidal_t-norm_logic:61">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>∗</mo>
   </msub>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
    <ci>normal-∗</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [0,1]_{\ast},
  </annotation>
 </semantics>
</math>

 implication is represented by the <a href="t-norm#Residuum" title="wikilink">residuum</a> of 

<math display="inline" id="Monoidal_t-norm_logic:62">
 <semantics>
  <mrow>
   <mo>∗</mo>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-∗</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ast,
  </annotation>
 </semantics>
</math>

 weak conjunction and disjunction respectively by the minimum and maximum, and the truth constants zero and one respectively by the real numbers 0 and 1.</p>

<p>The logic MTL is complete with respect to standard MTL-algebras; this fact is expressed by the <em>standard completeness theorem</em> (Jenei &amp; Montagna, 2002):</p>
<dl>
<dd>A formula is provable in MTL if and only if it is valid in all standard MTL-algebras.
</dd>
</dl>

<p>Since MTL is complete with respect to standard MTL-algebras, which are determined by left-continuous t-norms, MTL is often referred to as the <em>logic of left-continuous t-norms</em> (similarly as <a href="BL_(logic)" title="wikilink">BL</a> is the logic of continuous t-norms).</p>
<h2 id="bibliography">Bibliography</h2>
<ul>
<li>Hájek P., 1998, <em>Metamathematics of Fuzzy Logic</em>. Dordrecht: Kluwer.</li>
<li>Esteva F. &amp; Godo L., 2001, "Monoidal t-norm based logic: Towards a logic of left-continuous t-norms". <em>Fuzzy Sets and Systems</em> <strong>124</strong>: 271–288.</li>
<li>Jenei S. &amp; Montagna F., 2002, "A proof of standard completeness of Esteva and Godo's monoidal logic MTL". <em>Studia Logica</em> <strong>70</strong>: 184–192.</li>
<li>Ono, H., 2003, "Substructural logics and residuated lattices — an introduction". In F.V. Hendricks, J. Malinowski (eds.): Trends in Logic: 50 Years of Studia Logica, <em>Trends in Logic</em> <strong>20</strong>: 177–212.</li>
<li>Cintula P., 2005, "Short note: On the redundancy of axiom (A3) in BL and MTL". <em>Soft Computing</em> <strong>9</strong>: 942.</li>
<li>Cintula P., 2006, "Weakly implicative (fuzzy) logics I: Basic properties". <em>Archive for Mathematical Logic</em> <strong>45</strong>: 673–704.</li>
<li>Chvalovský K., 2012, "<a href="http://karel.chvalovsky.cz/publications/nezavislost.pdf">On the Independence of Axioms in BL and MTL</a>". <em>Fuzzy Sets and Systems</em> <strong>197</strong>: 123–129, .</li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Fuzzy_logic" title="wikilink">Category:Fuzzy logic</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Ono (2003).<a href="#fnref1">↩</a></li>
<li id="fn2">Conjectured by Esteva and Godo who introduced the logic (2001), proved by Jenei and Montagna (2002).<a href="#fnref2">↩</a></li>
<li id="fn3">Hájek (1998), Definition 2.2.4.<a href="#fnref3">↩</a></li>
<li id="fn4">The proof of Lemma 2.3.10 in Hájek (1998) for BL-algebras can easily be adapted to work for MTL-algebras, too.<a href="#fnref4">↩</a></li>
<li id="fn5">A general proof of the strong completeness with respect to all <em>L</em>-algebras for any weakly implicative logic <em>L</em> (which includes MTL) can be found in Cintula (2006).<a href="#fnref5">↩</a></li>
<li id="fn6">Cintula (2006).<a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
