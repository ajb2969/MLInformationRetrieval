<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1450">Event calculus</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Event calculus</h1>
<hr/>

<p>The <strong>event calculus</strong> is a <a href="logic" title="wikilink">logical</a> language for representing and reasoning about events and their effects first presented by <a href="Robert_Kowalski" title="wikilink">Robert Kowalski</a> and <a href="Marek_Sergot" title="wikilink">Marek Sergot</a> in 1986. It was extended by <a href="Murray_Shanahan" title="wikilink">Murray Shanahan</a> and <a href="Rob_Miller" title="wikilink">Rob Miller</a> in the 1990s. Similar to other languages for reasoning about change, the event calculus represents the effects of <a href="Action_(artificial_intelligence)" title="wikilink">actions</a> on <a href="fluent_(artificial_intelligence)" title="wikilink">fluents</a>. However, <a href="Event_(computing)" title="wikilink">events</a> can also be external to the system. In the event calculus, one can specify the value of fluents at some given time points, the events that take place at given time points, and their effects.</p>
<h2 id="fluents-and-events">Fluents and events</h2>

<p>In the event calculus, fluents are <a class="uri" href="reified" title="wikilink">reified</a>. This means that they are not formalized by means of <a href="Predicate_(mathematics)" title="wikilink">predicates</a> but by means of <a href="function_(mathematics)" title="wikilink">functions</a>. A separate predicate 

<math display="inline" id="Event_calculus:0">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mi>o</mi>
   <mi>l</mi>
   <mi>d</mi>
   <mi>s</mi>
   <mi>A</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>o</ci>
    <ci>l</ci>
    <ci>d</ci>
    <ci>s</ci>
    <ci>A</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   HoldsAt
  </annotation>
 </semantics>
</math>

 is used to tell which fluents hold at a given time point. For example, 

<math display="inline" id="Event_calculus:1">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mi>o</mi>
   <mi>l</mi>
   <mi>d</mi>
   <mi>s</mi>
   <mi>A</mi>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>o</mi>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>b</mi>
       <mi>o</mi>
       <mi>x</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>t</mi>
       <mi>a</mi>
       <mi>b</mi>
       <mi>l</mi>
       <mi>e</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>o</ci>
    <ci>l</ci>
    <ci>d</ci>
    <ci>s</ci>
    <ci>A</ci>
    <ci>t</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>n</ci>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>b</ci>
        <ci>o</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <times></times>
        <ci>t</ci>
        <ci>a</ci>
        <ci>b</ci>
        <ci>l</ci>
        <ci>e</ci>
       </apply>
      </interval>
     </apply>
     <ci>t</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   HoldsAt(on(box,table),t)
  </annotation>
 </semantics>
</math>

 means that the box is on the table at time 

<math display="inline" id="Event_calculus:2">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

; in this formula, 

<math display="inline" id="Event_calculus:3">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mi>o</mi>
   <mi>l</mi>
   <mi>d</mi>
   <mi>s</mi>
   <mi>A</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>o</ci>
    <ci>l</ci>
    <ci>d</ci>
    <ci>s</ci>
    <ci>A</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   HoldsAt
  </annotation>
 </semantics>
</math>

 is a predicate while 

<math display="inline" id="Event_calculus:4">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   on
  </annotation>
 </semantics>
</math>

 is a function.</p>

<p>Events are also represented as terms. The effects of events are given using the predicates 

<math display="inline" id="Event_calculus:5">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mi>n</mi>
   <mi>i</mi>
   <mi>t</mi>
   <mi>i</mi>
   <mi>a</mi>
   <mi>t</mi>
   <mi>e</mi>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>n</ci>
    <ci>i</ci>
    <ci>t</ci>
    <ci>i</ci>
    <ci>a</ci>
    <ci>t</ci>
    <ci>e</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Initiates
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Event_calculus:6">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mi>e</mi>
   <mi>r</mi>
   <mi>m</mi>
   <mi>i</mi>
   <mi>n</mi>
   <mi>a</mi>
   <mi>t</mi>
   <mi>e</mi>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>e</ci>
    <ci>r</ci>
    <ci>m</ci>
    <ci>i</ci>
    <ci>n</ci>
    <ci>a</ci>
    <ci>t</ci>
    <ci>e</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Terminates
  </annotation>
 </semantics>
</math>

. In particular, 

<math display="inline" id="Event_calculus:7">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mi>n</mi>
   <mi>i</mi>
   <mi>t</mi>
   <mi>i</mi>
   <mi>a</mi>
   <mi>t</mi>
   <mi>e</mi>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo>,</mo>
    <mi>f</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>n</ci>
    <ci>i</ci>
    <ci>t</ci>
    <ci>i</ci>
    <ci>a</ci>
    <ci>t</ci>
    <ci>e</ci>
    <ci>s</ci>
    <vector>
     <ci>e</ci>
     <ci>f</ci>
     <ci>t</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Initiates(e,f,t)
  </annotation>
 </semantics>
</math>

 means that, if the event represented by the term 

<math display="inline" id="Event_calculus:8">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 is executed at time 

<math display="inline" id="Event_calculus:9">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, then the fluent 

<math display="inline" id="Event_calculus:10">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 will be true after 

<math display="inline" id="Event_calculus:11">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

. The 

<math display="inline" id="Event_calculus:12">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mi>e</mi>
   <mi>r</mi>
   <mi>m</mi>
   <mi>i</mi>
   <mi>n</mi>
   <mi>a</mi>
   <mi>t</mi>
   <mi>e</mi>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>e</ci>
    <ci>r</ci>
    <ci>m</ci>
    <ci>i</ci>
    <ci>n</ci>
    <ci>a</ci>
    <ci>t</ci>
    <ci>e</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Terminates
  </annotation>
 </semantics>
</math>

 predicate has a similar meaning, with the only difference being that 

<math display="inline" id="Event_calculus:13">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 will be false and not true after 

<math display="inline" id="Event_calculus:14">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="domain-independent-axioms">Domain-independent axioms</h2>

<p>Like other languages for representing actions, the event calculus formalizes the correct evolution of the fluent via formulae telling the value of each fluent after an arbitrary action has been performed. The event calculus solves the <a href="frame_problem" title="wikilink">frame problem</a> in a way that is similar to the <a href="successor_state_axiom" title="wikilink">successor state axioms</a> of the <a href="situation_calculus" title="wikilink">situation calculus</a>: a fluent is true at time 

<math display="inline" id="Event_calculus:15">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 if and only if it has been made true in the past and has not been made false in the meantime.</p>

<p>

<math display="inline" id="Event_calculus:16">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 is true at time 

<math display="inline" id="Event_calculus:17">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 if:</p>
<ol>
<li>an event 

<math display="block" id="Event_calculus:18">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mi>a</mi>
   <mi>p</mi>
   <mi>p</mi>
   <mi>e</mi>
   <mi>n</mi>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo>,</mo>
    <msub>
     <mi>t</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>a</ci>
    <ci>p</ci>
    <ci>p</ci>
    <ci>e</ci>
    <ci>n</ci>
    <ci>s</ci>
    <interval closure="open">
     <ci>e</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Happens(e,t_{1})
  </annotation>
 </semantics>
</math>

 has taken place

<math display="inline" id="Event_calculus:19">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

;</li>
<li>this took place in the past:<math>t_1<t math="">;</t></math></li>
<li>this event has the fluent 

<math display="block" id="Event_calculus:20">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mi>n</mi>
   <mi>i</mi>
   <mi>t</mi>
   <mi>i</mi>
   <mi>a</mi>
   <mi>t</mi>
   <mi>e</mi>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo>,</mo>
    <mi>f</mi>
    <mo>,</mo>
    <msub>
     <mi>t</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>n</ci>
    <ci>i</ci>
    <ci>t</ci>
    <ci>i</ci>
    <ci>a</ci>
    <ci>t</ci>
    <ci>e</ci>
    <ci>s</ci>
    <vector>
     <ci>e</ci>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Initiates(e,f,t_{1})
  </annotation>
 </semantics>
</math>

 as an effect

<math display="block" id="Event_calculus:21">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mi>l</mi>
   <mi>i</mi>
   <mi>p</mi>
   <mi>p</mi>
   <mi>e</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>t</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi>f</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>l</ci>
    <ci>i</ci>
    <ci>p</ci>
    <ci>p</ci>
    <ci>e</ci>
    <ci>d</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>f</ci>
     <ci>t</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Clipped(t_{1},f,t)
  </annotation>
 </semantics>
</math>

;</li>
<li>the fluent has not been made false in the meantime

<math display="inline" id="Event_calculus:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mi>a</mi>
    <mi>p</mi>
    <mi>p</mi>
    <mi>e</mi>
    <mi>n</mi>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>e</mi>
     <mo>,</mo>
     <msub>
      <mi>t</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mi>I</mi>
    <mi>n</mi>
    <mi>i</mi>
    <mi>t</mi>
    <mi>i</mi>
    <mi>a</mi>
    <mi>t</mi>
    <mi>e</mi>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>e</mi>
     <mo>,</mo>
     <mi>f</mi>
     <mo>,</mo>
     <msub>
      <mi>t</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>a</ci>
     <ci>p</ci>
     <ci>p</ci>
     <ci>e</ci>
     <ci>n</ci>
     <ci>s</ci>
     <interval closure="open">
      <ci>e</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>I</ci>
     <ci>n</ci>
     <ci>i</ci>
     <ci>t</ci>
     <ci>i</ci>
     <ci>a</ci>
     <ci>t</ci>
     <ci>e</ci>
     <ci>s</ci>
     <vector>
      <ci>e</ci>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Happens(e,t_{1})\wedge Initiates(e,f,t_{1})
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>A similar formula is used to formalize the opposite case in which a fluent is false at a given time. Other formulae are also needed for correctly formalizing fluents before they have been effects of an event. These formulae are similar to the above, but 

<math display="inline" id="Event_calculus:23">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mi>o</mi>
   <mi>l</mi>
   <mi>d</mi>
   <mi>s</mi>
   <mi>A</mi>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo>,</mo>
    <msub>
     <mi>t</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>o</ci>
    <ci>l</ci>
    <ci>d</ci>
    <ci>s</ci>
    <ci>A</ci>
    <ci>t</ci>
    <interval closure="open">
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   HoldsAt(f,t_{1})
  </annotation>
 </semantics>
</math>

 is replaced by 

<math display="inline" id="Event_calculus:24">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mi>l</mi>
   <mi>i</mi>
   <mi>p</mi>
   <mi>p</mi>
   <mi>e</mi>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>l</ci>
    <ci>i</ci>
    <ci>p</ci>
    <ci>p</ci>
    <ci>e</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Clipped
  </annotation>
 </semantics>
</math>

.</p>

<p>The 

<math display="block" id="Event_calculus:25">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mi>l</mi>
   <mi>i</mi>
   <mi>p</mi>
   <mi>p</mi>
   <mi>e</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>t</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi>f</mi>
    <mo>,</mo>
    <msub>
     <mi>t</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≡</mo>
   <mo>∃</mo>
   <mi>e</mi>
   <mo>,</mo>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>H</mi>
    <mi>a</mi>
    <mi>p</mi>
    <mi>p</mi>
    <mi>e</mi>
    <mi>n</mi>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>e</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>t</mi>
      <mn>1</mn>
     </msub>
     <mo>≤</mo>
     <mi>t</mi>
     <mo><</mo>
     <msub>
      <mi>t</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mi>T</mi>
    <mi>e</mi>
    <mi>r</mi>
    <mi>m</mi>
    <mi>i</mi>
    <mi>n</mi>
    <mi>a</mi>
    <mi>t</mi>
    <mi>e</mi>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>e</mi>
     <mo>,</mo>
     <mi>f</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">C</csymbol>
    <csymbol cd="unknown">l</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">d</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <equivalent></equivalent>
    <exists></exists>
    <csymbol cd="unknown">e</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">t</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">H</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <csymbol cd="unknown">s</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">e</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
      <leq></leq>
      <csymbol cd="unknown">t</csymbol>
      <lt></lt>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <csymbol cd="unknown">T</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <csymbol cd="unknown">r</csymbol>
     <csymbol cd="unknown">m</csymbol>
     <csymbol cd="unknown">i</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <csymbol cd="unknown">s</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">e</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">f</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Clipped(t_{1},f,t_{2})\equiv\exists e,t[Happens(e,t)\wedge(t_{1}\leq t<t_{2})%
\wedge Terminates(e,f,t)]
  </annotation>
 </semantics>
</math>

 predicate, stating that a fluent has been made false during an interval, can be axiomatized, or simply taken as a shorthand, as follows:</p>

<p>

<math display="inline" id="Event_calculus:26">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mi>o</mi>
   <mi>l</mi>
   <mi>d</mi>
   <mi>s</mi>
   <mi>A</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>o</ci>
    <ci>l</ci>
    <ci>d</ci>
    <ci>s</ci>
    <ci>A</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   HoldsAt
  </annotation>
 </semantics>
</math>

</p>
<h2 id="domain-dependent-axioms">Domain-dependent axioms</h2>

<p>The axioms above relate the value of the predicates 

<math display="inline" id="Event_calculus:27">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mi>n</mi>
   <mi>i</mi>
   <mi>t</mi>
   <mi>i</mi>
   <mi>a</mi>
   <mi>t</mi>
   <mi>e</mi>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>n</ci>
    <ci>i</ci>
    <ci>t</ci>
    <ci>i</ci>
    <ci>a</ci>
    <ci>t</ci>
    <ci>e</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Initiates
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Event_calculus:28">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mi>e</mi>
   <mi>r</mi>
   <mi>m</mi>
   <mi>i</mi>
   <mi>n</mi>
   <mi>a</mi>
   <mi>t</mi>
   <mi>e</mi>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>e</ci>
    <ci>r</ci>
    <ci>m</ci>
    <ci>i</ci>
    <ci>n</ci>
    <ci>a</ci>
    <ci>t</ci>
    <ci>e</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Terminates
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Event_calculus:29">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mi>o</mi>
   <mi>l</mi>
   <mi>d</mi>
   <mi>s</mi>
   <mi>A</mi>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>o</ci>
    <ci>l</ci>
    <ci>d</ci>
    <ci>s</ci>
    <ci>A</ci>
    <ci>t</ci>
    <interval closure="open">
     <ci>f</ci>
     <ci>t</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   HoldsAt(f,t)
  </annotation>
 </semantics>
</math>

, but do not specify which fluents are known to be true and which events actually make fluents true or false. This is done by using a set of domain-dependent axioms. The known values of fluents are stated as simple literals 

<math display="inline" id="Event_calculus:30">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mi>p</mi>
   <mi>e</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <ci>p</ci>
    <ci>e</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   open
  </annotation>
 </semantics>
</math>

. The effects of events are stated by formulae relating the effects of events with their preconditions. For example, if the event 

<math display="inline" id="Event_calculus:31">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mi>s</mi>
   <mi>o</mi>
   <mi>p</mi>
   <mi>e</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>i</ci>
    <ci>s</ci>
    <ci>o</ci>
    <ci>p</ci>
    <ci>e</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   isopen
  </annotation>
 </semantics>
</math>

 makes the fluent 

<math display="inline" id="Event_calculus:32">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mi>a</mi>
   <mi>s</mi>
   <mi>k</mi>
   <mi>e</mi>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <ci>a</ci>
    <ci>s</ci>
    <ci>k</ci>
    <ci>e</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   haskey
  </annotation>
 </semantics>
</math>

 true, but only if 

<math display="block" id="Event_calculus:33">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mi>n</mi>
   <mi>i</mi>
   <mi>t</mi>
   <mi>i</mi>
   <mi>a</mi>
   <mi>t</mi>
   <mi>e</mi>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo>,</mo>
    <mi>f</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>e</mi>
    <mo>=</mo>
    <mi>o</mi>
    <mi>p</mi>
    <mi>e</mi>
    <mi>n</mi>
    <mo>∧</mo>
    <mi>f</mi>
    <mo>=</mo>
    <mi>i</mi>
    <mi>s</mi>
    <mi>o</mi>
    <mi>p</mi>
    <mi>e</mi>
    <mi>n</mi>
    <mo>∧</mo>
    <mi>H</mi>
    <mi>o</mi>
    <mi>l</mi>
    <mi>d</mi>
    <mi>s</mi>
    <mi>A</mi>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>h</mi>
     <mi>a</mi>
     <mi>s</mi>
     <mi>k</mi>
     <mi>e</mi>
     <mi>y</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>∨</mo>
   <mi mathvariant="normal">⋯</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">I</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">e</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">e</csymbol>
     <eq></eq>
     <csymbol cd="unknown">o</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <and></and>
     <csymbol cd="unknown">f</csymbol>
     <eq></eq>
     <csymbol cd="unknown">i</csymbol>
     <csymbol cd="unknown">s</csymbol>
     <csymbol cd="unknown">o</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <and></and>
     <csymbol cd="unknown">H</csymbol>
     <csymbol cd="unknown">o</csymbol>
     <csymbol cd="unknown">l</csymbol>
     <csymbol cd="unknown">d</csymbol>
     <csymbol cd="unknown">s</csymbol>
     <csymbol cd="unknown">A</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">h</csymbol>
      <csymbol cd="unknown">a</csymbol>
      <csymbol cd="unknown">s</csymbol>
      <csymbol cd="unknown">k</csymbol>
      <csymbol cd="unknown">e</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <or></or>
    <ci>normal-⋯</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Initiates(e,f,t)\equiv[e=open\wedge f=isopen\wedge HoldsAt(haskey,t)]\vee\cdots
  </annotation>
 </semantics>
</math>

 is currently true, the corresponding formula in the event calculus is:</p>

<p>

<math display="inline" id="Event_calculus:34">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

</p>

<p>The right-hand expression of this equivalence is composed of a disjunction: for each event and fluent that can be made true by the event, there is a disjunct saying that 

<math display="inline" id="Event_calculus:35">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is actually that event, that 

<math display="inline" id="Event_calculus:36">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mi>n</mi>
   <mi>i</mi>
   <mi>t</mi>
   <mi>i</mi>
   <mi>a</mi>
   <mi>t</mi>
   <mi>e</mi>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo>,</mo>
    <mi>f</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>n</ci>
    <ci>i</ci>
    <ci>t</ci>
    <ci>i</ci>
    <ci>a</ci>
    <ci>t</ci>
    <ci>e</ci>
    <ci>s</ci>
    <vector>
     <ci>e</ci>
     <ci>f</ci>
     <ci>t</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Initiates(e,f,t)
  </annotation>
 </semantics>
</math>

 is actually that fluent, and that the precondition of the event is met.</p>

<p>The formula above specifies the <a href="truth_value" title="wikilink">truth value</a> of 

<math display="block" id="Event_calculus:37">
 <semantics>
  <mrow>
   <mrow>
    <mi>I</mi>
    <mi>n</mi>
    <mi>i</mi>
    <mi>t</mi>
    <mi>i</mi>
    <mi>a</mi>
    <mi>t</mi>
    <mi>e</mi>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>o</mi>
      <mi>p</mi>
      <mi>e</mi>
      <mi>n</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>i</mi>
      <mi>s</mi>
      <mi>o</mi>
      <mi>p</mi>
      <mi>e</mi>
      <mi>n</mi>
     </mrow>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>←</mo>
   <mrow>
    <mi>H</mi>
    <mi>o</mi>
    <mi>l</mi>
    <mi>d</mi>
    <mi>s</mi>
    <mi>A</mi>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>h</mi>
      <mi>a</mi>
      <mi>s</mi>
      <mi>k</mi>
      <mi>e</mi>
      <mi>y</mi>
     </mrow>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <times></times>
     <ci>I</ci>
     <ci>n</ci>
     <ci>i</ci>
     <ci>t</ci>
     <ci>i</ci>
     <ci>a</ci>
     <ci>t</ci>
     <ci>e</ci>
     <ci>s</ci>
     <vector>
      <apply>
       <times></times>
       <ci>o</ci>
       <ci>p</ci>
       <ci>e</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>s</ci>
       <ci>o</ci>
       <ci>p</ci>
       <ci>e</ci>
       <ci>n</ci>
      </apply>
      <ci>t</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>o</ci>
     <ci>l</ci>
     <ci>d</ci>
     <ci>s</ci>
     <ci>A</ci>
     <ci>t</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>a</ci>
       <ci>s</ci>
       <ci>k</ci>
       <ci>e</ci>
       <ci>y</ci>
      </apply>
      <ci>t</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Initiates(open,isopen,t)\leftarrow HoldsAt(haskey,t)
  </annotation>
 </semantics>
</math>

 for every possible event and fluent. As a result, all effects of all events have to be combined in a single formulae. This is a problem, because the addition of a new event requires modifying an existing formula rather than adding new ones. This problem can be solved by the application of <a href="Circumscription_(logic)" title="wikilink">circumscription</a> to a set of formulae each specifying one effect of one event:</p>

<p>

<math display="block" id="Event_calculus:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>I</mi>
    <mi>n</mi>
    <mi>i</mi>
    <mi>t</mi>
    <mi>i</mi>
    <mi>a</mi>
    <mi>t</mi>
    <mi>e</mi>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>b</mi>
      <mi>r</mi>
      <mi>e</mi>
      <mi>a</mi>
      <mi>k</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>i</mi>
      <mi>s</mi>
      <mi>o</mi>
      <mi>p</mi>
      <mi>e</mi>
      <mi>n</mi>
     </mrow>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>←</mo>
   <mrow>
    <mi>H</mi>
    <mi>o</mi>
    <mi>l</mi>
    <mi>d</mi>
    <mi>s</mi>
    <mi>A</mi>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>h</mi>
      <mi>a</mi>
      <mi>s</mi>
      <mi>h</mi>
      <mi>a</mi>
      <mi>m</mi>
      <mi>m</mi>
      <mi>e</mi>
      <mi>r</mi>
     </mrow>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <times></times>
     <ci>I</ci>
     <ci>n</ci>
     <ci>i</ci>
     <ci>t</ci>
     <ci>i</ci>
     <ci>a</ci>
     <ci>t</ci>
     <ci>e</ci>
     <ci>s</ci>
     <vector>
      <apply>
       <times></times>
       <ci>b</ci>
       <ci>r</ci>
       <ci>e</ci>
       <ci>a</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>s</ci>
       <ci>o</ci>
       <ci>p</ci>
       <ci>e</ci>
       <ci>n</ci>
      </apply>
      <ci>t</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>o</ci>
     <ci>l</ci>
     <ci>d</ci>
     <ci>s</ci>
     <ci>A</ci>
     <ci>t</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>a</ci>
       <ci>s</ci>
       <ci>h</ci>
       <ci>a</ci>
       <ci>m</ci>
       <ci>m</ci>
       <ci>e</ci>
       <ci>r</ci>
      </apply>
      <ci>t</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Initiates(break,isopen,t)\leftarrow HoldsAt(hashammer,t)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Event_calculus:39">
 <semantics>
  <mrow>
   <mrow>
    <mi>I</mi>
    <mi>n</mi>
    <mi>i</mi>
    <mi>t</mi>
    <mi>i</mi>
    <mi>a</mi>
    <mi>t</mi>
    <mi>e</mi>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>b</mi>
      <mi>r</mi>
      <mi>e</mi>
      <mi>a</mi>
      <mi>k</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>b</mi>
      <mi>r</mi>
      <mi>o</mi>
      <mi>k</mi>
      <mi>e</mi>
      <mi>n</mi>
     </mrow>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>←</mo>
   <mrow>
    <mi>H</mi>
    <mi>o</mi>
    <mi>l</mi>
    <mi>d</mi>
    <mi>s</mi>
    <mi>A</mi>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>h</mi>
      <mi>a</mi>
      <mi>s</mi>
      <mi>h</mi>
      <mi>a</mi>
      <mi>m</mi>
      <mi>m</mi>
      <mi>e</mi>
      <mi>r</mi>
     </mrow>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <times></times>
     <ci>I</ci>
     <ci>n</ci>
     <ci>i</ci>
     <ci>t</ci>
     <ci>i</ci>
     <ci>a</ci>
     <ci>t</ci>
     <ci>e</ci>
     <ci>s</ci>
     <vector>
      <apply>
       <times></times>
       <ci>b</ci>
       <ci>r</ci>
       <ci>e</ci>
       <ci>a</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <ci>b</ci>
       <ci>r</ci>
       <ci>o</ci>
       <ci>k</ci>
       <ci>e</ci>
       <ci>n</ci>
      </apply>
      <ci>t</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>o</ci>
     <ci>l</ci>
     <ci>d</ci>
     <ci>s</ci>
     <ci>A</ci>
     <ci>t</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>a</ci>
       <ci>s</ci>
       <ci>h</ci>
       <ci>a</ci>
       <ci>m</ci>
       <ci>m</ci>
       <ci>e</ci>
       <ci>r</ci>
      </apply>
      <ci>t</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Initiates(break,broken,t)\leftarrow HoldsAt(hashammer,t)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Event_calculus:40">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

</p>

<p>These formulae are simpler than the formula above, because each effect of each event can be specified separately. The single formula telling which events 

<math display="inline" id="Event_calculus:41">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and fluents 

<math display="inline" id="Event_calculus:42">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mi>n</mi>
   <mi>i</mi>
   <mi>t</mi>
   <mi>i</mi>
   <mi>a</mi>
   <mi>t</mi>
   <mi>e</mi>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo>,</mo>
    <mi>f</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>n</ci>
    <ci>i</ci>
    <ci>t</ci>
    <ci>i</ci>
    <ci>a</ci>
    <ci>t</ci>
    <ci>e</ci>
    <ci>s</ci>
    <vector>
     <ci>e</ci>
     <ci>f</ci>
     <ci>t</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Initiates(e,f,t)
  </annotation>
 </semantics>
</math>

 make 

<math display="inline" id="Event_calculus:43">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mi>n</mi>
   <mi>i</mi>
   <mi>t</mi>
   <mi>i</mi>
   <mi>a</mi>
   <mi>t</mi>
   <mi>e</mi>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo>,</mo>
    <mi>f</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>n</ci>
    <ci>i</ci>
    <ci>t</ci>
    <ci>i</ci>
    <ci>a</ci>
    <ci>t</ci>
    <ci>e</ci>
    <ci>s</ci>
    <vector>
     <ci>e</ci>
     <ci>f</ci>
     <ci>t</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Initiates(e,f,t)
  </annotation>
 </semantics>
</math>

 true has been replaced by a set of smaller formulae, each one telling the effect of an event on a fluent.</p>

<p>However, these formulae are not equivalent to the formula above. Indeed, they only specify sufficient conditions for 

<math display="inline" id="Event_calculus:44">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mi>n</mi>
   <mi>i</mi>
   <mi>t</mi>
   <mi>i</mi>
   <mi>a</mi>
   <mi>t</mi>
   <mi>e</mi>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>n</ci>
    <ci>i</ci>
    <ci>t</ci>
    <ci>i</ci>
    <ci>a</ci>
    <ci>t</ci>
    <ci>e</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Initiates
  </annotation>
 </semantics>
</math>

 to be true, which should be completed by the fact that 

<math display="inline" id="Event_calculus:45">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mi>n</mi>
   <mi>i</mi>
   <mi>t</mi>
   <mi>i</mi>
   <mi>a</mi>
   <mi>t</mi>
   <mi>e</mi>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>n</ci>
    <ci>i</ci>
    <ci>t</ci>
    <ci>i</ci>
    <ci>a</ci>
    <ci>t</ci>
    <ci>e</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Initiates
  </annotation>
 </semantics>
</math>

 is false in all other cases. This fact can be formalized by simply circumscribing the predicate 

<math display="inline" id="Event_calculus:46">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mi>n</mi>
   <mi>i</mi>
   <mi>t</mi>
   <mi>i</mi>
   <mi>a</mi>
   <mi>t</mi>
   <mi>e</mi>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>n</ci>
    <ci>i</ci>
    <ci>t</ci>
    <ci>i</ci>
    <ci>a</ci>
    <ci>t</ci>
    <ci>e</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Initiates
  </annotation>
 </semantics>
</math>

 in the formula above. It is important to note that this circumscription is done only on the formulae specifying 

<math display="inline" id="Event_calculus:47">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mi>e</mi>
   <mi>r</mi>
   <mi>m</mi>
   <mi>i</mi>
   <mi>n</mi>
   <mi>a</mi>
   <mi>t</mi>
   <mi>e</mi>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>e</ci>
    <ci>r</ci>
    <ci>m</ci>
    <ci>i</ci>
    <ci>n</ci>
    <ci>a</ci>
    <ci>t</ci>
    <ci>e</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Terminates
  </annotation>
 </semantics>
</math>

 and not on the domain-independent axioms. The predicate 

<math display="inline" id="Event_calculus:48">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mi>n</mi>
   <mi>i</mi>
   <mi>t</mi>
   <mi>i</mi>
   <mi>a</mi>
   <mi>t</mi>
   <mi>e</mi>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>n</ci>
    <ci>i</ci>
    <ci>t</ci>
    <ci>i</ci>
    <ci>a</ci>
    <ci>t</ci>
    <ci>e</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Initiates
  </annotation>
 </semantics>
</math>

 can be specified in the same way 

<math display="inline" id="Event_calculus:49">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mi>a</mi>
   <mi>p</mi>
   <mi>p</mi>
   <mi>e</mi>
   <mi>n</mi>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>a</ci>
    <ci>p</ci>
    <ci>p</ci>
    <ci>e</ci>
    <ci>n</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Happens
  </annotation>
 </semantics>
</math>

 is.</p>

<p>A similar approach can be taken for the 

<math display="block" id="Event_calculus:50">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mi>a</mi>
   <mi>p</mi>
   <mi>p</mi>
   <mi>e</mi>
   <mi>n</mi>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo>=</mo>
    <mi>o</mi>
    <mi>p</mi>
    <mi>e</mi>
    <mi>n</mi>
    <mo>∧</mo>
    <mi>t</mi>
    <mo>=</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∨</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo>=</mo>
    <mi>e</mi>
    <mi>x</mi>
    <mi>i</mi>
    <mi>t</mi>
    <mo>∧</mo>
    <mi>t</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∨</mo>
   <mi mathvariant="normal">⋯</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">H</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">e</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">e</csymbol>
     <eq></eq>
     <csymbol cd="unknown">o</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <and></and>
     <csymbol cd="unknown">t</csymbol>
     <eq></eq>
     <cn type="integer">0</cn>
     <ci>normal-)</ci>
    </cerror>
    <or></or>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">e</csymbol>
     <eq></eq>
     <csymbol cd="unknown">e</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="unknown">i</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <and></and>
     <csymbol cd="unknown">t</csymbol>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <or></or>
    <ci>normal-⋯</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Happens(e,t)\equiv(e=open\wedge t=0)\vee(e=exit\wedge t=1)\vee\cdots
  </annotation>
 </semantics>
</math>

 predicate. The evaluation of this predicate can be enforced by formulae specifying not only when it is true and when it is false:</p>

<p>

<math display="block" id="Event_calculus:51">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mi>a</mi>
   <mi>p</mi>
   <mi>p</mi>
   <mi>e</mi>
   <mi>n</mi>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>o</mi>
     <mi>p</mi>
     <mi>e</mi>
     <mi>n</mi>
    </mrow>
    <mo>,</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>a</ci>
    <ci>p</ci>
    <ci>p</ci>
    <ci>e</ci>
    <ci>n</ci>
    <ci>s</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>p</ci>
      <ci>e</ci>
      <ci>n</ci>
     </apply>
     <cn type="integer">0</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Happens(open,0)
  </annotation>
 </semantics>
</math>

</p>

<p>Circumscription can simplify this specification, as only necessary conditions can be specified:</p>

<p>

<math display="block" id="Event_calculus:52">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mi>a</mi>
   <mi>p</mi>
   <mi>p</mi>
   <mi>e</mi>
   <mi>n</mi>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>e</mi>
     <mi>x</mi>
     <mi>i</mi>
     <mi>t</mi>
    </mrow>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>a</ci>
    <ci>p</ci>
    <ci>p</ci>
    <ci>e</ci>
    <ci>n</ci>
    <ci>s</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>e</ci>
      <ci>x</ci>
      <ci>i</ci>
      <ci>t</ci>
     </apply>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Happens(exit,1)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="Event_calculus:53">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mi>a</mi>
   <mi>p</mi>
   <mi>p</mi>
   <mi>e</mi>
   <mi>n</mi>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>a</ci>
    <ci>p</ci>
    <ci>p</ci>
    <ci>e</ci>
    <ci>n</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Happens
  </annotation>
 </semantics>
</math>

</p>

<p>Circumscribing the predicate 

<math display="inline" id="Event_calculus:54">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

, this predicate will be false at all points in which it is not explicitly specified to be true. This circumscription has to be done separately from the circumscription of the other formulae. In other words, if 

<math display="inline" id="Event_calculus:55">
 <semantics>
  <mrow>
   <mrow>
    <mi>I</mi>
    <mi>n</mi>
    <mi>i</mi>
    <mi>t</mi>
    <mi>i</mi>
    <mi>a</mi>
    <mi>t</mi>
    <mi>e</mi>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>e</mi>
     <mo>,</mo>
     <mi>f</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>←</mo>
   <mi mathvariant="normal">⋯</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <times></times>
     <ci>I</ci>
     <ci>n</ci>
     <ci>i</ci>
     <ci>t</ci>
     <ci>i</ci>
     <ci>a</ci>
     <ci>t</ci>
     <ci>e</ci>
     <ci>s</ci>
     <vector>
      <ci>e</ci>
      <ci>f</ci>
      <ci>t</ci>
     </vector>
    </apply>
    <ci>normal-⋯</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Initiates(e,f,t)\leftarrow\cdots
  </annotation>
 </semantics>
</math>

 is the set of formulae of the kind 

<math display="inline" id="Event_calculus:56">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Event_calculus:57">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mi>a</mi>
   <mi>p</mi>
   <mi>p</mi>
   <mi>e</mi>
   <mi>n</mi>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>a</ci>
    <ci>p</ci>
    <ci>p</ci>
    <ci>e</ci>
    <ci>n</ci>
    <ci>s</ci>
    <interval closure="open">
     <ci>e</ci>
     <ci>t</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Happens(e,t)
  </annotation>
 </semantics>
</math>

 is the set of formulae 

<math display="inline" id="Event_calculus:58">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

, and 

<math display="block" id="Event_calculus:59">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mi>i</mi>
    <mi>r</mi>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>F</mi>
     <mo>;</mo>
     <mrow>
      <mi>I</mi>
      <mi>n</mi>
      <mi>i</mi>
      <mi>t</mi>
      <mi>i</mi>
      <mi>a</mi>
      <mi>t</mi>
      <mi>e</mi>
      <mi>s</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>T</mi>
      <mi>e</mi>
      <mi>r</mi>
      <mi>m</mi>
      <mi>i</mi>
      <mi>n</mi>
      <mi>a</mi>
      <mi>t</mi>
      <mi>e</mi>
      <mi>s</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mi>C</mi>
    <mi>i</mi>
    <mi>r</mi>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>G</mi>
     <mo>;</mo>
     <mrow>
      <mi>H</mi>
      <mi>a</mi>
      <mi>p</mi>
      <mi>p</mi>
      <mi>e</mi>
      <mi>n</mi>
      <mi>s</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∧</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>i</ci>
     <ci>r</ci>
     <ci>c</ci>
     <list>
      <ci>F</ci>
      <apply>
       <times></times>
       <ci>I</ci>
       <ci>n</ci>
       <ci>i</ci>
       <ci>t</ci>
       <ci>i</ci>
       <ci>a</ci>
       <ci>t</ci>
       <ci>e</ci>
       <ci>s</ci>
      </apply>
      <apply>
       <times></times>
       <ci>T</ci>
       <ci>e</ci>
       <ci>r</ci>
       <ci>m</ci>
       <ci>i</ci>
       <ci>n</ci>
       <ci>a</ci>
       <ci>t</ci>
       <ci>e</ci>
       <ci>s</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>i</ci>
     <ci>r</ci>
     <ci>c</ci>
     <list>
      <ci>G</ci>
      <apply>
       <times></times>
       <ci>H</ci>
       <ci>a</ci>
       <ci>p</ci>
       <ci>p</ci>
       <ci>e</ci>
       <ci>n</ci>
       <ci>s</ci>
      </apply>
     </list>
    </apply>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Circ(F;Initiates,Terminates)\wedge Circ(G;Happens)\wedge H
  </annotation>
 </semantics>
</math>

 are the domain independent axioms, the correct formulation of the domain is:</p>

<p><span class="LaTeX">$$Circ(F; Initiates, Terminates) \wedge
Circ(G; Happens) \wedge H$$</span></p>
<h2 id="the-event-calculus-as-a-logic-program">The event calculus as a logic program</h2>

<p>The event calculus was originally formulated as a set of <a href="Horn_clauses" title="wikilink">Horn clauses</a> augmented with <a href="negation_as_failure" title="wikilink">negation as failure</a> and could be run as a <a class="uri" href="Prolog" title="wikilink">Prolog</a> program. In fact, circumscription is one of the several semantics that can be given to negation as failure, and is closely related to the completion semantics (in which "if" is interpreted as "if and only if" — see <a href="logic_programming" title="wikilink">logic programming</a>).</p>
<h2 id="extensions-and-applications">Extensions and applications</h2>

<p>The original event calculus paper of Kowalski and Sergot focused on applications to database updates and narratives. Extensions of the event calculus can also formalize non-deterministic actions, concurrent actions, actions with delayed effects, gradual changes, actions with duration, continuous change, and non-inertial fluents.</p>

<p>Kave Eshghi showed how the event calculus can be used for planning, using <a href="Abduction_(logic)" title="wikilink">abduction</a> to generate hypothetical events in <a href="Abductive_Logic_Programming" title="wikilink">abductive logic programming</a>. Van Lambalgen and Hamm showed how the event calculus can also be used to give an algorithmic semantics to tense and aspect in natural language using constraint logic programming.</p>
<h2 id="reasoning-tools">Reasoning tools</h2>

<p>In addition to Prolog and its variants, several other tools for reasoning using the event calculus are also available:</p>
<ul>
<li><a href="http://www.doc.ic.ac.uk/~mpsha/planners.html">Abductive Event Calculus Planners</a></li>
<li><a href="http://decreasoner.sourceforge.net/">Discrete Event Calculus Reasoner</a></li>
<li><a href="http://reasoning.eas.asu.edu/ecasp/">Event Calculus Answer Set Programming</a></li>
<li><a href="https://www.inf.unibz.it/~montali/tools.html">Reactive Event Calculus</a></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="First-order_logic" title="wikilink">First-order logic</a></li>
<li><a href="Frame_problem" title="wikilink">Frame problem</a></li>
<li><a href="Situation_calculus" title="wikilink">Situation calculus</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Brandano, S. (2001) "[<a class="uri" href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?isnumber=20130&amp;arnumber">http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?isnumber=20130&amp;arnumber;</a>;=930691&amp;count;=35&amp;index;=2 The Event Calculus Assessed,]" <em>IEEE TIME Symposium</em>: 7-12.</li>
<li>Eshghi, K. (1988) "Abductive Planning with Event Calculus," <em>ICLP/SLP</em>: 562-79.</li>
<li>Kowalski, R. (1992) "Database updates in the event calculus," <em>Journal of Logic Programming 12 (162)</em>: 121-46.</li>
<li>-------- and M. Sergot (1986) "<a href="http://www.doc.ic.ac.uk/~rak/papers/event%20calculus.pdf">A Logic-Based Calculus of Events,</a>" <em>New Generation Computing 4</em>: 67–95.</li>
<li>-------- and F. Sadri (1995) "Variants of the Event Calculus," <em>ICLP</em>: 67-81.</li>
<li>Miller, R., and M. Shanahan (1999) "<a href="http://www.ida.liu.se/ext/epa/ej/etai/1999/016/epapage.html">The event-calculus in classical logic — alternative axiomatizations,</a>" <em><a href="Electronic_Transactions_on_Artificial_Intelligence" title="wikilink">Electronic Transactions on Artificial Intelligence</a></em> 3(1): 77-105.</li>
<li>Mueller, Erik T. (2015). <em>Commonsense Reasoning: An Event Calculus Based Approach (2nd Ed.)</em>. Waltham, MA: Morgan Kaufmann/Elsevier. ISBN 978-0128014165. (Guide to using the event calculus)</li>
<li>Shanahan, M. (1997) <em>Solving the frame problem: A mathematical investigation of the common sense law of inertia</em>. MIT Press.</li>
<li>-------- (1999) "<a href="http://www.springerlink.com/content/1bxk8gd0n6pajxbq/?p=8f3428a89bad4589a949d74b6f0ec98dπ=0">The Event Calculus Explained,</a>" Springer Verlag, LNAI (1600): 409-30.</li>
<li>Van Lambalgen, M., and F. Hamm (2005) <em>The proper treatment of events</em>. Oxford and Boston: Blackwell Publishing.</li>
</ul>

<p>"</p>

<p><a href="Category:1986_introductions" title="wikilink">Category:1986 introductions</a> <a href="Category:Logic_in_computer_science" title="wikilink">Category:Logic in computer science</a> <a href="Category:Logic_programming" title="wikilink">Category:Logic programming</a> <a href="Category:Knowledge_representation" title="wikilink">Category:Knowledge representation</a> <a href="Category:Logical_calculi" title="wikilink">Category:Logical calculi</a></p>
</body>
</html>
