<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="115">Blend modes</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Blend modes</h1>
<hr/>

<p><strong>Blend modes</strong> (or Mixing modes<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a>) in digital <a href="image_editing" title="wikilink">image editing</a> are used to determine how two <a href="Layers_(digital_image_editing)" title="wikilink">layers</a> are blended into each other. The default blend mode in most applications is simply to hide the lower layer with whatever is present in the top layer. However, as each pixel has a numerical representation, a large number of ways to blend two layers is possible. Note that the top layer is not necessarily called a "layer" in the application. It may be applied with a painting or editing tool.</p>

<p>Most <a href="Graphics_software" title="wikilink">graphics editing programs</a>, like <a href="Adobe_Photoshop" title="wikilink">Adobe Photoshop</a> and <a class="uri" href="GIMP" title="wikilink">GIMP</a>, allow the user to modify the basic blend modes - for example by applying different levels of opacity to the top picture.</p>
<h2 id="normal-blend-mode">Normal blend mode</h2>

<p>This is the standard blend mode which uses the top layer alone,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> without mixing its colors with the layer beneath it.</p>

<p>

<math display="block" id="Blend_modes:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>a</ci>
      <ci>b</ci>
     </interval>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(a,b)=b
  </annotation>
 </semantics>
</math>

</p>

<p>Where <em>a</em> is the value of a <a href="Channel_(digital_image)" title="wikilink">color channel</a> in the underlying layer, and <em>b</em> is that of the corresponding channel of the upper layer. The result is most typically merged into the bottom layer using "simple" (b over a) <a href="alpha_compositing" title="wikilink">alpha compositing</a>, but other Porter-Duff operations are possible.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The compositing step results in the top layer's shape, as defined by its alpha channel, appearing over the bottom layer.</p>
<h2 id="dissolve">Dissolve</h2>

<p>The dissolve mode takes random pixels from both layers. With high opacity, most pixels are taken from the top layer. With low opacity most pixels are taken from the bottom layer. No <a href="Spatial_anti-aliasing" title="wikilink">anti-aliasing</a> is used with this blend mode, so the pictures may look grainy and harsh.</p>
<h2 id="multiply-and-screen">Multiply and Screen</h2>

<p>Multiply and Screen blend modes are basic blend modes for darkening and lightening images respectively. There are several different combinations of them like Overlay or Soft Light (mentioned further down) and Vivid Light, Linear Light and Pin Light.</p>
<h3 id="multiply">Multiply</h3>

<p>Multiply blend mode multiplies the numbers for each pixel of the top layer with the corresponding pixel for the bottom layer. The result is a darker picture.</p>

<p>

<math display="inline" id="Blend_modes:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>a</mi>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>a</ci>
      <ci>b</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(a,b)=ab
  </annotation>
 </semantics>
</math>

, where <em>a</em> is the base layer value and <em>b</em> is the top layer value.</p>

<p>This mode is <em>symmetric</em>: exchanging two layers does not change the result. If the two layers contain the same picture, multiply blend mode is equivalent to a quadratic <a href="Curve_(tonality)" title="wikilink">curve</a>, or <a href="gamma_correction" title="wikilink">gamma correction</a> with γ=2. (For image editing it is sometimes more convenient to simply go to the Curves dialog of the software, as it gives more flexibility in the shape of the curves. Or one can use Levels dialogue — the middle number is usually 1/γ, so one can just type 0.5.)</p>

<p>If one layer contains a homogeneous color, for example the gray color (0.8, 0.8, 0.8), multiply blend mode is equivalent to a curve which simply is a straight line. This is also equivalent to using this gray value as opacity when doing “normal mode” blend with black bottom layer.</p>
<h3 id="screen">Screen</h3>

<p>With Screen blend mode the values of the pixels in the two layers are inverted, multiplied, and then inverted again. This yields the opposite effect to multiply. The result is a brighter picture.</p>

<p>

<math display="inline" id="Blend_modes:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>a</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>b</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>a</ci>
      <ci>b</ci>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>a</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(a,b)=1-(1-a)(1-b)
  </annotation>
 </semantics>
</math>

, where <em>a</em> is the base layer value and <em>b</em> is the top layer value.</p>

<p>This mode is <em>symmetric</em>: exchanging two layers does not change the result. If one layer contains a homogeneous gray, Screen blend mode is equivalent to using this gray value as opacity when doing “normal mode” blend with white top layer.</p>

<p>Image:Blend modes 1.-top-layer.jpg|Example top layer Image:Blend modes 2.-bottom-layer.jpg| Example bottom layer Image:Blend modes 4.-multiply.jpg|<em>Multiply</em> blend mode applied to the example pictures Image:Blend modes 5.-screen.jpg|<em>Screen</em> blend mode applied to the example pictures</p>
<h3 id="overlay">Overlay</h3>

<p>Overlay combines Multiply and Screen blend modes.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The parts of the top layer where base layer is light become lighter, the parts where the base layer is dark become darker. An overlay with the same picture looks like an S-curve.</p>

<p>

<math display="inline" id="Blend_modes:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mn>2</mn>
         <mi>a</mi>
         <mi>b</mi>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>a</mi>
        </mrow>
        <mo><</mo>
        <mn>0.5</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mrow>
          <mn>2</mn>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mn>1</mn>
            <mo>-</mo>
            <mi>a</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mn>1</mn>
            <mo>-</mo>
            <mi>b</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>a</ci>
      <ci>b</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <lt></lt>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>a</ci>
      </apply>
      <cn type="float">0.5</cn>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>a</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>b</ci>
       </apply>
      </apply>
     </apply>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(a,b)=\begin{cases}2ab,&\mbox{if }a<0.5\\
1-2(1-a)(1-b),&\mbox{otherwise}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>a</em> is the base layer value and <em>b</em> is the top layer value.</p>

<p>Depending on the value <em>a</em> of the base layer, one gets a linear interpolation between black (<em>a</em>=0), the top layer (<em>a</em>=0.5), and white (<em>a</em>=1).</p>
<h3 id="hard-light">Hard Light</h3>

<p>Hard Light combines Multiply and Screen blend modes. Equivalent to Overlay, but with the bottom and top images swapped.</p>
<h3 id="soft-light">Soft Light</h3>
<figure><b>(Figure)</b>
<figcaption>Comparison of soft light blend modes</figcaption>
</figure>

<p>This is a softer version of Hard Light. Applying pure black or white does not result in pure black or white.</p>

<p>There are a variety of different methods of applying a soft light blend.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> All the flavors produce the same result when the top layer is pure black; same for when the top layer is pure neutral gray. The Photoshop and illusions.hu flavors also produce the same result when the top layer is pure white (the differences between these two are in how one interpolates between these 3 results).</p>

<p>These three results coincide with <a href="gamma_correction" title="wikilink">gamma correction</a> of the bottom layer with γ=2 (for top black), unchanged bottom layer (or, what is the same, γ=1) (for top neutral gray), and γ=0.5 (for top white).</p>

<p>The formula used by Photoshop has a discontinuity of local contrast (was), and other formulas correct it. Photoshop's formula is:<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>

<math display="block" id="Blend_modes:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mrow>
      <mi>p</mi>
      <mi>h</mi>
      <mi>o</mi>
      <mi>t</mi>
      <mi>o</mi>
      <mi>s</mi>
      <mi>h</mi>
      <mi>o</mi>
      <mi>p</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mn>2</mn>
          <mi>a</mi>
          <mi>b</mi>
         </mrow>
         <mo>+</mo>
         <mrow>
          <msup>
           <mi>a</mi>
           <mn>2</mn>
          </msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mn>1</mn>
            <mo>-</mo>
            <mrow>
             <mn>2</mn>
             <mi>b</mi>
            </mrow>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>b</mi>
        </mrow>
        <mo><</mo>
        <mn>0.5</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mn>2</mn>
          <mi>a</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mn>1</mn>
            <mo>-</mo>
            <mi>b</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>+</mo>
         <mrow>
          <msqrt>
           <mi>a</mi>
          </msqrt>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mrow>
             <mn>2</mn>
             <mi>b</mi>
            </mrow>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>h</ci>
       <ci>o</ci>
       <ci>t</ci>
       <ci>o</ci>
       <ci>s</ci>
       <ci>h</ci>
       <ci>o</ci>
       <ci>p</ci>
      </apply>
     </apply>
     <interval closure="open">
      <ci>a</ci>
      <ci>b</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>b</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <lt></lt>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>b</ci>
      </apply>
      <cn type="float">0.5</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>b</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <root></root>
        <ci>a</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>b</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{photoshop}(a,b)=\begin{cases}2ab+a^{2}(1-2b),&\mbox{if }b<0.5\\
2a(1-b)+\sqrt{a}(2b-1),&\mbox{otherwise}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>a</em> is the base layer value and <em>b</em> is the top layer value. Depending on <em>b</em>, one gets a linear interpolation between three <a href="gamma_correction" title="wikilink">gamma corrections</a>: γ=2 (for <em>b</em>=0), γ=1 (for <em>b</em>=0.5), and γ=0.5 (for <em>b</em>=1).</p>

<p>Pegtop's formula<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> is smoother and corrects the discontinuity at <em>b</em> = 0.5:</p>

<p>

<math display="block" id="Blend_modes:5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mrow>
      <mi>p</mi>
      <mi>e</mi>
      <mi>g</mi>
      <mi>t</mi>
      <mi>o</mi>
      <mi>p</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mrow>
        <mn>2</mn>
        <mi>b</mi>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msup>
      <mi>a</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mi>b</mi>
     <mi>a</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>e</ci>
       <ci>g</ci>
       <ci>t</ci>
       <ci>o</ci>
       <ci>p</ci>
      </apply>
     </apply>
     <interval closure="open">
      <ci>a</ci>
      <ci>b</ci>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>b</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>b</ci>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{pegtop}(a,b)=(1-2b)a^{2}+2ba
  </annotation>
 </semantics>
</math>

.</p>

<p>This is a linear interpolation between <a href="gamma_correction" title="wikilink">gamma correction</a> with γ=2 (for <em>b</em>=0), and a certain tonal curve (for <em>b</em>=1). (The latter curve is equivalent to applying γ=2 to the negative of image.)</p>

<p>A third formula defined by illusions.hu<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> corrects the discontinuity in a different way, doing <a href="gamma_correction" title="wikilink">gamma correction</a> with γ depending on <em>b</em>:</p>

<p>

<math display="block" id="Blend_modes:6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mrow>
      <mrow>
       <mi>i</mi>
       <mi>l</mi>
       <mi>l</mi>
       <mi>u</mi>
       <mi>s</mi>
       <mi>i</mi>
       <mi>o</mi>
       <mi>n</mi>
       <mi>s</mi>
      </mrow>
      <mo>.</mo>
      <mrow>
       <mi>h</mi>
       <mi>u</mi>
      </mrow>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>a</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mn>2</mn>
      <mrow>
       <mn>2</mn>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>0.5</mn>
         <mo>-</mo>
         <mi>b</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>l</ci>
        <ci>l</ci>
        <ci>u</ci>
        <ci>s</ci>
        <ci>i</ci>
        <ci>o</ci>
        <ci>n</ci>
        <ci>s</ci>
       </apply>
       <apply>
        <times></times>
        <ci>h</ci>
        <ci>u</ci>
       </apply>
      </apply>
     </apply>
     <interval closure="open">
      <ci>a</ci>
      <ci>b</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <cn type="float">0.5</cn>
        <ci>b</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{illusions.hu}(a,b)=a^{(2^{2(0.5-b)})}
  </annotation>
 </semantics>
</math>

</p>

<p>For <em>b</em>=0, one still gets γ=2, for <em>b</em>=0.5 one gets γ=1, for <em>b</em>=1 one gets γ=0.5, but it is not a linear interpolation between these 3 images.</p>

<p>The formula specified by recent <a class="uri" href="W3C" title="wikilink">W3C</a> drafts<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> for <a class="uri" href="SVG" title="wikilink">SVG</a> and <a href="Canvas_element" title="wikilink">Canvas</a> is mathematically equivalent to the Photoshop formula with a small variation where b≥0.5 and a≤0.25:</p>

<p>

<math display="block" id="Blend_modes:7">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mrow>
      <mi>w</mi>
      <mn>3</mn>
      <mi>c</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>a</mi>
        <mo>-</mo>
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mn>1</mn>
           <mo>-</mo>
           <mrow>
            <mn>2</mn>
            <mi>b</mi>
           </mrow>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>⋅</mo>
         <mi>a</mi>
         <mo>⋅</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mn>1</mn>
           <mo>-</mo>
           <mi>a</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>b</mi>
        </mrow>
        <mo>≤</mo>
        <mn>0.5</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mi>a</mi>
        <mo>+</mo>
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mrow>
            <mn>2</mn>
            <mi>b</mi>
           </mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>⋅</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mrow>
            <msub>
             <mi>g</mi>
             <mrow>
              <mi>w</mi>
              <mn>3</mn>
              <mi>c</mi>
             </mrow>
            </msub>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>a</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo>-</mo>
           <mi>a</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>w</ci>
       <cn type="integer">3</cn>
       <ci>c</ci>
      </apply>
     </apply>
     <interval closure="open">
      <ci>a</ci>
      <ci>b</ci>
     </interval>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <minus></minus>
      <ci>a</ci>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>b</ci>
        </apply>
       </apply>
       <ci>a</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>a</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <leq></leq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>b</ci>
      </apply>
      <cn type="float">0.5</cn>
     </apply>
     <apply>
      <plus></plus>
      <ci>a</ci>
      <apply>
       <ci>normal-⋅</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>b</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>g</ci>
          <apply>
           <times></times>
           <ci>w</ci>
           <cn type="integer">3</cn>
           <ci>c</ci>
          </apply>
         </apply>
         <ci>a</ci>
        </apply>
        <ci>a</ci>
       </apply>
      </apply>
     </apply>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{w3c}(a,b)=\begin{cases}a-(1-2b)\cdot a\cdot(1-a)&\text{if }b\leq 0.5\\
a+(2b-1)\cdot(g_{w3c}(a)-a)&\text{otherwise}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="block" id="Blend_modes:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>g</mi>
     <mrow>
      <mi>w</mi>
      <mn>3</mn>
      <mi>c</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mrow>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mrow>
              <mn>16</mn>
              <mi>a</mi>
             </mrow>
             <mo>-</mo>
             <mn>12</mn>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
           <mo>⋅</mo>
           <mi>a</mi>
          </mrow>
          <mo>+</mo>
          <mn>4</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo>⋅</mo>
        <mi>a</mi>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>a</mi>
        </mrow>
        <mo>≤</mo>
        <mn>0.25</mn>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <msqrt>
        <mi>a</mi>
       </msqrt>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <apply>
       <times></times>
       <ci>w</ci>
       <cn type="integer">3</cn>
       <ci>c</ci>
      </apply>
     </apply>
     <ci>a</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <plus></plus>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <cn type="integer">16</cn>
          <ci>a</ci>
         </apply>
         <cn type="integer">12</cn>
        </apply>
        <ci>a</ci>
       </apply>
       <cn type="integer">4</cn>
      </apply>
      <ci>a</ci>
     </apply>
     <apply>
      <leq></leq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>a</ci>
      </apply>
      <cn type="float">0.25</cn>
     </apply>
     <apply>
      <root></root>
      <ci>a</ci>
     </apply>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{w3c}(a)=\begin{cases}((16a-12)\cdot a+4)\cdot a&\text{if }a\leq 0.25\\
\sqrt{a}&\text{otherwise}\end{cases}
  </annotation>
 </semantics>
</math>

.</p>

<p>This is also the formula used by <a href="Cairo_(graphics)" title="wikilink">Cairo</a>,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> and in earlier <a href="Portable_Document_Format" title="wikilink">PDF</a> documentation.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>It is still a linear interpolation between 3 images for <em>b</em>=0, 0.5, 1. But now the image for <em>b</em>=1 is not γ=0.5, but the result of a tonal curve which differs from the curve of γ=0.5 for small values of <em>a</em>: while gamma correction with γ=0.5 may increase the value of <em>a</em> many times, this new curve limits the increase of <em>a</em> by coefficient 4.</p>
<h2 id="dodge-and-burn">Dodge and burn</h2>

<p>Dodge and burn change the lightness of the pictures, inspired by the <a href="dodging_and_burning" title="wikilink">dodging and burning</a> performed in a darkroom. Dodging lightens an image, while burning darkens it. Dodging the image is the same as burning its negative (and vice versa).</p>
<ul>
<li><strong>Dodge modes</strong>:
<ul>
<li>The <strong>Screen</strong> blend mode inverts both layers, multiplies them, and then inverts that result.</li>
<li>The <strong>Color Dodge</strong> blend mode divides the bottom layer by the inverted top layer. This lightens the bottom layer depending on the value of the top layer: the brighter the top layer, the more its color affects the bottom layer. Blending with white gives white. Blending with black does not change the image. The operation is not invertible due to possible clipping of highlights. (The clipping happens in the same area as for the <strong>Linear Dodge</strong>.) When top layer contains a homogeneous color, this effect is equivalent to changing the <a href="white_point" title="wikilink">white point</a> to the inverted color. The perceived contrast increases when there is no clipping.</li>
<li>The <strong>Linear Dodge</strong> blend mode simply sums the values in the two layers. Blending with white gives white. Blending with black does not change the image. When top layer contains a homogeneous color, this effect is equivalent to changing the output black point to this color, and (input) <a href="white_point" title="wikilink">white point</a> to the inverted color. The contrast is decreased when there is no clipping.</li>
<li><strong>Divide:</strong> Same as "Color Dodge", but blending with white does not change the image.</li>
</ul></li>
</ul>

<p>Image:Blend modes 5.-screen.jpg|<em>Screen</em> blend mode applied to the example pictures Image:Blend modes 7.-colordodge.jpg|<em>Color Dodge</em> blend mode applied to the example pictures Image:Blend modes 8.-lineardodge.jpg|<em>Additive</em> blend mode applied to the example pictures</p>
<ul>
<li><strong>Burn modes</strong>:
<ul>
<li>The <strong>Multiply</strong> mode simply multiplies each component in the two layers.</li>
<li>The <strong>Color Burn</strong> mode divides the inverted bottom layer by the top layer, and then inverts the result. This darkens the top layer increasing the contrast to reflect the color of the bottom layer. The darker the bottom layer, the more its color is used. Blending with white produces no difference. When top layer contains a homogeneous color, this effect is equivalent to changing the <a href="Black_point_compensation" title="wikilink">black point</a> to the inverted color. The operation is not invertible due to possible clipping of shadows. The clipping happens in the same area as for the <strong>Linear Burn</strong>.</li>
<li>The <strong>Linear Burn</strong> mode sums the value in the two layers and subtracts 1. This is the same as inverting each layer, adding them together (as in Linear Dodge), and then inverting the result. Blending with white leaves the image unchanged.</li>
</ul></li>
</ul>
<ul>
<li><strong>Vivid Light:</strong> this blend mode combines Color Dodge and Color Burn (rescaled so that neutral colors become middle gray). Dodge applies when values in the top layer are lighter than middle gray, and burn to darker values. The middle gray is the neutral color. When color is lighter than this, this effectively moves the white point of the bottom layer down by twice the difference; when it is darker, the black point is moved up by twice the difference. (The perceived contrast increases.)</li>
</ul>
<ul>
<li><strong>Linear Light:</strong> this blend mode combines Linear Dodge and Linear Burn (rescaled so that neutral colors become middle gray). Dodge applies to values of top layer lighter than middle gray, and burn to darker values. The calculation simplifies to the sum of bottom layer and twice the top layer, subtract 1. The contrast decreases.</li>
<li>'''Subtract: '''this blend mode sums the value in the two layers and subtracts 1. Unlike Linear Burn, blending with white affects the image.</li>
</ul>
<h2 id="simple-arithmetic-blend-modes">Simple arithmetic blend modes</h2>
<h3 id="divide">Divide</h3>

<p>This blend mode simply divides pixel values of one layer with the other, but it's useful for brightening photos if the color is on grey or less. It is also useful for removing a color tint from a photo. If you create a layer that is the color of the tint you wish to remove - such as a pale blue, for scenes that are too cool in color temperature - Divide mode will return that color to white in the resulting composite, as any value divided by itself equals 1.0 (white).</p>
<h3 id="addition">Addition</h3>

<p>This blend mode simply adds pixel values of one layer with the other. In case of values above 1 (in the case of RGB), white is displayed. "Linear Dodge" produces the same visual result. Since this always produces the same or lighter colors than the input it is also known as 'plus lighter'. A variant subtracts 1 from all end values, with values below 0 becoming black; this mode is known as 'plus darker'.</p>
<h3 id="subtract">Subtract</h3>

<p>This blend mode simply subtracts pixel values of one layer with the other. In case of negative values, black is displayed.</p>
<h3 id="difference">Difference</h3>

<p>Difference subtracts the bottom layer from the top layer or the other way round, to always get a positive value. Blending with black produces no change, as values for all colors are 0. (The <a class="uri" href="RGB" title="wikilink">RGB</a> value for black is 0,0,0). Blending with white inverts the picture.</p>

<p>One of the main utilities for this is during the editing process, when it can be used to verify alignment of pictures with similar content. <em>Exclusion</em> is a very similar blend mode with lower contrast.</p>
<h3 id="darken-only">Darken Only</h3>

<p><em>Darken Only</em> creates a pixel that retains the smallest components of the foreground and background pixels. If the foreground pixel has the components <em>r1</em>, <em>g1</em>, and <em>b1</em>, and the background has <em>r2</em>, <em>g2</em>, <em>b2</em>, the resultant pixel is</p>

<p>

<math display="block" id="Blend_modes:9">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <mi>m</mi>
    <mi>i</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>r</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>r</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>m</mi>
    <mi>i</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>g</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>g</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>m</mi>
    <mi>i</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>b</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>i</ci>
     <ci>n</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>i</ci>
     <ci>n</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>i</ci>
     <ci>n</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [min(r_{1},r_{2}),min(g_{1},g_{2}),min(b_{1},b_{2})]
  </annotation>
 </semantics>
</math>

 <a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h3 id="lighten-only">Lighten Only</h3>

<p><em>Lighten Only</em> has the opposite action of <em>Darken Only</em>. It selects the maximum of each component from the foreground and background pixels. The mathematical expression for <em>Lighten Only</em> is</p>

<p>

<math display="block" id="Blend_modes:10">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <mi>m</mi>
    <mi>a</mi>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>r</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>r</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>m</mi>
    <mi>a</mi>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>g</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>g</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>m</mi>
    <mi>a</mi>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>b</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>a</ci>
     <ci>x</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>a</ci>
     <ci>x</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>g</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>a</ci>
     <ci>x</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [max(r_{1},r_{2}),max(g_{1},g_{2}),max(b_{1},b_{2})]
  </annotation>
 </semantics>
</math>

 <a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h2 id="boolean-arithmetic-blend-modes">Boolean arithmetic blend modes</h2>

<p>Rarely, applications such as <a href="Aviary_(application_suite)" title="wikilink">Aviary's</a> Peacock will supply boolean arithmetic blend modes. These combine the binary expansion of the hexadecimal color at each pixel of two layers using boolean <a href="logic_gates" title="wikilink">logic gates</a>. The top layer's alpha controls interpolation between the lower layer's image and the combined image.</p>
<h2 id="hue-saturation-and-luminosity">Hue, saturation and luminosity</h2>

<p>Photoshop’s <em>hue</em>, <em>saturation</em>, <em>color</em>, and <em>luminosity</em> blend modes are based on a color space with dimensions that the article <a href="HSL_and_HSV" title="wikilink">HSL and HSV</a> calls <a href="HSL_and_HSV#Hue_and_chroma" title="wikilink">hue, chroma</a>, and <a href="HSL_and_HSV#Lightness" title="wikilink">luma</a>. Note that this space is different from both HSL and HSV, and only the hue dimension is shared between the three; see that article for details.</p>

<p>Unlike all of the previous blend modes described, which operate on each image channel independently, in each of these modes, some dimensions are taken from the bottom layer, while the remainder are taken from the top layer. Colors which end up out of gamut are brought inside by <a href="gamut_mapping" title="wikilink">mapping</a> along lines of constant hue and luma. This makes the operations <a href="Inverse_function" title="wikilink">uninvertible</a> – after a top layer has been applied in one of these blend modes, it is in some cases impossible to restore the appearance of the original (bottom) layer, even by applying a copy of the bottom layer in the same blend mode above both.</p>
<ul>
<li>The <strong>Hue</strong> blend mode preserves the luma and chroma of the bottom layer, while adopting the hue of the top layer.</li>
<li>The <strong>Saturation</strong> blend mode preserves the luma and hue of the bottom layer, while adopting the chroma of the top layer.</li>
<li>The <strong>Color</strong> blend mode preserves the luma of the bottom layer, while adopting the hue and chroma of the top layer.</li>
<li>The <strong>Luminosity</strong> blend mode preserves the hue and chroma of the bottom layer, while adopting the luma of the top layer.</li>
</ul>

<p>Because these blend modes are based on a color space which is much closer than RGB to perceptually relevant dimensions, it can be used to <a href="Color_balance" title="wikilink">correct the color</a> of an image without altering perceived <a href="lightness_(color)" title="wikilink">lightness</a>, and to manipulate lightness contrast without changing the hue or chroma. The Luminosity mode is commonly used for <a href="Unsharp_masking" title="wikilink">image sharpening</a>, because human vision is much more sensitive to fine-scale lightness contrast than color contrast. See <a href="Contrast_(vision)" title="wikilink">Contrast (vision)</a>.</p>

<p>Few editors other than Photoshop implement this same color space for their analogs of these blend modes. Instead, they typically base their blend modes on HSV (aka HSB) or HSL. Blend modes based on HSV are typically labeled <em>hue</em>, <em>saturation</em>, and <em>brightness</em>. Using HSL or HSV has the advantage that most operations become invertible (at least in theory), but the disadvantage that the dimensions of HSL and HSV are not as perceptually relevant as the dimensions of the space Photoshop uses.</p>
<h2 id="relation-to-masking">Relation to masking</h2>

<p>The result of applying several of these modes depends linearly on the pixel level of the top layer. In such cases, when the top layer is purely black, one gets a certain transformation of the bottom layer (which may be just a purely black or purely white image). When the top layer is purely white, one gets another such transformation. The intermediate gray values are described above using the opacity slider on the second transformation.</p>

<p>In such cases, applying the blending mode is equivalent to <strong>Normal blending</strong>:</p>
<ul>
<li>Apply two transformations to the bottom layers;</li>
<li>Use the result of the first transformation as the new bottom layer;</li>
<li>Put the result of the second transformation as the new top layer;</li>
<li>Use the initial top layer as the mask on the new top layer.</li>
</ul>

<p>(This assumes that the mask may be colored, with its R,G,B channels masking the channels of the image independently. Many image manipulation programs do not allow such masks; for them this equivalence holds only for grayscale top layers.)</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Alpha_compositing" title="wikilink">Alpha compositing</a></li>
<li><a href="Comparison_of_raster_graphics_editors" title="wikilink">Comparison of raster graphics editors</a></li>
<li><a href="Digital_image_editing" title="wikilink">Digital image editing</a></li>
<li><a href="Raster_graphics" title="wikilink">Raster graphics</a></li>
<li><a href="Image_processing" title="wikilink">Image processing</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Paul R. Dunn, <a href="http://dunnbypaul.net/blends/">“Insight into Photoshop 7.0 Blending Modes”</a></li>
<li><a href="http://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/">“Photoshop math with GLSL shaders”</a></li>
<li><a href="http://stackoverflow.com/q/5919663/610692">“Photoshop Blend Mode Math”</a>, includes C code.</li>
<li>Ron Bigelow, <a href="http://www.ronbigelow.com/articles/blend1/blend1.htm">“Using Blend Modes in Photoshop – Part I”</a>, a tutorial</li>
<li><a href="http://docs.gimp.org/en/gimp-tool-curves.html">The gimp manual</a></li>
<li><a href="http://livedocs.adobe.com/flash/9.0/UsingFlash/help.html?content=WSd60f23110762d6b883b18f10cb1fe1af6-7d5a.html">Adobe's website on blend modes</a></li>
<li><a href="http://www.adobe.com/designcenter/indesign/articles/idsn3kbtrans/idsn3kbtrans.pdf">Adobe <em>Master transparency and blends</em> pdf file</a></li>
<li>Gimp and Photoshop Blending Modes visually explained and compared, parts <a href="http://emptyeasel.com/2008/10/31/explaining-blending-modes-in-photoshop-and-gimp-multiply-divide-overlay-screen/">one</a>, <a href="http://emptyeasel.com/2008/11/07/how-blending-modes-work-part-two-dodge-burn-soft-light-and-hard-light/">two</a>, <a href="http://emptyeasel.com/2008/11/14/layer-modes-part-three-difference-addition-subtraction-darken-lighten/">three</a>, and <a href="http://emptyeasel.com/2008/11/21/gimp-and-photoshop-layer-modes-part-four-hue-saturation-color-and-value/">four</a></li>
<li><a href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/blenddemo.htm">JAVA demo on the image blending operator</a>, an interactive JAVA-based image blending demo</li>
<li><a href="http://www.w3.org/TR/SVGCompositing/">All the math behind photoshop compositing</a> (including math for using alpha in complex compositions like softlight)</li>
<li><a href="http://jswidget.com/blog/2011/03/11/image-blending-algorithmpart-ii/">Image Blending Algorithm</a></li>
</ul>

<p>"</p>

<p><a href="Category:Digital_photography" title="wikilink">Category:Digital photography</a> <a href="Category:Image_processing" title="wikilink">Category:Image processing</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a class="uri" href="http://www.northlite.net/ps/blend.htm">http://www.northlite.net/ps/blend.htm</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a class="uri" href="http://gimp.1065349.n5.nabble.com/Image-processing-algorithms-resources-td34204.html">http://gimp.1065349.n5.nabble.com/Image-processing-algorithms-resources-td34204.html</a><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"></li>
</ol>
</section>
</body>
</html>
