<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1598">Locality-sensitive hashing</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Locality-sensitive hashing</h1>
<hr/>

<p><strong>Locality-sensitive hashing</strong> (<strong>LSH</strong>) <a href="dimension_reduction" title="wikilink">reduces the dimensionality</a> of high-dimensional data. LSH <a href="Hash_Function" title="wikilink">hashes</a> input items so that similar items map to the same “buckets” with high probability (the number of buckets being much smaller than the universe of possible input items). LSH differs from conventional and <a href="cryptography" title="wikilink">cryptographic</a> hash functions because it aims to maximize the probability of a “collision” for similar items.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Locality-sensitive hashing has much in common with <a href="Cluster_analysis" title="wikilink">data clustering</a> and <a href="nearest_neighbor_search" title="wikilink">nearest neighbor search</a>.</p>
<h2 id="definition">Definition</h2>

<p>An <em>LSH family</em><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> 

<math display="inline" id="Locality-sensitive_hashing:0">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

 is defined for a <a href="metric_space" title="wikilink">metric space</a> 

<math display="inline" id="Locality-sensitive_hashing:1">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ℳ</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo>,</mo>
    <mi>d</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ℳ</ci>
    <interval closure="open">
     <ci>M</ci>
     <ci>d</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{M}=(M,d)
  </annotation>
 </semantics>
</math>

, a threshold 

<math display="inline" id="Locality-sensitive_hashing:2">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>R</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R>0
  </annotation>
 </semantics>
</math>

 and an approximation factor 

<math display="inline" id="Locality-sensitive_hashing:3">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>></mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>c</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c>1
  </annotation>
 </semantics>
</math>

. This family 

<math display="inline" id="Locality-sensitive_hashing:4">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

 is a family of functions 

<math display="inline" id="Locality-sensitive_hashing:5">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>:</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ℳ</mi>
    <mo>→</mo>
    <mi>S</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>h</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>ℳ</ci>
     <ci>S</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h:{\mathcal{M}}\to S
  </annotation>
 </semantics>
</math>

 which map elements from the <a href="metric_space" title="wikilink">metric space</a> to a bucket 

<math display="inline" id="Locality-sensitive_hashing:6">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>s</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\in S
  </annotation>
 </semantics>
</math>

. The LSH family satisfies the following conditions for any two points 

<math display="inline" id="Locality-sensitive_hashing:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mo>,</mo>
    <mi>q</mi>
   </mrow>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">ℳ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>p</ci>
     <ci>q</ci>
    </list>
    <ci>ℳ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p,q\in{\mathcal{M}}
  </annotation>
 </semantics>
</math>

, using a function 

<math display="inline" id="Locality-sensitive_hashing:8">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>h</ci>
    <ci>ℱ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h\in\mathcal{F}
  </annotation>
 </semantics>
</math>

 which is chosen uniformly at random:</p>
<ul>
<li>if 

<math display="inline" id="Locality-sensitive_hashing:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo>,</mo>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>d</ci>
     <interval closure="open">
      <ci>p</ci>
      <ci>q</ci>
     </interval>
    </apply>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(p,q)\leq R
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Locality-sensitive_hashing:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(p)=h(q)
  </annotation>
 </semantics>
</math>

 (i.e.,

<math display="inline" id="Locality-sensitive_hashing:11">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Locality-sensitive_hashing:12">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 collide) with probability at least 

<math display="inline" id="Locality-sensitive_hashing:13">
 <semantics>
  <msub>
   <mi>P</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{1}
  </annotation>
 </semantics>
</math>

,</li>
<li>if 

<math display="inline" id="Locality-sensitive_hashing:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo>,</mo>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mi>c</mi>
    <mi>R</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>d</ci>
     <interval closure="open">
      <ci>p</ci>
      <ci>q</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(p,q)\geq cR
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Locality-sensitive_hashing:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>q</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(p)=h(q)
  </annotation>
 </semantics>
</math>

 with probability at most 

<math display="inline" id="Locality-sensitive_hashing:16">
 <semantics>
  <msub>
   <mi>P</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{2}
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>A family is interesting when 

<math display="inline" id="Locality-sensitive_hashing:17">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mn>1</mn>
   </msub>
   <mo>></mo>
   <msub>
    <mi>P</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{1}>P_{2}
  </annotation>
 </semantics>
</math>

. Such a family 

<math display="inline" id="Locality-sensitive_hashing:18">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

 is called <em>

<math display="inline" id="Locality-sensitive_hashing:19">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>R</mi>
   <mo>,</mo>
   <mrow>
    <mi>c</mi>
    <mi>R</mi>
   </mrow>
   <mo>,</mo>
   <msub>
    <mi>P</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>P</mi>
    <mn>2</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>R</ci>
    <apply>
     <times></times>
     <ci>c</ci>
     <ci>R</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <cn type="integer">2</cn>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (R,cR,P_{1},P_{2})
  </annotation>
 </semantics>
</math>

-sensitive</em>.</p>

<p>Alternatively<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> it is defined with respect to a universe of items 

<math display="inline" id="Locality-sensitive_hashing:20">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 that have a <a href="String_metric" title="wikilink">similarity</a> function 

<math display="inline" id="Locality-sensitive_hashing:21">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>U</mi>
     <mo>×</mo>
     <mi>U</mi>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>ϕ</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>U</ci>
      <ci>U</ci>
     </apply>
     <interval closure="closed">
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi:U\times U\to[0,1]
  </annotation>
 </semantics>
</math>

. An LSH scheme is a family of <a href="hash_function" title="wikilink">hash functions</a> 

<math display="inline" id="Locality-sensitive_hashing:22">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 coupled with a probability distribution 

<math display="inline" id="Locality-sensitive_hashing:23">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 over the functions such that a function 

<math display="inline" id="Locality-sensitive_hashing:24">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>∈</mo>
   <mi>H</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>h</ci>
    <ci>H</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h\in H
  </annotation>
 </semantics>
</math>

 chosen according to 

<math display="inline" id="Locality-sensitive_hashing:25">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 satisfies the property that 

<math display="inline" id="Locality-sensitive_hashing:26">
 <semantics>
  <mrow>
   <mi>P</mi>
   <msub>
    <mi>r</mi>
    <mrow>
     <mi>h</mi>
     <mo>∈</mo>
     <mi>H</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <apply>
      <in></in>
      <ci>h</ci>
      <ci>H</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">h</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <csymbol cd="unknown">h</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">ϕ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Pr_{h\in H}[h(a)=h(b)]=\phi(a,b)
  </annotation>
 </semantics>
</math>

 for any 

<math display="inline" id="Locality-sensitive_hashing:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
   </mrow>
   <mo>∈</mo>
   <mi>U</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>a</ci>
     <ci>b</ci>
    </list>
    <ci>U</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a,b\in U
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="amplification">Amplification</h3>

<p>Given a 

<math display="inline" id="Locality-sensitive_hashing:28">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>d</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>d</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>p</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>p</mi>
    <mn>2</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <cn type="integer">2</cn>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (d_{1},d_{2},p_{1},p_{2})
  </annotation>
 </semantics>
</math>

-sensitive family 

<math display="inline" id="Locality-sensitive_hashing:29">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

, we can construct new families 

<math display="inline" id="Locality-sensitive_hashing:30">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒢</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒢</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{G}
  </annotation>
 </semantics>
</math>

 by either the AND-construction or OR-construction of 

<math display="inline" id="Locality-sensitive_hashing:31">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>To create an AND-construction, we define a new family 

<math display="inline" id="Locality-sensitive_hashing:32">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒢</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒢</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{G}
  </annotation>
 </semantics>
</math>

 of hash functions 

<math display="inline" id="Locality-sensitive_hashing:33">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

, where each function 

<math display="inline" id="Locality-sensitive_hashing:34">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 is constructed from 

<math display="inline" id="Locality-sensitive_hashing:35">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 random functions 

<math display="inline" id="Locality-sensitive_hashing:36">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>h</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{1},...,h_{k}
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Locality-sensitive_hashing:37">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

. We then say that for a hash function 

<math display="inline" id="Locality-sensitive_hashing:38">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒢</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>g</ci>
    <ci>𝒢</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\in\mathcal{G}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Locality-sensitive_hashing:39">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)=g(y)
  </annotation>
 </semantics>
</math>

 if and only if all 

<math display="inline" id="Locality-sensitive_hashing:40">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>h</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>h</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>i</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>i</ci>
     </apply>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{i}(x)=h_{i}(y)
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Locality-sensitive_hashing:41">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>k</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <ci>k</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,2,...,k
  </annotation>
 </semantics>
</math>

. Since the members of 

<math display="inline" id="Locality-sensitive_hashing:42">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

 are independently chosen for any 

<math display="inline" id="Locality-sensitive_hashing:43">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒢</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>g</ci>
    <ci>𝒢</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\in\mathcal{G}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Locality-sensitive_hashing:44">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒢</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒢</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{G}
  </annotation>
 </semantics>
</math>

 is a 

<math display="inline" id="Locality-sensitive_hashing:45">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>d</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>d</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <msubsup>
    <mi>p</mi>
    <mn>1</mn>
    <mi>k</mi>
   </msubsup>
   <mo>,</mo>
   <msubsup>
    <mi>p</mi>
    <mn>2</mn>
    <mi>k</mi>
   </msubsup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>k</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (d_{1},d_{2},p_{1}^{k},p_{2}^{k})
  </annotation>
 </semantics>
</math>

-sensitive family.</p>

<p>To create an OR-construction, we define a new family 

<math display="inline" id="Locality-sensitive_hashing:46">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒢</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒢</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{G}
  </annotation>
 </semantics>
</math>

 of hash functions 

<math display="inline" id="Locality-sensitive_hashing:47">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

, where each function 

<math display="inline" id="Locality-sensitive_hashing:48">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 is constructed from 

<math display="inline" id="Locality-sensitive_hashing:49">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 random functions 

<math display="inline" id="Locality-sensitive_hashing:50">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>h</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{1},...,h_{k}
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Locality-sensitive_hashing:51">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

. We then say that for a hash function 

<math display="inline" id="Locality-sensitive_hashing:52">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒢</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>g</ci>
    <ci>𝒢</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\in\mathcal{G}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Locality-sensitive_hashing:53">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(x)=g(y)
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Locality-sensitive_hashing:54">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>h</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>h</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>i</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>i</ci>
     </apply>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{i}(x)=h_{i}(y)
  </annotation>
 </semantics>
</math>

 for one or more values of 

<math display="inline" id="Locality-sensitive_hashing:55">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

. Since the members of 

<math display="inline" id="Locality-sensitive_hashing:56">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

 are independently chosen for any 

<math display="inline" id="Locality-sensitive_hashing:57">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒢</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>g</ci>
    <ci>𝒢</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\in\mathcal{G}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Locality-sensitive_hashing:58">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒢</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒢</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{G}
  </annotation>
 </semantics>
</math>

 is a 

<math display="inline" id="Locality-sensitive_hashing:59">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>d</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>d</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <msub>
        <mi>p</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>k</mi>
    </msup>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <msub>
        <mi>p</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>k</mi>
    </msup>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (d_{1},d_{2},1-(1-p_{1})^{k},1-(1-p_{2})^{k})
  </annotation>
 </semantics>
</math>

-sensitive family.</p>
<h2 id="applications">Applications</h2>

<p>LSH has been applied to several problem domains including</p>
<ul>
<li><a href="Near-duplicate_detection" title="wikilink">Near-duplicate detection</a><ref></ref></li>
</ul>

<p>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<ul>
<li><a href="Hierarchical_clustering" title="wikilink">Hierarchical clustering</a><ref></ref></li>
</ul>

<p>.</p>
<ul>
<li><a href="Genome-wide_association_study" title="wikilink">Genome-wide association study</a><ref></ref></li>
</ul>

<p></p>
<ul>
<li><a href="Image_similarity_identification" title="wikilink">Image similarity identification</a>
<ul>
<li><a class="uri" href="VisualRank" title="wikilink">VisualRank</a></li>
</ul></li>
<li><a href="Gene_expression_similarity_identification" title="wikilink">Gene expression similarity identification</a></li>
<li><a href="Audio_similarity_identification" title="wikilink">Audio similarity identification</a></li>
<li><a href="Nearest_neighbor_search" title="wikilink">Nearest neighbor search</a></li>
<li><a href="Audio_fingerprint" title="wikilink">Audio fingerprint</a><ref></ref></li>
</ul>

<p></p>
<ul>
<li><a href="Digital_video_fingerprinting" title="wikilink">Digital video fingerprinting</a></li>
</ul>
<h2 id="methods">Methods</h2>
<h3 id="bit-sampling-for-hamming-distance">Bit sampling for Hamming distance</h3>

<p>One of the easiest ways to construct an LSH family is by bit sampling.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> This approach works for the <a href="Hamming_distance" title="wikilink">Hamming distance</a> over d-dimensional vectors 

<math display="inline" id="Locality-sensitive_hashing:60">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
   <mi>d</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </set>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{0,1\}^{d}
  </annotation>
 </semantics>
</math>

. Here, the family 

<math display="inline" id="Locality-sensitive_hashing:61">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

 of hash functions is simply the family of all the projections of points on one of the 

<math display="inline" id="Locality-sensitive_hashing:62">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 coordinates, i.e., 

<math display="inline" id="Locality-sensitive_hashing:63">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ℱ</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>h</mi>
    <mo>:</mo>
    <msup>
     <mrow>
      <mo stretchy="false">{</mo>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
      <mo stretchy="false">}</mo>
     </mrow>
     <mi>d</mi>
    </msup>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>∣</mo>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mtext>for some</mtext>
    <mi>i</mi>
    <mo>∈</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>d</mi>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">F</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">h</csymbol>
     <ci>normal-:</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-{</ci>
       <cn type="integer">0</cn>
       <ci>normal-,</ci>
       <cn type="integer">1</cn>
       <ci>normal-}</ci>
      </cerror>
      <ci>d</ci>
     </apply>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cn type="integer">0</cn>
      <ci>normal-,</ci>
      <cn type="integer">1</cn>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-∣</ci>
     <csymbol cd="unknown">h</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <mtext>for some</mtext>
     <csymbol cd="unknown">i</csymbol>
     <in></in>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-{</ci>
      <cn type="integer">1</cn>
      <ci>normal-,</ci>
      <ci>normal-…</ci>
      <ci>normal-,</ci>
      <csymbol cd="unknown">d</csymbol>
      <ci>normal-}</ci>
     </cerror>
     <ci>normal-}</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathcal{F}}=\{h:\{0,1\}^{d}\to\{0,1\}\mid h(x)=x_{i}\text{ for some }i\in\{1%
,...,d\}\}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Locality-sensitive_hashing:64">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 is the 

<math display="inline" id="Locality-sensitive_hashing:65">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

th coordinate of 

<math display="inline" id="Locality-sensitive_hashing:66">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

. A random function 

<math display="inline" id="Locality-sensitive_hashing:67">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Locality-sensitive_hashing:68">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathcal{F}}
  </annotation>
 </semantics>
</math>

 simply selects a random bit from the input point. This family has the following parameters

<math display="block" id="Locality-sensitive_hashing:69">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <mi>R</mi>
     <mo>/</mo>
     <mi>d</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <divide></divide>
      <ci>R</ci>
      <ci>d</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{1}=1-R/d
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Locality-sensitive_hashing:70">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <mrow>
      <mi>c</mi>
      <mi>R</mi>
     </mrow>
     <mo>/</mo>
     <mi>d</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>c</ci>
       <ci>R</ci>
      </apply>
      <ci>d</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{2}=1-cR/d
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="min-wise-independent-permutations">Min-wise independent permutations</h3>

<p>Suppose 

<math display="inline" id="Locality-sensitive_hashing:71">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 is composed of subsets of some ground set of enumerable items 

<math display="inline" id="Locality-sensitive_hashing:72">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 and the similarity function of interest is the <a href="Jaccard_index" title="wikilink">Jaccard index</a> 

<math display="inline" id="Locality-sensitive_hashing:73">
 <semantics>
  <mi>J</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>J</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Locality-sensitive_hashing:74">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 is a permutation on the indices of 

<math display="inline" id="Locality-sensitive_hashing:75">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, for 

<math display="inline" id="Locality-sensitive_hashing:76">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>⊆</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>A</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\subseteq S
  </annotation>
 </semantics>
</math>

 let 

<math display="inline" id="Locality-sensitive_hashing:77">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>min</mi>
     <mrow>
      <mi>a</mi>
      <mo>∈</mo>
      <mi>A</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>π</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <apply>
       <in></in>
       <ci>a</ci>
       <ci>A</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>π</ci>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(A)=\min_{a\in A}\{\pi(a)\}
  </annotation>
 </semantics>
</math>

. Each possible choice of 

<math display="inline" id="Locality-sensitive_hashing:78">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 defines a single hash function 

<math display="inline" id="Locality-sensitive_hashing:79">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 mapping input sets to elements of 

<math display="inline" id="Locality-sensitive_hashing:80">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

.</p>

<p>Define the function family 

<math display="inline" id="Locality-sensitive_hashing:81">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 to be the set of all such functions and let 

<math display="inline" id="Locality-sensitive_hashing:82">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 be the uniform distribution. Given two sets 

<math display="inline" id="Locality-sensitive_hashing:83">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>,</mo>
    <mi>B</mi>
   </mrow>
   <mo>⊆</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <list>
     <ci>A</ci>
     <ci>B</ci>
    </list>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A,B\subseteq S
  </annotation>
 </semantics>
</math>

 the event that 

<math display="inline" id="Locality-sensitive_hashing:84">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>A</ci>
    </apply>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(A)=h(B)
  </annotation>
 </semantics>
</math>

 corresponds exactly to the event that the minimizer of 

<math display="inline" id="Locality-sensitive_hashing:85">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 over 

<math display="inline" id="Locality-sensitive_hashing:86">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋃</mo>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <apply>
     <union></union>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\bigcup B
  </annotation>
 </semantics>
</math>

 lies inside 

<math display="inline" id="Locality-sensitive_hashing:87">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mrow>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋂</mo>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <apply>
     <intersect></intersect>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\bigcap B
  </annotation>
 </semantics>
</math>

. As 

<math display="inline" id="Locality-sensitive_hashing:88">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 was chosen uniformly at random, 

<math display="inline" id="Locality-sensitive_hashing:89">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mi>J</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>B</mi>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">h</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <csymbol cd="unknown">h</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">J</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Pr[h(A)=h(B)]=J(A,B)\,
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Locality-sensitive_hashing:90">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>H</mi>
   <mo>,</mo>
   <mi>D</mi>
   <mo rspace="4.2pt" stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>H</ci>
    <ci>D</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (H,D)\,
  </annotation>
 </semantics>
</math>

 define an LSH scheme for the Jaccard index.</p>

<p>Because the symmetric group on n elements has size n!, choosing a truly random permutation from the full symmetric group is infeasible for even moderately sized n. Because of this fact, there has been significant work on finding a family of permutations that is "min-wise independent" - a permutation family for which each element of the domain has equal probability of being the minimum under a randomly chosen 

<math display="inline" id="Locality-sensitive_hashing:91">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

. It has been established that a min-wise independent family of permutations is at least of size 

<math display="inline" id="Locality-sensitive_hashing:92">
 <semantics>
  <mrow>
   <mrow>
    <mi>l</mi>
    <mi>c</mi>
    <mi>m</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mrow>
      <mi>o</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>c</ci>
     <ci>m</ci>
     <vector>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
      <ci>normal-…</ci>
      <ci>n</ci>
     </vector>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <apply>
       <times></times>
       <ci>o</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   lcm(1,2,...,n)\geq e^{n-o(n)}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> and that this bound is tight.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>Because min-wise independent families are too big for practical applications, two variant notions of min-wise independence are introduced: restricted min-wise independent permutations families, and approximate min-wise independent families. Restricted min-wise independence is the min-wise independence property restricted to certain sets of cardinality at most k.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> Approximate min-wise independence differs from the property by at most a fixed 

<math display="inline" id="Locality-sensitive_hashing:93">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h3 id="open-source-methods">Open source methods</h3>
<h4 id="nilsimsa-hash">Nilsimsa Hash</h4>

<p><strong>Nilsimsa</strong> is an <a href="Anti-spam_techniques" title="wikilink">anti-spam</a> focused locality-sensitive hashing algorithm.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> The goal of Nilsimsa is to generate a hash digest of an email message such that the digests of two similar messages are similar to each other. The paper suggests that the Nilsimsa satisfies three requirements:</p>
<ol>
<li>The digest identifying each message should not vary significantly for changes that can be produced automatically.</li>
<li>The encoding must be robust against intentional attacks.</li>
<li>The encoding should support an extremely low risk of false positives.</li>
</ol>
<h4 id="tlsh">TLSH</h4>

<p><strong>TLSH</strong> is locality-sensitive hashing algorithm designed for a range of security and digital forensic applications.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> The goal of TLSH is to generate a hash digest of document such that if two digests have a low distance between them, then it is likely that the messages are similar to each other.</p>

<p>Testing performed in the paper demonstrates that on a range of file types identified the Nilsimsa hash as having a significantly higher false positive rate when compared to other similarity digest schemes such as TLSH, Ssdeep and Sdhash.</p>

<p>An implementations of TLSH is available as <a href="open-source_software" title="wikilink">open-source software</a>.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h3 id="random-projection">Random projection</h3>
<figure><b>(Figure)</b>
<figcaption>For small angles (not too close to orthogonal), 

<math display="inline" id="Locality-sensitive_hashing:94">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mfrac>
    <mi>θ</mi>
    <mi>π</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <divide></divide>
     <ci>θ</ci>
     <ci>π</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\frac{\theta}{\pi}
  </annotation>
 </semantics>
</math>

 is a pretty good approximation to 

<math display="inline" id="Locality-sensitive_hashing:95">
 <semantics>
  <mrow>
   <mi>cos</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>θ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <cos></cos>
    <ci>θ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cos(\theta)
  </annotation>
 </semantics>
</math>

.</figcaption>
</figure>

<p>The random projection method of LSH<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> (termed arccos by Andoni and Indyk <a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a>) is designed to approximate the <a href="cosine_distance" title="wikilink">cosine distance</a> between vectors. The basic idea of this technique is to choose a random <a class="uri" href="hyperplane" title="wikilink">hyperplane</a> (defined by a normal unit vector 

<math display="inline" id="Locality-sensitive_hashing:96">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

) at the outset and use the hyperplane to hash input vectors.</p>

<p>Given an input vector 

<math display="inline" id="Locality-sensitive_hashing:97">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 and a hyperplane defined by 

<math display="inline" id="Locality-sensitive_hashing:98">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

, we let 

<math display="inline" id="Locality-sensitive_hashing:99">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>s</mi>
    <mi>g</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>v</mi>
      <mo>⋅</mo>
      <mi>r</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>v</ci>
    </apply>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>g</ci>
     <ci>n</ci>
     <apply>
      <ci>normal-⋅</ci>
      <ci>v</ci>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(v)=sgn(v\cdot r)
  </annotation>
 </semantics>
</math>

. That is, 

<math display="inline" id="Locality-sensitive_hashing:100">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>±</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>h</ci>
     <ci>v</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">plus-or-minus</csymbol>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(v)=\pm 1
  </annotation>
 </semantics>
</math>

 depending on which side of the hyperplane 

<math display="inline" id="Locality-sensitive_hashing:101">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 lies.</p>

<p>Each possible choice of 

<math display="inline" id="Locality-sensitive_hashing:102">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 defines a single function. Let 

<math display="inline" id="Locality-sensitive_hashing:103">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 be the set of all such functions and let 

<math display="inline" id="Locality-sensitive_hashing:104">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 be the uniform distribution once again. It is not difficult to prove that, for two vectors 

<math display="inline" id="Locality-sensitive_hashing:105">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>,</mo>
   <mi>v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>u</ci>
    <ci>v</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u,v
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Locality-sensitive_hashing:106">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
   <mo>-</mo>
   <mfrac>
    <mrow>
     <mi>θ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mi>π</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">h</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">u</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <csymbol cd="unknown">h</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">v</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">1</cn>
    <minus></minus>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>θ</ci>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
     </apply>
     <ci>π</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Pr[h(u)=h(v)]=1-\frac{\theta(u,v)}{\pi}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Locality-sensitive_hashing:107">
 <semantics>
  <mrow>
   <mi>θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>θ</ci>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta(u,v)
  </annotation>
 </semantics>
</math>

 is the angle between 

<math display="inline" id="Locality-sensitive_hashing:108">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Locality-sensitive_hashing:109">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Locality-sensitive_hashing:110">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mfrac>
    <mrow>
     <mi>θ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mi>π</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>θ</ci>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
     </apply>
     <ci>π</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\frac{\theta(u,v)}{\pi}
  </annotation>
 </semantics>
</math>

 is closely related to 

<math display="inline" id="Locality-sensitive_hashing:111">
 <semantics>
  <mrow>
   <mi>cos</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>θ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <cos></cos>
    <apply>
     <times></times>
     <ci>θ</ci>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cos(\theta(u,v))
  </annotation>
 </semantics>
</math>

.</p>

<p>In this instance hashing produces only a single bit. Two vectors' bits match with probability proportional to the cosine of the angle between them.</p>
<h3 id="stable-distributions">Stable distributions</h3>

<p>The hash function <a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> 

<math display="inline" id="Locality-sensitive_hashing:112">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>h</mi>
     <mrow>
      <mi>𝐚</mi>
      <mo>,</mo>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝝊</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <msup>
     <mi class="ltx_font_mathcaligraphic">ℛ</mi>
     <mi>d</mi>
    </msup>
    <mo>→</mo>
    <mi class="ltx_font_mathcaligraphic">𝒩</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <list>
       <ci>𝐚</ci>
       <ci>b</ci>
      </list>
     </apply>
     <ci>𝝊</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ℛ</ci>
      <ci>d</ci>
     </apply>
     <ci>𝒩</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{\mathbf{a},b}(\boldsymbol{\upsilon}):\mathcal{R}^{d}\to\mathcal{N}
  </annotation>
 </semantics>
</math>

 maps a <em>d</em> dimensional vector 

<math display="inline" id="Locality-sensitive_hashing:113">
 <semantics>
  <mi>𝝊</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝝊</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\upsilon}
  </annotation>
 </semantics>
</math>

 onto a set of integers. Each hash function in the family is indexed by a choice of random 

<math display="inline" id="Locality-sensitive_hashing:114">
 <semantics>
  <mi>𝐚</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐚</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{a}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Locality-sensitive_hashing:115">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Locality-sensitive_hashing:116">
 <semantics>
  <mi>𝐚</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐚</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{a}
  </annotation>
 </semantics>
</math>

 is a <em>d</em> dimensional vector with entries chosen independently from a <a href="stable_distribution" title="wikilink">stable distribution</a> and 

<math display="inline" id="Locality-sensitive_hashing:117">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

 is a real number chosen uniformly from the range [0,r]. For a fixed 

<math display="inline" id="Locality-sensitive_hashing:118">
 <semantics>
  <mrow>
   <mi>𝐚</mi>
   <mo>,</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>𝐚</ci>
    <ci>b</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{a},b
  </annotation>
 </semantics>
</math>

 the hash function 

<math display="inline" id="Locality-sensitive_hashing:119">
 <semantics>
  <msub>
   <mi>h</mi>
   <mrow>
    <mi>𝐚</mi>
    <mo>,</mo>
    <mi>b</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <list>
     <ci>𝐚</ci>
     <ci>b</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{\mathbf{a},b}
  </annotation>
 </semantics>
</math>

 is given by 

<math display="inline" id="Locality-sensitive_hashing:120">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>h</mi>
     <mrow>
      <mi>𝐚</mi>
      <mo>,</mo>
      <mi>b</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝝊</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>⌊</mo>
    <mfrac>
     <mrow>
      <mrow>
       <mi>𝐚</mi>
       <mo>⋅</mo>
       <mi>𝝊</mi>
      </mrow>
      <mo>+</mo>
      <mi>b</mi>
     </mrow>
     <mi>r</mi>
    </mfrac>
    <mo>⌋</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <list>
       <ci>𝐚</ci>
       <ci>b</ci>
      </list>
     </apply>
     <ci>𝝊</ci>
    </apply>
    <apply>
     <floor></floor>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <apply>
        <ci>normal-⋅</ci>
        <ci>𝐚</ci>
        <ci>𝝊</ci>
       </apply>
       <ci>b</ci>
      </apply>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{\mathbf{a},b}(\boldsymbol{\upsilon})=\left\lfloor\frac{\mathbf{a}\cdot%
\boldsymbol{\upsilon}+b}{r}\right\rfloor
  </annotation>
 </semantics>
</math>

.</p>

<p>Other construction methods for hash functions have been proposed to better fit the data. <a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> In particular k-means hash functions are better in practice than projection-based hash functions, but without any theoretical guarantee.</p>
<h2 id="lsh-algorithm-for-nearest-neighbor-search">LSH algorithm for nearest neighbor search</h2>

<p>One of the main applications of LSH is to provide a method for efficient approximate <a href="nearest_neighbor_search" title="wikilink">nearest neighbor search</a> algorithms. Consider an LSH family 

<math display="inline" id="Locality-sensitive_hashing:121">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

. The algorithm has two main parameters: the width parameter 

<math display="inline" id="Locality-sensitive_hashing:122">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 and the number of hash tables 

<math display="inline" id="Locality-sensitive_hashing:123">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

.</p>

<p>In the first step, we define a new family 

<math display="inline" id="Locality-sensitive_hashing:124">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒢</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒢</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{G}
  </annotation>
 </semantics>
</math>

 of hash functions 

<math display="inline" id="Locality-sensitive_hashing:125">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

, where each function 

<math display="inline" id="Locality-sensitive_hashing:126">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 is obtained by concatenating 

<math display="inline" id="Locality-sensitive_hashing:127">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 functions 

<math display="inline" id="Locality-sensitive_hashing:128">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>h</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{1},...,h_{k}
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Locality-sensitive_hashing:129">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

, i.e., 

<math display="inline" id="Locality-sensitive_hashing:130">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>p</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <msub>
      <mi>h</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>p</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>h</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>p</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>p</ci>
    </apply>
    <list>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>p</ci>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <ci>k</ci>
      </apply>
      <ci>p</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(p)=[h_{1}(p),...,h_{k}(p)]
  </annotation>
 </semantics>
</math>

. In other words, a random hash function 

<math display="inline" id="Locality-sensitive_hashing:131">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 is obtained by concatenating 

<math display="inline" id="Locality-sensitive_hashing:132">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 randomly chosen hash functions from 

<math display="inline" id="Locality-sensitive_hashing:133">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

. The algorithm then constructs 

<math display="inline" id="Locality-sensitive_hashing:134">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 hash tables, each corresponding to a different randomly chosen hash function 

<math display="inline" id="Locality-sensitive_hashing:135">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

.</p>

<p>In the preprocessing step we hash all 

<math display="inline" id="Locality-sensitive_hashing:136">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 points from the data set 

<math display="inline" id="Locality-sensitive_hashing:137">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 into each of the 

<math display="inline" id="Locality-sensitive_hashing:138">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 hash tables. Given that the resulting hash tables have only 

<math display="inline" id="Locality-sensitive_hashing:139">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 non-zero entries, one can reduce the amount of memory used per each hash table to 

<math display="inline" id="Locality-sensitive_hashing:140">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 using standard <a href="hash_functions" title="wikilink">hash functions</a>.</p>

<p>Given a query point 

<math display="inline" id="Locality-sensitive_hashing:141">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

, the algorithm iterates over the 

<math display="inline" id="Locality-sensitive_hashing:142">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 hash functions 

<math display="inline" id="Locality-sensitive_hashing:143">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

. For each 

<math display="inline" id="Locality-sensitive_hashing:144">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 considered, it retrieves the data points that are hashed into the same bucket as 

<math display="inline" id="Locality-sensitive_hashing:145">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

. The process is stopped as soon as a point within distance 

<math display="inline" id="Locality-sensitive_hashing:146">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>c</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   cR
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Locality-sensitive_hashing:147">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 is found.</p>

<p>Given the parameters 

<math display="inline" id="Locality-sensitive_hashing:148">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Locality-sensitive_hashing:149">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

, the algorithm has the following performance guarantees:</p>
<ul>
<li>preprocessing time

<math display="block" id="Locality-sensitive_hashing:150">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>L</mi>
     <mi>k</mi>
     <mi>t</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>L</ci>
     <ci>k</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nLkt)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Locality-sensitive_hashing:151">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 is the time to evaluate a function 

<math display="inline" id="Locality-sensitive_hashing:152">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>h</ci>
    <ci>ℱ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h\in\mathcal{F}
  </annotation>
 </semantics>
</math>

 on an input point 

<math display="inline" id="Locality-sensitive_hashing:153">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

;</li>
<li>space

<math display="block" id="Locality-sensitive_hashing:154">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>L</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nL)
  </annotation>
 </semantics>
</math>

, plus the space for storing data points;</li>
<li>query time

<math display="block" id="Locality-sensitive_hashing:155">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>L</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>k</mi>
        <mi>t</mi>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>d</mi>
        <mi>n</mi>
        <msubsup>
         <mi>P</mi>
         <mn>2</mn>
         <mi>k</mi>
        </msubsup>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>L</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>k</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>n</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(L(kt+dnP_{2}^{k}))
  </annotation>
 </semantics>
</math>

;</li>
<li>the algorithm succeeds in finding a point within distance 

<math display="inline" id="Locality-sensitive_hashing:156">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>c</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   cR
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Locality-sensitive_hashing:157">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 (if there exists a point within distance 

<math display="inline" id="Locality-sensitive_hashing:158">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

) with probability at least 

<math display="inline" id="Locality-sensitive_hashing:159">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <msubsup>
       <mi>P</mi>
       <mn>1</mn>
       <mi>k</mi>
      </msubsup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>L</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>k</ci>
      </apply>
     </apply>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-(1-P_{1}^{k})^{L}
  </annotation>
 </semantics>
</math>

;</li>
</ul>

<p>For a fixed approximation ratio 

<math display="inline" id="Locality-sensitive_hashing:160">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mi>ϵ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>c</ci>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>ϵ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=1+\epsilon
  </annotation>
 </semantics>
</math>

 and probabilities 

<math display="inline" id="Locality-sensitive_hashing:161">
 <semantics>
  <msub>
   <mi>P</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Locality-sensitive_hashing:162">
 <semantics>
  <msub>
   <mi>P</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{2}
  </annotation>
 </semantics>
</math>

, one can set 

<math display="inline" id="Locality-sensitive_hashing:163">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mrow>
     <mi>log</mi>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <msub>
       <mi>P</mi>
       <mn>2</mn>
      </msub>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <apply>
     <divide></divide>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
     <apply>
      <log></log>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k={\log n\over\log 1/P_{2}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Locality-sensitive_hashing:164">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <msup>
    <mi>n</mi>
    <mi>ρ</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <ci>ρ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=n^{\rho}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Locality-sensitive_hashing:165">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>log</mi>
     <msub>
      <mi>P</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mrow>
     <mi>log</mi>
     <msub>
      <mi>P</mi>
      <mn>2</mn>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ρ</ci>
    <apply>
     <divide></divide>
     <apply>
      <log></log>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <log></log>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho={\log P_{1}\over\log P_{2}}
  </annotation>
 </semantics>
</math>

. Then one obtains the following performance guarantees:</p>
<ul>
<li>preprocessing time

<math display="block" id="Locality-sensitive_hashing:166">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>n</mi>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mi>ρ</mi>
      </mrow>
     </msup>
     <mi>k</mi>
     <mi>t</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>ρ</ci>
      </apply>
     </apply>
     <ci>k</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{1+\rho}kt)
  </annotation>
 </semantics>
</math>

;</li>
<li>space

<math display="block" id="Locality-sensitive_hashing:167">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mi>ρ</mi>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <ci>ρ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{1+\rho})
  </annotation>
 </semantics>
</math>

, plus the space for storing data points;</li>
<li>query time

<math display="block" id="Locality-sensitive_hashing:168">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>n</mi>
      <mi>ρ</mi>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mi>k</mi>
        <mi>t</mi>
       </mrow>
       <mo>+</mo>
       <mi>d</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <ci>ρ</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>k</ci>
       <ci>t</ci>
      </apply>
      <ci>d</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{\rho}(kt+d))
  </annotation>
 </semantics>
</math>

;</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Bloom_Filter" title="wikilink">Bloom Filter</a></li>
<li><a href="Curse_of_dimensionality" title="wikilink">Curse of dimensionality</a></li>
<li><a href="Feature_hashing" title="wikilink">Feature hashing</a></li>
<li><a href="Fourier-related_transforms" title="wikilink">Fourier-related transforms</a></li>
<li><a href="Multilinear_subspace_learning" title="wikilink">Multilinear subspace learning</a></li>
<li><a href="Principal_component_analysis" title="wikilink">Principal component analysis</a></li>
<li><a href="Random_indexing" title="wikilink">Random indexing</a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></li>
<li><a href="Rolling_hash" title="wikilink">Rolling hash</a></li>
<li><a href="Singular_value_decomposition" title="wikilink">Singular value decomposition</a></li>
<li><a href="Sparse_distributed_memory" title="wikilink">Sparse distributed memory</a></li>
<li><a href="Wavelet_compression" title="wikilink">Wavelet compression</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Samet, H. (2006) <em>Foundations of Multidimensional and Metric Data Structures</em>. Morgan Kaufmann. ISBN 0-12-369446-9</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://web.mit.edu/andoni/www/LSH/index.html">Alex Andoni's LSH homepage</a></li>
<li><a href="http://lshkit.sourceforge.net/">LSHKIT: A C++ Locality Sensitive Hashing Library</a></li>
<li><a href="https://github.com/simonemainardi/LSHash">A Python Locality Sensitive Hashing library that optionally supports persistence via redis</a></li>
<li><a href="http://www.vision.caltech.edu/malaa/software/research/image-search/">Caltech Large Scale Image Search Toolbox</a>: a Matlab toolbox implementing several LSH hash functions, in addition to Kd-Trees, Hierarchical K-Means, and Inverted File search algorithms.</li>
<li><a href="https://github.com/salviati/slash">Slash: A C++ LSH library, implementing Spherical LSH by Terasawa, K., Tanaka, Y</a></li>
<li><a href="https://github.com/RSIA-LIESMARS-WHU/LSHBOX">LSHBOX: An Open Source C++ Toolbox of Locality-Sensitive Hashing for Large Scale Image Retrieval, Also Support Python and MATLAB.</a></li>
<li><a href="https://github.com/DBWangGroupUNSW/SRS">SRS: A C++ Implementation of An In-memory, Space-efficient Approximate Nearest Neighbor Query Processing Algorithm based on p-stable Random Projection</a></li>
</ul>

<p>"</p>

<p><a href="Category:Search_algorithms" title="wikilink">Category:Search algorithms</a> <a href="Category:Classification_algorithms" title="wikilink">Category:Classification algorithms</a> <a href="Category:Dimension_reduction" title="wikilink">Category:Dimension reduction</a> <a class="uri" href="Category:Hashing" title="wikilink">Category:Hashing</a> <a href="Category:Probabilistic_data_structures" title="wikilink">Category:Probabilistic data structures</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7">.<a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20">Gorman, James, and James R. Curran. "Scaling distributional similarity to large corpora." Proceedings of the 21st International Conference on Computational Linguistics and the 44th annual meeting of the Association for Computational Linguistics. Association for Computational Linguistics, 2006.<a href="#fnref20">↩</a></li>
</ol>
</section>
</body>
</html>
