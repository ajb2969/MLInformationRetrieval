<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="924">Shapiro's lemma</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Shapiro's lemma</h1>
<hr>In [[mathematics]], especially in the areas of [[abstract algebra]] dealing with [[group cohomology]] or relative homological algebra, '''Shapiro's lemma''', als
<p>o known as the <strong>Eckmann–Shapiro lemma</strong>, relates extensions of modules over one ring to extensions over another, especially the <a href="group_ring" title="wikilink">group ring</a> of a <a href="group_(mathematics)" title="wikilink">group</a> and of a <a class="uri" href="subgroup" title="wikilink">subgroup</a>. It thus relates the <a href="group_cohomology" title="wikilink">group cohomology</a> with respect to a group to the cohomology with respect to a subgroup. Shapiro's lemma is named after Arnold Shapiro, who proved it in 1961;<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> however, <a href="Beno_Eckmann" title="wikilink">Beno Eckmann</a> had discovered it earlier, in 1953.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="statement-for-rings">Statement for rings</h2>

<p>Let <em>R</em> → <em>S</em> be a <a href="ring_homomorphism" title="wikilink">ring homomorphism</a>, so that <em>S</em> becomes a left and right <em>R</em>-module. Let <em>M</em> be a left <em>S</em>-module and <em>N</em> a left <em>R</em>-module. By restriction of scalars, <em>M</em> is also a left <em>R</em>-module.</p>
<ul>
<li>If <em>S</em> is projective as a right <em>R</em>-module, then:</li>
</ul>

<p>

<math display="block" id="Shapiro's_lemma:0">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo>Ext</mo>
     <mi>R</mi>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo>,</mo>
     <mmultiscripts>
      <mi>M</mi>
      <mprescripts></mprescripts>
      <mi>R</mi>
      <none></none>
     </mmultiscripts>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≅</mo>
   <mrow>
    <msubsup>
     <mo>Ext</mo>
     <mi>S</mi>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>S</mi>
      <msub>
       <mo>⊗</mo>
       <mi>R</mi>
      </msub>
      <mi>N</mi>
     </mrow>
     <mo>,</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Ext</ci>
       <ci>n</ci>
      </apply>
      <ci>R</ci>
     </apply>
     <ci>N</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>R</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Ext</ci>
       <ci>n</ci>
      </apply>
      <ci>S</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">tensor-product</csymbol>
       <ci>R</ci>
      </apply>
      <ci>S</ci>
      <ci>N</ci>
     </apply>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Ext}^{n}_{R}(N,{}_{R}M)\cong\operatorname{Ext}^{n}_{S}(S\otimes_%
{R}N,M)
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>If <em>S</em> is projective as a left <em>R</em>-module, then:</li>
</ul>

<p>

<math display="block" id="Shapiro's_lemma:1">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo>Ext</mo>
     <mi>R</mi>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mmultiscripts>
      <mi>M</mi>
      <mprescripts></mprescripts>
      <mi>R</mi>
      <none></none>
     </mmultiscripts>
     <mo>,</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≅</mo>
   <mrow>
    <msubsup>
     <mo>Ext</mo>
     <mi>S</mi>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mo>Hom</mo>
       <mi>R</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>S</mi>
       <mo>,</mo>
       <mi>N</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Ext</ci>
       <ci>n</ci>
      </apply>
      <ci>R</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>R</ci>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>Ext</ci>
       <ci>n</ci>
      </apply>
      <ci>S</ci>
     </apply>
     <ci>M</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Hom</ci>
       <ci>R</ci>
      </apply>
      <ci>S</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Ext}^{n}_{R}({}_{R}M,N)\cong\operatorname{Ext}^{n}_{S}(M,%
\operatorname{Hom}_{R}(S,N))
  </annotation>
 </semantics>
</math>

</p>

<p>See . The projectivity conditions can be weakened into conditions on the vanishing of certain Tor- or Ext-groups: see .</p>
<h2 id="statement-for-group-rings">Statement for group rings</h2>

<p>When <em>H</em> is a subgroup of finite <a href="Index_of_a_subgroup" title="wikilink">index</a> in <em>G</em>, then the group ring <em>R</em>[<em>G</em>] is finitely generated projective as a left and right <em>R</em>[<em>H</em>] module, so the previous applies in a simple way. Let <em>M</em> be a finite-dimensional representation of <em>G</em> and <em>N</em> a finite-dimensional representation of <em>H</em>. In this case, the module <em>S</em> ⊗<sub><em>R</em></sub> <em>N</em> is called the <a href="induced_representation" title="wikilink">induced representation</a> of <em>N</em> from <em>H</em> to <em>G</em>, and <sub><em>R</em></sub><em>M</em> is called the <a href="restricted_representation" title="wikilink">restricted representation</a> of <em>M</em> from <em>G</em> to <em>H</em>. One has that:</p>

<p>

<math display="block" id="Shapiro's_lemma:2">
 <semantics>
  <mrow>
   <msubsup>
    <mo>Ext</mo>
    <mi>G</mi>
    <mi>n</mi>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <mo>,</mo>
    <mi>N</mi>
    <msubsup>
     <mo>↑</mo>
     <mi>H</mi>
     <mi>G</mi>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≅</mo>
   <msubsup>
    <mo>Ext</mo>
    <mi>H</mi>
    <mi>n</mi>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>M</mi>
    <msubsup>
     <mo>↓</mo>
     <mi>H</mi>
     <mi>G</mi>
    </msubsup>
    <mo>,</mo>
    <mi>N</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Ext</ci>
      <ci>n</ci>
     </apply>
     <ci>G</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">M</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">N</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-↑</ci>
       <ci>H</ci>
      </apply>
      <ci>G</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <approx></approx>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Ext</ci>
      <ci>n</ci>
     </apply>
     <ci>H</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">M</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-↓</ci>
       <ci>H</ci>
      </apply>
      <ci>G</ci>
     </apply>
     <ci>normal-,</ci>
     <csymbol cd="unknown">N</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{Ext}^{n}_{G}(M,N\uparrow_{H}^{G})\cong\operatorname{Ext}^{n}_{H}%
(M\downarrow_{H}^{G},N)
  </annotation>
 </semantics>
</math>

</p>

<p>When <em>n</em> = 0, this is called <a href="Frobenius_reciprocity" title="wikilink">Frobenius reciprocity</a> for completely reducible modules, and Nakayama reciprocity in general. See , which also contains these higher versions of the Mackey decomposition.</p>
<h2 id="statement-for-group-cohomology">Statement for group cohomology</h2>

<p>Specializing <em>M</em> to be the trivial module produces the familiar Shapiro's lemma. Let <em>H</em> be a subgroup of <em>G</em> and <em>N</em> a representation of <em>H</em>. For <em>N</em><sup><em>G</em></sup> the <a href="induced_representation" title="wikilink">induced representation</a> of <em>N</em> from <em>H</em> to <em>G</em> using the <a href="tensor_product" title="wikilink">tensor product</a>, and for H<sub>*</sub> the <a href="group_homology" title="wikilink">group homology</a>:</p>
<dl>
<dd>H<sub>*</sub>(<em>G</em>, <em>N</em><sup><em>G</em></sup>) = H<sub>*</sub>(<em>H</em>, <em>N</em>)
</dd>
</dl>

<p>Similarly, for <em>N</em><sup><em>G</em></sup> the co-induced representation of <em>N</em> from <em>H</em> to <em>G</em> using the <a href="Hom_functor" title="wikilink">Hom functor</a>, and for H<sup>*</sup> the <a href="group_cohomology" title="wikilink">group cohomology</a>:</p>
<dl>
<dd>H<sup>*</sup>(<em>G</em>, <em>N</em><sup><em>G</em></sup>) = H<sup>*</sup>(<em>H</em>, <em>N</em>)
</dd>
</dl>

<p>When <em>H</em> is finite index in <em>G</em>, then the induced and coinduced representations coincide and the lemma is valid for both homology and cohomology.</p>

<p>See .</p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li>

<p>.</p></li>
<li>Page 59 of </li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Homological_algebra" title="wikilink">Category:Homological algebra</a> <a href="Category:Representation_theory" title="wikilink">Category:Representation theory</a> <a class="uri" href="Category:Lemmas" title="wikilink">Category:Lemmas</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">.<a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
</ol>
</section>
</hr></body>
</html>
