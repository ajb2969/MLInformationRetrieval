<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1866">Gauss–Newton algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Gauss–Newton algorithm</h1>
<hr/>

<p>The <strong>Gauss–Newton algorithm</strong> is a method used to solve <a href="non-linear_least_squares" title="wikilink">non-linear least squares</a> problems. It is a modification of <a href="newton's_method_in_optimization" title="wikilink">Newton's method</a> for finding a <a href="maxima_and_minima" title="wikilink">minimum</a> of a <a href="function_(mathematics)" title="wikilink">function</a>. Unlike Newton's method, the Gauss–Newton algorithm can only be used to minimize a sum of squared function values, but it has the advantage that second derivatives, which can be challenging to compute, are not required.</p>

<p>Non-linear least squares problems arise for instance in <a href="non-linear_regression" title="wikilink">non-linear regression</a>, where parameters in a model are sought such that the model is in good agreement with available observations.</p>

<p>The method is named after the mathematicians <a href="Carl_Friedrich_Gauss" title="wikilink">Carl Friedrich Gauss</a> and <a href="Isaac_Newton" title="wikilink">Isaac Newton</a>.</p>
<h2 id="description">Description</h2>

<p>Given <em>m</em> functions <strong>r</strong> = (<em>r</em><sub>1</sub>, …, <em>r</em><sub><em>m</em></sub>) of <em>n</em> variables <strong><em>β</em></strong> = (<em>β</em><sub>1</sub>, …, <em>β</em><sub><em>n</em></sub>), with <em>m</em> ≥ <em>n</em>, the Gauss–Newton algorithm <a href="iterative_method" title="wikilink">iteratively</a> finds the minimum of the sum of squares<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>

<math display="block" id="Gauss–Newton_algorithm:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝜷</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>m</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>r</mi>
       <mi>i</mi>
      </msub>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>𝜷</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>𝜷</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝜷</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\boldsymbol{\beta})=\sum_{i=1}^{m}r_{i}(\boldsymbol{\beta})^{2}.
  </annotation>
 </semantics>
</math>

</p>

<p>Starting with an initial guess 

<math display="inline" id="Gauss–Newton_algorithm:1">
 <semantics>
  <msup>
   <mi>𝜷</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>𝜷</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\beta}^{(0)}
  </annotation>
 </semantics>
</math>

 for the minimum, the method proceeds by the iterations</p>

<p>

<math display="block" id="Gauss–Newton_algorithm:2">
 <semantics>
  <mrow>
   <msup>
    <mi>𝜷</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>s</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>𝜷</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo>-</mo>
    <mrow>
     <msup>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mmultiscripts>
         <mi>𝐉</mi>
         <mi>𝐫</mi>
         <none></none>
         <none></none>
         <mi>𝖳</mi>
        </mmultiscripts>
        <msub>
         <mi>𝐉</mi>
         <mi>𝐫</mi>
        </msub>
       </mrow>
       <mo>)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mmultiscripts>
      <mi>𝐉</mi>
      <mi>𝐫</mi>
      <none></none>
      <none></none>
      <mi>𝖳</mi>
     </mmultiscripts>
     <mi>𝐫</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>𝜷</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝜷</ci>
     <apply>
      <plus></plus>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝜷</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐉</ci>
          <ci>𝐫</ci>
         </apply>
         <ci>𝖳</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐉</ci>
         <ci>𝐫</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐉</ci>
        <ci>𝐫</ci>
       </apply>
       <ci>𝖳</ci>
      </apply>
      <ci>𝐫</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝜷</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\beta}^{(s+1)}=\boldsymbol{\beta}^{(s)}-\left(\mathbf{J_{r}}^{%
\mathsf{T}}\mathbf{J_{r}}\right)^{-1}\mathbf{J_{r}}^{\mathsf{T}}\mathbf{r}(%
\boldsymbol{\beta}^{(s)})
  </annotation>
 </semantics>
</math>

</p>

<p>where, if <strong>r</strong> and <strong><em>β</em></strong> are <a href="column_vectors" title="wikilink">column vectors</a>, the entries of the <a href="Jacobian_matrix" title="wikilink">Jacobian matrix</a> are</p>

<p>

<math display="block" id="Gauss–Newton_algorithm:3">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>𝐉</mi>
       <mi>𝐫</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mrow>
       <mo>∂</mo>
       <msub>
        <mi>r</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>𝜷</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>s</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mo>∂</mo>
      <msub>
       <mi>β</mi>
       <mi>j</mi>
      </msub>
     </mrow>
    </mfrac>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐉</ci>
      <ci>𝐫</ci>
     </apply>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <partialdiff></partialdiff>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝜷</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathbf{J_{r}})_{ij}=\frac{\partial r_{i}(\boldsymbol{\beta}^{(s)})}{\partial%
\beta_{j}},
  </annotation>
 </semantics>
</math>

</p>

<p>and the symbol 

<math display="inline" id="Gauss–Newton_algorithm:4">
 <semantics>
  <msup>
   <mi></mi>
   <mi>𝖳</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>𝖳</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {}^{\mathsf{T}}
  </annotation>
 </semantics>
</math>

 denotes the <a href="matrix_transpose" title="wikilink">matrix transpose</a>.</p>

<p>If <em>m</em> = <em>n</em>, the iteration simplifies to</p>

<p>

<math display="block" id="Gauss–Newton_algorithm:5">
 <semantics>
  <mrow>
   <msup>
    <mi>𝜷</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>s</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>𝜷</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo>-</mo>
    <mrow>
     <msup>
      <mrow>
       <mo>(</mo>
       <msub>
        <mi>𝐉</mi>
        <mi>𝐫</mi>
       </msub>
       <mo>)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mi>𝐫</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>𝜷</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝜷</ci>
     <apply>
      <plus></plus>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝜷</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐉</ci>
        <ci>𝐫</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>𝐫</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝜷</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\beta}^{(s+1)}=\boldsymbol{\beta}^{(s)}-\left(\mathbf{J_{r}}\right%
)^{-1}\mathbf{r}(\boldsymbol{\beta}^{(s)})
  </annotation>
 </semantics>
</math>

</p>

<p>which is a direct generalization of <a href="Newton's_method" title="wikilink">Newton's method</a> in one dimension.</p>

<p>In data fitting, where the goal is to find the parameters <strong><em>β</em></strong> such that a given model function <em>y</em> = <em>f</em>(<em>x</em>, <strong><em>β</em></strong>) best fits some data points (<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>i</em></sub>), the functions <em>r</em><sub><em>i</em></sub> are the <a href="residual_(statistics)" title="wikilink">residuals</a></p>

<p>

<math display="block" id="Gauss–Newton_algorithm:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>r</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>𝜷</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>i</mi>
     </msub>
     <mo>-</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <mi>𝜷</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>i</ci>
     </apply>
     <ci>𝜷</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <ci>𝜷</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{i}(\boldsymbol{\beta})=y_{i}-f(x_{i},\boldsymbol{\beta}).
  </annotation>
 </semantics>
</math>

</p>

<p>Then, the Gauss-Newton method can be expressed in terms of the Jacobian <strong>J</strong><sub><strong>f</strong></sub> of the function <em>f</em> as</p>

<p>

<math display="block" id="Gauss–Newton_algorithm:7">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>𝜷</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>s</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>𝜷</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mo>+</mo>
     <mrow>
      <msup>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mmultiscripts>
          <mi>𝐉</mi>
          <mi>𝐟</mi>
          <none></none>
          <none></none>
          <mi>𝖳</mi>
         </mmultiscripts>
         <msub>
          <mi>𝐉</mi>
          <mi>𝐟</mi>
         </msub>
        </mrow>
        <mo>)</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mmultiscripts>
       <mi>𝐉</mi>
       <mi>𝐟</mi>
       <none></none>
       <none></none>
       <mi>𝖳</mi>
      </mmultiscripts>
      <mi>𝐫</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msup>
        <mi>𝜷</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>s</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </msup>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝜷</ci>
     <apply>
      <plus></plus>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝜷</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐉</ci>
          <ci>𝐟</ci>
         </apply>
         <ci>𝖳</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐉</ci>
         <ci>𝐟</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐉</ci>
        <ci>𝐟</ci>
       </apply>
       <ci>𝖳</ci>
      </apply>
      <ci>𝐫</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝜷</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\beta}^{(s+1)}=\boldsymbol{\beta}^{(s)}+\left(\mathbf{J_{f}}^{%
\mathsf{T}}\mathbf{J_{f}}\right)^{-1}\mathbf{J_{f}}^{\mathsf{T}}\mathbf{r}(%
\boldsymbol{\beta}^{(s)}).
  </annotation>
 </semantics>
</math>

</p>
<h2 id="notes">Notes</h2>

<p>The assumption <em>m</em> ≥ <em>n</em> in the algorithm statement is necessary, as otherwise the matrix <strong>J<sub>r</sub></strong><sup>T</sup><strong>J<sub>r</sub></strong> is not invertible and the normal equations cannot be solved (at least uniquely).</p>

<p>The Gauss–Newton algorithm can be derived by <a href="linear_approximation" title="wikilink">linearly approximating</a> the vector of functions <em>r</em><sub><em>i</em></sub>. Using <a href="Taylor's_theorem" title="wikilink">Taylor's theorem</a>, we can write at every iteration:</p>

<p>

<math display="block" id="Gauss–Newton_algorithm:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐫</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝜷</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mrow>
     <mi>𝐫</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>𝜷</mi>
       <mi>s</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>𝐉</mi>
      <mi>𝐫</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>𝜷</mi>
       <mi>s</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">Δ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>𝐫</ci>
     <ci>𝜷</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>𝐫</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝜷</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐉</ci>
       <ci>𝐫</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝜷</ci>
       <ci>s</ci>
      </apply>
      <ci>normal-Δ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r}(\boldsymbol{\beta})\approx\mathbf{r}(\boldsymbol{\beta}^{s})+%
\mathbf{J_{r}}(\boldsymbol{\beta}^{s})\Delta
  </annotation>
 </semantics>
</math>

</p>

<p>with 

<math display="inline" id="Gauss–Newton_algorithm:9">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mo>=</mo>
    <mrow>
     <mi>𝜷</mi>
     <mo>-</mo>
     <msup>
      <mi>𝜷</mi>
      <mi>s</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Δ</ci>
    <apply>
     <minus></minus>
     <ci>𝜷</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝜷</ci>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta=\boldsymbol{\beta}-\boldsymbol{\beta}^{s}.
  </annotation>
 </semantics>
</math>

 The task of finding Δ minimizing the sum of squares of the right-hand side, i.e.,</p>

<p>

<math display="block" id="Gauss–Newton_algorithm:10">
 <semantics>
  <mrow>
   <mi>𝐦𝐢𝐧</mi>
   <msubsup>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mrow>
       <mi>𝐫</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>𝜷</mi>
         <mi>s</mi>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msub>
        <mi>𝐉</mi>
        <mi>𝐫</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msup>
         <mi>𝜷</mi>
         <mi>s</mi>
        </msup>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi mathvariant="normal">Δ</mi>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mn>2</mn>
    <mn>2</mn>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐦𝐢𝐧</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>𝐫</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>𝜷</ci>
          <ci>s</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐉</ci>
          <ci>𝐫</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>𝜷</ci>
          <ci>s</ci>
         </apply>
         <ci>normal-Δ</ci>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{min}\|\mathbf{r}(\boldsymbol{\beta}^{s})+\mathbf{J_{r}}(\boldsymbol{%
\beta}^{s})\Delta\|_{2}^{2}
  </annotation>
 </semantics>
</math>

, is a <a href="linear_least_squares_(mathematics)" title="wikilink">linear least squares</a> problem, which can be solved explicitly, yielding the normal equations in the algorithm.</p>

<p>The normal equations are <em>m</em> linear simultaneous equations in the unknown increments, Δ. They may be solved in one step, using <a href="Cholesky_decomposition" title="wikilink">Cholesky decomposition</a>, or, better, the <a href="QR_factorization" title="wikilink">QR factorization</a> of <strong>J</strong><sub><strong>r</strong></sub>. For large systems, an <a href="iterative_method" title="wikilink">iterative method</a>, such as the <a href="conjugate_gradient" title="wikilink">conjugate gradient</a> method, may be more efficient. If there is a linear dependence between columns of <strong>J</strong><sub><strong>r</strong></sub>, the iterations will fail as <strong>J<sub>r</sub></strong><sup>T</sup><strong>J<sub>r</sub></strong> becomes singular.</p>
<h2 id="example">Example</h2>

<p> In this example, the Gauss–Newton algorithm will be used to fit a model to some data by minimizing the sum of squares of errors between the data and model's predictions.</p>

<p>In a biology experiment studying the relation between substrate concentration [<em>S</em>] and reaction rate in an enzyme-mediated reaction, the data in the following table were obtained.</p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>i</em></p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;">
<p>7</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>[S]</p></td>
<td style="text-align: left;">
<p>0.038</p></td>
<td style="text-align: left;">
<p>0.194</p></td>
<td style="text-align: left;">
<p>0.425</p></td>
<td style="text-align: left;">
<p>0.626</p></td>
<td style="text-align: left;">
<p>1.253</p></td>
<td style="text-align: left;">
<p>2.500</p></td>
<td style="text-align: left;">
<p>3.740</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>rate</p></td>
<td style="text-align: left;">
<p>0.050</p></td>
<td style="text-align: left;">
<p>0.127</p></td>
<td style="text-align: left;">
<p>0.094</p></td>
<td style="text-align: left;">
<p>0.2122</p></td>
<td style="text-align: left;">
<p>0.2729</p></td>
<td style="text-align: left;">
<p>0.2665</p></td>
<td style="text-align: left;">
<p>0.3317</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>It is desired to find a curve (model function) of the form</p>

<p>

<math display="block" id="Gauss–Newton_algorithm:11">
 <semantics>
  <mrow>
   <mtext>rate</mtext>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>V</mi>
      <mtext>max</mtext>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>S</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mrow>
     <msub>
      <mi>K</mi>
      <mi>M</mi>
     </msub>
     <mo>+</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>S</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <mtext>rate</mtext>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <mtext>max</mtext>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>S</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>M</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{rate}=\frac{V_{\text{max}}[S]}{K_{M}+[S]}
  </annotation>
 </semantics>
</math>

</p>

<p>that fits best the data in the least squares sense, with the parameters 

<math display="inline" id="Gauss–Newton_algorithm:12">
 <semantics>
  <msub>
   <mi>V</mi>
   <mtext>max</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <mtext>max</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{\text{max}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Gauss–Newton_algorithm:13">
 <semantics>
  <msub>
   <mi>K</mi>
   <mi>M</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{M}
  </annotation>
 </semantics>
</math>

 to be determined.</p>

<p>Denote by 

<math display="inline" id="Gauss–Newton_algorithm:14">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Gauss–Newton_algorithm:15">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{i}
  </annotation>
 </semantics>
</math>

 the value of 

<math display="inline" id="Gauss–Newton_algorithm:16">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>S</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [S]
  </annotation>
 </semantics>
</math>

 and the rate from the table, 

<math display="inline" id="Gauss–Newton_algorithm:17">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mn>7.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <cn type="float">7.</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,\dots,7.
  </annotation>
 </semantics>
</math>

 Let 

<math display="inline" id="Gauss–Newton_algorithm:18">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>V</mi>
    <mtext>max</mtext>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <mtext>max</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{1}=V_{\text{max}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Gauss–Newton_algorithm:19">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>β</mi>
     <mn>2</mn>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>K</mi>
     <mi>M</mi>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{2}=K_{M}.
  </annotation>
 </semantics>
</math>

 We will find 

<math display="inline" id="Gauss–Newton_algorithm:20">
 <semantics>
  <msub>
   <mi>β</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Gauss–Newton_algorithm:21">
 <semantics>
  <msub>
   <mi>β</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{2}
  </annotation>
 </semantics>
</math>

 such that the sum of squares of the residuals</p>

<p>

<math display="block" id="Gauss–Newton_algorithm:22">
 <semantics>
  <mrow>
   <msub>
    <mi>r</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <msub>
       <mi>β</mi>
       <mn>1</mn>
      </msub>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mrow>
      <msub>
       <mi>β</mi>
       <mn>2</mn>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>x</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>β</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>β</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{i}=y_{i}-\frac{\beta_{1}x_{i}}{\beta_{2}+x_{i}}
  </annotation>
 </semantics>
</math>

   (

<math display="inline" id="Gauss–Newton_algorithm:23">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mn>7</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <cn type="integer">7</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,\dots,7
  </annotation>
 </semantics>
</math>

) is minimized.</p>

<p>The Jacobian 

<math display="inline" id="Gauss–Newton_algorithm:24">
 <semantics>
  <msub>
   <mi>𝐉</mi>
   <mi>𝐫</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐉</ci>
    <ci>𝐫</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{J_{r}}
  </annotation>
 </semantics>
</math>

 of the vector of residuals 

<math display="inline" id="Gauss–Newton_algorithm:25">
 <semantics>
  <msub>
   <mi>r</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{i}
  </annotation>
 </semantics>
</math>

 in respect to the unknowns 

<math display="inline" id="Gauss–Newton_algorithm:26">
 <semantics>
  <msub>
   <mi>β</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{j}
  </annotation>
 </semantics>
</math>

 is an 

<math display="inline" id="Gauss–Newton_algorithm:27">
 <semantics>
  <mrow>
   <mn>7</mn>
   <mo>×</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">7</cn>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   7\times 2
  </annotation>
 </semantics>
</math>

 matrix with the 

<math display="inline" id="Gauss–Newton_algorithm:28">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

-th row having the entries</p>

<p>

<math display="block" id="Gauss–Newton_algorithm:29">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mfrac>
      <mrow>
       <mo>∂</mo>
       <msub>
        <mi>r</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <msub>
        <mi>β</mi>
        <mn>1</mn>
       </msub>
      </mrow>
     </mfrac>
     <mo>=</mo>
     <mrow>
      <mo>-</mo>
      <mfrac>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
       <mrow>
        <msub>
         <mi>β</mi>
         <mn>2</mn>
        </msub>
        <mo>+</mo>
        <msub>
         <mi>x</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </mfrac>
     </mrow>
    </mrow>
    <mo rspace="7.5pt">,</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mo>∂</mo>
       <msub>
        <mi>r</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <msub>
        <mi>β</mi>
        <mn>2</mn>
       </msub>
      </mrow>
     </mfrac>
     <mo>=</mo>
     <mfrac>
      <mrow>
       <msub>
        <mi>β</mi>
        <mn>1</mn>
       </msub>
       <msub>
        <mi>x</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <msup>
       <mrow>
        <mo>(</mo>
        <mrow>
         <msub>
          <mi>β</mi>
          <mn>2</mn>
         </msub>
         <mo>+</mo>
         <msub>
          <mi>x</mi>
          <mi>i</mi>
         </msub>
        </mrow>
        <mo>)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <partialdiff></partialdiff>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>β</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>β</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <partialdiff></partialdiff>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>β</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>β</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>β</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial r_{i}}{\partial\beta_{1}}=-\frac{x_{i}}{\beta_{2}+x_{i}},\ %
\frac{\partial r_{i}}{\partial\beta_{2}}=\frac{\beta_{1}x_{i}}{\left(\beta_{2}%
+x_{i}\right)^{2}}.
  </annotation>
 </semantics>
</math>

</p>

<p>Starting with the initial estimates of 

<math display="inline" id="Gauss–Newton_algorithm:30">
 <semantics>
  <msub>
   <mi>β</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{1}
  </annotation>
 </semantics>
</math>

=0.9 and 

<math display="inline" id="Gauss–Newton_algorithm:31">
 <semantics>
  <msub>
   <mi>β</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{2}
  </annotation>
 </semantics>
</math>

=0.2, after five iterations of the Gauss–Newton algorithm the optimal values 

<math display="inline" id="Gauss–Newton_algorithm:32">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>β</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mn>0.362</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>β</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <cn type="float">0.362</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\beta}_{1}=0.362
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Gauss–Newton_algorithm:33">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>β</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mn>0.556</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>β</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <cn type="float">0.556</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\beta}_{2}=0.556
  </annotation>
 </semantics>
</math>

 are obtained. The sum of squares of residuals decreased from the initial value of 1.445 to 0.00784 after the fifth iteration. The plot in the figure on the right shows the curve determined by the model for the optimal parameters versus the observed data.</p>
<h2 id="convergence-properties">Convergence properties</h2>

<p>It can be shown<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> that the increment Δ is a <a href="descent_direction" title="wikilink">descent direction</a> for <em>S</em>, and, if the algorithm converges, then the limit is a <a href="stationary_point" title="wikilink">stationary point</a> of <em>S</em>. However, convergence is not guaranteed, not even <a href="local_convergence" title="wikilink">local convergence</a> as in <a href="Newton's_method_in_optimization" title="wikilink">Newton's method</a>.</p>

<p>The rate of convergence of the Gauss–Newton algorithm can approach <a href="rate_of_convergence" title="wikilink">quadratic</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The algorithm may converge slowly or not at all if the initial guess is far from the minimum or the matrix 

<math display="inline" id="Gauss–Newton_algorithm:34">
 <semantics>
  <mrow>
   <msubsup>
    <mi>𝐉</mi>
    <mi>𝐫</mi>
    <mi>𝖳</mi>
   </msubsup>
   <msub>
    <mi>𝐉</mi>
    <mi>𝐫</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐉</ci>
      <ci>𝐫</ci>
     </apply>
     <ci>𝖳</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐉</ci>
     <ci>𝐫</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{J_{r}^{\mathsf{T}}J_{r}}
  </annotation>
 </semantics>
</math>

 is <a class="uri" href="ill-conditioned" title="wikilink">ill-conditioned</a>. For example, consider the problem with 

<math display="inline" id="Gauss–Newton_algorithm:35">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=2
  </annotation>
 </semantics>
</math>

 equations and 

<math display="inline" id="Gauss–Newton_algorithm:36">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=1
  </annotation>
 </semantics>
</math>

 variable, given by</p>

<p>

<math display="inline" id="Gauss–Newton_algorithm:37">
 <semantics>
  <mrow>
   <msub>
    <mi>r</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>β</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle r_{1}(\beta)
  </annotation>
 </semantics>
</math>


 The optimum is at 

<math display="inline" id="Gauss–Newton_algorithm:38">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>β</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta=0
  </annotation>
 </semantics>
</math>

. (<strong>Actually the optimum is at 

<math display="inline" id="Gauss–Newton_algorithm:39">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>β</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta=-1
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Gauss–Newton_algorithm:40">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>λ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda=2
  </annotation>
 </semantics>
</math>

, because 

<math display="inline" id="Gauss–Newton_algorithm:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mn>1</mn>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>S</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(0)=1^{2}+(-1)^{2}=2
  </annotation>
 </semantics>
</math>

, but 

<math display="inline" id="Gauss–Newton_algorithm:42">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(-1)=0
  </annotation>
 </semantics>
</math>

.</strong>) If 

<math display="inline" id="Gauss–Newton_algorithm:43">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>λ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda=0
  </annotation>
 </semantics>
</math>

 then the problem is in fact linear and the method finds the optimum in one iteration. If |λ|  1, then the method does not even converge locally.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="derivation-from-newtons-method">Derivation from Newton's method</h2>

<p>In what follows, the Gauss–Newton algorithm will be derived from <a href="Newton's_method_in_optimization" title="wikilink">Newton's method</a> for function optimization via an approximation. As a consequence, the rate of convergence of the Gauss–Newton algorithm can be quadratic under certain regularity conditions. In general (under weaker conditions), the convergence rate is linear.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>The recurrence relation for Newton's method for minimizing a function <em>S</em> of parameters, 

<math display="inline" id="Gauss–Newton_algorithm:44">
 <semantics>
  <mi>𝜷</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝜷</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\beta}
  </annotation>
 </semantics>
</math>

, is</p>

<p>

<math display="block" id="Gauss–Newton_algorithm:45">
 <semantics>
  <mrow>
   <msup>
    <mi>𝜷</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>s</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>𝜷</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msup>
    <mo>-</mo>
    <mrow>
     <msup>
      <mi>𝐇</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mpadded width="+1.7pt">
      <mi>𝐠</mi>
     </mpadded>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝜷</ci>
     <apply>
      <plus></plus>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝜷</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐇</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>𝐠</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\beta}^{(s+1)}=\boldsymbol{\beta}^{(s)}-\mathbf{H}^{-1}\mathbf{g}\,
  </annotation>
 </semantics>
</math>

 where <strong>g</strong> denotes the <a href="gradient" title="wikilink">gradient vector</a> of <em>S</em> and <strong>H</strong> denotes the <a href="Hessian_matrix" title="wikilink">Hessian matrix</a> of <em>S</em>. Since 

<math display="inline" id="Gauss–Newton_algorithm:46">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>m</mi>
    </msubsup>
    <msubsup>
     <mi>r</mi>
     <mi>i</mi>
     <mn>2</mn>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>i</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\sum_{i=1}^{m}r_{i}^{2}
  </annotation>
 </semantics>
</math>

, the gradient is given by</p>

<p>

<math display="block" id="Gauss–Newton_algorithm:47">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>g</mi>
     <mi>j</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mn>2</mn>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>m</mi>
      </munderover>
      <mrow>
       <msub>
        <mi>r</mi>
        <mi>i</mi>
       </msub>
       <mfrac>
        <mrow>
         <mo>∂</mo>
         <msub>
          <mi>r</mi>
          <mi>i</mi>
         </msub>
        </mrow>
        <mrow>
         <mo>∂</mo>
         <msub>
          <mi>β</mi>
          <mi>j</mi>
         </msub>
        </mrow>
       </mfrac>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>m</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <partialdiff></partialdiff>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <ci>i</ci>
         </apply>
        </apply>
        <apply>
         <partialdiff></partialdiff>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>β</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{j}=2\sum_{i=1}^{m}r_{i}\frac{\partial r_{i}}{\partial\beta_{j}}.
  </annotation>
 </semantics>
</math>

 Elements of the Hessian are calculated by differentiating the gradient elements, 

<math display="inline" id="Gauss–Newton_algorithm:48">
 <semantics>
  <msub>
   <mi>g</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>g</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{j}
  </annotation>
 </semantics>
</math>

, with respect to 

<math display="inline" id="Gauss–Newton_algorithm:49">
 <semantics>
  <msub>
   <mi>β</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{k}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Gauss–Newton_algorithm:50">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mrow>
      <mi>j</mi>
      <mi>k</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <mn>2</mn>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>m</mi>
      </munderover>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mrow>
         <mfrac>
          <mrow>
           <mo>∂</mo>
           <msub>
            <mi>r</mi>
            <mi>i</mi>
           </msub>
          </mrow>
          <mrow>
           <mo>∂</mo>
           <msub>
            <mi>β</mi>
            <mi>j</mi>
           </msub>
          </mrow>
         </mfrac>
         <mfrac>
          <mrow>
           <mo>∂</mo>
           <msub>
            <mi>r</mi>
            <mi>i</mi>
           </msub>
          </mrow>
          <mrow>
           <mo>∂</mo>
           <msub>
            <mi>β</mi>
            <mi>k</mi>
           </msub>
          </mrow>
         </mfrac>
        </mrow>
        <mo>+</mo>
        <mrow>
         <msub>
          <mi>r</mi>
          <mi>i</mi>
         </msub>
         <mfrac>
          <mrow>
           <msup>
            <mo>∂</mo>
            <mn>2</mn>
           </msup>
           <msub>
            <mi>r</mi>
            <mi>i</mi>
           </msub>
          </mrow>
          <mrow>
           <mrow>
            <mo>∂</mo>
            <msub>
             <mi>β</mi>
             <mi>j</mi>
            </msub>
           </mrow>
           <mrow>
            <mo>∂</mo>
            <msub>
             <mi>β</mi>
             <mi>k</mi>
            </msub>
           </mrow>
          </mrow>
         </mfrac>
        </mrow>
       </mrow>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>m</ci>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <partialdiff></partialdiff>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>r</ci>
           <ci>i</ci>
          </apply>
         </apply>
         <apply>
          <partialdiff></partialdiff>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>β</ci>
           <ci>j</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <partialdiff></partialdiff>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>r</ci>
           <ci>i</ci>
          </apply>
         </apply>
         <apply>
          <partialdiff></partialdiff>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>β</ci>
           <ci>k</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <partialdiff></partialdiff>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>r</ci>
           <ci>i</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <apply>
           <partialdiff></partialdiff>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>β</ci>
            <ci>j</ci>
           </apply>
          </apply>
          <apply>
           <partialdiff></partialdiff>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>β</ci>
            <ci>k</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{jk}=2\sum_{i=1}^{m}\left(\frac{\partial r_{i}}{\partial\beta_{j}}\frac{%
\partial r_{i}}{\partial\beta_{k}}+r_{i}\frac{\partial^{2}r_{i}}{\partial\beta%
_{j}\partial\beta_{k}}\right).
  </annotation>
 </semantics>
</math>

</p>

<p>The Gauss–Newton method is obtained by ignoring the second-order derivative terms (the second term in this expression). That is, the Hessian is approximated by</p>

<p>

<math display="block" id="Gauss–Newton_algorithm:51">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mrow>
     <mi>j</mi>
     <mi>k</mi>
    </mrow>
   </msub>
   <mo>≈</mo>
   <mrow>
    <mn>2</mn>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>m</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>J</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <msub>
       <mi>J</mi>
       <mrow>
        <mi>i</mi>
        <mi>k</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>m</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>J</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>J</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{jk}\approx 2\sum_{i=1}^{m}J_{ij}J_{ik}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Gauss–Newton_algorithm:52">
 <semantics>
  <mrow>
   <msub>
    <mi>J</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>r</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>β</mi>
      <mi>j</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>J</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J_{ij}=\frac{\partial r_{i}}{\partial\beta_{j}}
  </annotation>
 </semantics>
</math>

 are entries of the Jacobian <strong>J<sub>r</sub></strong>. The gradient and the approximate Hessian can be written in matrix notation as</p>

<p>

<math display="block" id="Gauss–Newton_algorithm:53">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝐠</mi>
     <mo>=</mo>
     <mrow>
      <mn>2</mn>
      <msubsup>
       <mi>𝐉</mi>
       <mi>𝐫</mi>
       <mi>𝖳</mi>
      </msubsup>
      <mi>𝐫</mi>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mi>𝐇</mi>
     <mo>≈</mo>
     <mrow>
      <mn>2</mn>
      <msubsup>
       <mi>𝐉</mi>
       <mi>𝐫</mi>
       <mi>𝖳</mi>
      </msubsup>
      <msub>
       <mi>𝐉</mi>
       <mi>𝐫</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>𝐠</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐉</ci>
        <ci>𝐫</ci>
       </apply>
       <ci>𝖳</ci>
      </apply>
      <ci>𝐫</ci>
     </apply>
    </apply>
    <apply>
     <approx></approx>
     <ci>𝐇</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐉</ci>
        <ci>𝐫</ci>
       </apply>
       <ci>𝖳</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐉</ci>
       <ci>𝐫</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{g}=2\mathbf{J}_{\mathbf{r}}^{\mathsf{T}}\mathbf{r},\quad\mathbf{H}%
\approx 2\mathbf{J}_{\mathbf{r}}^{\mathsf{T}}\mathbf{J_{r}}.\,
  </annotation>
 </semantics>
</math>

</p>

<p>These expressions are substituted into the recurrence relation above to obtain the operational equations</p>

<p>

<math display="block" id="Gauss–Newton_algorithm:54">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>𝜷</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>s</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </msup>
     <mo>=</mo>
     <mrow>
      <msup>
       <mi>𝜷</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </msup>
      <mo>+</mo>
      <mi mathvariant="normal">Δ</mi>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">;</mo>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mo>=</mo>
     <mrow>
      <mo>-</mo>
      <mrow>
       <msup>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mmultiscripts>
           <mi>𝐉</mi>
           <mi>𝐫</mi>
           <none></none>
           <none></none>
           <mi>𝖳</mi>
          </mmultiscripts>
          <msub>
           <mi>𝐉</mi>
           <mi>𝐫</mi>
          </msub>
         </mrow>
         <mo>)</mo>
        </mrow>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mmultiscripts>
        <mi>𝐉</mi>
        <mi>𝐫</mi>
        <none></none>
        <none></none>
        <mi>𝖳</mi>
       </mmultiscripts>
       <mi>𝐫</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝜷</ci>
      <apply>
       <plus></plus>
       <ci>s</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝜷</ci>
       <ci>s</ci>
      </apply>
      <ci>normal-Δ</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>normal-Δ</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐉</ci>
           <ci>𝐫</ci>
          </apply>
          <ci>𝖳</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐉</ci>
          <ci>𝐫</ci>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐉</ci>
         <ci>𝐫</ci>
        </apply>
        <ci>𝖳</ci>
       </apply>
       <ci>𝐫</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\beta}^{(s+1)}=\boldsymbol{\beta}^{(s)}+\Delta;\quad\Delta=-\left(%
\mathbf{J_{r}}^{\mathsf{T}}\mathbf{J_{r}}\right)^{-1}\mathbf{J_{r}}^{\mathsf{T%
}}\mathbf{r}.
  </annotation>
 </semantics>
</math>

</p>

<p>Convergence of the Gauss–Newton method is not guaranteed in all instances. The approximation</p>

<p>

<math display="block" id="Gauss–Newton_algorithm:55">
 <semantics>
  <mrow>
   <mrow>
    <mo>|</mo>
    <mrow>
     <msub>
      <mi>r</mi>
      <mi>i</mi>
     </msub>
     <mfrac>
      <mrow>
       <msup>
        <mo>∂</mo>
        <mn>2</mn>
       </msup>
       <msub>
        <mi>r</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mrow>
       <mrow>
        <mo>∂</mo>
        <msub>
         <mi>β</mi>
         <mi>j</mi>
        </msub>
       </mrow>
       <mrow>
        <mo>∂</mo>
        <msub>
         <mi>β</mi>
         <mi>k</mi>
        </msub>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
    <mo>|</mo>
   </mrow>
   <mo>≪</mo>
   <mrow>
    <mo>|</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mo>∂</mo>
       <msub>
        <mi>r</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <msub>
        <mi>β</mi>
        <mi>j</mi>
       </msub>
      </mrow>
     </mfrac>
     <mfrac>
      <mrow>
       <mo>∂</mo>
       <msub>
        <mi>r</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <msub>
        <mi>β</mi>
        <mi>k</mi>
       </msub>
      </mrow>
     </mfrac>
    </mrow>
    <mo>|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">much-less-than</csymbol>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <partialdiff></partialdiff>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <partialdiff></partialdiff>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>β</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <apply>
         <partialdiff></partialdiff>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>β</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>β</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>β</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left|r_{i}\frac{\partial^{2}r_{i}}{\partial\beta_{j}\partial\beta_{k}}\right|%
\ll\left|\frac{\partial r_{i}}{\partial\beta_{j}}\frac{\partial r_{i}}{%
\partial\beta_{k}}\right|
  </annotation>
 </semantics>
</math>

 that needs to hold to be able to ignore the second-order derivative terms may be valid in two cases, for which convergence is to be expected.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<ol>
<li>The function values 

<math display="inline" id="Gauss–Newton_algorithm:56">
 <semantics>
  <msub>
   <mi>r</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{i}
  </annotation>
 </semantics>
</math>

 are small in magnitude, at least around the minimum.</li>
<li>The functions are only "mildly" non linear, so that 

<math display="inline" id="Gauss–Newton_algorithm:57">
 <semantics>
  <mfrac>
   <mrow>
    <msup>
     <mo>∂</mo>
     <mn>2</mn>
    </msup>
    <msub>
     <mi>r</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mrow>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>β</mi>
      <mi>j</mi>
     </msub>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>β</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <partialdiff></partialdiff>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial^{2}r_{i}}{\partial\beta_{j}\partial\beta_{k}}
  </annotation>
 </semantics>
</math>

 is relatively small in magnitude.</li>
</ol>
<h2 id="improved-versions">Improved versions</h2>

<p>With the Gauss–Newton method the sum of squares <em>S</em> may not decrease at every iteration. However, since Δ is a descent direction, unless 

<math display="inline" id="Gauss–Newton_algorithm:58">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>𝜷</mi>
     <mi>s</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝜷</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\boldsymbol{\beta}^{s})
  </annotation>
 </semantics>
</math>

 is a stationary point, it holds that 

<math display="inline" id="Gauss–Newton_algorithm:59">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>𝜷</mi>
       <mi>s</mi>
      </msup>
      <mo>+</mo>
      <mrow>
       <mi>α</mi>
       <mi mathvariant="normal">Δ</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>𝜷</mi>
      <mi>s</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝜷</ci>
       <ci>s</ci>
      </apply>
      <apply>
       <times></times>
       <ci>α</ci>
       <ci>normal-Δ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝜷</ci>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\boldsymbol{\beta}^{s}+\alpha\Delta)<S(\boldsymbol{\beta}^{s})
  </annotation>
 </semantics>
</math>

 for all sufficiently small 

<math display="inline" id="Gauss–Newton_algorithm:60">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>α</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha>0
  </annotation>
 </semantics>
</math>

. Thus, if divergence occurs, one solution is to employ a fraction, 

<math display="inline" id="Gauss–Newton_algorithm:61">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

, of the increment vector, Δ in the updating formula</p>

<p>

<math display="block" id="Gauss–Newton_algorithm:62">
 <semantics>
  <mrow>
   <msup>
    <mi>𝜷</mi>
    <mrow>
     <mi>s</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>𝜷</mi>
     <mi>s</mi>
    </msup>
    <mo>+</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>α</mi>
     </mpadded>
     <mi mathvariant="normal">Δ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>𝜷</ci>
     <apply>
      <plus></plus>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝜷</ci>
      <ci>s</ci>
     </apply>
     <apply>
      <times></times>
      <ci>α</ci>
      <ci>normal-Δ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\beta}^{s+1}=\boldsymbol{\beta}^{s}+\alpha\ \Delta
  </annotation>
 </semantics>
</math>

. In other words, the increment vector is too long, but it points in "downhill", so going just a part of the way will decrease the objective function <em>S</em>. An optimal value for 

<math display="inline" id="Gauss–Newton_algorithm:63">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 can be found by using a <a href="line_search" title="wikilink">line search</a> algorithm, that is, the magnitude of 

<math display="inline" id="Gauss–Newton_algorithm:64">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 is determined by finding the value that minimizes <em>S</em>, usually using a <a href="line_search" title="wikilink">direct search method</a> in the interval 

<math display="inline" id="Gauss–Newton_algorithm:65">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo><</mo>
   <mi>α</mi>
   <mo><</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <cn type="integer">0</cn>
     <ci>α</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0<\alpha<1
  </annotation>
 </semantics>
</math>

.</p>

<p>In cases where the direction of the shift vector is such that the optimal fraction, 

<math display="inline" id="Gauss–Newton_algorithm:66">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

, is close to zero, an alternative method for handling divergence is the use of the <a href="Levenberg–Marquardt_algorithm" title="wikilink">Levenberg–Marquardt algorithm</a>, also known as the "<a href="trust_region" title="wikilink">trust region</a> method".<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> The normal equations are modified in such a way that the increment vector is rotated towards the direction of <a href="steepest_descent" title="wikilink">steepest descent</a>,</p>

<p>

<math display="block" id="Gauss–Newton_algorithm:67">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <msup>
        <mi>𝐉</mi>
        <mi>𝐓</mi>
       </msup>
       <mi>𝐉</mi>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>λ</mi>
       <mi>𝐃</mi>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mi mathvariant="normal">Δ</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <msup>
      <mi>𝐉</mi>
      <mi>T</mi>
     </msup>
     <mi>𝐫</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>𝐉</ci>
        <ci>𝐓</ci>
       </apply>
       <ci>𝐉</ci>
      </apply>
      <apply>
       <times></times>
       <ci>λ</ci>
       <ci>𝐃</ci>
      </apply>
     </apply>
     <ci>normal-Δ</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐉</ci>
       <ci>T</ci>
      </apply>
      <ci>𝐫</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(\mathbf{J^{T}J+\lambda D}\right)\Delta=-\mathbf{J}^{T}\mathbf{r}
  </annotation>
 </semantics>
</math>

, where <strong>D</strong> is a positive diagonal matrix. Note that when <em>D</em> is the identity matrix and 

<math display="inline" id="Gauss–Newton_algorithm:68">
 <semantics>
  <mrow>
   <mi>λ</mi>
   <mo>→</mo>
   <mrow>
    <mo>+</mo>
    <mi mathvariant="normal">∞</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>λ</ci>
    <apply>
     <plus></plus>
     <infinity></infinity>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda\to+\infty
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Gauss–Newton_algorithm:69">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mo>/</mo>
    <mi>λ</mi>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <msup>
      <mi>𝐉</mi>
      <mi>T</mi>
     </msup>
     <mi>𝐫</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <divide></divide>
     <ci>normal-Δ</ci>
     <ci>λ</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐉</ci>
       <ci>T</ci>
      </apply>
      <ci>𝐫</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta/\lambda\to-\mathbf{J}^{T}\mathbf{r}
  </annotation>
 </semantics>
</math>

, therefore the <a href="Direction_(geometry,_geography)" title="wikilink">direction</a> of Δ approaches the direction of the negative gradient 

<math display="inline" id="Gauss–Newton_algorithm:70">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mrow>
    <msup>
     <mi>𝐉</mi>
     <mi>T</mi>
    </msup>
    <mi>𝐫</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐉</ci>
      <ci>T</ci>
     </apply>
     <ci>𝐫</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -\mathbf{J}^{T}\mathbf{r}
  </annotation>
 </semantics>
</math>

.</p>

<p>The so-called Marquardt parameter, 

<math display="inline" id="Gauss–Newton_algorithm:71">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

, may also be optimized by a line search, but this is inefficient as the shift vector must be re-calculated every time 

<math display="inline" id="Gauss–Newton_algorithm:72">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 is changed. A more efficient strategy is this. When divergence occurs increase the Marquardt parameter until there is a decrease in S. Then, retain the value from one iteration to the next, but decrease it if possible until a cut-off value is reached when the Marquardt parameter can be set to zero; the minimization of <em>S</em> then becomes a standard Gauss–Newton minimization.</p>
<h2 id="other-applications">Other applications</h2>

<p>The Gauss–Newton algorithm is a popular method for solving nonlinear inverse problems. A particular application is generating computational models of oil and gas reservoirs for consistency with observed production data.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="related-algorithms">Related algorithms</h2>

<p>In a <a href="quasi-Newton_method" title="wikilink">quasi-Newton method</a>, such as that due to <a href="Davidon–Fletcher–Powell_formula" title="wikilink">Davidon, Fletcher and Powell</a> or Broyden–Fletcher–Goldfarb–Shanno (<a href="BFGS_method" title="wikilink">BFGS method</a>) an estimate of the full Hessian, 

<math display="inline" id="Gauss–Newton_algorithm:73">
 <semantics>
  <mfrac>
   <mrow>
    <msup>
     <mo>∂</mo>
     <mn>2</mn>
    </msup>
    <mi>S</mi>
   </mrow>
   <mrow>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>β</mi>
      <mi>j</mi>
     </msub>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>β</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <partialdiff></partialdiff>
      <cn type="integer">2</cn>
     </apply>
     <ci>S</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial^{2}S}{\partial\beta_{j}\partial\beta_{k}}
  </annotation>
 </semantics>
</math>

, is built up numerically using first derivatives 

<math display="inline" id="Gauss–Newton_algorithm:74">
 <semantics>
  <mfrac>
   <mrow>
    <mo>∂</mo>
    <msub>
     <mi>r</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mrow>
    <mo>∂</mo>
    <msub>
     <mi>β</mi>
     <mi>j</mi>
    </msub>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <partialdiff></partialdiff>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <partialdiff></partialdiff>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial r_{i}}{\partial\beta_{j}}
  </annotation>
 </semantics>
</math>

 only so that after <em>n</em> refinement cycles the method closely approximates to Newton's method in performance. Note that quasi-Newton methods can minimize general real-valued functions, whereas Gauss-Newton, Levenberg-Marquardt, etc. fits only to nonlinear least-squares problems.</p>

<p>Another method for solving minimization problems using only first derivatives is <a href="gradient_descent" title="wikilink">gradient descent</a>. However, this method does not take into account the second derivatives even approximately. Consequently, it is highly inefficient for many functions, especially if the parameters have strong interactions.</p>
<h2 id="notes-1">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li></li>
<li>

<p>.</p></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Optimization_algorithms_and_methods" title="wikilink">Category:Optimization algorithms and methods</a> <a href="Category:Least_squares" title="wikilink">Category:Least squares</a> <a href="Category:Statistical_algorithms" title="wikilink">Category:Statistical algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Björck (1996)<a href="#fnref1">↩</a></li>
<li id="fn2">Björck (1996) p260<a href="#fnref2">↩</a></li>
<li id="fn3">Björck (1996) p341, 342<a href="#fnref3">↩</a></li>
<li id="fn4">Fletcher (1987) p.113<a href="#fnref4">↩</a></li>
<li id="fn5"><a class="uri" href="http://www.henley.ac.uk/web/FILES/maths/09-04.pdf">http://www.henley.ac.uk/web/FILES/maths/09-04.pdf</a><a href="#fnref5">↩</a></li>
<li id="fn6">Nocedal (1999) p259<a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
</ol>
</section>
</body>
</html>
