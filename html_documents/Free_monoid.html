<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1446">Free monoid</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Free monoid</h1>
<hr/>

<p>In <a href="abstract_algebra" title="wikilink">abstract algebra</a>, the <strong>free monoid</strong> on a <a href="Set_(mathematics)" title="wikilink">set</a> is the <a class="uri" href="monoid" title="wikilink">monoid</a> whose elements are all the <a href="finite_sequence" title="wikilink">finite sequences</a> (or strings) of zero or more elements from that set, with <a href="string_concatenation" title="wikilink">string concatenation</a> as the monoid operation and with the unique sequence of zero elements, often called the <a href="empty_string" title="wikilink">empty string</a> and denoted by ε or λ, as the <a href="identity_element" title="wikilink">identity element</a>. The free monoid on a set <em>A</em> is usually denoted <em>A</em><sup>∗</sup>. The <strong>free semigroup</strong> on <em>A</em> is the sub<a class="uri" href="semigroup" title="wikilink">semigroup</a> of <em>A</em><sup>∗</sup> containing all elements except the empty string. It is usually denoted <em>A</em><sup>+</sup>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>More generally, an abstract monoid (or semigroup) <em>S</em> is described as <strong>free</strong> if it is <a class="uri" href="isomorphic" title="wikilink">isomorphic</a> to the free monoid (or semigroup) on some set.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>As the name implies, free monoids and semigroups are those objects which satisfy the usual <a href="universal_property" title="wikilink">universal property</a> defining <a href="free_object" title="wikilink">free objects</a>, in the respective <a href="category_(mathematics)" title="wikilink">categories</a> of monoids and semigroups. It follows that every monoid (or semigroup) arises as a homomorphic image of a free monoid (or semigroup). The study of semigroups as images of free semigroups is called combinatorial semigroup theory.</p>
<h2 id="examples">Examples</h2>
<h3 id="natural-numbers">Natural numbers</h3>

<p>The monoid (<strong>N<sub>0</sub></strong>,+) of <a href="natural_numbers" title="wikilink">natural numbers</a> (including zero) under addition is a free monoid on a singleton free generator, in this case the natural number 1. According to the formal definition, this monoid consists of all sequences like "1", "1+1", "1+1+1", "1+1+1+1", and so on, including the empty sequence. Mapping each such sequence to its evaluation result <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> and the empty sequence to zero establishes an isomorphism from the set of such sequences to <strong>N<sub>0</sub></strong>. This isomorphism is compatible with "+", that is, for any two sequences <em>s</em> and <em>t</em>, if <em>s</em> is mapped (i.e. evaluated) to a number <em>m</em> and <em>t</em> to <em>n</em>, then their concatenation <em>s</em>+<em>t</em> is mapped to the sum <em>m</em>+<em>n</em>.</p>
<h3 id="kleene-star">Kleene star</h3>

<p>In <a href="formal_language" title="wikilink">formal language</a> theory, usually a finite set (called "alphabet" there) <em>A</em> of "symbols" is considered, a finite sequence of symbols is called "word over <em>A</em>", and the free monoid <em>A</em><sup>∗</sup> is called the "<a href="Kleene_star" title="wikilink">Kleene star</a> of <em>A</em>". Thus, the abstract study of formal languages can be thought of as the study of subsets of finitely generated free monoids. There are deep connections between the theory of semigroups and that of <a href="automata_theory" title="wikilink">automata</a>. For example, the <a href="regular_language" title="wikilink">regular languages</a> over <em>A</em> are the homomorphic <a href="Image_(mathematics)#Inverse_image" title="wikilink">pre-images</a> in <em>A</em><sup>∗</sup> of subsets of finite monoids.</p>

<p>For example, assuming an alphabet <em>A</em> = {<em>a</em>, <em>b</em>, <em>c</em>}, its Kleene star <em>A</em><sup>∗</sup> contains all concatenations of <em>a</em>, <em>b</em>, and <em>c</em>:</p>
<dl>
<dd>{ε, <em>a</em>, <em>ab</em>, <em>ba</em>, <em>caa</em>, <em>cccbabbc</em>, ...}.
</dd>
</dl>

<p>If <em>A</em> is any set, the <em>word length</em> function on <em>A</em><sup>∗</sup> is the unique <a href="monoid_homomorphism" title="wikilink">monoid homomorphism</a> from <em>A</em><sup>∗</sup> to (<strong>N<sub>0</sub></strong>,+) that maps each element of <em>A</em> to 1. A free monoid is thus a <strong>graded monoid</strong>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="conjugate-words">Conjugate words</h2>

<p> We define a pair of words in <em>A</em><sup>∗</sup> of the form <em>uv</em> and <em>vu</em> as <strong>conjugate</strong>: the conjugates of a word are thus its <a href="circular_shift" title="wikilink">circular shifts</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Two words are conjugate in this sense if they are <a href="Conjugation_(group_theory)" title="wikilink">conjugate in the sense of group theory</a> as elements of the <a href="free_group" title="wikilink">free group</a> generated by <em>A</em>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h3 id="equidivisibility">Equidivisibility</h3>

<p>A free monoid is <strong>equidivisible</strong>: if the equation <em>mn</em> = <em>pq</em> holds, then there exists an <em>s</em> such that either <em>m</em> = <em>ps</em>, <em>sn</em> = <em>q</em> (example see image) or <em>ms</em> = <em>p</em>, <em>n</em> = <em>sq</em>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> This result is also known as <a href="Levi's_lemma" title="wikilink">Levi's lemma</a>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>A monoid is free if and only if it is graded and equidivisible.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="free-generators-and-rank">Free generators and rank</h2>

<p>The members of a set <em>A</em> are called the <strong>free generators</strong> for <em>A</em><sup>∗</sup> and <em>A</em><sup>+</sup>. The superscript * is then commonly understood to be the <a href="Kleene_star" title="wikilink">Kleene star</a>. More generally, if <em>S</em> is an abstract free monoid (semigroup), then a set of elements which maps onto the set of single-letter words under an isomorphism to a semigroup <em>A<sup>+</sup></em> (monoid <em>A</em><sup>∗</sup>) is called a <em>set of free generators</em> for <em>S</em>.</p>

<p>Each free semigroup (or monoid) <em>S</em> has exactly one set of free generators, the <a class="uri" href="cardinality" title="wikilink">cardinality</a> of which is called the <em>rank</em> of <em>S</em>.</p>

<p>Two free monoids or semigroups are isomorphic if and only if they have the same rank. In fact, <em>every</em> set of generators for a free semigroup or monoid <em>S</em> contains the free generators. It follows that a free semigroup or monoid is finitely generated if and only if it has finite rank.</p>

<p>A <a class="uri" href="submonoid" title="wikilink">submonoid</a> <em>N</em> of <em>A</em><sup>∗</sup> is <strong>stable</strong> if <em>u</em>, <em>v</em>, <em>ux</em>, <em>xv</em> in <em>N</em> together imply <em>x</em> in <em>N</em>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> A submonoid of <em>A</em><sup>∗</sup> is stable if and only if it is free.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> For example, using the set of <a href="bit" title="wikilink">bits</a> { "0", "1" } as <em>A</em>, the set <em>N</em> of all bit strings containing evenly many "1"s is a stable<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> submonoid<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> of the set <em>A</em><sup>∗</sup> of all bit strings at all. While <em>N</em> cannot be freely generated by any set of single bits, it <em>can</em> be freely generated by the set of bit strings { "0", "11", "101", "1001", "10001", ... }.</p>
<h3 id="codes">Codes</h3>

<p>A set of free generators for a free monoid <em>P</em> is referred to as a <strong>basis</strong> for <strong>P</strong>: a set of words <em>C</em> is a <strong>code</strong> if <em>C</em>* is a free monoid and <em>C</em> is a basis.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> A set <em>X</em> of words in <em>A</em><sup>∗</sup> is a <strong>prefix</strong>, or has the <strong>prefix property</strong>, if it does not contain a proper <a href="prefix_(computer_science)" title="wikilink">(string) prefix</a> of any of its elements. Every prefix in <em>A</em><sup>+</sup> is a code, indeed a <a href="prefix_code" title="wikilink">prefix code</a>.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>

<p>A submonoid <em>N</em> of <em>A</em><sup>∗</sup> is <strong>right unitary</strong> if <em>x</em>, <em>xy</em> in <em>N</em> implies <em>y</em> in <em>N</em>. A submonoid is generated by a prefix if and only if it is right unitary.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h2 id="free-hull">Free hull</h2>

<p>The intersection of free submonoids of a free monoid <em>A</em><sup>∗</sup> is again free.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> If <em>S</em> is a subset of a free monoid <em>A</em>* then the intersection of all free submonoids of <em>A</em>* containing <em>S</em> is well-defined, since <em>A</em>* itself is free, and contains <em>S</em>; it is a free monoid. A basis for this intersection is the <strong>free hull</strong> of <em>S</em>.</p>

<p>The <strong>defect theorem</strong><a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a><a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a><a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> states that if <em>X</em> is finite and <em>C</em> is the free hull of <em>X</em>, then either <em>X</em> is a code and <em>C</em> = <em>X</em>, or</p>
<dl>
<dd>|<em>C</em>| ≤ |<em>X</em>| − 1 .
</dd>
</dl>
<h2 id="morphisms">Morphisms</h2>

<p>A <a href="monoid_morphism" title="wikilink">monoid morphism</a> <em>f</em> from a free monoid <em>B</em><sup>∗</sup> to a monoid <em>M</em> is a map such that <em>f</em>(<em>xy</em>) = <em>f</em>(<em>x</em>)⋅<em>f</em>(<em>y</em>) for words <em>x</em>,<em>y</em> and <em>f</em>(ε) = ι, where ε and ι denotes the identity element of <em>B</em><sup>∗</sup> and <em>M</em>, respectively. The morphism <em>f</em> is determined by its values on the letters of <em>B</em> and conversely any map from <em>B</em> to <em>M</em> extends to a morphism. A morphism is <strong>non-erasing</strong><a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> or <strong>continuous</strong><a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> if no letter of <em>B</em> maps to ι and <strong>trivial</strong> if every letter of <em>B</em> maps to ι.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>

<p>A morphism <em>f</em> from a free monoid <em>B</em><sup>∗</sup> to a free monoid <em>A</em><sup>∗</sup> is <strong>total</strong> if every letter of <em>A</em> occurs in some word in the image of <em>f</em>; <strong>cyclic</strong><a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> or <strong>periodic</strong><a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> if the image of <em>f</em> is contained in <em>w</em><sup>∗</sup> for some word <em>w</em> of <em>A</em><sup>∗</sup>. A morphism <em>f</em> is <strong><em>k</em>-uniform</strong> if the length |<em>f</em>(<em>a</em>)| is constant and equal to <em>k</em> for all <em>a</em> in <em>A</em>.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a><a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> A 1-uniform morphism is <strong>strictly alphabetic</strong><a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> or a <strong>coding</strong>.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a></p>

<p>A morphism <em>f</em> from a free monoid <em>B</em><sup>∗</sup> to a free monoid <em>A</em><sup>∗</sup> is <strong>simplifiable</strong> if there is an alphabet <em>C</em> of cardinality less than that of <em>B</em> such the morphism <em>f</em> factors through <em>C</em><sup>∗</sup>; otherwise <em>f</em> is <strong>elementary</strong>. The morphism <em>f</em> is called a <strong>code</strong> if the image of the alphabet <em>B</em> under <em>f</em> is a code: every elementary morphism is a code.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></p>
<h3 id="test-sets">Test sets</h3>

<p>For <em>L</em> a subset of <em>B</em><sup>∗</sup>, a finite subset <em>T</em> of <em>L</em> is a <em>test set</em> for <em>L</em> if morphisms <em>f</em> and <em>g</em> on <em>B</em><sup>∗</sup> agree on <em>L</em> if and only if they agree on <em>T</em>. The <strong>Ehrenfeucht conjecture</strong> is that any subset <em>L</em> has a test set:<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> it has been proved<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> independently by Albert and Lawrence; McNaughton; and Guba. The proofs rely on <a href="Hilbert's_basis_theorem" title="wikilink">Hilbert's basis theorem</a>.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a></p>
<h2 id="endomorphisms">Endomorphisms</h2>

<p>An <strong><a class="uri" href="endomorphism" title="wikilink">endomorphism</a></strong> of <em>A</em><sup>∗</sup> is a morphism from <em>A</em><sup>∗</sup> to itself.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> The <a href="identity_map" title="wikilink">identity map</a> <em>I</em> is an endomorphism of <em>A</em><sup>∗</sup>, and the endomorphisms form a <a class="uri" href="monoid" title="wikilink">monoid</a> under <a href="composition_of_functions" title="wikilink">composition of functions</a>.</p>

<p>An endomorphism <em>f</em> is <strong>prolongable</strong> if there is a letter <em>a</em> such that <em>f</em>(<em>a</em>) = <em>as</em> for a non-empty string <em>s</em>.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a></p>
<h3 id="string-projection">String projection</h3>

<p>The operation of <a href="String_operations#String_projection" title="wikilink">string projection</a> is an endomorphism. That is, given a letter <em>a</em> ∈ Σ and a string <em>s</em> ∈ Σ<sup>∗</sup>, the string projection <em>p</em><sub>a</sub>(<em>s</em>) removes every occurrence of <em>a</em> from <em>s</em>; it is formally defined by</p>

<p>

<math display="block" id="Free_monoid:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mi>a</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mi>ε</mi>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>s</mi>
        </mrow>
        <mo>=</mo>
        <mrow>
         <mi>ε</mi>
         <mo>,</mo>
         <mtext>the empty string</mtext>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <msub>
         <mi>p</mi>
         <mi>a</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>s</mi>
        </mrow>
        <mo>=</mo>
        <mrow>
         <mi>t</mi>
         <mi>a</mi>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <msub>
         <mi>p</mi>
         <mi>a</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>b</mi>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mi>s</mi>
         </mrow>
         <mo>=</mo>
         <mrow>
          <mi>t</mi>
          <mi>b</mi>
          <mtext>and</mtext>
          <mi>b</mi>
         </mrow>
         <mo>≠</mo>
         <mi>a</mi>
        </mrow>
        <mo>.</mo>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>a</ci>
     </apply>
     <ci>s</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <ci>ε</ci>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>s</ci>
      </apply>
      <list>
       <ci>ε</ci>
       <mtext>the empty string</mtext>
      </list>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>a</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>s</ci>
      </apply>
      <apply>
       <times></times>
       <ci>t</ci>
       <ci>a</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>a</ci>
      </apply>
      <ci>t</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <and></and>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <mtext>if</mtext>
        <ci>s</ci>
       </apply>
       <apply>
        <times></times>
        <ci>t</ci>
        <ci>b</ci>
        <mtext>and</mtext>
        <ci>b</ci>
       </apply>
      </apply>
      <apply>
       <neq></neq>
       <share href="#.cmml">
       </share>
       <ci>a</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{a}(s)=\begin{cases}\varepsilon&\text{if }s=\varepsilon,\text{ the empty %
string}\\
p_{a}(t)&\text{if }s=ta\\
p_{a}(t)b&\text{if }s=tb\text{ and }b\neq a.\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>Note that string projection is well-defined even if the rank of the monoid is infinite, as the above recursive definition works for all strings of finite length. String projection is a <a class="uri" href="morphism" title="wikilink">morphism</a> in the category of free monoids, so that</p>

<p>

<math display="block" id="Free_monoid:1">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mi>a</mi>
    </msub>
    <mrow>
     <mo>(</mo>
     <msup>
      <mi mathvariant="normal">Σ</mi>
      <mo>*</mo>
     </msup>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi mathvariant="normal">Σ</mi>
      <mo>-</mo>
      <mi>a</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Σ</ci>
      <times></times>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <minus></minus>
      <ci>normal-Σ</ci>
      <ci>a</ci>
     </apply>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{a}\left(\Sigma^{*}\right)=\left(\Sigma-a\right)^{*}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Free_monoid:2">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mi>a</mi>
   </msub>
   <mrow>
    <mo>(</mo>
    <msup>
     <mi mathvariant="normal">Σ</mi>
     <mo>*</mo>
    </msup>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{a}\left(\Sigma^{*}\right)
  </annotation>
 </semantics>
</math>

 is understood to be the free monoid of all finite strings that don't contain the letter <em>a</em>. The identity morphism is 

<math display="inline" id="Free_monoid:3">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>ε</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>ε</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{\varepsilon}
  </annotation>
 </semantics>
</math>

, as clearly 

<math display="inline" id="Free_monoid:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mi>ε</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>ε</ci>
     </apply>
     <ci>s</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{\varepsilon}(s)=s
  </annotation>
 </semantics>
</math>

 for all strings <em>s</em>. Of course, it commutes with the operation of string concatenation, so that 

<math display="inline" id="Free_monoid:5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mi>a</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>s</mi>
      <mi>t</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>p</mi>
     <mi>a</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>p</mi>
     <mi>a</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>a</ci>
     </apply>
     <ci>s</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>a</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{a}(st)=p_{a}(s)p_{a}(t)
  </annotation>
 </semantics>
</math>

 for all strings <em>s</em> and <em>t</em>. There are many right inverses to string projection, and thus it is a <a href="split_epimorphism" title="wikilink">split epimorphism</a>.</p>

<p>String projection is commutative, as clearly</p>

<p>

<math display="block" id="Free_monoid:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>p</mi>
      <mi>a</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>p</mi>
        <mi>b</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>p</mi>
      <mi>b</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>p</mi>
        <mi>a</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>b</ci>
      </apply>
      <ci>s</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>a</ci>
      </apply>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{a}(p_{b}(s))=p_{b}(p_{a}(s)).
  </annotation>
 </semantics>
</math>

</p>

<p>For free monoids of finite rank, this follows from the fact that free monoids of the same rank are isomorphic, as projection reduces the rank of the monoid by one.</p>

<p>String projection is <a class="uri" href="idempotent" title="wikilink">idempotent</a>, as</p>

<p>

<math display="block" id="Free_monoid:7">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mi>a</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>a</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>p</mi>
     <mi>a</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>a</ci>
      </apply>
      <ci>s</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>a</ci>
     </apply>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{a}(p_{a}(s))=p_{a}(s)
  </annotation>
 </semantics>
</math>

</p>

<p>for all strings <em>s</em>. Thus, projection is an idempotent, commutative operation, and so it forms a bounded <a class="uri" href="semilattice" title="wikilink">semilattice</a> or a commutative <a href="band_(algebra)" title="wikilink">band</a>.</p>
<h3 id="sturmian-endomorphisms">Sturmian endomorphisms</h3>

<p>An endomorphism of the free monoid <em>B</em><sup>∗</sup> on a 2-letter alphabet <em>B</em> is <strong>Sturmian</strong> if it maps every <a href="Sturmian_word" title="wikilink">Sturmian word</a> to a Sturmian word<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a><a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a> and <strong>locally Sturmian</strong> if it maps some Sturmian word to a Sturmian word.<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> The Sturmian endomorphisms form a submonoid of the monoid of endomorphisms of <em>B</em><sup>∗</sup>.<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a></p>

<p>Define endomorphisms φ and ψ of <em>B</em><sup>∗</sup>, where <em>B</em> = {0,1}, by φ(0) = 01, φ(1) = 0 and ψ(0) = 10, ψ(1) = 0. Then <em>I</em>, φ and ψ are Sturmian,<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> and the Sturmian endomorphisms of <em>B</em><sup>∗</sup> are precisely those endomorphisms in the submonoid of the endomorphism monoid generated by {<em>I</em>,φ,ψ}.<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a><a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a><a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a></p>

<p>A primitive substitution is Sturmian if the image of the word 10010010100101 is balanced.<a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a><a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a></p>
<h2 id="the-free-commutative-monoid">The free commutative monoid</h2>

<p>Given a set <em>A</em>, the <strong>free <a href="commutative_monoid" title="wikilink">commutative monoid</a></strong> on <em>A</em> is the set of all finite <a href="multiset" title="wikilink">multisets</a> with elements drawn from <em>A</em>, with the monoid operation being multiset sum and the monoid unit being the empty multiset.</p>

<p>For example, if <em>A</em> = {<em>a</em>, <em>b</em>, <em>c</em>}, elements of the free commutative monoid on <em>A</em> are of the form</p>
<dl>
<dd>{ε, <em>a</em>, <em>ab</em>, <em>a</em><sup>2</sup><em>b</em>, <em>ab</em><sup>3</sup><em>c</em><sup>4</sup>, ...}.
</dd>
</dl>

<p>The <a href="fundamental_theorem_of_arithmetic" title="wikilink">fundamental theorem of arithmetic</a> states that the monoid of positive integers under multiplication is a free commutative monoid on an infinite set of generators, the <a href="prime_number" title="wikilink">prime numbers</a>.</p>

<p>The <strong>free commutative semigroup</strong> is the subset of the free commutative monoid which contains all multisets with elements drawn from <em>A</em> except the empty multiset.</p>
<h2 id="generalization">Generalization</h2>

<p>The <a href="free_partially_commutative_monoid" title="wikilink">free partially commutative monoid</a>, or <em><a href="trace_monoid" title="wikilink">trace monoid</a></em>, is a generalization that encompasses both the free and free commutative monoids as instances. This generalization finds applications in <a class="uri" href="combinatorics" title="wikilink">combinatorics</a> and in the study of <a href="Parallel_computing" title="wikilink">parallelism</a> in <a href="computer_science" title="wikilink">computer science</a>.</p>
<h2 id="free-monoids-and-computing">Free monoids and computing</h2>

<p>The free monoid on a set <em>A</em> corresponds to <a href="List_(computing)" title="wikilink">lists</a> of elements from <em>A</em> with concatenation as the binary operation. A <a href="monoid_homomorphism" title="wikilink">monoid homomorphism</a> from the free monoid to any other monoid (<em>M</em>,•) is a function <em>f</em> such that</p>
<ul>
<li><em>f</em>(<em>x</em><sub>1</sub>…<em>x</em><sub><em>n</em></sub>) = <em>f</em>(<em>x</em><sub>1</sub>) • … • <em>f</em>(<em>x</em><sub><em>n</em></sub>)</li>
<li><em>f</em>() = <em>e</em></li>
</ul>

<p>where <em>e</em> is the identity on <em>M</em>. Computationally, every such homomorphism corresponds to a <a href="Map_(higher-order_function)" title="wikilink">map</a> operation applying <em>f</em> to all the elements of a list, followed by a <a href="Fold_(higher-order_function)" title="wikilink">fold</a> operation which combines the results using the binary operator •. This <a href="squiggol" title="wikilink">computational paradigm</a> (which can be generalised to non-associative binary operators) has inspired the <a class="uri" href="MapReduce" title="wikilink">MapReduce</a> software framework.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="String_operations" title="wikilink">String operations</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Semigroup_theory" title="wikilink">Category:Semigroup theory</a> <a href="Category:Formal_languages" title="wikilink">Category:Formal languages</a> <a href="Category:Free_algebraic_structures" title="wikilink">Category:Free algebraic structures</a> <a href="Category:Combinatorics_on_words" title="wikilink">Category:Combinatorics on words</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">, [<a class="uri" href="http://books.google.com/books?id=eATLTZzwW-sC&amp;pg">http://books.google.com/books?id=eATLTZzwW-sC&amp;pg;</a>;=PA2]<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4">Since addition of natural numbers is associative, the result doesn't depend on the order of evaluation, thus ensuring the mapping to be well-defined.<a href="#fnref4">↩</a></li>
<li id="fn5">Sakarovitch (2009) p.382<a href="#fnref5">↩</a></li>
<li id="fn6">Sakarovitch (2009) p.27<a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8">Sakarovitch (2009) p.26<a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13">if <em>u</em> contains an even number of "1"s, and <em>ux</em> as well, then <em>x</em> must contain an even number of "1"s, too<a href="#fnref13">↩</a></li>
<li id="fn14">since it is closed with respect to string concatenation<a href="#fnref14">↩</a></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"></li>
<li id="fn28">Salomaa (1981) p.77<a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
<li id="fn31"></li>
<li id="fn32"><a href="#fnref32">↩</a></li>
<li id="fn33">Salomaa (1981) p.72<a href="#fnref33">↩</a></li>
<li id="fn34"><a href="#fnref34">↩</a></li>
<li id="fn35"><a href="#fnref35">↩</a></li>
<li id="fn36"><a href="#fnref36">↩</a></li>
<li id="fn37"><a href="#fnref37">↩</a></li>
<li id="fn38">Allouche &amp; Shallit (2003) p.10<a href="#fnref38">↩</a></li>
<li id="fn39"><a href="#fnref39">↩</a></li>
<li id="fn40"><a href="#fnref40">↩</a></li>
<li id="fn41"><a href="#fnref41">↩</a></li>
<li id="fn42"></li>
<li id="fn43"><a href="#fnref43">↩</a></li>
<li id="fn44"></li>
<li id="fn45"></li>
<li id="fn46"><a href="#fnref46">↩</a></li>
<li id="fn47"></li>
<li id="fn48"><a href="#fnref48">↩</a></li>
</ol>
</section>
</body>
</html>
