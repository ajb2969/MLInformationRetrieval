<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1085">Frequent subtree mining</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Frequent subtree mining</h1>
<hr>In [[computer science]], '''frequent subtree mining''' is the problem 
<p>of finding all patterns in a given database whose support (a metric related to its number of occurrences in other subtrees) is over a given threshold.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> It is a more general form of the maximum agreement subtree problem.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="definition">Definition</h2>

<p>Frequent subtree mining is the problem of trying to find all of the patterns whose "support" is over a certain user-specified support, where "support" is calculated as the number of trees in a database which have at least one subtree <a href="Graph_isomorphism" title="wikilink">isomorphic</a> to a given pattern.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h3 id="formal-definition">Formal definition</h3>

<p>The problem of frequent subtree mining has been formally defined as:<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<dl>
<dd>Given a threshold <em>minfreq</em>, a class of trees 

<math display="inline" id="Frequent_subtree_mining:0">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒞</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{C}
  </annotation>
 </semantics>
</math>

, a transitive subtree relation 

<math display="inline" id="Frequent_subtree_mining:1">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>⪯</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">precedes-or-equals</csymbol>
    <ci>P</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\preceq T
  </annotation>
 </semantics>
</math>

 between trees 

<math display="inline" id="Frequent_subtree_mining:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mo>,</mo>
    <mi>T</mi>
   </mrow>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>P</ci>
     <ci>T</ci>
    </list>
    <ci>𝒞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P,T\in\mathcal{C}
  </annotation>
 </semantics>
</math>

, a finite set of trees 

<math display="inline" id="Frequent_subtree_mining:3">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒟</mi>
   <mo>⊆</mo>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>𝒟</ci>
    <ci>𝒞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{D}\subseteq\mathcal{C}
  </annotation>
 </semantics>
</math>

, the frequent subtree mining problem is the problem of finding all trees 

<math display="inline" id="Frequent_subtree_mining:4">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒫</mi>
   <mo>⊂</mo>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>𝒫</ci>
    <ci>𝒞</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}\subset\mathcal{C}
  </annotation>
 </semantics>
</math>

 such that no two trees in 

<math display="inline" id="Frequent_subtree_mining:5">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒫</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒫</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{P}
  </annotation>
 </semantics>
</math>

 are isomorphic and

<p>

<math display="block" id="Frequent_subtree_mining:6">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>P</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒫</mi>
   <mo>:</mo>
   <mi>freq</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo>,</mo>
    <mi class="ltx_font_mathcaligraphic">𝒟</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>T</mi>
     <mo>∈</mo>
     <mi class="ltx_font_mathcaligraphic">𝒟</mi>
    </mrow>
   </msub>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo>,</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≥</mo>
   <mi>minfreq</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <in></in>
    <csymbol cd="unknown">P</csymbol>
    <ci>normal-:</ci>
    <ci></ci>
    <csymbol cd="unknown">freq</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">D</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <ci>T</ci>
      <ci>𝒟</ci>
     </apply>
    </apply>
    <csymbol cd="unknown">d</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <geq></geq>
    <csymbol cd="unknown">minfreq</csymbol>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall P\in\mathcal{P}:\quad\mathrm{freq}(P,\mathcal{D})=\sum\nolimits_{T\in%
\mathcal{D}}d(P,T)\geq\mathrm{minfreq},
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>where 

<math display="inline" id="Frequent_subtree_mining:7">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 is an anti-monotone function such that if 

<math display="inline" id="Frequent_subtree_mining:8">
 <semantics>
  <mrow>
   <msup>
    <mi>P</mi>
    <mo>′</mo>
   </msup>
   <mo>⪯</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">precedes-or-equals</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{\prime}\preceq P
  </annotation>
 </semantics>
</math>

 then

<p>

<math display="block" id="Frequent_subtree_mining:9">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>T</mi>
   <mo>∈</mo>
   <mi class="ltx_font_mathcaligraphic">𝒞</mi>
   <mo>:</mo>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>P</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≥</mo>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo>,</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">T</csymbol>
    <in></in>
    <csymbol cd="unknown">C</csymbol>
    <ci>normal-:</ci>
    <ci></ci>
    <csymbol cd="unknown">d</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>P</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-,</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <geq></geq>
    <csymbol cd="unknown">d</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall T\in\mathcal{C}:\quad d(P^{\prime},T)\geq d(P,T).
  </annotation>
 </semantics>
</math>

</p>
</dd>
</dl>
<h2 id="algorithms">Algorithms</h2>

<p>In 2002, Mohammed J. Zaki introduced TreeMiner, an efficient algorithm for solving the frequent subtree mining problem, which used a "scope list" to represent tree nodes and which was contrasted with PatternMatcher, an algorithm based on pattern matching.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="applications">Applications</h2>

<p>Domains in which frequent subtree mining is useful tend to involve complex relationships between data entities: for instance, the analysis of XML documents often requires frequent subtree mining.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Another domain where this is useful is the web usage mining problem: since the actions taken by users when visiting a web site can be recorded and categorized in many different ways, complex databases of trees need to be analyzed with frequent subtree mining.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Other domains in which frequent subtree mining is useful include computational biology,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> RNA structure analysis,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> pattern recognition,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> bioinformatics,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> and analysis of the <a class="uri" href="KEGG" title="wikilink">KEGG</a> GLYCAN database.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h2 id="challenges">Challenges</h2>

<p>Checking whether a pattern (or a transaction) supports a given subgraph is an <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> problem, since it is an NP-complete instance of the <a href="subgraph_isomorphism_problem" title="wikilink">subgraph isomorphism problem</a>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Furthermore, due to <a href="combinatorial_explosion" title="wikilink">combinatorial explosion</a>, according to Lei et al., "mining all frequent subtree patterns becomes infeasible for a large and dense tree database".<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Computational_problems_in_graph_theory" title="wikilink">Category:Computational problems in graph theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">Dai, H., Srikant, R. and Zhang, C. (2004). "<a href="http://link.springer.com/book/10.1007%2Fb97861">Advances in Knowledge Discovery and Data Mining.</a>" <em>8th Pacific-Asia Conference, PAKDD 2004, Sydney, Australia, May 26–28, 2004, Proceedings</em>. 1st ed. p. 65.<a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8">Deepak, Akshay, David Fernández-Baca, Srikanta Tirthapura, Michael J. Sanderson, and Michelle M. McMahon. "<a href="http://link.springer.com/article/10.1007/s10115-013-0676-0">EvoMiner: frequent subtree mining in phylogenetic databases</a>." Knowledge and Information Systems (2011): 1-32.<a href="#fnref8">↩</a></li>
<li id="fn9">Chi, Yun, Yirong Yang, and Richard R. Muntz. "<a href="http://link.springer.com/article/10.1007/s10115-004-0180-7">Canonical forms for labelled trees and their applications in frequent subtree mining</a>." <em>Knowledge and Information Systems</em> 8, no. 2 (2005): 203–234.<a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15">Zou, Lei, Yansheng Lu, Huaming Zhang, and Rong Hu. "[//ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4063588 Mining frequent induced subtree patterns with subtree-constraint]." In Data Mining Workshops, 2006. ICDM Workshops 2006. Sixth IEEE International Conference on, pp. 3–7. IEEE, 2006.<a href="#fnref15">↩</a></li>
</ol>
</section>
</hr></body>
</html>
