<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1301">Background subtraction</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Background subtraction</h1>
<hr>'''Background subtraction''', also known as Foreground Detection, is a technique in the fields of [[image processing]] and [[computer vision]] wherein an image's foreground is extracted for further processing (object recognition etc.). Generally an image's regions of interest are objects (humans, cars, text etc.) in its foreground. After the stage of image preprocessing (which may include [[image denoising]], post process
<p>ing like morphology etc.) object localisation is required which may make use of this technique. Background subtraction is a widely used approach for detecting moving objects in videos from static cameras. The rationale in the approach is that of detecting the moving objects from the difference between the current frame and a reference frame, often called “background image”, or “background model”. Background subtraction is mostly done if the image in question is a part of a video stream. Background subtraction provides important cues for numerous applications in computer vision, for example surveillance tracking or human poses estimation. However, background subtraction is generally based on a static background hypothesis which is often not applicable in real environments. With indoor scenes, reflections or animated images on screens lead to background changes. In a same way, due to wind, rain or illumination changes brought by weather, static backgrounds methods have difficulties with outdoor scenes. <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="conventional-approaches">Conventional Approaches</h2>

<p>A robust background subtraction algorithm should be able to handle lighting changes, repetitive motions from clutter and long-term scene changes.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The following analyses make use of the function of <em>V</em>(<em>x</em>,<em>y</em>,<em>t</em>) as a video sequence where <em>t</em> is the time dimension, <em>x</em> and <em>y</em> are the pixel location variables. e.g. <em>V</em>(1,2,3) is the pixel intensity at (1,2) pixel location of the image at <em>t</em> = 3 in the video sequence.</p>
<h3 id="using-frame-differencing">Using frame differencing</h3>

<p>A motion detection algorithm begins with the segmentation part where foreground or moving objects are segmented from the background. The simplest way to implement this is to take an image as background and take the frames obtained at the time t, denoted by I(t) to compare with the background image denoted by B. Here using simple arithmetic calculations, we can segment out the objects simply by using image subtraction technique of computer vision meaning for each pixels in I(t), take the pixel value denoted by P[I(t)] and subtract it with the corresponding pixels at the same position on the background image denoted as P[B].</p>

<p>In mathematical equation, it is written as:</p>

<p>

<math display="block" id="Background_subtraction:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>F</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>I</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>B</mi>
      <mo rspace="4.2pt" stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>F</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>I</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P[F(t)]=P[I(t)]-P[B]\,
  </annotation>
 </semantics>
</math>

</p>

<p>The background is assumed to be the frame at time <em>t</em>. This difference image would only show some intensity for the pixel locations which have changed in the two frames. Though we have seemingly removed the background, this approach will only work for cases where all foreground pixels are moving and all background pixels are static.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> A threshold "Threshold" is put on this difference image to improve the subtraction (see Image <a href="Thresholding_(image_processing)" title="wikilink">thresholding</a>).</p>

<p>

<math display="block" id="Background_subtraction:1">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>F</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>P</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mrow>
        <mi>F</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>t</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">]</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>></mo>
   <mpadded width="+1.7pt">
    <mi>Threshold</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>P</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <ci>F</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>P</ci>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <ci>F</ci>
         <apply>
          <plus></plus>
          <ci>t</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <ci>Threshold</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |P[F(t)]-P[F(t+1)]|>\mathrm{Threshold}\,
  </annotation>
 </semantics>
</math>

</p>

<p>This means that the difference image's pixels' intensities are 'thresholded' or filtered on the basis of value of Threshold. <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The accuracy of this approach is dependent on speed of movement in the scene. Faster movements may require higher thresholds.</p>
<h3 id="mean-filter">Mean filter</h3>

<p>For calculating the image containing only the background, a series of preceding images are averaged. For calculating the background image at the instant <em>t</em>,</p>

<p>

<math display="block" id="Background_subtraction:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>B</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>N</mi>
    </mfrac>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </munderover>
     <mrow>
      <mi>V</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo>,</mo>
       <mrow>
        <mi>t</mi>
        <mo>-</mo>
        <mi>i</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>B</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>N</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <times></times>
       <ci>V</ci>
       <vector>
        <ci>x</ci>
        <ci>y</ci>
        <apply>
         <minus></minus>
         <ci>t</ci>
         <ci>i</ci>
        </apply>
       </vector>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B(x,y)={1\over N}\sum_{i=1}^{N}V(x,y,t-i)
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>N</em> is the number of preceding images taken for averaging. This averaging refers to averaging corresponding pixels in the given images. <em>N</em> would depend on the video speed (number of images per second in the video) and the amount of movement in the video.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> After calculating the background <em>B(x,y)</em> we can then subtract it from the image <em>V(x,y,t)</em> at time <em>t</em>=t and threshold it. Thus the foreground is</p>

<p>

<math display="block" id="Background_subtraction:3">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mi>V</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo>,</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>B</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>></mo>
   <mpadded width="+1.7pt">
    <mi>Th</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>V</ci>
       <vector>
        <ci>x</ci>
        <ci>y</ci>
        <ci>t</ci>
       </vector>
      </apply>
      <apply>
       <times></times>
       <ci>B</ci>
       <interval closure="open">
        <ci>x</ci>
        <ci>y</ci>
       </interval>
      </apply>
     </apply>
    </apply>
    <ci>Th</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |V(x,y,t)-B(x,y)|>\mathrm{Th}\,
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>Th</em> is threshold. Similarly we can also use median instead of mean in the above calculation of <em>B</em>(<em>x</em>,<em>y</em>).</p>

<p>Usage of global and time-independent Thresholds (same Th value for all pixels in the image) may limit the accuracy of the above two approaches.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h3 id="running-gaussian-average">Running Gaussian average</h3>

<p>For this method, Wren et al.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> propose fitting a <a href="Gaussian_function" title="wikilink">Gaussian probabilistic density function</a> (pdf) on the most recent 

<math display="inline" id="Background_subtraction:4">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 frames. In order to avoid fitting the pdf from scratch at each new frame time 

<math display="inline" id="Background_subtraction:5">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, a running (or on-line cumulative) average is computed.</p>

<p>The pdf of every pixel is characterized by <a class="uri" href="mean" title="wikilink">mean</a> 

<math display="inline" id="Background_subtraction:6">
 <semantics>
  <msub>
   <mi>μ</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>μ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{t}
  </annotation>
 </semantics>
</math>

 and <a class="uri" href="variance" title="wikilink">variance</a> <span style="vertical-align: 15%"> 

<math display="inline" id="Background_subtraction:7">
 <semantics>
  <msubsup>
   <mi>σ</mi>
   <mi>t</mi>
   <mn>2</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>σ</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}_{t}
  </annotation>
 </semantics>
</math>

 </span>. The following is a possible initial condition (assuming that initially every pixel is background):</p>

<p>

<math display="inline" id="Background_subtraction:8">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>I</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{0}=I_{0}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Background_subtraction:9">
 <semantics>
  <mrow>
   <msubsup>
    <mi>σ</mi>
    <mn>0</mn>
    <mn>2</mn>
   </msubsup>
   <mo>=</mo>
   <mo><</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>σ</ci>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <lt></lt>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}_{0}=<
  </annotation>
 </semantics>
</math>

 some default value 

<math display="inline" id="Background_subtraction:10">
 <semantics>
  <mo>></mo>
  <annotation-xml encoding="MathML-Content">
   <gt></gt>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   >
  </annotation>
 </semantics>
</math>

</p>

<p>where <span style="vertical-align:15%;"> 

<math display="inline" id="Background_subtraction:11">
 <semantics>
  <msub>
   <mi>I</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{t}
  </annotation>
 </semantics>
</math>

 </span> is the value of the pixel's intensity at time 

<math display="inline" id="Background_subtraction:12">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

. In order to initialize variance, we can, for example, use the variance in x and y from a small window around each pixel.</p>

<p>Note that background may change over time (e.g. due to illumination changes or non-static background objects). To accommodate for that change, at every frame 

<math display="inline" id="Background_subtraction:13">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, every pixel's mean and variance must be updated, as follows:</p>

<p>

<math display="inline" id="Background_subtraction:14">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>ρ</mi>
     <msub>
      <mi>I</mi>
      <mi>t</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>ρ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>μ</mi>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>ρ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>ρ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{t}=\rho I_{t}+(1-\rho)\mu_{t-1}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Background_subtraction:15">
 <semantics>
  <mrow>
   <msubsup>
    <mi>σ</mi>
    <mi>t</mi>
    <mn>2</mn>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>d</mi>
      <mn>2</mn>
     </msup>
     <mi>ρ</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>ρ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msubsup>
      <mi>σ</mi>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mn>2</mn>
     </msubsup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>σ</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>d</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>ρ</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>ρ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>σ</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}_{t}=d^{2}\rho+(1-\rho)\sigma^{2}_{t-1}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Background_subtraction:16">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>I</mi>
       <mi>t</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>μ</mi>
       <mi>t</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>d</ci>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>t</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=|(I_{t}-\mu_{t})|
  </annotation>
 </semantics>
</math>

</p>

<p>Where 

<math display="inline" id="Background_subtraction:17">
 <semantics>
  <mi>ρ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ρ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

 determines the size of the temporal window that is used to fit the pdf (usually 

<math display="inline" id="Background_subtraction:18">
 <semantics>
  <mrow>
   <mi>ρ</mi>
   <mo>=</mo>
   <mn>0.01</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ρ</ci>
    <cn type="float">0.01</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho=0.01
  </annotation>
 </semantics>
</math>

 ) and <span style="vertical-align:15%;"> 

<math display="inline" id="Background_subtraction:19">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 </span> is the Euclidean distance between the mean and the value of the pixel.</p>
<figure><b>(Figure)</b>
<figcaption>Gaussian distribution for each pixel.</figcaption>
</figure>

<p>We can now classify a pixel as background if its current intensity lies within some <a href="confidence_interval" title="wikilink">confidence interval</a> of its distribution's mean:</p>

<p>

<math display="inline" id="Background_subtraction:20">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>I</mi>
        <mi>t</mi>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>μ</mi>
        <mi>t</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <msub>
     <mi>σ</mi>
     <mi>t</mi>
    </msub>
   </mfrac>
   <mo>></mo>
   <mi>k</mi>
   <mo>⟶</mo>
   <mi>𝐹𝑜𝑟𝑒𝑔𝑟𝑜𝑢𝑛𝑑</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <gt></gt>
     <apply>
      <divide></divide>
      <apply>
       <abs></abs>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>I</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>μ</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <ci>normal-⟶</ci>
     <share href="#.cmml">
     </share>
     <ci>𝐹𝑜𝑟𝑒𝑔𝑟𝑜𝑢𝑛𝑑</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{|(I_{t}-\mu_{t})|}{\sigma_{t}}>k\longrightarrow\mathit{Foreground}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Background_subtraction:21">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>I</mi>
        <mi>t</mi>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>μ</mi>
        <mi>t</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <msub>
     <mi>σ</mi>
     <mi>t</mi>
    </msub>
   </mfrac>
   <mo>≤</mo>
   <mi>k</mi>
   <mo>⟶</mo>
   <mi>𝐵𝑎𝑐𝑘𝑔𝑟𝑜𝑢𝑛𝑑</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <divide></divide>
      <apply>
       <abs></abs>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>I</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>μ</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>σ</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <ci>normal-⟶</ci>
     <share href="#.cmml">
     </share>
     <ci>𝐵𝑎𝑐𝑘𝑔𝑟𝑜𝑢𝑛𝑑</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{|(I_{t}-\mu_{t})|}{\sigma_{t}}\leq k\longrightarrow\mathit{Background}
  </annotation>
 </semantics>
</math>

</p>

<p>where the parameter <span style="vertical-align:15%;">

<math display="inline" id="Background_subtraction:22">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

</span> is a free threshold (usually <span style="vertical-align:15%;"> 

<math display="inline" id="Background_subtraction:23">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mn>2.5</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <cn type="float">2.5</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=2.5
  </annotation>
 </semantics>
</math>

 </span>). A larger value for 

<math display="inline" id="Background_subtraction:24">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 allows for more dynamic background, while a smaller 

<math display="inline" id="Background_subtraction:25">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 increases the probability of a transition from background to foreground due to more subtle changes.</p>

<p>In a variant of the method, a pixel's distribution is only updated if it is classified as background. This is to prevent newly introduced foreground objects from fading into the background. The update formula for the mean is changed accordingly:</p>

<p>

<math display="inline" id="Background_subtraction:26">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mi>t</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>M</mi>
     <msub>
      <mi>μ</mi>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>M</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>I</mi>
         <mi>t</mi>
        </msub>
        <mi>ρ</mi>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <mi>ρ</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <msub>
         <mi>μ</mi>
         <mrow>
          <mi>t</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>M</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <apply>
        <minus></minus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>M</ci>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>I</ci>
         <ci>t</ci>
        </apply>
        <ci>ρ</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <ci>ρ</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>μ</ci>
         <apply>
          <minus></minus>
          <ci>t</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{t}=M\mu_{t-1}+(1-M)(I_{t}\rho+(1-\rho)\mu_{t-1})
  </annotation>
 </semantics>
</math>

</p>

<p>where <span style="vertical-align:15%;"> 

<math display="inline" id="Background_subtraction:27">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=1
  </annotation>
 </semantics>
</math>

 </span> when 

<math display="inline" id="Background_subtraction:28">
 <semantics>
  <msub>
   <mi>I</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{t}
  </annotation>
 </semantics>
</math>

 is considered foreground and <span style="vertical-align: 15%"> 

<math display="inline" id="Background_subtraction:29">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=0
  </annotation>
 </semantics>
</math>

 </span> otherwise. So when <span style="vertical-align:15%;"> 

<math display="inline" id="Background_subtraction:30">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=1
  </annotation>
 </semantics>
</math>

 </span>, that is, when the pixel is detected as foreground, the mean will stay the same. As a result, a pixel, once it has become foreground, can only become background again when the intensity value gets close to what it was before turning foreground. This method, however, has several issues: It only works if all pixels are initially background pixels (or foreground pixels are annotated as such). Also, it cannot cope with gradual background changes: If a pixel is categorized as foreground for a too long period of time, the background intensity in that location might have changed (because illumination has changed etc.). As a result, once the foreground object is gone, the new background intensity might not be recognized as such anymore.</p>
<h3 id="background-mixture-models">Background mixture models</h3>

<p>In this technique, it is assumed that every pixel's intensity values in the video can be modeled using a <a href="Gaussian_mixture_model" title="wikilink">Gaussian mixture model</a>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> A simple heuristic determines which intensities are most probably of the background. Then the pixels which do not match to these are called the foreground pixels. Foreground pixels are grouped using 2D <a href="Connected-component_labeling" title="wikilink">connected component</a> analysis.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>At any time t, a particular pixel (

<math display="inline" id="Background_subtraction:31">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">0</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0},y_{0}
  </annotation>
 </semantics>
</math>

)'s history is</p>

<p>

<math display="block" id="Background_subtraction:32">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>X</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mi>t</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>0</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mn>0</mn>
      </msub>
      <mo>,</mo>
      <mi>i</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mn>1</mn>
     <mo>⩽</mo>
     <mi>i</mi>
     <mo>⩽</mo>
     <mi>t</mi>
    </mrow>
    <mo rspace="4.2pt" stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>t</ci>
     </apply>
    </list>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <ci>V</ci>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>i</ci>
      </vector>
     </apply>
     <apply>
      <and></and>
      <apply>
       <leq></leq>
       <cn type="integer">1</cn>
       <ci>i</ci>
      </apply>
      <apply>
       <leq></leq>
       <share href="#.cmml">
       </share>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{1},\ldots,X_{t}=\{V(x_{0},y_{0},i):1\leqslant i\leqslant t\}\,
  </annotation>
 </semantics>
</math>

</p>

<p>This history is modeled by a mixture of <em>K</em> Gaussian distributions:</p>

<p>

<math display="block" id="Background_subtraction:33">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>X</mi>
     <mi>t</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <munderover>
    <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>K</mi>
   </munderover>
   <msub>
    <mi>ω</mi>
    <mrow>
     <mi>i</mi>
     <mo>,</mo>
     <mi>t</mi>
    </mrow>
   </msub>
   <mi>N</mi>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>X</mi>
     <mi>t</mi>
    </msub>
    <mo>∣</mo>
    <msub>
     <mi>μ</mi>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>t</mi>
     </mrow>
    </msub>
    <mo>,</mo>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>t</mi>
     </mrow>
    </msub>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>K</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <list>
      <ci>i</ci>
      <ci>t</ci>
     </list>
    </apply>
    <csymbol cd="unknown">N</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <list>
       <ci>i</ci>
       <ci>t</ci>
      </list>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <list>
       <ci>i</ci>
       <ci>t</ci>
      </list>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X_{t})=\sum_{i=1}^{K}\omega_{i,t}N\left(X_{t}\mid\mu_{i,t},\Sigma_{i,t}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="block" id="Background_subtraction:34">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mrow>
    <mo>(</mo>
    <msub>
     <mi>X</mi>
     <mi>t</mi>
    </msub>
    <mo>∣</mo>
    <msub>
     <mi>μ</mi>
     <mrow>
      <mi>i</mi>
      <mi>t</mi>
     </mrow>
    </msub>
    <mo>,</mo>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>t</mi>
     </mrow>
    </msub>
    <mo>)</mo>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi>D</mi>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msup>
   </mfrac>
   <mfrac>
    <mn>1</mn>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <msub>
       <mi mathvariant="normal">Σ</mi>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mi>t</mi>
       </mrow>
      </msub>
      <mo stretchy="false">|</mo>
     </mrow>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msup>
   </mfrac>
   <mi>exp</mi>
   <mrow>
    <mo>(</mo>
    <mo>-</mo>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>X</mi>
       <mi>t</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>μ</mi>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mi>t</mi>
       </mrow>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>T</mi>
    </msup>
    <msubsup>
     <mi mathvariant="normal">Σ</mi>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>t</mi>
     </mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
    <mrow>
     <mo>(</mo>
     <msub>
      <mi>X</mi>
      <mi>t</mi>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>μ</mi>
      <mrow>
       <mi>i</mi>
       <mo>,</mo>
       <mi>t</mi>
      </mrow>
     </msub>
     <mo>)</mo>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">N</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <list>
       <ci>i</ci>
       <ci>t</ci>
      </list>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
      </apply>
      <apply>
       <divide></divide>
       <ci>D</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Σ</ci>
        <list>
         <ci>i</ci>
         <ci>t</ci>
        </list>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <exp></exp>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <minus></minus>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <ci>t</ci>
       </apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <list>
         <ci>i</ci>
         <ci>t</ci>
        </list>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>T</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Σ</ci>
       <list>
        <ci>i</ci>
        <ci>t</ci>
       </list>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <ci>t</ci>
      </apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>μ</ci>
       <list>
        <ci>i</ci>
        <ci>t</ci>
       </list>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\left(X_{t}\mid\mu_{it},\Sigma_{i,t}\right)=\dfrac{1}{(2\pi)^{D/2}}{1\over|%
\Sigma_{i,t}|^{1/2}}\exp\left(-{1\over 2}(X_{t}-\mu_{i,t})^{T}\Sigma_{i,t}^{-1%
}\left(X_{t}-\mu_{i,t}\right)\right)
  </annotation>
 </semantics>
</math>

</p>

<p>An on-line <a class="uri" href="K-means" title="wikilink">K-means</a> approximation is used to update the Gaussians. Numerous improvements of this original method developed by Stauffer and Grimson <a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> have been proposed and a complete survey can be found in Bouwmans et al.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h3 id="surveys">Surveys</h3>

<p>Several surveys which concern categories or sub-categories of models can be found as follows:</p>
<ul>
<li>MOG Background Subtraction</li>
</ul>

<p>First, each pixel is characterized by its intensity in RGB color space. Then probability of observing the current pixel is given by the following formula in the multidimensional case</p>

<p>

<math display="block" id="Background_subtraction:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>X</mi>
      <mi>t</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>K</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>ω</mi>
      <mrow>
       <mi>i</mi>
       <mo>,</mo>
       <mi>t</mi>
      </mrow>
     </msub>
     <mi>η</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mpadded width="+1.7pt">
        <msub>
         <mi>X</mi>
         <mi>t</mi>
        </msub>
       </mpadded>
       <msub>
        <mi>μ</mi>
        <mrow>
         <mi>i</mi>
         <mo>,</mo>
         <mi>t</mi>
        </mrow>
       </msub>
      </mrow>
      <mo>,</mo>
      <msub>
       <mi mathvariant="normal">Σ</mi>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mi>t</mi>
       </mrow>
      </msub>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>K</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <list>
        <ci>i</ci>
        <ci>t</ci>
       </list>
      </apply>
      <ci>η</ci>
      <interval closure="open">
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>t</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>μ</ci>
         <list>
          <ci>i</ci>
          <ci>t</ci>
         </list>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-Σ</ci>
        <list>
         <ci>i</ci>
         <ci>t</ci>
        </list>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(X_{t})=\sum_{i=1}^{K}\omega_{i,t}\eta\left(X_{t}\,\mu_{i,t},\Sigma_{i,t}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>Where the parameters are K is the number of distributions, ω is a weight associated to the ith Gaussian at time t with mean µ and standard deviation Σ .</p>

<p>

<math display="block" id="Background_subtraction:36">
 <semantics>
  <mrow>
   <mrow>
    <mi>η</mi>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <msub>
        <mi>X</mi>
        <mi>t</mi>
       </msub>
      </mpadded>
      <msub>
       <mi>μ</mi>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mi>t</mi>
       </mrow>
      </msub>
     </mrow>
     <mo>,</mo>
     <msub>
      <mi mathvariant="normal">Σ</mi>
      <mrow>
       <mi>i</mi>
       <mo>,</mo>
       <mi>t</mi>
      </mrow>
     </msub>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mn>2</mn>
          <mo>/</mo>
          <mi>p</mi>
         </mrow>
         <mi>i</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mi>n</mi>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </msup>
      <msubsup>
       <mi mathvariant="normal">Σ</mi>
       <mrow>
        <mi>i</mi>
        <mo>,</mo>
        <mi>t</mi>
       </mrow>
       <mn>0.5</mn>
      </msubsup>
     </mrow>
    </mfrac>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mfrac>
         <mn>1</mn>
         <mn>2</mn>
        </mfrac>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msub>
           <mi>X</mi>
           <mi>t</mi>
          </msub>
          <mo>-</mo>
          <msub>
           <mi>μ</mi>
           <mrow>
            <mi>i</mi>
            <mo>,</mo>
            <mi>t</mi>
           </mrow>
          </msub>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <msub>
         <mi mathvariant="normal">Σ</mi>
         <mrow>
          <mi>i</mi>
          <mo>,</mo>
          <mi>t</mi>
         </mrow>
        </msub>
        <mrow>
         <mo>(</mo>
         <mrow>
          <msub>
           <mi>X</mi>
           <mi>t</mi>
          </msub>
          <mo>-</mo>
          <msub>
           <mi>μ</mi>
           <mrow>
            <mi>i</mi>
            <mo>,</mo>
            <mi>t</mi>
           </mrow>
          </msub>
         </mrow>
         <mo>)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>η</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <list>
         <ci>i</ci>
         <ci>t</ci>
        </list>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Σ</ci>
       <list>
        <ci>i</ci>
        <ci>t</ci>
       </list>
      </apply>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <cn type="integer">2</cn>
          <ci>p</ci>
         </apply>
         <ci>i</ci>
        </apply>
        <apply>
         <divide></divide>
         <ci>n</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-Σ</ci>
         <list>
          <ci>i</ci>
          <ci>t</ci>
         </list>
        </apply>
        <cn type="float">0.5</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <exp></exp>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>X</ci>
          <ci>t</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>μ</ci>
          <list>
           <ci>i</ci>
           <ci>t</ci>
          </list>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-Σ</ci>
         <list>
          <ci>i</ci>
          <ci>t</ci>
         </list>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>X</ci>
          <ci>t</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>μ</ci>
          <list>
           <ci>i</ci>
           <ci>t</ci>
          </list>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta\left(X_{t}\,\mu_{i,t},\Sigma_{i,t}\right)=\dfrac{1}{(2/pi)^{n/2}\Sigma_{i%
,t}^{0.5}}\exp\left(-{1\over 2}(X_{t}-\mu_{i,t})\Sigma_{i,t}\left(X_{t}-\mu_{i%
,t}\right)\right)
  </annotation>
 </semantics>
</math>

</p>

<p>Once the parameters initialization is made, a first foreground detection can be made then the parameters are updated. The first B Gaussian distribution which exceeds the threshold T is re-tained for a background distribution</p>

<p>

<math display="block" id="Background_subtraction:37">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>=</mo>
   <mi>a</mi>
   <mi>r</mi>
   <mi>g</mi>
   <mi>m</mi>
   <mi>i</mi>
   <mi>n</mi>
   <mrow>
    <mo>(</mo>
    <msubsup>
     <mi mathvariant="normal">Σ</mi>
     <mrow>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mi>B</mi>
    </msubsup>
    <msub>
     <mi>ω</mi>
     <mrow>
      <mi>i</mi>
      <mo>,</mo>
      <mi>t</mi>
     </mrow>
    </msub>
    <mo>></mo>
    <mi>T</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">B</csymbol>
    <eq></eq>
    <csymbol cd="unknown">a</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <csymbol cd="unknown">g</csymbol>
    <csymbol cd="unknown">m</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Σ</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>B</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <list>
       <ci>i</ci>
       <ci>t</ci>
      </list>
     </apply>
     <gt></gt>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B=argmin\left(\Sigma_{i-1}^{B}\omega_{i,t}>T\right)
  </annotation>
 </semantics>
</math>

</p>

<p>The other distributions are considered to represent a foreground distribution. Then, when the new frame incomes at times 

<math display="inline" id="Background_subtraction:38">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>t</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t+1
  </annotation>
 </semantics>
</math>

, a match test is made of each pixel. A pixel matches a Gaussian distribution if the Mahalanobis distance</p>

<p>

<math display="block" id="Background_subtraction:39">
 <semantics>
  <mrow>
   <msub>
    <mi>σ</mi>
    <mrow>
     <mi>i</mi>
     <mo>,</mo>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>ρ</mi>
      </mrow>
      <mo>)</mo>
     </mrow>
     <msubsup>
      <mi>σ</mi>
      <mrow>
       <mi>i</mi>
       <mo>,</mo>
       <mi>t</mi>
      </mrow>
      <mn>2</mn>
     </msubsup>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>ρ</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msub>
        <mi>X</mi>
        <mrow>
         <mi>x</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>μ</mi>
        <mrow>
         <mi>x</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mrow>
      <mo>)</mo>
     </mrow>
     <msup>
      <mrow>
       <mo>(</mo>
       <mrow>
        <msub>
         <mi>X</mi>
         <mrow>
          <mi>x</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>μ</mi>
         <mrow>
          <mi>x</mi>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mrow>
       <mo>)</mo>
      </mrow>
      <mi>T</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <list>
      <ci>i</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </list>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>ρ</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>σ</ci>
        <list>
         <ci>i</ci>
         <ci>t</ci>
        </list>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>ρ</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <apply>
         <plus></plus>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <apply>
         <plus></plus>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <apply>
          <plus></plus>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>μ</ci>
         <apply>
          <plus></plus>
          <ci>x</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{i,t+1}=\left(1-\rho\right)\sigma_{i,t}^{2}+\rho\left(X_{x+1}-\mu_{x+1}%
\right)\left(X_{x+1}-\mu_{x+1}\right)^{T}
  </annotation>
 </semantics>
</math>

.Then, two cases can occur:</p>

<p>Case 1: A match is found with one of the K Gaussians. For the matched component, the update is done as follows<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>

<math display="block" id="Background_subtraction:40">
 <semantics>
  <mrow>
   <msub>
    <mi>σ</mi>
    <mrow>
     <mi>i</mi>
     <mo>,</mo>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mn>1</mn>
    <mo>-</mo>
    <mi>α</mi>
    <mo>)</mo>
   </mrow>
   <msub>
    <mi>ω</mi>
    <mrow>
     <mi>i</mi>
     <mo>,</mo>
     <mi>t</mi>
    </mrow>
   </msub>
   <mo>+</mo>
   <mi>α</mi>
   <mi>P</mi>
   <mrow>
    <mo>(</mo>
    <mi>k</mi>
    <mo rspace="7.5pt">∣</mo>
    <msub>
     <mi>X</mi>
     <mi>t</mi>
    </msub>
    <mo>,</mo>
    <mi>ϕ</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <list>
      <ci>i</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </list>
    </apply>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">1</cn>
     <minus></minus>
     <csymbol cd="unknown">α</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <list>
      <ci>i</ci>
      <ci>t</ci>
     </list>
    </apply>
    <plus></plus>
    <csymbol cd="unknown">α</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">k</csymbol>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-,</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{i,t+1}=\left(1-\alpha\right)\omega_{i,t}+\alpha P\left(k\mid\ X_{t},%
\phi\right)
  </annotation>
 </semantics>
</math>

</p>

<p>Power and Schoonees [3] used the same algorithm to segment the foreground of the image</p>

<p>

<math display="inline" id="Background_subtraction:41">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo>(</mo>
    <mi>k</mi>
    <mo rspace="7.5pt">∣</mo>
    <msub>
     <mi>X</mi>
     <mi>t</mi>
    </msub>
    <mo>,</mo>
    <mi>ϕ</mi>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">k</csymbol>
     <ci>normal-∣</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-,</ci>
     <csymbol cd="unknown">ϕ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\left(k\mid\ X_{t},\phi\right)
  </annotation>
 </semantics>
</math>

</p>

<p>The essential approximation to 

<math display="inline" id="Background_subtraction:42">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mo stretchy="false">(</mo>
   </msub>
   <mi>k</mi>
   <mo>,</mo>
   <mi>t</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <ci>normal-(</ci>
    </apply>
    <csymbol cd="unknown">k</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">t</csymbol>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{(}k,t)
  </annotation>
 </semantics>
</math>

 is given by 

<math display="block" id="Background_subtraction:43">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>M</mi>
     <mo stretchy="false">(</mo>
    </msub>
    <mi>k</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
   <mrow>
    <mo>(</mo>
    <mi>m</mi>
    <mi>a</mi>
    <mi>t</mi>
    <mi>c</mi>
    <mi>h</mi>
    <mo>)</mo>
   </mrow>
   <mo>,</mo>
   <msub>
    <mi>M</mi>
    <mo stretchy="false">(</mo>
   </msub>
   <mi>k</mi>
   <mo>,</mo>
   <mi>t</mi>
   <mo stretchy="false">)</mo>
   <mo>=</mo>
   <mn>0</mn>
   <mo>(</mo>
   <mi>o</mi>
   <mi>t</mi>
   <mi>h</mi>
   <mi>e</mi>
   <mi>r</mi>
   <mi>w</mi>
   <mi>i</mi>
   <mi>s</mi>
   <mi>e</mi>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>normal-(</ci>
     </apply>
     <csymbol cd="unknown">k</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">1</cn>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">m</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <csymbol cd="unknown">c</csymbol>
     <csymbol cd="unknown">h</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <ci>normal-(</ci>
    </apply>
    <csymbol cd="unknown">k</csymbol>
    <ci>normal-,</ci>
    <csymbol cd="unknown">t</csymbol>
    <ci>normal-)</ci>
    <eq></eq>
    <cn type="integer">0</cn>
    <ci>normal-(</ci>
    <csymbol cd="unknown">o</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <csymbol cd="unknown">h</csymbol>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <csymbol cd="unknown">w</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <csymbol cd="unknown">e</csymbol>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{(}k,t)=1\left(match\right),M_{(}k,t)=0\left(otherwise\right)
  </annotation>
 </semantics>
</math>

<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>

<math display="inline" id="Background_subtraction:44">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

</p>

<p>Case 2: No match is found with any of the

<math display="inline" id="Background_subtraction:45">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

Gaussians. In this case, the least probable distribu-tion 

<math display="block" id="Background_subtraction:46">
 <semantics>
  <mrow>
   <msub>
    <mi>k</mi>
    <mrow>
     <mi>i</mi>
     <mo>.</mo>
     <mi>t</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>l</mi>
    <mi>o</mi>
    <mi>w</mi>
    <mi>P</mi>
    <mi>r</mi>
    <mi>i</mi>
    <mi>o</mi>
    <mi>r</mi>
    <mi>W</mi>
    <mi>e</mi>
    <mi>i</mi>
    <mi>g</mi>
    <mi>h</mi>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <ci>i</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <ci>w</ci>
     <ci>P</ci>
     <ci>r</ci>
     <ci>i</ci>
     <ci>o</ci>
     <ci>r</ci>
     <ci>W</ci>
     <ci>e</ci>
     <ci>i</ci>
     <ci>g</ci>
     <ci>h</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{i.t}=lowPriorWeight
  </annotation>
 </semantics>
</math>

 is replaced with a new one with parameters</p>

<p>

<math display="block" id="Background_subtraction:47">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mrow>
     <mi>i</mi>
     <mo>,</mo>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>X</mi>
    <mrow>
     <mi>t</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <list>
      <ci>i</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </list>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <apply>
      <plus></plus>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{i,t+1}=X_{t+1}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Background_subtraction:48">
 <semantics>
  <mrow>
   <msub>
    <mi>k</mi>
    <mrow>
     <mi>i</mi>
     <mo>.</mo>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>L</mi>
    <mi>a</mi>
    <mi>r</mi>
    <mi>g</mi>
    <mi>e</mi>
    <mi>I</mi>
    <mi>n</mi>
    <mi>i</mi>
    <mi>t</mi>
    <mi>i</mi>
    <mi>a</mi>
    <mi>l</mi>
    <mi>W</mi>
    <mi>e</mi>
    <mi>i</mi>
    <mi>g</mi>
    <mi>h</mi>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <ci>i</ci>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>a</ci>
     <ci>r</ci>
     <ci>g</ci>
     <ci>e</ci>
     <ci>I</ci>
     <ci>n</ci>
     <ci>i</ci>
     <ci>t</ci>
     <ci>i</ci>
     <ci>a</ci>
     <ci>l</ci>
     <ci>W</ci>
     <ci>e</ci>
     <ci>i</ci>
     <ci>g</ci>
     <ci>h</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{i.t+1}=LargeInitialWeight
  </annotation>
 </semantics>
</math>

</p>

<p><span class="LaTeX">$$k_{i.t+1}= Large Initial Weight$$</span></p>

<p>Once the parameter maintenance is made, foreground detection can be made and so on.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>Relative OPEN CV background /foreground segmentation algorithm can be found in the link below:</p>

<p><a class="uri" href="http://docs.opencv.org/trunk/doc/py_tutorials/py_video/py_bg_subtraction/py_bg_subtraction.html">http://docs.opencv.org/trunk/doc/py_tutorials/py_video/py_bg_subtraction/py_bg_subtraction.html</a></p>
<ul>
<li>Subspace Learning Background Subtraction <a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></li>
</ul>
<ul>
<li>Statistical Background Subtraction <a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></li>
</ul>
<ul>
<li>Fuzzy Background Subtraction <a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></li>
</ul>
<ul>
<li>RPCA Background Subtraction <a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a><a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> (See <a href="Robust_principal_component_analysis" title="wikilink">Robust principal component analysis</a> for more details)</li>
</ul>
<ul>
<li>Traditional and Recent Approaches for Background Subtraction <a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a><a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></li>
</ul>
<h2 id="books-journals-and-workshops">Books, Journals and Workshops</h2>
<h3 id="books">Books</h3>

<p>T. Bouwmans, F. Porikli, B. Horferlin, A. Vacavant, Handbook on "Background Modeling and Foreground Detection for Video Surveillance: Traditional and Recent Approaches, Implementations, Benchmarking and Evaluation", CRC Press, Taylor and Francis Group, June 2014. (For more information: <a class="uri" href="http://www.crcpress.com/product/isbn/9781482205374">http://www.crcpress.com/product/isbn/9781482205374</a>)</p>
<h3 id="journals">Journals</h3>
<ul>
<li>T. Bouwmans, L. Davis, J. Gonzalez, M. Piccardi, C. Shan, Special Issue on "Background Modeling for Foreground Detection in Real-World Dynamic Scenes", Special Issue in Machine Vision and Applications, July 2014.</li>
<li>A. Vacavant, L. Tougne, T. Chateau, "Special section on background models comparison", Computer Vision and Image Understanding, CVIU 2014, May 2014.</li>
</ul>
<h3 id="workshops">Workshops</h3>
<ul>
<li>Scene Background Modeling and Initialization (SBMI 2015) Workshop in conjunction with ICIAP 2015.</li>
<li>IEEE on Change Detection Workshop in conjunction with CVPR 2014.</li>
<li>Workshop on Background Model Challenges (BMC 2012) in conjunction with ACCV 2012.</li>
</ul>
<h2 id="resources-datasets-and-codes">Resources, Datasets and Codes</h2>
<h3 id="bgs-web-site">BGS Web Site</h3>

<p>The Background Subtraction Web Site (T. Bouwmans, Univ. La Rochelle, France) contains a full list of the references in the field, links to available datasets and codes. (For more information: <a class="uri" href="http://sites.google.com/site/backgroundsubtraction/overview">http://sites.google.com/site/backgroundsubtraction/overview</a>)</p>
<h3 id="bgs-datasets">BGS Datasets</h3>
<ul>
<li>ChangeDetection.net (For more information: <a class="uri" href="http://www.changedetection.net/">http://www.changedetection.net/</a>)</li>
<li>Background Models Challenge (For more information: <a class="uri" href="http://bmc.univ-bpclermont.fr/">http://bmc.univ-bpclermont.fr/</a>)</li>
<li>Stuttgart Artificial Background Subtraction Dataset (For more information: <a class="uri" href="http://www.vis.uni-stuttgart.de/index.php?id=sabs">http://www.vis.uni-stuttgart.de/index.php?id=sabs</a>)</li>
<li>SBMI dataset (For more information: <a class="uri" href="http://sbmi2015.na.icar.cnr.it/">http://sbmi2015.na.icar.cnr.it/</a>)</li>
</ul>
<h3 id="bgs-libraries">BGS Libraries</h3>
<ul>
<li>BGS Library</li>
</ul>

<p>The BGS Library (A. Sobral, Univ. La Rochelle, France) provides a C++ framework to perform background subtraction algorithms. The code works either on Windows or on Linux. Currently the library offers 29 BGS algorithms. (For more information: <a class="uri" href="http://github.com/andrewssobral/bgslibrary">http://github.com/andrewssobral/bgslibrary</a>)</p>
<ul>
<li>LRS Library - Low-Rank and Sparse tools for Background Modeling and Subtraction in Videos</li>
</ul>

<p>The LRSLibrary (A. Sobral, Univ. La Rochelle, France) provides a collection of low-rank and sparse decomposition algorithms in MATLAB. The library was designed for motion segmentation in videos, but it can be also used or adapted for other computer vision problems. Currently the LRSLibrary contains a total of 64 matrix-based and tensor-based algorithms. The LRSLibrary was tested successfully in MATLAB R2013b both x86 and x64 versions. (For more information: <a class="uri" href="https://github.com/andrewssobral/lrslibrary#lrslibrary">https://github.com/andrewssobral/lrslibrary#lrslibrary</a>)</p>
<h2 id="applications">Applications</h2>
<ul>
<li>Video Surveillance</li>
<li>Optical Motion Capture</li>
<li>Human Computer Interaction</li>
<li>Content based Video Coding</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="ViBe" title="wikilink">ViBe</a></li>
<li>PBAS</li>
<li>SOBS</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Articles_created_via_the_Article_Wizard" title="wikilink">Category:Articles created via the Article Wizard</a> <a href="Category:Mathematical_examples" title="wikilink">Category:Mathematical examples</a> <a href="Category:Image_processing" title="wikilink">Category:Image processing</a> <a href="Category:Computer_vision" title="wikilink">Category:Computer vision</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
</ol>
</section>
</hr></body>
</html>
