<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title offset="409">Fixed-point combinator</title>
   <script type="text/javascript"
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js">
    </script>
</head>
<body>
<h1>Fixed-point combinator</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</head>
<body>
<hr/>
<p>In <a href="computer_science" title="wikilink">computer science</a>, a <strong>fixed-point combinator</strong> (or <strong>fixpoint combinator<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></strong>) is a <a href="higher-order_function" title="wikilink">higher-order function</a> <em>y</em> that satisfies the equation,</p>
<p><span class="LaTeX">$$y\ f = f\ (y\ f)$$</span></p>
<p>It is so named because, by setting <span class="LaTeX">$x = y\ f$</span>, it represents a solution to the <a href="fixed_point_(mathematics)" title="wikilink">fixed point</a> equation,</p>
<p><span class="LaTeX">$$x = f\ x$$</span></p>
<p>A <em>fixed point</em> of a function <em>f</em> is a value that doesn't change under the application of the function <em>f</em>. Consider the function <span class="LaTeX">$f\ x = x^2$</span>. The values 0 and 1 are fixed points of this function, because <span class="LaTeX">$0 = 0^2$</span> and <span class="LaTeX">$1 = 1^2$</span>. This function has no other fixed points.</p>
<p>A fixed point combinator need not exist for all functions. Also if <em>f</em> is a function of more than 1 parameter, the fixed point of the function need not be a <a href="Total_function#Total_function" title="wikilink">total function</a>.</p>
<p>Functions that satisfy the equation for <em>y</em> expand as,</p>
<p><span class="LaTeX">$$y\ f = f\ (\ldots f\ (y\ f) \ldots)$$</span></p>
<p>A particular implementation of <em>y</em> is <a href="Haskell_Curry" title="wikilink">Curry's</a> paradoxical combinator <em>Y</em>, represented in <a href="lambda_calculus" title="wikilink">lambda calculus</a> by,</p>
<p><span class="LaTeX">$$\lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))$$</span></p>
<p>This combinator may be used in implementing <a href="Curry's_paradox" title="wikilink">Curry's paradox</a>. The heart of Curry's paradox is that lambda calculus is unsound as a deductive system, and the <em>Y</em> combinator demonstrates that by allowing an anonymous expression to represent zero, or even many values. This is inconsistent in mathematical logic.</p>
<p>Applied to a function with one variable the <em>Y</em> combinator usually does not terminate. More interesting results are obtained by applying the <em>Y</em> combinator to functions of two or more variables. The second variable may be used as a counter, or index. The resulting function behaves like a <em>while</em> or a <em>for</em> loop in an imperative language.</p>
<p>Used in this way the <em>Y</em> combinator implements simple recursion. In the lambda calculus it is not possible to refer to the definition of a function in a function body. Recursion may only be achieved by passing in a function as a parameter. The <em>Y</em> combinator demonstrates this style of programming.</p>
<h2 id="introduction">Introduction</h2>
<p>The <em>Y</em> combinator is an implementation of the fixed-point combinator in lambda calculus. Fixed-point combinators may also be easily defined in other functional and imperative languages. The implementation in lambda calculus is more difficult due to limitations in lambda calculus.</p>
<p>The fixed combinator may be used in a number of different areas,</p>
<ul>
<li><a href="mathematics" title="wikilink">General mathematics</a></li>
<li><a href="Lambda_calculus" title="wikilink">Untyped lambda calculus</a></li>
<li><a href="Typed_lambda_calculus" title="wikilink">Typed lambda calculus</a></li>
<li><a href="Functional_programming" title="wikilink">Functional programming</a></li>
<li><a href="Imperative_programming" title="wikilink">Imperative programming</a></li>
</ul>
<p>Fixed point combinators may be applied to a range of different functions, but normally will not terminate unless there is an extra parameter. Even with lazy evaluation when the function to be fixed refers to its parameter, another call to the function is invoked. The calculation never gets started. The extra parameter is needed to trigger the start of the calculation.</p>
<p>The type of the fixed point is the return type of the function being fixed. This may be a real or a function or any other type.</p>
<p>In the untyped lambda calculus, the function to apply the fix point combinator to may be expressed using an encoding, like <a href="Church_encoding" title="wikilink">Church encoding</a>. In this case particular lambda terms (which define functions) are considered as values. "Running" (beta reducing) the fixed point combinator on the encoding gives a lambda term for the result which may then be interpreted as fixed point value.</p>
<p>Alternately a function may be considered as a lambda term defined purely in lambda calculus.</p>
<p>These different approaches affect how a mathematician and a programmer may regard a fixed point combinator. A lambda calculus mathematician may see the <em>Y</em> combinator applied to a function as being an expression satisfying the fixed point equation, and therefore a solution.</p>
<p>In contrast a person only wanting to apply a fixed point combinator to some general programming task may see it only as a means of implementing recursion.</p>
<h3 id="values-and-domains">Values and domains</h3>
<p>Every expression has one value. This is true in general mathematics and it must be true in lambda calculus. This means that in lambda calculus, applying a fixed point combinator to a function gives you an expression whose value is the fixed point of the function.</p>
<p>However this is a value in the <a href="Deductive_lambda_calculus#Domain_of_lambda_calculus" title="wikilink">lambda calculus domain</a>, it may not correspond to any value in the domain of the function, so in a practical sense it is not necessarily a fixed point of the function, and only in the lambda calculus domain is it a fixed point of the equation.</p>
<p>For example, consider,</p>
<p><span class="LaTeX">$$x^2 = -1 \Rightarrow x = \frac{-1}{x} \Rightarrow f\ x = \frac{-1}{x} \and Y\ f = x$$</span></p>
<p><a href="Church_encoding#Division" title="wikilink">Division</a> of <a href="Church_encoding#Signed_numbers" title="wikilink">Signed numbers</a> may be implemented in the Church encoding, so <em>f</em> may be represented by a lambda term. This equation has no solution in the real numbers. But in the domain of the <a href="complex_number" title="wikilink">complex numbers</a> <em>i</em> and <em>-i</em> are solutions. This demonstrates that there may be solutions to an equation in another domain. However the lambda term for the solution for the above equation is weirder than that. The lambda term <span class="LaTeX">$Y\ f$</span> represents the state where x could be either <em>i</em> or <em>-i</em>, as one value. The information distinguishing these two values has been lost, in the change of domain.</p>
<p>For the lambda calculus mathematician, this is a consequence of the definition of lambda calculus. For the programmer, it means that the beta reduction of the lambda term will loop forever, never reaching a normal form.</p>
<h3 id="function-versus-implementation">Function versus implementation</h3>
<p>The fixed-point combinator may be defined in mathematics and then implemented in other languages. General mathematics defines a function based on its <a href="Extensionality" title="wikilink">extensional</a> properties.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> That is, two functions are equal if they perform the same mapping. Lambda calculus and programming languages regard function identity as an intensional property. A functions identity is based on its implementation.</p>
<p>A lambda calculus function (or term) is an implementation of a mathematical function. In the lambda calculus there are a number of combinator (implementations) that satisfy the mathematical definition of a fixed-point combinator.</p>
<h3 id="what-is-a-combinator">What is a "combinator"?</h3>
<p>A <a href="Combinatory_logic" title="wikilink">combinator</a> is a particular type of <a href="higher-order_function" title="wikilink">higher-order function</a> that may be used in defining functions without using variables. The combinators may be combined to direct values to their correct places in the expression without ever naming them as variables.</p>
<h2 id="usage">Usage</h2>
<p>Usually when applied to functions of one parameter, implementations of the fixed point combinator fail to terminate. Functions with extra parameters are more interesting.</p>
<p>The Y combinator is an example of what makes the Lambda calculus inconsistent. So it should be regarded with suspicion. However it is safe to consider the Y combinator when defined in mathematic logic only. The definition is,</p>
<p><span class="LaTeX">$$y\ f = f\ (y\ f)$$</span></p>
<p>It is easy to see how <em>f</em> may be applied to one variable. Applying it to two or more variables requires adding them to the equation,</p>
<p><span class="LaTeX">$$y\ f\ x = f\ (y\ f)\ x$$</span></p>
<p>This version of the equation must be shown consistent with the previous by the definition for equality of functions,</p>
<p><span class="LaTeX">$$(\forall x f\ x = g\ x) \equiv f = g$$</span></p>
<p>This definition allows the two equations for y to be regarded as equivalent, provided that the domain of <em>x</em> is well defined. So if <em>f</em> has multiple parameters the <em>y f</em> may still be regarded as a fixed point, with some restrictions.</p>
<h3 id="the-factorial-function">The factorial function</h3>
<p>The factorial function provides a good example of how the fixed point combinator may be applied to functions of two variables. The result demonstrates simple recursion, as would be implemented in a single loop, in an imperative language. The definition of numbers used is explained in <a href="Church_encoding" title="wikilink">Church encoding</a>. The fixed point function is,</p>
<p><span class="LaTeX">$$F\ f\ n = (\operatorname{IsZero}\ n)\ 1\ (\operatorname{multiply}\ n\ (f\ (\operatorname{pred}\ n)))$$</span></p>
<p>so <em>y F</em> is,</p>
<p><span class="LaTeX">$$y\ F\ n = F\ (y\ F)\ n$$</span> or</p>
<p><span class="LaTeX">$$y\ F\ n = (\operatorname{IsZero}\ n)\ 1\ (\operatorname{multiply}\ n\ ((y\ F)\ (\operatorname{pred}\ n)))$$</span></p>
<p>Setting <span class="LaTeX">$y\ F = \operatorname{fact}$</span> gives,</p>
<p><span class="LaTeX">$$\operatorname{fact}\ n = (\operatorname{IsZero}\ n)\ 1\ (\operatorname{multiply}\ n\ (\operatorname{fact}\ (\operatorname{pred}\ n)))$$</span></p>
<p>this definition is equivalent to the mathematical definition of factorial,</p>
<p><span class="LaTeX">$$\operatorname{fact}\ n = \operatorname{if} n = 0 \operatorname{then} 1 \operatorname{else} n * \operatorname{fact}\ (n - 1)$$</span></p>
<p>This definition puts <em>F</em> in the role of the body of a loop to be iterated.</p>
<h2 id="fixed-point-combinators-in-lambda-calculus">Fixed point combinators in lambda calculus</h2>
<p>The <em>Y</em> combinator, discovered by <a href="Haskell_Curry" title="wikilink">Haskell B. Curry</a>, is defined as:</p>
<p><span class="LaTeX">$$Y = \lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))$$</span></p>
<p>Beta reduction of this gives,</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p><span class="LaTeX">$Y\ g$</span></p></td>
<td style="text-align: left;"><p><span class="LaTeX">$= (\lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x)))\ g$</span></p></td>
<td style="text-align: left;"><p>(by definition of <em>Y</em>)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"><p><span class="LaTeX">$= (\lambda x.g\ (x\ x))\ (\lambda x.g\ (x\ x))$</span></p></td>
<td style="text-align: left;"><p>(by <a class="uri" href="β-reduction" title="wikilink">β-reduction</a> of λf: applied Y to g)</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"><p><span class="LaTeX">$= g ((\lambda x.g\ (x\ x))\ (\lambda x.g\ (x\ x)))$</span></p></td>
<td style="text-align: left;"><p>(by β-reduction of λx: applied left function to right function)</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"><p><span class="LaTeX">$= g\ (Y\ g)$</span></p></td>
<td style="text-align: left;"><p>(by second equality)</p></td>
</tr>
</tbody>
</table>
<p>By repeatedly applying this equality we get,</p>
<p><span class="LaTeX">$$Y\ g = g\ (Y\ g) = g\ (g\ (Y\ g)) = g\ (\ldots g\ (Y\ g) \ldots)$$</span></p>
<h3 id="equivalent-definition-of-a-fixed-point-combinator">Equivalent definition of a fixed-point combinator</h3>
<p>This fixed-point combinator may be defined as <em>y</em> in,</p>
<p><span class="LaTeX">$$x = f\ x \and y\ f = x$$</span></p>
<p>An expression for y may be derived using rules from the <a href="Let_expression#Let_definition_in_mathematics" title="wikilink">definition of a let expression</a>. Firstly using the rule,</p>
<p><span class="LaTeX">$$(\exists x E \and F) \iff \operatorname{let} x : E \operatorname{in} F$$</span></p>
<p>gives,</p>
<p><span class="LaTeX">$$\operatorname{let} x = f\ x \operatorname{in} y\ f = x$$</span></p>
<p>Also using,</p>
<p><span class="LaTeX">$$x \not \in \operatorname{FV}(E) \and x \in \operatorname{FV}(F) \to \operatorname{let} x : G \operatorname{in} E\ F = E\  (\operatorname{let} x : G \operatorname{in} F)$$</span></p>
<p>gives</p>
<p><span class="LaTeX">$$y\ f =  \operatorname{let} x = f\ x \operatorname{in} x$$</span></p>
<p>Then using the <a href="Deductive_lambda_calculus#Eta_reduction_as_mathematics" title="wikilink">eta reduction</a> rule,</p>
<p><span class="LaTeX">$$f\ x = y \iff f = \lambda x.y$$</span></p>
<p>gives,</p>
<p><span class="LaTeX">$$y = \lambda f.\operatorname{let} x = f\ x \operatorname{in} x$$</span></p>
<h3 id="derivation-of-the-y-combinator">Derivation of the Y combinator</h3>
<p>Curry's Y combinator may be readily obtained from the definition of <em>y</em>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Starting with,</p>
<p><span class="LaTeX">$$\lambda f.\operatorname{let} x = f\ x \operatorname{in} x$$</span></p>
<p>A lambda abstraction does not support reference to the variable name, in the applied expression, so <em>x</em> must be passed in as a parameter to <em>x</em>. We can think of this as replacing <em>x</em> by <em>x x</em>, but formally this is not correct. Instead defining <em>y</em> by <span class="LaTeX">$\forall z, y\ z = x$</span> gives,</p>
<p><span class="LaTeX">$$\lambda f.\operatorname{let} y\ z = f\ (y\ z) \operatorname{in} y\ z$$</span></p>
<p>The let expression may be regarded as the definition of the function <em>y</em>, where <em>z</em> is the parameter. Instantiation <em>z</em> as <em>y</em> in the call gives,</p>
<p><span class="LaTeX">$$\lambda f.\operatorname{let} y\ z = f\ (y\ z) \operatorname{in} y\ y$$</span></p>
<p>And because the parameter <em>z</em> always passes the function <em>y</em>.</p>
<p><span class="LaTeX">$$\lambda f.\operatorname{let} y\ z = f\ (z\ z) \operatorname{in} y\ y$$</span></p>
<p>Using the <a href="Deductive_lambda_calculus#Eta_reduction_as_mathematics" title="wikilink">eta reduction</a> rule,</p>
<p><span class="LaTeX">$$f\ x = y \equiv f = \lambda x.y$$</span></p>
<p>gives,</p>
<p><span class="LaTeX">$$\lambda f.\operatorname{let} y = \lambda z.f\ (z\ z) \operatorname{in} y\ y$$</span></p>
<p>A <a href="Let_expression#Let_definition_in_mathematics" title="wikilink">let expression may be expressed as a lambda abstraction</a> using,</p>
<p><span class="LaTeX">$$n \not \in FV(E) \to (\operatorname{let} n = E \operatorname{in} L \equiv (\lambda n.L)\ E)$$</span></p>
<p>gives,</p>
<p><span class="LaTeX">$$\lambda f.(\lambda y.y\ y)\ (\lambda z.f\ (z\ z))$$</span></p>
<p>This is possibly the simplest implementation of a fixed point combinator in lambda calculus. However one beta reduction gives the more symmetrical form of Curry's Y combinator.</p>
<p><span class="LaTeX">$$\lambda f.(\lambda z.f\ (z\ z))\ (\lambda z.f\ (z\ z))$$</span></p>
<p>See also <a href="Let_expression#Conversion_from_let_to_lambda_expressions" title="wikilink">translating between let and lambda expressions</a>.</p>
<h3 id="other-fixed-point-combinators">Other fixed-point combinators</h3>
<p>In untyped lambda calculus fixed-point combinators are not especially rare. In fact there are infinitely many of them.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> In 2005 Mayer Goldberg showed that the set of fixed-point combinators of untyped lambda calculus is <a href="recursively_enumerable" title="wikilink">recursively enumerable</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<p>The <em>Y</em> combinator can be expressed in the <a href="SKI_combinator_calculus" title="wikilink">SKI-calculus</a> as</p>
<dl>
<dd><em>Y</em> = S (K (S I I)) (S (S (K S) K) (K (S I I)))
</dd>
</dl>
<p>The simplest fixed point combinator in the SK-calculus, found by <a href="John_Tromp" title="wikilink">John Tromp</a>, is</p>
<dl>
<dd><em>Y</em>' = S S K (S (K (S S (S (S S K)))) K)
</dd>
</dl>
<p>which corresponds to the lambda expression</p>
<dl>
<dd><em>Y</em>' = (λx. λy. x y x) (λy. λx. y (x y x))
</dd>
</dl>
<p>The following fixed-point combinator is simpler than the Y combinator, and β-reduces into the Y combinator; it is sometimes cited as the Y combinator itself:</p>
<dl>
<dd><em>X</em> = λf.(λx.x x) (λx.f (x x))
</dd>
</dl>
<p>Another common fixed point combinator is the Turing fixed-point combinator (named after its discoverer, <a href="Alan_Turing" title="wikilink">Alan Turing</a>):</p>
<dl>
<dd><em>Θ</em> = (λx. λy. (y (x x y))) (λx. λy. (y (x x y)))
</dd>
</dl>
<p>It also has a simple call-by-value form:</p>
<dl>
<dd><em>Θ</em><sub><strong>v</strong></sub> = (λx. λy. (y (λz. x x y z))) (λx. λy. (y (λz. x x y z)))
</dd>
</dl>
<p>The analog for <a href="mutual_recursion" title="wikilink">mutual recursion</a> is a <em>polyvariadic fix-point combinator</em>, <a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> which may be denoted Y*.</p>
<h3 id="strict-fixed-point-combinator">Strict fixed point combinator</h3>
<p>The <em>Z</em> combinator will work in strict languages (or where normal order is applied). The <em>Z</em> combinator has the next argument defined explicitly, preventing the expansion of <em>Z</em> g in the right hand side of the definition:</p>
<dl>
<dd><em>Z</em> g v = g (<em>Z</em> g) v
</dd>
</dl>
<p>and in lambda calculus is an eta-expansion:</p>
<dl>
<dd><em>Z</em> = λf.(λx.f (λv.((x x) v))) (λx.f (λv.((x x) v)))
</dd>
</dl>
<h3 id="non-standard-fixed-point-combinators">Non-standard fixed-point combinators</h3>
<p>In untyped lambda calculus there are terms that have the same <a href="Böhm_tree" title="wikilink">Böhm tree</a> as a fixed-point combinator, that is they have the same infinite extension λx.x (x (x ... )). These are called <em>non-standard fixed-point combinators</em>. Any fixed-point combinator is also a non-standard one, but not all non-standard fixed-point combinators are fixed-point combinators because some of them fail to satisfy the equation that defines the "standard" ones. These strange combinators are called <em>strictly non-standard fixed-point combinators</em>; an example is the following combinator;</p>
<dl>
<dd>N = B M (B (B M) B)
</dd>
</dl>
<p>where,</p>
<dl>
<dd>B = λx,y,z.x (y z)
</dd>
<dd>M = λx.x x
</dd>
</dl>
<p>The set of non-standard fixed-point combinators is not recursively enumerable.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h2 id="implementation-in-other-languages">Implementation in other languages</h2>
<p>Note that the Y combinator is a particular implementation of a fixed point combinator in lambda calculus. Its structure is determined by the limitations of lambda calculus. It is not necessary or helpful to use this structure in implementing the fixed point combinator in other languages.</p>
<p>Simple examples of fixed point combinators implemented in some <a href="programming_paradigm" title="wikilink">programming paradigms</a> are given below.</p>
<p>For examples of implementations of the fixed point combinators in various languages see,</p>
<ul>
<li><a href="http://rosettacode.org/wiki/Y_combinator">Rosetta code - Y combinator</a></li>
<li><a href="http://arcfn.com/2009/03/y-combinator-in-arc-and-java.html">Java code</a>.</li>
<li><a href="http://stackoverflow.com/questions/152084/fixed-point-combinators-in-c/154267#154267">C++ code</a>.</li>
</ul>
<h3 id="lazy-functional-implementation">Lazy functional implementation</h3>
<p>In a language that supports <a href="lazy_evaluation" title="wikilink">lazy evaluation</a>, like in Haskell, it is possible to define a fixed-point combinator using the defining equation of the fixed-point combinator which is conventionally named <code>fix</code>. The definition is given here, followed by some usage examples.</p>
<div class="sourceCode"><pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="ot"> fix ::</span> (a <span class="ot">-></span> a) <span class="ot">-></span> a
 fix f <span class="fu">=</span> f (fix f)                <span class="co">-- Lambda lifted</span>
 <span class="co">-- alternative:</span>
 <span class="co">-- fix f = let x = f x in x      -- Lambda dropped</span>
 
 fix (\x <span class="ot">-></span> <span class="dv">9</span>)                    <span class="co">-- this evaluates to 9</span>
 factabs fact <span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span>               <span class="co">-- factabs is F from the lambda calculus example</span>
 factabs fact x <span class="fu">=</span> x <span class="fu">*</span> fact (x<span class="fu">-</span><span class="dv">1</span>)
 (fix factabs) <span class="dv">5</span>                  <span class="co">-- evaluates to 120</span></code></pre></div>
<h3 id="strict-functional-implementation">Strict functional implementation</h3>
<p>In a strict functional language the argument to <em>f</em> is expanded beforehand, yielding an infinite call sequence,</p>
<p><span class="LaTeX">$$f\ (f ... f\ (\operatorname{fix}\ f)... ))\ x$$</span>.</p>
<p>This may be resolved by defining fix with an extra parameter.</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> <span class="kw">rec</span> fix f x = f (fix f) x <span class="co">(* note the extra x; here fix f = \x-> f (fix f) x *)</span>

<span class="kw">let</span> factabs fact = <span class="kw">function</span>   <span class="co">(* factabs has extra level of lambda abstraction *)</span>
   <span class="dv">0</span> -> <span class="dv">1</span>
 | x -> x * fact (x<span class="dv">-1</span>)

<span class="kw">let</span> _ = (fix factabs) <span class="dv">5</span>       <span class="co">(* evaluates to "120" *)</span></code></pre></div>
<h3 id="imperative-language-implementation">Imperative language implementation</h3>
<p>This example is a slightly interpretive implementation of a fixed point combinator. A class is used to contain the <em>fix</em> function, called <em>fixer</em>. The function to be fixed is contained in a class that inherits from fixer. The <em>fix</em> function accesses the function to be fixed as a virtual function. As for the strict functional definition, <em>fix</em> is explicitly given an extra parameter <em>x</em>, which means that lazy evaluation is not needed.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> <<span class="kw">typename</span> d=<span class="st">""</span> r,=<span class="st">""</span> <span class="kw">typename</span>=<span class="st">""</span>>
<span class="kw">class</span> fixer
{
<span class="kw">public</span>:
    R fix(D x)
    {
        <span class="kw">return</span> f(x);
    }
<span class="kw">private</span>:
    <span class="kw">virtual</span> R f(D) = <span class="dv">0</span>;
};

<span class="kw">class</span> fact : <span class="kw">public</span> fixer<<span class="dt">long</span>, <span class="dt">long</span>=<span class="st">""</span>>
{
    <span class="kw">virtual</span> <span class="dt">long</span> f(<span class="dt">long</span> x)
    {
        <span class="kw">if</span> (x == <span class="dv">0</span>)
        {
            <span class="kw">return</span> <span class="dv">1</span>;
        }
        <span class="kw">return</span> x * fix(x<span class="dv">-1</span>);
    }
};

<span class="dt">long</span> result = fact().fix(<span class="dv">5</span>);
</<span class="dt">long</span>,></<span class="kw">typename</span>></code></pre></div>
<h2 id="typing">Typing</h2>
<p>In <a href="polymorphic_lambda_calculus" title="wikilink">polymorphic lambda calculus</a> (<a href="System_F" title="wikilink">System F</a>) a polymorphic fixed-point combinator has type;</p>
<dl>
<dd>∀a.(a → a) → a
</dd>
</dl>
<p>where <em>a</em> is a <a href="type_variable" title="wikilink">type variable</a>. That is, <em>fix</em> takes a function, which maps a → a and uses it to return a value of type a.</p>
<p>In the simply typed lambda calculus extended with <a href="recursive_type" title="wikilink">recursive types</a>, fixed-point operators can be written, but the type of a "useful" fixed-point operator (one whose application always returns) may be restricted.</p>
<p>In the <a href="simply_typed_lambda_calculus" title="wikilink">simply typed lambda calculus</a>, the fixed-point combinator Y cannot be assigned a type<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> because at some point it would deal with the self-application sub-term <span class="LaTeX">$x~x$</span> by the application rule:</p>
<p><span class="LaTeX">$${\Gamma\vdash x\!:\!t_1 \to t_2\quad\Gamma\vdash x\!:\!t_1}\over{\Gamma\vdash x~x\!:\!t_2}$$</span></p>
<p>where <span class="LaTeX">$x$</span> has the infinite type <span class="LaTeX">$t_1 = t_1\to t_2$</span>. No fixed-point combinator can in fact be typed, in those systems any support for recursion must be explicitly added to the language.</p>
<h3 id="type-for-the-y-combinator">Type for the Y combinator</h3>
<p>In programming languages that support <a href="recursive_type" title="wikilink">recursive types</a>, it is possible to type the Y combinator by appropriately accounting for the recursion at the type level. The need to self-apply the variable x can be managed using a type (Rec a), which is defined so as to be isomorphic to (Rec a -> a).</p>
<p>For example, in the following Haskell code, we have <code>In</code> and <code>Out</code> being the names of the two directions of the isomorphism, with types:<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">In</span><span class="ot"> ::</span> (<span class="dt">Rec</span> a <span class="ot">-></span> a) <span class="ot">-></span> <span class="dt">Rec</span> a
<span class="ot">out ::</span> <span class="dt">Rec</span> a <span class="ot">-></span> (<span class="dt">Rec</span> a <span class="ot">-></span> a)</code></pre></div>
<p>which lets us write:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Rec</span> a <span class="fu">=</span> <span class="dt">In</span> {<span class="ot"> out ::</span> <span class="dt">Rec</span> a <span class="ot">-></span> a }

<span class="ot">y ::</span> (a <span class="ot">-></span> a) <span class="ot">-></span> a
y <span class="fu">=</span> \f <span class="ot">-></span> (\x <span class="ot">-></span> f (out x x)) (<span class="dt">In</span> (\x <span class="ot">-></span> f (out x x)))</code></pre></div>
<p>Or equivalently in OCaml:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> 'a recc = <span class="dt">In</span> <span class="kw">of</span> ('a recc -> 'a)
<span class="kw">let</span> out (<span class="dt">In</span> x) = x

<span class="kw">let</span> y f = (<span class="kw">fun</span> x a -> f (out x x) a) (<span class="dt">In</span> (<span class="kw">fun</span> x a -> f (out x x) a))</code></pre></div>
<h2 id="general-information">General information</h2>
<p>The function for which any input is a fixed point is called the <a href="identity_function" title="wikilink">identity function</a>. Formally:</p>
<p><span class="LaTeX">$$\forall x f\ x = x$$</span></p>
<p>Other functions have the special property that after being applied once, further applications don't have any effect. More formally:</p>
<p><span class="LaTeX">$$\forall x f\ f\ x = f\ x$$</span></p>
<p>Such functions are called <a class="uri" href="idempotent" title="wikilink">idempotent</a>. An example of such a function is the function that returns <em>0</em> for all even integers, and <em>1</em> for all odd integers.</p>
<p>Fixed-point combinators do not necessarily exist in more restrictive models of computation. For instance, they do not exist in <a href="simply_typed_lambda_calculus" title="wikilink">simply typed lambda calculus</a>.</p>
<p>The Y combinator allows <a href="Recursion_(computer_science)" title="wikilink">recursion</a> to be defined as a set of <a href="Production_(computer_science)" title="wikilink">rewrite rules</a>,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> without requiring native recursion support in the language.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<p>The <a href="recursive_join" title="wikilink">recursive join</a> in <a href="relational_databases" title="wikilink">relational databases</a> implements a fixed point, by recursively adding records to a set until no more may be added.</p>
<p>In programming languages that support <a href="anonymous_function" title="wikilink">anonymous functions</a>, fixed-point combinators allow the definition and use of anonymous <a href="recursion" title="wikilink">recursive functions</a>, i.e. without having to <a href="Name_binding" title="wikilink">bind</a> such functions to <a href="identifier" title="wikilink">identifiers</a>. In this setting, the use of fixed-point combinators is sometimes called <em><a href="anonymous_recursion" title="wikilink">anonymous recursion</a></em>.<ref>This terminology appear to be largely <a href="mathematical_folklore" title="wikilink">folklore</a>, but it does appear in the following:</ref></p>
<ul>
<li>Trey Nash, <em>Accelerated C# 2008</em>, Apress, 2007, ISBN 1-59059-873-3, p. 462—463. Derived substantially from <a href="http://www.linkedin.com/pub/wes-dyer/2/727/a39">Wes Dyer</a>'s blog (see next item).</li>
<li>Wes Dyer <a href="http://blogs.msdn.com/wesdyer/archive/2007/02/02/anonymous-recursion-in-c.aspx">Anonymous Recursion in C#</a>, February 02, 2007, contains a substantially similar example found in the book above, but accompanied by more discussion.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Fixed-point_iteration" title="wikilink">Fixed-point iteration</a></li>
<li><a href="Anonymous_function" title="wikilink">Anonymous function</a></li>
<li><a href="Lambda_calculus#Recursion_and_fixed_points" title="wikilink">Lambda calculus</a></li>
<li><a href="Let_expression" title="wikilink">Let expression</a></li>
<li><a href="Lambda_lifting" title="wikilink">Lambda lifting</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>Werner Kluge, <em>Abstract computing machines: a lambda calculus perspective</em>, Springer, 2005, ISBN 3-540-21146-2, pp. 73–77</li>
<li>Mayer Goldberg, (2005) <em><a href="http://www.brics.dk/RS/05/1/BRICS-RS-05-1.pdf">On the Recursive Enumerability of Fixed-Point Combinators</a></em>, BRICS Report RS-05-1, University of Aarhus</li>
<li><a href="Matthias_Felleisen" title="wikilink">Matthias Felleisen</a>. <a href="http://www.ps.uni-sb.de/courses/sem-prog97/material/YYWorks.ps">A Lecture on the <em>Why</em> of <em>Y</em></a>.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a class="uri" href="http://www.latrobe.edu.au/philosophy/phimvt/joy/j05cmp.html">http://www.latrobe.edu.au/philosophy/phimvt/joy/j05cmp.html</a></li>
<li><a class="uri" href="http://okmij.org/ftp/Computation/fixed-point-combinators.html">http://okmij.org/ftp/Computation/fixed-point-combinators.html</a></li>
<li><a href="http://matt.might.net/articles/implementation-of-recursive-fixed-point-y-combinator-in-javascript-for-memoization/">"Fixed-point combinators in Javascript"</a></li>
<li><a class="uri" href="http://www.cs.brown.edu/courses/cs173/2002/Lectures/2002-10-28-lc.pdf">http://www.cs.brown.edu/courses/cs173/2002/Lectures/2002-10-28-lc.pdf</a></li>
<li><a class="uri" href="http://www.mactech.com/articles/mactech/Vol.07/07.05/LambdaCalculus/">http://www.mactech.com/articles/mactech/Vol.07/07.05/LambdaCalculus/</a></li>
<li><a class="uri" href="http://www.csse.monash.edu.au/~lloyd/tildeFP/Lambda/Examples/Y/">http://www.csse.monash.edu.au/~lloyd/tildeFP/Lambda/Examples/Y/</a> (executable)</li>
<li><a class="uri" href="http://www.ece.uc.edu/~franco/C511/html/Scheme/ycomb.html">http://www.ece.uc.edu/~franco/C511/html/Scheme/ycomb.html</a></li>
<li><a href="http://use.perl.org/~Aristotle/journal/30896">an example and discussion of a perl implementation</a></li>
<li><a href="http://www.ps.uni-sb.de/courses/sem-prog97/material/YYWorks.ps">"A Lecture on the Why of Y"</a></li>
<li><a href="http://www.eecs.harvard.edu/~cduan/technical/ruby/ycombinator.shtml">"A Use of the Y Combinator in Ruby"</a></li>
<li><a href="http://okasaki.blogspot.com/2008/07/functional-programming-inada.html">"Functional programming in Ada"</a></li>
<li><a href="http://bc.tech.coop/blog/070611.html">"Y Combinator in Erlang"</a></li>
<li><a href="http://kestas.kuliukas.com/YCombinatorExplained/">"The Y Combinator explained with JavaScript"</a></li>
<li><a href="http://mvanier.livejournal.com/2897.html">"The Y Combinator (Slight Return)"</a> (detailed derivation)</li>
<li><a href="http://blogs.msdn.com/b/madst/archive/2007/05/11/recursive-lambda-expressions.aspx">"The Y Combinator in C#"</a></li>
<li><a href="http://rosettacode.org/wiki/Y_combinator">Rosetta code - Y combinator</a></li>
</ul>
<p>"</p>
<p><a href="Category:Lambda_calculus" title="wikilink">Category:Lambda calculus</a> <a href="Category:Mathematics_of_computing" title="wikilink">Category:Mathematics of computing</a> <a href="Category:Fixed_points_(mathematics)" title="wikilink">Category:Fixed points (mathematics)</a> <a href="Category:Combinatory_logic" title="wikilink">Category:Combinatory logic</a> <a class="uri" href="Category:Recursion" title="wikilink">Category:Recursion</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a class="uri" href="http://math.stackexchange.com/questions/51246/can-someone-explain-the-y-combinator">http://math.stackexchange.com/questions/51246/can-someone-explain-the-y-combinator</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">Goldberg, 2005<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="http://okmij.org/ftp/Computation/fixed-point-combinators.html#Poly-variadic">Poly-variadic fix-point combinators</a><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="http://osdir.com/ml/lang.haskell.cafe/2003-10/msg00211.html">Polyvariadic Y in pure Haskell98</a>, lang.haskell.cafe, October 28, 2003<a href="#fnref7">↩</a></li>
<li id="fn8"><a href="http://stackoverflow.com/questions/4899113/fixed-point-combinator-for-mutually-recursive-functions">Fixed point combinator for mutually recursive functions?</a><a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"><a href="http://cs.anu.edu.au/courses/COMP3610/lectures/Lambda.pdf">An Introduction to the Lambda Calculus</a><a href="#fnref10">↩</a></li>
<li id="fn11">Haskell mailing list thread on <a href="http://groups.google.co.uk/group/fa.haskell/browse_frm/thread/f0a62b6de1416d8b">How to define Y combinator in Haskell</a>, 15 Sep 2006<a href="#fnref11">↩</a></li>
<li id="fn12"> "In the chapter we have derived a Y-combinator which allows us to write recursive functions of one argument withour using define."<a href="#fnref12">↩</a></li>
<li id="fn13"> "More generally, Y gives us a way to get recursion in a programming language that supports first-class functions but that doesn't have recursion built in to it."<a href="#fnref13">↩</a></li>
<li id="fn14">The If Works <a href="http://blog.jcoglan.com/2008/01/10/deriving-the-y-combinator/">Deriving the Y combinator</a>, January 10th, 2008<a href="#fnref14">↩</a></li>
</ol>
</section>
</body>
</html>
