<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="666">Solomonoff's theory of inductive inference</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Solomonoff's theory of inductive inference</h1>
<hr/>

<p><a href="Ray_Solomonoff" title="wikilink">Solomonoff</a>'s theory of universal <strong>inductive inference</strong> is a theory of prediction based on logical observations, such as predicting the next symbol based upon a given series of symbols. The only assumption that the theory makes is that the environment follows some unknown but <a href="Computable_function" title="wikilink">computable</a> <a href="probability_distribution" title="wikilink">probability distribution</a>. It is a mathematical formalization of <a href="Occam's_razor" title="wikilink">Occam's razor</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> and the <a href="Principle_of_Multiple_Explanations" title="wikilink">Principle of Multiple Explanations</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>Prediction is done using a completely Bayesian framework. The universal prior is taken over the class of all computable sequences—this is the universal a priori probability distribution; no hypothesis will have a zero probability. This means that Bayes rule of causation can be used in predicting the continuation of any particular sequence.</p>
<h2 id="origin">Origin</h2>
<h3 id="philosophical">Philosophical</h3>

<p>The theory is based in philosophical foundations, and was founded by <a href="Ray_Solomonoff" title="wikilink">Ray Solomonoff</a> around 1960.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> It is a mathematically formalized combination of <a href="Occam's_razor" title="wikilink">Occam's razor</a>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> and the <a href="Principle_of_Multiple_Explanations" title="wikilink">Principle of Multiple Explanations</a>.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> All <a class="uri" href="computable" title="wikilink">computable</a> theories which perfectly describe previous observations are used to calculate the probability of the next observation, with more weight put on the shorter computable theories. Marcus Hutter's <a href="universal_artificial_intelligence" title="wikilink">universal artificial intelligence</a> builds upon this to calculate the <a href="expected_value" title="wikilink">expected value</a> of an action.</p>
<h3 id="mathematical">Mathematical</h3>

<p>The proof of the "razor" is based on the known mathematical properties of a probability distribution over a <a class="uri" href="denumerable" title="wikilink">denumerable</a> set. These properties are relevant because the infinite set of all programs is a denumerable set. The sum S of the probabilities of all programs must be exactly equal to one (as per the definition of <a class="uri" href="probability" title="wikilink">probability</a>) thus the probabilities must roughly decrease as we enumerate the infinite set of all programs, otherwise S will be strictly greater than one. To be more precise, for every 

<math display="inline" id="Solomonoff's_theory_of_inductive_inference:0">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 &gt; 0, there is some length <em>l</em> such that the probability of all programs longer than <em>l</em> is at most 

<math display="inline" id="Solomonoff's_theory_of_inductive_inference:1">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

. This does not, however, preclude very long programs from having very high probability.</p>

<p>Fundamental ingredients of the theory are the concepts of <a href="algorithmic_probability" title="wikilink">algorithmic probability</a> and <a href="Kolmogorov_complexity" title="wikilink">Kolmogorov complexity</a>. The universal <a href="prior_probability" title="wikilink">prior probability</a> of any prefix <em>p</em> of a computable sequence <em>x</em> is the sum of the probabilities of all programs (for a <a href="universal_computer" title="wikilink">universal computer</a>) that compute something starting with <em>p</em>. Given some <em>p</em> and any computable but unknown probability distribution from which <em>x</em> is sampled, the universal prior and <a href="Bayes'_theorem" title="wikilink">Bayes' theorem</a> can be used to predict the yet unseen parts of <em>x</em> in optimal fashion.</p>
<h2 id="modern-applications">Modern applications</h2>
<h3 id="artificial-intelligence">Artificial intelligence</h3>

<p>Though Solomonoff's inductive inference is not computable, several <a class="uri" href="AIXI" title="wikilink">AIXI</a>-derived algorithms approximate it in order to make it run on a modern computer. The more computing power they are given, the closer their predictions are to the predictions of inductive inference (their mathematical <a href="limit_(math)" title="wikilink">limit</a> is Solomonoff's inductive inference).<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>Another direction of inductive inference is based on <a href="E._Mark_Gold" title="wikilink">E. Mark Gold</a>'s model of <a href="Language_identification_in_the_limit" title="wikilink">learning in the limit</a> from 1967 and has developed since then more and more models of learning. <a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> The general scenario is the following: Given a class <em>S</em> of computable functions, is there a learner (that is, recursive functional) which for any input of the form (<em>f</em>(0),<em>f</em>(1),...,<em>f</em>(<em>n</em>)) outputs a hypothesis (an index <em>e</em> with respect to a previously agreed on acceptable numbering of all computable functions; the indexed function should be consistent with the given values of <em>f</em>). A learner <em>M</em> learns a function <em>f</em> if almost all its hypotheses are the same index <em>e</em>, which generates the function <em>f</em>; <em>M</em> learns <em>S</em> if <em>M</em> learns every <em>f</em> in <em>S</em>. Basic results are that all recursively enumerable classes of functions are learnable while the class REC of all computable functions is not learnable.  Many related models have been considered and also the learning of classes of recursively enumerable sets from positive data is a topic studied from Gold's pioneering paper in 1967 onwards. A far reaching extension of the Gold’s approach is developed by Schmidhuber's theory of generalized Kolmogorov complexities,<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> which are kinds of <a href="super-recursive_algorithm" title="wikilink">super-recursive algorithms</a>.</p>
<h3 id="turing-machines">Turing machines</h3>

<p>The third mathematically based direction of inductive inference makes use of the theory of automata and computation. In this context, the process of inductive inference is performed by an abstract automaton called an inductive <a href="Turing_machine" title="wikilink">Turing machine</a> (Burgin, 2005). <em>Inductive Turing machines</em> represent the next step in the development of computer science providing better models for contemporary computers and computer networks (Burgin, 2001) and forming an important class of super-recursive algorithms as they satisfy all conditions in the definition of <a class="uri" href="algorithm" title="wikilink">algorithm</a>. Namely, each inductive Turing machines is a type of effective method in which a definite list of well-defined instructions for completing a task, when given an initial state, will proceed through a well-defined series of successive states, eventually terminating in an end-state. The difference between an inductive Turing machine and a <a href="Turing_machine" title="wikilink">Turing machine</a> is that to produce the result a Turing machine has to stop, while in some cases an inductive Turing machine can do this without stopping. Kleene called procedures that could run forever without stopping by the name <em>calculation procedure or algorithm</em> (Kleene 1952:137). Kleene also demanded that such an algorithm must eventually exhibit "some object" (Kleene 1952:137). This condition is satisfied by inductive Turing machines, as their results are exhibited after a finite number of steps, but inductive Turing machines do not always tell at which step the result has been obtained.</p>

<p>Simple inductive Turing machines are equivalent to other models of computation. More advanced inductive Turing machines are much more powerful. It is proved (Burgin, 2005) that limiting partial recursive functions, trial and error predicates, general Turing machines, and simple inductive Turing machines are equivalent models of computation. However, simple inductive Turing machines and general Turing machines give direct constructions of computing automata, which are thoroughly grounded in physical machines. In contrast, trial and error predicates, limiting recursive functions and limiting partial recursive functions present syntactic systems of symbols with formal rules for their manipulation. Simple inductive Turing machines and general Turing machines are related to limiting partial recursive functions and trial and error predicates as Turing machines are related to partial recursive functions and lambda-calculus.</p>

<p>Note that only simple inductive Turing machines have the same structure (but different functioning semantics of the output mode) as Turing machines. Other types of inductive Turing machines have an essentially more advanced structure due to the structured memory and more powerful instructions. Their utilization for inference and learning allows achieving higher efficiency and better reflects learning of people (Burgin and Klinger, 2004).</p>

<p>Some researchers confuse computations of inductive Turing machines with non-stopping computations or with infinite time computations. First, some of computations of inductive Turing machines halt. As in the case of conventional Turing machines, some halting computations give the result, while others do not give. Second, some non-stopping computations of inductive Turing machines give results, while others do not give. Rules of inductive Turing machines determine when a computation (stopping or non-stopping) gives a result. Namely, an inductive Turing machine produces output from time to time and once this output stops changing, it is considered the result of the computation. It is necessary to know that descriptions of this rule in some papers are incorrect. For instance, Davis (2006: 128) formulates the rule when result is obtained without stopping as "… once the correct output has been produced any subsequent output will simply repeat this correct result." Third, in contrast to the widespread misconception, inductive Turing machines give results (when it happens) always after a finite number of steps (in finite time) in contrast to infinite and infinite-time computations. There are two main distinctions between conventional Turing machines and simple inductive Turing machines. The first distinction is that even simple inductive Turing machines can do much more than conventional Turing machines. The second distinction is that a conventional Turing machine always informs (by halting or by coming to a final state) when the result is obtained, while a simple inductive Turing machine in some cases does inform about reaching the result, while in other cases (where the conventional Turing machine is helpless), it does not inform. People have an illusion that a computer always itself informs (by halting or by other means) when the result is obtained. In contrast to this, users themselves have to decide in many cases whether the computed result is what they need or it is necessary to continue computations. Indeed, everyday desktop computer applications like word processors and spreadsheets spend most of their time waiting in <a href="event_loop" title="wikilink">event loops</a>, and do not terminate until directed to do so by users.</p>
<h4 id="evolutionary-inductive-turing-machines">Evolutionary inductive Turing machines</h4>

<p>Evolutionary approach to inductive inference is accomplished by another class of automata called evolutionary inductive Turing machines (Burgin and Eberbach, 2009; 2012). An ‘’’evolutionary inductive Turing machine’’’ is a (possibly infinite) sequence <em>E</em> = {<em>A</em>[<em>t</em>]; <em>t</em> = 1, 2, 3, ... } of inductive Turing machines <em>A</em>[<em>t</em>] each working on generations X[t] which are coded as words in the alphabet of the machines <em>A</em>[<em>t</em>]. The goal is to build a “population” <em>Z</em> satisfying the inference condition. The automaton <em>A</em>[<em>t</em>] called a component, or a level automaton, of E represents (encodes) a one-level evolutionary algorithm that works with input generations <em>X</em>[<em>i</em>] of the population by applying the variation operators v and selection operator s. The first generation <em>X</em>[0] is given as input to <em>E</em> and is processed by the automaton <em>A</em>[1], which generates/produces the first generation <em>X</em>[1] as its transfer output, which goes to the automaton <em>A</em>[2]. For all <em>t</em> = 1, 2, 3, ..., the automaton <em>A</em>[<em>t</em>] receives the generation <em>X</em>[<em>t</em> − 1] as its input from <em>A</em>[<em>t</em> − 1] and then applies the variation operator v and selection operator <em>s</em>, producing the generation <em>X</em>[<em>i</em> + 1] and sending it to <em>A</em>[<em>t</em> + 1] to continue evolution.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Algorithmic_probability" title="wikilink">Algorithmic probability</a></li>
<li><a href="Algorithmic_information_theory" title="wikilink">Algorithmic information theory</a></li>
<li><a href="Bayesian_inference" title="wikilink">Bayesian inference</a></li>
<li><a href="Language_identification_in_the_limit" title="wikilink">Language identification in the limit</a></li>
<li><a href="Inductive_inference" title="wikilink">Inductive inference</a></li>
<li><a href="Inductive_probability" title="wikilink">Inductive probability</a></li>
<li><a href="Mill's_methods" title="wikilink">Mill's methods</a></li>
<li><a href="Minimum_description_length" title="wikilink">Minimum description length</a></li>
<li><a href="Minimum_message_length" title="wikilink">Minimum message length</a></li>
<li><a href="Turing_Machine" title="wikilink">Turing Machine</a></li>
<li>For a philosophical viewpoint, see: <a href="Problem_of_induction" title="wikilink">Problem of induction</a> and <a href="New_riddle_of_induction" title="wikilink">New riddle of induction</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li>Burgin, M. (2005), <em>Super-recursive Algorithms</em>, Monographs in computer science, Springer. ISBN 0-387-95569-0</li>
<li>Burgin, M., "How We Know What Technology Can Do", <em>Communications of the ACM</em>, v. 44, No. 11, 2001, pp. 82–88.</li>
<li>Burgin, M.; Eberbach, E., "Universality for Turing Machines, Inductive Turing Machines and Evolutionary Algorithms", <em>Fundamenta Informaticae</em>, v. 91, No. 1, 2009, 53–77.</li>
<li>Burgin, M.; Eberbach, E., "On Foundations of Evolutionary Computation: An Evolutionary Automata Approach", in <em>Handbook of Research on Artificial Immune Systems and Natural Computing: Applying Complex Adaptive Technologies</em> (Hongwei Mo, Ed.), IGI Global, Hershey, Pennsylvania, 2009, 342–360.</li>
<li>Burgin, M.; Eberbach, E., "Evolutionary Automata: Expressiveness and Convergence of Evolutionary Computation", <em>Computer Journal</em>, v. 55, No. 9, 2012, pp. 1023–1029.</li>
<li>Burgin, M.; Klinger, A. Experience, Generations, and Limits in Machine Learning, <em>Theoretical Computer Science</em>, v. 317, No. 1/3, 2004, pp. 71–91</li>
<li><a href="Martin_Davis" title="wikilink">Davis, Martin</a> (2006) "The Church–Turing Thesis: Consensus and opposition]". Proceedings, Computability in Europe 2006. Lecture notes in computer science, 3988 pp. 125–132.</li>
<li>Gasarch, W.; Smith, C. H. (1997) "A survey of inductive inference with an emphasis on queries". <em>Complexity, logic, and recursion theory</em>, Lecture Notes in Pure and Appl. Math., 187, Dekker, New York, pp. 225–260.</li>
<li>Hay, Nick. "<a href="http://www.cs.auckland.ac.nz/CDMTCS/researchreports/300nick.pdf">Universal Semimeasures: An Introduction</a>," CDMTCS Research Report Series, University of Auckland, Feb. 2007.</li>
<li>Jain, Sanjay ; Osherson, Daniel ; Royer, James ; Sharma, Arun, <em>Systems that Learn: An Introduction to Learning Theory</em> (second edition), <a href="MIT_Press" title="wikilink">MIT Press</a>, 1999.</li>
<li>

<p>.</p></li>
<li>Li Ming; Vitanyi, Paul, <em>An Introduction to Kolmogorov Complexity and Its Applications</em>, 2nd Edition, Springer Verlag, 1997.</li>
<li>Osherson, Daniel ; Stob, Michael ; Weinstein, Scott, <em>Systems That Learn, An Introduction to Learning Theory for Cognitive and Computer Scientists</em>, <a href="MIT_Press" title="wikilink">MIT Press</a>, 1986.</li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://lesswrong.com/lw/dhg/an_intuitive_explanation_of_solomonoff_induction/">An Intuitive Explanation of Solomonoff Induction - Less Wrong wiki</a></li>
<li><a href="http://www.scholarpedia.org/article/Algorithmic_probability">Algorithmic probability - Scholarpedia</a></li>
</ul>

<p>"</p>

<p><a href="Category:Statistical_inference" title="wikilink">Category:Statistical inference</a> <a href="Category:Inductive_reasoning" title="wikilink">Category:Inductive reasoning</a> <a class="uri" href="Category:Inference" title="wikilink">Category:Inference</a> <a href="Category:Machine_learning" title="wikilink">Category:Machine learning</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">JJ McCall. Induction: From Kolmogorov and Solomonoff to De Finetti and Back to Kolmogorov – Metroeconomica, 2004 – Wiley Online Library.<a href="#fnref1">↩</a></li>
<li id="fn2">D Stork. Foundations of Occam's razor and parsimony in learning from ricoh.com – NIPS 2001 Workshop, 2001<a href="#fnref2">↩</a></li>
<li id="fn3">A.N. Soklakov. Occam's razor as a formal basis for a physical theory <a href="http://arxiv.org/abs/math-ph/0009007">from arxiv.org</a> – Foundations of Physics Letters, 2002 – Springer<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">M Hutter. On the existence and convergence of computable universal priors <a href="http://arxiv.org/abs/cs/0305052">arxiv.org</a> – Algorithmic Learning Theory, 2003 – Springer<a href="#fnref5">↩</a></li>
<li id="fn6">Ming Li and Paul Vitanyi, <em>An Introduction to Kolmogorov Complexity and Its Applications.</em> Springer-Verlag, N.Y., 2008p 339 ff.<a href="#fnref6">↩</a></li>
<li id="fn7">Samuel Rathmanner and <a href="Marcus_Hutter" title="wikilink">Marcus Hutter</a>. A philosophical treatise of universal induction. Entropy, 13(6):1076–1136, 2011<a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14">J. Veness, K.S. Ng, M. Hutter, W. Uther, D. Silver. "A Monte Carlo AIXI Approximation" – <a href="http://arxiv.org/abs/0909.0801">Arxiv preprint</a>, 2009 arxiv.org<a href="#fnref14">↩</a></li>
<li id="fn15">J. Veness, K.S. Ng, M. Hutter, D. Silver. "Reinforcement Learning via AIXI Approximation" <a href="http://arxiv.org/abs/1007.2049">Arxiv preprint</a>, 2010 – aaai.org<a href="#fnref15">↩</a></li>
<li id="fn16">S. Pankov. A computational approximation to the AIXI model from agiri.org – Artificial general intelligence, 2008: proceedings of …, 2008 – books.google.com<a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
</ol>
</section>
</body>
</html>
