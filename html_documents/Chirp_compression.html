<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1802">Chirp compression</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Chirp compression</h1>
<hr/>

<p>The chirp <a href="pulse_compression" title="wikilink">pulse compression</a> process transforms a long duration frequency-coded pulse into a narrow pulse of greatly increased amplitude. It is a technique used in <a class="uri" href="radar" title="wikilink">radar</a> and <a class="uri" href="sonar" title="wikilink">sonar</a> systems because it is a method whereby a narrow pulse with high peak power can be derived from a long duration pulse with low peak power. Furthermore, the process offers good range resolution because the half-power beam width of the compressed pulse is consistent with the system bandwidth.</p>

<p>The basics of the method for radar applications were developed in the late 1940’s and early 1950's,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> but it was not until 1960, following declassification of the subject matter, that a detailed article on the topic appeared the public domain.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Thereafter, the number of published articles grew quickly, as demonstrated by the comprehensive selection of papers to be found in a compilation by Barton.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>Briefly, the basic pulse compression properties can be related as follows. For a chirp waveform that sweeps over a frequency range F1 to F2 in a time period T, the nominal bandwidth of the pulse is B, where B = F2 – F1, and the pulse has a time-bandwidth product of T×B . Following pulse compression, a narrow pulse of duration τ is obtained, where τ ≈ 1/B, together with a peak voltage amplification of √(T×B).</p>
<h2 id="the-chirp-compression-process-in-outline">The Chirp Compression Process – in Outline</h2>

<p>In order to compress a chirp pulse of duration T seconds, which sweeps linearly in frequency from F1 Hz to F2 Hz, a device with the characteristics of a dispersive delay line is required. This provides most delay for the frequency F1, the first to be generated, but with a delay which reduces linearly with frequency, to be T second less at the end frequency F2. Such a delay characteristic ensures that all frequency components of the chirp pass through the device, to arrive at the detector at the same time instant and so augment one another, to produce a narrow high amplitude pulse, as shown in the figure:</p>
<figure><b>(Figure)</b>
<figcaption>centre</figcaption>
</figure>

<p>An expression describing the required delay characteristic is</p>

<p>

<math display="inline" id="Chirp_compression:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>Y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>e</mi>
    <mi>x</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mrow>
       <mi>j</mi>
       <mi>π</mi>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>f</mi>
          <mo>-</mo>
          <msub>
           <mi>f</mi>
           <mn>0</mn>
          </msub>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo>/</mo>
      <mi>k</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Y</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>x</ci>
     <ci>p</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>j</ci>
        <ci>π</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <minus></minus>
          <ci>f</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>f</ci>
           <cn type="integer">0</cn>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y(f)=exp[j\pi(f-f_{0})^{2}/k]
  </annotation>
 </semantics>
</math>

</p>

<p>This has a phase component <mtpl></mtpl>(f), where</p>

<p>

<math display="inline" id="Chirp_compression:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>ψ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>π</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>f</mi>
       <mo>-</mo>
       <msub>
        <mi>f</mi>
        <mn>0</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo>/</mo>
    <mi>k</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>ψ</ci>
      <ci>f</ci>
     </apply>
     <ci>π</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi(f)=\pi.(f-f_{0})^{2}/k
  </annotation>
 </semantics>
</math>

, and the instantaneous delay <mtpl></mtpl> is given by</p>

<p>

<math display="inline" id="Chirp_compression:2">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>t</mi>
     <mi>d</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mi>d</mi>
      <mi>ψ</mi>
     </mrow>
     <mrow>
      <mi>d</mi>
      <mi>f</mi>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <mfrac>
     <mn>1</mn>
     <mi>k</mi>
    </mfrac>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mn>0</mn>
     </msub>
     <mo>-</mo>
     <mi>f</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>d</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>π</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>ψ</ci>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>f</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{d}=-\frac{1}{2\pi}.\frac{d\psi}{df}=\frac{1}{k}.(f_{0}-f)
  </annotation>
 </semantics>
</math>

</p>

<p>which has a linear slope with frequency, as required. In this expression, the delay characteristic has been normalized (for convenience), so as to give zero delay when the frequency f equals the carrier frequency f<sub>0</sub>. Consequently, when the instantaneous frequency is (f<sub>0</sub> - B/2) or (f<sub>0</sub> + B/2), the required delay is +T/2 or -T/2, respectively, so k = B/T.</p>

<p>The required dispersive characteristic may be obtained from a lumped element delay network,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> a SAW device,<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> or by means of digital signal processing <a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<h2 id="an-overview-of-pulse-compression-concepts">An Overview of Pulse Compression Concepts</h2>
<h3 id="compression-by-matched-filter">Compression by Matched Filter</h3>

<p>A chirp pulse, however generated, can be considered as the output of one of a pair of filters, which have dispersive characteristics. So, if the transmit filter has a group delay response which increases with frequency, then the receive filter will have one which decreases with frequency and vice versa.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>

<p>In principle, the transmitted pulses can be generated by applying impulses to the input of the dispersive transmit filter, with the resultant output chirp amplified as necessary for transmission. Alternatively, a voltage controlled oscillator may be used to generate the chirp signal.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> To achieve maximum transmitted power (and so achieve maximum range) it is normal for a radar system to transmit chirp pulses at constant amplitude from a transmitter run in a near-limiting condition. The chirp signals reflected from targets are amplified in the receiver and then processed by the compression filter to give narrow pulses of high amplitude, as previously described.</p>

<p>In general, the compression process is a practical implementation of a <a href="matched_filter" title="wikilink">matched filter</a> system.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a><a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> For the compression filter to be matched to the radiated chirp signal, its response is the complex conjugate of the time inverse of the transmit filter’s impulse response. So, the output of this matched filter is given by the convolution of the signal h(t) with the conjugate impulse response h*(-t):</p>

<p>

<math display="inline" id="Chirp_compression:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>τ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <msup>
     <mi>h</mi>
     <mo>*</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mi>τ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>d</mi>
    <mi>τ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>τ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>h</ci>
      <times></times>
     </apply>
     <apply>
      <minus></minus>
      <ci>t</ci>
      <ci>τ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(t)=\int_{-\infty}^{\infty}h(\tau).h^{*}(t-\tau).d\tau
  </annotation>
 </semantics>
</math>

</p>

<p>Alternately, if the frequency response of the coding filter is H(<mtpl></mtpl>), then that of the matched filter is H*(<mtpl></mtpl>), the spectrum of the compressed pulse is |H(<mtpl></mtpl>)|<sup>2</sup>. The waveform of this spectrum is obtained from the inverse Fourier transform, i.e.</p>

<p>

<math display="inline" id="Chirp_compression:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mo>-</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>H</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>ω</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>e</mi>
    <mi>x</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>j</mi>
      <mi>ω</mi>
      <mi>t</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>d</mi>
    <mi>ω</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <minus></minus>
        <infinity></infinity>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <ci>H</ci>
        <ci>ω</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>x</ci>
     <ci>p</ci>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>ω</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>ω</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(t)=\frac{1}{2\pi}.\int_{-\infty}^{\infty}|H(\omega)|^{2}.exp(j\omega t).d\omega
  </annotation>
 </semantics>
</math>

</p>

<p>For the case of a linear chirp, with constant amplitude and time duration T, compression by the matched filter gives a waveform with the <a class="uri" href="sinc" title="wikilink">sinc</a> characteristic, with duration 2T, as shown later. So, in addition to the main pulse, there are a large number of time sidelobes (or, more precisely, range sidelobes) present, the biggest of which are only 13.5 dB below the peak signal level.</p>

<p>In order to achieve a more desirable pulse characteristic (with lower sidelobes, for example), an alternative to the matched filter is often preferred. In this more general case, the compression filter has, say, impulse response g(t) and spectral response G(<mtpl></mtpl>), so the equations for y(t) becomes:</p>

<p>

<math display="inline" id="Chirp_compression:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <mi>h</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>τ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <msup>
     <mi>g</mi>
     <mo>*</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mi>τ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>d</mi>
    <mi>τ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <ci>h</ci>
       <ci>τ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <times></times>
     </apply>
     <apply>
      <minus></minus>
      <ci>t</ci>
      <ci>τ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(t)=\int_{-\infty}^{\infty}h(\tau).g^{*}(t-\tau).d\tau
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="inline" id="Chirp_compression:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mo>-</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <mi>H</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ω</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>G</mi>
    <mo>*</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>e</mi>
    <mi>x</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>j</mi>
      <mi>ω</mi>
      <mi>t</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>d</mi>
    <mi>ω</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <minus></minus>
        <infinity></infinity>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <ci>H</ci>
      <ci>ω</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>G</ci>
     <ci>ω</ci>
    </apply>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>x</ci>
     <ci>p</ci>
     <apply>
      <times></times>
      <ci>j</ci>
      <ci>ω</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>ω</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(t)=\frac{1}{2\pi}.\int_{-\infty}^{\infty}H(\omega).G*(\omega).exp(j\omega t)%
.d\omega
  </annotation>
 </semantics>
</math>

</p>

<p>When compared to the performance of the true matched filter, there will be some loss of processing gain, the main pulse lobe will be broader, and the total time duration of the compressed waveform will exceed 2T (usually).</p>
<h3 id="the-application-of-windowing-to-linear-chirps">The Application of Windowing to Linear Chirps</h3>

<p>The sinc characteristic of a compressed pulse is a direct consequence of the spectrum of the linear chirp pulse having a rectangular profile. By modifying the spectrum to have a bell-shaped profile, by means of a <a class="uri" href="weighting" title="wikilink">weighting</a> (or <a href="window_function" title="wikilink">windowing</a>, or <a class="uri" href="apodization" title="wikilink">apodization</a>) function, lower level sidelobes are obtained.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a><a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> When windowing is implemented, some signal attenuation occurs and there is a broadening of the main pulse, so both signal-to-noise ratio and range resolution are impaired by the process. Preferably, the transmitted and received pulses should be modified in equal measure, but when this is impractical, windowing in the compression filter alone is still beneficial.</p>
<h3 id="doppler-tolerance-of-linear-chirps">Doppler Tolerance of Linear Chirps</h3>

<p>When the frequency sweep of a chirp is linear, the compression process is found to be very tolerant of Doppler frequency shifts on target returns, for a wide range of time-bandwidth products. It is only when T×B is very large (&gt;2000, say) that loss of performance due to Doppler becomes an issue (with main-pulse broadening and increased sidelobe levels). In these situations a chirp with a hyperbolic frequency law can be used, as it has been shown to be fully tolerant to Doppler shifts.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a><a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> Windowing techniques can still be applied to the compressed pulse spectra, to lower sidelobe levels, in a similar manner to linear chirps.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>
<h3 id="far-out-sidelobes">Far-Out Sidelobes</h3>

<p>There are different concerns when the time-bandwidth product is small. When T×B is less than about 75, the windowing process is not altogether successful, especially when it is applied only within the compressor. In such a situation, even though the close-in sidelobes are lowered by the anticipated amount, further away from the main lobe the sidelobes are found to increase in amplitude once more. These sidelobes tend to reach a maximum at locations ±T/2 on each side of the main lobe of the compressed pulse<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> and they are a consequence of the Fresnel ripples present on the frequency spectrum. This topic is discussed in more detail later.</p>

<p>There are techniques available that will reduce the amplitude of the spectral ripple (see <a href="Chirp_spectrum" title="wikilink">Chirp spectrum</a>) and so reduce the amplitude of these far-out sidelobes, but they are not very effective when T×B. is small. In practice, the technique of “reciprocal ripple correction”<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a><a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a><a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> gives good results (where the spectrum of the compression filter is designed to have a ripple characteristic which is the inverse of that of the signal), but the method is less successful when signal returns contain large Doppler frequency shifts.</p>
<h3 id="non-linear-chirps">Non-linear Chirps</h3>

<p>An alternative method of obtaining a bell-shaped spectral shape in order to achieve lower sidelobes, is to sweep the frequency band in a non-linear manner. The required characteristic is obtained by having rapid changes in frequency near to the band edges, with a slower rate of change around band centre. This is a more efficient way of achieving the required spectral shape than by applying amplitude weighting to the spectrum of the linear chirp because no attenuation of signal power is necessary in order to achieve it.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a><a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> In addition, the procedure gives far-out sidelobes that tend to be lower than those for the comparable linear sweep version. As the mathematics of non-linear chirps is more complicated than that of linear chirps, many early workers resorted to stationary phase methods to design them.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a><a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a></p>

<p>The results obtained by using a non-linear sweep are particularly good when the time bandwidth product of the pulse is high (T×B &gt;100). However, non-linear sweeps have to be used with caution when target returns are affected by Doppler frequency shifts. Even modest levels of Doppler can seriously degrade the profile of the main compressed pulse and raise sidelobe levels, as is shown later.</p>
<h3 id="the-generation-of-chirp-waveforms-analogue-methods">The Generation of Chirp Waveforms – Analogue Methods</h3>

<p>Many early dispersive filters were built using lumped element all-pass filter sections.,<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a><a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a><a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a><a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a><a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a><a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a><a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> but these proved hard to fabricate with any accuracy and it was difficult to achieve a satisfactory and repeatable performance. Consequently, the time sidelobe levels of the compressed pulses were high with these early systems, even after spectral weighting, with results no better than those achieved by phase coding or chip coding at that time.<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a> Typically, sidelobe levels were in the range -20 to -25 dB <a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> a poor result when compared to later achievements.</p>

<p>There were similar problems too, when a voltage controlled oscillator was used as a signal source. Matching the chirp characteristic from a VCO to a dispersive delay line proved difficult and, in addition, achieving adequate temperature compensation proved challenging.<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a><a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a></p>

<p>A major improvement in performance of chirp pulse generation and compression systems was achieved with the development of SAW filters.<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a><a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a><a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a><a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a> These allowed much more precision in the synthesis of filter characteristics and consequently in the radar performance. The inherent temperature sensitivity of the quartz substrates was overcome by mounting both the transmit and receive filters in a common package, so providing thermal compensation. The increased precision offered by SAW technology, enabled time sidelobe levels approaching -30 dB to become achievable by radar systems. (In actual fact, the performance level now achievable was set more by limitations in the system hardware than in SAW shortcomings).</p>

<p>SAW technology still continues to be relevant to radar systems <a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a> and is particularly useful for systems using very wideband sweeps, where digital technology (see below) may not always be appropriate or may be difficult to implement.</p>
<h3 id="the-generation-of-chirp-waveforms-digital-methods">The Generation of Chirp Waveforms – Digital Methods</h3>

<p>By the late 20th century, digital technology was able to offer a new approach to signal processing, with the availability of small high power computers together with fast D/A and A/D converters offering wide dynamic ranges. (see <a href="digital-to-analog_converter" title="wikilink">digital-to-analog converter</a> and <a href="analog-to-digital_converter" title="wikilink">analog-to-digital converter</a>).<a class="footnoteRef" href="#fn51" id="fnref51"><sup>51</sup></a><a class="footnoteRef" href="#fn52" id="fnref52"><sup>52</sup></a></p>

<p>In a typical installation, data for the transmit pulses are stored in digital memory as a sequence of baseband I/Q samples (see <a href="quadrature_phase" title="wikilink">quadrature phase</a>), or as samples of a low IF waveform, and read out to a high speed D/A converters, as required. The analogue signal, so formed, is up-converted for transmission. On reception, returning signals are amplified and, typically, converted to a low IF or to baseband I/Q signals before being digitised by A/D converters. The compression of the chirps and additional signal processing is all performed by a digital computer, which has stored within it the chirp pulse data needed to carry out the compression process numerically.</p>

<p>Digital signal processing is conveniently carried out using FFT methods. If a chirp sequence is a(n) and that for the compression filter is b(n), then the compressed pulse sequence c(n) is given by</p>

<p>

<math display="inline" id="Chirp_compression:7">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>c</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>I</mi>
    <mi>F</mi>
    <mi>F</mi>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>F</mi>
      <mi>F</mi>
      <mi>T</mi>
      <msup>
       <mrow>
        <mo>{</mo>
        <mrow>
         <mi>a</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>n</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>}</mo>
       </mrow>
       <mo>*</mo>
      </msup>
      <mi>F</mi>
      <mi>F</mi>
      <mi>T</mi>
      <mrow>
       <mo>{</mo>
       <mrow>
        <mi>b</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>n</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>}</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>I</ci>
     <ci>F</ci>
     <ci>F</ci>
     <ci>T</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>F</ci>
       <ci>F</ci>
       <ci>T</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <set>
         <apply>
          <times></times>
          <ci>a</ci>
          <ci>n</ci>
         </apply>
        </set>
        <times></times>
       </apply>
       <ci>F</ci>
       <ci>F</ci>
       <ci>T</ci>
       <set>
        <apply>
         <times></times>
         <ci>b</ci>
         <ci>n</ci>
        </apply>
       </set>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{1}(n)=IFFT[FFT\left\{a(n)\right\}^{*}FFT\left\{b(n)\right\}]
  </annotation>
 </semantics>
</math>

</p>

<p>In practice, in a radar system, for example, it is not just a chirp pulse sequence that is to be compressed, but a long data sequence of returns from a given range spoke, within which the returning chirp pulse is located. For convenience, and to permit the use of FFTs of practical size, the data is divided into shorter lengths, which are compressed by repeated use the above equation. By applying the <a href="Overlap-save_method" title="wikilink">Overlap-save method</a>, reconstruction of the full-duration compressed signal<a class="footnoteRef" href="#fn53" id="fnref53"><sup>53</sup></a><a class="footnoteRef" href="#fn54" id="fnref54"><sup>54</sup></a><a class="footnoteRef" href="#fn55" id="fnref55"><sup>55</sup></a> is achieved. In this process, the transform sequence FFT{b(n)} has to be calculated only once, prior to storage in the computer for repeated use.</p>
<h3 id="pulse-impairments-due-to-system-characteristics">Pulse Impairments due to System Characteristics</h3>

<p>There are many reasons why overall system performance is found to be disappointing; the presence of a Doppler shift on signal returns is a common cause for signal degradation, as was mentioned above. Some writers<a class="footnoteRef" href="#fn56" id="fnref56"><sup>56</sup></a><a class="footnoteRef" href="#fn57" id="fnref57"><sup>57</sup></a> favour using the <a href="ambiguity_function" title="wikilink">ambiguity function</a> <a class="footnoteRef" href="#fn58" id="fnref58"><sup>58</sup></a> as a way of assessing the Doppler tolerance of chirps.<br/>
Others causes of signal impairment include amplitude ripple and slope across the passband, phase ripple across the passband, large band-edge phase shifts caused by band-limiting filters, phase modulation due to poorly regulated power supplies, all of which lead to higher sidelobe levels. Tolerances for these various parameters can be derived with the aid of paired echo theory.<a class="footnoteRef" href="#fn59" id="fnref59"><sup>59</sup></a><a class="footnoteRef" href="#fn60" id="fnref60"><sup>60</sup></a> Fortunately, with the aid of modern processing techniques and using a procedure similar to reciprocal ripple correction, or an optimization method with an <a href="adaptive_filter" title="wikilink">adaptive filter</a> it is possible to correct for many of these shortcomings.<br/>
Another type of waveform degradation is caused by eclipsing, where part of a returning chirp pulse is missing. As expected, this results in the loss of signal amplitude and a rise in sidelobe levels.<a class="footnoteRef" href="#fn61" id="fnref61"><sup>61</sup></a></p>
<h2 id="a-general-closed-form-solution-for-chirp-compression">A General Closed Form Solution for Chirp Compression</h2>

<p>The characteristic of a single linear chirp pulse, of unit amplitude, can be described by</p>

<p>

<math display="inline" id="Chirp_compression:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>s</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>r</mi>
     <mi>e</mi>
     <mi>c</mi>
     <mi>t</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mfrac>
       <mi>t</mi>
       <mi>T</mi>
      </mfrac>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mn>2</mn>
     <mi>π</mi>
     <mi>j</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>f</mi>
         <mn>0</mn>
        </msub>
        <mi>t</mi>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mrow>
         <mi>k</mi>
         <msup>
          <mi>t</mi>
          <mn>2</mn>
         </msup>
        </mrow>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>e</ci>
      <ci>c</ci>
      <ci>t</ci>
      <apply>
       <divide></divide>
       <ci>t</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>π</ci>
      <ci>j</ci>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>t</ci>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>k</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>t</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{1}(t)=rect(\frac{t}{T}).e^{2\pi j(f_{0}t+kt^{2}/2)}
  </annotation>
 </semantics>
</math>

</p>

<p>where rect(z) is defined by rect(z) = 1 if |z|  1/2</p>

<p>The phase response <mtpl></mtpl>(t) is given by</p>

<p>

<math display="inline" id="Chirp_compression:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>2</mn>
     <mi>π</mi>
    </mfrac>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>f</mi>
        <mn>0</mn>
       </msub>
       <mi>t</mi>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mrow>
        <mi>k</mi>
        <msup>
         <mi>t</mi>
         <mn>2</mn>
        </msup>
       </mrow>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">2</cn>
      <ci>π</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>t</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>k</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>t</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(t)=\frac{2}{\pi}(f_{0}t+kt^{2}/2)
  </annotation>
 </semantics>
</math>

</p>

<p>and the instantaneous frequency f<sub>I</sub> is</p>

<p>

<math display="inline" id="Chirp_compression:10">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mn>2</mn>
     <mi>π</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mi>d</mi>
      <mi>ϕ</mi>
     </mrow>
     <mrow>
      <mi>d</mi>
      <mi>ω</mi>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mn>0</mn>
     </msub>
     <mo>+</mo>
     <mi>k</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>π</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>ϕ</ci>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>ω</ci>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}={2\pi}.\frac{d\phi}{d\omega}=f_{0}+k.t
  </annotation>
 </semantics>
</math>

</p>

<p>So, during the T second duration of the pulse, the frequency changes in a linear fashion from f<sub>0</sub> – kT/2 to f<sub>0</sub> + kT/2 . With the net frequency sweep defined as B, where B = (F1- F2), then k = B/T , as stated previously.</p>

<p>The spectrum of this waveform may be found from its transform</p>

<p>

<math display="inline" id="Chirp_compression:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>S</mi>
      <mn>1</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>s</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>j</mi>
       <mn>2</mn>
       <mi>π</mi>
      </mrow>
     </mrow>
     <mo>.</mo>
     <mrow>
      <mi>f</mi>
      <mi>t</mi>
     </mrow>
    </mrow>
   </msup>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mi>t</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <msup>
      <mi>e</mi>
      <mrow>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mi>j</mi>
         <mn>2</mn>
         <mi>π</mi>
        </mrow>
       </mrow>
       <mo>.</mo>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <msub>
             <mi>f</mi>
             <mn>0</mn>
            </msub>
            <mo>-</mo>
            <mi>f</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mi>t</mi>
         </mrow>
         <mo>+</mo>
         <mrow>
          <mi>k</mi>
          <msup>
           <mi>t</mi>
           <mn>2</mn>
          </msup>
         </mrow>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>d</mi>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>f</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>s</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>j</ci>
        <cn type="integer">2</cn>
        <ci>π</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <csymbol cd="ambiguous">formulae-sequence</csymbol>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>j</ci>
          <cn type="integer">2</cn>
          <ci>π</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="latexml">delimited-[]</csymbol>
         <apply>
          <plus></plus>
          <apply>
           <times></times>
           <apply>
            <minus></minus>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>f</ci>
             <cn type="integer">0</cn>
            </apply>
            <ci>f</ci>
           </apply>
           <ci>t</ci>
          </apply>
          <apply>
           <times></times>
           <ci>k</ci>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>t</ci>
            <cn type="integer">2</cn>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{1}(f)=\int_{-\infty}^{\infty}s_{1}(t).e^{-j2\pi.ft}.dt=\int_{-\infty}^{%
\infty}e^{-j2\pi.[(f_{0}-f)t+kt^{2}]}.dt
  </annotation>
 </semantics>
</math>

</p>

<p>which is an integral which has been evaluated in <a href="Chirp_spectrum" title="wikilink">Chirp spectrum</a>.</p>

<p>The spectrum of the compressed pulse can be found from</p>

<p>

<math display="inline" id="Chirp_compression:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>S</mi>
      <mtext>out</mtext>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>Y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <msub>
     <mi>S</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <mtext>out</mtext>
      </apply>
      <ci>f</ci>
     </apply>
     <apply>
      <times></times>
      <ci>Y</ci>
      <ci>f</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{\text{out}}(f)=Y(f).S_{1}(f)
  </annotation>
 </semantics>
</math>

</p>

<p>Where Y(f) is the spectrum of the compression filter.<br/>
The time domain waveform 

<math display="inline" id="Chirp_compression:13">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mtext>out</mtext>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <mtext>out</mtext>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{\text{out}}(t)
  </annotation>
 </semantics>
</math>

 of the compressed pulse can be found as the inverse transform of 

<math display="inline" id="Chirp_compression:14">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mtext>out</mtext>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <mtext>out</mtext>
    </apply>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{\text{out}}(f)
  </annotation>
 </semantics>
</math>

. (This procedure has been described in papers by Chin and Cook<a class="footnoteRef" href="#fn62" id="fnref62"><sup>62</sup></a><a class="footnoteRef" href="#fn63" id="fnref63"><sup>63</sup></a>).</p>

<p>Here it is more convenient to find 

<math display="inline" id="Chirp_compression:15">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mtext>out</mtext>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <mtext>out</mtext>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{\text{out}}(t)
  </annotation>
 </semantics>
</math>

 from the <a class="uri" href="convolution" title="wikilink">convolution</a> of the two time domain responses, i.e.</p>

<p>

<math display="inline" id="Chirp_compression:16">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>s</mi>
     <mtext>out</mtext>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>s</mi>
     <mn>1</mn>
    </msub>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>*</mo>
    </msup>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <mtext>out</mtext>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <times></times>
     </apply>
     <ci>y</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{\text{out}}(t)=s_{1}(t)^{*}y(t)
  </annotation>
 </semantics>
</math>

</p>

<p>where the convolution of two arbitrary functions is defined by</p>

<p>

<math display="inline" id="Chirp_compression:17">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>*</mo>
     </msup>
     <mi>g</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>τ</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>t</mi>
      <mo>-</mo>
      <mi>τ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>d</mi>
    <mi>τ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>t</ci>
       <times></times>
      </apply>
      <ci>g</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>τ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <apply>
      <minus></minus>
      <ci>t</ci>
      <ci>τ</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(t)^{*}g(t)=\int_{-\infty}^{\infty}f(\tau).g(t-\tau).d\tau
  </annotation>
 </semantics>
</math>

</p>

<p>However, in order to use this method, the impulse response of Y(f) is first needed. This is y(t), which is obtained from</p>

<p>

<math display="inline" id="Chirp_compression:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <mrow>
      <mi>Y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>f</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
     </mrow>
     <mo>.</mo>
     <mrow>
      <mi>f</mi>
      <mi>t</mi>
     </mrow>
    </mrow>
   </msup>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mi>f</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <msup>
      <mi>e</mi>
      <mrow>
       <mrow>
        <mi>j</mi>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>f</mi>
           <mo>-</mo>
           <msub>
            <mi>f</mi>
            <mn>0</mn>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mn>2</mn>
        </msup>
       </mrow>
       <mo>/</mo>
       <mi>k</mi>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mrow>
      <mi>j</mi>
      <mn>2</mn>
      <mi>π</mi>
     </mrow>
     <mo>.</mo>
     <mrow>
      <mi>f</mi>
      <mi>t</mi>
     </mrow>
    </mrow>
   </msup>
   <mo>.</mo>
   <mrow>
    <mi>d</mi>
    <mi>f</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <ci>Y</ci>
       <ci>f</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>j</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <minus></minus>
           <ci>f</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>f</ci>
            <cn type="integer">0</cn>
           </apply>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <times></times>
       <ci>j</ci>
       <cn type="integer">2</cn>
       <ci>π</ci>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>f</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(t)=\int_{-\infty}^{\infty}Y(f).e^{2\pi.ft}.df=\int_{-\infty}^{\infty}e^{j(f-%
f_{0})^{2}/k}.e^{j2\pi.ft}.df
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Chirp_compression:19">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>u</mi>
   <mi>t</mi>
   <mi>f</mi>
   <mo>-</mo>
   <msub>
    <mi>f</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mi>u</mi>
   <mi>s</mi>
   <mi>o</mi>
   <mi>f</mi>
   <mo>=</mo>
   <mi>u</mi>
   <mo>-</mo>
   <msub>
    <mi>f</mi>
    <mn>0</mn>
   </msub>
   <mi>a</mi>
   <mi>n</mi>
   <mi>d</mi>
   <mi>d</mi>
   <mi>f</mi>
   <mo>=</mo>
   <mi>d</mi>
   <mi>u</mi>
   <mo>.</mo>
   <mi>A</mi>
   <mi>l</mi>
   <mi>s</mi>
   <mi>o</mi>
   <mi>w</mi>
   <mi>h</mi>
   <mi>e</mi>
   <mi>n</mi>
   <mi>f</mi>
   <mo>=</mo>
   <mo>±</mo>
   <mi mathvariant="normal">∞</mi>
   <mi>t</mi>
   <mi>h</mi>
   <mi>e</mi>
   <mi>n</mi>
   <mi>u</mi>
   <mo>=</mo>
   <mo>±</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">u</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <ci></ci>
    <csymbol cd="unknown">f</csymbol>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">0</cn>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">u</csymbol>
    <ci></ci>
    <csymbol cd="unknown">s</csymbol>
    <csymbol cd="unknown">o</csymbol>
    <ci></ci>
    <csymbol cd="unknown">f</csymbol>
    <eq></eq>
    <csymbol cd="unknown">u</csymbol>
    <minus></minus>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci></ci>
    <csymbol cd="unknown">a</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <csymbol cd="unknown">d</csymbol>
    <ci></ci>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">f</csymbol>
    <eq></eq>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">u</csymbol>
    <ci>normal-.</ci>
    <ci>italic-</ci>
    <csymbol cd="unknown">A</csymbol>
    <csymbol cd="unknown">l</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <csymbol cd="unknown">o</csymbol>
    <ci></ci>
    <csymbol cd="unknown">w</csymbol>
    <csymbol cd="unknown">h</csymbol>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <ci></ci>
    <csymbol cd="unknown">f</csymbol>
    <eq></eq>
    <csymbol cd="latexml">plus-or-minus</csymbol>
    <infinity></infinity>
    <ci></ci>
    <csymbol cd="unknown">t</csymbol>
    <csymbol cd="unknown">h</csymbol>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <ci></ci>
    <csymbol cd="unknown">u</csymbol>
    <eq></eq>
    <csymbol cd="latexml">plus-or-minus</csymbol>
    <infinity></infinity>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Put\quad f-f_{0}=u\quad so\quad f=u-f_{0}\quad and\quad df=du.\qquad Also\quad
when%
\quad f=\pm\infty\quad then\quad u=\pm\infty
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Chirp_compression:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </msubsup>
     <msup>
      <mi>e</mi>
      <mrow>
       <mrow>
        <mi>j</mi>
        <mi>π</mi>
       </mrow>
       <mo>.</mo>
       <mrow>
        <msup>
         <mi>u</mi>
         <mn>2</mn>
        </msup>
        <mo>/</mo>
        <mi>k</mi>
       </mrow>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mrow>
      <mi>j</mi>
      <mi>π</mi>
     </mrow>
     <mo>.</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>u</mi>
        <mo>-</mo>
        <msub>
         <mi>f</mi>
         <mn>0</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>t</mi>
     </mrow>
    </mrow>
   </msup>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mi>u</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>e</mi>
      <mrow>
       <mrow>
        <mi>j</mi>
        <mn>2</mn>
        <mi>π</mi>
       </mrow>
       <mo>.</mo>
       <mrow>
        <msub>
         <mi>f</mi>
         <mn>0</mn>
        </msub>
        <mi>t</mi>
       </mrow>
      </mrow>
     </msup>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <mrow>
        <mo>-</mo>
        <mi mathvariant="normal">∞</mi>
       </mrow>
       <mi mathvariant="normal">∞</mi>
      </msubsup>
      <msup>
       <mi>e</mi>
       <mrow>
        <mrow>
         <mi>j</mi>
         <mi>π</mi>
        </mrow>
        <mo>.</mo>
        <mrow>
         <msup>
          <mi>u</mi>
          <mn>2</mn>
         </msup>
         <mo>/</mo>
         <mi>k</mi>
        </mrow>
       </mrow>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mrow>
      <mi>j</mi>
      <mn>2</mn>
      <mi>π</mi>
     </mrow>
     <mo>.</mo>
     <mrow>
      <mi>u</mi>
      <mi>t</mi>
     </mrow>
    </mrow>
   </msup>
   <mo>.</mo>
   <mrow>
    <mi>d</mi>
    <mi>u</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <csymbol cd="ambiguous">formulae-sequence</csymbol>
        <apply>
         <times></times>
         <ci>j</ci>
         <ci>π</ci>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>u</ci>
          <cn type="integer">2</cn>
         </apply>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <times></times>
       <ci>j</ci>
       <ci>π</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <ci>u</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>u</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <csymbol cd="ambiguous">formulae-sequence</csymbol>
        <apply>
         <times></times>
         <ci>j</ci>
         <cn type="integer">2</cn>
         <ci>π</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <cn type="integer">0</cn>
         </apply>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <int></int>
         <apply>
          <minus></minus>
          <infinity></infinity>
         </apply>
        </apply>
        <infinity></infinity>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <csymbol cd="ambiguous">formulae-sequence</csymbol>
         <apply>
          <times></times>
          <ci>j</ci>
          <ci>π</ci>
         </apply>
         <apply>
          <divide></divide>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>u</ci>
           <cn type="integer">2</cn>
          </apply>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <times></times>
       <ci>j</ci>
       <cn type="integer">2</cn>
       <ci>π</ci>
      </apply>
      <apply>
       <times></times>
       <ci>u</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(t)=\int_{-\infty}^{\infty}e^{j\pi.u^{2}/k}.e^{j\pi.(u-f_{0})t}.du=e^{j2\pi.f%
_{0}t}\int_{-\infty}^{\infty}e^{j\pi.u^{2}/k}.e^{j2\pi.ut}.du
  </annotation>
 </semantics>
</math>

</p>

<p>A table of standard integrals<a class="footnoteRef" href="#fn64" id="fnref64"><sup>64</sup></a> gives the following transform 

<math display="inline" id="Chirp_compression:21">
 <semantics>
  <mrow>
   <msubsup>
    <mo largeop="true" symmetric="true">∫</mo>
    <mrow>
     <mo>-</mo>
     <mi mathvariant="normal">∞</mi>
    </mrow>
    <mi mathvariant="normal">∞</mi>
   </msubsup>
   <mi>e</mi>
   <mi>x</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>-</mo>
    <mi>π</mi>
    <mi>β</mi>
    <mo>.</mo>
    <msup>
     <mi>u</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mi>e</mi>
   <mi>x</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>j</mi>
    <mn>2</mn>
    <mi>π</mi>
    <mo>.</mo>
    <mi>u</mi>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mi>d</mi>
   <mi>u</mi>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <msqrt>
     <mi>β</mi>
    </msqrt>
   </mfrac>
   <mo>.</mo>
   <mi>e</mi>
   <mi>x</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <mi>π</mi>
      <mo>.</mo>
      <msup>
       <mi>t</mi>
       <mn>2</mn>
      </msup>
     </mrow>
     <mi>β</mi>
    </mfrac>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <minus></minus>
       <infinity></infinity>
      </apply>
     </apply>
     <infinity></infinity>
    </apply>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <minus></minus>
     <csymbol cd="unknown">π</csymbol>
     <csymbol cd="unknown">β</csymbol>
     <ci>normal-.</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>u</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">j</csymbol>
     <cn type="integer">2</cn>
     <csymbol cd="unknown">π</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">u</csymbol>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">u</csymbol>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <root></root>
      <ci>β</ci>
     </apply>
    </apply>
    <ci>normal-.</ci>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <ci>π</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>t</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>β</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{-\infty}^{\infty}exp(-\pi\beta.u^{2}).exp(j2\pi.ut).du=\frac{1}{\sqrt{%
\beta}}.exp(-\frac{\pi.t^{2}}{\beta})
  </annotation>
 </semantics>
</math>

<br/>
Comparing the equations, they are equivalent if β = -j/k , so y(t) becomes<br/>


<math display="inline" id="Chirp_compression:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msqrt>
     <mrow>
      <mi>j</mi>
      <mi>k</mi>
     </mrow>
    </msqrt>
   </mrow>
   <mo>.</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mi>π</mi>
     </mrow>
     <mo>.</mo>
     <mrow>
      <msub>
       <mi>f</mi>
       <mn>0</mn>
      </msub>
      <mi>t</mi>
     </mrow>
    </mrow>
   </msup>
   <mo>.</mo>
   <mrow>
    <msup>
     <mi>e</mi>
     <mrow>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>j</mi>
        <mi>π</mi>
       </mrow>
      </mrow>
      <mo>.</mo>
      <mrow>
       <msup>
        <mi>t</mi>
        <mn>2</mn>
       </msup>
       <mi>k</mi>
      </mrow>
     </mrow>
    </msup>
    <mo>=</mo>
    <msqrt>
     <mfrac>
      <mrow>
       <mi>j</mi>
       <mi>B</mi>
      </mrow>
      <mi>T</mi>
     </mfrac>
    </msqrt>
   </mrow>
   <mo>.</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mrow>
      <mi>j</mi>
      <mn>2</mn>
      <mi>π</mi>
     </mrow>
     <mo>.</mo>
     <mrow>
      <msub>
       <mi>f</mi>
       <mn>0</mn>
      </msub>
      <mi>t</mi>
     </mrow>
    </mrow>
   </msup>
   <mo>.</mo>
   <mrow>
    <msup>
     <mi>e</mi>
     <mrow>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>j</mi>
        <mi>π</mi>
       </mrow>
      </mrow>
      <mo>.</mo>
      <msup>
       <mi>t</mi>
       <mn>2</mn>
      </msup>
      <mo>.</mo>
      <mi>k</mi>
     </mrow>
    </msup>
    <mo>=</mo>
    <msqrt>
     <mfrac>
      <mrow>
       <mi>j</mi>
       <mi>B</mi>
      </mrow>
      <mi>T</mi>
     </mfrac>
    </msqrt>
   </mrow>
   <mo>.</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mi>j</mi>
     <mn>2</mn>
     <mi>π</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>f</mi>
         <mn>0</mn>
        </msub>
        <mi>t</mi>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mrow>
         <msup>
          <mi>t</mi>
          <mn>2</mn>
         </msup>
         <mi>k</mi>
        </mrow>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <root></root>
      <apply>
       <times></times>
       <ci>j</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>j</ci>
         <ci>π</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>t</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <root></root>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>j</ci>
        <ci>B</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <times></times>
       <ci>j</ci>
       <cn type="integer">2</cn>
       <ci>π</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>j</ci>
         <ci>π</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>t</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <root></root>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>j</ci>
        <ci>B</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <times></times>
      <ci>j</ci>
      <cn type="integer">2</cn>
      <ci>π</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>t</ci>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>t</ci>
          <cn type="integer">2</cn>
         </apply>
         <ci>k</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(t)=\sqrt{jk}.e^{2\pi.f_{0}t}.e^{-j\pi.t^{2}k}=\sqrt{\frac{jB}{T}}.e^{j2\pi.f%
_{0}t}.e^{-j\pi.t^{2}.k}=\sqrt{\frac{jB}{T}}.e^{j2\pi(f_{0}t-t^{2}k/2)}
  </annotation>
 </semantics>
</math>

</p>

<p>[Note: the same transform can also be found in <a href="Fourier_transforms" title="wikilink">Fourier transforms</a>, no. 206, but with <mtpl></mtpl> replacing <mtpl></mtpl><mtpl></mtpl>]</p>

<p>With y(t) determined, the output s<sub>out</sub>(t) can be obtained from the convolution of s<sub>1</sub>(t) and y(t) , i.e.<br/>


<math display="inline" id="Chirp_compression:23">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>s</mi>
     <mtext>out</mtext>
    </msub>
    <mo>=</mo>
    <msqrt>
     <mfrac>
      <mrow>
       <mi>j</mi>
       <mi>B</mi>
      </mrow>
      <mi>T</mi>
     </mfrac>
    </msqrt>
   </mrow>
   <mo>.</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>T</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </mrow>
     <mrow>
      <mi>T</mi>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msubsup>
    <msup>
     <mi>e</mi>
     <mrow>
      <mi>j</mi>
      <mn>2</mn>
      <mi>π</mi>
      <mo>.</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>f</mi>
        <mn>0</mn>
       </msub>
       <mi>τ</mi>
       <mo>+</mo>
       <mi>k</mi>
       <msup>
        <mi>τ</mi>
        <mn>2</mn>
       </msup>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </mrow>
    </msup>
   </mrow>
   <mo>.</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mi>j</mi>
     <mn>2</mn>
     <mi>π</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>f</mi>
         <mn>0</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>t</mi>
          <mo>-</mo>
          <mi>τ</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mrow>
         <mi>k</mi>
         <msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>t</mi>
            <mo>-</mo>
            <mi>τ</mi>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
          <mn>2</mn>
         </msup>
        </mrow>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <mo>.</mo>
   <mrow>
    <mi>d</mi>
    <mi>τ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <mtext>out</mtext>
     </apply>
     <apply>
      <root></root>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>j</ci>
        <ci>B</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <ci>T</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <ci>T</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <csymbol cd="unknown">j</csymbol>
       <cn type="integer">2</cn>
       <csymbol cd="unknown">π</csymbol>
       <ci>normal-.</ci>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <cn type="integer">0</cn>
        </apply>
        <csymbol cd="unknown">τ</csymbol>
        <plus></plus>
        <csymbol cd="unknown">k</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>τ</ci>
         <cn type="integer">2</cn>
        </apply>
        <divide></divide>
        <cn type="integer">2</cn>
       </cerror>
      </cerror>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <times></times>
      <ci>j</ci>
      <cn type="integer">2</cn>
      <ci>π</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <cn type="integer">0</cn>
        </apply>
        <apply>
         <minus></minus>
         <ci>t</ci>
         <ci>τ</ci>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>k</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <minus></minus>
           <ci>t</ci>
           <ci>τ</ci>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{\text{out}}=\sqrt{\frac{jB}{T}}.\int_{-T/2}^{T/2}e^{j2\pi.(f_{0}\tau+k\tau^%
{2}/2}.e^{j2\pi(f_{0}(t-\tau)-k(t-\tau)^{2}/2)}.d\tau
  </annotation>
 </semantics>
</math>

<br/>
which can be simplified to<br/>


<math display="inline" id="Chirp_compression:24">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>s</mi>
     <mtext>out</mtext>
    </msub>
    <mo>=</mo>
    <msqrt>
     <mfrac>
      <mrow>
       <mi>j</mi>
       <mi>B</mi>
      </mrow>
      <mi>T</mi>
     </mfrac>
    </msqrt>
   </mrow>
   <mo>.</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mi>j</mi>
     <mn>2</mn>
     <mi>π</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>f</mi>
         <mn>0</mn>
        </msub>
        <mi>t</mi>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mrow>
         <mi>k</mi>
         <msup>
          <mi>t</mi>
          <mn>2</mn>
         </msup>
        </mrow>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
   <mo>.</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>T</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </mrow>
     <mrow>
      <mi>T</mi>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msubsup>
    <msup>
     <mi>e</mi>
     <mrow>
      <mi>j</mi>
      <mn>2</mn>
      <mi>π</mi>
      <mi>k</mi>
      <mi>t</mi>
      <mi>τ</mi>
     </mrow>
    </msup>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>d</mi>
    <mi>τ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <mtext>out</mtext>
     </apply>
     <apply>
      <root></root>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>j</ci>
        <ci>B</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <times></times>
      <ci>j</ci>
      <cn type="integer">2</cn>
      <ci>π</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>t</ci>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>k</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>t</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <ci>T</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <ci>T</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <times></times>
       <ci>j</ci>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <ci>k</ci>
       <ci>t</ci>
       <ci>τ</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>τ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{\text{out}}=\sqrt{\frac{jB}{T}}.e^{j2\pi(f_{0}t-kt^{2}/2)}.\int_{-T/2}^{T/2%
}e^{j2\pi kt\tau}.d\tau
  </annotation>
 </semantics>
</math>

</p>

<p>now as 

<math display="inline" id="Chirp_compression:25">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" symmetric="true">∫</mo>
    <msup>
     <mi>e</mi>
     <mrow>
      <mi>a</mi>
      <mi>x</mi>
     </mrow>
    </msup>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mi>x</mi>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <msup>
      <mi>e</mi>
      <mrow>
       <mi>a</mi>
       <mi>x</mi>
      </mrow>
     </msup>
     <mi>a</mi>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <int></int>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <times></times>
       <ci>a</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <times></times>
        <ci>a</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int e^{ax}.dx=\frac{e^{ax}}{a}
  </annotation>
 </semantics>
</math>

 then</p>

<p>

<math display="inline" id="Chirp_compression:26">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>T</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </mrow>
     <mrow>
      <mi>T</mi>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msubsup>
    <msup>
     <mi>e</mi>
     <mrow>
      <mrow>
       <mi>j</mi>
       <mn>2</mn>
       <mi>π</mi>
      </mrow>
      <mo>.</mo>
      <mrow>
       <mi>k</mi>
       <mi>t</mi>
       <mi>τ</mi>
      </mrow>
     </mrow>
    </msup>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mi>τ</mi>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mi>j</mi>
      <mn>2</mn>
      <mi>π</mi>
      <mi>k</mi>
      <mi>t</mi>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
   <mrow>
    <msubsup>
     <mrow>
      <mo maxsize="160%" minsize="160%">[</mo>
      <msup>
       <mi>e</mi>
       <mrow>
        <mrow>
         <mi>j</mi>
         <mn>2</mn>
         <mi>π</mi>
        </mrow>
        <mo>.</mo>
        <mrow>
         <mi>k</mi>
         <mi>t</mi>
         <mi>τ</mi>
        </mrow>
       </mrow>
      </msup>
      <mo maxsize="160%" minsize="160%">]</mo>
     </mrow>
     <mtext>-T/2</mtext>
     <mtext>T/2</mtext>
    </msubsup>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <mi>j</mi>
       <mn>2</mn>
       <mi>π</mi>
       <mi>k</mi>
       <mi>t</mi>
      </mrow>
     </mfrac>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <msup>
        <mi>e</mi>
        <mrow>
         <mrow>
          <mi>j</mi>
          <mn>2</mn>
          <mi>π</mi>
          <mi>k</mi>
          <mi>T</mi>
         </mrow>
         <mo>/</mo>
         <mn>2</mn>
        </mrow>
       </msup>
       <mo>-</mo>
       <msup>
        <mi>e</mi>
        <mrow>
         <mo>-</mo>
         <mrow>
          <mrow>
           <mi>j</mi>
           <mn>2</mn>
           <mi>π</mi>
           <mi>k</mi>
           <mi>T</mi>
          </mrow>
          <mo>/</mo>
          <mn>2</mn>
         </mrow>
        </mrow>
       </msup>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <ci>T</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <ci>T</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <times></times>
        <ci>j</ci>
        <cn type="integer">2</cn>
        <ci>π</ci>
       </apply>
       <apply>
        <times></times>
        <ci>k</ci>
        <ci>t</ci>
        <ci>τ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>τ</ci>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>j</ci>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <ci>k</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>e</ci>
         <apply>
          <csymbol cd="ambiguous">formulae-sequence</csymbol>
          <apply>
           <times></times>
           <ci>j</ci>
           <cn type="integer">2</cn>
           <ci>π</ci>
          </apply>
          <apply>
           <times></times>
           <ci>k</ci>
           <ci>t</ci>
           <ci>τ</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <mtext>T/2</mtext>
      </apply>
      <mtext>-T/2</mtext>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <ci>j</ci>
        <cn type="integer">2</cn>
        <ci>π</ci>
        <ci>k</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>e</ci>
         <apply>
          <divide></divide>
          <apply>
           <times></times>
           <ci>j</ci>
           <cn type="integer">2</cn>
           <ci>π</ci>
           <ci>k</ci>
           <ci>T</ci>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>e</ci>
         <apply>
          <minus></minus>
          <apply>
           <divide></divide>
           <apply>
            <times></times>
            <ci>j</ci>
            <cn type="integer">2</cn>
            <ci>π</ci>
            <ci>k</ci>
            <ci>T</ci>
           </apply>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{-T/2}^{T/2}e^{j2\pi.kt\tau}.d\tau=\frac{1}{j2\pi kt}.\Bigl[e^{j2\pi.kt%
\tau}\Bigr]^{\text{T/2}}_{\text{-T/2}}=\frac{1}{j2\pi kt}[e^{j2\pi kT/2}-e^{-j%
2\pi kT/2}]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Chirp_compression:27">
 <semantics>
  <mrow>
   <mrow>
    <mi></mi>
    <mo>=</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mi>π</mi>
      <mi>k</mi>
      <mi>t</mi>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mfrac>
     <mrow>
      <msup>
       <mi>e</mi>
       <mrow>
        <mi>j</mi>
        <mi>π</mi>
        <mi>B</mi>
        <mi>t</mi>
       </mrow>
      </msup>
      <mo>-</mo>
      <msup>
       <mi>e</mi>
       <mrow>
        <mo>-</mo>
        <mrow>
         <mi>j</mi>
         <mi>π</mi>
         <mi>B</mi>
         <mi>t</mi>
        </mrow>
       </mrow>
      </msup>
     </mrow>
     <mrow>
      <mn>2</mn>
      <mi>j</mi>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mi>π</mi>
      <mi>k</mi>
      <mi>t</mi>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mi>s</mi>
    <mi>i</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>π</mi>
      <mi>B</mi>
      <mi>t</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>π</ci>
       <ci>k</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <times></times>
         <ci>j</ci>
         <ci>π</ci>
         <ci>B</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>j</ci>
          <ci>π</ci>
          <ci>B</ci>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>π</ci>
       <ci>k</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>i</ci>
     <ci>n</ci>
     <apply>
      <times></times>
      <ci>π</ci>
      <ci>B</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\frac{1}{\pi kt}.\frac{e^{j\pi Bt}-e^{-j\pi Bt}}{2j}=\frac{1}{\pi kt}.sin(\pi
Bt)
  </annotation>
 </semantics>
</math>

</p>

<p>and finally<br/>


<math display="inline" id="Chirp_compression:28">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mtext>out</mtext>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mi>π</mi>
     <mi>k</mi>
     <mi>t</mi>
    </mrow>
   </mfrac>
   <mo>.</mo>
   <msqrt>
    <mfrac>
     <mrow>
      <mi>j</mi>
      <mi>B</mi>
     </mrow>
     <mi>T</mi>
    </mfrac>
   </msqrt>
   <mo>.</mo>
   <mi>s</mi>
   <mi>i</mi>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>π</mi>
    <mi>B</mi>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
   <mi>e</mi>
   <mi>x</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>j</mi>
    <mn>2</mn>
    <mi>π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>f</mi>
      <mn>0</mn>
     </msub>
     <mi>t</mi>
     <mo>-</mo>
     <mi>k</mi>
     <msup>
      <mi>t</mi>
      <mn>2</mn>
     </msup>
     <mo>/</mo>
     <mn>2</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <mtext>out</mtext>
    </apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>π</ci>
      <ci>k</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <ci>normal-.</ci>
    <apply>
     <root></root>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>j</ci>
       <ci>B</ci>
      </apply>
      <ci>T</ci>
     </apply>
    </apply>
    <ci>normal-.</ci>
    <csymbol cd="unknown">s</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">π</csymbol>
     <csymbol cd="unknown">B</csymbol>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">j</csymbol>
     <cn type="integer">2</cn>
     <csymbol cd="unknown">π</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">0</cn>
      </apply>
      <csymbol cd="unknown">t</csymbol>
      <minus></minus>
      <csymbol cd="unknown">k</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>t</ci>
       <cn type="integer">2</cn>
      </apply>
      <divide></divide>
      <cn type="integer">2</cn>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{\text{out}}=\frac{1}{\pi kt}.\sqrt{\frac{jB}{T}}.sin(\pi BT).exp[j2\pi(f_{0%
}t-kt^{2}/2)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Chirp_compression:29">
 <semantics>
  <mrow>
   <mo>=</mo>
   <msqrt>
    <mrow>
     <mi>T</mi>
     <mo>.</mo>
     <mi>B</mi>
    </mrow>
   </msqrt>
   <mo>.</mo>
   <msqrt>
    <mi>j</mi>
   </msqrt>
   <mo>.</mo>
   <mfrac>
    <mrow>
     <mi>s</mi>
     <mi>i</mi>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>π</mi>
       <mi>B</mi>
       <mi>T</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>π</mi>
     <mi>B</mi>
     <mi>t</mi>
    </mrow>
   </mfrac>
   <mo>.</mo>
   <mi>e</mi>
   <mi>x</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>j</mi>
    <mn>2</mn>
    <mi>π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>f</mi>
      <mn>0</mn>
     </msub>
     <mi>t</mi>
     <mo>-</mo>
     <mi>k</mi>
     <msup>
      <mi>t</mi>
      <mn>2</mn>
     </msup>
     <mo>/</mo>
     <mn>2</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <eq></eq>
    <apply>
     <root></root>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <ci>T</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <ci>normal-.</ci>
    <apply>
     <root></root>
     <ci>j</ci>
    </apply>
    <ci>normal-.</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>i</ci>
      <ci>n</ci>
      <apply>
       <times></times>
       <ci>π</ci>
       <ci>B</ci>
       <ci>T</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>π</ci>
      <ci>B</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <ci>normal-.</ci>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">j</csymbol>
     <cn type="integer">2</cn>
     <csymbol cd="unknown">π</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <cn type="integer">0</cn>
      </apply>
      <csymbol cd="unknown">t</csymbol>
      <minus></minus>
      <csymbol cd="unknown">k</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>t</ci>
       <cn type="integer">2</cn>
      </apply>
      <divide></divide>
      <cn type="integer">2</cn>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =\sqrt{T.B}.\sqrt{j}.\frac{sin(\pi BT)}{\pi Bt}.exp[j2\pi(f_{0}t-kt^{2}/2)
  </annotation>
 </semantics>
</math>

</p>

<p>So, for a unit amplitude linear chirp, with a pulse duration T seconds and a frequency sweep B Hz (i.e. with a ‘time-bandwidth product’ T.B), pulse compression gives a waveform with a magnitude given by<br/>


<math display="inline" id="Chirp_compression:30">
 <semantics>
  <mrow>
   <mrow>
    <mo>|</mo>
    <mtext>Compressed Output</mtext>
    <mo>|</mo>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <msqrt>
     <mrow>
      <mi>T</mi>
      <mo>.</mo>
      <mi>B</mi>
     </mrow>
    </msqrt>
    <mo>×</mo>
    <mfrac>
     <mrow>
      <mi>s</mi>
      <mi>i</mi>
      <mi>n</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>π</mi>
        <mi>B</mi>
        <mi>t</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>π</mi>
       <mi>B</mi>
       <mi>t</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <abs></abs>
     <mtext>Compressed Output</mtext>
    </apply>
    <apply>
     <times></times>
     <apply>
      <root></root>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <ci>T</ci>
       <ci>B</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>i</ci>
       <ci>n</ci>
       <apply>
        <times></times>
        <ci>π</ci>
        <ci>B</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>π</ci>
       <ci>B</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left|{\text{Compressed Output}}\right|\approx\sqrt{T.B}\times\frac{sin(\pi Bt%
)}{(\pi Bt)}
  </annotation>
 </semantics>
</math>

</p>

<p>which has the form of the familiar <a href="sinc_function" title="wikilink">sinc function</a>. The collapsed pulse width <mtpl></mtpl>, is of the order 1/B (with <mtpl></mtpl> measured at the –4 dB points). Consequently, a pulse width reduction has occurred given by the ratio T/<mtpl></mtpl> where 

<math display="inline" id="Chirp_compression:31">
 <semantics>
  <mrow>
   <mfrac>
    <mi>T</mi>
    <mi>τ</mi>
   </mfrac>
   <mo>≈</mo>
   <mrow>
    <mi>T</mi>
    <mo>×</mo>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <divide></divide>
     <ci>T</ci>
     <ci>τ</ci>
    </apply>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{T}{\tau}\approx T\times B
  </annotation>
 </semantics>
</math>

<br/>
Also there is a signal amplification of 

<math display="inline" id="Chirp_compression:32">
 <semantics>
  <msqrt>
   <mrow>
    <mi>T</mi>
    <mo>×</mo>
    <mi>B</mi>
   </mrow>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{T\times B}
  </annotation>
 </semantics>
</math>

<br/>
The main parameters are displayed in the figures below. The product T.B gives the compression ratio of the system and it equates, approximately, to the improvement in signal to noise ratio of the main lobe of the compressed pulse relative to that of the original chirp. </p>
<h2 id="properties-of-linear-chirps">Properties of Linear Chirps</h2>
<h3 id="pulse-degradation-caused-by-fresnel-ripples">Pulse Degradation caused by Fresnel Ripples</h3>

<p>In the closed form solution, just presented, the compressed waveform has the standard <a class="uri" href="sinc" title="wikilink">sinc</a> function response, because a rectangular shape was assumed for the amplitude of the pulse spectrum. In practice, the spectrum of a linear chirp has a rectangular profile only when the time-bandwidth product of a pulse is large, i.e. when T×B exceeds 100, say. When the product is small, the spectral profile of the chirp pulse is seriously degraded by Fresnel ripples as shown in <a href="Chirp_spectrum" title="wikilink">Chirp spectrum</a> and so is that of the matched filter. To investigate fully the consequences of these ripples it is advisable to consider each situation individually, either by evaluating convolution integrals, or more conveniently, by means of <a href="FFT" title="wikilink">FFTs</a>.</p>

<p>Some examples are shown below, for TB = 1000, 250, 100 and 25. They are dB plots which have all been normalised to have their pulse peaks set at 0 dB.</p>
<figure><b>(Figure)</b>
<figcaption>Compressed Pulses for TB=1000,250.png</figcaption>
</figure>
<figure><b>(Figure)</b>
<figcaption>Compressed Pulses for TB=100,25.png</figcaption>
</figure>

<p>As can be seen, at high values of TB, the plots match the sinc characteristic closely, but at low values, significant differences can be seen. As already stated, these degradations in the waveforms, at low TB values, are because the spectral characteristics are no longer truly rectangular. In all cases, the close-in sidelobe levels are consistently high, at about -13.5 dB relative to the main lobe.</p>

<p>These range sidelobes are an unwelcome presence on the compressed pulse, because they will obscure signals of lower amplitude, which may also be present.</p>
<h3 id="reducing-sidelobes-by-weighting-functions">Reducing Sidelobes by Weighting Functions</h3>

<p>As the sinc-like characteristics of a compressed pulse are due to the near-rectangular profile of its spectrum, then by modifying that characteristic into a bell shape, for example, it is possible to reduce the sidelobe levels considerably. Previous work for antenna arrays and digital signal processing has already addressed this same problem. So, for example, in the case of antennas, the spatial sidelobes on the beam pattern are improved by applying a <a href="weighting_function" title="wikilink">weighting function</a> to the array elements,<a class="footnoteRef" href="#fn65" id="fnref65"><sup>65</sup></a> and in the case of digital signal processing, <a href="window_functions" title="wikilink">window functions</a> are used to reduce the amplitude of unwanted sidelobes<a class="footnoteRef" href="#fn66" id="fnref66"><sup>66</sup></a> on the sampled functions.</p>

<p>In an example of the process, the spectrum of a chirp pulse, with a time-bandwidth product of 250, is shown on the left, and is approximately rectangular in profile. Below this plot, also on the left, is shown the waveform after compression of the chirp by its matched filter and is similar to the sinc function, as expected. The top plot, on the right, is the spectrum after Hamming weighting. (This was achieved by applying a root-Hamming characteristic to both the chirp spectrum and to the compressor spectrum). The compressed pulse corresponding to this spectrum, shown in the lower plots on the right, has much lower sidelobe levels.</p>
<figure><b>(Figure)</b>
<figcaption>Chirp spectra, TB=250, without &amp; with  weighting.png</figcaption>
</figure>
<figure><b>(Figure)</b>
<figcaption>centre</figcaption>
</figure>
<figure><b>(Figure)</b>
<figcaption>centre</figcaption>
</figure>

<p>Although the sidelobe level has been much reduced, there are some undesirable consequences of the weighting process. Firstly, there is an overall loss of gain, with the peak amplitude of the main lobe reduced by about 5.4 dB and, secondly, the half-power beam width of the main pulse has increased by nearly 50%. In, say, a radar system, these effects would cause loss of range and reduced range resolution, respectively.</p>

<p>In general, the more the sidelobe levels are lowered, the broader the main lobe will become. However, the various windowing functions do perform differently from one other, with some giving main lobes which are unnecessarily broad for the sidelobe levels achieved. The most efficient function is the Dolph-Chebyshev window (see <a href="Window_functions" title="wikilink">Window functions</a>) as this gives the narrowest pulse at a given sidelobe level.<a class="footnoteRef" href="#fn67" id="fnref67"><sup>67</sup></a> A selection of the better performing windowing functions are shown in the graph of Beamwidth × Bandwidth as sidelobe level.</p>

<p>The lowest full line on the graph is for Dolph-Chebyshev weighting which, as already mentioned, sets the narrowest lobe possible for a given sidelobe level. So, from this plot, if a sidelobe level of -40 dB is desired, the graph shows that the smallest achievable half-power beamwidth × bandwidth is 1.2. Thus a chirp sweeping over a 20 MHz frequency band will have a compressed pulsewidth of 60 nanoseconds (at least).</p>

<p>As can be seen from the diagram, Taylor weighting is particularly efficient, and Hamming and the three and four term Blackman-Harris functions all give good results, too. Although the cos<sup>N</sup> functions perform badly, they have been included because they are amenable to mathematical manipulation and were studied in some detail in early work.<a class="footnoteRef" href="#fn68" id="fnref68"><sup>68</sup></a><a class="footnoteRef" href="#fn69" id="fnref69"><sup>69</sup></a></p>
<figure><b>(Figure)</b>
<figcaption>Pulse width versus sidelobe level for  several weighting functions.png</figcaption>
</figure>
<h3 id="far-out-sidelobes-on-compressed-pulses">Far-out Sidelobes on Compressed Pulses</h3>

<p>The example of a chirp with TB = 250 and Hamming weighting, given earlier, illustrates the benefits of weighting but is not representative of a normal situation because the results there were achieved by applying weighting equally to both the signal chirp and to its compressor. However, in a typical radar system the chirp pulse is usually transmitted by an amplifier operating in or near to compression, to maximise transmitter efficiency. In such a case, amplitude modulation of the chirp waveform or its spectrum is not possible, so the full window characteristic has to be incorporated into the compressor response. Unfortunately, this arrangement has undesirable consequences for the far-out sidelobes of the compressed pulse, especially when the time-bandwidth of the chirp is small.<br/>
Consider first the compressed pulse when TB = 250, which is shown in the left-hand figure below. For this result no weighting has been applied to the transmit pulse, but the full Hamming weighting has been applied in the compressor. As can be seen, the close-in sidelobe levels are consistent with the Hamming weighting (-42 dB), but further out, the sidelobe levels rise to a peak value of -45 dB at <mtpl></mtpl>T/2 each side of the main lobe. In the right-hand figure, where TB =25, the problems with the far-out sidelobes are much more serious. Here these sidelobes now rise to -25 dB at <mtpl></mtpl>T/2</p>
<figure><b>(Figure)</b>
<figcaption>Compressed Pulses, TB=250,25, far out slobes.png</figcaption>
</figure>

<p>As a guide, the far-out sidelobe levels are given by</p>

<p>

<math display="inline" id="Chirp_compression:33">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mi>a</mi>
   <mi>r</mi>
   <mi>S</mi>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>d</mi>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≈</mo>
   <mo>-</mo>
   <mn>20</mn>
   <mo>×</mo>
   <mi>l</mi>
   <mi>o</mi>
   <msub>
    <mi>g</mi>
    <mtext>10</mtext>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo>.</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">F</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <csymbol cd="unknown">L</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">d</csymbol>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <approx></approx>
    <minus></minus>
    <cn type="integer">20</cn>
    <times></times>
    <csymbol cd="unknown">l</csymbol>
    <csymbol cd="unknown">o</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <mtext>10</mtext>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">T</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   FarSL(dB)\approx-20\times log_{\text{10}}(T.B)
  </annotation>
 </semantics>
</math>

</p>

<p>Slight variations on this equation are given in the literature,<a class="footnoteRef" href="#fn70" id="fnref70"><sup>70</sup></a><a class="footnoteRef" href="#fn71" id="fnref71"><sup>71</sup></a><a class="footnoteRef" href="#fn72" id="fnref72"><sup>72</sup></a> but they only differ by a few dBs. Best results seem to be obtained when the window function is applied in the time domain to the compressor waveform (as amplitude modulation) rather than in the frequency domain to its spectrum.<a class="footnoteRef" href="#fn73" id="fnref73"><sup>73</sup></a></p>
<h3 id="reducing-far-out-sidelobes">Reducing Far-Out Sidelobes</h3>

<p>As the far-out sidelobes are a consequence of the Fresnel ripple on the compressed pulse spectrum, any technique that reduces this ripple will also reduce the level of the sidelobes. In fact, there are several ways of achieving this reduction,<a class="footnoteRef" href="#fn74" id="fnref74"><sup>74</sup></a> as shown below. Several of the methods are featured in <a href="Chirp_spectrum" title="wikilink">Chirp spectrum</a>.</p>
<h4 id="introducing-finite-duration-rise-and-fall-times">Introducing Finite Duration Rise and Fall Times</h4>

<p>A chirp with slow rise and fall times has reduced ripple on its spectrum (see <a href="Chirp_spectrum" title="wikilink">Chirp spectrum</a>), so will result in lower time sidelobes on the compressed pulse. As an example, consider first the figure shows the compressed spectrum of a linear chirp, which has fast rise and fall times, with T×B = 100 and where Blackman-Harris weighting has been applied. The waveform corresponding to this spectrum has time sidelobes rising to about -40 dB, as predicted.</p>
<figure><b>(Figure)</b>
<figcaption>Chirp spectrum + wfm, TB=100, B-H weighting.png</figcaption>
</figure>

<p>After linear rise and fall times are introduced, using the amplitude template shown, the ripple on the spectrum is much reduced and the time sidelobes are significantly lower, as shown.</p>

<p> <embed src="Compr. pulse, Spec and wfm, TB=100, BH wgt, slow r&amp;f.png;" title="fig:Compr. pulse, Spec and wfm, TB=100, BH wgt, slow r&amp;f.png;"></embed></p>

<p>The procedure is most effective when both the signal chirp and the compressor chirp have modified rise-times, when sidelobe levels can be lowered by 15 – 20 dB. However, it is not always possible to apply amplitude modulation in the transmitter, so there is less improvement when only the compressor waveform is modified. Even so, a sidelobe reduction of about 6 dB can still be achieved.</p>

<p>The precise manner in which the rise and fall times are made less severe is not very critical, so the technique of adding cosine tapers to the compressed pulse spectrum (as with the Tukey<a class="footnoteRef" href="#fn75" id="fnref75"><sup>75</sup></a> weighting function) gives a similar improvement - of several dBs.<a class="footnoteRef" href="#fn76" id="fnref76"><sup>76</sup></a></p>

<p>Improvements achieved by the method are tolerant of Doppler shifts.</p>
<h4 id="introducing-tweaking-of-the-phase-characteristic">Introducing ‘Tweaking’ of the Phase Characteristic</h4>

<p>An alternative form of waveform ‘tweaking’ is where frequency modulation distortion is applied to the chirps, instead of amplitude modulation.<a class="footnoteRef" href="#fn77" id="fnref77"><sup>77</sup></a><a class="footnoteRef" href="#fn78" id="fnref78"><sup>78</sup></a><a class="footnoteRef" href="#fn79" id="fnref79"><sup>79</sup></a> The two types of distortion are functionally similar when the distortion levels are low. As with amplitude modulation, best results are obtained when both the expander and compressor waveforms are modified.</p>
<figure><b>(Figure)</b>
<figcaption>Linear chirp with phase tweaks.png</figcaption>
</figure>

<p>For best results Cook and Paolillo recommend δf = 0.75×B and δ = 1/B. As an example, a pulse considered earlier, with T×B = 100 and Blackman-Harris weighting, is modified with phase tweaking and the results are shown. There is reduced ripple on the compressed pulse spectrum and the far-out sidelobes have been reduced.</p>
<figure><b>(Figure)</b>
<figcaption>Chirp spectrum and wfm, TB=100, BH wgt, with phase treaks.png</figcaption>
</figure>

<p>The improvements are maintained even when Doppler frequency shifts are present on the signals. In a more recent paper <a class="footnoteRef" href="#fn80" id="fnref80"><sup>80</sup></a> slightly different parameters have been suggested, namely δ = 0.86/B and δf = 0.73×B. Also, Kowatsch and Stocker<a class="footnoteRef" href="#fn81" id="fnref81"><sup>81</sup></a> has reported improved results by applying a cubic distortion function (whereas Cook and Paolillo’s technique may be termed ‘square-law modulation distortion’). This new characteristic is also tolerant of Doppler frequency shifts.</p>
<h4 id="reciprocal-ripple-correction">Reciprocal Ripple Correction</h4>

<p>The spectral response of the matched filter has a magnitude which is the mirror image of that of the expanded pulse, when a chirp spectrum has symmetry about its centre frequency, so the Fresnell ripples on the spectrum are augmented by the compression process. What is needed to reduce the ripples is a compression filter whose spectrum has the inverse (reciprocal) ripple to that of the expander.<a class="footnoteRef" href="#fn82" id="fnref82"><sup>82</sup></a> As this will no longer be a matched filter, there will be increased mismatch loss. In his early work<a class="footnoteRef" href="#fn83" id="fnref83"><sup>83</sup></a><a class="footnoteRef" href="#fn84" id="fnref84"><sup>84</sup></a><a class="footnoteRef" href="#fn85" id="fnref85"><sup>85</sup></a> Cook did not recommend attempting such a procedure because the filters needed were considered too difficult to make. However, with the advent of SAW technology it became possible to achieve the required characteristics.<a class="footnoteRef" href="#fn86" id="fnref86"><sup>86</sup></a><a class="footnoteRef" href="#fn87" id="fnref87"><sup>87</sup></a><a class="footnoteRef" href="#fn88" id="fnref88"><sup>88</sup></a><a class="footnoteRef" href="#fn89" id="fnref89"><sup>89</sup></a> More recently, digital techniques with mathematically derived look-up tables have provided a convenient way of introducing reciprocal ripple correction.<a class="footnoteRef" href="#fn90" id="fnref90"><sup>90</sup></a></p>

<p>The spectrum of the compressed pulse is the product of the spectra of the expander and compressor filters, as given earlier. Now, instead of C(ω), a new output spectrum C'(ω) is defined, which has no Fresnell ripples but which defines a desired sidelobe structure (such as that defined by a Hamming window). The compression filter that will achieve this requirement is determined by the equation</p>

<p>

<math display="inline" id="Chirp_compression:34">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msup>
      <mi>C</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ω</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>H</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ω</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <ci>ω</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>C</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>ω</ci>
     </apply>
     <apply>
      <times></times>
      <ci>H</ci>
      <ci>ω</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(\omega)=\frac{C^{\prime}(\omega)}{H(\omega)}
  </annotation>
 </semantics>
</math>

</p>

<p>where H(<mtpl></mtpl>) is the spectrum of the signal, C’(<mtpl></mtpl>) is the target spectrum for the compressed pulse and has the low sidelobes of the chosen weighting function and K(<mtpl></mtpl>) is the spectrum of the compression filter which has the reciprocal ripple properties. Close-in sidelobes are automatically dealt with in the process.</p>

<p>As an example of the procedure consider a linear chirp with T×B =100. The left-hand figures shows (one half of) the spectrum of the chirp, and the right-hand figure shows the waveform after compression. As expected, close-in sidelobes start at -13.5 dB.</p>
<figure><b>(Figure)</b>
<figcaption>Linear Chirp, TB=100, no wgting.png</figcaption>
</figure>

<p>In the next figure, Blackman-Harris weighting has been applied to the compressed pulse spectrum. Although the close-in sidelobes have been reduced, the far-out sidelobes remain high with a predicted level of, approximately -20×log<sub>10</sub>(100) = -40 dB, as predicted for a time-bandwidth product of 100. With lower time-bandwidth products, these sidelobes will be even higher.</p>
<figure><b>(Figure)</b>
<figcaption>Chirp Pulse, TB=100, with B-H weighting.png</figcaption>
</figure>

<p>Next, a compression filter that provides reciprocal-ripple correction has been used. As can be seen, a ripple-free spectrum has been achieved resulting in a waveform that is free from high level far-out sidelobes.</p>
<figure><b>(Figure)</b>
<figcaption>Chirp, TB=100, BH wgt, RR corr, no trunc.png</figcaption>
</figure>

<p>However, this procedure has a problem. Although the process has found a compressor spectrum that leads to low sidelobes on the compressed pulse, no account was taken of the waveform this spectrum might have. When an inverse Fourier transform is carried out on this spectrum, in order to determine the characteristics of its waveform, it is found that the waveform is of extremely long duration, typically exceeding 10T. Even assuming the waveform is no longer than 10T, it means that the total time needed to process one chirp will be at least 11T, in total, a length of time unacceptable in most circumstances.</p>

<p>In order to achieve a practical solution Judd<a class="footnoteRef" href="#fn91" id="fnref91"><sup>91</sup></a> proposed that the total length of the compression pulse be truncated to 2T, whereas Butler<a class="footnoteRef" href="#fn92" id="fnref92"><sup>92</sup></a> suggested 1.6T and 1.3T. Extensions as low as 10% have also been used<a class="footnoteRef" href="#fn93" id="fnref93"><sup>93</sup></a></p>

<p>Unfortunately, when the new compressor waveform is truncated, then far-out sidelobes reappear once more. The next figures shows what happens to the compressed pulse when the compressor is set at 2T duration and then at 1.1T duration. New far-out sidelobes have appeared with amplitudes that make them clearly visible. These sidelobes are often referred to as “gating sidelobes”.<a class="footnoteRef" href="#fn94" id="fnref94"><sup>94</sup></a> They can be irritatingly high but, fortunately, even if the compressor is set have just 10% extension, the sidelobes are still at a level than that achieved without correction.</p>
<figure><b>(Figure)</b>
<figcaption>Chirp, TB=100, BH=100, RR Corr, 100% Extn.png</figcaption>
</figure>
<figure><b>(Figure)</b>
<figcaption>Chirp Pulse, TB=100, BH Wgt, RR Corr, 10% Extn.png</figcaption>
</figure>

<p>Any Doppler frequency shift on the received signals will degrade the ripple cancelation process<a class="footnoteRef" href="#fn95" id="fnref95"><sup>95</sup></a><a class="footnoteRef" href="#fn96" id="fnref96"><sup>96</sup></a> and this is discussed in more detail next.</p>
<h3 id="doppler-tolerance-of-linear-chirps-1">Doppler Tolerance of Linear Chirps</h3>

<p>Whenever the radial distance between a moving target and the radar changes with time, the reflected chirp returns will exhibit a frequency shift (<a href="Doppler_shift" title="wikilink">Doppler shift</a>). After compression, the resulting pulses will show some loss in amplitude, a time (range) shift and degradation in sidelobe performance.<a class="footnoteRef" href="#fn97" id="fnref97"><sup>97</sup></a></p>

<p>In a typical radar system, the Doppler frequency is a small fraction of the swept frequency range (i.e. the system bandwidth) of the chirp, so the range errors due to Doppler are found to be minor. For example, for fdTerman F.E., "Electronic and Radio Engineering, 4th Edition", McGraw Hill 1955, p.1033 

<math display="inline" id="Chirp_compression:35">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>t</mi>
     <mtext>shift</mtext>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mfrac>
      <msub>
       <mi>f</mi>
       <mi>d</mi>
      </msub>
      <mi>B</mi>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mi>w</mi>
      <mi>h</mi>
      <mi>e</mi>
      <mi>r</mi>
      <mi>e</mi>
     </mrow>
     <msub>
      <mi>f</mi>
      <mi>d</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>2.</mn>
     <mfrac>
      <msub>
       <mi>V</mi>
       <mi>r</mi>
      </msub>
      <mi>λ</mi>
     </mfrac>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mn>2.</mn>
     <mfrac>
      <mrow>
       <msub>
        <mi>f</mi>
        <mi>m</mi>
       </msub>
       <mo>.</mo>
       <msub>
        <mi>V</mi>
        <mi>r</mi>
       </msub>
      </mrow>
      <mi>c</mi>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <mtext>shift</mtext>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>d</ci>
       </apply>
       <ci>B</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <list>
       <ci>T</ci>
       <apply>
        <times></times>
        <ci>w</ci>
        <ci>h</ci>
        <ci>e</ci>
        <ci>r</ci>
        <ci>e</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>d</ci>
       </apply>
      </list>
      <apply>
       <times></times>
       <cn type="float">2.</cn>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>V</ci>
         <ci>r</ci>
        </apply>
        <ci>λ</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <cn type="float">2.</cn>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">formulae-sequence</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <ci>m</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>V</ci>
          <ci>r</ci>
         </apply>
        </apply>
        <ci>c</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{\text{shift}}=-\frac{f_{d}}{B}.T\quad where\quad f_{d}=2.\frac{V_{r}}{%
\lambda}=2.\frac{f_{m}.V_{r}}{c}
  </annotation>
 </semantics>
</math>

</p>

<p>and where f<sub>d</sub> is the Doppler frequency, B is the frequency sweep of the chirp, T is the duration of the chirp, f<sub>m</sub> is the mid (centre) frequency of the chirp, V<sub>r</sub> is the radial velocity of the target and c is the velocity of light (= 3×10<sup>8</sup> m/s).</p>

<p>Consider as an example, a chirp centered on 10 GHz, with pulse duration of 10μs and a bandwidth of 10 MHz. For a target with an approach velocity of Mach1 <mtpl></mtpl> 300 m/s), the Doppler shift will be about 20 kHz and the time shift of the pulse will be about 20ns. This is roughly one fifth of the compressed pulse beamwidth and corresponds to a range error of about 7½ metres. In addition there is a tiny loss in signal amplitude (approximately 0.02 dB).</p>

<p>Linear chirps with a time-bandwidth product of less than 2000, say, are found to be very tolerant of Doppler frequency shifts, so main pulse width and the time sidelobe levels show little change for Doppler frequencies up to several percent of system bandwidth, In addition, linear chirps which use phase pre-distortion to lower sidelobe levels, as described in an earlier section, are found to be tolerant of Doppler.<a class="footnoteRef" href="#fn98" id="fnref98"><sup>98</sup></a></p>

<p>For very large Doppler values (up to 10% of system bandwidth), time sidelobes are found to increase. In these cases Doppler tolerance can be improved by introducing small frequency extensions onto the spectra of the compressed pulses.<a class="footnoteRef" href="#fn99" id="fnref99"><sup>99</sup></a> The penalty for doing this is, either, an increase in main lobe width, or an increase in bandwidth requirements.</p>

<p>Only when chirp time-bandwidth products are very high, say well over 2000, is it necessary consider a sweep-frequency law other than linear, to cope with Doppler frequency shifts. A Doppler tolerant characteristic is the linear-period (i.e. hyperbolic) modulation of the chirp, and this has been discussed by several authors,<a class="footnoteRef" href="#fn100" id="fnref100"><sup>100</sup></a><a class="footnoteRef" href="#fn101" id="fnref101"><sup>101</sup></a> as was mentioned earlier</p>

<p>If reciprocal-ripple correction has been implemented in order to lower the time-sidelobe levels, then the benefits of the technique diminish as the Doppler frequency is increased. This is because the inverse ripples on the signal spectrum are shifted along in frequency and the reciprocal ripple of the compressor no longer matches those ripples. It is not possible to determine a precise Doppler frequency at which r-r fails because the Fresnell ripples on chirp spectra do not have a single dominant component. However, as a rough guide, r-r correction ceases to be of benefit when</p>

<p>

<math display="inline" id="Chirp_compression:36">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mo>×</mo>
    <mi>T</mi>
    <mo>×</mo>
    <msub>
     <mi>f</mi>
     <mi>d</mi>
    </msub>
   </mrow>
   <mo>≈</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>T</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>d</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\times T\times f_{d}\approx 1
  </annotation>
 </semantics>
</math>

</p>
<h2 id="non-linear-chirps-1">Non-Linear Chirps</h2>

<p>To ensure that a compressed pulse has low time sidelobes, its spectrum should be approximately bell-shaped. With linear chirp pulses this can be achieved by applying a window function either in the time domain or in the frequency domain, i.e. by amplitude modulating the chirp waveforms or by applying weighting to the compressed pulse spectra. In either case there is a mismatch loss of 1½dB, or more.</p>

<p>An alternative way to obtain the required spectral shape is to use a non-linear frequency sweep in the chirp. In this case, to achieve the required spectral shape, the frequency sweep changes very rapidly at band edges and more slowly around band centre. Consider, as an example, the frequency versus time plot that achieves the Blackman-Harris windowing profile. When T×B =100, the spectrum of the compressed pulse and the compressed waveform are as shown.</p>
<figure><b>(Figure)</b>
<figcaption>Non-linear Chirp Characteristic, TB=100, BH   Wgt.png</figcaption>
</figure>
<figure><b>(Figure)</b>
<figcaption>Non-linear Chirp, Spec and Wfm, BT=100, BH Wgt.png</figcaption>
</figure>

<p>The required non-linear characteristic can be derived using the method of stationary phase.<a class="footnoteRef" href="#fn102" id="fnref102"><sup>102</sup></a><a class="footnoteRef" href="#fn103" id="fnref103"><sup>103</sup></a> As this technique does not take account of the Fresnel ripples, these have to be dealt with in additional ways, as was the case with linear chirps.</p>

<p>In order to achieve the required spectral shape for low time sidelobes, linear chirps require amplitude weighting and consequently incur a mismatch loss. Non-linear chirps, however, have the advantage that by achieving the spectral shaping directly, close-in sidelobe levels can be made low with negligible mismatch loss (typically less than 0.1 dB). Another benefit is that the far out sidelobes, due to Fresnel ripples on the spectrum, tend to be lower than for a linear chirp with the same T×B product (4 to 5 dB lower with large T×B).</p>

<p>However, for chirps where the T×B product is low, the far-out sidelobe levels of the compressed pulse can still be disappointingly high, because of high amplitude Fresnel ripples on the spectrum. As with linear chirps, results can be improved by means of reciprocal ripple correction but, as previously, truncation of the compression waveform results in the appearance of gating sidelobes.</p>

<p>An example of reciprocal ripple and truncation is shown below. The left hand figure shows the spectrum of a non-linear chirp, with a time bandwidth product of 40, aiming to have a Blackman-Harris profile. The right-hand figure shows the compressed pulse for this spectrum,</p>
<figure><b>(Figure)</b>
<figcaption>Non-linear Chirp, B-H profile, TB=40,.png</figcaption>
</figure>

<p>The next figures shows the spectrum after r-r compensation, but with truncation of the compression waveform to 1.1T, and the final compressed waveform.</p>
<figure><b>(Figure)</b>
<figcaption>Non-linear Chirp, B-H wgt, TB=40, RR correction.png</figcaption>
</figure>
<h3 id="doppler-tolerance-of-non-linear-chirps">Doppler Tolerance of Non-Linear Chirps</h3>

<p>A major disadvantage of non-linear chirps is their sensitivity to Doppler frequency shifts. Even modest values of Doppler will result in broadening of the main pulse, raising of the sidelobe levels, increase in mismatch loss and the appearance of new spurious sidelobes.</p>

<p>An example of a non-linear chirp pulse and the effects of Doppler are shown The non-linear characteristic is chosen to achieve -50 dB sidelobes using Taylor weighting. The first figure shows the compressed pulse for a non-linear chirp, with bandwidth 10 MHz, pulse duration 10usec, so T×B = 100, and with no Doppler shift. The next two figures shows the pulse degradation cause by 10 kHz and 100 kHz Doppler, respectively. In addition to the waveform degradation, the mismatch loss increases to 0.5 dB. The final figure shows the effect of 100 kHz Doppler on a linear chirp which has had amplitude weighting applied to give the same spectral shape as that of the non-linear chirp. The greater tolerance to Doppler is clearly seen.</p>
<figure><b>(Figure)</b>
<figcaption>Non-linear Chirp, Taylor, TB=100, Doppler=0,10.png</figcaption>
</figure>
<figure><b>(Figure)</b>
<figcaption>Non-linear + Linear Chirp, Taylor, TB=100, Doppler=100.png</figcaption>
</figure>

<p>Cook,<a class="footnoteRef" href="#fn104" id="fnref104"><sup>104</sup></a> using paired-echo distortion methods,<a class="footnoteRef" href="#fn105" id="fnref105"><sup>105</sup></a> estimated that in order to keep sidelobe levels below -30 dB, the maximum allowed Doppler frequency is given by 

<math display="inline" id="Chirp_compression:37">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mi>d</mi>
   </msub>
   <mo>≤</mo>
   <mfrac>
    <mn>0.06</mn>
    <mi>T</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>d</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="float">0.06</cn>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{d}\leq\frac{0.06}{T}
  </annotation>
 </semantics>
</math>

</p>

<p>so, for a 10μs pulse, the maximum Doppler frequency that can be tolerated is 6 kHz. However, more recent work suggests that this is unduly pessimistic.<a class="footnoteRef" href="#fn106" id="fnref106"><sup>106</sup></a> In addition, as the new sidelobes, when at a low level, are very narrow. Consequently, it may be possible to ignore them initially, as they may not be resolvable by the receiver’s D to A.</p>
<h3 id="using-a-combination-of-non-linear-and-linear-characteristics-to-improve-doppler-tolerance">Using a combination of non-linear and linear characteristics to improve Doppler tolerance</h3>

<p>A way of reducing the susceptibility of non-linear chirps to Doppler is to use a ‘hybrid’ scheme, where part of the spectral shaping is achieved by a non-linear sweep, but with additional spectral shaping achieved by amplitude weighting.<a class="footnoteRef" href="#fn107" id="fnref107"><sup>107</sup></a><a class="footnoteRef" href="#fn108" id="fnref108"><sup>108</sup></a> Such a scheme will have greater mismatch loss than a true non-linear scheme, so the advantage of greater Doppler tolerance has to be weighed against the disadvantage of the increased mismatch loss.</p>

<p>In the two examples below, the chirps have a non-linear sweep characteristic which gives a spectrum with Taylor weighting which, used alone, will achieve a sidelobe level of -20 dB on its compressed pulses. To achieve lower level sidelobes, this spectral shape is augmented by amplitude weighting so that the final target sidelobe level for the compressed pulses is -50 dB. Comparing the results for Doppler shifts of 10 kHz and 100 kHz with those shown earlier it is seen that the new spurious sidelobes, caused by the Doppler, are seen to be 6 dB lower than before. However, the mismatch loss has increased from 0.1 dB to 0.6 dB, but this is still better than the 1.6 dB figure for linear chirps.</p>
<figure><b>(Figure)</b>
<figcaption>Hybrid Chirp, Taylor, TB=100, Doppler=10,100.png</figcaption>
</figure>
<h2 id="signal-to-noise-improvements-by-pulse-compression">Signal to Noise Improvements by Pulse Compression</h2>

<p>The amplitude of random noise is not changed by the compression process, so the signal to noise ratios of received chirp signals are increased in the process. In the case of a high power search radars, this extends the range performance of the system, while for stealth systems the property will permit lower transmitter powers to be used.</p>

<p>As an illustration, a possible received noise sequence is shown, which contains a low amplitude chirp signal obscured within it. After processing by the compressor, the compressed pulse is clearly visible above the noise floor.</p>
<figure><b>(Figure)</b>
<figcaption>Noise Sequence with Embedded Chirp Pulse.png</figcaption>
</figure>
<figure><b>(Figure)</b>
<figcaption>Noise with Embedded Chirp Pulse, after Compression.png</figcaption>
</figure>

<p>When pulse compression is carried out in digital signal processing, after the incoming signals are digitised by A/D converters, it is important that level of the noise floor is correctly set. The noise floor at the A/D must be high enough to ensure that the noise is adequately characterised. If the noise level is too low, <a class="uri" href="Nyquist" title="wikilink">Nyquist</a> will not be satisfied, and any embedded chirp will not be recovered correctly. On the other hand, setting the noise level unnecessarily high will reduce the dynamic range capability of the system.<br/>
For systems using digital processing, it is important to carry out the chirp compression in the digital domain, after the A/D converters. If the compression process is carried out in the analogue domain before digitization (by a SAW filter, for example), the resulting high-amplitude pulses will place excessive demands on the dynamic range of the A/D converters.<a class="footnoteRef" href="#fn109" id="fnref109"><sup>109</sup></a></p>
<h2 id="pre-correction-of-system-characteristics">Pre-Correction of System Characteristics</h2>

<p>The transmitter and receiver subsystems of a radar are not distortion free. In consequence system performance is often less than optimum. In particular, the time sidelobe levels of the compressed pulses are found to be disappointingly high.</p>

<p>Some of the characteristics which degrade performance are:-<br/>
Gain slope, or non-linear phase slope, across the system passband.<br/>
Amplitude and phase ripple ripple across the passband (which may be caused by mismatches on interconnecting cables<a class="footnoteRef" href="#fn110" id="fnref110"><sup>110</sup></a> as well as by imperfections in amplifiers).<br/>
Delay modulation by the transmitter (if power supply regulation is poor).</p>

<p>In addition, filters employed in the frequency conversion processes of the transmitter and receiver all contribute to gain and phase variations across the system passband, especially near to band edges. In particular, major contributors to overall non-linear phase characteristics are the low-pass filters preceding the A/D converters, which are usually sharp-cut filters chosen to ensure maximum bandwidth while minimizing aliased noise. The transient response characteristics of these filters contribute another (unwanted) source of time sidelobes.</p>

<p>Fortunately it is possible to compensate for several system properties, provided they are stable and can be characterized adequately when a system is first assembled. This is not difficult to implement in radars using digital look-up tables, since these tables can be easily amended to include compensation data. Phase pre-corrections can be included in the expander tables and phase and amplitude corrections can be included in the compressor tables, as required.</p>

<p>So, for example, the earlier equation, defining the compressor characteristic to minimize spectral ripple, could be expanded to include additional terms to correct for known amplitude and phase impairments, thus:</p>

<p>

<math display="inline" id="Chirp_compression:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msup>
      <mi>C</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>ω</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mi mathvariant="normal">Φ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ω</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>.</mo>
     <mrow>
      <mi>A</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ω</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>.</mo>
     <mrow>
      <mi>H</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ω</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <ci>ω</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>C</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>ω</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <times></times>
       <ci>normal-Φ</ci>
       <ci>ω</ci>
      </apply>
      <apply>
       <times></times>
       <ci>A</ci>
       <ci>ω</ci>
      </apply>
      <apply>
       <times></times>
       <ci>H</ci>
       <ci>ω</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K(\omega)=\frac{C^{\prime}(\omega)}{\Phi(\omega).A(\omega).H(\omega)}
  </annotation>
 </semantics>
</math>

</p>

<p>where, as before, H(<mtpl></mtpl>) is the initial chirp spectrum and C'(<mtpl></mtpl>) is the target spectrum, such as a Taylor window, but now additional terms have been included, namely, <mtpl></mtpl>((<mtpl></mtpl>) ) and A(<mtpl></mtpl>) which are the phase and amplitude characteristics that require compensation.</p>

<p>A compressor chirp waveform that includes phase correction data will have additional ripple components present at each end of the waveform (pre-shoots and after-shoots). Any truncation procedure should not remove these new features.</p>

<p>In addition, it is easy to time shift the compressed pulses by ±t<sub>0</sub>, by multiplying the compressor spectrum by the unity amplitude vector, i.e.<br/>


<math display="inline" id="Chirp_compression:39">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mi>o</mi>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ω</mi>
    <mo>.</mo>
    <msub>
     <mi>t</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>±</mo>
   <mi>j</mi>
   <mo>.</mo>
   <mi>s</mi>
   <mi>i</mi>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ω</mi>
    <mo>.</mo>
    <msub>
     <mi>t</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>e</mi>
   <mi>x</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>±</mo>
    <mi>j</mi>
    <mi>ω</mi>
    <mo>.</mo>
    <msub>
     <mi>t</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">c</csymbol>
    <csymbol cd="unknown">o</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ω</csymbol>
     <ci>normal-.</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="latexml">plus-or-minus</csymbol>
    <csymbol cd="unknown">j</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">s</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ω</csymbol>
     <ci>normal-.</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <ci></ci>
    <eq></eq>
    <ci></ci>
    <csymbol cd="unknown">e</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">plus-or-minus</csymbol>
     <csymbol cd="unknown">j</csymbol>
     <csymbol cd="unknown">ω</csymbol>
     <ci>normal-.</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   cos(\omega.t_{0})\pm j.sin(\omega.t_{0})\quad=\quad exp(\pm j\omega.t_{0})
  </annotation>
 </semantics>
</math>

.</p>

<p>Time shift can be useful to position the main lobes of compressed pulses at a standard location, regardless of chirp pulse length. However, care has to be taken with the overlap and save or overlap and discard algorithm, should time shift be used, to ensure only valid waveform sequences are retained.</p>

<p>There has been a growth in interest in adaptive filters for pulse compression, made possible by the availability of small fast computers, and some relevant articles are mentioned in the next section. These techniques will also compensate for hardware deficiencies, as part of their optimization procedure<a class="footnoteRef" href="#fn111" id="fnref111"><sup>111</sup></a></p>
<h2 id="more-recent-work-on-chirp-compression-techniques---some-examples">More recent work on chirp compression techniques - some examples</h2>

<p>The growth in digital processing and methods had a significant influence in the field of chirp pulse compression. An introduction to these techniques is provided in a chapter of the Radar Handbook (3rd ed.), edited by Skolnik.<a class="footnoteRef" href="#fn112" id="fnref112"><sup>112</sup></a></p>

<p>The main aims of most investigations into pulse compression has been to to obtain narrow main lobes, with low sidelobe levels, a tolerance to Doppler frequency shifts and to incur low system losses. The availability of computers has led to a growth in numerical processing and much interest in adaptive networks and optimization methods, to achieve these aims. For example, see the comparison of the various techniques made by Damtie and Lehtinen<a class="footnoteRef" href="#fn113" id="fnref113"><sup>113</sup></a> and, also, various articles by Blunt and Gerlach on these topics.<a class="footnoteRef" href="#fn114" id="fnref114"><sup>114</sup></a><a class="footnoteRef" href="#fn115" id="fnref115"><sup>115</sup></a><a class="footnoteRef" href="#fn116" id="fnref116"><sup>116</sup></a><a class="footnoteRef" href="#fn117" id="fnref117"><sup>117</sup></a> A number of other contributors in the filed has included Zrnic et al<a class="footnoteRef" href="#fn118" id="fnref118"><sup>118</sup></a> Li et al<a class="footnoteRef" href="#fn119" id="fnref119"><sup>119</sup></a> and Scholnik.<a class="footnoteRef" href="#fn120" id="fnref120"><sup>120</sup></a></p>

<p>A number of other works, with a variety of approaches to pulse compression, are listed below.<br/>
New methods of generating non linear chirp waveforms and of improving their Doppler tolerance has been investigated by Doerry<a class="footnoteRef" href="#fn121" id="fnref121"><sup>121</sup></a><a class="footnoteRef" href="#fn122" id="fnref122"><sup>122</sup></a><br/>
Further studies of Hyperbolic chirps have been carried out by Kiss,<a class="footnoteRef" href="#fn123" id="fnref123"><sup>123</sup></a> Readhead,<a class="footnoteRef" href="#fn124" id="fnref124"><sup>124</sup></a> Nagajyothi and Rajarajeswari<a class="footnoteRef" href="#fn125" id="fnref125"><sup>125</sup></a> and Yang and Sarkar.<a class="footnoteRef" href="#fn126" id="fnref126"><sup>126</sup></a><br/>
Convolution windows have been investigated by Sahoo and Panda who show that they can result in very low sidelobes yet be Doppler tolerant, but may suffer from some pulse broadening.<a class="footnoteRef" href="#fn127" id="fnref127"><sup>127</sup></a> Wen and his co-workers have also discussed convolution windows.<a class="footnoteRef" href="#fn128" id="fnref128"><sup>128</sup></a><a class="footnoteRef" href="#fn129" id="fnref129"><sup>129</sup></a><br/>
Some new window functions have been proposed by Samad<a class="footnoteRef" href="#fn130" id="fnref130"><sup>130</sup></a> and Sinha and Ferreira,<a class="footnoteRef" href="#fn131" id="fnref131"><sup>131</sup></a> which claim improved performance over the familiar functions.<br/>
Several techniques to lower the sidelobe levels of the compressed pulses for non-linear FM chirps are compared by Varshney and Thomas.<a class="footnoteRef" href="#fn132" id="fnref132"><sup>132</sup></a><br/>
In a paper by Vizitui,<a class="footnoteRef" href="#fn133" id="fnref133"><sup>133</sup></a> sidelobe reduction is considered where phase pre-distortion is applied to non-linear FM chirps, rather than to linear chirps. Lower sidelobes and some improvement in Doppler tolerance is claimed. There have been extensive investigations of <a href="phase_modulation" title="wikilink">phase modulation</a> for pulse compression schemes, such as biphase (binary <a href="Phase_shift_keying" title="wikilink">Phase shift keying</a>) and <a href="polyphase_matrix" title="wikilink">polyphase</a> coding methods, but this work is not considered here.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Chirp" title="wikilink">Chirp</a></li>
<li><a href="Chirp_spectrum" title="wikilink">Chirp spectrum</a></li>
<li><a href="Pulse_compression" title="wikilink">Pulse compression</a></li>
<li><a href="Spread_spectrum" title="wikilink">Spread spectrum</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Signal_processing" title="wikilink">Category:Signal processing</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Dicke R.H.,"Object Detection System", U.S. Patent 2,624,876, submitted Sept. 1945<a href="#fnref1">↩</a></li>
<li id="fn2">Darlington S.,"Pulse Transmission", U.S. Patent 2,678,997, submitted Sept. 1945<a href="#fnref2">↩</a></li>
<li id="fn3">Sproule D.O. and Hughes A.J., "Improvements in and Relating to System Operation by Means of Wave Trains", U.K. Patent 604,429, submitted June 1945<a href="#fnref3">↩</a></li>
<li id="fn4">Klauder J.R., Price A.C., Darlington S. and Albersheim W.J., "The Theory and Design of Chirp Radars", BSTJ Vol.39, July 1960, (pp.745-808)<a href="#fnref4">↩</a></li>
<li id="fn5">Barton D.K. (ed), "Radars, Volume 3, Pulse Compresion", Artech House 1975, 1978<a href="#fnref5">↩</a></li>
<li id="fn6">Bernfeld M., Cook C.E., Paolillo J., and Palmieri C.A., "Matched Filtering, Pulse Compression and Waveform Design", Microwave Journal, Oct 1964 - Jan 1965, (34 pp.)<a href="#fnref6">↩</a></li>
<li id="fn7">Farnett E.C. &amp; Stevens G.H., "Pulse Compression Radar", Chapter 10 of "Radar Handbook, 2nd Ed.", ed Skolnik M., McGraw Hill 1990<a href="#fnref7">↩</a></li>
<li id="fn8">Millett R.E., "A Matched-Filter Pulse-Compression System Using a Non-linear F.M. Waveform", IEEE Trans. Aerospace and Electronic Systems, Vol. AES-6, No. 1, Jan 1970, (pp. 73-78)<a href="#fnref8">↩</a></li>
<li id="fn9">Cook C.E., "Pulse Compression - Key to More Efficient Radar Transmission", Proc. IRE, Vol.48, March 1960 (pp. 310-316)<a href="#fnref9">↩</a></li>
<li id="fn10">Jones W.S., Kempf R.A. and Hartman C.S., "Practical Surface Wave Chirp Filters for Modern Radar Systems", Microwave Journal, May 1972 (pp. 43-50<a href="#fnref10">↩</a></li>
<li id="fn11">Butler M.B. "Radar applications of s.a.w. dispersive filters", Proc IEE, Vol.27, Pt. F, April 1980 (pp.118-124)<a href="#fnref11">↩</a></li>
<li id="fn12">Arthur J.W., Modern SAW-based pulse compression systems for radar applications. Part 1: SAW matched filters, Part 2: Practical systems", Electronics &amp; Communication Engineering Journal, Dec 1995 (pp.236-246) and April 1996 (pp.57-79)<a href="#fnref12">↩</a></li>
<li id="fn13">Andersen Laboratories, " Handbook of Acoustic Signal Processing, Vols. 2 &amp; 3, SAW Filters and Pulse Expansion/Compression IF Subsystems for Radar"<a href="#fnref13">↩</a></li>
<li id="fn14">MESL Microwave, "SAW Pulse Compression" (technical brochure), www.meslmicrowave/saw-pulse-compression/technical-notes/<a href="#fnref14">↩</a></li>
<li id="fn15">Halpern H.M. and Perry R.P., "Digital Matched Filters Using Fast Fourier Transforms", IEEE EASTCON '71 Record, (pp.222-230)<a href="#fnref15">↩</a></li>
<li id="fn16">Arthur J.W., "Digital Waveform Generation for SAW Compression Systems", Tech. Note, Racal MESL, Newbridge, Midlothian<a href="#fnref16">↩</a></li>
<li id="fn17">Alter J.J. and Coleman J.O., "Digital Signal Processing", Chapter 25 of "Radar Handbook, 3rd edition" ed. Skolnik M.I., McGraw Hill 2008<a href="#fnref17">↩</a></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23">Harris F.J., "On the Use of Windows for Harmonic Analysis qith the Discrete Fourier Transform", Proc. IEEE, Vol.66, Jan 1978, (pp.174-204)<a href="#fnref23">↩</a></li>
<li id="fn24">Thor R.C., "A large Time-Bandwidth Product Pulse Compression Technique", Trans IRE MIL-6, No.2, April 1962, (pp.169-173)<a href="#fnref24">↩</a></li>
<li id="fn25">Kroszczynski J.J., "Pulse Compression by Means of Linear-Period Modulation", Proc. IEEE, Vol. 57, No.7, July 1969, (pp.1260-1266)<a href="#fnref25">↩</a></li>
<li id="fn26"></li>
<li id="fn27">Kowatsch M. and Stocker H.R., "Effect of Fresnel ripples on sidelobe supression in low time-bandwidth product linear FM", IEE Proc. Vol, 129, Pf.F, No.1, Feb 1982, (pp.41-44)<a href="#fnref27">↩</a></li>
<li id="fn28">Butler M.B.,"Radar applications of s.a.w. dispersive filters", Proc. IEE, Vol. 27, Pt. F, April 1980<a href="#fnref28">↩</a></li>
<li id="fn29">Judd G.W., "Technique for Realising Low Time Sidelobe Levels in Small Compression Ratio Chirp Waveforms", Proc. IEEE Ultrasonics Symposium, 1973, (pp.478-483)<a href="#fnref29">↩</a></li>
<li id="fn30">Cook C.E. and Bernfeld M, "Radar Signals, An Introduction to Theory and Application"; Academic Press 1967, 1987; Artech House 1993<a href="#fnref30">↩</a></li>
<li id="fn31"></li>
<li id="fn32">Key E.L., Fowle E.N., Haggarty R.D.., "A Method of Designing Signals of Large Time-Bandwidth Product", Proc. IRE Int. Conf. Rec. Pt.4, Mar 1961 (pp.146-154)<a href="#fnref32">↩</a></li>
<li id="fn33"></li>
<li id="fn34">Fowle E.N., "The design of FM pulse-compression signals", IEEE Trans. IT-10, 1964, (pp. 61-67)<a href="#fnref34">↩</a></li>
<li id="fn35"></li>
<li id="fn36"></li>
<li id="fn37"></li>
<li id="fn38">Abel J.S. and Smith J.O., "Robust Design of Very High Order All-pass Dispersion Filters", Proc. 9th Int. Conf. on Digital Audio Effects (DAFx-06), Montreal Canada, Sept 2006<a href="#fnref38">↩</a></li>
<li id="fn39">Farnett E.C. and Stevens G.H., "Pulse Compression Radar", Chapter 10 of "Radar Handbook 2nd Ed.", ed Skolnik M., McGraw Hill 1990<a href="#fnref39">↩</a></li>
<li id="fn40">Brandon P.S., "The Design Methods for Lumped-Constant Dispersive Networks Suitable for Pulse Compression Radar", Marconi Review, Vol. 28, No. 159, 4th qtr. 1965, (pp. 225-253)<a href="#fnref40">↩</a></li>
<li id="fn41">Steward K.W.F., "A Practical Dispersive Network System", Marconi Review, Vol. 28, No. 159, 4th qtr. 1965, (pp. 254-272)<a href="#fnref41">↩</a></li>
<li id="fn42">Barton D.K. Modern Radar System Analysis", Artech House 1988, (pp.220-231)<a href="#fnref42">↩</a></li>
<li id="fn43"></li>
<li id="fn44"></li>
<li id="fn45">Mortley W.S., "A Pulse Compression System for Radar, Part 2: Practical Realization", Industrial Electronics, Nov. 1965, (pp. 518-520)<a href="#fnref45">↩</a></li>
<li id="fn46"></li>
<li id="fn47">Jones W.S., Kempf R.A. and Hartman C.S., "Practical Surface Wave Chirp Filters for Modern Radar Systems", Microwave Journal, May 1972<a href="#fnref47">↩</a></li>
<li id="fn48">Newton C.O., "Nonlinear Chirp Radar Signal Waveforms for Surface Acoustic Wave Pulse Compression Filters", Wave Electronics, No. 1, 1974/6, (pp. 387-401)<a href="#fnref48">↩</a></li>
<li id="fn49">Arthur J.W., "Modern SAW-based pulse compression systems for radar applications. Part 1:SAW matched filters", Electronics &amp; Communication Engineering Journal, Dec. 1995, (PP.236-246)<a href="#fnref49">↩</a></li>
<li id="fn50"></li>
<li id="fn51"></li>
<li id="fn52"></li>
<li id="fn53">Oppenheim A.V. and Schaffer R.W., "Digital Signal Processing", Prentice Hall 1975, (pp.113-115)<a href="#fnref53">↩</a></li>
<li id="fn54">Harris F.J., "Convolution, Correlation and Narrowband Filtering with the Fast Fourier Transform", San Diago State Univ., CA,(sponsored paper Int. Def. Elec. Assoc.)<a href="#fnref54">↩</a></li>
<li id="fn55">Smith S.W., "Digital Signal Processing", Newnes 2003,(p.311)<a href="#fnref55">↩</a></li>
<li id="fn56">Rihaczek A.W., "Principles of High-Resolution Radar", McGraw Hill 1969, Artech House 1996<a href="#fnref56">↩</a></li>
<li id="fn57">Mahafza B.R. "Radar sytem Analysis and Design using MATLAB", Chapman &amp; Hall/CRC, 2000<a href="#fnref57">↩</a></li>
<li id="fn58">Woodward P.M., "Probability and information theory with applications to radar", Pergamon Press 1953, 1964<a href="#fnref58">↩</a></li>
<li id="fn59"></li>
<li id="fn60">Wheeler H.A., "The Interpretation of Amplitude and Phase Distortion in Terms of Paired Echoes", Proc. IRE, June 1939, (pp. 359-385)<a href="#fnref60">↩</a></li>
<li id="fn61">Billam E.R., "Eclipsing Effects with High Duty Factor Waveforms in Long Range Radar", IEEE International Radar Conference 1985<a href="#fnref61">↩</a></li>
<li id="fn62"></li>
<li id="fn63">Chin J.E. and Cook C.E., "The Mathematics of Pulse compression", Sperry Engineering Review, Vol. 12, Oct. 1959, (pp.11-16<a href="#fnref63">↩</a></li>
<li id="fn64">Campbell G.A. and Foster R.M. “Fourier Integrals for Practical Applications”, van Nostrand 1948, number 708.0. Also in BSTJ Oct. 1928, (pp. 639-707)<a href="#fnref64">↩</a></li>
<li id="fn65">Taylor T.T., "Design of Line-Source Antennas for narrow Beamwidth and Low Side Lobes", IRE Trans., Antennas and Prop., Jan 1955, (pp.169-173)<a href="#fnref65">↩</a></li>
<li id="fn66"></li>
<li id="fn67"></li>
<li id="fn68"></li>
<li id="fn69">Cook C.E., Bernfeld M. and Palmieri C.A., "Matched Filtering, Pulse Compression and Waveform Design", Microwave Journal Jan 1965<a href="#fnref69">↩</a></li>
<li id="fn70">Kowatsch M., Stocker H.R., Seifert F.J. and Lafferl J., "Time Sidelobe Performance of Low Time-Bandwidth Product Linear FM Pulse Compression System", IEEE Trans. on Sonics and ultrasonics, Vol SU-28, No. 4, July 1981, (pp.285-288)<a href="#fnref70">↩</a></li>
<li id="fn71">Vincent N., "Rain Radar (Final Presentation) - Introduction", Alcatel Espace, Nordwijk Nov. 1995<a href="#fnref71">↩</a></li>
<li id="fn72">Li L., Coon M. and McLinden M., "Radar Range Sidelobe Reduction Using Adaptive Pulse Compression Techniques", NASA Tech Brief GSC-16458-1, October 2013<a href="#fnref72">↩</a></li>
<li id="fn73">McCue J.J.G., "A Note on the Hamming Weighting of Linear-FM Pulses", Proc. IEEE, Vol. 67, No. 11, Nov 1949<a href="#fnref73">↩</a></li>
<li id="fn74">Cook C.E. and Paolillo J., "A Pulse Compression Predistortion Function for Efficient Sidelobe Reduction in a High-Power Radar", Proc. IEEE, Vol. 52, April 1964, (pp. 377-389)<a href="#fnref74">↩</a></li>
<li id="fn75"></li>
<li id="fn76"></li>
<li id="fn77"></li>
<li id="fn78">Cook C.E. And Paolillo J., “A Pulse Compression Predistortion Function for Efficient Sidelobe Reduction in a High Power Radar”, Proc. IEEE, Vol. 52, April 1964, (pp. 377-389)<a href="#fnref78">↩</a></li>
<li id="fn79">Vincent N., "Rain Radar (Final Presentation) - Selected Concept and overall design", Alcatel Espace, Nordwijk Nov. 1995<a href="#fnref79">↩</a></li>
<li id="fn80">Solal M., "High Performance SAW Delay Lines for Low Time Bandwidth Using Periodically Sampled Transducers", IEEE Ultrasonics Symposium (Chicago), Nov. 1988<a href="#fnref80">↩</a></li>
<li id="fn81"></li>
<li id="fn82"></li>
<li id="fn83"></li>
<li id="fn84"></li>
<li id="fn85"></li>
<li id="fn86"></li>
<li id="fn87"></li>
<li id="fn88"></li>
<li id="fn89"></li>
<li id="fn90"></li>
<li id="fn91"></li>
<li id="fn92"></li>
<li id="fn93">Racal-MESL Brochure, "Pulse Compression", Technical Brochure TP510, 1990<a href="#fnref93">↩</a></li>
<li id="fn94"></li>
<li id="fn95"></li>
<li id="fn96"></li>
<li id="fn97"></li>
<li id="fn98"></li>
<li id="fn99"></li>
<li id="fn100"></li>
<li id="fn101"></li>
<li id="fn102"></li>
<li id="fn103">Fowle E.N., "The design of FM pulse-compression signals", IEEE Trans. IT-10, 1964, (pp. 61-64)<a href="#fnref103">↩</a></li>
<li id="fn104"></li>
<li id="fn105">Wheeler H.A., "The Interpretation of Amplitude and Phase Distortion in Terms of Paired Echoes", Proc. IRE, June 1939, (pp.359-385)<a href="#fnref105">↩</a></li>
<li id="fn106"></li>
<li id="fn107"></li>
<li id="fn108"></li>
<li id="fn109"></li>
<li id="fn110">Reed J., Long Line Effect in Pulse Compression Radar", Microwave Journal, September 1961, (pp.99-100)<a href="#fnref110">↩</a></li>
<li id="fn111">Scholnik D., "Optimal Filters for Range-Time Sidelobe Suppression" Naval Research Lab., Washington, DC<a href="#fnref111">↩</a></li>
<li id="fn112"></li>
<li id="fn113">Damtie B. and Lehtinen M.S., "Comparison of the performance of different radar pulse compression techniques in an incoherent scatter radar measurement", Ann. Geophys., Vol. 27, 2009,(pp.797-806)<a href="#fnref113">↩</a></li>
<li id="fn114">Blunt S.D. and Gerlach G., "A Novel Pulse Compression Scheme Based on Minimum Mean-Square Error Reiteration", IEEE RADAR 2003, Australia 2003, (pp.349-353)<a href="#fnref114">↩</a></li>
<li id="fn115">Blunt S.D. and Gerlach G., "Adaptive Pulse Compression via MMSE Estimation", IEEE Trans. Aerospace and Electronic Systems, Vol. 42, No. 2, April 2006, (pp. 572-583<a href="#fnref115">↩</a></li>
<li id="fn116">Blunt S.D. and Gerlach G.,"Adaptive Radar Pulse Compression", NRL Review 2005, Simulation Computing and Modelling, 2005, (pp.215-217<a href="#fnref116">↩</a></li>
<li id="fn117">Blunt S.D., Smith K.J. and Gerlach G., "Doppler-Compensated Adaptive Pulse Compression", IEEE Trans., 2006, (pp. 114-119)<a href="#fnref117">↩</a></li>
<li id="fn118">Zrnic B., Zejak A., Petrovic A. and Simic I., "Range sidelobe suppression for pulse compression radars utilizing modified RLS algorithm", IEEE 5th Int. Symp. Spread Spectrum Techniques and Applications, 1998, (pp.1008-1011)<a href="#fnref118">↩</a></li>
<li id="fn119"></li>
<li id="fn120"></li>
<li id="fn121">Doerry A.W., "Generating Nonlinear FM Chirp Waveforms for Radar", Sandia Report SAND2006-5856, Sandia National Laboratories, Sept. 2006, (pp.34)<a href="#fnref121">↩</a></li>
<li id="fn122">Doerry A.W.., "Generating Nonlinear FM Chirp Radar Signals by Multiple Integrations", U.S. Patent 7,880,672 B1, Feb 2011, (pp.11)<a href="#fnref122">↩</a></li>
<li id="fn123">Kiss C.J., "Hyperbolic-FM (Chype)", US Army Missile Res., Dev. &amp; Eng. Lab., Alabama 35809, Report No. RE-73-32, 1972<a href="#fnref123">↩</a></li>
<li id="fn124">Readhead M., "Calculations of the Sound Scattering of Hyperbolic Frequency Modulated Chirp Pulses from Sonar Targets", www.dsto.defence.gov.au/corporate/reports/DSTO-RR-0351.pdf Feb 2010 (pp.43)<a href="#fnref124">↩</a></li>
<li id="fn125">Nagajyothi A. and Rajarajeswari K., "Delay-Doppler Performance of Hyperbolic Frequency Modulation Waveforms", Intl. Jour. Electrial, Electronics and Data Communications, Issn: 2320-2084, vol. 1, Iss-9, Nov 2013<a href="#fnref125">↩</a></li>
<li id="fn126">Yang J. and Sarkar T.K., "Acceleration-invariance of hyperbolic frequency modulated pulse compression", www.sciencedirect.com<a href="#fnref126">↩</a></li>
<li id="fn127">Sahoo A.K. and Panda G., "Doppler Tolerant Convolution Windows for Radar Pulse Compression", Int. Jour.Electronics and Communication Engineering, ISSN 0974-2166, Vol. 4, No. 1, "011, (pp.145-152)<a href="#fnref127">↩</a></li>
<li id="fn128">Wen H., Teng Z.S., Gao S.Y., Wang J.X., Yng B.M., ang Y. and Chen T., "Hanning self-convolution window and its application to harmonic analysis", Science in China, Series E: Technological Sciences 2009, (pp.10)<a href="#fnref128">↩</a></li>
<li id="fn129">Wen H., Teng Z. and Gao S., "Triangular Self-Convolution Window with Desirable Sidelobe Behaviours for Harmonic Analysis of Power System", IEEE Trans. Instr. and Measurement, Vol59, No.3, March 2010, (pp.10)<a href="#fnref129">↩</a></li>
<li id="fn130">Samad M.A., "A Novel Window Function Yielding Suppressed Mainlobe Width and Minimum Sidelobe Peak", Int. Jour. Computer Science, Engineering and Information Technology (IJCSEIT), Vol. 2, No. 2, April 2012<a href="#fnref130">↩</a></li>
<li id="fn131">Sinha D. and Ferreira A.J.S., "A New Class of smooth Power Complementary Windows and their Application to Audio Signal Processing", Audio Eng. Soc. Conv. Paper, 119th Convention, Oct 2005, www.atc-labs.com/technology/misc/windows/docs/aes119_218_ds.pdf<a href="#fnref131">↩</a></li>
<li id="fn132">Varshney L.R. and Thomas D., "Sidelobe Reduction for Matched Filter Range Processing", IEEE Radar Conference 2003, (pp.7)<a href="#fnref132">↩</a></li>
<li id="fn133">Vizitui J.C., "Some Aspects of Sidelobe reduction in Pulse Compression Theory, using NLFM Signal Processing", Progress in Electronics Research, C, Vol. 47, 2014, (pp. 119-129)<a href="#fnref133">↩</a></li>
</ol>
</section>
</body>
</html>
