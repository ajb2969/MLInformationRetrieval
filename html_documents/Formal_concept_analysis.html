<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1975">Formal concept analysis</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Formal concept analysis</h1>
<hr/>

<p>In <a href="information_science" title="wikilink">information science</a>, <strong>formal concept analysis</strong> is a <a href="Principle" title="wikilink">principled way</a> of deriving a <em>concept hierarchy</em> or formal <a href="Ontology_(computer_science)" title="wikilink">ontology</a> from a collection of <a href="Mathematical_object" title="wikilink">objects</a> and their <a href="Property_(philosophy)" title="wikilink">properties</a>. Each concept in the hierarchy represents the set of objects sharing the same values for a certain set of properties; and each sub-concept in the hierarchy contains a <a class="uri" href="subset" title="wikilink">subset</a> of the objects in the concepts above it. The term was introduced by <a href="Rudolf_Wille" title="wikilink">Rudolf Wille</a> in 1984, and builds on applied <a href="lattice_theory" title="wikilink">lattice</a> and <a href="order_theory" title="wikilink">order theory</a> that was developed by <a href="Garrett_Birkhoff" title="wikilink">Garrett Birkhoff</a> and others in the 1930s.</p>

<p>Formal concept analysis finds practical application in fields including <a href="data_mining" title="wikilink">data mining</a>, <a href="text_mining" title="wikilink">text mining</a>, <a href="machine_learning" title="wikilink">machine learning</a>, <a href="knowledge_management" title="wikilink">knowledge management</a>, <a href="semantic_web" title="wikilink">semantic web</a>, <a href="software_development" title="wikilink">software development</a>, <a class="uri" href="chemistry" title="wikilink">chemistry</a> and <a class="uri" href="biology" title="wikilink">biology</a>.</p>
<h2 id="overview-and-history">Overview and history</h2>

<p>The original motivation of formal concept analysis was the concrete representation of complete <a href="Lattice_(order)" title="wikilink">lattices</a> and their properties by means of <em>formal contexts</em>, data tables that represent binary <a href="Relation_(mathematics)" title="wikilink">relations</a> between objects and attributes. In this theory, a formal concept is defined to be a pair consisting of a set of objects (the "extent") and a set of attributes (the "intent") such that the extent consists of all objects that share the given attributes, and the intent consists of all attributes shared by the given objects. In this way, formal concept analysis formalizes the notions of <a href="Extension_(semantics)" title="wikilink">extension</a> and <a class="uri" href="intension" title="wikilink">intension</a>.</p>

<p>Pairs of formal concepts may be <a href="partially_ordered_set" title="wikilink">partially ordered</a> by the subset relation between their sets of objects, or equivalently by the superset relation between their sets of attributes. This ordering results in a graded system of sub- and superconcepts, a <em>concept hierarchy</em>, which can be displayed as a <a href="Hasse_diagram" title="wikilink">line diagram</a>. The family of these concepts obeys the mathematical axioms defining a lattice, and is called more formally a <em>concept lattice</em>. In French this is called a <em>treillis de Galois</em> (Galois lattice) because of the relation between the sets of concepts and attributes is a <a href="Galois_connection" title="wikilink">Galois connection</a>.</p>

<p>The theory in its present form goes back to the <a href="Technische_Universität_Darmstadt" title="wikilink">Technische Universität Darmstadt</a> research group led by <a href="Rudolf_Wille" title="wikilink">Rudolf Wille</a>, Bernhard Ganter and Peter Burmeister, where formal concept analysis originated in the early 1980s. The mathematical basis, however, was already created by <a href="Garrett_Birkhoff" title="wikilink">Garrett Birkhoff</a> in the 1930s as part of the general lattice theory. Before the work of the Darmstadt group, there were already approaches to the same idea in various French research groups but the <a href="Technische_Universität_Darmstadt" title="wikilink">Technische Universität Darmstadt</a> normalised and popularised the field in Computer Science research circles. Philosophical foundations of formal concept analysis refer in particular to <a href="Charles_S._Peirce" title="wikilink">Charles S. Peirce</a> and the educationalist <a href="Hartmut_von_Hentig" title="wikilink">Hartmut von Hentig</a>.</p>
<h2 id="motivation-and-philosophical-background">Motivation and philosophical background</h2>

<p>In his article <em>Restructuring Lattice Theory</em> (1982) initiating formal concept analysis as a mathematical discipline, Wille starts from a discontent with the current lattice theory and pure mathematics in general: The production of theoretical results - often achieved by "elaborate mental gymnastics" - were impressive, but the connections between neighbouring domains, even parts of a theory were getting weaker.</p>
<blockquote>

<p>Restructuring lattice theory is an attempt to reinvigorate connections with our general culture by interpreting the theory as concretely as possible, and in this way to promote better communication between lattice theorists and potential users of lattice theory.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
</blockquote>

<p>This aim traces back to Hartmut von Hentig, who in 1972 pleaded for restructuring sciences in view of better teaching and in order to make sciences mutually available and more generally (i.e. also without specialized knowledge) criticable.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Hence, by its origins formal concept analysis aims at interdisciplinarity and democratic control of research.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>It corrects the starting point of lattice theory during the development of <a href="formal_logic" title="wikilink">formal logic</a> in the 19th century. Then - and later in <a href="model_theory" title="wikilink">model theory</a> - a concept as unary <a href="predicate_(logic)" title="wikilink">predicate</a> had been reduced to its extent. Now again, the philosophy of concepts should become less abstract by considering the intent. Hence, formal concept analysis is oriented towards the categories <a href="extension_(semantics)" title="wikilink">extension</a> and <a class="uri" href="intension" title="wikilink">intension</a> of <a class="uri" href="linguistics" title="wikilink">linguistics</a> and classical conceptual logic.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Formal Concept Analysis aims at the clarity of concepts according to Charles S. Peirce's <a href="pragmatic_maxim" title="wikilink">pragmatic maxim</a> by unfolding observable, elementary properties of the <a href="Minor_premise" title="wikilink">subsumed</a> objects.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> In his late philosophy, Peirce assumed that logical thinking aims at perceiving <a class="uri" href="reality" title="wikilink">reality</a>, by the triade concept, <a class="uri" href="judgement" title="wikilink">judgement</a> and <a href="Consequent" title="wikilink">conclusion</a>. Mathematics is an abstraction of logic, develops patterns of <a href="Logical_possibility" title="wikilink">possible</a> realities and therefore may support rational <a class="uri" href="communication" title="wikilink">communication</a>. On this background, Wille defines:</p>
<blockquote>

<p>The aim and meaning of Formal Concept Analysis as mathematical theory of concepts and concept hierarchies is to support the rational communication of humans by mathematically developing appropriate conceptual structures which can be logically activated.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
</blockquote>
<h2 id="contexts-and-concepts">Contexts and concepts</h2>

<p>Formal context in FCA is a triple <em>K</em> = <em>(G, M, I)</em> where <em>G</em> is a set of <em>objects</em>, <em>M</em> is a set of <em>attributes</em> and the binary relation <em>I ⊆ G × M</em>, called <em>incidence</em> shows, which objects possess which attributes. <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Formally it can be regarded as a <a href="bipartite_graph" title="wikilink">bipartite graph</a> <em>I</em> ⊆ <em>G</em> × <em>M</em>. <a href="Predicate_(mathematical_logic)" title="wikilink">Predicate</a> <em>gIm</em> designates object <em>g</em> having attribute <em>m</em>. For subsets of objects and attributes <em>A ⊆ G</em> and <em>B ⊆ M</em> <a href="Galois_closure" title="wikilink"><em>Galois operators</em></a> are defined as follows:</p>

<p><em>A' = {m ∈ M | ∀ g ∈ A (gIm)},</em></p>

<p><em>B' = {g ∈ G | ∀ m ∈ B (gIm)}</em>.</p>

<p>The operator <em>″</em> (applying the operator ′ twice) is a <a href="closure_operator" title="wikilink">closure operator</a> as it is:</p>
<ul>
<li><a class="uri" href="idempotent" title="wikilink">idempotent</a>: <em>A″″</em> = <em>A″</em>,</li>
<li><a href="Increasing" title="wikilink">monotonic</a>: <em>A<sub>1</sub> ⊆ A<sub>2</sub> → A<sub>1</sub>″ ⊆ A<sub>2</sub>″</em>,</li>
<li>extensive: <em>A ⊆ A″</em>.</li>
</ul>

<p>A set of objects <em>A ⊆ G</em> such that <em>A″ = A</em> is called <em>closed</em>. The same properties hold for closed attribute sets, i.e. subsets of the set <em>M</em>.</p>

<p>A pair <em>(A,B)</em> is called a <em>formal concept</em> of a context <em>K</em> if:</p>
<ul>
<li><em>A ⊆ G</em>,</li>
<li><em>B ⊆ M</em>,</li>
<li><em>A' = B</em>,</li>
<li><em>B' = A</em>.</li>
</ul>

<p>Intuitively, it can be understood that a formal concept is such a pair <em>(A,B)</em> of subsets of objects <em>G</em> and attributes <em>M</em> of a formal context <em>K = (G,M,I)</em> that:</p>
<ul>
<li>every object in <em>A</em> has every attribute in <em>B</em>,</li>
<li>for every object in <em>G</em> that is not in <em>A</em>, there is an attribute in <em>B</em> that the object does not have,</li>
<li>for every attribute in <em>M</em> that is not in <em>B</em>, there is an object in <em>A</em> that does not have that attribute.</li>
</ul>

<p>The sets <em>A</em> and <em>B</em> are closed and are called the <em><a href="Extension_(semantics)" title="wikilink">extent</a></em> and the <em><a href="Intension" title="wikilink">intent</a></em> of a formal context <em>(G,M,I)</em> respectively. For a set of objects <em>A</em> the set of their common attributes <em>A′</em> describes the similarity of objects of the set <em>A</em> while the closed set <em>A″</em> is a cluster of similar objects with the set of common attributes <em>A′</em>. <a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>A context may be described as a table with the objects corresponding to the rows of the table, the attributes corresponding to the columns of the table and a <a href="boolean_value" title="wikilink">boolean value</a> (in the example represented graphically as a checkmark) in cell (<em>x</em>, <em>y</em>) whenever object <em>x</em> has attribute <em>y</em>.</p>

<p>A concept, in this representation, forms a <a href="maximal_element" title="wikilink">maximal</a> subarray (not necessarily contiguous) such that all cells within the subarray are checked. For instance, the concept highlighted with a different background color in the example table below is the one describing odd prime numbers and forms a 3 × 2 subarray in which all cells are checked.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h3 id="example">Example</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">
<p>composite</p></th>
<th style="text-align: left;">
<p>even</p></th>
<th style="text-align: left;">
<p>odd</p></th>
<th style="text-align: left;">
<p>prime</p></th>
<th style="text-align: left;">
<p>square</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>8</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>9</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>10</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>

<p>Consider <em>G</em> = {1,2,3,4,5,6,7,8,9,10}, and <em>M</em> = {<a href="Composite_number" title="wikilink">composite</a>, <a href="Even_number" title="wikilink">even</a>, <a href="Odd_number" title="wikilink">odd</a>, <a href="Prime_number" title="wikilink">prime</a>, <a href="Square_number" title="wikilink">square</a>}. The smallest concept including number 3 is the one with objects {3,5,7} and attributes {<a href="Odd_number" title="wikilink">odd</a>, <a href="Prime_number" title="wikilink">prime</a>}, for 3 has both of those attributes and {3,5,7} is the set of objects having that set of attributes. The largest concept involving the attribute of being square is the one with objects {1,4,9} and attributes {<a href="Square_number" title="wikilink">square</a>}, for 1, 4 and 9 are all the square numbers and all three of them have that set of attributes. It can readily be seen that both of these example concepts satisfy the formal definitions above. </p>
<h2 id="concept-lattice-of-a-context">Concept lattice of a context</h2>

<p>The concepts (<em>G</em><sub><em>i</em></sub>, <em>M</em><sub><em>i</em></sub>) defined above can be <a href="Partial_order" title="wikilink">partially ordered</a> by inclusion: if (<em>G</em><sub><em>i</em></sub>, <em>M</em><sub><em>i</em></sub>) and (<em>G</em><sub><em>j</em></sub>, <em>M</em><sub><em>j</em></sub>) are concepts, we define a partial order ≤ by saying that (<em>G</em><sub><em>i</em></sub>, <em>M</em><sub><em>i</em></sub>) ≤ (<em>G</em><sub><em>j</em></sub>, <em>M</em><sub><em>j</em></sub>) whenever <em>G</em><sub><em>i</em></sub> ⊆ <em>G</em><sub><em>j</em></sub>. Equivalently, (<em>G</em><sub><em>i</em></sub>, <em>M</em><sub><em>i</em></sub>) ≤ (<em>G</em><sub><em>j</em></sub>, <em>M</em><sub><em>j</em></sub>) whenever <em>M</em><sub><em>j</em></sub> ⊆ <em>M</em><sub><em>i</em></sub>.</p>

<p>Every pair of concepts in this partial order has a unique greatest lower bound (meet). The greatest lower bound of (<em>G</em><sub><em>i</em></sub>, <em>M</em><sub><em>i</em></sub>) and (<em>G</em><sub><em>j</em></sub>, <em>M</em><sub><em>j</em></sub>) is the concept with objects <em>G</em><sub><em>i</em></sub> ∩ <em>G</em><sub><em>j</em></sub>; it has as its attributes the union of <em>M</em><sub><em>i</em></sub>, <em>M</em><sub><em>j</em></sub>, and any additional attributes held by all objects in <em>G</em><sub><em>i</em></sub> ∩ <em>G</em><sub><em>j</em></sub>. Symmetrically, every pair of concepts in this partial order has a unique least upper bound (join). The least upper bound of (<em>G</em><sub><em>i</em></sub>, <em>M</em><sub><em>i</em></sub>) and (<em>G</em><sub><em>j</em></sub>, <em>M</em><sub><em>j</em></sub>) is the concept with attributes <em>M</em><sub><em>i</em></sub> ∩ <em>M</em><sub><em>j</em></sub>; it has as its objects the union of <em>G</em><sub><em>i</em></sub>, <em>G</em><sub><em>j</em></sub>, and any additional objects that have all attributes in <em>M</em><sub><em>i</em></sub> ∩ <em>M</em><sub><em>j</em></sub>.</p>

<p>These meet and join operations satisfy the axioms defining a <a href="Lattice_(order)" title="wikilink">lattice</a>. In fact, by considering infinite meets and joins, analogously to the binary meets and joins defined above, one sees that this is a <a href="complete_lattice" title="wikilink">complete lattice</a>. It may be viewed as the <a href="Dedekind–MacNeille_completion" title="wikilink">Dedekind–MacNeille completion</a> of a <a href="partially_ordered_set" title="wikilink">partially ordered set</a> of height two in which the elements of the partial order are the objects and attributes of <em>M</em> and in which two elements <em>x</em> and <em>y</em> satisfy <em>x</em> ≤ <em>y</em> exactly when <em>x</em> is an object that has attribute <em>y</em>.</p>

<p>Any finite lattice may be generated as the concept lattice for some context. Let <em>L</em> be a finite lattice and form a context in which the objects and the attributes both correspond to elements of <em>L</em>. In this context, let object <em>x</em> have attribute <em>y</em> exactly when <em>x</em> and <em>y</em> are ordered as <em>x</em> ≤ <em>y</em> in the lattice. Then the concept lattice of this context is isomorphic to <em>L</em> itself.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> This construction may be interpreted as forming the Dedekind–MacNeille completion of <em>L</em>, which is known to produce an isomorphic lattice from any finite lattice.</p>
<h3 id="example-1">Example</h3>

<p> The full set of concepts for objects and attributes from the above example is shown in the illustration. It includes a concept for each of the original attributes: composite, square, even, odd and prime. Additionally, it includes concepts for even composite numbers, composite square numbers (that is, all square numbers except 1), even composite squares, odd squares, odd composite squares, even primes, and odd primes. </p>
<h2 id="clarified">Clarified</h2>

<p><em>row-clarified</em>: the context does not have duplicate rows (

<math display="inline" id="Formal_concept_analysis:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>o</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>o</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>o</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>o</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(o)=o^{\prime}
  </annotation>
 </semantics>
</math>

 is <a href="Injective_function" title="wikilink">injective</a>)</p>

<p><em>column-clarified</em>: the context does not have duplicate columns (

<math display="inline" id="Formal_concept_analysis:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>a</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>O</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(a)=a^{\prime}
  </annotation>
 </semantics>
</math>

 is <a href="Injective_function" title="wikilink">injective</a>)</p>

<p><em>clarified</em>: row-clarified and column-clarified</p>
<h2 id="reduced">Reduced</h2>

<p><em>row-reduced</em>: no context rows can be expressed as intersection of other rows. The lattice of such context is <em>meet-reduced</em>.</p>

<p><em>column-reduced</em>: no context columns can be expressed as intersection of other columns. The lattice of such context is <em>join-reduced</em>.</p>

<p><em>reduced</em>: row-reduced and column-reduced</p>

<p>A reducible attribute gets added in a node of the lattice, which would be there also without this attribute.</p>
<h2 id="concept-algebra-of-a-context">Concept algebra of a context</h2>

<p>Modelling negation in a formal context is somewhat problematic because the complement (<em>G</em>\<em>G</em><sub><em>i</em></sub>, <em>M</em>\<em>M</em><sub><em>i</em></sub>) of a concept (<em>G</em><sub><em>i</em></sub>, <em>M</em><sub><em>i</em></sub>) is in general not a concept. However, since the concept lattice is complete one can consider the join (<em>G</em><sub><em>i</em></sub>, <em>M</em><sub><em>i</em></sub>)<sup>Δ</sup> of all concepts (<em>G</em><sub><em>j</em></sub>, <em>M</em><sub><em>j</em></sub>) that satisfy <em>G</em><sub>j</sub> ⊆ <em>G</em>\<em>G</em><sub>i</sub>; or dually the meet (<em>G</em><sub><em>i</em></sub>, <em>M</em><sub><em>i</em></sub>)<sup>𝛁</sup> of all concepts satisfying <em>M</em><sub>j</sub> ⊆ <em>G</em>\<em>M</em><sub>i</sub>. These two operations are known as <em>weak negation</em> and <em>weak opposition</em>, respectively.</p>

<p>This can be expressed in terms of the <em>derivative</em> functions. The derivative of a set <em>G</em><sub>i</sub> ⊆ <em>G</em> of objects is the set <em>G</em><sub>i</sub>' ⊆ <em>M</em> of all attributes that hold for all objects in <em>G</em><sub>i</sub>. The derivative of a set <em>M</em><sub>i</sub> ⊆ <em>M</em> of attributes is the set <em>M</em><sub>i</sub>' ⊆ <em>G</em> of all objects that have all attributes in <em>M</em><sub>i</sub>. A pair (<em>G</em><sub><em>i</em></sub>, <em>M</em><sub><em>i</em></sub>) is a concept if and only if <em>G</em><sub>i</sub>' = <em>M</em><sub>i</sub> and <em>M</em><sub>i</sub>' = <em>G</em><sub>i</sub>. Using this function, weak negation can be written as</p>
<dl>
<dd>(<em>G</em><sub><em>i</em></sub>, <em>M</em><sub><em>i</em></sub>)<sup>Δ</sup> = ((<em>G</em>\<em>M</em>)'', (<em>G</em>\<em>M</em>)'),
</dd>
</dl>

<p>and weak opposition can be written as</p>
<dl>
<dd>(<em>G</em><sub><em>i</em></sub>, <em>M</em><sub><em>i</em></sub>)<sup>𝛁</sup> = ((<em>M</em>\<em>B</em>)', (<em>M</em>\<em>B</em>)'').
</dd>
</dl>

<p>The concept lattice equipped with the two additional operations Δ and 𝛁 is known as the <em>concept algebra</em> of a context. Concept algebras are a generalization of <a href="power_set" title="wikilink">power sets</a>.</p>

<p>Weak negation on a concept lattice <em>L</em> is a <em>weak complementation</em>, i.e. an <a class="uri" href="order-reversing" title="wikilink">order-reversing</a> map Δ: <em>L</em> → <em>L</em> which satisfies the axioms <em>x</em><sup>ΔΔ</sup> ≤ <em>x</em> and (<em>x</em>⋀<em>y</em>) ⋁ (<em>x</em>⋀<em>y</em><sup>Δ</sup>) = <em>x</em>. Weak composition is a dual weak complementation. A (bounded) lattice such as a concept algebra, which is equipped with a weak complementation and a dual weak complementation, is called a <em>weakly dicomplemented lattice</em>. Weakly dicomplemented lattices generalize distributive <a href="orthocomplemented_lattice" title="wikilink">orthocomplemented lattices</a>, i.e. <a href="Boolean_algebra_(structure)" title="wikilink">Boolean algebras</a>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h2 id="recovering-the-context-from-the-line-diagram">Recovering the context from the line diagram</h2>

<p>The <a href="Hasse_diagram" title="wikilink">line diagram</a> of the concept lattice encodes enough information to recover the original context from which it was formed. Each object of the context corresponds to a lattice element, the element with the minimal object set that contains that object, and with an attribute set consisting of all attributes of the object. Symmetrically, each attribute of the context corresponds to a lattice element, the one with the minimal attribute set containing that attribute, and with an object set consisting of all objects with that attribute. We may label the nodes of the line diagram with the objects and attributes they correspond to; with this labeling, object <em>x</em> has attribute <em>y</em> if and only if there exists a <a class="uri" href="monotonic" title="wikilink">monotonic</a> path from <em>x</em> to <em>y</em> in the diagram.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h2 id="implications-and-association-rules-with-fca">Implications and association rules with FCA</h2>

<p>In FCA <strong>implication</strong> <em>A → B</em> for subsets <em>A</em>, <em>B</em> of the set of attributes <em>M</em> (''A,B ⊆ M '') holds if <em>A′ ⊆ B′</em>, i.e. every object possessing each attribute from <em>A</em> also has each attribute from <em>B</em>. Implications obey <a href="Armstrong_axioms" title="wikilink">Armstrong rules</a>:</p>

<p>

<math display="inline" id="Formal_concept_analysis:2">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mi>Y</mi>
     <mo>⊆</mo>
     <mi>X</mi>
    </mrow>
    <mrow>
     <mi>X</mi>
     <mo>→</mo>
     <mi>Y</mi>
    </mrow>
   </mfrac>
   <mo>,</mo>
   <mfrac>
    <mrow>
     <mi>X</mi>
     <mo>→</mo>
     <mi>Y</mi>
    </mrow>
    <mrow>
     <mrow>
      <mi>X</mi>
      <mi>Z</mi>
     </mrow>
     <mo>→</mo>
     <mrow>
      <mi>Y</mi>
      <mi>Z</mi>
     </mrow>
    </mrow>
   </mfrac>
   <mo>,</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mi>X</mi>
      <mo>→</mo>
      <mi>Y</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>Y</mi>
      <mo>→</mo>
      <mi>Z</mi>
     </mrow>
    </mrow>
    <mrow>
     <mi>X</mi>
     <mo>→</mo>
     <mi>Z</mi>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <divide></divide>
     <apply>
      <subset></subset>
      <ci>Y</ci>
      <ci>X</ci>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <ci>X</ci>
      <ci>Y</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <ci>normal-→</ci>
      <ci>X</ci>
      <ci>Y</ci>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>Z</ci>
      </apply>
      <apply>
       <times></times>
       <ci>Y</ci>
       <ci>Z</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <ci>normal-→</ci>
       <ci>X</ci>
       <ci>Y</ci>
      </apply>
      <apply>
       <ci>normal-→</ci>
       <ci>Y</ci>
       <ci>Z</ci>
      </apply>
     </apply>
     <apply>
      <ci>normal-→</ci>
      <ci>X</ci>
      <ci>Z</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{Y\subseteq X}{X\rightarrow Y},\frac{X\rightarrow Y}{XZ\rightarrow YZ},%
\frac{X\rightarrow Y,Y\rightarrow Z}{X\rightarrow Z}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="fca-algorithms">FCA Algorithms</h2>
<h3 id="algorithms-for-generating-formal-concepts-and-constructing-concept-lattices">Algorithms for generating formal concepts and constructing concept lattices</h3>

<p>Kuznetsov and Obiedkov <a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> survey many algorithms that have been developed for constructing concept lattices. These algorithms vary in many details, but are in general based on the idea that each edge of the line diagram of the concept lattice connects some concept <em>C</em> to the concept formed by the join of <em>C</em> with a single object. Thus, one can build up the concept lattice one concept at a time, by finding the neighbors in the line diagram of known concepts, starting from the concept with an empty set of objects. The amount of time spent to <a href="graph_traversal" title="wikilink">traverse</a> the entire concept lattice in this way is polynomial in the number of input objects and attributes per generated concept.</p>

<p>Generation of the concept set presents two main problems: how to generate all concepts and how to avoid repetitive generation of the same concept or, at least, to determine whether a concept is generated for the first time. There are several ways to generate a new intent. Some algorithms (in particular, incremental ones) intersect a generated intent with some object intent. Other algorithms compute an intent explicitly intersecting all objects of the corresponding extent. There are algorithms that, starting from object intents, create new intents by intersecting already obtained intents. Lastly, one of the algorithms <a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> does not use the intersection operation to generate intents. It forms new intents by adding attributes to those already generated and tests some condition on supports of attribute sets (a support of an attribute set is the number of objects whose intents contain all attributes from this set) to realize whether an attribute set is an intent.</p>

<p>The <em>Close by One</em> algorithm, for instance, generates concepts in the lexicographical order of their extents assuming that there is a linear order on the set of objects. At each step of the algorithm there is a current object. The generation of a concept is considered canonical if its extent contains no object preceding the current object. <em>Close by One</em> uses the described canonicity test, a method for selecting subsets of a set of objects <em>G</em> and an intermediate structure that helps to compute closures more efficiently using the generated concepts. Its time complexity is <em>O(|G|<sup>2</sup>|M||L|)</em>, and its polynomial delay is O(|G|<sup>3</sup>|M|) where <em>|G|</em> stands for the cardinality of the set of objects <em>G</em>, <em>|M|</em>, similarly, is the number of all attributes from <em>M</em> and <em>|L|</em> is the size of the concept lattice.</p>

<p>The <em>Chein</em> Algorithm <a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> represents the objects by extent–intent pairs and generates each new concept intent as the intersection of intents of two existent concepts. At every iteration step of the <em>Chein</em> algorithm a new layer of concepts is created by intersecting pairs of concept intents from the current layer and the new intent is searched for in the new layer. The time complexity of the modified version of <em>Chein</em> algorithm is <em>O(|G|<sup>3</sup>|M||L|)</em> while its polynomial delay is <em>O(|G|<sup>3</sup>|M|)</em>.</p>

<p>The algorithm by <em>Bordat</em> <a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> uses a tree for fast storing and retrieval of concepts. This algorithm uses a technique that requires <em>O(|M|)</em> time to realize whether a concept is generated for the first time without any search - the uniqueness of a concept is tested by intersecting its intent with the content of the cache. The time complexity of Bordat is <em>O(|G||M|<sup>2</sup>|L|)</em>. This algorithm has a polynomial delay <em>O(|G||M|<sup>3</sup>)</em>.</p>

<p>The algorithm proposed by <em>Norris</em> <a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> is essentially an incremental version of the <em>Close by One</em> algorithm with time complexity - <em>O(|G|<sup>2</sup>|M||L|)</em>.</p>

<p>The algorithm proposed by <em>Godin</em> <a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> has the worst-case time complexity quadratic in the number of concepts. This algorithm is based on the use of an efficiently computable hash function f (which is actually the cardinality of an intent) defined on the set of concepts.</p>

<p>The choice of an algorithm for construction of the concept lattice should be based on the properties of input data. According to the survey <a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> , recommendations are as follows: the <em>Godin</em> algorithm should be used for small and sparse contexts. For dense contexts the algorithms based on the canonicity test, linear in the number of input objects, such as <em>Close by One</em> and <em>Norris</em>, should be used. <em>Bordat</em> performs well on contexts of average density, especially, when the diagram graph is to be constructed.</p>

<p><em>Fast Close by One</em> (<em>FCbO</em>) <a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> can be seen as an extended version of <em>Close by One</em> which involves improved canonicity test that significantly reduces the number of formal concepts computed multiple times. It also combines depth-first and breadth-first search and employs an additional test that can be performed before a new formal concept is computed eliminating thus some unnecessary computations. <em>FCbO</em> performs well in case of both sparse and dense data of reasonable size. From the point of view of the asymptotic worst-case complexity, <em>FCbO</em> has time delay <em>O(|G|<sup>3</sup>|M|)</em> <a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> , and asymptotic time complexity <em>O(|G|<sup>2</sup>|M||L|)</em> because in the worst case <em>FCbO</em> can degenerate into the original <em>Close by One</em>.</p>

<p>The <em>AddIntent</em> algorithm <a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> produces not only the concept set, but also the diagram graph. Being incremental, it relies on the graph constructed from the first objects of the context to integrate the next object into the lattice. Therefore, its use is most appropriate in those applications that require both the concept set and diagram graph, for example, in applications related to information retrieval and document browsing. The best estimate for the algorithm’s upper bound complexity to construct a concept lattice <em>L</em> whose context has a set of objects <em>G</em>, each of which possesses at most <em>max(|g′|)</em> attributes, is <em>O(|L||G|<sup>2</sup>max(|g′|))</em>. The <em>AddIntent</em> algorithm outperformed a selection of other published algorithms in experimental comparison for most types of contexts and was close to the most efficient algorithm in other cases.</p>
<h2 id="relationships-of-fca-to-models-of-knowledge-representation-and-processing">Relationships of FCA to models of knowledge representation and processing</h2>
<h3 id="fca-biclustering-and-multidimensional-clustering">FCA, biclustering and multidimensional clustering</h3>

<p>There are several types of biclusters (co-clusters) known in the literature: <a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> biclusters of equal values, similar values, coherent values, the commonality of them being the existence of inclusion-maximal set of objects described by inclusion-maximal set of attributes with some special pattern of behavior. Clustering objects based on sets of attributes taking similar values dates back to the work of Hartigan <a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> and was called biclustering by Mirkin. <a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> Attention to biclustering approaches started to grow from the beginning of the 2000s with the growth of the need to analyze similarities in gene expression data <a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> and design of recommender systems. <a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></p>

<p>Given an object-attribute numerical data-table (many-valued context in terms of FCA), the goal of biclustering is to group together some objects having similar values of some attributes. For example, in gene expression data, it is known that genes (objects) may share a common behavior for a subset of biological situations (attributes) only: one should accordingly produce local patterns to characterize biological processes, the latter should possibly overlap, since a gene may be involved in several processes. The same remark applies for recommender systems where one is interested in local patterns characterizing groups of users that strongly share almost the same tastes for a subset of items. <a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>

<p>A bicluster in a binary object-attribute data-table is a pair <em>(A,B)</em> consisting of an inclusion-maximal set of objects <em>A</em> and an inclusion-maximal set of attributes <em>B</em> such that almost all objects from <em>A</em> have almost all attributes from <em>B</em> and vice versa. Of course, formal concepts can be considered as "rigid" biclusters where all objects have all attributes and vice versa. Hence, it is not surprising that some bicluster definitions coming from practice <a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> are just definitions of a formal concept. <a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> A bicluster of similar values in a numerical object-attribute data-table is usually defined <a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> <a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a> <a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> as a pair consisting of an inclusion-maximal set of objects and an inclusion-maximal set of attributes having similar values for the objects. Such a pair can be represented as an inclusion-maximal rectangle in the numerical table, modulo rows and columns permutations. In <a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> it was shown that biclusters of similar values correspond to triconcepts of a triadic context <a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> where the third dimension is given by a scale that represents numerical attribute values by binary attributes. This fact can be generalized to <em>n</em>-dimensional case, where <em>n</em>-dimensional clusters of similar values in <em>n</em>-dimensional data are represented by <em>n+1</em>-dimensional concepts. This reduction allows one to use standard definitions and algorithms from multidimensional concept analysis <a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> <a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> for computing multidimensional clusters.</p>
<h2 id="tools">Tools</h2>

<p>Many FCA software applications are available today. The main purpose of these tools varies from formal context creation to formal concept mining and generating the concepts lattice of a given formal context and the corresponding association rules. Most of these tools are academic and still under active development. One can find a non exhaustive list of FCA tools in the <a href="http://www.fcahome.org.uk/fcasoftware.html">FCA software website</a>. Most of these tools are open-source applications like <a href="http://conexp.sourceforge.net">ConExp</a>, <a href="http://toscanaj.sourceforge.net">ToscanaJ</a>, <a href="Lattice_Miner" title="wikilink">Lattice Miner</a>,<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a> <a href="http://coron.loria.fr/">Coron</a>, <a href="http://sourceforge.net/projects/fcabedrock">FcaBedrock</a>, etc.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Association_rule_learning" title="wikilink">Association rule learning</a></li>
<li><a class="uri" href="Biclustering" title="wikilink">Biclustering</a></li>
<li><a href="Cluster_analysis" title="wikilink">Cluster analysis</a></li>
<li><a href="Commonsense_reasoning" title="wikilink">Commonsense reasoning</a></li>
<li><a href="Conceptual_clustering" title="wikilink">Conceptual clustering</a></li>
<li><a href="Concept_learning" title="wikilink">Concept learning</a></li>
<li><a href="Concept_mining" title="wikilink">Concept mining</a></li>
<li><a href="Correspondence_analysis" title="wikilink">Correspondence analysis</a></li>
<li><a href="Description_logic" title="wikilink">Description logic</a></li>
<li><a href="Factor_analysis" title="wikilink">Factor analysis</a></li>
<li><a href="Graphical_model" title="wikilink">Graphical model</a></li>
<li><a href="Grounded_theory" title="wikilink">Grounded theory</a></li>
<li><a href="Inductive_logic_programming" title="wikilink">Inductive logic programming</a></li>
<li><a href="Pattern_theory" title="wikilink">Pattern theory</a></li>
<li><a href="Statistical_relational_learning" title="wikilink">Statistical relational learning</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>
<ul>
<li>

<p>. Translated by C. Franzke.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li>

<p>.</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.fcahome.org.uk/">A Formal Concept Analysis Homepage</a></li>
<li><a href="http://www.ketlab.org.uk/scripts/context">Demo</a></li>
<li><a href="http://www.math.tu-dresden.de/icfca13/">11th International Conference on Formal Concept Analysis. ICFCA 2013 - Dresden, Germany - May 21-24, 2013</a></li>
</ul>

<p>"</p>

<p><a href="Category:Machine_learning" title="wikilink">Category:Machine learning</a> <a href="Category:Lattice_theory" title="wikilink">Category:Lattice theory</a> <a href="Category:Data_mining" title="wikilink">Category:Data mining</a> <a href="Category:Ontology_(information_science)" title="wikilink">Category:Ontology (information science)</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Rudolf Wille: <em>[<a class="uri" href="http://books.google.de/books?hl=de&amp;lr">http://books.google.de/books?hl=de&amp;lr;</a>;=&amp;id;=gwpq0acO3kgC&amp;oi;=fnd&amp;pg;=PA314&amp;dq;=Wille+Restructuring+Lattice+Theory&amp;ots;=zYmNQeCJKb&amp;sig;=TyDygU5lU_91iJWIuJbNi2or6Ls#v=onepage&amp;q;=Wille%20Restructuring%20Lattice%20Theory&amp;f;=false Restructuring lattice theory: An approach based on hierarchies of concepts.]</em> Reprint in: ICFCA '09: Proceedings of the 7th International Conference on Formal Concept Analysis, Berlin, Heidelberg, 2009, p. 314.<a href="#fnref1">↩</a></li>
<li id="fn2">Hartmut von Hentig: <em>Magier oder Magister? Über die Einheit der Wissenschaft im Verständigungsprozeß</em>. Klett 1972 / Suhrkamp 1974. Cited after Karl Erich Wolff: <em><a href="http://www.fbmn.h-da.de/~wolff/Publikationen/Ordnung_Wille_und_Begriff.doc">Ordnung, Wille und Begriff</a></em>, Ernst Schröder Zentrum für Begriffliche Wissensverarbeitung, Darmstadt 2003.<a href="#fnref2">↩</a></li>
<li id="fn3">Johannes Wollbold: <em><a href="http://www.db-thueringen.de/servlets/DerivateServlet/Derivate-24615/Wollbold/Dissertation.pdf">Attribute Exploration of Gene Regulatory Processes</a></em>. PhD thesis, University of Jena 2011, p. 9<a href="#fnref3">↩</a></li>
<li id="fn4">Bernhard Ganter, Bernhard and Rudolf Wille: <em>Formal Concept Analysis: Mathematical Foundations</em>. Springer, Berlin, ISBN 3-540-62771-5, p. 1<a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6">Rudolf Wille: <em>[<a class="uri" href="http://books.google.de/books?hl=de&amp;lr">http://books.google.de/books?hl=de&amp;lr;</a>;=&amp;id;=nEh4D4e88NwC&amp;oi;=fnd&amp;pg;=PA1&amp;dq;=Formal+Concept+Analysis+Fondations+and+Applications&amp;ots;=GSCkikE8pv&amp;sig;=8TJOPrSW07sJqLH0hF8_-HH_gb4#v=onepage&amp;q;=Formal%20Concept%20Analysis%20Fondations%20and%20Applications&amp;f;=false Formal Concept Analysis as Mathematical Theory of Concepts and Concept Hierarchies].</em> In: B. Ganter et al.: Formal Concept Analysis. Foundations and Applications, Springer, 2005, p. 1f.<a href="#fnref6">↩</a></li>
<li id="fn7">Ganter B., Wille R. <em>Formal Concept Analysis: Mathematical Foundations, 1st edn</em>. Springer-Verlag New York, Inc., Secaucus. 1999<a href="#fnref7">↩</a></li>
<li id="fn8">Ignatov D.I., Kuznetsov S.O., Zhukov L.E., Poelmans J. Can triconcepts become triclusters? In: International Journal of General Systems, Vol. 42. No. 6, pp. 572-593, 2013.<a href="#fnref8">↩</a></li>
<li id="fn9">Wolff, section 2.<a href="#fnref9">↩</a></li>
<li id="fn10">Stumme, Theorem 1.<a href="#fnref10">↩</a></li>
<li id="fn11">.<a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13">Wolff, section 3.<a href="#fnref13">↩</a></li>
<li id="fn14">Kuznetsov S., Obiedkov S. <em>Comparing Performance of Algorithms for Generating Concept Lattices</em>, 14, <a href="Journal_of_Experimental_and_Theoretical_Artificial_Intelligence" title="wikilink">Journal of Experimental and Theoretical Artificial Intelligence</a>, Taylor &amp; Francis, ISSN 0952–813X print/ISSN 1362–3079 online, pp.189–216, 2002<a href="#fnref14">↩</a></li>
<li id="fn15">Stumme G., Taouil R., Bastide Y., Pasquier N., Lakhal L. <em>Fast Computation of Concept Lattices Using Data Mining Techniques</em>. Proc. 7th Int. Workshop on Knowledge Representation Meets Databases (KRDB 2000) pp.129-139, 2000.<a href="#fnref15">↩</a></li>
<li id="fn16">Chein M., <em>Algorithme de recherche des sous-matrice~ premieres d'une matrice</em>, Bull. Math. R.S. Roumanie, No. 13, No. 1, 21-25, 1969<a href="#fnref16">↩</a></li>
<li id="fn17">Bordat J.P. <em>Calcul pratique du treillis de Galois d’une correspondance</em>, Math. Sci. Hum.no. 96, pp. 31–47, 1986<a href="#fnref17">↩</a></li>
<li id="fn18">Norris E.M.,<em>An algorithm for computing the maximal rectangles in a binary relation</em>. Rev. Roum. de Math. Pures Appliqudes, 23, No. 2, 243-250, 1978<a href="#fnref18">↩</a></li>
<li id="fn19">Godin R., Missaoui R. and Alaoui H. <em>Incremental Concept Formation Algorithms Based on Galois Lattices</em>. Computation Intelligence, 1995<a href="#fnref19">↩</a></li>
<li id="fn20"></li>
<li id="fn21">Krajca P., Outrata J., Vychodil V. <em>Advances in algorithms based on CbO</em>. in: Proceedings of the CLA, pp. 325–337, 2010<a href="#fnref21">↩</a></li>
<li id="fn22">Outrata J., Vychodil V. <em>Fast algorithm for computing fixpoints of galois connections induced by object-attribute relational data</em>. Information Sciences, Volume 185, Issue 1, 15 February 2012, Pages 114-127, ISSN 0020-0255<a href="#fnref22">↩</a></li>
<li id="fn23">van der Merwe D, Obiedkov S., Kourie D. <em>AddIntent: A New Incremental Algorithm for Constructing Concept Lattices</em>, in: Proceedings of the 2nd International Conference on Formal Concept Analysis (ICFCA 2004). "Concept Lattices, Proceedings", Lecture Notes in Artificial Intelligence, vol. 2961, pp. 372-385. 2004<a href="#fnref23">↩</a></li>
<li id="fn24">Madeira S., Oliveira, A. <em>Biclustering algorithms for biological data analysis: a survey</em>. IEEE/ACM Transactions on Computational Biology and Bioinformatics, 1(1):24-45, 2004.<a href="#fnref24">↩</a></li>
<li id="fn25">Hartigan, J. A. <em>Direct Clustering of a Data Matrix</em>. Journal of the American Statistical Association, 67(337):123-129, 1972.<a href="#fnref25">↩</a></li>
<li id="fn26">Mirkin B. <em>Mathematical classification and clustering</em>. Boston-Dordrecht: Kluwer academic publisher, 1996<a href="#fnref26">↩</a></li>
<li id="fn27">Cheng Y., Church G. <em>Biclustering of expression data</em>. In Proc. 8th International Conference on Intelligent Systems for Molecular Biology (ISBM), 2000. pp. 93-103<a href="#fnref27">↩</a></li>
<li id="fn28">Adomavicius C., Tuzhilin A. <em>Toward the next generation of recommender systems: a survey of the state-of-the-art and possible extensions</em>. Knowledge and Data Engineering, IEEE Transac-tions on, 17(6): 734 -749, 2005.<a href="#fnref28">↩</a></li>
<li id="fn29"></li>
<li id="fn30">Prelic, S. Bleuler, P. Zimmermann, A. Wille, P. Buhlmann, W. Gruissem, L. Hennig, L. Thiele, and E. Zitzler. <em>A Systematic Comparison and Evaluation of Biclustering Methods for Gene Expression Data</em>. Bioinformatics, 22(9):1122-1129, 2006<a href="#fnref30">↩</a></li>
<li id="fn31">Kaytoue M., Kuznetsov S., Macko J., Wagner Meira Jr., Napoli A. <em>Mining Biclusters of Similar Values with Triadic Concept Analysis</em>. CLA : 175-190, 2011<a href="#fnref31">↩</a></li>
<li id="fn32">R. G. Pensa, C. Leschi, J. Besson, J.-F. Boulicaut. <em>Assessment of discretization techniques for relevant pattern discovery from gene expression data</em>. In M. J. Zaki, S. Morishita, and I. Rigoutsos, editors, Proceedings of the 4th ACM SIGKDD Workshop on Data Mining in Bioinformatics (BIOKDD 2004), 24-30, 2004.<a href="#fnref32">↩</a></li>
<li id="fn33">Besson J., Robardet C. Raedt L.D., Boulicaut, J.-F. <em>Mining bi-sets in numerical data</em>. In S. Dzeroski and J. Struyf, editors, KDID, LNCS 4747, p.11-23. Springer, 2007.<a href="#fnref33">↩</a></li>
<li id="fn34">Cerf L., Besson J., Robardet C., Boulicaut J.-F. <em>Closed patterns meet n-ary relations</em>. TKDD, 3(1), 2009<a href="#fnref34">↩</a></li>
<li id="fn35"></li>
<li id="fn36">Wille R. <em>The basic theorem of triadic concept analysis</em>. Order 12, 149-158., 1995<a href="#fnref36">↩</a></li>
<li id="fn37"></li>
<li id="fn38">Voutsadakis G. <em>Polyadic Concept Analysis</em>. Order, 19 (3), 295-304., 2002<a href="#fnref38">↩</a></li>
<li id="fn39">Boumedjout Lahcen and Leonard Kwuida. Lattice Miner: A Tool for Concept Lattice Construction and Exploration. In Supplementary Proceeding of International Conference on Formal concept analysis (ICFCA'10), 2010<a href="#fnref39">↩</a></li>
</ol>
</section>
</body>
</html>
