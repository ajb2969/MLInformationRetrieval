<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="958">Hungarian algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Hungarian algorithm</h1>
<hr/>

<p>The <strong>Hungarian method</strong> is a <a href="combinatorial_optimization" title="wikilink">combinatorial optimization</a> <a class="uri" href="algorithm" title="wikilink">algorithm</a> that solves the <a href="assignment_problem" title="wikilink">assignment problem</a> in <a href="polynomial_time" title="wikilink">polynomial time</a> and which anticipated later <a href="primal-dual_method" title="wikilink">primal-dual methods</a>. It was developed and published in 1955 by <a href="Harold_Kuhn" title="wikilink">Harold Kuhn</a>, who gave the name "Hungarian method" because the algorithm was largely based on the earlier works of two <a href="Hungary" title="wikilink">Hungarian</a> mathematicians: <a href="Dénes_Kőnig" title="wikilink">Dénes Kőnig</a> and <a href="Jenő_Egerváry" title="wikilink">Jenő Egerváry</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p><a href="James_Munkres" title="wikilink">James Munkres</a> reviewed the algorithm in 1957 and observed that it is <a href="Time_complexity#Strongly_and_weakly_polynomial_time" title="wikilink">(strongly) polynomial</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Since then the algorithm has been known also as the <strong>Kuhn–Munkres algorithm</strong> or <strong>Munkres assignment algorithm</strong>. The <a href="Computational_complexity_theory#Time_and_space_complexity" title="wikilink">time complexity</a> of the original algorithm was 

<math display="inline" id="Hungarian_algorithm:0">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>4</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{4})
  </annotation>
 </semantics>
</math>

, however <a href="Jack_Edmonds" title="wikilink">Edmonds</a> and <a href="Richard_Karp" title="wikilink">Karp</a>, and independently Tomizawa noticed that it can be modified to achieve an 

<math display="inline" id="Hungarian_algorithm:1">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{3})
  </annotation>
 </semantics>
</math>

 running time. <a href="L._R._Ford,_Jr." title="wikilink">Ford</a> and <a href="D._R._Fulkerson" title="wikilink">Fulkerson</a> extended the method to general transportation problems. In 2006, it was discovered that <a href="Carl_Gustav_Jacobi" title="wikilink">Carl Gustav Jacobi</a> had solved the assignment problem in the 19th century, and the solution had been published posthumously in 1890 in Latin.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="laymans-explanation-of-the-assignment-problem">Layman’s explanation of the assignment problem</h2>

<p>Say you have three workers: Jim, Steve, and Alan. You need to have one of them clean the bathroom, another sweep the floors, and the third wash the windows, but they each demand different pay for the various tasks. What's the lowest-cost way to assign the jobs? The problem can be represented in a <a href="Matrix_(mathematics)" title="wikilink">matrix</a> of the costs of the workers doing the jobs. For example:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">
<p>Clean bathroom</p></th>
<th style="text-align: left;">
<p>Sweep floors</p></th>
<th style="text-align: left;">
<p>Wash windows</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Jim</p></td>
<td style="text-align: left;">
<p>$2</p></td>
<td style="text-align: left;">
<p>$3</p></td>
<td style="text-align: left;">
<p>$3</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Steve</p></td>
<td style="text-align: left;">
<p>$3</p></td>
<td style="text-align: left;">
<p>$2</p></td>
<td style="text-align: left;">
<p>$3</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Alan</p></td>
<td style="text-align: left;">
<p>$3</p></td>
<td style="text-align: left;">
<p>$3</p></td>
<td style="text-align: left;">
<p>$2</p></td>
</tr>
</tbody>
</table>

<p>The Hungarian method, when applied to the above table, would give us the minimum cost: this is $6, achieved by having Jim clean the bathroom, Steve sweep the floors, and Alan wash the windows.</p>
<h2 id="setting">Setting</h2>

<p>We are given a nonnegative <em>n</em>×<em>n</em> <a href="Matrix_(mathematics)" title="wikilink">matrix</a>, where the element in the <em>i</em>-th row and <em>j</em>-th column represents the cost of assigning the <em>j</em>-th job to the <em>i</em>-th worker. We have to find an assignment of the jobs to the workers that has minimum cost. If the goal is to find the assignment that yields the maximum cost, the problem can be altered to fit the setting by replacing each cost with the maximum cost subtracted by the cost.</p>

<p>The algorithm is easier to describe if we formulate the problem using a bipartite graph. We have a <a href="complete_bipartite_graph" title="wikilink">complete bipartite graph</a> <em>G=(S, T; E)</em> with <em>n</em> worker vertices (<em>S</em>) and <em>n</em> job vertices (<em>T</em>), and each edge has a nonnegative cost <em>c(i,j)</em>. We want to find a <a href="perfect_matching" title="wikilink">perfect matching</a> with minimum cost.</p>

<p>Let us call a function 

<math display="inline" id="Hungarian_algorithm:2">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>S</mi>
      <mo>∪</mo>
      <mi>T</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>↦</mo>
    <mi>ℝ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>y</ci>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <apply>
      <union></union>
      <ci>S</ci>
      <ci>T</ci>
     </apply>
     <ci>ℝ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y:(S\cup T)\mapsto\mathbb{R}
  </annotation>
 </semantics>
</math>

 a <strong>potential</strong> if 

<math display="inline" id="Hungarian_algorithm:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>i</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>j</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <interval closure="open">
      <ci>i</ci>
      <ci>j</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(i)+y(j)\leq c(i,j)
  </annotation>
 </semantics>
</math>

 for each 

<math display="inline" id="Hungarian_algorithm:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>i</mi>
    <mo>∈</mo>
    <mi>S</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>j</mi>
    <mo>∈</mo>
    <mi>T</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <ci>i</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <in></in>
     <ci>j</ci>
     <ci>T</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\in S,j\in T
  </annotation>
 </semantics>
</math>

. The value of potential <em>y</em> is 

<math display="inline" id="Hungarian_algorithm:5">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>v</mi>
     <mo>∈</mo>
     <mrow>
      <mi>S</mi>
      <mo>∪</mo>
      <mi>T</mi>
     </mrow>
    </mrow>
   </msub>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <ci>v</ci>
      <apply>
       <union></union>
       <ci>S</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>y</ci>
     <ci>v</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{v\in S\cup T}y(v)
  </annotation>
 </semantics>
</math>

. It can be seen that the cost of each perfect matching is at least the value of each potential. The Hungarian method finds a perfect matching and a potential with equal cost/value which proves the optimality of both. In fact it finds a perfect matching of <strong>tight edges</strong>: an edge <em>ij</em> is called tight for a potential <em>y</em> if 

<math display="inline" id="Hungarian_algorithm:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>i</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>j</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>i</mi>
     <mo>,</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>c</ci>
     <interval closure="open">
      <ci>i</ci>
      <ci>j</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(i)+y(j)=c(i,j)
  </annotation>
 </semantics>
</math>

. Let us denote the <a href="Glossary_of_graph_theory#Subgraphs" title="wikilink">subgraph</a> of tight edges by 

<math display="inline" id="Hungarian_algorithm:7">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>y</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{y}
  </annotation>
 </semantics>
</math>

. The cost of a perfect matching in 

<math display="inline" id="Hungarian_algorithm:8">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>y</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{y}
  </annotation>
 </semantics>
</math>

 (if there is one) equals the value of <em>y</em>.</p>
<h2 id="the-algorithm-in-terms-of-bipartite-graphs">The algorithm in terms of bipartite graphs</h2>

<p>During the algorithm we maintain a potential <em>y</em> and an <a href="Glossary_of_graph_theory#Direction" title="wikilink">orientation</a> of 

<math display="inline" id="Hungarian_algorithm:9">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>y</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{y}
  </annotation>
 </semantics>
</math>

 (denoted by 

<math display="inline" id="Hungarian_algorithm:10">
 <semantics>
  <mover accent="true">
   <msub>
    <mi>G</mi>
    <mi>y</mi>
   </msub>
   <mo>→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overrightarrow{G_{y}}
  </annotation>
 </semantics>
</math>

) which has the property that the edges oriented from <em>T</em> to <em>S</em> form a matching <em>M</em>. Initially, <em>y</em> is 0 everywhere, and all edges are oriented from <em>S</em> to <em>T</em> (so <em>M</em> is empty). In each step, either we modify <em>y</em> so that its value increases, or modify the orientation to obtain a matching with more edges. We maintain the invariant that all the edges of <em>M</em> are tight. We are done if <em>M</em> is a perfect matching.</p>

<p>In a general step, let 

<math display="inline" id="Hungarian_algorithm:11">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>S</mi>
   </msub>
   <mo>⊆</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>S</ci>
    </apply>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{S}\subseteq S
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hungarian_algorithm:12">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>T</mi>
   </msub>
   <mo>⊆</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>T</ci>
    </apply>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{T}\subseteq T
  </annotation>
 </semantics>
</math>

 be the vertices not covered by <em>M</em> (so 

<math display="inline" id="Hungarian_algorithm:13">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>S</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{S}
  </annotation>
 </semantics>
</math>

 consists of the vertices in <em>S</em> with no incoming edge and 

<math display="inline" id="Hungarian_algorithm:14">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>T</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{T}
  </annotation>
 </semantics>
</math>

 consists of the vertices in <em>T</em> with no outgoing edge). Let 

<math display="inline" id="Hungarian_algorithm:15">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

 be the set of vertices reachable in 

<math display="inline" id="Hungarian_algorithm:16">
 <semantics>
  <mover accent="true">
   <msub>
    <mi>G</mi>
    <mi>y</mi>
   </msub>
   <mo>→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overrightarrow{G_{y}}
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Hungarian_algorithm:17">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>S</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{S}
  </annotation>
 </semantics>
</math>

 by a directed path only following edges that are tight. This can be computed by <a href="breadth-first_search" title="wikilink">breadth-first search</a>.</p>

<p>If 

<math display="inline" id="Hungarian_algorithm:18">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>T</mi>
   </msub>
   <mo>∩</mo>
   <mi>Z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <intersect></intersect>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>T</ci>
    </apply>
    <ci>Z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{T}\cap Z
  </annotation>
 </semantics>
</math>

 is nonempty, then reverse the orientation of a directed path in 

<math display="inline" id="Hungarian_algorithm:19">
 <semantics>
  <mover accent="true">
   <msub>
    <mi>G</mi>
    <mi>y</mi>
   </msub>
   <mo>→</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overrightarrow{G_{y}}
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Hungarian_algorithm:20">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>S</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{S}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Hungarian_algorithm:21">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>T</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{T}
  </annotation>
 </semantics>
</math>

. Thus the size of the corresponding matching increases by 1.</p>

<p>If 

<math display="inline" id="Hungarian_algorithm:22">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>T</mi>
   </msub>
   <mo>∩</mo>
   <mi>Z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <intersect></intersect>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>T</ci>
    </apply>
    <ci>Z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{T}\cap Z
  </annotation>
 </semantics>
</math>

 is empty, then let 

<math display="inline" id="Hungarian_algorithm:23">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mo>:=</mo>
   <mrow>
    <mi>min</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mrow>
       <mrow>
        <mi>c</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>i</mi>
         <mo>,</mo>
         <mi>j</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>y</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>i</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>y</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>j</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mrow>
        <mi>i</mi>
        <mo>∈</mo>
        <mrow>
         <mi>Z</mi>
         <mo>∩</mo>
         <mi>S</mi>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>j</mi>
        <mo>∈</mo>
        <mrow>
         <mi>T</mi>
         <mo>∖</mo>
         <mi>Z</mi>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>normal-Δ</ci>
    <apply>
     <min></min>
     <apply>
      <ci>normal-:</ci>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>c</ci>
        <interval closure="open">
         <ci>i</ci>
         <ci>j</ci>
        </interval>
       </apply>
       <apply>
        <times></times>
        <ci>y</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <times></times>
        <ci>y</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <in></in>
        <ci>i</ci>
        <apply>
         <intersect></intersect>
         <ci>Z</ci>
         <ci>S</ci>
        </apply>
       </apply>
       <apply>
        <in></in>
        <ci>j</ci>
        <apply>
         <setdiff></setdiff>
         <ci>T</ci>
         <ci>Z</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta:=\min\{c(i,j)-y(i)-y(j):i\in Z\cap S,j\in T\setminus Z\}
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Hungarian_algorithm:24">
 <semantics>
  <mi mathvariant="normal">Δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>

 is positive because there are no tight edges between 

<math display="inline" id="Hungarian_algorithm:25">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>∩</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <intersect></intersect>
    <ci>Z</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z\cap S
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Hungarian_algorithm:26">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>∖</mo>
   <mi>Z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <setdiff></setdiff>
    <ci>T</ci>
    <ci>Z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T\setminus Z
  </annotation>
 </semantics>
</math>

. Increase <em>y</em> by 

<math display="inline" id="Hungarian_algorithm:27">
 <semantics>
  <mi mathvariant="normal">Δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>

 on the vertices of 

<math display="inline" id="Hungarian_algorithm:28">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>∩</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <intersect></intersect>
    <ci>Z</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z\cap S
  </annotation>
 </semantics>
</math>

 and decrease <em>y</em> by 

<math display="inline" id="Hungarian_algorithm:29">
 <semantics>
  <mi mathvariant="normal">Δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>

 on the vertices of 

<math display="inline" id="Hungarian_algorithm:30">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>∩</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <intersect></intersect>
    <ci>Z</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z\cap T
  </annotation>
 </semantics>
</math>

. The resulting <em>y</em> is still a potential. The graph 

<math display="inline" id="Hungarian_algorithm:31">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>y</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{y}
  </annotation>
 </semantics>
</math>

 changes, but it still contains <em>M</em>. We orient the new edges from <em>S</em> to <em>T</em>. By the definition of 

<math display="inline" id="Hungarian_algorithm:32">
 <semantics>
  <mi mathvariant="normal">Δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>

 the set <em>Z</em> of vertices reachable from 

<math display="inline" id="Hungarian_algorithm:33">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>S</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{S}
  </annotation>
 </semantics>
</math>

 increases (note that the number of tight edges does not necessarily increase).</p>

<p>We repeat these steps until <em>M</em> is a perfect matching, in which case it gives a minimum cost assignment. The running time of this version of the method is 

<math display="inline" id="Hungarian_algorithm:34">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>4</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{4})
  </annotation>
 </semantics>
</math>

: <em>M</em> is augmented <em>n</em> times, and in a phase where <em>M</em> is unchanged, there are at most <em>n</em> potential changes (since <em>Z</em> increases every time). The time needed for a potential change is 

<math display="inline" id="Hungarian_algorithm:35">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2})
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="matrix-interpretation">Matrix interpretation</h2>

<p>Given 

<math display="inline" id="Hungarian_algorithm:36">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 workers and tasks, and an <em>n</em>×<em>n</em> matrix containing the cost of assigning each worker to a task, find the cost minimizing assignment.</p>

<p>First the problem is written in the form of a matrix as given below</p>

<p>

<math display="block" id="Hungarian_algorithm:37">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="center">
      <mrow>
       <mi>a</mi>
       <mn>1</mn>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mi>a</mi>
       <mn>2</mn>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mi>a</mi>
       <mn>3</mn>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mi>a</mi>
       <mn>4</mn>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mrow>
       <mi>b</mi>
       <mn>1</mn>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mi>b</mi>
       <mn>2</mn>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mi>b</mi>
       <mn>3</mn>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mi>b</mi>
       <mn>4</mn>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mrow>
       <mi>c</mi>
       <mn>1</mn>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mi>c</mi>
       <mn>2</mn>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mi>c</mi>
       <mn>3</mn>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mi>c</mi>
       <mn>4</mn>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mrow>
       <mi>d</mi>
       <mn>1</mn>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mi>d</mi>
       <mn>2</mn>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mi>d</mi>
       <mn>3</mn>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mi>d</mi>
       <mn>4</mn>
      </mrow>
     </mtd>
    </mtr>
   </mtable>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <times></times>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <cn type="integer">4</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <times></times>
      <ci>b</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <ci>b</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <ci>b</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <times></times>
      <ci>b</ci>
      <cn type="integer">4</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <times></times>
      <ci>c</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <ci>c</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <ci>c</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <times></times>
      <ci>c</ci>
      <cn type="integer">4</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <times></times>
      <ci>d</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <cn type="integer">4</cn>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}a1&a2&a3&a4\\
b1&b2&b3&b4\\
c1&c2&c3&c4\\
d1&d2&d3&d4\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>where a, b, c and d are the workers who have to perform tasks 1, 2, 3 and 4. a1, a2, a3, a4 denote the penalties incurred when worker "a" does task 1, 2, 3, 4 respectively. The same holds true for the other symbols as well. The matrix is square, so each worker can perform only one task.</p>

<p><strong>Step 1</strong></p>

<p>Then we perform row operations on the matrix. To do this, the lowest of all <em>a<sub>i</sub></em> (i belonging to 1-4) is taken and is subtracted from each element in that row. This will lead to at least one zero in that row (We get multiple zeros when there are two equal elements which also happen to be the lowest in that row). This procedure is repeated for all rows. We now have a matrix with at least one zero per row. Now we try to assign tasks to agents such that each agent is doing only one task and the penalty incurred in each case is zero. This is illustrated below.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>a2'</p></td>
<td style="text-align: left;">
<p>a3'</p></td>
<td style="text-align: left;">
<p>a4'</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>b1'</p></td>
<td style="text-align: left;">
<p>b2'</p></td>
<td style="text-align: left;">
<p>b3'</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>c1'</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>c3'</p></td>
<td style="text-align: left;">
<p>c4'</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>d1'</p></td>
<td style="text-align: left;">
<p>d2'</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>d4'</p></td>
</tr>
</tbody>
</table>

<p>The zeros that are indicated as 0' are the assigned tasks.</p>

<p><strong>Step 2</strong></p>

<p>Sometimes it may turn out that the matrix at this stage cannot be used for assigning, as is the case in for the matrix below.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>a2'</p></td>
<td style="text-align: left;">
<p>a3'</p></td>
<td style="text-align: left;">
<p>a4'</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>b1'</p></td>
<td style="text-align: left;">
<p>b2'</p></td>
<td style="text-align: left;">
<p>b3'</p></td>
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>c2'</p></td>
<td style="text-align: left;">
<p>c3'</p></td>
<td style="text-align: left;">
<p>c4'</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>d1'</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>d3'</p></td>
<td style="text-align: left;">
<p>d4'</p></td>
</tr>
</tbody>
</table>

<p>In the above case, no assignment can be made. Note that task 1 is done efficiently by both agent a and c. Both can't be assigned the same task. Also note that no one does task 3 efficiently. To overcome this, we repeat the above procedure for all columns (i.e. the minimum element in each column is subtracted from all the elements in that column) and then check if an assignment is possible.</p>

<p>In most situations this will give the result, but if it is still not possible then we need to keep going.</p>

<p><strong>Step 3</strong></p>

<p>All zeros in the matrix must be covered by marking as few rows and/or columns as possible. The following procedure is one way to accomplish this:</p>

<p>First, assign as many tasks as possible.</p>
<ul>
<li>Row 1 has one zero, so it is assigned. The 0 in row 3 is crossed out because it is in the same column.</li>
<li>Row 2 has one zero, so it is assigned.</li>
<li>Row 3's only zero has been crossed out, so nothing is assigned.</li>
<li>Row 4 has two uncrossed zeros. Either one can be assigned (both are optimum), and the other zero would be crossed out.</li>
</ul>

<p>Alternatively, the 0 in row 3 may be assigned, causing the 0 in row 1 to be crossed instead.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>0'</p></td>
<td style="text-align: left;">
<p>a2'</p></td>
<td style="text-align: left;">
<p>a3'</p></td>
<td style="text-align: left;">
<p>a4'</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>b1'</p></td>
<td style="text-align: left;">
<p>b2'</p></td>
<td style="text-align: left;">
<p>b3'</p></td>
<td style="text-align: left;">
<p>0'</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>c2'</p></td>
<td style="text-align: left;">
<p>c3'</p></td>
<td style="text-align: left;">
<p>c4'</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>d1'</p></td>
<td style="text-align: left;">
<p>0'</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>d4'</p></td>
</tr>
</tbody>
</table>

<p>Now to the drawing part.</p>
<ul>
<li>Mark all rows having no assignments (row 3).</li>
<li>Mark all (unmarked) columns having zeros in newly marked row(s) (column 1).</li>
<li>Mark all rows having assignments in newly marked columns (row 1).</li>
<li>Repeat for all non-assigned rows.</li>
</ul>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>×</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0'</p></td>
<td style="text-align: left;">
<p>a2'</p></td>
<td style="text-align: left;">
<p>a3'</p></td>
<td style="text-align: left;">
<p>a4'</p></td>
<td style="text-align: left;">
<p>×</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>b1'</p></td>
<td style="text-align: left;">
<p>b2'</p></td>
<td style="text-align: left;">
<p>b3'</p></td>
<td style="text-align: left;">
<p>0'</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>c2'</p></td>
<td style="text-align: left;">
<p>c3'</p></td>
<td style="text-align: left;">
<p>c4'</p></td>
<td style="text-align: left;">
<p>×</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>d1'</p></td>
<td style="text-align: left;">
<p>0'</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>d4'</p></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>

<p>Now draw lines through all marked columns and <strong>unmarked</strong> rows.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>×</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0'</p></td>
<td style="text-align: left;">
<p>a2'</p></td>
<td style="text-align: left;">
<p>a3'</p></td>
<td style="text-align: left;">
<p>a4'</p></td>
<td style="text-align: left;">
<p>×</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>b1'</p></td>
<td style="text-align: left;">
<p>b2'</p></td>
<td style="text-align: left;">
<p>b3'</p></td>
<td style="text-align: left;">
<p>0'</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>c2'</p></td>
<td style="text-align: left;">
<p>c3'</p></td>
<td style="text-align: left;">
<p>c4'</p></td>
<td style="text-align: left;">
<p>×</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>d1'</p></td>
<td style="text-align: left;">
<p>0'</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>d4'</p></td>
</tr>
</tbody>
</table>

<p>The aforementioned detailed description is just one way to draw the minimum number of lines to cover all the 0s. Other methods work as well.</p>

<p><strong>Step 4</strong></p>

<p>Now remove the marked rows and columns. This will leave a matrix as follows:</p>

<p>

<math display="block" id="Hungarian_algorithm:38">
 <semantics>
  <mrow>
   <mo>[</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="center">
      <mrow>
       <mi>a</mi>
       <mn>2</mn>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mi>a</mi>
       <mn>3</mn>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mi>a</mi>
       <mn>4</mn>
      </mrow>
     </mtd>
    </mtr>
    <mtr>
     <mtd columnalign="center">
      <mrow>
       <mi>c</mi>
       <mn>2</mn>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mi>c</mi>
       <mn>3</mn>
      </mrow>
     </mtd>
     <mtd columnalign="center">
      <mrow>
       <mi>c</mi>
       <mn>4</mn>
      </mrow>
     </mtd>
    </mtr>
   </mtable>
   <mo>]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <times></times>
      <ci>a</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <times></times>
      <ci>a</ci>
      <cn type="integer">4</cn>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <times></times>
      <ci>c</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <times></times>
      <ci>c</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <times></times>
      <ci>c</ci>
      <cn type="integer">4</cn>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{bmatrix}a2&a3&a4\\
c2&c3&c4\end{bmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>Return to step 1 and repeat the process until the matrix is empty.</p>
<h2 id="bibliography">Bibliography</h2>
<ul>
<li>R.E. Burkard, M. Dell'Amico, S. Martello: <em>Assignment Problems</em> (Revised reprint). SIAM, Philadelphia (PA.) 2012. ISBN 978-1-61197-222-1</li>
<li>M. Fischetti, "Lezioni di Ricerca Operativa", Edizioni Libreria Progetto Padova, Italia, 1995.</li>
<li><a href="Ravindra_K._Ahuja" title="wikilink">R. Ahuja</a>, <a href="Thomas_L._Magnanti" title="wikilink">T. Magnanti</a>, <a href="James_B._Orlin" title="wikilink">J. Orlin</a>, "Network Flows", Prentice Hall, 1993.</li>
<li>S. Martello, "Jeno Egerváry: from the origins of the Hungarian algorithm to satellite communication". Central European Journal of Operations Research 18, 47–58, 2010</li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li>Bruff, Derek, "The Assignment Problem and the Hungarian Method", <a href="http://www.math.harvard.edu/archive/20_spring_05/handouts/assignment_overheads.pdf">1</a></li>
<li>Mordecai J. Golin, <a href="http://www.cse.ust.hk/~golin/COMP572/Notes/Matching.pdf">Bipartite Matching and the Hungarian Method</a>, Course Notes, <a href="Hong_Kong_University_of_Science_and_Technology" title="wikilink">Hong Kong University of Science and Technology</a>.</li>
<li><a href="R._A._Pilgrim" title="wikilink">R. A. Pilgrim</a>, <em><a href="http://csclab.murraystate.edu/bob.pilgrim/445/munkres.html">Munkres' Assignment Algorithm. Modified for Rectangular Matrices</a></em>, Course notes, <a href="Murray_State_University" title="wikilink">Murray State University</a>.</li>
<li><a href="Mike_Dawes" title="wikilink">Mike Dawes</a>, <em><a href="http://www.math.uwo.ca/~mdawes/courses/344/kuhn-munkres.pdf">The Optimal Assignment Problem</a></em>, Course notes, <a href="University_of_Western_Ontario" title="wikilink">University of Western Ontario</a>.</li>
<li><a href="http://www.cs.elte.hu/egres/tr/egres-04-14.pdf">On Kuhn's Hungarian Method – A tribute from Hungary</a>, <a href="András_Frank" title="wikilink">András Frank</a>, Egervary Research Group, Pazmany P. setany 1/C, H1117, Budapest, Hungary.</li>
<li>Lecture: <a href="https://www.youtube.com/watch?v=BUGIhEecipE">Fundamentals of Operations Research - Assignment Problem - Hungarian Algorithm</a>, Prof. G. Srinivasan, Department of Management Studies, IIT Madras.</li>
<li>Extension: <a href="http://www.roboticsproceedings.org/rss06/p16.html">Assignment sensitivity analysis (with O(n^4) time complexity)</a>, Liu, Shell.</li>
<li><a href="http://www.hungarianalgorithm.com/solve.php">Solve any Assignment Problem online</a>, provides a step by step explanation of the Hungarian Algorithm.</li>
</ul>
<h3 id="implementations">Implementations</h3>

<p>(Note that not all of these satisfy the 

<math display="inline" id="Hungarian_algorithm:39">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{3})
  </annotation>
 </semantics>
</math>

 time constraint.)</p>
<ul>
<li><a href="https://github.com/maandree/hungarian-algorithm-n3/blob/master/hungarian.c">C implementation with 

<math display="inline" id="Hungarian_algorithm:40">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{3})
  </annotation>
 </semantics>
</math>

 time complexity</a></li>
<li><a href="https://github.com/KevinStern/software-and-algorithms/blob/master/src/main/java/blogspot/software_and_algorithms/stern_library/optimization/HungarianAlgorithm.java">Java implementation of 

<math display="inline" id="Hungarian_algorithm:41">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{3})
  </annotation>
 </semantics>
</math>

 time variant</a></li>
<li><a href="http://software.clapper.org/munkres/">Python implementation</a> (see also <a href="https://github.com/xtof-durr/makeSimple/blob/master/Munkres/kuhnMunkres.py">here</a>)</li>
<li><a href="https://github.com/evansenter/gene/blob/f515fd73cb9d6a22b4d4b146d70b6c2ec6a5125b/objects/extensions/hungarian.rb">Ruby implementation with unit tests</a></li>
<li><a href="http://noldorin.com/blog/2009/09/hungarian-algorithm-in-csharp/">C# implementation</a></li>
<li><a href="http://www.fantascienza.net/leonardo/so/hungarian.d">D implementation with unit tests (port of the Java 

<math display="inline" id="Hungarian_algorithm:42">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{3})
  </annotation>
 </semantics>
</math>

 version)</a></li>
<li><a href="http://www.ifors.ms.unimelb.edu.au/tutorial/hungarian/welcome_frame.html">Online interactive implementation</a> Please note that this implements a variant of the algorithm as described above.</li>
<li><a href="http://web.axelero.hu/szilardandras/gaps.html">Graphical implementation with options</a> (<a href="Java_applet" title="wikilink">Java applet</a>)</li>
<li><a href="http://www.netlib.org/utk/lsi/pcwLSI/text/node220.html">Serial and parallel implementations.</a></li>
<li><a href="http://www.mathworks.com/matlabcentral/fileexchange/loadFile.do?objectId=6543">Implementation in Matlab and C</a></li>
<li>[<a class="uri" href="https://metacpan.org/module/Algorithm">https://metacpan.org/module/Algorithm</a>::Munkres Perl implementation]</li>
<li><a href="http://www.koders.com/lisp/fid7C3730AF4E356C65F93F20A6410814CBF5F40854.aspx?s=iso+3166">Lisp implementation</a></li>
<li><a href="http://students.cse.tamu.edu/lantao/codes/codes.php">C++ (STL) implementation (multi-functional bipartite graph version)</a></li>
<li><a href="https://github.com/saebyn/munkres-cpp">C++ implementation</a></li>
<li><a href="http://dlib.net/optimization.html#max_cost_assignment">C++ implementation of the 

<math display="inline" id="Hungarian_algorithm:43">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{3})
  </annotation>
 </semantics>
</math>

 algorithm</a> (BSD style open source licensed)</li>
<li>[<a class="uri" href="http://www.topcoder.com/tc?module=Static&amp;d1">http://www.topcoder.com/tc?module=Static&amp;d1;</a>;=tutorials&amp;d2;=hungarianAlgorithm Another C++ implementation with unit tests]</li>
<li><a href="http://timefinder.svn.sourceforge.net/viewvc/timefinder/trunk/timefinder-algo/src/main/java/de/timefinder/algo/roomassignment/">Another Java implementation with JUnit tests (Apache 2.0)</a></li>
<li><a href="http://www.mathworks.com/matlabcentral/fileexchange/11609">MATLAB implementation</a></li>
<li><a href="https://launchpad.net/lib-bipartite-match">C implementation</a></li>
<li><a href="http://twofourone.blogspot.com/2009/01/hungarian-algorithm-in-javascript.html">Javascript implementation</a></li>
<li><a href="http://cran.r-project.org/web/packages/clue/clue.pdf">The clue R package proposes an implementation, solve_LSAP</a></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Matching" title="wikilink">Category:Matching</a> <a href="Category:Combinatorial_optimization" title="wikilink">Category:Combinatorial optimization</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Harold W. Kuhn, "The Hungarian Method for the assignment problem", <em><a href="Naval_Research_Logistics_Quarterly" title="wikilink">Naval Research Logistics Quarterly</a></em>, <strong>2</strong>: 83–97, 1955. Kuhn's original publication.<a href="#fnref1">↩</a></li>
<li id="fn2">Harold W. Kuhn, "Variants of the Hungarian method for assignment problems", <em>Naval Research Logistics Quarterly</em>, <strong>3</strong>: 253–258, 1956.<a href="#fnref2">↩</a></li>
<li id="fn3">J. Munkres, "Algorithms for the Assignment and Transportation Problems", <em><a href="Journal_of_the_Society_for_Industrial_and_Applied_Mathematics" title="wikilink">Journal of the Society for Industrial and Applied Mathematics</a></em>, <strong>5</strong>(1):32–38, 1957 March.<a href="#fnref3">↩</a></li>
<li id="fn4"><a class="uri" href="http://www.lix.polytechnique.fr/~ollivier/JACOBI/jacobiEngl.htm">http://www.lix.polytechnique.fr/~ollivier/JACOBI/jacobiEngl.htm</a><a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
