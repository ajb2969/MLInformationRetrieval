<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="3">Quantization (signal processing)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Quantization (signal processing)</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>The simplest way to quantize a signal is to choose the digital amplitude value closest to the original analog amplitude. This example shows the original analog signal (green), the quantized signal (black dots), the <a href="Signal_reconstruction" title="wikilink">signal reconstructed</a> from the quantized signal (yellow) and the difference between the original signal and the reconstructed signal (red). The difference between the original signal and the reconstructed signal is the quantization error and, in this simple quantization scheme, is a deterministic function of the input signal.</figcaption>
</figure>

<p><strong>Quantization</strong>, in mathematics and <a href="digital_signal_processing" title="wikilink">digital signal processing</a>, is the process of mapping a large set of input values to a (countable) smaller set. <a class="uri" href="Rounding" title="wikilink">Rounding</a> and <a class="uri" href="truncation" title="wikilink">truncation</a> are typical examples of quantization processes. Quantization is involved to some degree in nearly all digital signal processing, as the process of representing a signal in digital form ordinarily involves rounding. Quantization also forms the core of essentially all <a href="lossy_compression" title="wikilink">lossy compression</a> algorithms. The difference between an input value and its quantized value (such as <a href="round-off_error" title="wikilink">round-off error</a>) is referred to as <strong>quantization error</strong>. A device or <a href="algorithm_function" title="wikilink">algorithmic function</a> that performs quantization is called a <strong>quantizer</strong>. An <a href="analog-to-digital_converter" title="wikilink">analog-to-digital converter</a> is an example of a quantizer.</p>
<h2 id="basic-properties-of-quantization">Basic properties of quantization</h2>

<p>Because quantization is a many-to-few mapping, it is an inherently <a href="Nonlinear_system" title="wikilink">non-linear</a> and irreversible process (i.e., because the same output value is shared by multiple input values, it is impossible in general to recover the exact input value when given only the output value).</p>

<p>The set of possible input values may be infinitely large, and may possibly be continuous and therefore <a class="uri" href="uncountable" title="wikilink">uncountable</a> (such as the set of all <a href="real_number" title="wikilink">real numbers</a>, or all real numbers within some limited range). The set of possible output values may be <a href="finite_set" title="wikilink">finite</a> or <a href="Countable_set" title="wikilink">countably infinite</a>. The input and output sets involved in quantization can be defined in a rather general way. For example, <em><a href="vector_quantization" title="wikilink">vector quantization</a></em> is the application of quantization to multi-dimensional (vector-valued) input data.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="basic-types-of-quantization">Basic types of quantization</h2>

<p> </p>
<h3 id="analog-to-digital-converter-adc">Analog-to-digital converter (ADC)</h3>

<p>Outside the realm of signal processing, this category may simply be called <em>rounding</em> or <em>scalar quantization</em>. An ADC can be modeled as two processes: <a href="Sampling_(signal_processing)" title="wikilink">sampling</a> and <strong>quantization</strong>. Sampling converts a voltage signal (function of time) into a <a href="discrete-time_signal" title="wikilink">discrete-time signal</a> (sequence of <a href="real_numbers" title="wikilink">real numbers</a>). Quantization replaces each real number with an approximation from a finite set of discrete values (<strong>levels</strong>), which is necessary for storage and processing by numerical methods. Most commonly, these discrete values are represented as fixed-point words (either proportional to the waveform values or companded) or floating-point words. Common word-lengths are <a class="uri" href="8-bit" title="wikilink">8-bit</a> (256 levels), <a class="uri" href="16-bit" title="wikilink">16-bit</a> (65,536 levels), <a class="uri" href="32-bit" title="wikilink">32-bit</a> (4.3 billion levels), and so on, though any number of quantization levels is possible (not just <a href="power_of_two" title="wikilink">powers of two</a>). Quantizing a sequence of numbers produces a sequence of quantization errors which is sometimes modeled as an additive random signal called <strong>quantization noise</strong> because of its <a class="uri" href="stochastic" title="wikilink">stochastic</a> behavior. The more levels a quantizer uses, the lower is its quantization noise power.</p>

<p>In general, both ADC processes lose some information. So discrete-valued signals are only an approximation of the continuous-valued discrete-time signal, which is itself only an approximation of the original continuous-valued continuous-time signal. But both types of approximation errors can, in theory, be made arbitrarily small by good design.</p>
<h3 id="ratedistortion-optimization">Rate–distortion optimization</h3>

<p><em>Rate–distortion optimized</em> quantization is encountered in <a href="source_coding" title="wikilink">source coding</a> for "lossy" data compression algorithms, where the purpose is to manage distortion within the limits of the bit rate supported by a communication channel or storage medium. In this second setting, the amount of introduced distortion may be managed carefully by sophisticated techniques, and introducing some significant amount of distortion may be unavoidable. A quantizer designed for this purpose may be quite different and more elaborate in design than an ordinary rounding operation. It is in this domain that substantial <a href="rate–distortion_theory" title="wikilink">rate–distortion theory</a> analysis is likely to be applied. However, the same concepts actually apply in both use cases.</p>

<p>The analysis of quantization involves studying the amount of data (typically measured in digits or bits or bit <em>rate</em>) that is used to represent the output of the quantizer, and studying the loss of precision that is introduced by the quantization process (which is referred to as the <em>distortion</em>). The general field of such study of rate and distortion is known as <em><a href="rate–distortion_theory" title="wikilink">rate–distortion theory</a></em>.</p>
<h2 id="rounding-example">Rounding example</h2>

<p>As an example, <a class="uri" href="rounding" title="wikilink">rounding</a> a <a href="real_number" title="wikilink">real number</a> 

<math display="inline" id="Quantization_(signal_processing):0">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 to the nearest integer value forms a very basic type of quantizer – a <em>uniform</em> one. A typical (<em>mid-tread</em>) uniform quantizer with a quantization <em>step size</em> equal to some value 

<math display="inline" id="Quantization_(signal_processing):1">
 <semantics>
  <mi mathvariant="normal">Δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>

 can be expressed as</p>

<p>

<math display="block" id="Quantization_(signal_processing):2">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>sgn</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⋅</mo>
    <mi mathvariant="normal">Δ</mi>
    <mo>⋅</mo>
    <mrow>
     <mo>⌊</mo>
     <mrow>
      <mfrac>
       <mrow>
        <mo>|</mo>
        <mi>x</mi>
        <mo>|</mo>
       </mrow>
       <mi mathvariant="normal">Δ</mi>
      </mfrac>
      <mo>+</mo>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
     </mrow>
     <mo>⌋</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <ci>sgn</ci>
      <ci>x</ci>
     </apply>
     <ci>normal-Δ</ci>
     <apply>
      <floor></floor>
      <apply>
       <plus></plus>
       <apply>
        <divide></divide>
        <apply>
         <abs></abs>
         <ci>x</ci>
        </apply>
        <ci>normal-Δ</ci>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x)=\operatorname{sgn}(x)\cdot\Delta\cdot\left\lfloor\frac{\left|x\right|}{%
\Delta}+\frac{1}{2}\right\rfloor
  </annotation>
 </semantics>
</math>

, where the function 

<math display="inline" id="Quantization_(signal_processing):3">
 <semantics>
  <mo>sgn</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>sgn</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{sgn}
  </annotation>
 </semantics>
</math>

( ) is the <a href="sign_function" title="wikilink">sign function</a> (also known as the <em>signum</em> function). For simple rounding to the nearest integer, the step size 

<math display="inline" id="Quantization_(signal_processing):4">
 <semantics>
  <mi mathvariant="normal">Δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>

 is equal to 1. With 

<math display="inline" id="Quantization_(signal_processing):5">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Δ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta=1
  </annotation>
 </semantics>
</math>

 or with 

<math display="inline" id="Quantization_(signal_processing):6">
 <semantics>
  <mi mathvariant="normal">Δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>

 equal to any other integer value, this quantizer has real-valued inputs and integer-valued outputs, although this property is not a necessity – a quantizer may also have an integer input domain and may also have non-integer output values. The essential property of a quantizer is that it has a countable set of possible output values that has fewer members than the set of possible input values. The members of the set of output values may have integer, rational, or real values (or even other possible values as well, in general – such as vector values or <a href="complex_number" title="wikilink">complex numbers</a>).</p>

<p>When the quantization step size is small (relative to the variation in the signal being measured), it is relatively simple to show<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> that the <a href="mean_squared_error" title="wikilink">mean squared error</a> produced by such a rounding operation will be approximately 

<math display="inline" id="Quantization_(signal_processing):7">
 <semantics>
  <mrow>
   <msup>
    <mi mathvariant="normal">Δ</mi>
    <mn>2</mn>
   </msup>
   <mo>/</mo>
   <mn>12</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Δ</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">12</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta^{2}/12
  </annotation>
 </semantics>
</math>

. Mean squared error is also called the quantization <strong>noise power</strong>. Adding one bit to the quantizer halves the value of Δ, which reduces the noise power by the factor ¼.  In terms of decibels, the noise power change is  

<math display="inline" id="Quantization_(signal_processing):8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mn>10</mn>
     <mo>⋅</mo>
     <mrow>
      <msub>
       <mi>log</mi>
       <mn>10</mn>
      </msub>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mn>1</mn>
        <mn>4</mn>
       </mfrac>
       <mo rspace="7.5pt">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="7.5pt">=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mpadded width="+5pt">
       <mn>6</mn>
      </mpadded>
      <mi>dB</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <cn type="integer">10</cn>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <cn type="integer">10</cn>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">4</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <cn type="integer">6</cn>
      <ci>dB</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle 10\cdot\log_{10}\left(\tfrac{1}{4}\right)\ =\ -6\ \mathrm{dB}.
  </annotation>
 </semantics>
</math>

</p>

<p>Because the set of possible output values of a quantizer is countable, any quantizer can be decomposed into two distinct stages, which can be referred to as the <em>classification</em> stage (or <em>forward quantization</em> stage) and the <em>reconstruction</em> stage (or <em>inverse quantization</em> stage), where the classification stage maps the input value to an integer <em>quantization index</em> 

<math display="inline" id="Quantization_(signal_processing):9">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 and the reconstruction stage maps the index 

<math display="inline" id="Quantization_(signal_processing):10">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 to the <em>reconstruction value</em> 

<math display="inline" id="Quantization_(signal_processing):11">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}
  </annotation>
 </semantics>
</math>

 that is the output approximation of the input value. For the example uniform quantizer described above, the forward quantization stage can be expressed as</p>

<p>

<math display="block" id="Quantization_(signal_processing):12">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>sgn</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>⋅</mo>
    <mrow>
     <mo>⌊</mo>
     <mrow>
      <mfrac>
       <mrow>
        <mo>|</mo>
        <mi>x</mi>
        <mo>|</mo>
       </mrow>
       <mi mathvariant="normal">Δ</mi>
      </mfrac>
      <mo>+</mo>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
     </mrow>
     <mo>⌋</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <ci>sgn</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <floor></floor>
      <apply>
       <plus></plus>
       <apply>
        <divide></divide>
        <apply>
         <abs></abs>
         <ci>x</ci>
        </apply>
        <ci>normal-Δ</ci>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=\operatorname{sgn}(x)\cdot\left\lfloor\frac{\left|x\right|}{\Delta}+\frac{1}%
{2}\right\rfloor
  </annotation>
 </semantics>
</math>

, and the reconstruction stage for this example quantizer is simply 

<math display="inline" id="Quantization_(signal_processing):13">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>k</mi>
    <mo>⋅</mo>
    <mi mathvariant="normal">Δ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <ci>k</ci>
     <ci>normal-Δ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}=k\cdot\Delta
  </annotation>
 </semantics>
</math>

.</p>

<p>This decomposition is useful for the design and analysis of quantization behavior, and it illustrates how the quantized data can be communicated over a communication channel – a <em>source encoder</em> can perform the forward quantization stage and send the index information through a communication channel (possibly applying <a href="entropy_coding" title="wikilink">entropy coding</a> techniques to the quantization indices), and a <em>decoder</em> can perform the reconstruction stage to produce the output approximation of the original input data. In more elaborate quantization designs, both the forward and inverse quantization stages may be substantially more complex. In general, the forward quantization stage may use any function that maps the input data to the integer space of the quantization index data, and the inverse quantization stage can conceptually (or literally) be a table look-up operation to map each quantization index to a corresponding reconstruction value. This two-stage decomposition applies equally well to <a href="vector_quantization" title="wikilink">vector</a> as well as scalar quantizers.</p>
<h2 id="mid-riser-and-mid-tread-uniform-quantizers">Mid-riser and mid-tread uniform quantizers</h2>

<p>Most uniform quantizers for signed input data can be classified as being of one of two types: <strong>mid-riser</strong> and <strong>mid-tread</strong>. The terminology is based on what happens in the region around the value 0, and uses the analogy of viewing the input-output function of the quantizer as a <a class="uri" href="stairway" title="wikilink">stairway</a>. Mid-tread quantizers have a zero-valued reconstruction level (corresponding to a <em>tread</em> of a stairway), while mid-riser quantizers have a zero-valued classification threshold (corresponding to a <em><a href="Stair_riser" title="wikilink">riser</a></em> of a stairway).<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>The formulas for mid-tread uniform quantization are provided above.</p>

<p>The input-output formula for a mid-riser uniform quantizer is given by:</p>

<p>

<math display="block" id="Quantization_(signal_processing):14">
 <semantics>
  <mrow>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mo>⋅</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mo>⌊</mo>
       <mfrac>
        <mi>x</mi>
        <mi mathvariant="normal">Δ</mi>
       </mfrac>
       <mo>⌋</mo>
      </mrow>
      <mo>+</mo>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <ci>normal-Δ</ci>
     <apply>
      <plus></plus>
      <apply>
       <floor></floor>
       <apply>
        <divide></divide>
        <ci>x</ci>
        <ci>normal-Δ</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q(x)=\Delta\cdot\left(\left\lfloor\frac{x}{\Delta}\right\rfloor+\frac{1}{2}\right)
  </annotation>
 </semantics>
</math>

, where the classification rule is given by</p>

<p>

<math display="block" id="Quantization_(signal_processing):15">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mo>⌊</mo>
    <mfrac>
     <mi>x</mi>
     <mi mathvariant="normal">Δ</mi>
    </mfrac>
    <mo>⌋</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <apply>
     <floor></floor>
     <apply>
      <divide></divide>
      <ci>x</ci>
      <ci>normal-Δ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=\left\lfloor\frac{x}{\Delta}\right\rfloor
  </annotation>
 </semantics>
</math>

 and the reconstruction rule is</p>

<p>

<math display="block" id="Quantization_(signal_processing):16">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mo>⋅</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mstyle displaystyle="false">
       <mfrac>
        <mn>1</mn>
        <mn>2</mn>
       </mfrac>
      </mstyle>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <ci>normal-Δ</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}=\Delta\cdot\left(k+\tfrac{1}{2}\right)
  </annotation>
 </semantics>
</math>

.</p>

<p>Note that mid-riser uniform quantizers do not have a zero output value – their minimum output magnitude is half the step size. When the input data can be modeled as a <a href="random_variable" title="wikilink">random variable</a> with a <a href="probability_density_function" title="wikilink">probability density function</a> (pdf) that is smooth and symmetric around zero, mid-riser quantizers also always produce an output <em><a href="Entropy_(information_theory)" title="wikilink">entropy</a></em> of at least 1 bit per sample.</p>

<p>In contrast, mid-tread quantizers do have a zero output level, and can reach arbitrarily low bit rates per sample for input distributions that are symmetric and taper off at higher magnitudes. For some applications, having a zero output signal representation or supporting low output entropy may be a necessity. In such cases, using a mid-tread uniform quantizer may be appropriate while using a mid-riser one would not be.</p>

<p>In general, a mid-riser or mid-tread quantizer may not actually be a <em>uniform</em> quantizer – i.e., the size of the quantizer's classification intervals may not all be the same, or the spacing between its possible output values may not all be the same. The distinguishing characteristic of a mid-riser quantizer is that it has a classification threshold value that is exactly zero, and the distinguishing characteristic of a mid-tread quantizer is that is it has a reconstruction value that is exactly zero.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>Another name for a mid-tread quantizer is <strong>dead-zone quantizer</strong>, and the classification region around the zero output value of such a quantizer is referred to as the <em>dead zone</em>. The dead zone can sometimes serve the same purpose as a <a href="noise_gate" title="wikilink">noise gate</a> or <a class="uri" href="squelch" title="wikilink">squelch</a> function.</p>
<h2 id="granular-distortion-and-overload-distortion">Granular distortion and overload distortion</h2>

<p>Often the design of a quantizer involves supporting only a limited range of possible output values and performing clipping to limit the output to this range whenever the input exceeds the supported range. The error introduced by this clipping is referred to as <em>overload</em> distortion. Within the extreme limits of the supported range, the amount of spacing between the selectable output values of a quantizer is referred to as its <em>granularity</em>, and the error introduced by this spacing is referred to as <em>granular</em> distortion. It is common for the design of a quantizer to involve determining the proper balance between granular distortion and overload distortion. For a given supported number of possible output values, reducing the average granular distortion may involve increasing the average overload distortion, and vice versa. A technique for controlling the amplitude of the signal (or, equivalently, the quantization step size 

<math display="inline" id="Quantization_(signal_processing):17">
 <semantics>
  <mi mathvariant="normal">Δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>

) to achieve the appropriate balance is the use of <em><a href="automatic_gain_control" title="wikilink">automatic gain control</a></em> (AGC). However, in some quantizer designs, the concepts of granular error and overload error may not apply (e.g., for a quantizer with a limited range of input data or with a countably infinite set of selectable output values).</p>
<h2 id="the-additive-noise-model-for-quantization-error">The additive noise model for quantization error</h2>

<p>A common assumption for the analysis of <a href="quantization_error" title="wikilink">quantization error</a> is that it affects a signal processing system in a similar manner to that of additive <a href="white_noise" title="wikilink">white noise</a> – having negligible correlation with the signal and an approximately flat <a href="power_spectral_density" title="wikilink">power spectral density</a>.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> The additive noise model is commonly used for the analysis of quantization error effects in digital filtering systems, and it can be very useful in such analysis. It has been shown to be a valid model in cases of high resolution quantization (small 

<math display="inline" id="Quantization_(signal_processing):18">
 <semantics>
  <mi mathvariant="normal">Δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>

 relative to the signal strength) with smooth probability density functions.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> However, additive noise behaviour is not always a valid assumption, and care should be taken to avoid assuming that this model always applies. In actuality, the quantization error (for quantizers defined as described here) is deterministically related to the signal rather than being independent of it.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a>  Thus, periodic signals can create periodic quantization noise. And in some cases it can even cause <a href="limit_cycle" title="wikilink">limit cycles</a> to appear in digital signal processing systems.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>

<p>One way to ensure effective independence of the quantization error from the source signal is to perform <em><a href="dither" title="wikilink">dithered</a> quantization</em> (sometimes with <em><a href="noise_shaping" title="wikilink">noise shaping</a></em>), which involves adding random (or <a class="uri" href="pseudo-random" title="wikilink">pseudo-random</a>) noise to the signal prior to quantization.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> This can sometimes be beneficial for such purposes as improving the subjective quality of the result, however it can increase the total quantity of error introduced by the quantization process.</p>
<h2 id="quantization-error-models">Quantization error models</h2>

<p>In the typical case, the original signal is much larger than one <a href="least_significant_bit" title="wikilink">least significant bit (LSB)</a>. When this is the case, the quantization error is not significantly correlated with the signal, and has an approximately <a href="uniform_distribution_(continuous)" title="wikilink">uniform distribution</a>. In the rounding case, the quantization error has a mean of zero and the <a href="root_mean_square" title="wikilink">RMS</a> value is the <a href="standard_deviation" title="wikilink">standard deviation</a> of this distribution, given by 

<math display="inline" id="Quantization_(signal_processing):19">
 <semantics>
  <mrow>
   <mrow>
    <mstyle scriptlevel="+1">
     <mfrac>
      <mn>1</mn>
      <msqrt>
       <mn>12</mn>
      </msqrt>
     </mfrac>
    </mstyle>
    <mpadded width="+5pt">
     <mi>LSB</mi>
    </mpadded>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mn>0.289</mn>
    </mpadded>
    <mi>LSB</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <cn type="integer">12</cn>
      </apply>
     </apply>
     <ci>LSB</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="float">0.289</cn>
     <ci>LSB</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle{\frac{1}{\sqrt{12}}}\mathrm{LSB}\ \approx\ 0.289\,\mathrm{LSB}
  </annotation>
 </semantics>
</math>

. In the truncation case the error has a non-zero mean of 

<math display="inline" id="Quantization_(signal_processing):20">
 <semantics>
  <mrow>
   <mstyle scriptlevel="+1">
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
   </mstyle>
   <mi>LSB</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
    <ci>LSB</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle{\frac{1}{2}}\mathrm{LSB}
  </annotation>
 </semantics>
</math>

 and the RMS value is 

<math display="inline" id="Quantization_(signal_processing):21">
 <semantics>
  <mrow>
   <mstyle scriptlevel="+1">
    <mfrac>
     <mn>1</mn>
     <msqrt>
      <mn>3</mn>
     </msqrt>
    </mfrac>
   </mstyle>
   <mi>LSB</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <root></root>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <ci>LSB</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle{\frac{1}{\sqrt{3}}}\mathrm{LSB}
  </annotation>
 </semantics>
</math>

. In either case, the standard deviation, as a percentage of the full signal range, changes by a factor of 2 for each 1-bit change in the number of quantizer bits. The potential signal-to-quantization-noise power ratio therefore changes by 4, or  

<math display="inline" id="Quantization_(signal_processing):22">
 <semantics>
  <mrow>
   <mrow>
    <mn>10</mn>
    <mo>⋅</mo>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>10</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>4</mn>
      <mo rspace="7.5pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>6.02</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-⋅</ci>
     <cn type="integer">10</cn>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <cn type="integer">10</cn>
      </apply>
      <cn type="integer">4</cn>
     </apply>
    </apply>
    <cn type="float">6.02</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle 10\cdot\log_{10}(4)\ =\ 6.02
  </annotation>
 </semantics>
</math>

  <em>decibels per bit</em>.</p>

<p>At lower amplitudes the quantization error becomes dependent on the input signal, resulting in distortion. This distortion is created after the anti-aliasing filter, and if these distortions are above 1/2 the sample rate they will alias back into the band of interest. In order to make the quantization error independent of the input signal, noise with an amplitude of 2 least significant bits is added to the signal. This slightly reduces signal to noise ratio, but, ideally, completely eliminates the distortion. It is known as <a class="uri" href="dither" title="wikilink">dither</a>.</p>
<h2 id="quantization-noise-model">Quantization noise model</h2>

<p> </p>

<p>Quantization noise is a <a href="Model_(abstract)" title="wikilink">model</a> of quantization error introduced by quantization in the <a href="Analog-to-digital_converter" title="wikilink">analog-to-digital conversion</a> (ADC) in <a href="Communications_system" title="wikilink">telecommunication systems</a> and <a href="Digital_signal_processing" title="wikilink">signal processing</a>. It is a rounding error between the analog input voltage to the ADC and the output digitized value. The noise is non-linear and signal-dependent. It can be modelled in several different ways.</p>

<p>In an ideal analog-to-digital converter, where the quantization error is uniformly distributed between −1/2 LSB and +1/2 LSB, and the signal has a uniform distribution covering all quantization levels, the <a href="Signal-to-quantization-noise_ratio" title="wikilink">Signal-to-quantization-noise ratio</a> (SQNR) can be calculated from</p>

<p>

<math display="block" id="Quantization_(signal_processing):23">
 <semantics>
  <mrow>
   <mi>SQNR</mi>
   <mo>=</mo>
   <mrow>
    <mn>20</mn>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>10</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mn>2</mn>
       <mi>Q</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mrow>
     <mn>6.02</mn>
     <mo>⋅</mo>
     <mpadded width="+5pt">
      <mi>Q</mi>
     </mpadded>
    </mrow>
    <mi>dB</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>SQNR</ci>
     <apply>
      <times></times>
      <cn type="integer">20</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <log></log>
        <cn type="integer">10</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <ci>Q</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <approx></approx>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <cn type="float">6.02</cn>
       <ci>Q</ci>
      </apply>
      <ci>dB</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{SQNR}=20\log_{10}(2^{Q})\approx 6.02\cdot Q\ \mathrm{dB}\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>Where Q is the number of quantization bits.</p>

<p>The most common test signals that fulfill this are full amplitude <a href="triangle_wave" title="wikilink">triangle waves</a> and <a href="sawtooth_wave" title="wikilink">sawtooth waves</a>.</p>

<p>For example, a <a class="uri" href="16-bit" title="wikilink">16-bit</a> ADC has a maximum signal-to-noise ratio of 6.02 × 16 = 96.3 dB.</p>

<p>When the input signal is a full-amplitude <a href="sine_wave" title="wikilink">sine wave</a> the distribution of the signal is no longer uniform, and the corresponding equation is instead</p>

<p>

<math display="block" id="Quantization_(signal_processing):24">
 <semantics>
  <mrow>
   <mi>SQNR</mi>
   <mo>≈</mo>
   <mrow>
    <mn>1.761</mn>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mn>6.02</mn>
      <mo>⋅</mo>
      <mpadded width="+5pt">
       <mi>Q</mi>
      </mpadded>
     </mrow>
     <mi>dB</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <ci>SQNR</ci>
    <apply>
     <plus></plus>
     <cn type="float">1.761</cn>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <cn type="float">6.02</cn>
       <ci>Q</ci>
      </apply>
      <ci>dB</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{SQNR}\approx 1.761+6.02\cdot Q\ \mathrm{dB}\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>Here, the quantization noise is once again <em>assumed</em> to be uniformly distributed. When the input signal has a high amplitude and a wide frequency spectrum this is the case.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> In this case a 16-bit ADC has a maximum signal-to-noise ratio of 98.09 dB. The 1.761 difference in signal-to-noise only occurs due to the signal being a full-scale sine wave instead of a triangle/sawtooth.</p>

<p>Quantization noise power can be derived from</p>

<p>

<math display="block" id="Quantization_(signal_processing):25">
 <semantics>
  <mrow>
   <mi mathvariant="normal">N</mi>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>δ</mi>
        <mi mathvariant="normal">v</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mn>12</mn>
    </mfrac>
    <mi mathvariant="normal">W</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-N</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <ci>δ</ci>
        <ci>normal-v</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">12</cn>
     </apply>
     <ci>normal-W</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{N}=\frac{(\delta\mathrm{v})^{2}}{12}\mathrm{W}\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Quantization_(signal_processing):26">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mi mathvariant="normal">v</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>δ</ci>
    <ci>normal-v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta\mathrm{v}
  </annotation>
 </semantics>
</math>

 is the voltage of the level.</p>

<p>(Typical real-life values are worse than this theoretical minimum, due to the addition of <a class="uri" href="dither" title="wikilink">dither</a> to reduce the objectionable effects of quantization, and to imperfections of the ADC circuitry. Also see <a href="noise_shaping" title="wikilink">noise shaping</a>.)</p>

<p>For complex signals in high-resolution ADCs this is an accurate model. For low-resolution ADCs, low-level signals in high-resolution ADCs, and for simple waveforms the quantization noise is not uniformly distributed, making this model inaccurate.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> In these cases the quantization noise distribution is strongly affected by the exact amplitude of the signal.</p>

<p>The calculations above, however, assume a completely filled input channel. If this is not the case - if the input signal is small - the relative quantization distortion can be very large. To circumvent this issue, analog <a href="dynamic_range_compression" title="wikilink">compressors and expanders</a> can be used, but these introduce large amounts of distortion as well, especially if the compressor does not match the expander. The application of such compressors and expanders is also known as <a class="uri" href="companding" title="wikilink">companding</a>.</p>
<h2 id="ratedistortion-quantizer-design">Rate–distortion quantizer design</h2>

<p>A scalar quantizer, which performs a quantization operation, can ordinarily be decomposed into two stages:</p>
<ul>
<li><strong>Classification:</strong> A process that classifies the input signal range into 

<math display="inline" id="Quantization_(signal_processing):27">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 non-overlapping <strong>intervals</strong> 

<math display="inline" id="Quantization_(signal_processing):28">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>I</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>M</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>k</ci>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{I_{k}\}_{k=1}^{M}
  </annotation>
 </semantics>
</math>

, by defining 

<math display="inline" id="Quantization_(signal_processing):29">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>M</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M-1
  </annotation>
 </semantics>
</math>

 <strong>boundary (decision)</strong> values 

<math display="inline" id="Quantization_(signal_processing):30">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>b</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mrow>
    <mi>M</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>k</ci>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <ci>M</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{b_{k}\}_{k=1}^{M-1}
  </annotation>
 </semantics>
</math>

, such that 

<math display="inline" id="Quantization_(signal_processing):31">
 <semantics>
  <mrow>
   <msub>
    <mi>I</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mpadded width="+3.3pt">
     <msub>
      <mi>b</mi>
      <mrow>
       <mi>k</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mpadded>
    <mo rspace="5.8pt">,</mo>
    <msub>
     <mi>b</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>I</ci>
     <ci>k</ci>
    </apply>
    <interval closure="closed-open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <apply>
       <minus></minus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>k</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{k}=[b_{k-1}~{},~{}b_{k})
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Quantization_(signal_processing):32">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>M</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <list>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <ci>M</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=1,2,\ldots,M
  </annotation>
 </semantics>
</math>

, with the extreme limits defined by 

<math display="inline" id="Quantization_(signal_processing):33">
 <semantics>
  <mrow>
   <msub>
    <mi>b</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mi mathvariant="normal">∞</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <minus></minus>
     <infinity></infinity>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{0}=-\infty
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quantization_(signal_processing):34">
 <semantics>
  <mrow>
   <msub>
    <mi>b</mi>
    <mi>M</mi>
   </msub>
   <mo>=</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>b</ci>
     <ci>M</ci>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{M}=\infty
  </annotation>
 </semantics>
</math>

. All the inputs 

<math display="inline" id="Quantization_(signal_processing):35">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 that fall in a given interval range 

<math display="inline" id="Quantization_(signal_processing):36">
 <semantics>
  <msub>
   <mi>I</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{k}
  </annotation>
 </semantics>
</math>

 are associated with the same quantization index 

<math display="inline" id="Quantization_(signal_processing):37">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

.</li>
<li><strong>Reconstruction:</strong> Each interval 

<math display="inline" id="Quantization_(signal_processing):38">
 <semantics>
  <msub>
   <mi>I</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{k}
  </annotation>
 </semantics>
</math>

 is represented by a <strong>reconstruction value</strong> 

<math display="inline" id="Quantization_(signal_processing):39">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}
  </annotation>
 </semantics>
</math>

 which implements the mapping 

<math display="inline" id="Quantization_(signal_processing):40">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msub>
    <mi>I</mi>
    <mi>k</mi>
   </msub>
   <mo>⇒</mo>
   <mi>y</mi>
   <mo>=</mo>
   <msub>
    <mi>y</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <ci>y</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in I_{k}\Rightarrow y=y_{k}
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>These two stages together comprise the mathematical operation of 

<math display="inline" id="Quantization_(signal_processing):41">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <times></times>
     <ci>Q</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=Q(x)
  </annotation>
 </semantics>
</math>

.</p>

<p><a href="Entropy_coding" title="wikilink">Entropy coding</a> techniques can be applied to communicate the quantization indices from a source encoder that performs the classification stage to a decoder that performs the reconstruction stage. One way to do this is to associate each quantization index 

<math display="inline" id="Quantization_(signal_processing):42">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 with a binary codeword 

<math display="inline" id="Quantization_(signal_processing):43">
 <semantics>
  <msub>
   <mi>c</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{k}
  </annotation>
 </semantics>
</math>

. An important consideration is the number of bits used for each codeword, denoted here by 

<math display="inline" id="Quantization_(signal_processing):44">
 <semantics>
  <mrow>
   <mi>length</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>c</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>length</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{length}(c_{k})
  </annotation>
 </semantics>
</math>

.</p>

<p>As a result, the design of an 

<math display="inline" id="Quantization_(signal_processing):45">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

-level quantizer and an associated set of codewords for communicating its index values requires finding the values of 

<math display="inline" id="Quantization_(signal_processing):46">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>b</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mrow>
    <mi>M</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>k</ci>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <ci>M</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{b_{k}\}_{k=1}^{M-1}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Quantization_(signal_processing):47">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>c</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>M</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>k</ci>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{c_{k}\}_{k=1}^{M}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quantization_(signal_processing):48">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>y</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>M</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>k</ci>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{y_{k}\}_{k=1}^{M}
  </annotation>
 </semantics>
</math>

 which optimally satisfy a selected set of design constraints such as the <strong>bit rate</strong> 

<math display="inline" id="Quantization_(signal_processing):49">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 and <strong>distortion</strong> 

<math display="inline" id="Quantization_(signal_processing):50">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

.</p>

<p>Assuming that an information source 

<math display="inline" id="Quantization_(signal_processing):51">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 produces random variables 

<math display="inline" id="Quantization_(signal_processing):52">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 with an associated <a href="probability_density_function" title="wikilink">probability density function</a> 

<math display="inline" id="Quantization_(signal_processing):53">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

, the probability 

<math display="inline" id="Quantization_(signal_processing):54">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{k}
  </annotation>
 </semantics>
</math>

 that the random variable falls within a particular quantization interval 

<math display="inline" id="Quantization_(signal_processing):55">
 <semantics>
  <msub>
   <mi>I</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{k}
  </annotation>
 </semantics>
</math>

 is given by</p>

<p>

<math display="block" id="Quantization_(signal_processing):56">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>∈</mo>
    <msub>
     <mi>I</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>=</mo>
   <msubsup>
    <mo largeop="true" symmetric="true">∫</mo>
    <msub>
     <mi>b</mi>
     <mrow>
      <mi>k</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <msub>
     <mi>b</mi>
     <mi>k</mi>
    </msub>
   </msubsup>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>d</mi>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>k</ci>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>k</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <csymbol cd="unknown">f</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">d</csymbol>
    <csymbol cd="unknown">x</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{k}=P[x\in I_{k}]=\int_{b_{k-1}}^{b_{k}}f(x)dx
  </annotation>
 </semantics>
</math>

.</p>

<p>The resulting bit rate 

<math display="inline" id="Quantization_(signal_processing):57">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

, in units of average bits per quantized value, for this quantizer can be derived as follows:</p>

<p>

<math display="block" id="Quantization_(signal_processing):58">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>M</mi>
    </munderover>
    <mrow>
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>k</mi>
      </msub>
      <mo>⋅</mo>
      <mi>length</mi>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>c</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>M</mi>
    </munderover>
    <mrow>
     <mi>length</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>c</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <msub>
        <mi>b</mi>
        <mrow>
         <mi>k</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <msub>
        <mi>b</mi>
        <mi>k</mi>
       </msub>
      </msubsup>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>d</mi>
       <mi>x</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>R</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>M</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>k</ci>
        </apply>
        <ci>length</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>M</ci>
      </apply>
      <apply>
       <times></times>
       <ci>length</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <int></int>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>b</ci>
           <apply>
            <minus></minus>
            <ci>k</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>b</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>x</ci>
         <ci>d</ci>
         <ci>x</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=\sum_{k=1}^{M}p_{k}\cdot\mathrm{length}(c_{k})=\sum_{k=1}^{M}\mathrm{length}%
(c_{k})\int_{b_{k-1}}^{b_{k}}f(x)dx
  </annotation>
 </semantics>
</math>

.</p>

<p>If it is assumed that distortion is measured by <a href="mean_squared_error" title="wikilink">mean squared error</a>, the distortion <strong>D</strong>, is given by:</p>

<p>

<math display="block" id="Quantization_(signal_processing):59">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <mrow>
         <mi>Q</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mo>-</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <mrow>
         <mi>Q</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>M</mi>
    </munderover>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <msub>
       <mi>b</mi>
       <mrow>
        <mi>k</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <msub>
       <mi>b</mi>
       <mi>k</mi>
      </msub>
     </msubsup>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>x</mi>
         <mo>-</mo>
         <msub>
          <mi>y</mi>
          <mi>k</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>D</ci>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <ci>x</ci>
         <apply>
          <times></times>
          <ci>Q</ci>
          <ci>x</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <ci>x</ci>
         <apply>
          <times></times>
          <ci>Q</ci>
          <ci>x</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <ci>f</ci>
       <ci>x</ci>
       <ci>d</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>M</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <int></int>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>b</ci>
          <apply>
           <minus></minus>
           <ci>k</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <minus></minus>
          <ci>x</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>k</ci>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <ci>f</ci>
        <ci>x</ci>
        <ci>d</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=E[(x-Q(x))^{2}]=\int_{-\infty}^{\infty}(x-Q(x))^{2}f(x)dx=\sum_{k=1}^{M}\int%
_{b_{k-1}}^{b_{k}}(x-y_{k})^{2}f(x)dx
  </annotation>
 </semantics>
</math>

.</p>

<p>Note that other distortion measures can also be considered, although mean squared error is a popular one.</p>

<p>A key observation is that rate 

<math display="inline" id="Quantization_(signal_processing):60">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 depends on the decision boundaries 

<math display="inline" id="Quantization_(signal_processing):61">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>b</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mrow>
    <mi>M</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>k</ci>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <ci>M</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{b_{k}\}_{k=1}^{M-1}
  </annotation>
 </semantics>
</math>

 and the codeword lengths 

<math display="inline" id="Quantization_(signal_processing):62">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>length</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>c</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>M</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <times></times>
       <ci>length</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\mathrm{length}(c_{k})\}_{k=1}^{M}
  </annotation>
 </semantics>
</math>

, whereas the distortion 

<math display="inline" id="Quantization_(signal_processing):63">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 depends on the decision boundaries 

<math display="inline" id="Quantization_(signal_processing):64">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>b</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mrow>
    <mi>M</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>k</ci>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <ci>M</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{b_{k}\}_{k=1}^{M-1}
  </annotation>
 </semantics>
</math>

 and the reconstruction levels 

<math display="inline" id="Quantization_(signal_processing):65">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>y</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>M</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>k</ci>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{y_{k}\}_{k=1}^{M}
  </annotation>
 </semantics>
</math>

.</p>

<p>After defining these two performance metrics for the quantizer, a typical Rate–Distortion formulation for a quantizer design problem can be expressed in one of two ways:</p>
<ol>
<li>Given a maximum distortion constraint 

<math display="inline" id="Quantization_(signal_processing):66">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>≤</mo>
   <msub>
    <mi>D</mi>
    <mi>max</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>D</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <max></max>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D\leq D_{\max}
  </annotation>
 </semantics>
</math>

, minimize the bit rate 

<math display="inline" id="Quantization_(signal_processing):67">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

</li>
<li>Given a maximum bit rate constraint 

<math display="inline" id="Quantization_(signal_processing):68">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>≤</mo>
   <msub>
    <mi>R</mi>
    <mi>max</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>R</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <max></max>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\leq R_{\max}
  </annotation>
 </semantics>
</math>

, minimize the distortion 

<math display="inline" id="Quantization_(signal_processing):69">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>Often the solution to these problems can be equivalently (or approximately) expressed and solved by converting the formulation to the unconstrained problem 

<math display="inline" id="Quantization_(signal_processing):70">
 <semantics>
  <mrow>
   <mi>min</mi>
   <mrow>
    <mo>{</mo>
    <mrow>
     <mi>D</mi>
     <mo>+</mo>
     <mrow>
      <mi>λ</mi>
      <mo>⋅</mo>
      <mi>R</mi>
     </mrow>
    </mrow>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <min></min>
    <apply>
     <plus></plus>
     <ci>D</ci>
     <apply>
      <ci>normal-⋅</ci>
      <ci>λ</ci>
      <ci>R</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min\left\{D+\lambda\cdot R\right\}
  </annotation>
 </semantics>
</math>

 where the <a href="Lagrange_multiplier" title="wikilink">Lagrange multiplier</a> 

<math display="inline" id="Quantization_(signal_processing):71">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 is a non-negative constant that establishes the appropriate balance between rate and distortion. Solving the unconstrained problem is equivalent to finding a point on the <a href="convex_hull" title="wikilink">convex hull</a> of the family of solutions to an equivalent constrained formulation of the problem. However, finding a solution – especially a <a href="Closed-form_expression" title="wikilink">closed-form</a> solution – to any of these three problem formulations can be difficult. Solutions that do not require multi-dimensional iterative optimization techniques have been published for only three probability distribution functions: the <a href="Uniform_distribution_(continuous)" title="wikilink">uniform</a>,<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> <a href="Exponential_distribution" title="wikilink">exponential</a>,<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> and <a href="Laplace_distribution" title="wikilink">Laplacian</a><a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> distributions. Iterative optimization approaches can be used to find solutions in other cases.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a><a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a><a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>

<p>Note that the reconstruction values 

<math display="inline" id="Quantization_(signal_processing):72">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>y</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>M</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>k</ci>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{y_{k}\}_{k=1}^{M}
  </annotation>
 </semantics>
</math>

 affect only the distortion – they do not affect the bit rate – and that each individual 

<math display="inline" id="Quantization_(signal_processing):73">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}
  </annotation>
 </semantics>
</math>

 makes a separate contribution 

<math display="inline" id="Quantization_(signal_processing):74">
 <semantics>
  <msub>
   <mi>d</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{k}
  </annotation>
 </semantics>
</math>

 to the total distortion as shown below:</p>

<p>

<math display="block" id="Quantization_(signal_processing):75">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>M</mi>
    </munderover>
    <msub>
     <mi>d</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>D</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>M</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=\sum_{k=1}^{M}d_{k}
  </annotation>
 </semantics>
</math>

 where</p>

<p>

<math display="block" id="Quantization_(signal_processing):76">
 <semantics>
  <mrow>
   <msub>
    <mi>d</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <msub>
      <mi>b</mi>
      <mrow>
       <mi>k</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msub>
      <mi>b</mi>
      <mi>k</mi>
     </msub>
    </msubsup>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <msub>
         <mi>y</mi>
         <mi>k</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <apply>
         <minus></minus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>y</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <ci>f</ci>
      <ci>x</ci>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{k}=\int_{b_{k-1}}^{b_{k}}(x-y_{k})^{2}f(x)dx
  </annotation>
 </semantics>
</math>

 This observation can be used to ease the analysis – given the set of 

<math display="inline" id="Quantization_(signal_processing):77">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>b</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mrow>
    <mi>M</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>k</ci>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <ci>M</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{b_{k}\}_{k=1}^{M-1}
  </annotation>
 </semantics>
</math>

 values, the value of each 

<math display="inline" id="Quantization_(signal_processing):78">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}
  </annotation>
 </semantics>
</math>

 can be optimized separately to minimize its contribution to the distortion 

<math display="inline" id="Quantization_(signal_processing):79">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

.</p>

<p>For the mean-square error distortion criterion, it can be easily shown that the optimal set of reconstruction values 

<math display="inline" id="Quantization_(signal_processing):80">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">{</mo>
    <msubsup>
     <mi>y</mi>
     <mi>k</mi>
     <mo>*</mo>
    </msubsup>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>M</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <times></times>
       </apply>
       <ci>k</ci>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{y^{*}_{k}\}_{k=1}^{M}
  </annotation>
 </semantics>
</math>

 is given by setting the reconstruction value 

<math display="inline" id="Quantization_(signal_processing):81">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}
  </annotation>
 </semantics>
</math>

 within each interval 

<math display="inline" id="Quantization_(signal_processing):82">
 <semantics>
  <msub>
   <mi>I</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{k}
  </annotation>
 </semantics>
</math>

 to the conditional expected value (also referred to as the <em><a class="uri" href="centroid" title="wikilink">centroid</a></em>) within the interval, as given by:</p>

<p>

<math display="block" id="Quantization_(signal_processing):83">
 <semantics>
  <mrow>
   <msubsup>
    <mi>y</mi>
    <mi>k</mi>
    <mo>*</mo>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msub>
      <mi>p</mi>
      <mi>k</mi>
     </msub>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <msub>
       <mi>b</mi>
       <mrow>
        <mi>k</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <msub>
       <mi>b</mi>
       <mi>k</mi>
      </msub>
     </msubsup>
     <mrow>
      <mi>x</mi>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <times></times>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <apply>
          <minus></minus>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>x</ci>
       <ci>f</ci>
       <ci>x</ci>
       <ci>d</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{*}_{k}=\frac{1}{p_{k}}\int_{b_{k-1}}^{b_{k}}xf(x)dx
  </annotation>
 </semantics>
</math>

.</p>

<p>The use of sufficiently well-designed entropy coding techniques can result in the use of a bit rate that is close to the true information content of the indices 

<math display="inline" id="Quantization_(signal_processing):84">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>k</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>M</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <ci>k</ci>
     </set>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{k\}_{k=1}^{M}
  </annotation>
 </semantics>
</math>

, such that effectively</p>

<p>

<math display="block" id="Quantization_(signal_processing):85">
 <semantics>
  <mrow>
   <mrow>
    <mi>length</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>c</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>2</mn>
     </msub>
     <mrow>
      <mo>(</mo>
      <msub>
       <mi>p</mi>
       <mi>k</mi>
      </msub>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>length</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{length}(c_{k})\approx-\log_{2}\left(p_{k}\right)
  </annotation>
 </semantics>
</math>

 and therefore</p>

<p>

<math display="block" id="Quantization_(signal_processing):86">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>M</mi>
    </munderover>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>p</mi>
      <mi>k</mi>
     </msub>
     <mo>⋅</mo>
     <mrow>
      <msub>
       <mi>log</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo>(</mo>
       <msub>
        <mi>p</mi>
        <mi>k</mi>
       </msub>
       <mo>)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>M</ci>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <log></log>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=\sum_{k=1}^{M}-p_{k}\cdot\log_{2}\left(p_{k}\right)
  </annotation>
 </semantics>
</math>

.</p>

<p>The use of this approximation can allow the entropy coding design problem to be separated from the design of the quantizer itself. Modern entropy coding techniques such as <a href="arithmetic_coding" title="wikilink">arithmetic coding</a> can achieve bit rates that are very close to the true entropy of a source, given a set of known (or adaptively estimated) probabilities 

<math display="inline" id="Quantization_(signal_processing):87">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>p</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>M</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>k</ci>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{p_{k}\}_{k=1}^{M}
  </annotation>
 </semantics>
</math>

.</p>

<p>In some designs, rather than optimizing for a particular number of classification regions 

<math display="inline" id="Quantization_(signal_processing):88">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

, the quantizer design problem may include optimization of the value of 

<math display="inline" id="Quantization_(signal_processing):89">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 as well. For some probabilistic source models, the best performance may be achieved when 

<math display="inline" id="Quantization_(signal_processing):90">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 approaches infinity.</p>
<h2 id="neglecting-the-entropy-constraint-lloydmax-quantization">Neglecting the entropy constraint: Lloyd–Max quantization</h2>

<p>In the above formulation, if the bit rate constraint is neglected by setting 

<math display="inline" id="Quantization_(signal_processing):91">
 <semantics>
  <mi>λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda
  </annotation>
 </semantics>
</math>

 equal to 0, or equivalently if it is assumed that a fixed-length code (FLC) will be used to represent the quantized data instead of a <a href="variable-length_code" title="wikilink">variable-length code</a> (or some other <a href="entropy_coding" title="wikilink">entropy coding</a> technology such as <a href="arithmetic_coding" title="wikilink">arithmetic coding</a> that is better than an FLC in the rate–distortion sense), the optimization problem reduces to minimization of distortion 

<math display="inline" id="Quantization_(signal_processing):92">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 alone.</p>

<p>The indices produced by an 

<math display="inline" id="Quantization_(signal_processing):93">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

-level quantizer can be coded using a fixed-length code using 

<math display="inline" id="Quantization_(signal_processing):94">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⌈</mo>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>2</mn>
     </msub>
     <mi>M</mi>
    </mrow>
    <mo stretchy="false">⌉</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <apply>
     <ceiling></ceiling>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <cn type="integer">2</cn>
      </apply>
      <ci>M</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=\lceil\log_{2}M\rceil
  </annotation>
 </semantics>
</math>

 bits/symbol. For example when 

<math display="inline" id="Quantization_(signal_processing):95">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=
  </annotation>
 </semantics>
</math>

256 levels, the FLC bit rate 

<math display="inline" id="Quantization_(signal_processing):96">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is 8 bits/symbol. For this reason, such a quantizer has sometimes been called an 8-bit quantizer. However using an FLC eliminates the compression improvement that can be obtained by use of better entropy coding.</p>

<p>Assuming an FLC with 

<math display="inline" id="Quantization_(signal_processing):97">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 levels, the Rate–Distortion minimization problem can be reduced to distortion minimization alone. The reduced problem can be stated as follows: given a source 

<math display="inline" id="Quantization_(signal_processing):98">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X
  </annotation>
 </semantics>
</math>

 with <a href="probability_density_function" title="wikilink">pdf</a> 

<math display="inline" id="Quantization_(signal_processing):99">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 and the constraint that the quantizer must use only 

<math display="inline" id="Quantization_(signal_processing):100">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 classification regions, find the decision boundaries 

<math display="inline" id="Quantization_(signal_processing):101">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>b</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mrow>
    <mi>M</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>k</ci>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <ci>M</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{b_{k}\}_{k=1}^{M-1}
  </annotation>
 </semantics>
</math>

 and reconstruction levels 

<math display="inline" id="Quantization_(signal_processing):102">
 <semantics>
  <msubsup>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>y</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mi>M</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <set>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>k</ci>
      </apply>
     </set>
     <apply>
      <eq></eq>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>M</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{y_{k}\}_{k=1}^{M}
  </annotation>
 </semantics>
</math>

 to minimize the resulting distortion</p>

<p>

<math display="block" id="Quantization_(signal_processing):103">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <mrow>
         <mi>Q</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mo>-</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <mrow>
         <mi>Q</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>M</mi>
    </munderover>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <msub>
       <mi>b</mi>
       <mrow>
        <mi>k</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <msub>
       <mi>b</mi>
       <mi>k</mi>
      </msub>
     </msubsup>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>x</mi>
         <mo>-</mo>
         <msub>
          <mi>y</mi>
          <mi>k</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>M</mi>
    </munderover>
    <msub>
     <mi>d</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>D</ci>
     <apply>
      <times></times>
      <ci>E</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <ci>x</ci>
         <apply>
          <times></times>
          <ci>Q</ci>
          <ci>x</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <apply>
         <minus></minus>
         <infinity></infinity>
        </apply>
       </apply>
       <infinity></infinity>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <ci>x</ci>
         <apply>
          <times></times>
          <ci>Q</ci>
          <ci>x</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <ci>f</ci>
       <ci>x</ci>
       <ci>d</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>M</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <int></int>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>b</ci>
          <apply>
           <minus></minus>
           <ci>k</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <minus></minus>
          <ci>x</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>y</ci>
           <ci>k</ci>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <ci>f</ci>
        <ci>x</ci>
        <ci>d</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>M</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=E[(x-Q(x))^{2}]=\int_{-\infty}^{\infty}(x-Q(x))^{2}f(x)dx=\sum_{k=1}^{M}\int%
_{b_{k-1}}^{b_{k}}(x-y_{k})^{2}f(x)dx=\sum_{k=1}^{M}d_{k}
  </annotation>
 </semantics>
</math>

.</p>

<p>Finding an optimal solution to the above problem results in a quantizer sometimes called a MMSQE (minimum mean-square quantization error) solution, and the resulting pdf-optimized (non-uniform) quantizer is referred to as a <em>Lloyd–Max</em> quantizer, named after two people who independently developed iterative methods<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a><a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a><a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> to solve the two sets of simultaneous equations resulting from 

<math display="inline" id="Quantization_(signal_processing):104">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∂</mo>
     <mi>D</mi>
    </mrow>
    <mo>/</mo>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>b</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <ci>D</ci>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\partial D/\partial b_{k}}=0
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quantization_(signal_processing):105">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∂</mo>
     <mi>D</mi>
    </mrow>
    <mo>/</mo>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>y</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <partialdiff></partialdiff>
      <ci>D</ci>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\partial D/\partial y_{k}}=0
  </annotation>
 </semantics>
</math>

, as follows:</p>

<p>

<math display="block" id="Quantization_(signal_processing):106">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <mi>D</mi>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>b</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mn>0</mn>
   <mo>⇒</mo>
   <msub>
    <mi>b</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>k</mi>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>y</mi>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mn>2</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <partialdiff></partialdiff>
       <ci>D</ci>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <apply>
         <plus></plus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\partial D\over\partial b_{k}}=0\Rightarrow b_{k}={y_{k}+y_{k+1}\over 2}
  </annotation>
 </semantics>
</math>

, which places each threshold at the midpoint between each pair of reconstruction values, and</p>

<p>

<math display="block" id="Quantization_(signal_processing):107">
 <semantics>
  <mrow>
   <mfrac>
    <mrow>
     <mo>∂</mo>
     <mi>D</mi>
    </mrow>
    <mrow>
     <mo>∂</mo>
     <msub>
      <mi>y</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mn>0</mn>
   <mo>⇒</mo>
   <msub>
    <mi>y</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <msub>
       <mi>b</mi>
       <mrow>
        <mi>k</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <msub>
       <mi>b</mi>
       <mi>k</mi>
      </msub>
     </msubsup>
     <mrow>
      <mi>x</mi>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <msub>
       <mi>b</mi>
       <mrow>
        <mi>k</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <msub>
       <mi>b</mi>
       <mi>k</mi>
      </msub>
     </msubsup>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msub>
      <mi>p</mi>
      <mi>k</mi>
     </msub>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <msub>
       <mi>b</mi>
       <mrow>
        <mi>k</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <msub>
       <mi>b</mi>
       <mi>k</mi>
      </msub>
     </msubsup>
     <mrow>
      <mi>x</mi>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <partialdiff></partialdiff>
       <ci>D</ci>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <int></int>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>b</ci>
          <apply>
           <minus></minus>
           <ci>k</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>f</ci>
        <ci>x</ci>
        <ci>d</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <int></int>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>b</ci>
          <apply>
           <minus></minus>
           <ci>k</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>x</ci>
        <ci>d</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <int></int>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>b</ci>
          <apply>
           <minus></minus>
           <ci>k</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>f</ci>
        <ci>x</ci>
        <ci>d</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\partial D\over\partial y_{k}}=0\Rightarrow y_{k}={\int_{b_{k-1}}^{b_{k}}xf(x%
)dx\over\int_{b_{k-1}}^{b_{k}}f(x)dx}=\frac{1}{p_{k}}\int_{b_{k-1}}^{b_{k}}xf(%
x)dx
  </annotation>
 </semantics>
</math>

 which places each reconstruction value at the centroid (conditional expected value) of its associated classification interval.</p>

<p><a href="Lloyd's_algorithm" title="wikilink">Lloyd's Method I algorithm</a>, originally described in 1957, can be generalized in a straightforward way for application to <a href="vector_quantization" title="wikilink">vector</a> data. This generalization results in the <a href="Linde–Buzo–Gray_algorithm" title="wikilink">Linde–Buzo–Gray (LBG)</a> or <a href="k-means_clustering" title="wikilink">k-means</a> classifier optimization methods. Moreover, the technique can be further generalized in a straightforward way to also include an entropy constraint for vector data.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p>
<h2 id="uniform-quantization-and-the-6-dbbit-approximation">Uniform quantization and the 6 dB/bit approximation</h2>

<p>The Lloyd–Max quantizer is actually a uniform quantizer when the input <a href="probability_density_function" title="wikilink">pdf</a> is uniformly distributed over the range 

<math display="inline" id="Quantization_(signal_processing):108">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mo>-</mo>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </mrow>
   <mo rspace="5.8pt">,</mo>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>M</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi mathvariant="normal">Δ</mi>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed-open">
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <divide></divide>
      <ci>normal-Δ</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>M</ci>
     </apply>
     <apply>
      <divide></divide>
      <ci>normal-Δ</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [y_{1}-\Delta/2,~{}y_{M}+\Delta/2)
  </annotation>
 </semantics>
</math>

. However, for a source that does not have a uniform distribution, the minimum-distortion quantizer may not be a uniform quantizer.</p>

<p>The analysis of a uniform quantizer applied to a uniformly distributed source can be summarized in what follows:</p>

<p>A symmetric source X can be modelled with 

<math display="inline" id="Quantization_(signal_processing):109">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mn>1</mn>
    <mrow>
     <mn>2</mn>
     <msub>
      <mi>X</mi>
      <mrow>
       <mi>m</mi>
       <mi>a</mi>
       <mi>x</mi>
      </mrow>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>a</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=\frac{1}{2X_{max}}
  </annotation>
 </semantics>
</math>

, for 

<math display="inline" id="Quantization_(signal_processing):110">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo>-</mo>
     <msub>
      <mi>X</mi>
      <mrow>
       <mi>m</mi>
       <mi>a</mi>
       <mi>x</mi>
      </mrow>
     </msub>
    </mrow>
    <mo>,</mo>
    <msub>
     <mi>X</mi>
     <mrow>
      <mi>m</mi>
      <mi>a</mi>
      <mi>x</mi>
     </mrow>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <interval closure="closed">
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>a</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>a</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in[-X_{max},X_{max}]
  </annotation>
 </semantics>
</math>

 and 0 elsewhere. The step size 

<math display="inline" id="Quantization_(signal_processing):111">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mn>2</mn>
     <msub>
      <mi>X</mi>
      <mrow>
       <mi>m</mi>
       <mi>a</mi>
       <mi>x</mi>
      </mrow>
     </msub>
    </mrow>
    <mi>M</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>normal-Δ</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>a</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta=\frac{2X_{max}}{M}
  </annotation>
 </semantics>
</math>

 and the <em>signal to quantization noise ratio</em> (SQNR) of the quantizer is</p>

<p>

<math display="block" id="Quantization_(signal_processing):112">
 <semantics>
  <mrow>
   <mi>SQNR</mi>
   <mo>=</mo>
   <mrow>
    <mn>10</mn>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>10</mn>
     </msub>
     <mfrac>
      <msubsup>
       <mi>σ</mi>
       <mi>x</mi>
       <mn>2</mn>
      </msubsup>
      <msubsup>
       <mi>σ</mi>
       <mi>q</mi>
       <mn>2</mn>
      </msubsup>
     </mfrac>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>10</mn>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>10</mn>
     </msub>
     <mfrac>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>M</mi>
          <mi mathvariant="normal">Δ</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mn>2</mn>
       </msup>
       <mo>/</mo>
       <mn>12</mn>
      </mrow>
      <mrow>
       <msup>
        <mi mathvariant="normal">Δ</mi>
        <mn>2</mn>
       </msup>
       <mo>/</mo>
       <mn>12</mn>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>10</mn>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>10</mn>
     </msub>
     <msup>
      <mi>M</mi>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>20</mn>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>10</mn>
     </msub>
     <mi>M</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>SQNR</ci>
     <apply>
      <times></times>
      <cn type="integer">10</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <log></log>
        <cn type="integer">10</cn>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>σ</ci>
          <ci>x</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>σ</ci>
          <ci>q</ci>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="integer">10</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <log></log>
        <cn type="integer">10</cn>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <divide></divide>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <times></times>
           <ci>M</ci>
           <ci>normal-Δ</ci>
          </apply>
          <cn type="integer">2</cn>
         </apply>
         <cn type="integer">12</cn>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>normal-Δ</ci>
          <cn type="integer">2</cn>
         </apply>
         <cn type="integer">12</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="integer">10</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <log></log>
        <cn type="integer">10</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>M</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <cn type="integer">20</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <log></log>
        <cn type="integer">10</cn>
       </apply>
       <ci>M</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm SQNR}=10\log_{10}{\frac{\sigma_{x}^{2}}{\sigma_{q}^{2}}}=10\log_{10}{%
\frac{(M\Delta)^{2}/12}{\Delta^{2}/12}}=10\log_{10}M^{2}=20\log_{10}M
  </annotation>
 </semantics>
</math>

.</p>

<p>For a fixed-length code using 

<math display="inline" id="Quantization_(signal_processing):113">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 bits, 

<math display="inline" id="Quantization_(signal_processing):114">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mi>N</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=2^{N}
  </annotation>
 </semantics>
</math>

, resulting in 

<math display="inline" id="Quantization_(signal_processing):115">
 <semantics>
  <mrow>
   <mi>SQNR</mi>
   <mo>=</mo>
   <mrow>
    <mn>20</mn>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>10</mn>
     </msub>
     <msup>
      <mn>2</mn>
      <mi>N</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>N</mi>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>20</mn>
      <mrow>
       <msub>
        <mi>log</mi>
        <mn>10</mn>
       </msub>
       <mn>2</mn>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>N</mi>
     <mo>⋅</mo>
     <mpadded width="+1.7pt">
      <mn>6.0206</mn>
     </mpadded>
    </mrow>
    <mi>dB</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>SQNR</ci>
     <apply>
      <times></times>
      <cn type="integer">20</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <log></log>
        <cn type="integer">10</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-⋅</ci>
      <ci>N</ci>
      <apply>
       <times></times>
       <cn type="integer">20</cn>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <log></log>
         <cn type="integer">10</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <ci>normal-⋅</ci>
       <ci>N</ci>
       <cn type="float">6.0206</cn>
      </apply>
      <ci>dB</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm SQNR}=20\log_{10}{2^{N}}=N\cdot(20\log_{10}2)=N\cdot 6.0206\,\rm{dB}
  </annotation>
 </semantics>
</math>

,</p>

<p>or approximately 6 dB per bit. For example, for 

<math display="inline" id="Quantization_(signal_processing):116">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

=8 bits, 

<math display="inline" id="Quantization_(signal_processing):117">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

=256 levels and SQNR = 8*6 = 48 dB; and for 

<math display="inline" id="Quantization_(signal_processing):118">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

=16 bits, 

<math display="inline" id="Quantization_(signal_processing):119">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

=65536 and SQNR = 16*6 = 96 dB. The property of 6 dB improvement in SQNR for each extra bit used in quantization is a well-known figure of merit. However, it must be used with care: this derivation is only for a uniform quantizer applied to a uniform source.</p>

<p>For other source pdfs and other quantizer designs, the SQNR may be somewhat different from that predicted by 6 dB/bit, depending on the type of pdf, the type of source, the type of quantizer, and the bit rate range of operation.</p>

<p>However, it is common to assume that for many sources, the slope of a quantizer SQNR function can be approximated as 6 dB/bit when operating at a sufficiently high bit rate. At asymptotically high bit rates, cutting the step size in half increases the bit rate by approximately 1 bit per sample (because 1 bit is needed to indicate whether the value is in the left or right half of the prior double-sized interval) and reduces the mean squared error by a factor of 4 (i.e., 6 dB) based on the 

<math display="inline" id="Quantization_(signal_processing):120">
 <semantics>
  <mrow>
   <msup>
    <mi mathvariant="normal">Δ</mi>
    <mn>2</mn>
   </msup>
   <mo>/</mo>
   <mn>12</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Δ</ci>
     <cn type="integer">2</cn>
    </apply>
    <cn type="integer">12</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta^{2}/12
  </annotation>
 </semantics>
</math>

 approximation.</p>

<p>At asymptotically high bit rates, the 6 dB/bit approximation is supported for many source pdfs by rigorous theoretical analysis.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a><a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a><a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a><a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> Moreover, the structure of the optimal scalar quantizer (in the rate–distortion sense) approaches that of a uniform quantizer under these conditions.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a><a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a></p>
<h2 id="other-fields">Other fields</h2>

<p>Many physical quantities are actually quantized by physical entities. Examples of fields where this limitation applies include <a class="uri" href="electronics" title="wikilink">electronics</a> (due to electrons), <a class="uri" href="optics" title="wikilink">optics</a> (due to photons), <a class="uri" href="biology" title="wikilink">biology</a> (due to <a class="uri" href="DNA" title="wikilink">DNA</a>), <a class="uri" href="physics" title="wikilink">physics</a> (due to Planck limits) and <a class="uri" href="chemistry" title="wikilink">chemistry</a> (due to <a class="uri" href="molecules" title="wikilink">molecules</a>). This is sometimes known as the "quantum noise limit" of systems in those fields. This is a different manifestation of "quantization error," in which theoretical models may be analog but physically occurs digitally. Around the <a href="quantum_limit" title="wikilink">quantum limit</a>, the distinction between analog and digital quantities vanishes.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Beta_encoder" title="wikilink">Beta encoder</a></li>
<li><a href="Bit_resolution" title="wikilink">Bit resolution</a></li>
<li><a href="Discretization_error" title="wikilink">Discretization error</a></li>
<li><a class="uri" href="Posterization" title="wikilink">Posterization</a></li>
<li><a href="Pulse_code_modulation" title="wikilink">Pulse code modulation</a></li>
<li><a href="Regression_dilution" title="wikilink">Regression dilution</a> - a bias in parameter estimates caused by errors such as quantization in the explanatory or independent variable</li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.mit.bme.hu/books/quantization/">Quantization noise in Digital Computation, Signal Processing, and Control</a>, Bernard Widrow and István Kollár, 2007.</li>
<li><a href="http://www.techonline.com/community/related_content/20771">The Relationship of Dynamic Range to Data Word Size in Digital Audio Processing</a></li>
<li><a href="http://ccrma.stanford.edu/~jos/mdft/Round_Off_Error_Variance.html">Round-Off Error Variance</a> — derivation of noise power of q²/12 for round-off error</li>
<li><a href="http://www.ieee.li/pdf/essay/dynamic_evaluation_dac.pdf">Dynamic Evaluation of High-Speed, High Resolution D/A Converters</a> Outlines HD, IMD and NPR measurements, also includes a derivation of quantization noise</li>
<li><a href="http://www.dsplog.com/2007/03/19/signal-to-quantization-noise-in-quantized-sinusoidal/">Signal to quantization noise in quantized sinusoidal</a></li>
</ul>

<p>"</p>

<p><a href="Category:Digital_signal_processing" title="wikilink">Category:Digital signal processing</a> <a href="Category:Computer_graphic_artifacts" title="wikilink">Category:Computer graphic artifacts</a> <a href="Category:Digital_audio" title="wikilink">Category:Digital audio</a> <a class="uri" href="Category:Noise" title="wikilink">Category:Noise</a> <a href="Category:Signal_processing" title="wikilink">Category:Signal processing</a> <a href="Category:Telecommunication_theory" title="wikilink">Category:Telecommunication theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Allen Gersho and <a href="Robert_M._Gray" title="wikilink">Robert M. Gray</a>, <em><a href="http://books.google.com/books/about/Vector_Quantization_and_Signal_Compressi.html?id=DwcDm6xgItUC">Vector Quantization and Signal Compression</a></em>, <a href="Springer_Science+Business_Media" title="wikilink">Springer</a>, ISBN 978-0-7923-9181-4, 1991.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="William_Fleetwood_Sheppard" title="wikilink">William Fleetwood Sheppard</a>, "On the Calculation of the Most Probable Values of Frequency Constants for data arranged according to Equidistant Divisions of a Scale", <em><a href="Proceedings_of_the_London_Mathematical_Society" title="wikilink">Proceedings of the London Mathematical Society</a></em>, Vol. 29, pp. 353–80, 1898.<a href="#fnref2">↩</a></li>
<li id="fn3">W. R. Bennett, "<a href="http://www.alcatel-lucent.com/bstj/vol27-1948/articles/bstj27-3-446.pdf">Spectra of Quantized Signals</a>", <em><a href="Bell_System_Technical_Journal" title="wikilink">Bell System Technical Journal</a></em>, Vol. 27, pp. 446–472, July 1948.<a href="#fnref3">↩</a></li>
<li id="fn4">B. M. Oliver, J. R. Pierce, and <a href="Claude_Shannon" title="wikilink">Claude E. Shannon</a>, "The Philosophy of PCM", <em><a href="Proceedings_of_the_IEEE" title="wikilink">Proceedings of the IRE</a></em>, Vol. 36, pp. 1324–1331, Nov. 1948. <a href="#fnref4">↩</a></li>
<li id="fn5">Seymour Stein and J. Jay Jones, <em><a href="http://books.google.com/books/about/Modern_communication_principles.html?id=jBc3AQAAIAAJ">Modern Communication Principles</a></em>, <a class="uri" href="McGraw–Hill" title="wikilink">McGraw–Hill</a>, ISBN 978-0-07-061003-3, 1967 (p. 196).<a href="#fnref5">↩</a></li>
<li id="fn6">Herbert Gish and John N. Pierce, "Asymptotically Efficient Quantizing", <em><a href="IEEE_Transactions_on_Information_Theory" title="wikilink">IEEE Transactions on Information Theory</a></em>, Vol. IT-14, No. 5, pp. 676–683, Sept. 1968. <a href="#fnref6">↩</a></li>
<li id="fn7"><a href="Robert_M._Gray" title="wikilink">Robert M. Gray</a> and David L. Neuhoff, "Quantization", <em><a href="IEEE_Transactions_on_Information_Theory" title="wikilink">IEEE Transactions on Information Theory</a></em>, Vol. IT-44, No. 6, pp. 2325–2383, Oct. 1998. <a href="#fnref7">↩</a></li>
<li id="fn8">Allen Gersho, "Quantization", <em><a href="IEEE_Communications_Magazine" title="wikilink">IEEE Communications Society Magazine</a></em>, pp. 16–28, Sept. 1977. <a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12"><a href="Bernard_Widrow" title="wikilink">Bernard Widrow</a>, "A study of rough amplitude quantization by means of Nyquist sampling theory", <em>IRE Trans. Circuit Theory</em>, Vol. CT-3, pp. 266–276, 1956. <a href="#fnref12">↩</a></li>
<li id="fn13"><a href="Bernard_Widrow" title="wikilink">Bernard Widrow</a>, "<a href="http://www-isl.stanford.edu/~widrow/papers/j1961statisticalanalysis.pdf">Statistical analysis of amplitude quantized sampled data systems</a>", <em>Trans. AIEE Pt. II: Appl. Ind.</em>, Vol. 79, pp. 555–568, Jan. 1961.<a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15">Daniel Marco and David L. Neuhoff, "The Validity of the Additive Noise Model for Uniform Scalar Quantizers", <em><a href="IEEE_Transactions_on_Information_Theory" title="wikilink">IEEE Transactions on Information Theory</a></em>, Vol. IT-51, No. 5, pp. 1739–1755, May 2005. <a href="#fnref15">↩</a></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="Nariman_Farvardin" title="wikilink">Nariman Farvardin</a> and James W. Modestino, "Optimum Quantizer Performance for a Class of Non-Gaussian Memoryless Sources", <em><a href="IEEE_Transactions_on_Information_Theory" title="wikilink">IEEE Transactions on Information Theory</a></em>, Vol. IT-30, No. 3, pp. 485–497, May 1982 (Section VI.C and Appendix B). <a href="#fnref22">↩</a></li>
<li id="fn23"><a href="Gary_Sullivan_(engineer)" title="wikilink">Gary J. Sullivan</a>, "Efficient Scalar Quantization of Exponential and Laplacian Random Variables", <em><a href="IEEE_Transactions_on_Information_Theory" title="wikilink">IEEE Transactions on Information Theory</a></em>, Vol. IT-42, No. 5, pp. 1365–1374, Sept. 1996. <a href="#fnref23">↩</a></li>
<li id="fn24"></li>
<li id="fn25"></li>
<li id="fn26"><a href="Toby_Berger" title="wikilink">Toby Berger</a>, "Optimum Quantizers and Permutation Codes", <em><a href="IEEE_Transactions_on_Information_Theory" title="wikilink">IEEE Transactions on Information Theory</a></em>, Vol. IT-18, No. 6, pp. 759–765, Nov. 1972. <a href="#fnref26">↩</a></li>
<li id="fn27"><a href="Toby_Berger" title="wikilink">Toby Berger</a>, "Minimum Entropy Quantizers and Permutation Codes", <em><a href="IEEE_Transactions_on_Information_Theory" title="wikilink">IEEE Transactions on Information Theory</a></em>, Vol. IT-28, No. 2, pp. 149–157, Mar. 1982. <a href="#fnref27">↩</a></li>
<li id="fn28"></li>
<li id="fn29">Stuart P. Lloyd, "Least Squares Quantization in PCM", <em><a href="IEEE_Transactions_on_Information_Theory" title="wikilink">IEEE Transactions on Information Theory</a></em>, Vol. IT-28, pp. 129–137, No. 2, March 1982  (work documented in a manuscript circulated for comments at <a href="Bell_Labs" title="wikilink">Bell Laboratories</a> with a department log date of 31 July 1957 and also presented at the 1957 meeting of the <a href="Institute_of_Mathematical_Statistics" title="wikilink">Institute of Mathematical Statistics</a>, although not formally published until 1982).<a href="#fnref29">↩</a></li>
<li id="fn30">Joel Max, "Quantizing for Minimum Distortion", <em><a href="IEEE_Transactions_on_Information_Theory" title="wikilink">IRE Transactions on Information Theory</a></em>, Vol. IT-6, pp. 7–12, March 1960. <a href="#fnref30">↩</a></li>
<li id="fn31">Philip A. Chou, Tom Lookabaugh, and <a href="Robert_M._Gray" title="wikilink">Robert M. Gray</a>, "Entropy-Constrained Vector Quantization", <em>IEEE Transactions on Acoustics, Speech, and Signal Processing</em>, Vol. ASSP-37, No. 1, Jan. 1989. <a href="#fnref31">↩</a></li>
<li id="fn32"></li>
<li id="fn33"></li>
<li id="fn34"></li>
<li id="fn35"></li>
<li id="fn36"></li>
<li id="fn37"></li>
</ol>
</section>
</body>
</html>
