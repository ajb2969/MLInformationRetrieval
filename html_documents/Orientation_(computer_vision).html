<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1630">Orientation (computer vision)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Orientation (computer vision)</h1>
<hr/>

<p>In <a href="computer_vision" title="wikilink">computer vision</a> and <a href="image_processing" title="wikilink">image processing</a> a common assumption is that sufficiently small image regions can be characterized as locally one-dimensional, e.g., in terms of lines or edges. For natural images this assumption is usually correct except at specific points, e.g., corners or line junctions or crossings, or in regions of high frequency textures. However, what size the regions have to be in order to appear as one-dimensional varies both between images and within an image. Also, in practice a local region is never exactly one-dimensional but can be so to a sufficient degree of approximation.</p>

<p>Image regions which are one-dimensional are also referred to as simple or intrinsic one-dimensional (i1D).</p>

<p>Given an image of dimension d (d = 2 for ordinary images), a mathematical representation of a local i1D image region is</p>

<p>

<math display="inline" id="Orientation_(computer_vision):0">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>𝐱</mi>
      <mo>⋅</mo>
      <mover accent="true">
       <mi>𝐧</mi>
       <mo stretchy="false">^</mo>
      </mover>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>𝐱</ci>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <apply>
      <ci>normal-⋅</ci>
      <ci>𝐱</ci>
      <apply>
       <ci>normal-^</ci>
       <ci>𝐧</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\mathbf{x})=g(\mathbf{x}\cdot\hat{\mathbf{n}})
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Orientation_(computer_vision):1">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is the image intensity function which varies over a local image coordinate 

<math display="inline" id="Orientation_(computer_vision):2">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 (a d-dimensional vector), 

<math display="inline" id="Orientation_(computer_vision):3">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 is a one-variable function, and 

<math display="inline" id="Orientation_(computer_vision):4">
 <semantics>
  <mover accent="true">
   <mi>𝐧</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>𝐧</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbf{n}}
  </annotation>
 </semantics>
</math>

 is a unit vector.</p>

<p>The intensity function 

<math display="inline" id="Orientation_(computer_vision):5">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is constant in all directions which are perpendicular to 

<math display="inline" id="Orientation_(computer_vision):6">
 <semantics>
  <mover accent="true">
   <mi>𝐧</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>𝐧</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbf{n}}
  </annotation>
 </semantics>
</math>

. Intuitively, the orientation of an i1D-region is therefore represented by the vector 

<math display="inline" id="Orientation_(computer_vision):7">
 <semantics>
  <mover accent="true">
   <mi>𝐧</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>𝐧</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbf{n}}
  </annotation>
 </semantics>
</math>

. However, for a given 

<math display="inline" id="Orientation_(computer_vision):8">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Orientation_(computer_vision):9">
 <semantics>
  <mover accent="true">
   <mi>𝐧</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>𝐧</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbf{n}}
  </annotation>
 </semantics>
</math>

 is not uniquely determined. If</p>

<p>

<math display="inline" id="Orientation_(computer_vision):10">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>𝐧</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mover accent="true">
     <mi>𝐧</mi>
     <mo stretchy="false">^</mo>
    </mover>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-~</ci>
     <ci>𝐧</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <ci>normal-^</ci>
      <ci>𝐧</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{\mathbf{n}}=-\hat{\mathbf{n}}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Orientation_(computer_vision):11">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>g</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-~</ci>
      <ci>g</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <apply>
      <minus></minus>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{g}(x)=g(-x)
  </annotation>
 </semantics>
</math>

</p>

<p>then 

<math display="inline" id="Orientation_(computer_vision):12">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 can be written as</p>

<p>

<math display="inline" id="Orientation_(computer_vision):13">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝐱</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mover accent="true">
     <mi>g</mi>
     <mo stretchy="false">~</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>𝐱</mi>
      <mo>⋅</mo>
      <mover accent="true">
       <mi>𝐧</mi>
       <mo stretchy="false">~</mo>
      </mover>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>𝐱</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-~</ci>
      <ci>g</ci>
     </apply>
     <apply>
      <ci>normal-⋅</ci>
      <ci>𝐱</ci>
      <apply>
       <ci>normal-~</ci>
       <ci>𝐧</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\mathbf{x})=\tilde{g}(\mathbf{x}\cdot\tilde{\mathbf{n}})
  </annotation>
 </semantics>
</math>

</p>

<p>which implies that 

<math display="inline" id="Orientation_(computer_vision):14">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>𝐧</mi>
    <mo stretchy="false">~</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mover accent="true">
     <mi>𝐧</mi>
     <mo stretchy="false">^</mo>
    </mover>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-~</ci>
     <ci>𝐧</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <ci>normal-^</ci>
      <ci>𝐧</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tilde{\mathbf{n}}=-\hat{\mathbf{n}}
  </annotation>
 </semantics>
</math>

 also is a valid representation of the local orientation.</p>

<p>In order to avoid this ambiguity in the representation of local orientation two representations have been proposed</p>
<ul>
<li>The double angle representation</li>
<li>The tensor representation</li>
</ul>

<p>The double angle representation is only valid for 2D images (d=2), but the tensor representation can be defined for arbitrary dimensions d of the image data.</p>
<h2 id="relation-to-direction">Relation to direction</h2>

<p>A line between two points p1 and p2 has no given direction, but has a well-defined orientation. However, if one of the points p1 is used as a reference or origin, then the other point p2 can be described in terms of a vector which points in the direction to p2. Intuitively, orientation can be thought of as a direction without sign. Formally, this relates to projective spaces where the orientation of a vector corresponds to the equivalence class of vectors which are scaled versions of the vector.</p>

<p>For an image edge, we may talk of its direction which can be defined in terms of the gradient, pointing in the direction of maximum image intensity increase (from dark to bright). This implies that two edges can have the same orientation but the corresponding image gradients point in opposite directions if the edges go in different directions.</p>
<h2 id="relation-to-gradients">Relation to gradients</h2>

<p>In image processing, the computation of the local image gradient is a common operation, e.g., for edge detection. If 

<math display="inline" id="Orientation_(computer_vision):15">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 above is an edge, then its gradient is parallel to 

<math display="inline" id="Orientation_(computer_vision):16">
 <semantics>
  <mover accent="true">
   <mi>𝐧</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>𝐧</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbf{n}}
  </annotation>
 </semantics>
</math>

. As is already discussed above the gradient is not a unique representation of orientation. Also, in the case of a local region which is centered on a line, the image gradient is approximately zero. However, in this case the vector 

<math display="inline" id="Orientation_(computer_vision):17">
 <semantics>
  <mover accent="true">
   <mi>𝐧</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>𝐧</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbf{n}}
  </annotation>
 </semantics>
</math>

 is still well-defined except for its sign. Therefore, 

<math display="inline" id="Orientation_(computer_vision):18">
 <semantics>
  <mover accent="true">
   <mi>𝐧</mi>
   <mo stretchy="false">^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>𝐧</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbf{n}}
  </annotation>
 </semantics>
</math>

 is a more appropriate starting point for defining local orientation than the image gradient.</p>
<h2 id="estimation-of-local-image-orientation">Estimation of local image orientation</h2>

<p>A number of methods have been proposed for computing or estimating an orientation representation from image data. These include</p>
<ul>
<li>Quadrature filter based methods</li>
<li>The <a href="structure_tensor" title="wikilink">structure tensor</a></li>
<li>Using a local polynomial approximation</li>
<li>The Energy tensor</li>
<li>The Boundary tensor</li>
</ul>

<p>The first approach can be used both for the double angle representation (only 2D images) and the tensor representation, and the other methods compute a tensor representation of local orientation.</p>
<h2 id="application-of-local-image-orientation">Application of local image orientation</h2>

<p>Given that a local image orientation representation has been computed for some image data, this formation can be used for solving the following tasks:</p>
<ul>
<li>Estimation of line or edge consistency</li>
<li>Estimation of curvature information</li>
<li>Detection of corner points</li>
<li>Adaptive or anisotropic noise reduction</li>
<li>Motion estimation</li>
</ul>

<p>"</p>

<p><a href="Category:Computer_vision" title="wikilink">Category:Computer vision</a></p>
</body>
</html>
