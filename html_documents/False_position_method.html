<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="69">False position method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>False position method</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>The <strong>false position method</strong> or <strong>regula falsi method</strong> is a term for problem-solving methods in arithmetic, algebra, and calculus. In simple terms, these methods begin by attempting to evaluate a problem using test ("false") values for the variables, and then adjust the values accordingly.</p>

<p>Two basic types of false position method can be distinguished, <em>simple false position</em> and <em>double false position</em>. <em>Simple false position</em> is aimed at solving problems involving direct proportion. Such problems can be written algebraically in the form: determine <em>x</em> such that</p>

<p>

<math display="block" id="False_position_method:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mi>x</mi>
    </mrow>
    <mo>=</mo>
    <mi>b</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>x</ci>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ax=b,
  </annotation>
 </semantics>
</math>

 if <em>a</em> and <em>b</em> are known. <em>Double false position</em> is aimed at solving more difficult problems that can be written algebraically in the form: determine <em>x</em> such that</p>

<p>

<math display="block" id="False_position_method:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi>b</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=b,
  </annotation>
 </semantics>
</math>

 if it is known that</p>

<p>

<math display="block" id="False_position_method:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo rspace="22.5pt">,</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>x</mi>
        <mn>2</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>b</mi>
      <mn>2</mn>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x_{1})=b_{1},\qquad f(x_{2})=b_{2}.
  </annotation>
 </semantics>
</math>

 Double false position is mathematically equivalent to <a href="linear_interpolation" title="wikilink">linear interpolation</a>; for an affine <a href="linear_function" title="wikilink">linear function</a>,</p>

<p>

<math display="block" id="False_position_method:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>a</mi>
      <mi>x</mi>
     </mrow>
     <mo>+</mo>
     <mi>c</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>x</ci>
     </apply>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=ax+c,
  </annotation>
 </semantics>
</math>

 it provides the exact solution, while for a <a href="nonlinear_system" title="wikilink">nonlinear</a> function <em>f</em> it provides an <a class="uri" href="approximation" title="wikilink">approximation</a> that can be successively improved by <a href="iterative_method" title="wikilink">iteration</a>.</p>
<h2 id="arithmetic-and-algebra">Arithmetic and algebra</h2>

<p>In problems involving <a class="uri" href="arithmetic" title="wikilink">arithmetic</a> or <a class="uri" href="algebra" title="wikilink">algebra</a>, the <strong>false position method</strong> or <strong>regula falsi</strong> is used to refer to basic <a href="trial_and_error" title="wikilink">trial and error</a> methods of solving problems by substituting test values for the unknown quantities. This is sometimes also referred to as "guess and check". Versions of this method predate the advent of <a class="uri" href="algebra" title="wikilink">algebra</a> and the use of <a class="uri" href="equations" title="wikilink">equations</a>.</p>

<p>For simple false position, the method of solving what we would now write as <em>ax</em> = <em>b</em> begins by using a test input value <em>x</em>′, and finding the corresponding output value <em>b</em>′ by multiplication: <em>ax</em>′ = <em>b</em>′. The correct answer is then found by proportional adjustment, <em>x</em> = <em>x</em>′ · <em>b</em> ÷ <em>b</em>′. This technique is found in <a class="uri" href="cuneiform" title="wikilink">cuneiform</a> tablets from ancient <a href="Babylonian_mathematics" title="wikilink">Babylonian mathematics</a>, and possibly in <a href="papyrus" title="wikilink">papyri</a> from ancient <a href="Egyptian_mathematics" title="wikilink">Egyptian mathematics</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Likewise, double false position arose in late antiquity as a purely arithmetical algorithm. It was used mostly to solve what are now called affine linear problems by using a pair of test inputs and the corresponding pair of outputs. This algorithm would be memorized and carried out by rote. In the ancient <a href="Chinese_mathematics" title="wikilink">Chinese mathematical</a> text called <em><a href="The_Nine_Chapters_on_the_Mathematical_Art" title="wikilink">The Nine Chapters on the Mathematical Art</a></em> (九章算術), dated from 200 BC to AD 100, most of Chapter 7 was devoted to the algorithm. There, the procedure was justified by concrete arithmetical arguments, then applied creatively to a wide variety of story problems, including one involving what we would call <a href="secant_line" title="wikilink">secant lines</a> on a <a href="quadratic_polynomial" title="wikilink">quadratic polynomial</a>. A more typical example is this "joint purchase" problem:</p>
<blockquote>

<p>Now an item is purchased jointly; everyone contributes 8 [coins], the excess is 3; everyone contributes 7, the deficit is 4. Tell: The number of people, the item price, what is each? Answer: 7 people, item price 53.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
</blockquote>

<p>Between the 9th and 10th centuries, the <a href="Egyptians" title="wikilink">Egyptian</a> <a class="uri" href="Muslim" title="wikilink">Muslim</a> mathematician <a href="Abu_Kamil" title="wikilink">Abu Kamil</a> wrote a now-lost treatise on the use of double false position, known as the <em>Book of the Two Errors</em> (<em>Kitāb al-khaṭāʾayn</em>). The oldest surviving writing on double false position from the <a href="Middle_East" title="wikilink">Middle East</a> is that of <a href="Qusta_ibn_Luqa" title="wikilink">Qusta ibn Luqa</a> (10th century), a <a class="uri" href="Christian" title="wikilink">Christian</a> <a class="uri" href="Arab" title="wikilink">Arab</a> mathematician from <a class="uri" href="Baalbek" title="wikilink">Baalbek</a>, <a class="uri" href="Lebanon" title="wikilink">Lebanon</a>. He justified the technique by a formal, <a href="Euclidean_geometry" title="wikilink">Euclidean-style geometric proof</a>. Within the tradition of <a href="Mathematics_in_medieval_Islam" title="wikilink">medieval Muslim mathematics</a>, double false position was known as <em>hisāb al-khaṭāʾayn</em> ("reckoning by two errors"). It was used for centuries, especially in the <a class="uri" href="Maghreb" title="wikilink">Maghreb</a>, to solve practical problems such as commercial and juridical questions (estate partitions according to rules of <a href="Islamic_inheritance_jurisprudence" title="wikilink">Quranic inheritance</a>), as well as purely recreational problems. The algorithm was often memorized with the aid of <a class="uri" href="mnemonics" title="wikilink">mnemonics</a>, such as a verse attributed to <a href="Ibn_al-Yasamin" title="wikilink">Ibn al-Yasamin</a> and balance-scale diagrams explained by <a class="uri" href="al-Hassar" title="wikilink">al-Hassar</a> and <a href="Ibn_al-Banna" title="wikilink">Ibn al-Banna</a>, all three being mathematicians of <a href="Moroccan_people" title="wikilink">Moroccan</a> origin.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>Leonardo of Pisa (<a class="uri" href="Fibonacci" title="wikilink">Fibonacci</a>) devoted Chapter 13 of his book <em><a href="Liber_Abaci" title="wikilink">Liber Abaci</a></em> (AD 1202) to explaining and demonstrating the uses of double false position, terming the method <em>regulis elchatayn</em> after the <em>al-khaṭāʾayn</em> method that he had learned from <a class="uri" href="Arab" title="wikilink">Arab</a> sources.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="numerical-analysis">Numerical analysis</h2>

<p>In <a href="numerical_analysis" title="wikilink">numerical analysis</a>, double false position became a <a href="root-finding_algorithm" title="wikilink">root-finding algorithm</a> that combines features from the <a href="bisection_method" title="wikilink">bisection method</a> and the <a href="secant_method" title="wikilink">secant method</a>.</p>

<p> Like the bisection method, the false position method starts with two points <em>a</em><sub>0</sub> and <em>b</em><sub>0</sub> such that <em>f</em>(<em>a</em><sub>0</sub>) and <em>f</em>(<em>b</em><sub>0</sub>) are of opposite signs, which implies by the <a href="intermediate_value_theorem" title="wikilink">intermediate value theorem</a> that the function <em>f</em> has a root in the interval [<em>a</em><sub>0</sub>, <em>b</em><sub>0</sub>], assuming continuity of the function <em>f</em>. The method proceeds by producing a sequence of shrinking intervals [<em>a</em><sub><em>k</em></sub>, <em>b</em><sub><em>k</em></sub>] that all contain a root of <em>f</em>.</p>

<p>At iteration number <em>k</em>, the number</p>

<p>

<math display="block" id="False_position_method:4">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>b</mi>
     <mi>k</mi>
    </msub>
    <mo>-</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>b</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mfrac>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>b</mi>
         <mi>k</mi>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>a</mi>
         <mi>k</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>b</mi>
          <mi>k</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>a</mi>
          <mi>k</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>f</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>b</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>f</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{k}=b_{k}-f(b_{k})\frac{(b_{k}-a_{k})}{f(b_{k})-f(a_{k})}
  </annotation>
 </semantics>
</math>

 is computed. As explained below, <em>c</em><sub><em>k</em></sub> is the root of the secant line through (<em>a</em><sub><em>k</em></sub>, f(<em>a</em><sub><em>k</em></sub>)) and (<em>b</em><sub><em>k</em></sub>, f(<em>b</em><sub><em>k</em></sub>)). If f(<em>a</em><sub><em>k</em></sub>) and f(<em>c</em><sub><em>k</em></sub>) have the same sign, then we set <em>a</em><sub><em>k</em>+1</sub> = <em>c</em><sub><em>k</em></sub> and <em>b</em><sub><em>k</em>+1</sub> = <em>b</em><sub><em>k</em></sub>, otherwise we set <em>a</em><sub><em>k</em>+1</sub> = <em>a</em><sub><em>k</em></sub> and <em>b</em><sub><em>k</em>+1</sub> = <em>c</em><sub><em>k</em></sub>. This process is repeated until the root is approximated sufficiently well.</p>

<p>The above formula is also used in the secant method, but the secant method always retains the last two computed points, while the false position method retains two points which certainly bracket a root. On the other hand, the only difference between the false position method and the bisection method is that the latter uses <em>c</em><sub><em>k</em></sub> = (<em>a</em><sub><em>k</em></sub> + <em>b</em><sub><em>k</em></sub>) / 2.</p>
<h3 id="finding-the-root-of-the-secant">Finding the root of the secant</h3>

<p>Given <em>a</em><sub><em>k</em></sub> and <em>b</em><sub><em>k</em></sub>, we construct the line through the points (<em>a</em><sub><em>k</em></sub>, <em>f</em>(<em>a</em><sub><em>k</em></sub>)) and (<em>b</em><sub><em>k</em></sub>, <em>f</em>(<em>b</em><sub><em>k</em></sub>)), as demonstrated in the picture immediately above. Note that this line is a <a href="secant_method" title="wikilink">secant</a> or chord of the graph of the function <em>f</em>. In <a href="slope" title="wikilink">point-slope form</a>, it can be defined as</p>

<p>

<math display="block" id="False_position_method:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>y</mi>
     <mo>-</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>b</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>b</mi>
          <mi>k</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>a</mi>
          <mi>k</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mrow>
       <msub>
        <mi>b</mi>
        <mi>k</mi>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>a</mi>
        <mi>k</mi>
       </msub>
      </mrow>
     </mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <msub>
        <mi>b</mi>
        <mi>k</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <ci>y</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y-f(b_{k})=\frac{f(b_{k})-f(a_{k})}{b_{k}-a_{k}}(x-b_{k}).
  </annotation>
 </semantics>
</math>

</p>

<p>We now choose <em>c</em><sub><em>k</em></sub> to be the root of this line (substituting for <em>x</em>), and setting 

<math display="inline" id="False_position_method:6">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=0
  </annotation>
 </semantics>
</math>

 and see that</p>

<p>

<math display="block" id="False_position_method:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>b</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>b</mi>
          <mi>k</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>a</mi>
          <mi>k</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mrow>
       <msub>
        <mi>b</mi>
        <mi>k</mi>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>a</mi>
        <mi>k</mi>
       </msub>
      </mrow>
     </mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>c</mi>
        <mi>k</mi>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>b</mi>
        <mi>k</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>f</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>b</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>f</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <ci>k</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(b_{k})+\frac{f(b_{k})-f(a_{k})}{b_{k}-a_{k}}(c_{k}-b_{k})=0.
  </annotation>
 </semantics>
</math>

</p>

<p>Solving this equation gives the above equation for <em>c</em><sub><em>k</em></sub>.</p>

<p>

<math display="inline" id="False_position_method:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>b</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mstyle displaystyle="true">
     <mfrac>
      <mrow>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>b</mi>
          <mi>k</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>a</mi>
          <mi>k</mi>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mrow>
       <msub>
        <mi>b</mi>
        <mi>k</mi>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>a</mi>
        <mi>k</mi>
       </msub>
      </mrow>
     </mfrac>
    </mstyle>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>c</mi>
       <mi>k</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>b</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>b</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle f(b_{k})+\frac{f(b_{k})-f(a_{k})}{b_{k}-a_{k}}(c_{k}-b_{k})
  </annotation>
 </semantics>
</math>


</p>
<h2 id="analysis">Analysis</h2>

<p>If the initial end-points <em>a</em><sub>0</sub> and <em>b</em><sub>0</sub> are chosen such that <em>f</em>(<em>a</em><sub>0</sub>) and <em>f</em>(<em>b</em><sub>0</sub>) are of opposite signs, then at each step, one of the end-points will get closer to a root of <em>f</em>. If the second derivative of <em>f</em> is of constant sign (so there is no <a href="inflection_point" title="wikilink">inflection point</a>) in the interval, then one endpoint (the one where <em>f</em> also has the same sign) will remain fixed for all subsequent iterations while the converging endpoint becomes updated. As a result, unlike the <a href="bisection_method" title="wikilink">bisection method</a>, the width of the bracket does not tend to zero (unless the zero is at an inflection point around which <em>sign(f)=-sign(f″)</em>). As a consequence, the linear approximation to <em>f</em>(<em>x</em>), which is used to pick the false position, does not improve in its quality.</p>

<p>One example of this phenomenon is the function</p>

<p>

<math display="block" id="False_position_method:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mn>2</mn>
      <msup>
       <mi>x</mi>
       <mn>3</mn>
      </msup>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mn>4</mn>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>3</mn>
     <mi>x</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">4</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">3</cn>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=2x^{3}-4x^{2}+3x
  </annotation>
 </semantics>
</math>

 on the initial bracket [−1,1]. The left end, −1, is never replaced (after the first three iterations, <em>f″</em> is negative on the interval) and thus the width of the bracket never falls below 1. Hence, the right endpoint approaches 0 at a linear rate (the number of accurate digits grows linearly, with a <a href="rate_of_convergence" title="wikilink">rate of convergence</a> of 2/3).</p>

<p>For discontinuous functions, this method can only be expected to find a point where the function changes sign (for example at <em>x=0</em> for <a href="multiplicative_inverse" title="wikilink"><em>1/x</em></a> or the <a href="sign_function" title="wikilink">sign function</a>). In addition to sign changes, it is also possible for the method to converge to a point where the limit of the function is zero, even if the function is undefined (or has another value) at that point (for example at <em>x=0</em> for the function given by <em>f(x)=abs(x)-x²</em> when <em>x≠0</em> and by <em>f(0)=5</em>, starting with the interval [-0.5, 3.0]). It is mathematically possible with discontinuous functions for the method to fail to converge to a zero limit or sign change, but this is not a problem in practice since it would require an infinite sequence of coincidences for both endpoints to get stuck converging to discontinuities where the sign does not change (for example at <em>x=±1</em> in <em>f(x)=1/(x-1)²+1/(x+1)²</em>). The <a href="method_of_bisection" title="wikilink">method of bisection</a> avoids this hypothetical convergence problem.</p>
<h2 id="illinois-algorithm">Illinois algorithm</h2>

<p>While it is a misunderstanding to think that the method of false position is a good method, it is equally a mistake to think that it is unsalvageable. The failure mode is easy to detect (the same end-point is retained twice in a row) and easily remedied by next picking a modified false position, such as</p>

<p>

<math display="block" id="False_position_method:10">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>b</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>a</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>a</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>b</mi>
       <mi>k</mi>
      </msub>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>b</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>a</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{k}=\frac{\frac{1}{2}f(b_{k})a_{k}-f(a_{k})b_{k}}{\frac{1}{2}f(b_{k})-f(a_{k%
})}
  </annotation>
 </semantics>
</math>

 or</p>

<p>

<math display="block" id="False_position_method:11">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>b</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>a</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>a</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>b</mi>
       <mi>k</mi>
      </msub>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>b</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mn>2</mn>
      </mfrac>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>a</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{k}=\frac{f(b_{k})a_{k}-\frac{1}{2}f(a_{k})b_{k}}{f(b_{k})-\frac{1}{2}f(a_{k%
})}
  </annotation>
 </semantics>
</math>

 down-weighting one of the endpoint values to force the next <em>c</em><sub>k</sub> to occur on that side of the function. The factor of 2 above looks like a hack, but it guarantees superlinear convergence (asymptotically, the algorithm will perform two regular steps after any modified step, and has order of convergence 1.442). There are other ways to pick the rescaling which give even better superlinear convergence rates.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>The above adjustment to <em>regula falsi</em> is sometimes called the <strong>Illinois algorithm</strong>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Ford (1995) summarizes and analyzes this and other similar superlinear variants of the method of false position.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="example-code">Example code</h2>

<p>This example programme, written in the <a href="C_(programming_language)" title="wikilink">C programming language</a>, has been written for clarity instead of efficiency. It was designed to solve the same problem as solved by the <a href="Newton's_method" title="wikilink">Newton's method</a> and <a href="secant_method" title="wikilink">secant method</a> code: to find the positive number <em>x</em> where cos(<em>x</em>) = <em>x</em><sup>3</sup>. This problem is transformed into a root-finding problem of the form <em>f</em>(<em>x</em>) = cos(<em>x</em>) - <em>x</em><sup>3</sup> = 0.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include <stdio.h></stdio.h></span>
<span class="ot">#include <math.h></math.h></span>

<span class="dt">double</span> f(<span class="dt">double</span> x)
{
   <span class="kw">return</span> cos(x) - x*x*x;
}
<span class="co">/* s,t: endpoints of an interval where we search</span>
<span class="co">   e: half of upper bound for relative error</span>
<span class="co">   m: maximal number of iterations */</span>
<span class="dt">double</span> FalsiMethod(<span class="dt">double</span> s, <span class="dt">double</span> t, <span class="dt">double</span> e, <span class="dt">int</span> m)
{
   <span class="dt">double</span> r,fr;
   <span class="dt">int</span> n, side=<span class="dv">0</span>;
   <span class="co">/* starting values at endpoints of interval */</span>
   <span class="dt">double</span> fs = f(s);
   <span class="dt">double</span> ft = f(t);

   <span class="kw">for</span> (n = <span class="dv">0</span>; n &lt; m; n++)
   {

       r = (fs*t - ft*s) / (fs - ft);
       <span class="kw">if</span> (fabs(t-s) &lt; e*fabs(t+s)) <span class="kw">break</span>;
       fr = f(r);

       <span class="kw">if</span> (fr * ft &gt; <span class="dv">0</span>)
       {
         <span class="co">/* fr and ft have same sign, copy r to t */</span>
         t = r; ft = fr;
         <span class="kw">if</span> (side==-<span class="dv">1</span>) fs /= <span class="dv">2</span>;
         side = -<span class="dv">1</span>;
       }
       <span class="kw">else</span> <span class="kw">if</span> (fs * fr &gt; <span class="dv">0</span>)
       {
         <span class="co">/* fr and fs have same sign, copy r to s */</span>
         s = r;  fs = fr;
         <span class="kw">if</span> (side==+<span class="dv">1</span>) ft /= <span class="dv">2</span>;
         side = +<span class="dv">1</span>;
       }
       <span class="kw">else</span>
       {
         <span class="co">/* fr * f_ very small (looks like zero) */</span>
         <span class="kw">break</span>;
       } 
    }
    <span class="kw">return</span> r;
}

<span class="dt">int</span> main(<span class="dt">void</span>)
{
    printf(<span class="st">"%0.15f</span><span class="ch">\n</span><span class="st">"</span>, FalsiMethod(<span class="dv">0</span>, <span class="dv">1</span>, <span class="fl">5E-15</span>, <span class="dv">100</span>));
    <span class="kw">return</span> <span class="dv">0</span>;
}
</code></pre></div></body>

<p>After running this code, the final answer is approximately 0.865474033101614</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Ridders'_method" title="wikilink">Ridders' method</a>, another root-finding method based on the false position method</li>
<li><a href="Brent's_method" title="wikilink">Brent's method</a></li>
<li><a href="Secant_method" title="wikilink">Secant method</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Richard L. Burden, J. Douglas Faires (2000). <em>Numerical Analysis</em>, 7th ed. Brooks/Cole. ISBN 0-534-38216-9.</li>
<li>L.E. Sigler (2002). <em>Fibonacci's Liber Abaci, Leonardo Pisano's Book of Calculation</em>. Springer-Verlag, New York. ISBN 0-387-40737-5.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://math.fullerton.edu/mathews/n2003/RegulaFalsiMod.html">The Regula Falsi Method by John H. Mathews</a></li>
</ul>

<p>"</p>

<p><a href="Category:Root-finding_algorithms" title="wikilink">Category:Root-finding algorithms</a> <a href="Category:Articles_with_example_C_code" title="wikilink">Category:Articles with example C code</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Jean-Luc Chabert, ed., <em>A History of Algorithms: From the Pebble to the Microchip</em> (Berlin: Springer, 1999), pp. 86-91.<a href="#fnref1">↩</a></li>
<li id="fn2">Shen Kangshen, John N. Crossley and Anthony W.-C. Lun, 1999. <em>The Nine Chapters on the Mathematical Art: Companion and Commentary</em>. Oxford: Oxford University Press, p. 358.<a href="#fnref2">↩</a></li>
<li id="fn3"> Available online at: <a class="uri" href="http://facstaff.uindy.edu/~oaks/Biblio/COMHISMA8paper.doc">http://facstaff.uindy.edu/~oaks/Biblio/COMHISMA8paper.doc</a> and <a class="uri" href="http://www.ub.edu/islamsci/Schwartz.pdf">http://www.ub.edu/islamsci/Schwartz.pdf</a><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"></li>
</ol>
</section>


