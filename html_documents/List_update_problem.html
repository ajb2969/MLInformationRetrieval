<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1014">List update problem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>List update problem</h1>
<hr/>

<p>The <strong>List Update</strong> or the <strong>List Access</strong> problem is a simple model used in the study of <a href="Competitive_analysis_(online_algorithm)" title="wikilink">competitive analysis</a> of <a href="online_algorithms" title="wikilink">online algorithms</a>. Given a set of items in a list where the cost of accessing an item is proportional to its distance from the head of the list, e.g. a <a href="Linked_List" title="wikilink">Linked List</a>, and a request sequence of accesses, the problem is to come up with a strategy of reordering the list so that the total cost of accesses is minimized. The reordering can be done at any time but incurs a cost. The standard model includes two reordering actions:</p>
<ul>
<li>A free transposition of the item being accessed anywhere ahead of its current position;</li>
<li>A paid transposition of a unit cost for exchanging any two items in the list. Performance of algorithms depend on the construction of request sequences by adversaries under various <a href="Adversary_model" title="wikilink">Adversary models</a></li>
</ul>

<p>An online algorithm for this problem has to reorder the elements and serve requests based only on the knowledge of previously requested items and hence its strategy may not have the optimum cost as compared to an offline algorithm that gets to see the entire request sequence and devise a complete strategy before serving the first request.</p>
<h2 id="adversary-models">Adversary Models</h2>

<p>An adversary is an entity that gets to choose the request sequence 

<math display="inline" id="List_update_problem:0">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 for an algorithm <em>ALG</em>. Depending of whether 

<math display="inline" id="List_update_problem:1">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 can be changed based on the strategy of <em>ALG</em>, adversaries are given various powers, and the performance of <em>ALG</em> is measured against these adversaries.</p>

<p>An <strong>oblivious adversary</strong> has to construct the entire request sequence 

<math display="inline" id="List_update_problem:2">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 before running <em>ALG</em>, and pays the optimal offline price, 

<math display="inline" id="List_update_problem:3">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>P</mi>
   <mi>T</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>σ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>P</ci>
    <ci>T</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   OPT(\sigma)
  </annotation>
 </semantics>
</math>

 which is compared against 

<math display="inline" id="List_update_problem:4">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mi>L</mi>
   <mi>G</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>σ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>L</ci>
    <ci>G</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ALG(\sigma)
  </annotation>
 </semantics>
</math>

</p>

<p>An <strong>adaptive online adversary</strong> gets to make the next request based on the previous results of the online algorithm, but pays for the request optimally and online.</p>

<p>An <strong>adaptive offline adversary</strong> gets to make the next request based on the previous results of the online algorithm, but pays the optimal offline cost.</p>
<h2 id="offline-algorithms">Offline algorithms</h2>

<p>Competitive analysis for many list update problems were carried out without any specific knowledge of the exact nature of the optimum offline algorithm (OPT). The best known algorithm runs in O(<em>n</em>2<sup><em>l</em></sup>(<em>l</em>-1)!) time and O(<em>l</em>!) space where <em>n</em> is the length of the request sequence and <em>l</em> is the length of the list.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>It is interesting to note that paid transpositions are in general necessary for optimum algorithms. Consider a list (<em>a</em>,<em>b</em>,<em>c</em>) where <em>a</em> is at the head of the list, and a request sequence <em>c</em>,<em>b</em>,<em>c</em>,<em>b</em>. An optimal offline algorithm using only free exchanges would cost 9 (3+3+2+1), whereas an optimal offline algorithm using only paid exchanges would cost 8. So, we cannot get away with just using free transpositions for the optimum offline algorithm.</p>

<p>The optimum list update problem was proven to be <a class="uri" href="NP-Hard" title="wikilink">NP-Hard</a> by .</p>
<h2 id="online-algorithm">Online algorithm</h2>

<p>An online algorithm <em>ALG</em> has a competitive ratio <em>c</em> if for any input it performs at least as good as <em>c</em> times worse than OPT. i.e. if there exists an 

<math display="inline" id="List_update_problem:5">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>α</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\geq 0
  </annotation>
 </semantics>
</math>

 such that for all finite length request sequences 

<math display="inline" id="List_update_problem:6">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="List_update_problem:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mi>L</mi>
     <mi>G</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>σ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mi>c</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mi>O</mi>
     <mi>P</mi>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>σ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mi>α</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>L</ci>
      <ci>G</ci>
      <ci>σ</ci>
     </apply>
     <ci>c</ci>
    </apply>
    <apply>
     <leq></leq>
     <apply>
      <times></times>
      <ci>O</ci>
      <ci>P</ci>
      <ci>T</ci>
      <ci>σ</ci>
     </apply>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ALG(\sigma)-c.OPT(\sigma)\leq\alpha
  </annotation>
 </semantics>
</math>

. Online algorithms can either be deterministic or randomized and it turns out that randomization in this case can truly help against oblivious adversaries.</p>
<h3 id="deterministic">Deterministic</h3>

<p>Most deterministic algorithms are variants of these three algorithms :</p>
<dl>
<dt>MTF (Move to front) : After accessing an item move it to the front of the list without changing the order of other items<br/>
TRANS (Transpose) : After accessing an item, transpose it with the immediately preceding item.<br/>
FC (Frequency Count) : For each item maintain a frequency count of the number of accesses to it - when an element is accessed increase its frequency count and reorder the list in the decreasing order of frequencies.</dt>
</dl>

<p>Observe that all these use just free transpositions. It turns out that both TRANS and FC are not competitive. In a classic result using <a href="Potential_method" title="wikilink">Potential method</a> analysis  proved that MTF is 2-competitive. The proof does not require the explicit knowledge of OPT but instead counts the number of inversions i.e. elements occurring in opposite order in the lists of MTF and OPT.</p>

<p>Any deterministic algorithm has a lower bound of 

<math display="inline" id="List_update_problem:8">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mo>-</mo>
   <mfrac>
    <mn>2</mn>
    <mrow>
     <mi>l</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">2</cn>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <apply>
      <plus></plus>
      <ci>l</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2-\frac{2}{l+1}
  </annotation>
 </semantics>
</math>

 for a list of length <em>l</em>, and MTF is actually the optimum deterministic list update algorithm. The type of adversary doesn't matter in the case of deterministic algorithms, because the adversary can run a copy of the deterministic algorithm on his own to precompute the most disastrous sequence.</p>
<h3 id="randomized">Randomized</h3>

<p>Consider the following simple randomized algorithm :</p>
<dl>
<dt>BIT : For every item in the list, maintain a bit. Initialize all the bits uniformly and randomly to 0 or 1. When an item is accessed, flip the bit, and if it is 1 move it to the front, else don't.</dt>
</dl>

<p>This algorithm is barely random - it makes all its random choices in the beginning and not during the run. It turns out that BIT breaks the deterministic bound - it is <strong>better</strong> than MTF against oblivious adversaries. It is 7/4-competitive. There are other randomized algorithms, like COMB, that perform better than BIT. Boris Teia proved a lower bound of 1.5 for any randomized list update algorithm.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="related-problems">Related Problems</h2>

<p>The list update problem where elements maybe inserted and deleted is called the dynamic list update problem, as opposed to the static list update problem where only accessing list elements are allowed. The upper bound of 

<math display="inline" id="List_update_problem:9">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mo>-</mo>
   <mfrac>
    <mn>2</mn>
    <mrow>
     <mi>l</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">2</cn>
    <apply>
     <divide></divide>
     <cn type="integer">2</cn>
     <apply>
      <plus></plus>
      <ci>l</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2-\frac{2}{l+1}
  </annotation>
 </semantics>
</math>

 holds for the dynamic model as well.</p>

<p>There are different cost models as well. In the usual full cost model, an access to an element located at a position <em>i</em> costs <em>i</em>, but the last comparison is inevitable for any algorithm, i.e. there are <em>i-1</em> elements standing in the way of <em>i</em>. In the partial cost model, these final comparison costs totaling to the number of elements in the request sequence are ignored. For the costs of paid transpositions other than unity, <strong>P</strong><sup><strong>d</strong></sup> models are used.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Online_algorithm" title="wikilink">Online algorithm</a></li>
<li><a href="Competitive_analysis_(online_algorithm)" title="wikilink">Competitive analysis</a></li>
<li><a href="Cache_algorithms" title="wikilink">Cache algorithms</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
</ul>
<ul>
<li></li>
</ul>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Analysis_of_algorithms" title="wikilink">Category:Analysis of algorithms</a> <a href="Category:Online_algorithms" title="wikilink">Category:Online algorithms</a> <a href="Category:Randomized_algorithms" title="wikilink">Category:Randomized algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">N. Reingold and J. Westbrook. Optimum Offline algorithms for the list update and paging rules. Technical Report YALE/DcS/TR-805, Yale University, New Haven, Conn, August 1990<a href="#fnref1">↩</a></li>
<li id="fn2">Teia, Boris, A lower bound for randomized list update algorithms, Inf. Process. Lett. (1993), pp. 5--9<a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
