<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="907">Optical flow</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Optical flow</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>The optic flow experienced by a rotating observer (in this case a fly). The direction and magnitude of optic flow at each location is represented by the direction and length of each arrow.</figcaption>
</figure>

<p><strong>Optical flow</strong> or <strong>optic flow</strong> is the pattern of apparent <a href="motion_(physics)" title="wikilink">motion</a> of objects, surfaces, and edges in a visual scene caused by the relative motion between an observer (an <a href="human_eye" title="wikilink">eye</a> or a <a class="uri" href="camera" title="wikilink">camera</a>) and the scene.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The concept of optical flow was introduced by the American psychologist <a href="James_J._Gibson" title="wikilink">James J. Gibson</a> in the 1940s to describe the visual stimulus provided to animals moving through the world.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Gibson stressed the importance of optic flow for <a href="Affordance" title="wikilink">affordance perception</a>, the ability to discern possibilities for action within the environment. Followers of Gibson and his <a href="Ecological_Psychology" title="wikilink">ecological approach to psychology</a> have further demonstrated the role of the optical flow stimulus for the perception of movement by the observer in the world; perception of the shape, distance and movement of objects in the world; and the control of locomotion.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The term optical flow is also used by roboticist, encompassing related techniques from image processing and control of navigation including motion detection, object segmentation, time-to-contact information, focus of expansion calculations, luminance, motion compensated encoding, and stereo disparity measurement.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="estimation">Estimation</h2>

<p>Sequences of ordered images allow the estimation of motion as either instantaneous image velocities or discrete image displacements.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Fleet and Weiss provide a tutorial introduction to gradient based optical flow .<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> John L. Barron, David J. Fleet, and Steven Beauchemin provide a performance analysis of a number of optical flow techniques. It emphasizes the accuracy and density of measurements.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>The optical flow methods try to calculate the motion between two image frames which are taken at times <em>t</em> and 

<math display="inline" id="Optical_flow:0">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>+</mo>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mi>t</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>t</ci>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t+\Delta t
  </annotation>
 </semantics>
</math>

 at every <a class="uri" href="voxel" title="wikilink">voxel</a> position. These methods are called differential since they are based on local <a href="Taylor_series" title="wikilink">Taylor series</a> approximations of the image signal; that is, they use partial derivatives with respect to the spatial and temporal coordinates.</p>

<p>For a 2D+<em>t</em> dimensional case (3D or <em>n</em>-D cases are similar) a voxel at location 

<math display="inline" id="Optical_flow:1">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo>,</mo>
   <mi>t</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>x</ci>
    <ci>y</ci>
    <ci>t</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y,t)
  </annotation>
 </semantics>
</math>

 with intensity 

<math display="inline" id="Optical_flow:2">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <vector>
     <ci>x</ci>
     <ci>y</ci>
     <ci>t</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(x,y,t)
  </annotation>
 </semantics>
</math>

 will have moved by 

<math display="inline" id="Optical_flow:3">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta x
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Optical_flow:4">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta y
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Optical_flow:5">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta t
  </annotation>
 </semantics>
</math>

 between the two image frames, and the following <em>brightness constancy constraint</em> can be given:</p>

<p>

<math display="block" id="Optical_flow:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>I</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>I</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>+</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>x</mi>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>y</mi>
      <mo>+</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>y</mi>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>t</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>I</ci>
     <vector>
      <ci>x</ci>
      <ci>y</ci>
      <ci>t</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <ci>I</ci>
     <vector>
      <apply>
       <plus></plus>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <ci>y</ci>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>y</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(x,y,t)=I(x+\Delta x,y+\Delta y,t+\Delta t)
  </annotation>
 </semantics>
</math>

</p>

<p>Assuming the movement to be small, the image constraint at 

<math display="inline" id="Optical_flow:7">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <vector>
     <ci>x</ci>
     <ci>y</ci>
     <ci>t</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(x,y,t)
  </annotation>
 </semantics>
</math>

 with <a href="Taylor_series" title="wikilink">Taylor series</a> can be developed to get:</p>

<p>

<math display="block" id="Optical_flow:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>I</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>+</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>x</mi>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>y</mi>
      <mo>+</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>y</mi>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>t</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>I</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mo>∂</mo>
       <mi>I</mi>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <mi>x</mi>
      </mrow>
     </mfrac>
     <mi mathvariant="normal">Δ</mi>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mo>∂</mo>
       <mi>I</mi>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <mi>y</mi>
      </mrow>
     </mfrac>
     <mi mathvariant="normal">Δ</mi>
     <mi>y</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mfrac>
       <mrow>
        <mo>∂</mo>
        <mi>I</mi>
       </mrow>
       <mrow>
        <mo>∂</mo>
        <mi>t</mi>
       </mrow>
      </mfrac>
      <mi mathvariant="normal">Δ</mi>
      <mi>t</mi>
     </mrow>
     <mo>+</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>I</ci>
     <vector>
      <apply>
       <plus></plus>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <ci>y</ci>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>y</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <ci>t</ci>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </vector>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>I</ci>
      <vector>
       <ci>x</ci>
       <ci>y</ci>
       <ci>t</ci>
      </vector>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>I</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>x</ci>
       </apply>
      </apply>
      <ci>normal-Δ</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>I</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>y</ci>
       </apply>
      </apply>
      <ci>normal-Δ</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">limit-from</csymbol>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <partialdiff></partialdiff>
         <ci>I</ci>
        </apply>
        <apply>
         <partialdiff></partialdiff>
         <ci>t</ci>
        </apply>
       </apply>
       <ci>normal-Δ</ci>
       <ci>t</ci>
      </apply>
      <plus></plus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(x+\Delta x,y+\Delta y,t+\Delta t)=I(x,y,t)+\frac{\partial I}{\partial x}%
\Delta x+\frac{\partial I}{\partial y}\Delta y+\frac{\partial I}{\partial t}%
\Delta t+
  </annotation>
 </semantics>
</math>

<a href="higher-order_terms" title="wikilink">H.O.T.</a> From these equations it follows that:</p>

<p>

<math display="block" id="Optical_flow:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mfrac>
      <mrow>
       <mo>∂</mo>
       <mi>I</mi>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <mi>x</mi>
      </mrow>
     </mfrac>
     <mi mathvariant="normal">Δ</mi>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mo>∂</mo>
       <mi>I</mi>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <mi>y</mi>
      </mrow>
     </mfrac>
     <mi mathvariant="normal">Δ</mi>
     <mi>y</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mo>∂</mo>
       <mi>I</mi>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <mi>t</mi>
      </mrow>
     </mfrac>
     <mi mathvariant="normal">Δ</mi>
     <mi>t</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>I</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>x</ci>
       </apply>
      </apply>
      <ci>normal-Δ</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>I</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>y</ci>
       </apply>
      </apply>
      <ci>normal-Δ</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>I</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>t</ci>
       </apply>
      </apply>
      <ci>normal-Δ</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial I}{\partial x}\Delta x+\frac{\partial I}{\partial y}\Delta y+%
\frac{\partial I}{\partial t}\Delta t=0
  </annotation>
 </semantics>
</math>

 or</p>

<p>

<math display="block" id="Optical_flow:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mfrac>
      <mrow>
       <mo>∂</mo>
       <mi>I</mi>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <mi>x</mi>
      </mrow>
     </mfrac>
     <mfrac>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>x</mi>
      </mrow>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>t</mi>
      </mrow>
     </mfrac>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mo>∂</mo>
       <mi>I</mi>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <mi>y</mi>
      </mrow>
     </mfrac>
     <mfrac>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>y</mi>
      </mrow>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>t</mi>
      </mrow>
     </mfrac>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mo>∂</mo>
       <mi>I</mi>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <mi>t</mi>
      </mrow>
     </mfrac>
     <mfrac>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>t</mi>
      </mrow>
      <mrow>
       <mi mathvariant="normal">Δ</mi>
       <mi>t</mi>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>I</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>x</ci>
       </apply>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>I</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>y</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>y</ci>
       </apply>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>I</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <times></times>
        <ci>normal-Δ</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial I}{\partial x}\frac{\Delta x}{\Delta t}+\frac{\partial I}{%
\partial y}\frac{\Delta y}{\Delta t}+\frac{\partial I}{\partial t}\frac{\Delta
t%
}{\Delta t}=0
  </annotation>
 </semantics>
</math>

 which results in</p>

<p>

<math display="block" id="Optical_flow:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mfrac>
      <mrow>
       <mo>∂</mo>
       <mi>I</mi>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <mi>x</mi>
      </mrow>
     </mfrac>
     <msub>
      <mi>V</mi>
      <mi>x</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mo>∂</mo>
       <mi>I</mi>
      </mrow>
      <mrow>
       <mo>∂</mo>
       <mi>y</mi>
      </mrow>
     </mfrac>
     <msub>
      <mi>V</mi>
      <mi>y</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mfrac>
     <mrow>
      <mo>∂</mo>
      <mi>I</mi>
     </mrow>
     <mrow>
      <mo>∂</mo>
      <mi>t</mi>
     </mrow>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>I</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <partialdiff></partialdiff>
        <ci>I</ci>
       </apply>
       <apply>
        <partialdiff></partialdiff>
        <ci>y</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>y</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <partialdiff></partialdiff>
       <ci>I</ci>
      </apply>
      <apply>
       <partialdiff></partialdiff>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\partial I}{\partial x}V_{x}+\frac{\partial I}{\partial y}V_{y}+\frac{%
\partial I}{\partial t}=0
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Optical_flow:12">
 <semantics>
  <mrow>
   <msub>
    <mi>V</mi>
    <mi>x</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>V</mi>
    <mi>y</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <ci>y</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{x},V_{y}
  </annotation>
 </semantics>
</math>

 are the 

<math display="inline" id="Optical_flow:13">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Optical_flow:14">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 components of the velocity or optical flow of 

<math display="inline" id="Optical_flow:15">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <vector>
     <ci>x</ci>
     <ci>y</ci>
     <ci>t</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I(x,y,t)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Optical_flow:16">
 <semantics>
  <mfrac>
   <mrow>
    <mo>∂</mo>
    <mi>I</mi>
   </mrow>
   <mrow>
    <mo>∂</mo>
    <mi>x</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <partialdiff></partialdiff>
     <ci>I</ci>
    </apply>
    <apply>
     <partialdiff></partialdiff>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{\partial I}{\partial x}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Optical_flow:17">
 <semantics>
  <mfrac>
   <mrow>
    <mo>∂</mo>
    <mi>I</mi>
   </mrow>
   <mrow>
    <mo>∂</mo>
    <mi>y</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <partialdiff></partialdiff>
     <ci>I</ci>
    </apply>
    <apply>
     <partialdiff></partialdiff>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{\partial I}{\partial y}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Optical_flow:18">
 <semantics>
  <mfrac>
   <mrow>
    <mo>∂</mo>
    <mi>I</mi>
   </mrow>
   <mrow>
    <mo>∂</mo>
    <mi>t</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <partialdiff></partialdiff>
     <ci>I</ci>
    </apply>
    <apply>
     <partialdiff></partialdiff>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{\partial I}{\partial t}
  </annotation>
 </semantics>
</math>

 are the derivatives of the image at 

<math display="inline" id="Optical_flow:19">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo>,</mo>
   <mi>t</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>x</ci>
    <ci>y</ci>
    <ci>t</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y,t)
  </annotation>
 </semantics>
</math>

 in the corresponding directions. 

<math display="inline" id="Optical_flow:20">
 <semantics>
  <msub>
   <mi>I</mi>
   <mi>x</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{x}
  </annotation>
 </semantics>
</math>

,

<math display="inline" id="Optical_flow:21">
 <semantics>
  <msub>
   <mi>I</mi>
   <mi>y</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{y}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Optical_flow:22">
 <semantics>
  <msub>
   <mi>I</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>I</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{t}
  </annotation>
 </semantics>
</math>

 can be written for the derivatives in the following.</p>

<p>Thus:</p>

<p>

<math display="block" id="Optical_flow:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>I</mi>
      <mi>x</mi>
     </msub>
     <msub>
      <mi>V</mi>
      <mi>x</mi>
     </msub>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>I</mi>
      <mi>y</mi>
     </msub>
     <msub>
      <mi>V</mi>
      <mi>y</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <msub>
     <mi>I</mi>
     <mi>t</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>y</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{x}V_{x}+I_{y}V_{y}=-I_{t}
  </annotation>
 </semantics>
</math>

 or</p>

<p>

<math display="block" id="Optical_flow:24">
 <semantics>
  <mrow>
   <mrow>
    <mo>∇</mo>
    <mrow>
     <msup>
      <mi>I</mi>
      <mi>T</mi>
     </msup>
     <mo>⋅</mo>
     <mover accent="true">
      <mi>V</mi>
      <mo stretchy="false">→</mo>
     </mover>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <msub>
     <mi>I</mi>
     <mi>t</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-∇</ci>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>I</ci>
       <ci>T</ci>
      </apply>
      <apply>
       <ci>normal-→</ci>
       <ci>V</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla I^{T}\cdot\vec{V}=-I_{t}
  </annotation>
 </semantics>
</math>

 This is an equation in two unknowns and cannot be solved as such. This is known as the <em><a href="Motion_perception#The_aperture_problem" title="wikilink">aperture problem</a></em> of the optical flow algorithms. To find the optical flow another set of equations is needed, given by some additional constraint. All optical flow methods introduce additional conditions for estimating the actual flow.</p>
<h3 id="methods-for-determination">Methods for determination</h3>
<ul>
<li><a href="Phase_correlation" title="wikilink">Phase correlation</a> – inverse of normalized cross-power spectrum</li>
<li>Block-based methods – minimizing sum of squared differences or <a href="sum_of_absolute_differences" title="wikilink">sum of absolute differences</a>, or maximizing normalized <a class="uri" href="cross-correlation" title="wikilink">cross-correlation</a></li>
<li>Differential methods of estimating optical flow, based on partial derivatives of the image signal and/or the sought flow field and higher-order partial derivatives, such as:
<ul>
<li><a href="Lucas–Kanade_method" title="wikilink">Lucas–Kanade method</a> – regarding image patches and an affine model for the flow field</li>
<li><a href="Horn–Schunck_method" title="wikilink">Horn–Schunck method</a> – optimizing a functional based on residuals from the brightness constancy constraint, and a particular regularization term expressing the expected smoothness of the flow field</li>
<li><a href="Buxton–Buxton_method" title="wikilink">Buxton–Buxton method</a> – based on a model of the motion of edges in image sequences<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></li>
<li><a href="Black–Jepson_method" title="wikilink">Black–Jepson method</a> – coarse optical flow via correlation<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></li>
<li>General <a href="variational_methods" title="wikilink">variational methods</a> – a range of modifications/extensions of Horn–Schunck, using other data terms and other smoothness terms.</li>
</ul></li>
<li>Discrete optimization methods – the search space is quantized, and then image matching is addressed through label assignment at every pixel, such that the corresponding deformation minimizes the distance between the source and the target image.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> The optimal solution is often recovered through <a href="Max-flow_min-cut_theorem" title="wikilink">Max-flow min-cut theorem</a> algorithms, linear programming or belief propagation methods.</li>
</ul>

<p>Many of these, in addition to the current state-of-the-art algorithms are evaluated on the Middlebury Benchmark Dataset.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h2 id="uses">Uses</h2>

<p><a href="Motion_estimation" title="wikilink">Motion estimation</a> and <a href="video_compression" title="wikilink">video compression</a> have developed as a major aspect of optical flow research. While the optical flow field is superficially similar to a dense motion field derived from the techniques of motion estimation, optical flow is the study of not only the determination of the optical flow field itself, but also of its use in estimating the three-dimensional nature and structure of the scene, as well as the 3D motion of objects and the observer relative to the scene, most of them using the <a href="Jacobian_matrix_and_determinant#Image_Jacobian" title="wikilink">Image Jacobian</a>.</p>

<p>Optical flow was used by robotics researchers in many areas such as: object detection and tracking, image dominant plane extraction, movement detection, robot navigation and <a href="visual_odometry" title="wikilink">visual odometry</a>.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Optical flow information has been recognized as being useful for controlling micro air vehicles.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>

<p>The application of optical flow includes the problem of inferring not only the motion of the observer and objects in the scene, but also the <a class="uri" href="structure" title="wikilink">structure</a> of objects and the environment. Since awareness of motion and the generation of mental maps of the structure of our environment are critical components of animal (and human) <a href="Visual_perception" title="wikilink">vision</a>, the conversion of this innate ability to a computer capability is similarly crucial in the field of <a href="machine_vision" title="wikilink">machine vision</a>.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<figure><b>(Figure)</b>
<figcaption>The optical flow vector of a moving object in a video sequence.</figcaption>
</figure>

<p>Consider a five-frame clip of a ball moving from the bottom left of a field of vision, to the top right. Motion estimation techniques can determine that on a two dimensional plane the ball is moving up and to the right and vectors describing this motion can be extracted from the sequence of frames. For the purposes of video compression (e.g., <a class="uri" href="MPEG" title="wikilink">MPEG</a>), the sequence is now described as well as it needs to be. However, in the field of machine vision, the question of whether the ball is moving to the right or if the observer is moving to the left is unknowable yet critical information. Not even if a static, patterned background were present in the five frames, could we confidently state that the ball was moving to the right, because the pattern might have an infinite distance to the observer.</p>
<h2 id="optical-flow-sensor">Optical flow sensor</h2>

<p>An optical flow sensor is a vision sensor capable of measuring optical flow or visual motion and outputting a measurement based on optical flow. Various configurations of optical flow sensors exist. One configuration is an image sensor chip connected to a processor programmed to run an optical flow algorithm. Another configuration uses a vision chip, which is an integrated circuit having both the <a href="image_sensor" title="wikilink">image sensor</a> and the processor on the same die, allowing for a compact implementation.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> An example of this is a generic optical mouse sensor used in an <a href="optical_mouse" title="wikilink">optical mouse</a>. In some cases the processing circuitry may be implemented using analog or mixed-signal circuits to enable fast optical flow computation using minimal current consumption.</p>

<p>One area of contemporary research is the use of <a href="neuromorphic_engineering" title="wikilink">neuromorphic engineering</a> techniques to implement circuits that respond to optical flow, and thus may be appropriate for use in an optical flow sensor.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> Such circuits may draw inspiration from biological neural circuitry that similarly responds to optical flow.</p>

<p>Optical flow sensors are used extensively in computer <a href="optical_mouse" title="wikilink">optical mice</a>, as the main sensing component for measuring the motion of the mouse across a surface.</p>

<p>Optical flow sensors are also being used in <a class="uri" href="robotics" title="wikilink">robotics</a> applications, primarily where there is a need to measure <a href="optical_flow" title="wikilink">visual motion</a> or relative motion between the robot and other objects in the vicinity of the robot. The use of optical flow sensors in <a href="unmanned_aerial_vehicle" title="wikilink"> unmanned aerial vehicles (UAVs)</a>, for stability and obstacle avoidance, is also an area of current research.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Optical_mouse" title="wikilink">Optical mouse</a></li>
<li><a href="Ambient_optic_array" title="wikilink">Ambient optic array</a></li>
<li><a href="Range_imaging" title="wikilink">Range imaging</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://users.fmrib.ox.ac.uk/~steve/review/review/node1.html#SECTION00010000000000000000">Finding Optic Flow</a></li>
<li><a href="http://www.fxguide.com/featured/art_of_optical_flow/">Art of Optical Flow article on fxguide.com (using optical flow in Visual Effects)</a></li>
<li><a href="http://of-eval.sourceforge.net/">Optical flow evaluation and ground truth sequences.</a></li>
<li><a href="http://vision.middlebury.edu/flow/">Middlebury Optical flow evaluation and ground truth sequences.</a></li>
<li><a href="http://www.mrf-registration.net/">mrf-registration.net - Optical flow estimation through MRF</a></li>
<li><a href="http://www.onera.fr/dtim-en/gpu-for-image/folkigpu.php">The French Aerospace Lab :</a> GPU implementation of a Lucas-Kanade based optical flow</li>
<li><a href="http://www.cuvilib.com/features/motion-estimation/">CUDA Implementation</a> by CUVI (CUDA Vision &amp; Imaging Library)</li>
<li><a href="http://www.ipol.im/pub/art/2013/20/">Horn and Schunck Optical Flow:</a> Online demo and source code of the Horn and Schunck method</li>
<li><a href="http://www.ipol.im/pub/art/2013/26/">TV-L1 Optical Flow:</a> Online demo and source code of the Zach et al. method</li>
<li><a href="http://www.ipol.im/pub/art/2013/21/">Robust Optical Flow:</a> Online demo and source code of the Brox et al. method</li>
</ul>

<p>"</p>

<p><a href="Category:Motion_in_computer_vision" title="wikilink">Category:Motion in computer vision</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a class="uri" href="http://vision.middlebury.edu/flow/">http://vision.middlebury.edu/flow/</a><a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15">Barrows G.L., Chahl J.S., and Srinivasan M.V., Biologically inspired visual sensing and flight control, Aeronautical Journal vol. 107, pp. 159–268, 2003.<a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17">Vision Chips, by Alireza Moini, Kluwer Academic Publishers, 2000<a href="#fnref17">↩</a></li>
<li id="fn18">Analog VLSI and Neural Systems, by Carver Mead, 1989<a href="#fnref18">↩</a></li>
<li id="fn19">Analog VLSI Circuits for the Perception of Visual Motion, by Alan Stocker, Wiley and Sons, 2006<a href="#fnref19">↩</a></li>
<li id="fn20">Flying Insects and Robotics, Ed. by Floreano, Zufferey, and Srinivasan, Springer, 2006<a href="#fnref20">↩</a></li>
</ol>
</section>
</body>
</html>
