<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="165">Brent's method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Brent's method</h1>
<hr/>

<p>In <a href="numerical_analysis" title="wikilink">numerical analysis</a>, <strong>Brent's method</strong> is a complicated but popular <a href="root-finding_algorithm" title="wikilink">root-finding algorithm</a> combining the <a href="bisection_method" title="wikilink">bisection method</a>, the <a href="secant_method" title="wikilink">secant method</a> and <a href="inverse_quadratic_interpolation" title="wikilink">inverse quadratic interpolation</a>. It has the reliability of bisection but it can be as quick as some of the less reliable methods. The algorithm tries to use the potentially fast-converging secant method or inverse quadratic interpolation if possible, but it falls back to the more robust bisection method if necessary. Brent's method is due to <a href="Richard_Brent_(scientist)" title="wikilink">Richard Brent</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and builds on an earlier algorithm by <a href="Theodorus_Dekker" title="wikilink">Theodorus Dekker</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Consequently, the method is also known as <strong>Brent-Dekker</strong>.</p>
<h2 id="dekkers-method">Dekker's method</h2>

<p>The idea to combine the bisection method with the secant method goes back to .</p>

<p>Suppose that we want to solve the equation <em>f</em>(<em>x</em>) = 0. As with the bisection method, we need to initialize Dekker's method with two points, say <em>a</em><sub>0</sub> and <em>b</em><sub>0</sub>, such that <em>f</em>(<em>a</em><sub>0</sub>) and <em>f</em>(<em>b</em><sub>0</sub>) have opposite signs. If <em>f</em> is continuous on [<em>a</em><sub>0</sub>, <em>b</em><sub>0</sub>], the <a href="intermediate_value_theorem" title="wikilink">intermediate value theorem</a> guarantees the existence of a solution between <em>a</em><sub>0</sub> and <em>b</em><sub>0</sub>.</p>

<p>Three points are involved in every iteration:</p>
<ul>
<li><em>b</em><sub><em>k</em></sub> is the current iterate, i.e., the current guess for the root of <em>f</em>.</li>
<li><em>a</em><sub><em>k</em></sub> is the "contrapoint," i.e., a point such that <em>f</em>(<em>a</em><sub><em>k</em></sub>) and <em>f</em>(<em>b</em><sub><em>k</em></sub>) have opposite signs, so the interval [<em>a</em><sub><em>k</em></sub>, <em>b</em><sub><em>k</em></sub>] contains the solution. Furthermore, |<em>f</em>(<em>b</em><sub><em>k</em></sub>)| should be less than or equal to |<em>f</em>(<em>a</em><sub><em>k</em></sub>)|, so that <em>b</em><sub><em>k</em></sub> is a better guess for the unknown solution than <em>a</em><sub><em>k</em></sub>.</li>
<li><em>b</em><sub><em>k</em>−1</sub> is the previous iterate (for the first iteration, we set <em>b</em><sub><em>k</em>−1</sub> = <em>a</em><sub>0</sub>).</li>
</ul>

<p>Two provisional values for the next iterate are computed. The first one is given by linear interpolation, also known as the secant method:</p>

<p>

<math display="block" id="Brent's_method:0">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <msub>
          <mi>b</mi>
          <mi>k</mi>
         </msub>
         <mo>-</mo>
         <mrow>
          <mstyle displaystyle="false">
           <mfrac>
            <mrow>
             <msub>
              <mi>b</mi>
              <mi>k</mi>
             </msub>
             <mo>-</mo>
             <msub>
              <mi>b</mi>
              <mrow>
               <mi>k</mi>
               <mo>-</mo>
               <mn>1</mn>
              </mrow>
             </msub>
            </mrow>
            <mrow>
             <mrow>
              <mi>f</mi>
              <mrow>
               <mo stretchy="false">(</mo>
               <msub>
                <mi>b</mi>
                <mi>k</mi>
               </msub>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
             <mo>-</mo>
             <mrow>
              <mi>f</mi>
              <mrow>
               <mo stretchy="false">(</mo>
               <msub>
                <mi>b</mi>
                <mrow>
                 <mi>k</mi>
                 <mo>-</mo>
                 <mn>1</mn>
                </mrow>
               </msub>
               <mo stretchy="false">)</mo>
              </mrow>
             </mrow>
            </mrow>
           </mfrac>
          </mstyle>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>b</mi>
            <mi>k</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>,</mo>
       </mrow>
      </mtd>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>b</mi>
           <mi>k</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>≠</mo>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>b</mi>
           <mrow>
            <mi>k</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mi>m</mi>
      </mtd>
      <mtd columnalign="left">
       <mtext>otherwise</mtext>
      </mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>b</ci>
          <ci>k</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>b</ci>
          <apply>
           <minus></minus>
           <ci>k</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>f</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>b</ci>
           <ci>k</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>f</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>b</ci>
           <apply>
            <minus></minus>
            <ci>k</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <neq></neq>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <apply>
         <minus></minus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>m</ci>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=\begin{cases}b_{k}-\frac{b_{k}-b_{k-1}}{f(b_{k})-f(b_{k-1})}f(b_{k}),&\mbox{%
if }f(b_{k})\neq f(b_{k-1})\\
m&\mbox{otherwise }\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>and the second one is given by the bisection method</p>
<dl>
<dd>
</dd>
</dl>

<p>

<math display="inline" id="Brent's_method:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>m</mi>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <msub>
       <mi>a</mi>
       <mi>k</mi>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>b</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mn>2</mn>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=\frac{a_{k}+b_{k}}{2}.
  </annotation>
 </semantics>
</math>

 If the result of the secant method, <em>s</em>, lies strictly between <em>b</em><sub><em>k</em></sub> and <em>m</em>, then it becomes the next iterate (<em>b</em><sub><em>k</em>+1</sub> = <em>s</em>), otherwise the midpoint is used (<em>b</em><sub><em>k</em>+1</sub> = <em>m</em>).</p>

<p>Then, the value of the new contrapoint is chosen such that <em>f</em>(<em>a</em><sub><em>k</em>+1</sub>) and <em>f</em>(<em>b</em><sub><em>k</em>+1</sub>) have opposite signs. If <em>f</em>(<em>a</em><sub><em>k</em></sub>) and <em>f</em>(<em>b</em><sub><em>k</em>+1</sub>) have opposite signs, then the contrapoint remains the same: <em>a</em><sub><em>k</em>+1</sub> = <em>a</em><sub><em>k</em></sub>. Otherwise, <em>f</em>(<em>b</em><sub><em>k</em>+1</sub>) and <em>f</em>(<em>b</em><sub><em>k</em></sub>) have opposite signs, so the new contrapoint becomes <em>a</em><sub><em>k</em>+1</sub> = <em>b</em><sub><em>k</em></sub>.</p>

<p>Finally, if |<em>f</em>(<em>a</em><sub><em>k</em>+1</sub>)| <em>k</em>+1)|, then <em>a</em><sub><em>k</em>+1</sub> is probably a better guess for the solution than <em>b</em><sub><em>k</em>+1</sub>, and hence the values of <em>a</em><sub><em>k</em>+1</sub> and <em>b</em><sub><em>k</em>+1</sub> are exchanged.</p>

<p>This ends the description of a single iteration of Dekker's method.</p>

<p>Dekker's method performs well if the function <em>f</em> is reasonably well-behaved. However, there are circumstances in which every iteration employs the secant method, but the iterates <em>b</em><sub><em>k</em></sub> converge very slowly (in particular, |<em>b</em><sub><em>k</em></sub> − <em>b</em><sub><em>k</em>−1</sub>| may be arbitrarily small). Dekker's method requires far more iterations than the bisection method in this case.</p>

<p>proposed a small modification to avoid this problem. He inserted an additional test which must be satisfied before the result of the secant method is accepted as the next iterate. Two inequalities must be simultaneously satisfied:</p>
<ul>
<li>given a specific numerical tolerance 

<math display="inline" id="Brent's_method:2">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

,</li>
</ul>

<p>if the previous step used the bisection method, the inequality</p>

<p>

<math display="block" id="Brent's_method:3">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>δ</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo><</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msub>
      <mi>b</mi>
      <mi>k</mi>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>b</mi>
      <mrow>
       <mi>k</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <abs></abs>
     <ci>δ</ci>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\delta|<|b_{k}-b_{k-1}|
  </annotation>
 </semantics>
</math>

 must hold to perform interpolation, otherwise the bisection method is performed and its result used for the next iteration.</p>

<p>If the previous step performed interpolation, then the inequality</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Brent's_method:4">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>δ</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo><</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msub>
      <mi>b</mi>
      <mrow>
       <mi>k</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>b</mi>
      <mrow>
       <mi>k</mi>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
     </msub>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <abs></abs>
     <ci>δ</ci>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\delta|<|b_{k-1}-b_{k-2}|
  </annotation>
 </semantics>
</math>

 is used instead to perform the next action (to choose) interpolation (when inequality is true) or bisection method
</dd>
</dl>
</dd>
</dl>

<p>(when inequality is not true).</p>
<ul>
<li>Also, if the previous step used the bisection method, the inequality</li>
</ul>

<p>

<math display="block" id="Brent's_method:5">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>s</mi>
     <mo>-</mo>
     <msub>
      <mi>b</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo><</mo>
   <mrow>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mstyle displaystyle="false">
        <mfrac>
         <mn>1</mn>
         <mn>2</mn>
        </mfrac>
       </mstyle>
      </mtd>
     </mtr>
    </mtable>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <msub>
       <mi>b</mi>
       <mi>k</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>b</mi>
       <mrow>
        <mi>k</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <ci>s</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <matrix>
      <matrixrow>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </matrixrow>
     </matrix>
     <apply>
      <abs></abs>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <apply>
         <minus></minus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |s-b_{k}|<\begin{matrix}\frac{1}{2}\end{matrix}|b_{k}-b_{k-1}|
  </annotation>
 </semantics>
</math>

 must hold, otherwise the bisection method is performed and its result used for the next iteration.</p>

<p>If the previous step performed interpolation, then the inequality</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Brent's_method:6">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mi>s</mi>
     <mo>-</mo>
     <msub>
      <mi>b</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo><</mo>
   <mrow>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mfrac>
        <mn>1</mn>
        <mn>2</mn>
       </mfrac>
      </mtd>
     </mtr>
    </mtable>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <msub>
       <mi>b</mi>
       <mrow>
        <mi>k</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>b</mi>
       <mrow>
        <mi>k</mi>
        <mo>-</mo>
        <mn>2</mn>
       </mrow>
      </msub>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <ci>s</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <matrix>
      <matrixrow>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </matrixrow>
     </matrix>
     <apply>
      <abs></abs>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <apply>
         <minus></minus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <apply>
         <minus></minus>
         <ci>k</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |s-b_{k}|<\begin{matrix}\frac{1}{2}\end{matrix}|b_{k-1}-b_{k-2}|
  </annotation>
 </semantics>
</math>

 is used instead.
</dd>
</dl>
</dd>
</dl>

<p>This modification ensures that at the kth iteration, a bisection step will be performed in at most 

<math display="inline" id="Brent's_method:7">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <msub>
         <mi>b</mi>
         <mrow>
          <mi>k</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>b</mi>
         <mrow>
          <mi>k</mi>
          <mo>-</mo>
          <mn>2</mn>
         </mrow>
        </msub>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
      <mo>/</mo>
      <mi>δ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <abs></abs>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <apply>
          <minus></minus>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <apply>
          <minus></minus>
          <ci>k</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>δ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\log_{2}(|b_{k-1}-b_{k-2}|/\delta)
  </annotation>
 </semantics>
</math>

 additional iterations, because the above conditions force consecutive interpolation step sizes to halve every two iterations, and after at most 

<math display="inline" id="Brent's_method:8">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <msub>
         <mi>b</mi>
         <mrow>
          <mi>k</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>b</mi>
         <mrow>
          <mi>k</mi>
          <mo>-</mo>
          <mn>2</mn>
         </mrow>
        </msub>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
      <mo>/</mo>
      <mi>δ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <abs></abs>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <apply>
          <minus></minus>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <apply>
          <minus></minus>
          <ci>k</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>δ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\log_{2}(|b_{k-1}-b_{k-2}|/\delta)
  </annotation>
 </semantics>
</math>


 iterations, the step size will be smaller than 

<math display="inline" id="Brent's_method:9">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

, which invokes a bisection step. Brent proved that his method requires at most <em>N</em><sup>2</sup> iterations, where <em>N</em> denotes the number of iterations for the bisection method. If the function <em>f</em> is well-behaved, then Brent's method will usually proceed by either inverse quadratic or linear interpolation, in which case it will converge <a href="rate_of_convergence" title="wikilink">superlinearly</a>.</p>

<p>Furthermore, Brent's method uses <a href="inverse_quadratic_interpolation" title="wikilink">inverse quadratic interpolation</a> instead of <a href="linear_interpolation" title="wikilink">linear interpolation</a> (as used by the secant method) .If <em>f</em>(<em>b</em><sub><em>k</em></sub>), <em>f</em>(<em>a</em><sub><em>k</em></sub>) and <em>f</em>(<em>b</em><sub><em>k</em>−1</sub>) are distinct, it slightly increases the efficiency. As a consequence, the condition for accepting <em>s</em> (the value proposed by either linear interpolation or inverse quadratic interpolation) has to be changed: <em>s</em> has to lie between (3<em>a</em><sub><em>k</em></sub> + <em>b</em><sub><em>k</em></sub>) / 4 and <em>b</em><sub><em>k</em></sub>.</p>
<h2 id="algorithm">Algorithm</h2>

<p><strong><code>input</code></strong><code> </code><em><code>a</code></em><code>, </code><em><code>b</code></em><code>, and (a pointer to) a function for </code><em><code>f</code></em><br/>
<code>calculate </code><em><code>f</code></em><code>(</code><em><code>a</code></em><code>)</code><br/>
<code>calculate </code><em><code>f</code></em><code>(</code><em><code>b</code></em><code>)</code><br/>
<strong><code>if</code></strong><code> </code><em><code>f</code></em><code>(</code><em><code>a</code></em><code>) </code><em><code>f</code></em><code>(</code><em><code>b</code></em><code>) &gt;= 0 </code><strong><code>then</code></strong><code> exit function because the root is not bracketed.</code><br/>
<strong><code>if</code></strong><code> |</code><em><code>f</code></em><code>(</code><em><code>a</code></em><code>)| </code><code> s := \frac{af(b)f(c)}{(f(a)-f(b))(f(a)-f(c))} + \frac{bf(a)f(c)}{(f(b)-f(a))(f(b)-f(c))} + \frac{cf(a)f(b)}{(f(c)-f(a))(f(c)-f(b))} </code><code> </code><em><code>(</code><a href="inverse_quadratic_interpolation" title="wikilink"><code>inverse</code> <code>quadratic</code> <code>interpolation</code></a><code>)</code></em><br/>
<code>  </code><strong><code>else</code></strong><br/>
<code>    </code>

<math display="inline" id="Brent's_method:10">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>:=</mo>
   <mrow>
    <mi>b</mi>
    <mo>-</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mfrac>
      <mrow>
       <mi>b</mi>
       <mo>-</mo>
       <mi>a</mi>
      </mrow>
      <mrow>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>b</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>a</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>s</ci>
    <apply>
     <minus></minus>
     <ci>b</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>b</ci>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <ci>b</ci>
        <ci>a</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>b</ci>
        </apply>
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>a</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s:=b-f(b)\frac{b-a}{f(b)-f(a)}
  </annotation>
 </semantics>
</math>

<code> </code><em><code>(</code><a href="secant_method" title="wikilink"><code>secant</code> <code>method</code></a><code>)</code></em><br/>
<code>  </code><strong><code>end</code> <code>if</code></strong><br/>
<code>  </code><strong><code>if</code></strong><code> </code><em><code>(condition</code> <code>1)</code></em><code> </code><em><code>s</code></em><code> is not between </code>

<math display="inline" id="Brent's_method:11">
 <semantics>
  <mfrac>
   <mrow>
    <mrow>
     <mn>3</mn>
     <mi>a</mi>
    </mrow>
    <mo>+</mo>
    <mi>b</mi>
   </mrow>
   <mn>4</mn>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">3</cn>
      <ci>a</ci>
     </apply>
     <ci>b</ci>
    </apply>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{3a+b}{4}
  </annotation>
 </semantics>
</math>

<code> and </code>

<math display="inline" id="Brent's_method:12">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>

<code> </code><strong><code>or</code></strong><br/>
<code>     </code><em><code>(condition</code> <code>2)</code></em><code> (mflag is set </code><strong><code>and</code></strong><code> |</code>

<math display="inline" id="Brent's_method:13">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mi mathvariant="normal"></mi>
   <mi mathvariant="normal">−</mi>
   <mi mathvariant="normal"></mi>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>normal-</ci>
    <ci>normal-−</ci>
    <ci>normal-</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s − b
  </annotation>
 </semantics>
</math>


<code>| ≥ |</code>

<math display="inline" id="Brent's_method:14">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mi mathvariant="normal"></mi>
   <mi mathvariant="normal">−</mi>
   <mi mathvariant="normal"></mi>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>b</ci>
    <ci>normal-</ci>
    <ci>normal-−</ci>
    <ci>normal-</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b − c
  </annotation>
 </semantics>
</math>

<code>|/2) </code><strong><code>or</code></strong><br/>
<code>     </code><em><code>(condition</code> <code>3)</code></em><code> (mflag is cleared </code><strong><code>and</code></strong><code> |</code>

<math display="inline" id="Brent's_method:15">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mi mathvariant="normal"></mi>
   <mi mathvariant="normal">−</mi>
   <mi mathvariant="normal"></mi>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>normal-</ci>
    <ci>normal-−</ci>
    <ci>normal-</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s − b
  </annotation>
 </semantics>
</math>

<code>| ≥ |</code>

<math display="inline" id="Brent's_method:16">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mi mathvariant="normal"></mi>
   <mi mathvariant="normal">−</mi>
   <mi mathvariant="normal"></mi>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>c</ci>
    <ci>normal-</ci>
    <ci>normal-−</ci>
    <ci>normal-</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c − d
  </annotation>
 </semantics>
</math>

<code>|/2) </code><strong><code>or</code></strong><br/>
<code>     </code><em><code>(condition</code> <code>4)</code></em><code> (mflag is set </code><strong><code>and</code></strong><code> |</code>

<math display="inline" id="Brent's_method:17">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mi mathvariant="normal"></mi>
   <mi mathvariant="normal">−</mi>
   <mi mathvariant="normal"></mi>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>b</ci>
    <ci>normal-</ci>
    <ci>normal-−</ci>
    <ci>normal-</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b − c
  </annotation>
 </semantics>
</math>

<code>| </code><code>$δ$</code><code>|) </code><strong><code>or</code></strong><br/>
<code>     </code><em><code>(condition</code> <code>5)</code></em><code> (mflag is cleared </code><strong><code>and</code></strong><code> |</code>

<math display="inline" id="Brent's_method:18">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mi mathvariant="normal"></mi>
   <mi mathvariant="normal">−</mi>
   <mi mathvariant="normal"></mi>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>c</ci>
    <ci>normal-</ci>
    <ci>normal-−</ci>
    <ci>normal-</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c − d
  </annotation>
 </semantics>
</math>


<code>| </code><code>$δ$</code><code>|)</code><br/>
<code>  </code><strong><code>then</code></strong><br/>
<code>    </code>

<math display="inline" id="Brent's_method:19">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>:=</mo>
   <mfrac>
    <mrow>
     <mi>a</mi>
     <mo>+</mo>
     <mi>b</mi>
    </mrow>
    <mn>2</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>s</ci>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s:=\frac{a+b}{2}
  </annotation>
 </semantics>
</math>

<code> </code><em><code>(</code><a href="bisection_method" title="wikilink"><code>bisection</code> <code>method</code></a><code>)</code></em><br/>
<code>    </code><strong><code>set</code></strong><code> mflag</code><br/>
<code>  </code><strong><code>else</code></strong><br/>
<code>    </code><strong><code>clear</code></strong><code> mflag</code><br/>
<code>  </code><strong><code>end</code> <code>if</code></strong><br/>
<code>  calculate </code><em><code>f</code></em><code>(</code><em><code>s</code></em><code>)</code><br/>
<code>  </code><em><code>d</code></em><code> := </code><em><code>c</code></em><code>  </code><em><code>(d</code> <code>is</code> <code>assigned</code> <code>for</code> <code>the</code> <code>first</code> <code>time</code> <code>here;</code> <code>it</code> <code>won't</code> <code>be</code> <code>used</code> <code>above</code> <code>on</code> <code>the</code> <code>first</code> <code>iteration</code> <code>because</code> <code>mflag</code> <code>is</code> <code>set)</code></em><br/>
<code>  </code><em><code>c</code></em><code> := </code><em><code>b</code></em><br/>
<code>  </code><strong><code>if</code></strong><code> </code><em><code>f</code></em><code>(</code><em><code>a</code></em><code>) </code><em><code>f</code></em><code>(</code><em><code>s</code></em><code>) </code><code>2</code><code>. We take [</code><em><code>a</code></em><sub><code>0</code></sub><code>, </code><em><code>b</code></em><sub><code>0</code></sub><code>] = [−4, 4/3] as our initial interval. We have </code><em><code>f</code></em><code>(</code><em><code>a</code></em><sub><code>0</code></sub><code>) = −25 and </code><em><code>f</code></em><code>(</code><em><code>b</code></em><sub><code>0</code></sub><code>) = 0.48148 (all numbers in this section are rounded), so the conditions </code><em><code>f</code></em><code>(</code><em><code>a</code></em><sub><code>0</code></sub><code>) </code><em><code>f</code></em><code>(</code><em><code>b</code></em><sub><code>0</code></sub><code>) </code><code>0</code><code>)| ≤ |</code><em><code>f</code></em><code>(</code><em><code>a</code></em><sub><code>0</code></sub><code>)| are satisfied.</code></p>
<figure><b>(Figure)</b>
<figcaption>Graph of <em>f</em>(<em>x</em>) = (<em>x</em> + 3)(<em>x</em> − 1)<sup>2</sup></figcaption>
</figure>
<ol>
<li>In the first iteration, we use linear interpolation between (<em>b</em><sub>−1</sub>, <em>f</em>(<em>b</em><sub>−1</sub>)) = (<em>a</em><sub>0</sub>, <em>f</em>(<em>a</em><sub>0</sub>)) = (−4, −25) and (<em>b</em><sub>0</sub>, <em>f</em>(<em>b</em><sub>0</sub>)) = (1.33333, 0.48148), which yields <em>s</em> = 1.23256. This lies between (3<em>a</em><sub>0</sub> + <em>b</em><sub>0</sub>) / 4 and <em>b</em><sub>0</sub>, so this value is accepted. Furthermore, <em>f</em>(1.23256) = 0.22891, so we set <em>a</em><sub>1</sub> = <em>a</em><sub>0</sub> and <em>b</em><sub>1</sub> = <em>s</em> = 1.23256.</li>
<li>In the second iteration, we use inverse quadratic interpolation between (<em>a</em><sub>1</sub>, <em>f</em>(<em>a</em><sub>1</sub>)) = (−4, −25) and (<em>b</em><sub>0</sub>, <em>f</em>(<em>b</em><sub>0</sub>)) = (1.33333, 0.48148) and (<em>b</em><sub>1</sub>, <em>f</em>(<em>b</em><sub>1</sub>)) = (1.23256, 0.22891). This yields 1.14205, which lies between (3<em>a</em><sub>1</sub> + <em>b</em><sub>1</sub>) / 4 and <em>b</em><sub>1</sub>. Furthermore, the inequality |1.14205 − <em>b</em><sub>1</sub>| ≤ |<em>b</em><sub>0</sub> − <em>b</em><sub>−1</sub>| / 2 is satisfied, so this value is accepted. Furthermore, <em>f</em>(1.14205) = 0.083582, so we set <em>a</em><sub>2</sub> = <em>a</em><sub>1</sub> and <em>b</em><sub>2</sub> = 1.14205.</li>
<li>In the third iteration, we use inverse quadratic interpolation between (<em>a</em><sub>2</sub>, <em>f</em>(<em>a</em><sub>2</sub>)) = (−4, −25) and (<em>b</em><sub>1</sub>, <em>f</em>(<em>b</em><sub>1</sub>)) = (1.23256, 0.22891) and (<em>b</em><sub>2</sub>, <em>f</em>(<em>b</em><sub>2</sub>)) = (1.14205, 0.083582). This yields 1.09032, which lies between (3<em>a</em><sub>2</sub> + <em>b</em><sub>2</sub>) / 4 and <em>b</em><sub>2</sub>. But here Brent's additional condition kicks in: the inequality |1.09032 − <em>b</em><sub>2</sub>| ≤ |<em>b</em><sub>1</sub> − <em>b</em><sub>0</sub>| / 2 is not satisfied, so this value is rejected. Instead, the midpoint <em>m</em> = −1.42897 of the interval [<em>a</em><sub>2</sub>, <em>b</em><sub>2</sub>] is computed. We have <em>f</em>(<em>m</em>) = 9.26891, so we set <em>a</em><sub>3</sub> = <em>a</em><sub>2</sub> and <em>b</em><sub>3</sub> = −1.42897.</li>
<li>In the fourth iteration, we use inverse quadratic interpolation between (<em>a</em><sub>3</sub>, <em>f</em>(<em>a</em><sub>3</sub>)) = (−4, −25) and (<em>b</em><sub>2</sub>, <em>f</em>(<em>b</em><sub>2</sub>)) = (1.14205, 0.083582) and (<em>b</em><sub>3</sub>, <em>f</em>(<em>b</em><sub>3</sub>)) = (−1.42897, 9.26891). This yields 1.15448, which is not in the interval between (3<em>a</em><sub>3</sub> + <em>b</em><sub>3</sub>) / 4 and <em>b</em><sub>3</sub>). Hence, it is replaced by the midpoint <em>m</em> = −2.71449. We have <em>f</em>(<em>m</em>) = 3.93934, so we set <em>a</em><sub>4</sub> = <em>a</em><sub>3</sub> and <em>b</em><sub>4</sub> = −2.71449.</li>
<li>In the fifth iteration, inverse quadratic interpolation yields −3.45500, which lies in the required interval. However, the previous iteration was a bisection step, so the inequality |−3.45500 − <em>b</em><sub>4</sub>| ≤ |<em>b</em><sub>4</sub> − <em>b</em><sub>3</sub>| / 2 need to be satisfied. This inequality is false, so we use the midpoint <em>m</em> = −3.35724. We have <em>f</em>(<em>m</em>) = −6.78239, so <em>m</em> becomes the new contrapoint (<em>a</em><sub>5</sub> = −3.35724) and the iterate remains the same (<em>b</em><sub>5</sub> = <em>b</em><sub>4</sub>).</li>
<li>In the sixth iteration, we cannot use inverse quadratic interpolation because <em>b</em><sub>5</sub> = <em>b</em><sub>4</sub>. Hence, we use linear interpolation between (<em>a</em><sub>5</sub>, <em>f</em>(<em>a</em><sub>5</sub>)) = (−3.35724, −6.78239) and (<em>b</em><sub>5</sub>, <em>f</em>(<em>b</em><sub>5</sub>)) = (−2.71449, 3.93934). The result is <em>s</em> = −2.95064, which satisfies all the conditions. But since the iterate did not change in the previous step, we reject this result and fall back to bisection. We update <em>s</em> = -3.03587, and <em>f</em>(<em>s</em>) = -0.58418.</li>
<li>In the seventh iteration, we can again use inverse quadratic interpolation. The result is <em>s</em> = −3.00219, which satisfies all the conditions. Now, <em>f</em>(<em>s</em>) = −0.03515, so we set <em>a</em><sub>7</sub> = <em>b</em><sub>6</sub> and <em>b</em><sub>7</sub> = −3.00219 (<em>a</em><sub>7</sub> and <em>b</em><sub>7</sub> are exchanged so that the condition |<em>f</em>(<em>b</em><sub>7</sub>)| ≤ |<em>f</em>(<em>a</em><sub>7</sub>)| is satisfied). <em>(Correct : linear interpolation s = -2.99436, f(s) = 0.089961)</em></li>
<li>In the eighth iteration, we cannot use inverse quadratic interpolation because <em>a</em><sub>7</sub> = <em>b</em><sub>6</sub>. Linear interpolation yields <em>s</em> = −2.99994, which is accepted. <em>(Correct : s = -2.9999, f(s) = 0.0016)</em></li>
<li>In the following iterations, the root <em>x</em> = −3 is approached rapidly: <em>b</em><sub>9</sub> = −3 + 6·10<sup>−8</sup> and <em>b</em><sub>10</sub> = −3 − 3·10<sup>−15</sup>. <em>(Correct : Iter 9 : f(s) = -1.4E-07, Iter 10 : f(s) = 6.96E-12)</em></li>
</ol>
<h2 id="implementations">Implementations</h2>
<ul>
<li>

<p>published an <a href="Algol_60" title="wikilink">Algol 60</a> implementation.</p></li>
<li><a class="uri" href="Netlib" title="wikilink">Netlib</a> contains a Fortran translation of this implementation with slight modifications.</li>
<li>The <a class="uri" href="PARI/GP" title="wikilink">PARI/GP</a> method <code>solve</code> implements the method.</li>
<li>Other implementations of the algorithm (in C++, C, and Fortran) can be found in the <a href="Numerical_Recipes" title="wikilink">Numerical Recipes</a> books.</li>
<li>The <a href="Apache_Commons" title="wikilink">Apache Commons</a> Math library implements the algorithm in <a href="Java_(programming_language)" title="wikilink">Java</a>.</li>
<li>The <a class="uri" href="Scipy" title="wikilink">Scipy</a> optimize module implements the algorithm in <a href="Python_(programming_language)" title="wikilink">Python (programming language)</a></li>
<li>The Modelica Standard Library implements the algorithm in <a class="uri" href="Modelica" title="wikilink">Modelica</a>.</li>
<li>The <code>optimize</code> function implements the algorithm in <a href="R_(software)" title="wikilink">R (software)</a>.</li>
<li>The <a href="Boost_(C++_libraries)" title="wikilink">Boost (C++ libraries)</a> implements the algorithm in <a class="uri" href="C++" title="wikilink">C++</a> in the Math toolkit ("Locating function minima").</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
<li>

<p>. This article claims to simplify and improve Brent's method.</p></li>
<li>

<p>. This article points out and corrects errors in Zhang's algorithm and then compares several methods (not just Zhang and Brent).</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.netlib.org/go/zeroin.f">zeroin.f</a> at <a class="uri" href="Netlib" title="wikilink">Netlib</a>.</li>
<li><a href="http://math.fullerton.edu/mathews/n2003/BrentMethodMod.html">Module for Brent's Method</a> by John H. Mathews</li>
<li><a href="http://people.sc.fsu.edu/~jburkardt/cpp_src/brent/brent.html">module brent in C++ (also C, Fortran, Matlab)</a> by John Burkardt</li>
<li><a href="http://www.gnu.org/software/gsl/">GSL</a> implementation.</li>
<li><a href="http://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/internals1/minima.html">Boost C++</a> implementation.</li>
</ul>

<p>"</p>

<p><a href="Category:Root-finding_algorithms" title="wikilink">Category:Root-finding algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
