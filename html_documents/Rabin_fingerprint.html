<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="461">Rabin fingerprint</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Rabin fingerprint</h1>
<hr/>

<p>The <strong>Rabin fingerprinting scheme</strong> is a method for implementing <a href="fingerprint_(computing)" title="wikilink">fingerprints</a> using <a href="polynomial" title="wikilink">polynomials</a> over a <a href="finite_field" title="wikilink">finite field</a>. It was proposed by <a href="Michael_O._Rabin" title="wikilink">Michael O. Rabin</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="scheme">Scheme</h2>

<p>Given an <em>n</em>-bit message <em>m</em><sub>0</sub>,...,<em>m</em><sub>n-1</sub>, we view it as a polynomial of degree <em>n</em>-1 over the <a href="finite_field" title="wikilink">finite field</a> <a href="Galois_field" title="wikilink">GF(2)</a>.</p>

<p>

<math display="inline" id="Rabin_fingerprint:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>m</mi>
     <mn>0</mn>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>m</mi>
      <mn>1</mn>
     </msub>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">…</mi>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>m</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <msup>
      <mi>x</mi>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>x</ci>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=m_{0}+m_{1}x+\ldots+m_{n-1}x^{n-1}
  </annotation>
 </semantics>
</math>

</p>

<p>We then pick a random <a href="irreducible_polynomial" title="wikilink">irreducible polynomial</a> <em>p(x)</em> of degree <em>k</em> over GF(2), and we define the fingerprint of the message <em>m</em> to be the remainder 

<math display="inline" id="Rabin_fingerprint:1">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(x)
  </annotation>
 </semantics>
</math>

 after division of 

<math display="inline" id="Rabin_fingerprint:2">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Rabin_fingerprint:3">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x)
  </annotation>
 </semantics>
</math>

 over GF(2) which can be viewed as a polynomial of degree <em>k</em>-1 or as a <em>k</em>-bit number.</p>
<h2 id="applications">Applications</h2>

<p>Many implementations of the <a href="Rabin–Karp_algorithm" title="wikilink">Rabin–Karp algorithm</a> internally use Rabin fingerprints.</p>

<p>The <em>Low Bandwidth Network Filesystem</em> (LBFS) from MIT uses Rabin fingerprints to implement variable size shift-resistant blocks. <ref>Athicha Muthitacharoen, Benjie Chen, and <a href="David_Mazières" title="wikilink">David Mazières</a></ref></p>

<p><a href="http://pdos.csail.mit.edu/papers/lbfs:sosp01/lbfs.pdf"><code>"A</code> <code>Low-bandwidth</code> <code>Network</code> <code>File</code> <code>System"</code></a></p>

<p>The basic idea is that the filesystem computes the <a href="cryptographic_hash" title="wikilink">cryptographic hash</a> of each block in a file. To save on transfers between the client and server, they compare their checksums and only transfer blocks whose checksums differ. But one problem with this scheme is that a single insertion at the beginning of the file will cause every checksum to change if fixed-sized (e.g. 4 KB) blocks are used. So the idea is to select blocks not based on a specific offset but rather by some property of the block contents. LBFS does this by sliding a 48 byte window over the file and computing the Rabin fingerprint of each window. When the low 13 bits of the fingerprint are zero LBFS calls those 48 bytes a breakpoint and ends the current block and begins a new one. Since the output of Rabin fingerprints are <a class="uri" href="pseudo-random" title="wikilink">pseudo-random</a> the probability of any given 48 bytes being a breakpoint is 

<math display="inline" id="Rabin_fingerprint:4">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mo>-</mo>
    <mn>13</mn>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <minus></minus>
     <cn type="integer">13</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{-13}
  </annotation>
 </semantics>
</math>

. This has the effect of shift-resistant variable size blocks. <em>Any</em> <a href="hash_function" title="wikilink">hash function</a> could be used to divide a long file into blocks (as long as a <a href="cryptographic_hash_function" title="wikilink">cryptographic hash function</a> is then used to find the checksum of each block): but the Rabin fingerprint is an efficient <a href="rolling_hash" title="wikilink">rolling hash</a>, since the computation of the Rabin fingerprint of region <em>B</em> can reuse some of the computation of the Rabin fingerprint of region <em>A</em> when regions <em>A</em> and <em>B</em> overlap.</p>

<p>Note that this is a problem similar to that faced by <a class="uri" href="rsync" title="wikilink">rsync</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="W-shingling" title="wikilink">W-shingling</a></li>
<li><a href="Rolling_hash" title="wikilink">Rolling hash</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li></li>
<li><a href="https://github.com/joeltucci/rabin-fingerprint-c">Rabin fingerprint algorithm implemented in C</a></li>
</ul>

<p>"</p>

<p><a href="Category:Theory_of_cryptography" title="wikilink">Category:Theory of cryptography</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
