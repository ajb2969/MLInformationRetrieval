<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1642">Klam value</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Klam value</h1>
<hr/>

<p>In the <a href="parameterized_complexity" title="wikilink">parameterized complexity</a> of <a href="algorithm" title="wikilink">algorithms</a>, the <strong>klam value</strong> of a parameterized algorithm is a number that bounds the parameter values for which the algorithm might reasonably be expected to be practical.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> An algorithm with a higher klam value can be used for a wider range of parameter values than another algorithm with a lower klam value. The klam value was first defined by ,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and has since been used by other researchers in parameterized complexity both as a way of comparing different algorithms to each other and in order to set goals for future algorithmic improvements.</p>
<h2 id="definition">Definition</h2>

<p>An algorithm is said to be fixed-parameter tractable if the number of elementary operations it performs has a bound of the form 

<math display="inline" id="Klam_value:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>n</mi>
      <mi>c</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{c})+f(k)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Klam_value:1">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is some measure of the input size (such as the number of <a href="vertex_(graph_theory)" title="wikilink">vertices</a> in a <a href="graph_(mathematics)" title="wikilink">graph</a>), 

<math display="inline" id="Klam_value:2">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is a parameter describing the complexity of the input (such as the <a class="uri" href="treewidth" title="wikilink">treewidth</a> of the graph), 

<math display="inline" id="Klam_value:3">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>


 is a constant that does not depend on 

<math display="inline" id="Klam_value:4">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Klam_value:5">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Klam_value:6">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is a <a href="computable_function" title="wikilink">computable function</a>.</p>

<p>Given a time bound of this form, the klam value of the algorithm (or more properly of the time bound) is defined to be the largest value of 

<math display="inline" id="Klam_value:7">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Klam_value:8">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(k)
  </annotation>
 </semantics>
</math>


 does not exceed "some reasonable absolute bound on the maximum number of steps of any computation".<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> More precisely both  and  use the number 10<sup>20</sup> as this bound, and this has been followed by later researchers. To prevent artificially improving the klam value of an algorithm by putting more of its complexity into the 

<math display="inline" id="Klam_value:9">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mi>c</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{c})
  </annotation>
 </semantics>
</math>

 part of the time bound,  also limit 

<math display="inline" id="Klam_value:10">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 to be at most three, valid for many known fixed-parameter tractable algorithms.</p>
<h2 id="examples">Examples</h2>

<p>cites the example of <a href="vertex_cover" title="wikilink">vertex cover</a>, with its natural parameter (the number of vertices in the cover). At that time the best known parameterized time bound had 

<math display="inline" id="Klam_value:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>k</mi>
       <mn>2</mn>
      </msup>
      <msup>
       <mn>1.3248</mn>
       <mi>k</mi>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>k</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="float">1.3248</cn>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(k)=O(k^{2}1.3248^{k})
  </annotation>
 </semantics>
</math>

. Solving 

<math display="inline" id="Klam_value:12">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>k</mi>
     <mn>2</mn>
    </msup>
    <msup>
     <mn>1.3248</mn>
     <mi>k</mi>
    </msup>
   </mrow>
   <mo>=</mo>
   <msup>
    <mn>10</mn>
    <mn>20</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>k</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="float">1.3248</cn>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">10</cn>
     <cn type="integer">20</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{2}1.3248^{k}=10^{20}
  </annotation>
 </semantics>
</math>

 gives a klam value of approximately 129. However, the 

<math display="inline" id="Klam_value:13">
 <semantics>
  <msup>
   <mi>k</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{2}
  </annotation>
 </semantics>
</math>


 part of the time bound can be simplified out of it, giving a bound of the form 

<math display="inline" id="Klam_value:14">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mn>1.3248</mn>
     <mi>k</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="float">1.3248</cn>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1.3248^{k})
  </annotation>
 </semantics>
</math>

 with both a larger constant factor hidden in the O-notation and a larger base of the exponent hidden in its approximate decimal value. For a simple exponential bound 

<math display="inline" id="Klam_value:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>c</mi>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>c</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(k)=c^{k}
  </annotation>
 </semantics>
</math>

such as this one, one can solve directly 

<math display="inline" id="Klam_value:16">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mn>20</mn>
    <mo>/</mo>
    <mrow>
     <msub>
      <mi>log</mi>
      <mn>10</mn>
     </msub>
     <mi>c</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <apply>
     <divide></divide>
     <cn type="integer">20</cn>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <log></log>
       <cn type="integer">10</cn>
      </apply>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=20/\log_{10}c
  </annotation>
 </semantics>
</math>

 from which Niedermeyer derives a klam value of approximately 165. Subsequent research has developed parameterized vertex cover algorithms with 

<math display="inline" id="Klam_value:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mn>1.2738</mn>
      <mi>k</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="float">1.2738</cn>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(k)=O(1.2738^{k})
  </annotation>
 </semantics>
</math>

<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> giving a klam value of approximately 190. That is, one can conclude from this analysis that vertex cover instances with cover size greater than 190 are out of reach of this algorithm, but instances whose cover size is sufficiently far below this limit are likely to be solvable.</p>

<p>Another example of a problem in which the klam value has been explicitly used as a goal for future research is the <a href="Connected_dominating_set" title="wikilink">maximum leaf spanning tree problem</a>, in which the goal is to find a <a href="spanning_tree" title="wikilink">spanning tree</a> of a graph with as many leaf nodes as possible (parameterized by the number of leaves).  develop an algorithm for this problem which they compare using the klam value to previous work on the same problem: previous algorithms had klam values of 1 and 5, and theirs has a klam value of 16.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> However, they also suggest that it should be possible to provide improved algorithms for this problem with a klam value of at least 50. Although this remains open, several later papers have incrementally improved the klam value of this problem to 37.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Parameterized_complexity" title="wikilink">Category:Parameterized complexity</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">.<a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3"> uses the klam value and was published earlier than , but gives credit to Downey and Fellows for the concept.<a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5">.<a href="#fnref5">↩</a></li>
<li id="fn6">.<a href="#fnref6">↩</a></li>
<li id="fn7">.<a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
