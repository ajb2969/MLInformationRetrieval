<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="622">Tonelli–Shanks algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Tonelli–Shanks algorithm</h1>
<hr/>

<p>The <strong>Tonelli–Shanks</strong> <a class="uri" href="algorithm" title="wikilink">algorithm</a> (referred to by Shanks as the RESSOL algorithm) is used within <a href="modular_arithmetic" title="wikilink">modular arithmetic</a> to solve a congruence of the form</p>

<p>

<math display="block" id="Tonelli–Shanks_algorithm:0">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>2</mn>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mi>n</mi>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <ci>n</ci>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}\equiv n\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>n</em> is a <a href="quadratic_residue" title="wikilink">quadratic residue</a> (mod <em>p</em>), and <em>p</em> is an odd <a href="prime_number" title="wikilink">prime</a>.</p>

<p>Tonelli–Shanks cannot be used for composite moduli; finding square roots modulo composite numbers is a computational problem equivalent to <a href="integer_factorization" title="wikilink">integer factorization</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>An equivalent, but slightly more redundant version of this algorithm was developed by Alberto Tonelli in 1891. The version discussed here was developed independently by <a href="Daniel_Shanks" title="wikilink">Daniel Shanks</a> in 1973, who explained:</p>
<blockquote>

<p>"My tardiness in learning of these historical references was because I had lent Volume 1 of <a href="Leonard_Eugene_Dickson" title="wikilink">Dickson's</a> <a href="History_of_the_Theory_of_Numbers" title="wikilink">History</a> to a friend and it was never returned."<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
</blockquote>
<h2 id="the-algorithm">The algorithm</h2>

<p>(Note: All 

<math display="inline" id="Tonelli–Shanks_algorithm:1">
 <semantics>
  <mo>≡</mo>
  <annotation-xml encoding="MathML-Content">
   <equivalent></equivalent>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \equiv
  </annotation>
 </semantics>
</math>

 are taken to mean 

<math display="inline" id="Tonelli–Shanks_algorithm:2">
 <semantics>
  <mrow>
   <mo lspace="8.1pt" stretchy="false">(</mo>
   <mrow>
    <mo>mod</mo>
    <mi>p</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>pmod</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

, unless indicated otherwise).</p>

<p><strong>Inputs</strong>: <em>p</em>, an odd prime. <em>n</em>, an integer which is a quadratic residue (mod <em>p</em>), meaning that the <a href="Legendre_symbol" title="wikilink">Legendre symbol</a> 

<math display="inline" id="Tonelli–Shanks_algorithm:3">
 <semantics>
  <mrow>
   <mrow>
    <mo maxsize="120%" minsize="120%">(</mo>
    <mfrac>
     <mi>n</mi>
     <mi>p</mi>
    </mfrac>
    <mo maxsize="120%" minsize="120%">)</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>n</ci>
     <ci>p</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigl(\tfrac{n}{p}\bigr)=1
  </annotation>
 </semantics>
</math>


.</p>

<p><strong>Outputs</strong>: <em>R</em>, an integer satisfying 

<math display="inline" id="Tonelli–Shanks_algorithm:4">
 <semantics>
  <mrow>
   <msup>
    <mi>R</mi>
    <mn>2</mn>
   </msup>
   <mo>≡</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{2}\equiv n
  </annotation>
 </semantics>
</math>

.</p>
<ol>
<li>Factor out powers of 2 from <em>p</em> − 1, defining <em>Q</em> and <em>S</em> as

<math display="block" id="Tonelli–Shanks_algorithm:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>Q</mi>
    <msup>
     <mn>2</mn>
     <mi>S</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p-1=Q2^{S}
  </annotation>
 </semantics>
</math>

 with <em>Q</em> odd. Note that if 

<math display="inline" id="Tonelli–Shanks_algorithm:6">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=1
  </annotation>
 </semantics>
</math>

, <em>i.e.</em> 

<math display="inline" id="Tonelli–Shanks_algorithm:7">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>≡</mo>
   <mrow>
    <mn>3</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>4</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>p</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">3</cn>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">4</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\equiv 3\;\;(\mathop{{\rm mod}}4)
  </annotation>
 </semantics>
</math>

, then solutions are given directly by 

<math display="inline" id="Tonelli–Shanks_algorithm:8">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>≡</mo>
   <mrow>
    <mo>±</mo>
    <msup>
     <mi>n</mi>
     <mfrac>
      <mrow>
       <mi>p</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mn>4</mn>
     </mfrac>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>R</ci>
    <apply>
     <csymbol cd="latexml">plus-or-minus</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <apply>
       <divide></divide>
       <apply>
        <plus></plus>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">4</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\equiv\pm n^{\frac{p+1}{4}}
  </annotation>
 </semantics>
</math>


.</li>
<li>Select a <em>z</em> such that the <a href="Legendre_symbol" title="wikilink">Legendre symbol</a> 

<math display="inline" id="Tonelli–Shanks_algorithm:9">
 <semantics>
  <mrow>
   <mrow>
    <mo maxsize="120%" minsize="120%">(</mo>
    <mfrac>
     <mi>z</mi>
     <mi>p</mi>
    </mfrac>
    <mo maxsize="120%" minsize="120%">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>z</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigl(\tfrac{z}{p}\bigr)=-1
  </annotation>
 </semantics>
</math>

 (that is, <em>z</em> should be a quadratic non-residue modulo <em>p</em>), and set 

<math display="inline" id="Tonelli–Shanks_algorithm:10">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>≡</mo>
   <msup>
    <mi>z</mi>
    <mi>Q</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>c</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>z</ci>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\equiv z^{Q}
  </annotation>
 </semantics>
</math>

.</li>
<li>Let 

<math display="inline" id="Tonelli–Shanks_algorithm:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>R</mi>
     <mo>≡</mo>
     <msup>
      <mi>n</mi>
      <mfrac>
       <mrow>
        <mi>Q</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mn>2</mn>
      </mfrac>
     </msup>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <mi>t</mi>
      <mo>≡</mo>
      <msup>
       <mi>n</mi>
       <mi>Q</mi>
      </msup>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>M</mi>
      <mo>=</mo>
      <mi>S</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <equivalent></equivalent>
     <ci>R</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <apply>
       <divide></divide>
       <apply>
        <plus></plus>
        <ci>Q</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <equivalent></equivalent>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <ci>Q</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <ci>M</ci>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\equiv n^{\frac{Q+1}{2}},t\equiv n^{Q},M=S.
  </annotation>
 </semantics>
</math>

</li>
<li>Loop:
<ol>
<li>If 

<math display="inline" id="Tonelli–Shanks_algorithm:12">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>≡</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>t</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\equiv 1
  </annotation>
 </semantics>
</math>

, return <em>R</em>.</li>
<li>Otherwise, find the lowest <em>i</em>, 

<math display="inline" id="Tonelli–Shanks_algorithm:13">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo><</mo>
   <mi>i</mi>
   <mo><</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <cn type="integer">0</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0<i<M
  </annotation>
 </semantics>
</math>


, such that 

<math display="inline" id="Tonelli–Shanks_algorithm:14">
 <semantics>
  <mrow>
   <msup>
    <mi>t</mi>
    <msup>
     <mn>2</mn>
     <mi>i</mi>
    </msup>
   </msup>
   <mo>≡</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>t</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>i</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{2^{i}}\equiv 1
  </annotation>
 </semantics>
</math>

; <em>e.g.</em> via repeated squaring.</li>
<li>Let 

<math display="inline" id="Tonelli–Shanks_algorithm:15">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>≡</mo>
   <msup>
    <mi>c</mi>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>M</mi>
      <mo>-</mo>
      <mi>i</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>b</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>c</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <ci>M</ci>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\equiv c^{2^{M-i-1}}
  </annotation>
 </semantics>
</math>

, and set 

<math display="inline" id="Tonelli–Shanks_algorithm:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mo>≡</mo>
    <mrow>
     <mi>R</mi>
     <mi>b</mi>
    </mrow>
   </mrow>
   <mo rspace="5.3pt">,</mo>
   <mrow>
    <mrow>
     <mi>t</mi>
     <mo>≡</mo>
     <mrow>
      <mi>t</mi>
      <msup>
       <mi>b</mi>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>c</mi>
     <mo>≡</mo>
     <msup>
      <mi>b</mi>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <equivalent></equivalent>
     <ci>R</ci>
     <apply>
      <times></times>
      <ci>R</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <equivalent></equivalent>
      <ci>t</ci>
      <apply>
       <times></times>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>b</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <equivalent></equivalent>
      <ci>c</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\equiv Rb,\;t\equiv tb^{2},c\equiv b^{2}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Tonelli–Shanks_algorithm:17">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo rspace="5.3pt">=</mo>
   <mi>i</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=\;i
  </annotation>
 </semantics>
</math>

.</li>
</ol></li>
</ol>

<p>Once you have solved the congruence with <em>R</em> the second solution is <em>p</em> − <em>R</em>.</p>
<h2 id="example">Example</h2>

<p>Solving the congruence 

<math display="inline" id="Tonelli–Shanks_algorithm:18">
 <semantics>
  <mrow>
   <msup>
    <mi>x</mi>
    <mn>2</mn>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mn>10</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>13</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>x</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">10</cn>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">13</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{2}\equiv 10\;\;(\mathop{{\rm mod}}13)
  </annotation>
 </semantics>
</math>


. It is clear that 

<math display="inline" id="Tonelli–Shanks_algorithm:19">
 <semantics>
  <mn>13</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">13</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   13
  </annotation>
 </semantics>
</math>

 is odd, and since 

<math display="inline" id="Tonelli–Shanks_algorithm:20">
 <semantics>
  <mrow>
   <msup>
    <mn>10</mn>
    <mfrac>
     <mrow>
      <mn>13</mn>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mn>2</mn>
    </mfrac>
   </msup>
   <mo>=</mo>
   <msup>
    <mn>10</mn>
    <mn>6</mn>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mn>1</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>13</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">10</cn>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <cn type="integer">13</cn>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">10</cn>
      <cn type="integer">6</cn>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <cn type="integer">1</cn>
      <apply>
       <ci>pmod</ci>
       <cn type="integer">13</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   10^{\frac{13-1}{2}}=10^{6}\equiv 1\;\;(\mathop{{\rm mod}}13)
  </annotation>
 </semantics>
</math>

, 10 is a quadratic residue (by <a href="Euler's_criterion" title="wikilink">Euler's criterion</a>).</p>
<ul>
<li>Step 1: Observe 

<math display="inline" id="Tonelli–Shanks_algorithm:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mn>12</mn>
   <mo>=</mo>
   <mrow>
    <mn>3</mn>
    <mo>⋅</mo>
    <msup>
     <mn>2</mn>
     <mn>2</mn>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">12</cn>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-⋅</ci>
      <cn type="integer">3</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p-1=12=3\cdot 2^{2}
  </annotation>
 </semantics>
</math>

 so 

<math display="inline" id="Tonelli–Shanks_algorithm:22">
 <semantics>
  <mrow>
   <mi>Q</mi>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Q</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q=3
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Tonelli–Shanks_algorithm:23">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=2
  </annotation>
 </semantics>
</math>


.</li>
</ul>
<ul>
<li>Step 2: Take 

<math display="inline" id="Tonelli–Shanks_algorithm:24">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>z</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z=2
  </annotation>
 </semantics>
</math>

 as the quadratic nonresidue (2 is a quadratic nonresidue since 

<math display="inline" id="Tonelli–Shanks_algorithm:25">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mfrac>
     <mrow>
      <mn>13</mn>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mn>2</mn>
    </mfrac>
   </msup>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>13</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <cn type="integer">13</cn>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">13</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{\frac{13-1}{2}}=-1\;\;(\mathop{{\rm mod}}13)
  </annotation>
 </semantics>
</math>

 (again, Euler's criterion)). Set 

<math display="inline" id="Tonelli–Shanks_algorithm:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mo>=</mo>
    <msup>
     <mn>2</mn>
     <mn>3</mn>
    </msup>
    <mo>≡</mo>
    <mrow>
     <mn>8</mn>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mn>13</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>c</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <cn type="integer">8</cn>
      <apply>
       <ci>pmod</ci>
       <cn type="integer">13</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=2^{3}\equiv 8\;\;(\mathop{{\rm mod}}13).
  </annotation>
 </semantics>
</math>

</li>
</ul>
<ul>
<li>Step 3

<math display="block" id="Tonelli–Shanks_algorithm:27">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mo>=</mo>
    <msup>
     <mn>10</mn>
     <mn>2</mn>
    </msup>
    <mo>≡</mo>
    <mrow>
     <mo>-</mo>
     <mn>4</mn>
    </mrow>
   </mrow>
   <mo rspace="5.3pt">,</mo>
   <mrow>
    <mi>t</mi>
    <mo>≡</mo>
    <msup>
     <mn>10</mn>
     <mn>3</mn>
    </msup>
    <mo>≡</mo>
    <mrow>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mn>13</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>M</mi>
    <mo>=</mo>
    <mn>2.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <ci>R</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">10</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <equivalent></equivalent>
      <share href="#.cmml">
      </share>
      <apply>
       <minus></minus>
       <cn type="integer">4</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <equivalent></equivalent>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">10</cn>
       <cn type="integer">3</cn>
      </apply>
     </apply>
     <apply>
      <equivalent></equivalent>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="latexml">annotated</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <ci>pmod</ci>
        <cn type="integer">13</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>M</ci>
     <cn type="float">2.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=10^{2}\equiv-4,\;t\equiv 10^{3}\equiv-1\;\;(\mathop{{\rm mod}}13),M=2.
  </annotation>
 </semantics>
</math>

</li>
</ul>
<ul>
<li>Step 4: Now we start the loop

<math display="block" id="Tonelli–Shanks_algorithm:28">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>≢</mo>
   <mrow>
    <mn>1</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>13</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">not-equivalent-to</csymbol>
    <ci>t</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">13</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\not\equiv 1\;\;(\mathop{{\rm mod}}13)
  </annotation>
 </semantics>
</math>

 so 

<math display="inline" id="Tonelli–Shanks_algorithm:29">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo><</mo>
   <mi>i</mi>
   <mo><</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <cn type="integer">0</cn>
     <ci>i</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <cn type="float">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0<i<\;2
  </annotation>
 </semantics>
</math>

; <em>i.e.</em> 

<math display="inline" id="Tonelli–Shanks_algorithm:30">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mn>1.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <cn type="float">1.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=\;1.
  </annotation>
 </semantics>
</math>


<ul>
<li>Let 

<math display="inline" id="Tonelli–Shanks_algorithm:31">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>≡</mo>
   <msup>
    <mn>8</mn>
    <msup>
     <mn>2</mn>
     <mrow>
      <mn>2</mn>
      <mo>-</mo>
      <mn>1</mn>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mn>8</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>13</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <ci>b</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">8</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <cn type="integer">2</cn>
        <cn type="integer">1</cn>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <cn type="integer">8</cn>
      <apply>
       <ci>pmod</ci>
       <cn type="integer">13</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\equiv 8^{2^{2-1-1}}\equiv 8\;\;(\mathop{{\rm mod}}13)
  </annotation>
 </semantics>
</math>

, so 

<math display="inline" id="Tonelli–Shanks_algorithm:32">
 <semantics>
  <mrow>
   <msup>
    <mi>b</mi>
    <mn>2</mn>
   </msup>
   <mo>≡</mo>
   <msup>
    <mn>8</mn>
    <mn>2</mn>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>13</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">8</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <ci>pmod</ci>
       <cn type="integer">13</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b^{2}\equiv 8^{2}\equiv-1\;\;(\mathop{{\rm mod}}13)
  </annotation>
 </semantics>
</math>

.</li>
<li>Set 

<math display="inline" id="Tonelli–Shanks_algorithm:33">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mn>4</mn>
     <mo>⋅</mo>
     <mn>8</mn>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mn>7</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>13</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>R</ci>
     <apply>
      <minus></minus>
      <apply>
       <ci>normal-⋅</ci>
       <cn type="integer">4</cn>
       <cn type="integer">8</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <cn type="integer">7</cn>
      <apply>
       <ci>pmod</ci>
       <cn type="integer">13</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=-4\cdot 8\equiv 7\;\;(\mathop{{\rm mod}}13)
  </annotation>
 </semantics>
</math>


. Set 

<math display="inline" id="Tonelli–Shanks_algorithm:34">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>≡</mo>
   <mo>-</mo>
   <mn>1</mn>
   <mo>⋅</mo>
   <mo>-</mo>
   <mn>1</mn>
   <mo>≡</mo>
   <mn>1</mn>
   <mrow>
    <mo lspace="8.1pt" stretchy="false">(</mo>
    <mrow>
     <mo>mod</mo>
     <mn>13</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <equivalent></equivalent>
    <minus></minus>
    <cn type="integer">1</cn>
    <ci>normal-⋅</ci>
    <minus></minus>
    <cn type="integer">1</cn>
    <equivalent></equivalent>
    <cn type="integer">1</cn>
    <apply>
     <ci>pmod</ci>
     <cn type="integer">13</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\equiv-1\cdot-1\equiv 1\;\;(\mathop{{\rm mod}}13)
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Tonelli–Shanks_algorithm:35">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mn>1.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <cn type="float">1.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=\;1.
  </annotation>
 </semantics>
</math>

</li>
<li>We restart the loop, and since 

<math display="inline" id="Tonelli–Shanks_algorithm:36">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>≡</mo>
   <mrow>
    <mn>1</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>13</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>t</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">13</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\equiv 1\;\;(\mathop{{\rm mod}}13)
  </annotation>
 </semantics>
</math>

 we are done, returning 

<math display="inline" id="Tonelli–Shanks_algorithm:37">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mo>≡</mo>
    <mrow>
     <mn>7</mn>
     <mspace width="veryverythickmathspace">
     </mspace>
     <mrow>
      <mo lspace="8.1pt" stretchy="false">(</mo>
      <mrow>
       <mo>mod</mo>
       <mn>13</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>R</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">7</cn>
     <apply>
      <ci>pmod</ci>
      <cn type="integer">13</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\equiv 7\;\;(\mathop{{\rm mod}}13).
  </annotation>
 </semantics>
</math>

</li>
</ul></li>
</ul>

<p>Indeed, observe that 

<math display="inline" id="Tonelli–Shanks_algorithm:38">
 <semantics>
  <mrow>
   <msup>
    <mn>7</mn>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <mn>49</mn>
   <mo>≡</mo>
   <mrow>
    <mn>10</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>13</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">7</cn>
      <cn type="integer">2</cn>
     </apply>
     <cn type="integer">49</cn>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <cn type="integer">10</cn>
      <apply>
       <ci>pmod</ci>
       <cn type="integer">13</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   7^{2}=49\equiv 10\;\;(\mathop{{\rm mod}}13)
  </annotation>
 </semantics>
</math>


 and naturally also 

<math display="inline" id="Tonelli–Shanks_algorithm:39">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>-</mo>
      <mn>7</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>≡</mo>
   <msup>
    <mn>6</mn>
    <mn>2</mn>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mn>10</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mn>13</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">7</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">6</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <cn type="integer">10</cn>
      <apply>
       <ci>pmod</ci>
       <cn type="integer">13</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (-7)^{2}\equiv 6^{2}\equiv 10\;\;(\mathop{{\rm mod}}13)
  </annotation>
 </semantics>
</math>

. So the algorithm yields two solutions to our congruence.</p>
<h2 id="proof">Proof</h2>

<p>First write 

<math display="inline" id="Tonelli–Shanks_algorithm:40">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>Q</mi>
    <msup>
     <mn>2</mn>
     <mi>S</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p-1=Q2^{S}
  </annotation>
 </semantics>
</math>

. Now write 

<math display="inline" id="Tonelli–Shanks_algorithm:41">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>≡</mo>
   <mrow>
    <msup>
     <mi>n</mi>
     <mfrac>
      <mrow>
       <mi>Q</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mn>2</mn>
     </mfrac>
    </msup>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>r</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <apply>
       <divide></divide>
       <apply>
        <plus></plus>
        <ci>Q</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r\equiv n^{\frac{Q+1}{2}}\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Tonelli–Shanks_algorithm:42">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>≡</mo>
   <mrow>
    <msup>
     <mi>n</mi>
     <mi>Q</mi>
    </msup>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>t</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <ci>Q</ci>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\equiv n^{Q}\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

, observing that 

<math display="inline" id="Tonelli–Shanks_algorithm:43">
 <semantics>
  <mrow>
   <msup>
    <mi>r</mi>
    <mn>2</mn>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mi>n</mi>
     <mi>t</mi>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>r</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>t</ci>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{2}\equiv nt\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>


. This latter congruence will be true after every iteration of the algorithm's main loop. If at any point, 

<math display="inline" id="Tonelli–Shanks_algorithm:44">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>≡</mo>
   <mrow>
    <mn>1</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>t</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\equiv 1\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Tonelli–Shanks_algorithm:45">
 <semantics>
  <mrow>
   <msup>
    <mi>r</mi>
    <mn>2</mn>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mi>n</mi>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>r</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <ci>n</ci>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{2}\equiv n\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

 and the algorithm terminates with 

<math display="inline" id="Tonelli–Shanks_algorithm:46">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mo>±</mo>
     <mi>r</mi>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>R</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <csymbol cd="latexml">plus-or-minus</csymbol>
      <ci>r</ci>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\equiv\pm r\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

.</p>

<p>If 

<math display="inline" id="Tonelli–Shanks_algorithm:47">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>≢</mo>
   <mrow>
    <mn>1</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">not-equivalent-to</csymbol>
    <ci>t</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\not\equiv 1\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

, then consider 

<math display="inline" id="Tonelli–Shanks_algorithm:48">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>


, a quadratic non-residue of 

<math display="inline" id="Tonelli–Shanks_algorithm:49">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="Tonelli–Shanks_algorithm:50">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>≡</mo>
   <mrow>
    <msup>
     <mi>z</mi>
     <mi>Q</mi>
    </msup>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>c</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <ci>Q</ci>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c\equiv z^{Q}\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

. Then 

<math display="inline" id="Tonelli–Shanks_algorithm:51">
 <semantics>
  <mrow>
   <msup>
    <mi>c</mi>
    <msup>
     <mn>2</mn>
     <mi>S</mi>
    </msup>
   </msup>
   <mo>≡</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>z</mi>
      <mi>Q</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <msup>
     <mn>2</mn>
     <mi>S</mi>
    </msup>
   </msup>
   <mo>≡</mo>
   <msup>
    <mi>z</mi>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>S</mi>
     </msup>
     <mi>Q</mi>
    </mrow>
   </msup>
   <mo>≡</mo>
   <msup>
    <mi>z</mi>
    <mrow>
     <mi>p</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mn>1</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>c</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>S</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <ci>Q</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <ci>S</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <ci>S</ci>
       </apply>
       <ci>Q</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <apply>
       <minus></minus>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <cn type="integer">1</cn>
      <apply>
       <ci>pmod</ci>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c^{2^{S}}\equiv(z^{Q})^{2^{S}}\equiv z^{2^{S}Q}\equiv z^{p-1}\equiv 1\;\;(%
\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Tonelli–Shanks_algorithm:52">
 <semantics>
  <mrow>
   <msup>
    <mi>c</mi>
    <msup>
     <mn>2</mn>
     <mrow>
      <mi>S</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </msup>
   <mo>≡</mo>
   <msup>
    <mi>z</mi>
    <mfrac>
     <mrow>
      <mi>p</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mn>2</mn>
    </mfrac>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>c</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <ci>S</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>z</ci>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <ci>p</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">annotated</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <ci>pmod</ci>
       <ci>p</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c^{2^{S-1}}\equiv z^{\frac{p-1}{2}}\equiv-1\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

, which shows that the <a href="Order_(group_theory)" title="wikilink">order</a> of 

<math display="inline" id="Tonelli–Shanks_algorithm:53">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>


 is 

<math display="inline" id="Tonelli–Shanks_algorithm:54">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>S</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{S}
  </annotation>
 </semantics>
</math>

.</p>

<p>Similarly we have 

<math display="inline" id="Tonelli–Shanks_algorithm:55">
 <semantics>
  <mrow>
   <msup>
    <mi>t</mi>
    <msup>
     <mn>2</mn>
     <mi>S</mi>
    </msup>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mn>1</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>t</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>S</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{2^{S}}\equiv 1\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

, so the order of 

<math display="inline" id="Tonelli–Shanks_algorithm:56">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 divides 

<math display="inline" id="Tonelli–Shanks_algorithm:57">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>S</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{S}
  </annotation>
 </semantics>
</math>

. Suppose the order of 

<math display="inline" id="Tonelli–Shanks_algorithm:58">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>


 is 

<math display="inline" id="Tonelli–Shanks_algorithm:59">
 <semantics>
  <msup>
   <mn>2</mn>
   <msup>
    <mi>S</mi>
    <mo>′</mo>
   </msup>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{S^{\prime}}
  </annotation>
 </semantics>
</math>

. Since 

<math display="inline" id="Tonelli–Shanks_algorithm:60">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is a square modulo 

<math display="inline" id="Tonelli–Shanks_algorithm:61">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Tonelli–Shanks_algorithm:62">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>≡</mo>
   <mrow>
    <msup>
     <mi>n</mi>
     <mi>Q</mi>
    </msup>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>t</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <ci>Q</ci>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\equiv n^{Q}\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

 is also a square, and hence 

<math display="inline" id="Tonelli–Shanks_algorithm:63">
 <semantics>
  <mrow>
   <msup>
    <mi>S</mi>
    <mo>′</mo>
   </msup>
   <mo>≤</mo>
   <mrow>
    <mi>S</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>S</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{\prime}\leq S-1
  </annotation>
 </semantics>
</math>


.</p>

<p>Now we set 

<math display="inline" id="Tonelli–Shanks_algorithm:64">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>≡</mo>
   <mrow>
    <msup>
     <mi>c</mi>
     <msup>
      <mn>2</mn>
      <mrow>
       <mi>S</mi>
       <mo>-</mo>
       <msup>
        <mi>S</mi>
        <mo>′</mo>
       </msup>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </msup>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>b</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>c</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <ci>S</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>S</ci>
         <ci>normal-′</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\equiv c^{2^{S-S^{\prime}-1}}\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

 and with this 

<math display="inline" id="Tonelli–Shanks_algorithm:65">
 <semantics>
  <mrow>
   <msup>
    <mi>r</mi>
    <mo>′</mo>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mi>b</mi>
     <mi>r</mi>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>r</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <times></times>
      <ci>b</ci>
      <ci>r</ci>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{\prime}\equiv br\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Tonelli–Shanks_algorithm:66">
 <semantics>
  <mrow>
   <msup>
    <mi>c</mi>
    <mo>′</mo>
   </msup>
   <mo>≡</mo>
   <mrow>
    <msup>
     <mi>b</mi>
     <mn>2</mn>
    </msup>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>c</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>b</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c^{\prime}\equiv b^{2}\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Tonelli–Shanks_algorithm:67">
 <semantics>
  <mrow>
   <msup>
    <mi>t</mi>
    <mo>′</mo>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>c</mi>
      <mo>′</mo>
     </msup>
     <mi>t</mi>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>t</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>c</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{\prime}\equiv c^{\prime}t\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

. As before, 

<math display="inline" id="Tonelli–Shanks_algorithm:68">
 <semantics>
  <mrow>
   <msup>
    <mi>r</mi>
    <mrow>
     <mi mathvariant="normal">′</mi>
     <mn>2</mn>
    </mrow>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mi>n</mi>
     <msup>
      <mi>t</mi>
      <mo>′</mo>
     </msup>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>r</ci>
     <list>
      <ci>normal-′</ci>
      <cn type="integer">2</cn>
     </list>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>t</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{\prime 2}\equiv nt^{\prime}\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>


 holds; however with this construction both 

<math display="inline" id="Tonelli–Shanks_algorithm:69">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Tonelli–Shanks_algorithm:70">
 <semantics>
  <msup>
   <mi>c</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>c</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c^{\prime}
  </annotation>
 </semantics>
</math>

 have order 

<math display="inline" id="Tonelli–Shanks_algorithm:71">
 <semantics>
  <msup>
   <mn>2</mn>
   <msup>
    <mi>S</mi>
    <mo>′</mo>
   </msup>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{S^{\prime}}
  </annotation>
 </semantics>
</math>

. This implies that 

<math display="inline" id="Tonelli–Shanks_algorithm:72">
 <semantics>
  <msup>
   <mi>t</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>t</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{\prime}
  </annotation>
 </semantics>
</math>

 has order 

<math display="inline" id="Tonelli–Shanks_algorithm:73">
 <semantics>
  <msup>
   <mn>2</mn>
   <msup>
    <mi>S</mi>
    <mi>′′</mi>
   </msup>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>′′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{S^{\prime\prime}}
  </annotation>
 </semantics>
</math>


 with 

<math display="inline" id="Tonelli–Shanks_algorithm:74">
 <semantics>
  <mrow>
   <msup>
    <mi>S</mi>
    <mi>′′</mi>
   </msup>
   <mo><</mo>
   <msup>
    <mi>S</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>′′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{\prime\prime}<S^{\prime}
  </annotation>
 </semantics>
</math>

.</p>

<p>If 

<math display="inline" id="Tonelli–Shanks_algorithm:75">
 <semantics>
  <mrow>
   <msup>
    <mi>S</mi>
    <mi>′′</mi>
   </msup>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>S</ci>
     <ci>′′</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{\prime\prime}=0
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Tonelli–Shanks_algorithm:76">
 <semantics>
  <mrow>
   <msup>
    <mi>t</mi>
    <mo>′</mo>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mn>1</mn>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>t</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{\prime}\equiv 1\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

, and the algorithm stops, returning 

<math display="inline" id="Tonelli–Shanks_algorithm:77">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mo>±</mo>
     <msup>
      <mi>r</mi>
      <mo>′</mo>
     </msup>
    </mrow>
    <mspace width="veryverythickmathspace">
    </mspace>
    <mrow>
     <mo lspace="8.1pt" stretchy="false">(</mo>
     <mrow>
      <mo>mod</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>R</ci>
    <apply>
     <csymbol cd="latexml">annotated</csymbol>
     <apply>
      <csymbol cd="latexml">plus-or-minus</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>r</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <apply>
      <ci>pmod</ci>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\equiv\pm r^{\prime}\;\;(\mathop{{\rm mod}}p)
  </annotation>
 </semantics>
</math>

. Else, we restart the loop with analogous definitions of 

<math display="inline" id="Tonelli–Shanks_algorithm:78">
 <semantics>
  <msup>
   <mi>b</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>b</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b^{\prime}
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="Tonelli–Shanks_algorithm:79">
 <semantics>
  <msup>
   <mi>r</mi>
   <mi>′′</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>r</ci>
    <ci>′′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r^{\prime\prime}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Tonelli–Shanks_algorithm:80">
 <semantics>
  <msup>
   <mi>c</mi>
   <mi>′′</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>c</ci>
    <ci>′′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c^{\prime\prime}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Tonelli–Shanks_algorithm:81">
 <semantics>
  <msup>
   <mi>t</mi>
   <mi>′′</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>t</ci>
    <ci>′′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{\prime\prime}
  </annotation>
 </semantics>
</math>

 until we arrive at an 

<math display="inline" id="Tonelli–Shanks_algorithm:82">
 <semantics>
  <msup>
   <mi>S</mi>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>j</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>′</mo>
   </msup>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>j</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S^{(j)^{\prime}}
  </annotation>
 </semantics>
</math>

 that equals 0. Since the sequence of <em>S</em> is strictly decreasing the algorithm terminates.</p>
<h2 id="speed-of-the-algorithm">Speed of the algorithm</h2>

<p>The Tonelli–Shanks algorithm requires (on average over all possible input (quadratic residues and quadratic nonresidues))</p>

<p>

<math display="block" id="Tonelli–Shanks_algorithm:83">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi>m</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mi>k</mi>
    </mrow>
    <mo>+</mo>
    <mfrac>
     <mrow>
      <mi>S</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>S</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mn>4</mn>
    </mfrac>
    <mo>+</mo>
    <mfrac>
     <mn>1</mn>
     <msup>
      <mn>2</mn>
      <mrow>
       <mi>S</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
    </mfrac>
   </mrow>
   <mo>-</mo>
   <mn>9</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>m</ci>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>k</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>S</ci>
       <apply>
        <minus></minus>
        <ci>S</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <cn type="integer">4</cn>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <cn type="integer">2</cn>
       <apply>
        <minus></minus>
        <ci>S</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <cn type="integer">9</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2m+2k+\frac{S(S-1)}{4}+\frac{1}{2^{S-1}}-9
  </annotation>
 </semantics>
</math>

</p>

<p>modular multiplications, where 

<math display="inline" id="Tonelli–Shanks_algorithm:84">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 is the number of digits in the binary representation of 

<math display="inline" id="Tonelli–Shanks_algorithm:85">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Tonelli–Shanks_algorithm:86">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is the number of ones in the binary representation of 

<math display="inline" id="Tonelli–Shanks_algorithm:87">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

. If the required quadratic nonresidue 

<math display="inline" id="Tonelli–Shanks_algorithm:88">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>


 is to be found by checking if a randomly taken number 

<math display="inline" id="Tonelli–Shanks_algorithm:89">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is a quadratic nonresidue, it requires (on average) 

<math display="inline" id="Tonelli–Shanks_algorithm:90">
 <semantics>
  <mn>2</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">2</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2
  </annotation>
 </semantics>
</math>

 computations of the Legendre symbol.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The average of two computations of the Legendre symbol are explained as follows

<math display="block" id="Tonelli–Shanks_algorithm:91">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is a quadratic residue with chance 

<math display="inline" id="Tonelli–Shanks_algorithm:92">
 <semantics>
  <mrow>
   <mfrac>
    <mfrac>
     <mrow>
      <mi>p</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mn>2</mn>
    </mfrac>
    <mi>p</mi>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mfrac>
      <mn>1</mn>
      <mi>p</mi>
     </mfrac>
    </mrow>
    <mn>2</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <ci>p</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>p</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{\frac{p+1}{2}}{p}=\frac{1+\frac{1}{p}}{2}
  </annotation>
 </semantics>
</math>

, which is smaller than 

<math display="inline" id="Tonelli–Shanks_algorithm:93">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>


 but 

<math display="inline" id="Tonelli–Shanks_algorithm:94">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>≥</mo>
   <mfrac>
    <mn>1</mn>
    <mn>2</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \geq\frac{1}{2}
  </annotation>
 </semantics>
</math>

, so we will on average need to check if a 

<math display="inline" id="Tonelli–Shanks_algorithm:95">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 is a quadratic residue two times.</p>

<p>This shows essentially that the Tonelli–Shanks algorithm works very well if the modulus 

<math display="inline" id="Tonelli–Shanks_algorithm:96">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is random, that is, if 

<math display="inline" id="Tonelli–Shanks_algorithm:97">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is not particularly large with respect to the number of digits in the binary representation of 

<math display="inline" id="Tonelli–Shanks_algorithm:98">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>


. As written above, <a href="Cipolla's_algorithm" title="wikilink">Cipolla's algorithm</a> works better than Tonelli–Shanks if (and only if) 

<math display="inline" id="Tonelli–Shanks_algorithm:99">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>S</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mrow>
    <mrow>
     <mn>8</mn>
     <mi>m</mi>
    </mrow>
    <mo>+</mo>
    <mn>20</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <minus></minus>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">8</cn>
      <ci>m</ci>
     </apply>
     <cn type="integer">20</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(S-1)>8m+20
  </annotation>
 </semantics>
</math>

. However, if one instead uses Sutherland's algorithm to perform the discrete logarithm computation in the 2-Sylow subgroup of 

<math display="inline" id="Tonelli–Shanks_algorithm:100">
 <semantics>
  <msub>
   <mi>𝔽</mi>
   <mi>p</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝔽</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{F}_{p}
  </annotation>
 </semantics>
</math>

, one may replace 

<math display="inline" id="Tonelli–Shanks_algorithm:101">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>S</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <apply>
     <minus></minus>
     <ci>S</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(S-1)
  </annotation>
 </semantics>
</math>

 with an expression that is asymptotically bounded by 

<math display="inline" id="Tonelli–Shanks_algorithm:102">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mi>log</mi>
      <mrow>
       <mi>S</mi>
       <mo>/</mo>
       <mrow>
        <mi>log</mi>
        <mrow>
         <mi>log</mi>
         <mi>S</mi>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <log></log>
      <apply>
       <divide></divide>
       <ci>S</ci>
       <apply>
        <log></log>
        <apply>
         <log></log>
         <ci>S</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(S\log S/\log\log S)
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Explicitly, one computes 

<math display="inline" id="Tonelli–Shanks_algorithm:103">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>


 such that 

<math display="inline" id="Tonelli–Shanks_algorithm:104">
 <semantics>
  <mrow>
   <msup>
    <mi>c</mi>
    <mi>e</mi>
   </msup>
   <mo>≡</mo>
   <msup>
    <mi>n</mi>
    <mi>Q</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>c</ci>
     <ci>e</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <ci>Q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c^{e}\equiv n^{Q}
  </annotation>
 </semantics>
</math>

 and then 

<math display="inline" id="Tonelli–Shanks_algorithm:105">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>≡</mo>
   <mrow>
    <msup>
     <mi>c</mi>
     <mrow>
      <mo>-</mo>
      <mrow>
       <mi>e</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </mrow>
    </msup>
    <msup>
     <mi>n</mi>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>Q</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>R</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>c</ci>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <ci>e</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <apply>
       <divide></divide>
       <apply>
        <plus></plus>
        <ci>Q</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\equiv c^{-e/2}n^{(Q+1)/2}
  </annotation>
 </semantics>
</math>

 satisfies 

<math display="inline" id="Tonelli–Shanks_algorithm:106">
 <semantics>
  <mrow>
   <msup>
    <mi>R</mi>
    <mn>2</mn>
   </msup>
   <mo>≡</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{2}\equiv n
  </annotation>
 </semantics>
</math>

 (note that 

<math display="inline" id="Tonelli–Shanks_algorithm:107">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 is a multiple of 2 because 

<math display="inline" id="Tonelli–Shanks_algorithm:108">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


 is a quadratic residue).</p>

<p>The algorithm requires us to find a quadratic nonresidue 

<math display="inline" id="Tonelli–Shanks_algorithm:109">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

. There is no known deterministic algorithm that runs in polynomial time for finding such a 

<math display="inline" id="Tonelli–Shanks_algorithm:110">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

. However, if the <a href="generalized_Riemann_hypothesis" title="wikilink">generalized Riemann hypothesis</a> is true, there exists a quadratic nonresidue 

<math display="inline" id="Tonelli–Shanks_algorithm:111">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo><</mo>
   <mrow>
    <mn>2</mn>
    <mrow>
     <msup>
      <mi>ln</mi>
      <mn>2</mn>
     </msup>
     <mi>p</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>z</ci>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ln></ln>
       <cn type="integer">2</cn>
      </apply>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z<2\ln^{2}{p}
  </annotation>
 </semantics>
</math>

,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> making it possible to check every 

<math display="inline" id="Tonelli–Shanks_algorithm:112">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 up to that limit and find a suitable 

<math display="inline" id="Tonelli–Shanks_algorithm:113">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>


 within <a href="polynomial_time" title="wikilink">polynomial time</a>. Keep in mind, however, that this is a worst-case scenario; in general, 

<math display="inline" id="Tonelli–Shanks_algorithm:114">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 is found in on average 2 trials as stated above.</p>
<h2 id="uses">Uses</h2>

<p>The Tonelli–Shanks algorithm can (naturally) be used for any process in which square roots modulo a prime are necessary. For example, it can be used for finding points on <a href="elliptic_curves" title="wikilink">elliptic curves</a>. It is also useful for the computations in the <a href="Rabin_cryptosystem" title="wikilink">Rabin cryptosystem</a>.</p>
<h2 id="generalizations">Generalizations</h2>

<p>Tonelli–Shanks can be generalized to any cyclic group (instead of 

<math display="inline" id="Tonelli–Shanks_algorithm:115">
 <semantics>
  <mrow>
   <mrow>
    <mi>ℤ</mi>
    <mo>/</mo>
    <mi>p</mi>
   </mrow>
   <msup>
    <mi>ℤ</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <ci>ℤ</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ℤ</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{Z}/p\mathbb{Z}^{*}
  </annotation>
 </semantics>
</math>

) and to <em>k</em>th roots for arbitrary integer <em>k</em>, in particular to taking the <em>k</em>th root of an element of a <a href="finite_field" title="wikilink">finite field</a> .<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>If many square-roots must be done in the same cyclic group and S is not too large, a table of square-roots of the elements of 2-power order can be prepared in advance and the algorithm simplified and sped up as follows.</p>
<ol>
<li>Factor out powers of 2 from <em>p</em> − 1, defining <em>Q</em> and <em>S</em> as

<math display="block" id="Tonelli–Shanks_algorithm:116">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>Q</mi>
    <msup>
     <mn>2</mn>
     <mi>S</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <minus></minus>
     <ci>p</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>Q</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p-1=Q2^{S}
  </annotation>
 </semantics>
</math>

 with <em>Q</em> odd.</li>
<li>Let 

<math display="inline" id="Tonelli–Shanks_algorithm:117">
 <semantics>
  <mrow>
   <mrow>
    <mi>R</mi>
    <mo>≡</mo>
    <msup>
     <mi>n</mi>
     <mfrac>
      <mrow>
       <mi>Q</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
      <mn>2</mn>
     </mfrac>
    </msup>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>t</mi>
    <mo>≡</mo>
    <msup>
     <mi>n</mi>
     <mi>Q</mi>
    </msup>
    <mo>≡</mo>
    <mrow>
     <msup>
      <mi>R</mi>
      <mn>2</mn>
     </msup>
     <mo>/</mo>
     <mi>n</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <equivalent></equivalent>
     <ci>R</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <apply>
       <divide></divide>
       <apply>
        <plus></plus>
        <ci>Q</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <equivalent></equivalent>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>n</ci>
       <ci>Q</ci>
      </apply>
     </apply>
     <apply>
      <equivalent></equivalent>
      <share href="#.cmml">
      </share>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>R</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\equiv n^{\frac{Q+1}{2}},t\equiv n^{Q}\equiv R^{2}/n
  </annotation>
 </semantics>
</math>

</li>
<li>Find 

<math display="inline" id="Tonelli–Shanks_algorithm:118">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b
  </annotation>
 </semantics>
</math>


 from the table such that 

<math display="inline" id="Tonelli–Shanks_algorithm:119">
 <semantics>
  <mrow>
   <msup>
    <mi>b</mi>
    <mn>2</mn>
   </msup>
   <mo>≡</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>b</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b^{2}\equiv t
  </annotation>
 </semantics>
</math>

 and set 

<math display="inline" id="Tonelli–Shanks_algorithm:120">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>≡</mo>
   <mrow>
    <mi>R</mi>
    <mo>/</mo>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>R</ci>
    <apply>
     <divide></divide>
     <ci>R</ci>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\equiv R/b
  </annotation>
 </semantics>
</math>

</li>
<li>return <em>R</em>.</li>
</ol>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
</ul>

<p>Pages 110–115 describe the algorithm and explain the group theory behind it.</p>
<ul>
<li>Daniel Shanks. Five Number Theoretic Algorithms. Proceedings of the Second Manitoba Conference on Numerical Mathematics. Pp. 51–70. 1973.</li>
<li>Alberto Tonelli, Bemerkung über die Auflösung quadratischer Congruenzen. Nachrichten von der Königlichen Gesellschaft der Wissenschaften und der Georg-Augusts-Universität zu Göttingen. Pp. 344–346. 1891. <a href="http://resolver.sub.uni-goettingen.de/purl?GDZPPN002525739">1</a></li>
<li>Gagan Tara Nanda - Mathematics 115: The RESSOL Algorithm <a href="http://www.ocf.berkeley.edu/~gagnanda/mathstuff/RESSOL.pdf">2</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>Implementation in C# <a class="uri" href="http://shankstonelli.blogspot.com/2010/12/shanks-tonelli-algorithm-in-c.html">http://shankstonelli.blogspot.com/2010/12/shanks-tonelli-algorithm-in-c.html</a></li>
<li>Implementation in Python <a class="uri" href="http://eli.thegreenplace.net/2009/03/07/computing-modular-square-roots-in-python">http://eli.thegreenplace.net/2009/03/07/computing-modular-square-roots-in-python</a></li>
</ul>

<p><a href="ru:Алгоритм_Шенкса" title="wikilink">ru:Алгоритм Шенкса</a>"</p>

<p><a href="Category:Modular_arithmetic" title="wikilink">Category:Modular arithmetic</a> <a href="Category:Number_theoretic_algorithms" title="wikilink">Category:Number theoretic algorithms</a> <a href="Category:Articles_containing_proofs" title="wikilink">Category:Articles containing proofs</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Oded Goldreich, <em>Computational complexity: a conceptual perspective</em>, Cambridge University Press, 2008, p. 588.<a href="#fnref1">↩</a></li>
<li id="fn2">Daniel Shanks. Five Number-theoretic Algorithms. Proceedings of the Second Manitoba Conference on Numerical Mathematics. Pp. 51–70. 1973.<a href="#fnref2">↩</a></li>
<li id="fn3">Gonzalo Tornaria - Square roots modulo p, page 2 <a class="uri" href="http://www.springerlink.com/content/xgxe68edy03la96p/fulltext.pdf">http://www.springerlink.com/content/xgxe68edy03la96p/fulltext.pdf</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6">Adleman, L. M., K. Manders, and G. Miller: 1977, `On taking roots in finite fields'. In: 18th IEEE Symposium on Foundations of Computer Science. pp. 175-177<a href="#fnref6">↩</a></li>
</ol>
</section>
</body>
</html>
