<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="316">Optimal solutions for Rubik's Cube</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Optimal solutions for Rubik's Cube</h1>
<hr/>

<p>There are many <a href="algorithm" title="wikilink">algorithms</a> to solve scrambled <a href="Rubik's_Cube" title="wikilink">Rubik's Cubes</a>. The maximum number of face turns needed to solve any instance of the Rubik's Cube is 20,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and the maximum number of quarter turns is 26.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> These numbers are also the <a href="Distance_(graph_theory)" title="wikilink">diameters</a> of the corresponding <a href="Cayley_graph" title="wikilink">Cayley graphs</a> of the <a href="Rubik's_Cube_group" title="wikilink">Rubik's Cube group</a>. An algorithm that solves a cube in the minimum number of moves is known as <a href="God's_algorithm" title="wikilink">God's algorithm</a>.</p>

<p>There are two common ways to measure the length of a solution. The first is to count the number of quarter turns. The second is to count the number of face turns. A move like F2 (a half turn of the front face) would be counted as 2 moves in the quarter turn metric and as only 1 turn in the face metric.</p>
<h2 id="move-notation">Move notation</h2>

<p>To denote a sequence of moves on the 3×3×3 Rubik's Cube, this article uses "Singmaster notation",<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> which was developed by <a href="David_Singmaster" title="wikilink">David Singmaster</a>.</p>

<p>The letters L,R,F,B,U,D indicate a quarter clockwise turn of the left, right, front, back, up and down face respectively. Half turns are indicated by appending a 2. A quarter counterclockwise turn is indicated by appending a <a href="Prime_(symbol)" title="wikilink">prime symbol</a> ( ′ ).</p>
<h2 id="lower-bounds">Lower bounds</h2>

<p>It can be proven by counting arguments that there exist positions needing at least 18 moves to solve. To show this, first count the number of cube positions that exist in total, then count the number of positions achievable using at most 17 moves. It turns out that the latter number is smaller.</p>

<p>This argument was not improved upon for many years. Also, it is not a <a href="constructive_proof" title="wikilink">constructive proof</a>: it does not exhibit a concrete position that needs this many moves. It was <a href="conjecture" title="wikilink">conjectured</a> that the so-called <a class="uri" href="superflip" title="wikilink">superflip</a> would be a position that is very difficult. A Rubik's Cube is in the superflip pattern when each corner piece is in the correct position, but each edge piece is incorrectly oriented.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> In 1992, a solution for the superflip with 20 face turns was found by Dik T. Winter, of which the minimality was shown in 1995 by Michael Reid, providing a new lower bound for the diameter of the cube group. Also in 1995, a solution for superflip in 24 quarter turns was found by Michael Reid, with its minimality proven by Jerry Bryan.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> In 1998, a new position requiring more than 24 quarter turns to solve was found. The position, which was called a 'superflip composed with four spot' needs 26 quarter turns.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="upper-bounds">Upper bounds</h2>

<p>The first upper bounds were based on the 'human' algorithms. By combining the worst-case scenarios for each part of these algorithms, the typical upper bound was found to be around 100.</p>

<p>Perhaps the first concrete value for an upper bound was the 277 moves mentioned by <a href="David_Singmaster" title="wikilink">David Singmaster</a> in early 1979. He simply counted the maximum number of moves required by his cube-solving algorithm.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Later, Singmaster reported that <a href="Elwyn_Berlekamp" title="wikilink">Elwyn Berlekamp</a>, <a href="John_Horton_Conway" title="wikilink">John Conway</a>, and Richard Guy had come up with a different algorithm that took at most 160 moves. Soon after, Conway’s Cambridge Cubists reported that the cube could be restored in at most 94 moves.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h3 id="thistlethwaites-algorithm">Thistlethwaite's algorithm</h3>

<p>The breakthrough was found by <a href="Morwen_Thistlethwaite" title="wikilink">Morwen Thistlethwaite</a>; details of <a href="Morwen_Thistlethwaite#Thistlethwaite's_algorithm" title="wikilink">Thistlethwaite's algorithm</a> were published in <em><a href="Scientific_American" title="wikilink">Scientific American</a></em> in 1981 by <a href="Douglas_Hofstadter" title="wikilink">Douglas Hofstadter</a>. The approaches to the cube that lead to algorithms with very few moves are based on <a href="group_(mathematics)" title="wikilink">group theory</a> and on extensive computer searches. Thistlethwaite's idea was to divide the problem into subproblems. Where algorithms up to that point divided the problem by looking at the parts of the cube that should remain fixed, he divided it by restricting the type of moves you could execute. In particular he divided the <a href="Rubik's_Cube_group" title="wikilink">cube group</a> into the following chain of subgroups:</p>
<ul>
<li>

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:0">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>L</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo>,</mo>
    <mi>F</mi>
    <mo>,</mo>
    <mi>B</mi>
    <mo>,</mo>
    <mi>U</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <cn type="integer">0</cn>
    </apply>
    <list>
     <ci>L</ci>
     <ci>R</ci>
     <ci>F</ci>
     <ci>B</ci>
     <ci>U</ci>
     <ci>D</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{0}=\langle L,R,F,B,U,D\rangle
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:1">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>L</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo>,</mo>
    <mi>F</mi>
    <mo>,</mo>
    <mi>B</mi>
    <mo>,</mo>
    <msup>
     <mi>U</mi>
     <mn>2</mn>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>D</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <cn type="integer">1</cn>
    </apply>
    <list>
     <ci>L</ci>
     <ci>R</ci>
     <ci>F</ci>
     <ci>B</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>U</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>D</ci>
      <cn type="integer">2</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{1}=\langle L,R,F,B,U^{2},D^{2}\rangle
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:2">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>L</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo>,</mo>
    <msup>
     <mi>F</mi>
     <mn>2</mn>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>B</mi>
     <mn>2</mn>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>U</mi>
     <mn>2</mn>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>D</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <cn type="integer">2</cn>
    </apply>
    <list>
     <ci>L</ci>
     <ci>R</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>U</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>D</ci>
      <cn type="integer">2</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{2}=\langle L,R,F^{2},B^{2},U^{2},D^{2}\rangle
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:3">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mn>3</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <msup>
     <mi>L</mi>
     <mn>2</mn>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>R</mi>
     <mn>2</mn>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>F</mi>
     <mn>2</mn>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>B</mi>
     <mn>2</mn>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>U</mi>
     <mn>2</mn>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>D</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <cn type="integer">3</cn>
    </apply>
    <list>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>R</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>U</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>D</ci>
      <cn type="integer">2</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{3}=\langle L^{2},R^{2},F^{2},B^{2},U^{2},D^{2}\rangle
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:4">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mn>4</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <cn type="integer">4</cn>
    </apply>
    <set>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{4}=\{1\}
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>Next he prepared tables for each of the right <a class="uri" href="coset" title="wikilink">coset</a> spaces 

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:5">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>∖</mo>
   <msub>
    <mi>G</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <setdiff></setdiff>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{i+1}\setminus G_{i}
  </annotation>
 </semantics>
</math>

. For each element he found a sequence of moves that took it to the next smaller group. After these preparations he worked as follows. A random cube is in the general cube group 

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:6">
 <semantics>
  <msub>
   <mi>G</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{0}
  </annotation>
 </semantics>
</math>

. Next he found this element in the right <a class="uri" href="coset" title="wikilink">coset</a> space 

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:7">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mn>1</mn>
   </msub>
   <mo>∖</mo>
   <msub>
    <mi>G</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <setdiff></setdiff>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{1}\setminus G_{0}
  </annotation>
 </semantics>
</math>

. He applied the corresponding process to the cube. This took it to a cube in 

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:8">
 <semantics>
  <msub>
   <mi>G</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{1}
  </annotation>
 </semantics>
</math>

. Next he looked up a process that takes the cube to 

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:9">
 <semantics>
  <msub>
   <mi>G</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{2}
  </annotation>
 </semantics>
</math>

, next to 

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:10">
 <semantics>
  <msub>
   <mi>G</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{3}
  </annotation>
 </semantics>
</math>

 and finally to 

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:11">
 <semantics>
  <msub>
   <mi>G</mi>
   <mn>4</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{4}
  </annotation>
 </semantics>
</math>

. </p>

<p>Although the whole cube group 

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:12">
 <semantics>
  <msub>
   <mi>G</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{0}
  </annotation>
 </semantics>
</math>

 is very large (~4.3×10<sup>19</sup>), the right coset spaces 

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:13">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>G</mi>
     <mn>1</mn>
    </msub>
    <mo>∖</mo>
    <msub>
     <mi>G</mi>
     <mn>0</mn>
    </msub>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>G</mi>
     <mn>2</mn>
    </msub>
    <mo>∖</mo>
    <msub>
     <mi>G</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>G</mi>
     <mn>3</mn>
    </msub>
    <mo>∖</mo>
    <msub>
     <mi>G</mi>
     <mn>2</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <setdiff></setdiff>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <setdiff></setdiff>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <setdiff></setdiff>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>G</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{1}\setminus G_{0},G_{2}\setminus G_{1},G_{3}\setminus G_{2}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:14">
 <semantics>
  <msub>
   <mi>G</mi>
   <mn>3</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{3}
  </annotation>
 </semantics>
</math>

 are much smaller. The coset space 

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:15">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mn>2</mn>
   </msub>
   <mo>∖</mo>
   <msub>
    <mi>G</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <setdiff></setdiff>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{2}\setminus G_{1}
  </annotation>
 </semantics>
</math>

 is the largest and contains only 1082565 elements. The number of moves required by this algorithm is the sum of the largest process in each step.</p>

<p>Initially, Thistlethwaite showed that any configuration could be solved in at most 85 moves. In January 1980 he improved his strategy to yield a maximum of 80 moves. Later that same year, he reduced the number to 63, and then again to 52.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> By exhaustively searching the coset spaces it was later found that the best possible number of moves for each stage was 7, 10, 13, and 15 giving a total of 45 moves at most.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h3 id="kociembas-algorithm">Kociemba's algorithm</h3>

<p>Thistlethwaite's algorithm was improved by <a href="Herbert_Kociemba" title="wikilink">Herbert Kociemba</a> in 1992. He reduced the number of intermediate groups to only two:</p>
<ul>
<li>

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:16">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>U</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <mi>L</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo>,</mo>
    <mi>F</mi>
    <mo>,</mo>
    <mi>B</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <cn type="integer">0</cn>
    </apply>
    <list>
     <ci>U</ci>
     <ci>D</ci>
     <ci>L</ci>
     <ci>R</ci>
     <ci>F</ci>
     <ci>B</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{0}=\langle U,D,L,R,F,B\rangle
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:17">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>U</mi>
    <mo>,</mo>
    <mi>D</mi>
    <mo>,</mo>
    <msup>
     <mi>L</mi>
     <mn>2</mn>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>R</mi>
     <mn>2</mn>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>F</mi>
     <mn>2</mn>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>B</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <cn type="integer">1</cn>
    </apply>
    <list>
     <ci>U</ci>
     <ci>D</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>R</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>F</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>B</ci>
      <cn type="integer">2</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{1}=\langle U,D,L^{2},R^{2},F^{2},B^{2}\rangle
  </annotation>
 </semantics>
</math>

</li>
<li>

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:18">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <cn type="integer">2</cn>
    </apply>
    <set>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{2}=\{1\}
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>As with <a href="Morwen_Thistlethwaite#Thistlethwaite's_algorithm" title="wikilink">Thistlethwaite's Algorithm</a>, he would search through the right coset space 

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:19">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mn>1</mn>
   </msub>
   <mo>∖</mo>
   <msub>
    <mi>G</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <setdiff></setdiff>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{1}\setminus G_{0}
  </annotation>
 </semantics>
</math>

 to take the cube to group 

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:20">
 <semantics>
  <msub>
   <mi>G</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{1}
  </annotation>
 </semantics>
</math>

. Next he searched the optimal solution for group 

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:21">
 <semantics>
  <msub>
   <mi>G</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{1}
  </annotation>
 </semantics>
</math>

. The searches in 

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:22">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mn>1</mn>
   </msub>
   <mo>∖</mo>
   <msub>
    <mi>G</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <setdiff></setdiff>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{1}\setminus G_{0}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:23">
 <semantics>
  <msub>
   <mi>G</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{1}
  </annotation>
 </semantics>
</math>

 were both done with a method equivalent to <a class="uri" href="IDA*" title="wikilink">IDA*</a>. The search in 

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:24">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mn>1</mn>
   </msub>
   <mo>∖</mo>
   <msub>
    <mi>G</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <setdiff></setdiff>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{1}\setminus G_{0}
  </annotation>
 </semantics>
</math>

 needs at most 12 moves and the search in 

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:25">
 <semantics>
  <msub>
   <mi>G</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{1}
  </annotation>
 </semantics>
</math>

 at most 18 moves, as Michael Reid showed in 1995. By generating also suboptimal solutions that take the cube to group 

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:26">
 <semantics>
  <msub>
   <mi>G</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{1}
  </annotation>
 </semantics>
</math>

 and looking for short solutions in 

<math display="inline" id="Optimal_solutions_for_Rubik's_Cube:27">
 <semantics>
  <msub>
   <mi>G</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{1}
  </annotation>
 </semantics>
</math>

, you usually get much shorter overall solutions. Using this algorithm solutions are typically found of fewer than 21 moves, though there is no proof that it will always do so.</p>

<p>In 1995 Michael Reid proved that using these two groups every position can be solved in at most 29 face turns, or in 42 quarter turns. This result was improved by Silviu Radu in 2005 to 40.</p>
<h3 id="korfs-algorithm">Korf's algorithm</h3>

<p>Using these group solutions combined with computer searches will generally quickly give very short solutions. But these solutions do not always come with a guarantee of their minimality. To search specifically for minimal solutions a new approach was needed.</p>

<p>In 1997 Richard Korf<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> announced an algorithm with which he had optimally solved random instances of the cube. Of the ten random cubes he did, none required more than 18 face turns. The method he used is called <a class="uri" href="IDA*" title="wikilink">IDA*</a> and is described in his paper "Finding Optimal Solutions to Rubik's Cube Using Pattern Databases". Korf describes this method as follows</p>
<dl>
<dd>IDA* is a depth-first search that looks for increasingly longer solutions in a series of iterations, using a lower-bound heuristic to prune branches once a lower bound on their length exceeds the current iterations bound.
</dd>
</dl>

<p>It works roughly as follows. First he identified a number of subproblems that are small enough to be solved optimally. He used:</p>
<ol>
<li>The cube restricted to only the corners, not looking at the edges</li>
<li>The cube restricted to only 6 edges, not looking at the corners nor at the other edges.</li>
<li>The cube restricted to the other 6 edges.</li>
</ol>

<p>Clearly the number of moves required to solve any of these subproblems is a lower bound for the number of moves you will need to solve the entire cube.</p>

<p>Given a <a class="uri" href="random" title="wikilink">random</a> cube C, it is solved as <a href="iterative_deepening" title="wikilink">iterative deepening</a>. First all cubes are generated that are the result of applying 1 move to them. That is C * F, C * U, … Next, from this list, all cubes are generated that are the result of applying two moves. Then three moves and so on. If at any point a cube is found that needs too many moves based on the upper bounds to still be optimal it can be eliminated from the list.</p>

<p>Although this <a class="uri" href="algorithm" title="wikilink">algorithm</a> will always find optimal solutions, there is no worst case analysis. It is not known how many moves this algorithm might need. An implementation of this algorithm can be found here.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h3 id="further-improvements">Further improvements</h3>

<p>In 2006, Silviu Radu further improved his methods to prove that every position can be solved in at most 27 face turns or 35 quarter turns.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Daniel Kunkle and Gene Cooperman in 2007 used a <a class="uri" href="supercomputer" title="wikilink">supercomputer</a> to show that all unsolved cubes can be solved in no more than 26 moves (in face-turn metric). Instead of attempting to solve each of the billions of variations explicitly, the computer was programmed to bring the cube to one of 15,752 states, each of which could be solved within a few extra moves. All were proved solvable in 29 moves, with most solvable in 26. Those that could not initially be solved in 26 moves were then solved explicitly, and shown that they too could be solved in 26 moves.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> <a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>Tomas Rokicki reported in a 2008 computational proof that all unsolved cubes could be solved in 25 moves or fewer.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> This was later reduced to 23 moves.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> In August 2008 Rokicki announced that he had a proof for 22 moves.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> Finally, in 2010, Tomas Rokicki, Herbert Kociemba, Morley Davidson, and John Dethridge gave the final <a href="computer-assisted_proof" title="wikilink">computer-assisted proof</a> that all cube positions could be solved with a maximum of 20 face turns.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a><a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>

<p>In 2009, Tomas Rokicki proved that 29 moves in the quarter-turn metric is enough to solve any scrambled cube.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> And in 2014, Tomas Rokicki and Morley Davidson proved that the maximum number of quarter-turns needed to solve the cube is 26. <a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>

<p>The face-turn and quarter-turn metrics differ in the nature of their antipodes.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> An antipode is a scrambled cube that is maximally far from solved, one that requires the maximum number of moves to solve. In the half-turn metric with a maximum number of 20, there are hundreds of millions of such positions. In the quarter-turn metric, only a single position (and its two rotations) is known that requires the maximum of 26 moves. Despite significant effort, no additional quarter-turn distance-26 positions have been found. Even at distance 25, only two positions (and their rotations) are known to exist. At distance 24, perhaps 150,000 positions exist.</p>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="b:How_to_solve_the_Rubik's_Cube" title="wikilink">How to solve the Rubik's Cube</a>, a Wikibooks article that gives an overview over several algorithms that are simple enough to be memorizable by humans. However, such algorithms will usually not give an <em>optimal</em> solution which only uses the minimum possible number of moves.</li>
<li><a href="http://kociemba.org/cube.htm">Herbert Kociemba's Two-Phase-Solver and Optimal Solver for Rubik's Cube</a></li>
<li><a href="http://www.ryanheise.com/cube/human_thistlethwaite_algorithm.html">Ryan Heise's Human version of the Thistlethwaite algorithm</a></li>
<li><a href="http://arxiv.org/abs/math.CO/0512485">A New Upper Bound on Rubik's Cube Group, Silviu Radu</a></li>
<li><a href="http://rubiksolve.com">Online Solver using modified Kociemba's Algorithm to balance optimization vs. compute cycles</a></li>
</ul>

<p>"</p>

<p><a href="Category:Rubik's_Cube" title="wikilink">Category:Rubik's Cube</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://www.cube20.org/">God's Number is 20</a><a href="#fnref1">↩</a></li>
<li id="fn2">Described below in greater detail.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="http://www.math.ucf.edu/~reid/Rubik/m_symmetric.html">Michael Reid's Rubik's Cube page M-symmetric positions</a><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"><a href="http://www.math.ucf.edu/~reid/Rubik/Cubelovers/cube-mail-25">Posted to Cube lovers on 2 Aug 1998</a><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"><a href="http://cubeman.org/dotcs.txt">Progressive Improvements in Solving Algorithms</a><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="http://www.math.ucf.edu/~reid/Rubik/optimal_solver.html">Michael Reid's Optimal Solver for Rubik's Cube</a> (requires a compiler such as gcc)<a href="#fnref13">↩</a></li>
<li id="fn14"><a href="http://cubezzz.dyndns.org/drupal/?q=node/view/53">Rubik can be solved in 27f</a><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="http://www.neu.edu/nupr/news/0507/rubik.html">Press Release on Proof that 26 Face Turns Suffice</a><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="http://cubezzz.dyndns.org/drupal/?q=node/view/117">Twenty-Three Moves Suffice</a> — Domain of the Cube Forum<a href="#fnref18">↩</a></li>
<li id="fn19"><a href="http://cubezzz.dyndns.org/drupal/?q=node/view/121">twenty-two moves suffice</a><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="http://www.cube20.org/">1</a><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="http://epubs.siam.org/doi/abs/10.1137/120867366">SIAM J. Discrete Math., 27(2), 1082–1105</a><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="http://www.cube20.org/qtm">God's Number is 26 in the Quarter-Turn Metric</a><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="http://www.cube20.org/qtm">God's Number is 26 in the Quarter-Turn Metric</a><a href="#fnref24">↩</a></li>
</ol>
</section>
</body>
</html>
