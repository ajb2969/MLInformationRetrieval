<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1594">Parity game</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Parity game</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>A parity game. Circular nodes belong to player 0, rectangular nodes belong to player 1. On the left side is the winning region of player 0, on the right side is the winning region of player 1.</figcaption>
</figure>

<p>A <strong>parity game</strong> is played on a colored <a href="directed_graph" title="wikilink">directed graph</a>, where each node has been colored by a priority – one of (usually) finitely many <a href="natural_numbers" title="wikilink">natural numbers</a>. Two players, 0 and 1, move a (single, shared) token along the edges of the graph. The owner of the node that the token falls on selects the successor node, resulting in a (possibly infinite) <a href="Path_(graph_theory)" title="wikilink">path</a>, called the play.</p>

<p>The winner of a finite play is the player whose opponent is unable to move. The winner of an infinite play is determined by the priorities appearing in the play. Typically, player 0 wins an infinite play if the largest priority that occurs infinitely often in the play is even. Player 1 wins otherwise. This explains the word "parity" in the title.</p>

<p>Parity games lie in the third level of the <a href="borel_hierarchy" title="wikilink">borel hierarchy</a>, and are consequently <a href="Determinacy" title="wikilink">determined</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Games related to parity games were implicitly used in <a href="Michael_O._Rabin" title="wikilink">Rabin</a>'s proof of <a href="Decidability_(logic)" title="wikilink">decidability</a> of second order theory of n successors, where <a class="uri" href="determinacy" title="wikilink">determinacy</a> of such games was proven.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The <a href="Knaster–Tarski_theorem" title="wikilink">Knaster–Tarski theorem</a> leads to a relatively simple proof of determinacy of parity games.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>Moreover, parity games are history-free determined.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> This means that if a player has a winning strategy then that player has a winning strategy that depends only on the current board position, and not on the history of the play.</p>
<h2 id="solving-a-game">Solving a game</h2>

<p><em>Solving</em> a parity game played on a finite graph means deciding, for a given starting position, which of the two players has a winning strategy. It has been shown that this problem is in <a href="NP_(complexity)" title="wikilink">NP</a> and <a class="uri" href="Co-NP" title="wikilink">Co-NP</a>, as well as <a href="UP_(complexity)" title="wikilink">UP</a> and co-UP.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> It remains an open question whether this decision problem is solvable in <a href="P_(complexity)" title="wikilink">PTime</a>.</p>

<p>Given that parity games are history-free determined, solving a given parity game is equivalent to solving the following simple looking graph-theoretic problem. Given a finite colored directed <a href="bipartite_graph" title="wikilink">bipartite graph</a> with <em>n</em> vertices 

<math display="inline" id="Parity_game:0">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>V</mi>
     <mn>0</mn>
    </msub>
    <mo>∪</mo>
    <msub>
     <mi>V</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>V</ci>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V=V_{0}\cup V_{1}
  </annotation>
 </semantics>
</math>

, and <em>V</em> colored with colors from <em>1</em> to <em>m</em>, is there a choice function selecting a single out-going edge from each vertex of 

<math display="inline" id="Parity_game:1">
 <semantics>
  <msub>
   <mi>V</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{0}
  </annotation>
 </semantics>
</math>

, such that the resulting subgraph has the property that in each cycle the largest occurring color is even.</p>
<h2 id="recursive-algorithm-for-solving-parity-games">Recursive algorithm for solving parity games</h2>

<p>Zielonka outlined a recursive algorithm that solves parity games. Let 

<math display="inline" id="Parity_game:2">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <msub>
     <mi>V</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>V</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi>E</mi>
    <mo>,</mo>
    <mi mathvariant="normal">Ω</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <vector>
     <ci>V</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>E</ci>
     <ci>normal-Ω</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,V_{0},V_{1},E,\Omega)
  </annotation>
 </semantics>
</math>

 be parity game, where 

<math display="inline" id="Parity_game:3">
 <semantics>
  <msub>
   <mi>V</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{0}
  </annotation>
 </semantics>
</math>

 resp. 

<math display="inline" id="Parity_game:4">
 <semantics>
  <msub>
   <mi>V</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>V</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{1}
  </annotation>
 </semantics>
</math>

 are the sets of nodes belonging to player 0 resp. 1, 

<math display="inline" id="Parity_game:5">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>V</mi>
     <mn>0</mn>
    </msub>
    <mo>∪</mo>
    <msub>
     <mi>V</mi>
     <mn>1</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>V</ci>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V=V_{0}\cup V_{1}
  </annotation>
 </semantics>
</math>

 is the set of all nodes, 

<math display="inline" id="Parity_game:6">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mo>⊆</mo>
   <mrow>
    <mi>V</mi>
    <mo>×</mo>
    <mi>V</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>E</ci>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\subseteq V\times V
  </annotation>
 </semantics>
</math>

 is the total set of edges, and 

<math display="inline" id="Parity_game:7">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mo>:</mo>
   <mrow>
    <mi>V</mi>
    <mo>→</mo>
    <mi>ℕ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>normal-Ω</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>V</ci>
     <ci>ℕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega:V\rightarrow\mathbb{N}
  </annotation>
 </semantics>
</math>

 is the priority assignment function.</p>

<p>Zielonka's algorithm is based on the notation of attractors. Let 

<math display="inline" id="Parity_game:8">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mo>⊆</mo>
   <mi>V</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>U</ci>
    <ci>V</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U\subseteq V
  </annotation>
 </semantics>
</math>

 be a set of nodes and 

<math display="inline" id="Parity_game:9">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=0,1
  </annotation>
 </semantics>
</math>

 be a player. The 

<math display="inline" id="Parity_game:10">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

-attractor of 

<math display="inline" id="Parity_game:11">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 is the least set of nodes 

<math display="inline" id="Parity_game:12">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mi>t</mi>
   <mi>t</mi>
   <msub>
    <mi>r</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>U</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>t</ci>
    <ci>t</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>i</ci>
    </apply>
    <ci>U</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Attr_{i}(U)
  </annotation>
 </semantics>
</math>

 containing 

<math display="inline" id="Parity_game:13">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Parity_game:14">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 can force a visit to 

<math display="inline" id="Parity_game:15">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 from every node in 

<math display="inline" id="Parity_game:16">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mi>t</mi>
   <mi>t</mi>
   <msub>
    <mi>r</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>U</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>t</ci>
    <ci>t</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>i</ci>
    </apply>
    <ci>U</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Attr_{i}(U)
  </annotation>
 </semantics>
</math>

. It can be defined by a fix-point computation:</p>

<p>

<math display="inline" id="Parity_game:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi>t</mi>
    <mi>t</mi>
    <msub>
     <mi>r</mi>
     <mi>i</mi>
    </msub>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>U</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>0</mn>
    </msup>
   </mrow>
   <mo>:=</mo>
   <mi>U</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>t</ci>
     <ci>t</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>U</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <ci>U</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Attr_{i}(U)^{0}:=U
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Parity_game:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi>t</mi>
    <mi>t</mi>
    <msub>
     <mi>r</mi>
     <mi>i</mi>
    </msub>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>U</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mi>j</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mi>t</mi>
     <mi>t</mi>
     <msub>
      <mi>r</mi>
      <mi>i</mi>
     </msub>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>U</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>j</mi>
     </msup>
    </mrow>
    <mo>∪</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>v</mi>
      <mo>∈</mo>
      <msub>
       <mi>V</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo>∣</mo>
     <mrow>
      <mrow>
       <mrow>
        <mo>∃</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>v</mi>
         <mo>,</mo>
         <mi>w</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>∈</mo>
       <mi>E</mi>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mi>w</mi>
       <mo>∈</mo>
       <mrow>
        <mi>A</mi>
        <mi>t</mi>
        <mi>t</mi>
        <msub>
         <mi>r</mi>
         <mi>i</mi>
        </msub>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>U</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mi>j</mi>
        </msup>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
    <mo>∪</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>v</mi>
      <mo>∈</mo>
      <msub>
       <mi>V</mi>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mi>i</mi>
       </mrow>
      </msub>
     </mrow>
     <mo>∣</mo>
     <mrow>
      <mrow>
       <mrow>
        <mo>∀</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>v</mi>
         <mo>,</mo>
         <mi>w</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>∈</mo>
       <mi>E</mi>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mi>w</mi>
       <mo>∈</mo>
       <mrow>
        <mi>A</mi>
        <mi>t</mi>
        <mi>t</mi>
        <msub>
         <mi>r</mi>
         <mi>i</mi>
        </msub>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>U</mi>
          <mo stretchy="false">)</mo>
         </mrow>
         <mi>j</mi>
        </msup>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>t</ci>
     <ci>t</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>U</ci>
      <apply>
       <plus></plus>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <union></union>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>t</ci>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>U</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <in></in>
       <ci>v</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>V</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <ci>normal-:</ci>
       <apply>
        <in></in>
        <apply>
         <exists></exists>
         <interval closure="open">
          <ci>v</ci>
          <ci>w</ci>
         </interval>
        </apply>
        <ci>E</ci>
       </apply>
       <apply>
        <in></in>
        <ci>w</ci>
        <apply>
         <times></times>
         <ci>A</ci>
         <ci>t</ci>
         <ci>t</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>U</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <in></in>
       <ci>v</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>V</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <ci>normal-:</ci>
       <apply>
        <in></in>
        <apply>
         <csymbol cd="latexml">for-all</csymbol>
         <interval closure="open">
          <ci>v</ci>
          <ci>w</ci>
         </interval>
        </apply>
        <ci>E</ci>
       </apply>
       <apply>
        <in></in>
        <ci>w</ci>
        <apply>
         <times></times>
         <ci>A</ci>
         <ci>t</ci>
         <ci>t</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>U</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Attr_{i}(U)^{j+1}:=Attr_{i}(U)^{j}\cup\{v\in V_{i}\mid\exists(v,w)\in E:w\in
Attr%
_{i}(U)^{j}\}\cup\{v\in V_{1-i}\mid\forall(v,w)\in E:w\in Attr_{i}(U)^{j}\}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Parity_game:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mi>t</mi>
    <mi>t</mi>
    <msub>
     <mi>r</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>U</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋃</mo>
     <mrow>
      <mi>j</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mrow>
     <mi>A</mi>
     <mi>t</mi>
     <mi>t</mi>
     <msub>
      <mi>r</mi>
      <mi>i</mi>
     </msub>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>U</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>j</mi>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>t</ci>
     <ci>t</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>i</ci>
     </apply>
     <ci>U</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <union></union>
       <apply>
        <eq></eq>
        <ci>j</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>t</ci>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>r</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>U</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Attr_{i}(U):=\bigcup_{j=0}^{\infty}Attr_{i}(U)^{j}
  </annotation>
 </semantics>
</math>

</p>

<p>In other words, one starts with the initial set 

<math display="inline" id="Parity_game:20">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 and adds, in every step, all nodes belonging to player 0 that can reach 

<math display="inline" id="Parity_game:21">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 with a single edge and all nodes belonging to player 1 that must reach 

<math display="inline" id="Parity_game:22">
 <semantics>
  <mi>U</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>U</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U
  </annotation>
 </semantics>
</math>

 no matter which edge player 1 takes.</p>

<p>Zielonka's algorithm is based on a recursive descent on the number of priorities. If the maximal priority is 0, it is immediate to see that player 0 wins the whole game (with an arbitrary strategy). Otherwise, let 

<math display="inline" id="Parity_game:23">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 be the largest one and let 

<math display="inline" id="Parity_game:24">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mi>p</mi>
    <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <ci>p</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=p\mod 2
  </annotation>
 </semantics>
</math>

 be the player associated with the priority. Let 

<math display="inline" id="Parity_game:25">
 <semantics>
  <mrow>
   <mi>U</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>v</mi>
    <mo>∣</mo>
    <mrow>
     <mrow>
      <mi mathvariant="normal">Ω</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mi>p</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>U</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>v</ci>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>normal-Ω</ci>
       <ci>v</ci>
      </apply>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U=\{v\mid\Omega(v)=p\}
  </annotation>
 </semantics>
</math>

 be the set of nodes with priority 

<math display="inline" id="Parity_game:26">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 and let 

<math display="inline" id="Parity_game:27">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mi>t</mi>
    <mi>t</mi>
    <msub>
     <mi>r</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>U</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>t</ci>
     <ci>t</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <ci>i</ci>
     </apply>
     <ci>U</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=Attr_{i}(U)
  </annotation>
 </semantics>
</math>

 be the corresponding attractor of player 

<math display="inline" id="Parity_game:28">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

. Player 

<math display="inline" id="Parity_game:29">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 can now ensure that every play that visits 

<math display="inline" id="Parity_game:30">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 infinitely often is won by player 

<math display="inline" id="Parity_game:31">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

.</p>

<p>Consider the game 

<math display="inline" id="Parity_game:32">
 <semantics>
  <mrow>
   <msup>
    <mi>G</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>G</mi>
    <mo>∖</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>G</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <setdiff></setdiff>
     <ci>G</ci>
     <ci>A</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime}=G\setminus A
  </annotation>
 </semantics>
</math>

 in which all nodes and affected edges of 

<math display="inline" id="Parity_game:33">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 are removed. We can now solve the smaller game 

<math display="inline" id="Parity_game:34">
 <semantics>
  <msup>
   <mi>G</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>G</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime}
  </annotation>
 </semantics>
</math>

 by recursion and obtain a pair of winning sets 

<math display="inline" id="Parity_game:35">
 <semantics>
  <mrow>
   <msubsup>
    <mi>W</mi>
    <mi>i</mi>
    <mo>′</mo>
   </msubsup>
   <mo>,</mo>
   <msubsup>
    <mi>W</mi>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mi>i</mi>
    </mrow>
    <mo>′</mo>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>W</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>W</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>i</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{\prime}_{i},W^{\prime}_{1-i}
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Parity_game:36">
 <semantics>
  <msubsup>
   <mi>W</mi>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mi>i</mi>
   </mrow>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>W</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{\prime}_{1-i}
  </annotation>
 </semantics>
</math>

 is empty, then so is 

<math display="inline" id="Parity_game:37">
 <semantics>
  <msub>
   <mi>W</mi>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mi>i</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>W</ci>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{1-i}
  </annotation>
 </semantics>
</math>

 for the game 

<math display="inline" id="Parity_game:38">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, because player 

<math display="inline" id="Parity_game:39">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mi>i</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-i
  </annotation>
 </semantics>
</math>

 can only decide to escape from 

<math display="inline" id="Parity_game:40">
 <semantics>
  <msub>
   <mi>W</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>W</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{i}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Parity_game:41">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 which also results in a win for player 

<math display="inline" id="Parity_game:42">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

.</p>

<p>Otherwise, if 

<math display="inline" id="Parity_game:43">
 <semantics>
  <msubsup>
   <mi>W</mi>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mi>i</mi>
   </mrow>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>W</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{\prime}_{1-i}
  </annotation>
 </semantics>
</math>

 is not empty, we only know for sure that player 

<math display="inline" id="Parity_game:44">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mi>i</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-i
  </annotation>
 </semantics>
</math>

 can win on 

<math display="inline" id="Parity_game:45">
 <semantics>
  <msubsup>
   <mi>W</mi>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mi>i</mi>
   </mrow>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>W</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{\prime}_{1-i}
  </annotation>
 </semantics>
</math>

 as there is no player 

<math display="inline" id="Parity_game:46">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 escape from 

<math display="inline" id="Parity_game:47">
 <semantics>
  <msubsup>
   <mi>W</mi>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mi>i</mi>
   </mrow>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>W</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{\prime}_{1-i}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Parity_game:48">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 (because 

<math display="inline" id="Parity_game:49">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is an attractor already). We therefore compute to 

<math display="inline" id="Parity_game:50">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mi>i</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-i
  </annotation>
 </semantics>
</math>

 attractor 

<math display="inline" id="Parity_game:51">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>=</mo>
   <mrow>
    <mi>A</mi>
    <mi>t</mi>
    <mi>t</mi>
    <msub>
     <mi>r</mi>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>i</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>W</mi>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>i</mi>
      </mrow>
      <mo>′</mo>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>B</ci>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>t</ci>
     <ci>t</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>r</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>W</ci>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B=Attr_{1-i}(W^{\prime}_{1-i})
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Parity_game:52">
 <semantics>
  <msubsup>
   <mi>W</mi>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mi>i</mi>
   </mrow>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>W</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{\prime}_{1-i}
  </annotation>
 </semantics>
</math>

 and remove it from 

<math display="inline" id="Parity_game:53">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 to obtain the smaller game 

<math display="inline" id="Parity_game:54">
 <semantics>
  <mrow>
   <msup>
    <mi>G</mi>
    <mi>′′</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>G</mi>
    <mo>∖</mo>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>G</ci>
     <ci>′′</ci>
    </apply>
    <apply>
     <setdiff></setdiff>
     <ci>G</ci>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime\prime}=G\setminus B
  </annotation>
 </semantics>
</math>

. We again solve it by recursion and obtain a pair of winning sets 

<math display="inline" id="Parity_game:55">
 <semantics>
  <mrow>
   <msubsup>
    <mi>W</mi>
    <mi>i</mi>
    <mi>′′</mi>
   </msubsup>
   <mo>,</mo>
   <msubsup>
    <mi>W</mi>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mi>i</mi>
    </mrow>
    <mi>′′</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>W</ci>
      <ci>′′</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>W</ci>
      <ci>′′</ci>
     </apply>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>i</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{\prime\prime}_{i},W^{\prime\prime}_{1-i}
  </annotation>
 </semantics>
</math>

. It follows that 

<math display="inline" id="Parity_game:56">
 <semantics>
  <mrow>
   <msub>
    <mi>W</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <msubsup>
    <mi>W</mi>
    <mi>i</mi>
    <mi>′′</mi>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>W</ci>
      <ci>′′</ci>
     </apply>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{i}=W^{\prime\prime}_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Parity_game:57">
 <semantics>
  <mrow>
   <msub>
    <mi>W</mi>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mi>i</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>W</mi>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>i</mi>
     </mrow>
     <mi>′′</mi>
    </msubsup>
    <mo>∪</mo>
    <mi>B</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <union></union>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>W</ci>
       <ci>′′</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>i</ci>
      </apply>
     </apply>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{1-i}=W^{\prime\prime}_{1-i}\cup B
  </annotation>
 </semantics>
</math>

.</p>

<p>In simple <a class="uri" href="pseudocode" title="wikilink">pseudocode</a>, the algorithm might be expressed as this:</p>

<p><code>
  function solve(<math>G</math>)
      <math>p</math> = maximal priority in <math>G</math>
      if <math>p = 0</math>
          return <math>W_0 = V, W_1 = \{\}</math>
      else
          <math>U =</math> nodes in <math>G</math> with priority <math>p</math>
<math>i = p \mod 2</math>
<math>A = Attr_i(U)</math>
<math>W_0', W_1' = solve(G \setminus A)</math>
          if <math>W_i' = V</math>
               return <math>W_i = V, W_{1-i} = \{\}</math>
<math>B = Attr_{1-i}(W_{1-i}')</math>
<math>W_0'', W_1'' = solve(G \setminus B)</math>
          return <math>W_i = W_i'', W_{1-i} = W_{1-i}'' \cup B</math>
</code></p>
<h2 id="related-games-and-their-decision-problems">Related games and their decision problems</h2>

<p>A slight modification of the above game, and the related graph-theoretic problem, makes solving the game <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>. The modified game has the <a href="Rabin_automaton" title="wikilink">Rabin acceptance condition</a>. Specifically, in the above bipartite graph scenario, the problem now is to determine if there is a choice function selecting a single out-going edge from each vertex of <em>V</em><sub>0</sub>, such that the resulting subgraph has the property that in each cycle (and hence each <a href="strongly_connected_component" title="wikilink">strongly connected component</a>) it is the case that there exists an <em>i</em> and a node with color 2<em>i</em>, and no node with color 2<em>i</em> + 1...</p>

<p>Note that as opposed to parity games, this game is no longer symmetric with respect to players 0 and 1.</p>
<h2 id="relation-with-logic-and-automata-theory">Relation with logic and automata theory</h2>

<p> Despite its interesting complexity theoretic status, parity game solving can be seen as the algorithmic backend to problems in automated verification and controller synthesis. The model-checking problem for the <a href="modal_μ-calculus" title="wikilink">modal μ-calculus</a> for instance is known to be equivalent to parity game solving. Also, decision problems like validity or satisfiability for modal logics can be reduced to parity game solving.</p>
<h2 id="references">References</h2>
<references>
</references>
<ul>
<li></li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>E. Grädel, W. Thomas, T. Wilke (Eds.) : <em>Automata, Logics, and Infinite Games</em>, Springer LNCS 2500 (2003), ISBN 3-540-00388-6</li>
<li>W. Zielonka : <em>Infinite games on finitely coloured graphs with applications to automata on infinite tree</em>, TCS, 200(1-2):135-183, 1998</li>
</ul>
<h2 id="external-links">External links</h2>

<p>Parity Game Solvers:</p>
<ul>
<li><a href="http://www.tcs.ifi.lmu.de/pgsolver">PGSolver Collection</a></li>
</ul>

<p>"</p>

<p><a href="Category:Game_theory" title="wikilink">Category:Game theory</a> <a href="Category:Finite_model_theory" title="wikilink">Category:Finite model theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="Donald_A._Martin" title="wikilink">D. A. Martin</a>: Borel determinacy, The Annals of Mathematics, Vol 102 No. 2 pp. 363–371 (1975)<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">E. A. Emerson and C. S. Jutla: Tree Automata, Mu-Calculus and Determinacy, IEEE Proc. Foundations of Computer Science, pp 368–377 (1991), ISBN 0-8186-2445-0<a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5">A. Mostowski: Games with forbidden positions, University of Gdansk, Tech. Report 78 (1991)<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7">Grädel 2007, p. 163<a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
