<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1951">Super-recursive algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Super-recursive algorithm</h1>
<hr/>

<p>In <a href="computability_theory" title="wikilink">computability theory</a>, <strong>super-recursive algorithms</strong> are a generalization of ordinary <a href="algorithm" title="wikilink">algorithms</a> that are more powerful, that is, compute more than <a href="Turing_machines" title="wikilink">Turing machines</a>. The term was introduced by Mark Burgin, whose book "Super-recursive algorithms" develops their theory and presents several mathematical models. Turing machines and other mathematical models of conventional algorithms allow researchers to find properties of recursive algorithms and their computations. In a similar way, mathematical models of super-recursive algorithms, such as inductive Turing machines, allow researchers to find properties of super-recursive algorithms and their computations.</p>

<p>Burgin, as well as other researchers (including <a href="Selim_Akl" title="wikilink">Selim Akl</a>, Eugene Eberbach, Peter Kugel, <a href="Jan_van_Leeuwen" title="wikilink">Jan van Leeuwen</a>, <a href="Hava_Siegelmann" title="wikilink">Hava Siegelmann</a>, Peter Wegner, and Jiří Wiedermann) who studied different kinds of super-recursive algorithms and contributed to the theory of super-recursive algorithms, have argued that super-recursive algorithms can be used to disprove the <a href="Church-Turing_thesis" title="wikilink">Church-Turing thesis</a>, but this point of view has been criticized within the mathematical community and is not widely accepted.</p>
<h2 id="definition">Definition</h2>

<p>Burgin (2005: 13) uses the term <strong>recursive algorithms</strong> for <a href="algorithm" title="wikilink">algorithms</a> that can be implemented on Turing machines, and uses the word <em>algorithm</em> in a more general sense. Then a <strong>super-recursive class of algorithms</strong> is "a class of algorithms in which it is possible to compute functions not computable by any <a href="Turing_machine" title="wikilink">Turing machine</a>" (Burgin 2005: 107).</p>

<p>Super-recursive algorithms are closely related to <a class="uri" href="hypercomputation" title="wikilink">hypercomputation</a> in a way similar to the relationship between ordinary computation and ordinary algorithms. Computation is a process, while an algorithm is a finite constructive description of such a process. Thus a super-recursive algorithm defines a "computational process (including processes of input and output) that cannot be realized by recursive algorithms." (Burgin 2005: 108). A more restricted definition demands that <a class="uri" href="hypercomputation" title="wikilink">hypercomputation</a> solves a <a class="uri" href="supertask" title="wikilink">supertask</a> (see Copeland 2002; Hagar and Korolev 2007).</p>

<p>Super-recursive algorithms are also related to <strong>algorithmic schemes</strong>, which are more general than super-recursive algorithms. Burgin argues (2005: 115) that it is necessary to make a clear distinction between super-recursive algorithms and those algorithmic schemes that are not algorithms. Under this distinction, some types of hypercomputation are obtained by super-recursive algorithms, e.g., inductive Turing machines, while other types of hypercomputation are directed by algorithmic schemas, e.g., infinite time Turing machines. This explains how works on super-recursive algorithms are related to hypercomputation and vice versa. According to this argument, super-recursive algorithms are just one way of defining a hypercomputational process.</p>
<h2 id="examples">Examples</h2>

<p>Examples of super-recursive algorithms include (Burgin 2005: 132):</p>
<ul>
<li><strong>limiting recursive functions</strong> and <strong>limiting partial recursive functions</strong> (E.M. Gold)</li>
<li><strong>trial and error predicates</strong> (Hilary Putnam)</li>
<li><strong>inductive inference machines</strong> (Carl Smith)</li>
<li><strong>inductive Turing machines</strong>, which perform computations similar to computations of <a href="Turing_machines" title="wikilink">Turing machines</a> and produce their results after a finite number of steps (Mark Burgin)</li>
<li><strong>limit Turing machines</strong>, which perform computations similar to computations of Turing machines but their final results are limits of their intermediate results (Mark Burgin)</li>
<li><strong>trial-and-error machines</strong> (Ja. Hintikka and A. Mutanen)</li>
<li><strong>general Turing machines</strong> (J. Schmidhuber)</li>
<li><strong>Internet machines</strong> (<a href="Jan_van_Leeuwen" title="wikilink">van Leeuwen, J.</a> and Wiedermann, J.)</li>
<li><strong>evolutionary computers</strong>, which use DNA to produce the value of a function (Darko Roglic)</li>
<li><strong>fuzzy computation</strong> (Jirí Wiedermann)</li>
<li><strong>evolutionary Turing machines</strong> (Eugene Eberbach)</li>
</ul>

<p>Examples of algorithmic schemes include:</p>
<ul>
<li><strong>Turing machines with arbitrary oracles</strong> (Alan Turing)</li>
<li><strong>Transrecursive operators</strong> (Borodyanskii and Burgin)</li>
<li><strong>machines that compute with real numbers</strong> (L. Blum, F. Cucker, M. Shub, and S. Smale)</li>
<li><strong>neural networks based on real numbers</strong> (Hava Siegelmann)</li>
</ul>

<p>For examples of practical <strong>super-recursive algorithms</strong>, see the book of Burgin.</p>
<h2 id="inductive-turing-machines">Inductive Turing machines</h2>

<p><strong>Inductive Turing machines</strong> implement an important class of super-recursive algorithms. An inductive Turing machine is a definite list of well-defined instructions for completing a task which, when given an initial state, will proceed through a well-defined series of successive states, eventually giving the final result. The difference between an inductive Turing machine and an ordinary <a href="Turing_machine" title="wikilink">Turing machine</a> is that an ordinary Turing machine must stop when it has obtained its result, while in some cases an inductive Turing machine can continue to compute after obtaining the result, without stopping. Kleene called procedures that could run forever without stopping by the name <em>calculation procedure or algorithm</em> (Kleene 1952:137). Kleene also demanded that such an algorithm must eventually exhibit "some object" (Kleene 1952:137). Burgin argues that this condition is satisfied by inductive Turing machines, as their results are exhibited after a finite number of steps. The reason that inductive Turing machines cannot be instructed to halt when their final output is produced is that in some cases inductive Turing machines may not be able to tell at which step the result has been obtained.</p>

<p>Simple inductive Turing machines are equivalent to other models of computation such as general Turing machines of Schmidhuber, trial and error predicates of Hilary Putnam, limiting partial recursive functions of Gold, and trial-and-error machines of Hintikka and Mutanen. More advanced inductive Turing machines are much more powerful. There are hierarchies of inductive Turing machines that can decide membership in arbitrary sets of the <a href="arithmetical_hierarchy" title="wikilink">arithmetical hierarchy</a> (Burgin 2005). In comparison with other equivalent models of computation, simple inductive Turing machines and general Turing machines give direct constructions of computing automata that are thoroughly grounded in physical machines. In contrast, trial-and-error predicates, limiting recursive functions, and limiting partial recursive functions present only syntactic systems of symbols with formal rules for their manipulation. Simple inductive Turing machines and general Turing machines are related to limiting partial recursive functions and trial-and-error predicates as Turing machines are related to partial recursive functions and lambda calculus.</p>

<p>The non-halting computations of inductive Turing machines should not be confused with infinite-time computations (see, for example, Potgieter 2006). First, some computations of inductive Turing machines do halt. As in the case of conventional Turing machines, some halting computations give the result, while others do not. Even if it does not halt, an inductive Turing machine produces output from time to time. If this output stops changing, it is then considered the result of the computation.</p>

<p>There are two main distinctions between ordinary Turing machines and simple inductive Turing machines. The first distinction is that even simple inductive Turing machines can do much more than conventional Turing machines. The second distinction is that a conventional Turing machine will always determine (by coming to a final state) when the result is obtained, while a simple inductive Turing machine, in some cases (such as when "computing" something that cannot be computed by an ordinary Turing machine), will not be able to make this determination.</p>
<h2 id="schmidhubers-generalized-turing-machines">Schmidhuber's generalized Turing machines</h2>

<p>A symbol sequence is <strong>computable in the limit</strong> if there is a finite, possibly non-halting program on a <a href="universal_Turing_machine" title="wikilink">universal Turing machine</a> that incrementally outputs every symbol of the sequence. This includes the dyadic expansion of π but still excludes most of the real numbers, because most cannot be described by a finite program. Traditional <a href="Turing_machine" title="wikilink">Turing machines</a> cannot edit their previous outputs; generalized <a href="Turing_machines" title="wikilink">Turing machines</a>, according to <a href="Jürgen_Schmidhuber" title="wikilink">Jürgen Schmidhuber</a>, can. He defines the constructively describable symbol sequences as those that have a finite, non-halting program running on a generalized Turing machine, such that any output symbol eventually converges, that is, it does not change any more after some finite initial time interval. Due to limitations first exhibited by <a href="Kurt_Gödel" title="wikilink">Kurt Gödel</a> (1931), it may be impossible to predict the convergence time itself by a halting program, otherwise the <a href="halting_problem" title="wikilink">halting problem</a> could be solved. Schmidhuber (2000, 2002) uses this approach to define the set of formally describable or constructively computable universes or constructive <a href="theory_of_everything" title="wikilink">theories of everything</a>. Generalized Turing machines and simple inductive Turing machines are two classes of super-recursive algorithms that are the closest to recursive algorithms.</p>
<h2 id="relation-to-the-churchturing-thesis">Relation to the Church–Turing thesis</h2>

<p>The Church–Turing thesis in recursion theory relies on a particular definition of the term <em>algorithm</em>. Based on definitions that are more general than the one commonly used in recursion theory, Burgin argues that super-recursive algorithms, such as <strong>inductive Turing machines</strong> disprove the <a href="Church–Turing_thesis" title="wikilink">Church–Turing thesis</a>. He proves furthermore that super-recursive algorithms could theoretically provide even greater efficiency gains than using <a href="quantum_algorithms" title="wikilink">quantum algorithms</a>.</p>

<p>Burgin's interpretation of super-recursive algorithms has encountered opposition in the mathematical community. One critic is logician <a href="Martin_Davis" title="wikilink">Martin Davis</a>, who argues that Burgin's claims have been well understood "for decades". Davis states,</p>
<dl>
<dd>"The present criticism is not about the mathematical discussion of these matters but only about the misleading claims regarding physical systems of the present and future."(Davis 2006: 128)
</dd>
</dl>

<p>Davis disputes Burgin's claims that sets at level 

<math display="inline" id="Super-recursive_algorithm:0">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Δ</mi>
   <mn>2</mn>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Δ</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta^{0}_{2}
  </annotation>
 </semantics>
</math>

 of the <a href="arithmetical_hierarchy" title="wikilink">arithmetical hierarchy</a> can be called computable, saying</p>
<dl>
<dd>"It is generally understood that for a computational result to be useful one must be able to at least recognize that it is indeed the result sought." (Davis 2006: 128)
</dd>
</dl>
<h2 id="references">References</h2>
<ul>
<li>Akl, S.G., Three counterexamples to dispel the myth of the universal computer, <em>Parallel Processing Letters</em>, Vol. 16, No. 3, September 2006, pp. 381 – 403.</li>
<li>Akl, S.G., The myth of universal computation, in: Parallel Numerics, Trobec, R., Zinterhof, P., Vajtersic, M., and Uhl, A., Eds., Part 2, <em>Systems and Simulation</em>, University of Salzburg, Salzburg, Austria and Jozef Stefan Institute, Ljubljana, Slovenia, 2005, pp. 211 – 236</li>
<li>Angluin, D., and Smith, C. H. (1983) Inductive Inference: Theory and Methods, <em>Comput. Surveys</em>, v. 15, no. 3, pp. 237–269</li>
<li>Apsïtis, K, Arikawa, S, Freivalds, R., Hirowatari, E., and Smith, C. H. (1999) On the inductive inference of recursive real-valued functions, <em><a href="Theoretical_Computer_Science_(journal)" title="wikilink">Theoretical Computer Science</a></em>, 219(1-2): 3—17</li>
<li>Axt, P. (1959) On a Subrecursive Hierarchy and Primitive Recursive Degrees, <em>Transactions of the American Mathematical Society</em>, v. 92, pp. 85–105</li>
<li>Blum, L., and Blum, M. (1975) Toward a mathematical theory of inductive inference. <em><a href="Information_and_Control" title="wikilink">Information and Control</a></em> vol. 28, pp. 125–155</li>
<li>Blum, L., F. Cucker, M. Shub, and S. Smale, <em>Complexity and real computation</em>, <a href="Springer_Publishing" title="wikilink">Springer Publishing</a> 1998</li>
<li>Boddy, M, Dean, T. 1989. "Solving Time-Dependent Planning Problems". Technical Report: CS-89-03, <a href="Brown_University" title="wikilink">Brown University</a></li>
<li>Borodyanskii, Yu. M. and Burgin, M.S. (1994) Operations with Transrecursive Operators, Cybernetics and System Analysis, No. 4, pp. 3–11</li>
<li>Burgin, Mark (2005), <em>Super-recursive algorithms</em>, Monographs in computer science, Springer. ISBN 0-387-95569-0
<ul>
<li>José Félix Costa, [<a class="uri" href="http://www.ams.org/mathscinet/search/publdoc.html?pg1=IID&amp;s1">http://www.ams.org/mathscinet/search/publdoc.html?pg1=IID&amp;s1;</a>;=193826&amp;r;=3&amp;mx-pid;=2246430 MR2246430 Review] in <a class="uri" href="MathSciNet" title="wikilink">MathSciNet</a>.</li>
<li>Harvey Cohn (2005), <a href="http://www.computingreviews.net/browse/browse_topics4.cfm?ccs_id=2376">CR131542 (0606-0574) Review</a> in <a href="Computing_Reviews" title="wikilink">Computing Reviews</a></li>
<li>Martin Davis (2007),<a href="http://www.math.ucla.edu/~asl/bsl/1302/1302-004.ps">Review</a> in <em><a href="Bulletin_of_Symbolic_Logic" title="wikilink">Bulletin of Symbolic Logic</a></em>, v. 13 n. 2.</li>
<li>Marc L. Smith (2006), <a href="http://comjnl.oxfordjournals.org/cgi/reprint/49/6/762-a.pdf">Review</a> in <em><a href="The_Computer_Journal" title="wikilink">The Computer Journal</a></em>, Vol. 49 No. 6</li>
<li>Review, Vilmar Trevisan (2005), <a href="Zentralblatt_MATH" title="wikilink">Zentralblatt MATH</a>, Vol. 1070. Review [<a class="uri" href="http://siba-sinmdb.unile.it/cgi-bin/zmen/ZMATH/en/quick.html?first=1&amp;maxdocs">http://siba-sinmdb.unile.it/cgi-bin/zmen/ZMATH/en/quick.html?first=1&amp;maxdocs;</a>;=3&amp;type;=html&amp;an;=1070.68038&amp;format;=complete 1070.68038]</li>
</ul></li>
<li>Burgin, M. "How We Know What Technology Can Do", <em><a href="Communications_of_the_ACM" title="wikilink">Communications of the ACM</a></em>, v. 44, No. 11, 2001, pp. 82–88</li>
<li>Burgin M., "Universal limit Turing machines", <em>Notices of the <a href="Russian_Academy_of_Sciences" title="wikilink">Russian Academy of Sciences</a></em>, 325, No. 4, (1992), 654-658</li>
<li>Burgin, M. and Klinger, A. "Three Aspects of Super-recursive Algorithms and Hypercomputation or Finding Black Swans", <em><a href="Theoretical_Computer_Science_(journal)" title="wikilink">Theoretical Computer Science</a></em>, v. 317, No. 1/3, 2004, pp. 1–11</li>
<li>Burgin, M. "Algorithmic Complexity of Recursive and Inductive Algorithms", <em>Theoretical Computer Science</em>, v. 317, No. 1/3, 2004, pp. 31–60</li>
<li>Burgin, M. and Klinger, A. Experience, Generations, and Limits in Machine Learning, <em><a href="Theoretical_Computer_Science_(journal)" title="wikilink">Theoretical Computer Science</a></em>, v. 317, No. 1/3, 2004, pp. 71–91</li>
<li>Campagnolo, M.L., Moore, C., and Costa, J.F. (2000) An analog characterization of the subrecursive functions. In Proc. of the 4th Conference on Real Numbers and Computers, <a href="Odense_University" title="wikilink">Odense University</a>, pp. 91–109</li>
<li>Copeland, J. (2002) Hypercomputation, <em><a href="Minds_and_Machines" title="wikilink">Minds and Machines</a></em>, v. 12, pp. 461–502</li>
<li>Davis, Martin (2006), "<a href="http://people.cs.uchicago.edu/~simon/TEACH/28000/DavisUniversal.pdf">The Church–Turing Thesis: Consensus and opposition</a>". Proceedings, Computability in Europe 2006. Lecture notes in computer science, 3988 pp. 125–132</li>
<li>Eberbach, E. (2005) "Toward a theory of evolutionary computation", <em><a class="uri" href="BioSystems" title="wikilink">BioSystems</a></em> 82, 1-19</li>
<li>Eberbach, E., and Wegner, P., "Beyond Turing Machines", <em>Bulletin of the <a href="European_Association_for_Theoretical_Computer_Science" title="wikilink">European Association for Theoretical Computer Science</a></em> (EATCS Bulletin), 81, Oct. 2003, 279-304</li>
<li><a href="Kurt_Gödel" title="wikilink">Kurt Gödel</a>, 1931, "Über formal unentscheidbare Sätze der <em><a href="Principia_Mathematica" title="wikilink">Principia Mathematica</a></em> und verwandter Systeme," <em><a href="Monatshefte_für_Mathematik_und_Physik" title="wikilink">Monatshefte für Mathematik und Physik</a></em> 38: 173-98.</li>
<li>Gold, E.M. Limiting recursion. <em><a href="J._Symb._Logic" title="wikilink">J. Symb. Logic</a></em> 10 (1965), 28-48.</li>
<li></li>
<li>Hagar, A. and Korolev, A. (2007) <a href="http://philsci-archive.pitt.edu/archive/00003180/">"Quantum Hypercomputation – Hype or Computation?"</a></li>
<li>Hintikka, Ja. and Mutanen, A. An Alternative Concept of Computability, in “Language, Truth, and Logic in Mathematics”, Dordrecht, pp. 174–188, 1998</li>
<li>E. J. Horvitz. Reasoning about inference tradeoffs in a world of bounded resources. Technical Report KSL-86-55, Medical Computer Science Group, Section on Medical Informatics, <a href="Stanford_University" title="wikilink">Stanford University</a>, Stanford, CA, March 1986</li>
<li><a href="Juraj_Hromkovič" title="wikilink">Juraj Hromkovič</a>, <em>Design and Analysis of Randomized Algorithms</em>, Springer, 2005</li>
<li>

<p>.</p></li>
<li>Kosovsky, N. K. (1981) <em>Elements of Mathematical Logic and its Application to the theory of Subrecursive Algorithms</em>, <a href="Leningrad_State_University" title="wikilink">Leningrad State University</a> Publ., Leningrad</li>
<li>Peter Kugel, "It's time to think outside the computational box", <em>Communications of the ACM</em>, Volume 48, Issue 11, November 2005</li>
<li>Petrus H. Potgieter, "Zeno machines and hypercomputation", <em>Theoretical Computer Science</em>, Volume 358, Issue 1 (July 2006) pp. 23 – 33</li>
<li>Hilary Putnam, "Trial and Error Predicates and the Solution to a Problem of Mostowski". <em><a href="J._Symbolic_Logic" title="wikilink">J. Symbolic Logic</a></em>, Volume 30, Issue 1 (1965), 49-57</li>
<li>Darko Roglic, "<a href="http://arxiv.org/abs/0708.2686">The universal evolutionary computer based on super-recursive algorithms of evolvability</a>"</li>
<li><a href="Jürgen_Schmidhuber" title="wikilink">J. Schmidhuber</a> (2000): <a href="http://arxiv.org/abs/quant-ph/0011122">"Algorithmic Theories of Everything"</a></li>
<li><a href="Jürgen_Schmidhuber" title="wikilink">J. Schmidhuber</a> (2002): <a class="uri" href="http://www.idsia.ch/~juergen/kolmogorov.html">http://www.idsia.ch/~juergen/kolmogorov.html</a> "Hierarchies of generalized [Kolmogorov] complexities and nonenumerable universal measures computable in the limit". <em><a href="International_Journal_of_Foundations_of_Computer_Science" title="wikilink">International Journal of Foundations of Computer Science</a></em> 13(4):587-612</li>
<li>Hava Siegelmann, <em>Neural Networks and Analog Computation: Beyond the Turing Limit</em>, <a class="uri" href="Birkhäuser" title="wikilink">Birkhäuser</a>, 1999, ISBN 0817639497</li>
<li>Turing, A. (1939) Systems of Logic Based on Ordinals, <em><a href="Proc._Lond._Math._Soc." title="wikilink">Proc. Lond. Math. Soc.</a></em>, Ser.2, v. 45: 161-228</li>
<li><a href="Jan_van_Leeuwen" title="wikilink">van Leeuwen, J.</a> and Wiedermann, J. (2000a) <em>Breaking the Turing Barrier: The case of the Internet</em>, Techn. Report, Inst. of Computer Science, <a href="Academy_of_Sciences_of_the_Czech_Republic" title="wikilink">Academy of Sciences of the Czech Republic</a>, Prague</li>
<li>Jiří Wiedermann, Characterizing the super-Turing computing power and efficiency of classical fuzzy Turing machines, <em>Theoretical Computer Science</em>, Volume 317, Issue 1-3, June 2004</li>
<li>Jiří Wiedermann and <a href="Jan_van_Leeuwen" title="wikilink">Jan van Leeuwen</a>, "The emergent computational potential of evolving artificial living systems", <em>AI Communications</em>, v. 15, No. 4, 2002</li>
<li>Hector Zenil and Francisco Hernandez-Quiroz, On the possible computational power of the human mind, Worldviews, Science and Us, edited by Carlos Gershenson, Diederik Aerts and Bruce Edmonds, <a href="World_Scientific" title="wikilink">World Scientific</a>, 2007, (arXiv:cs.NE/0605065v3)</li>
<li>S. Zilberstein, Using Anytime Algorithms in Intelligent Systems, "AI Magazine", 17(3):73-83, 1996</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.la-acm.org/Archives/laacm9912.html">A New Paradigm for Computation</a>. Los Angeles ACM Chapter Meeting, December 1, 1999.</li>
<li><em><a href="http://foldoc.org/?anytime+algorithm">Anytime algorithm</a></em> from <a class="uri" href="FOLDOC" title="wikilink">FOLDOC</a></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Algorithms" title="wikilink">Category:Algorithms</a> <a class="uri" href="Category:Hypercomputation" title="wikilink">Category:Hypercomputation</a> <a href="Category:Theory_of_computation" title="wikilink">Category:Theory of computation</a></p>
</body>
</html>
