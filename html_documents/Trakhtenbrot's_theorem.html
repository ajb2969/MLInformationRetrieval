<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1227">Trakhtenbrot's theorem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Trakhtenbrot's theorem</h1>
<hr/>

<p>In <a class="uri" href="Logic" title="wikilink">Logic</a>, <a href="finite_model_theory" title="wikilink">finite model theory</a>, and <a href="Computability_Theory" title="wikilink">Computability Theory</a>, <strong>Trakhtenbrot's theorem</strong> (due to <a href="Boris_Trakhtenbrot" title="wikilink">Boris Trakhtenbrot</a>) states that the problem of <a class="uri" href="validity" title="wikilink">validity</a> in <a href="First-order_logic" title="wikilink">First-order logic</a> (FO) on the class of all finite models is <a href="Recursive_set" title="wikilink">undecidable</a>. In fact, the class of valid sentences over finite models is not <a href="recursively_enumerable" title="wikilink">recursively enumerable</a> (though it is <a href="Recursively_enumerable_set#Properties" title="wikilink">co-recursively enumerable</a>).</p>

<p>It is considered a very important result, since it implies that the <a href="Gödel's_completeness_theorem" title="wikilink">completeness theorem</a> (that is fundamental to FO) does not hold in the finite case. Also it seems counter intuitive that being valid over all structures is 'easier' than over just the finite ones.</p>

<p>The Theorem was first published in 1950: "The Impossibility of an Algorithm for the Decidability Problem on Finite Classes".<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="mathematical-formulation">Mathematical Formulation</h2>

<p>We follow the formulations as in <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h3 id="theorem">Theorem</h3>
<dl>
<dd>Finite <a class="uri" href="Satisfiability" title="wikilink">Satisfiability</a> is not decidable in <a href="First-order_logic" title="wikilink">First-order logic</a> (FO).
</dd>
</dl>

<p><strong>Remarks</strong></p>
<ol>
<li>That is, the set { φ | φ is a sentence of FO satisfiable in the finite } is not decidable.</li>
</ol>
<h3 id="corollary">Corollary</h3>

<p>Let σ be a relational vocabulary with one at least binary relation symbol.</p>
<dl>
<dd>The set of <a href="σ-sentence" title="wikilink">σ-sentences</a> valid in all finite structures is not <a href="recursively_enumerable" title="wikilink">recursively enumerable</a>.
</dd>
</dl>

<p><strong>Remarks</strong></p>
<ol>
<li>That is, the set { φ | φ is a sentence of FO[σ] valid in all finite structures } is not <a href="recursively_enumerable" title="wikilink">recursively enumerable</a>.</li>
<li>This implies that <a href="Gödel's_completeness_theorem" title="wikilink">Gödel's completeness theorem</a> fails in the finite. (since completeness implies recursive enumerability)</li>
<li>It follows that there is no recursive function f such that: if Φ has a finite model, then it has a model of size at most f(Φ). In other words, there is no effective analogue to the <a href="Löwenheim-Skolem_theorem" title="wikilink">Löwenheim-Skolem theorem</a> in the finite.</li>
</ol>
<h2 id="alternative-proof">Alternative Proof</h2>

<p>In this section we exhibit an alternative proof from Libkin.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Note in the above statement that the corollary also entails the theorem, and this is the direction we prove here.</p>

<p><strong>Theorem</strong></p>
<dl>
<dd>For every relational vocabulary τ with at least one binary relation symbol, it is undecidable whether a sentence φ of vocabulary τ is finitely satisfiable.
</dd>
</dl>

<p><strong>Proof</strong></p>

<p>According to the previous lemma, we can in fact use finitely many binary relation symbols. The idea of the proof is similar to the proof of Fagin's theorem, and we encode Turing machines in first order logic. What we want to prove is that for every Turing machine M we construct a sentence φ<sub>M</sub> of vocabulary τ such that φ<sub>M</sub> is finitely satisfiable if and only if M halts on the empty input, which is equivalent to the halting problem and therefore undecidable.</p>

<p>Let M= ⟨Q, Σ, δ, q<sub>0</sub>, Q<sub>a</sub>, Q<sub>r</sub>⟩ be a deterministic Turing machine with a single infinite tape.</p>
<ul>
<li>Q is the set of states,</li>
<li>Σ is the input alphabet,</li>
<li>Δ is the tape alphabet,</li>
<li>δ is the transition function,</li>
<li>q<sub>0</sub> is the initial state,</li>
<li>Q<sub>a</sub> and Q<sub>r</sub> are the sets of accepting and rejecting states.</li>
</ul>

<p>Since we are dealing with the problem of halting on an empty input we may assume w.l.o.g. that Δ={0,1} and that 0 represents a blank, while 1 represents some tape symbol. We define τ so that we can represent computations:</p>
<dl>
<dd>τ := {min, T<sub>0</sub> (⋅,⋅), T<sub>1</sub> (⋅,⋅), (H<sub>q</sub>(⋅,⋅))<sub>(q ∈ Q)</sub>}
</dd>
</dl>

<p>Where:</p>
<ul>
<li>min is a constant symbol for the minimal element with respect to &lt; (our finite domain will be associated with an initial segment of the natural numbers).</li>
<li>T<sub>0</sub> and T<sub>1</sub> are tape predicates. T<sub>i</sub>(s,t) indicates that position s at time t contains i, where i ∈ {0,1}.</li>
<li>H<sub>q</sub>'s are head predicates. H<sub>q</sub>(s,t) indicates that at time t the machine is in state q, and its head is in position s.</li>
</ul>

<p>The sentence φ<sub>M</sub> states that (i) min, T<sub>i</sub>'s and H<sub>q</sub>'s are interpreted as above and (ii) that the machine eventually halts. The halting condition is equivalent to saying that H<sub>q∗</sub>(s, t) holds for some s, t and q∗ ∈ Q<sub>a</sub> ∪ Q<sub>r</sub> and after that state, the configuration of the machine does not change. Configurantions of a halting machine (the nonhalting is not finite) can be represented as a τ (finite) sentence (more precisely, a finite τ-structure which satisfies the sentence). The sentence φ<sub>M</sub> is: φ ≡ α ∧ β ∧ γ ∧ η ∧ ζ ∧ θ.</p>

<p>We break it down by components:</p>
<ul>
<li>α states that min is its minimal element</li>
</ul>
<ul>
<li>γ defines the initial configuration of M: it is in state q<sub>0</sub>, the head is in the first position and the tape contains only zeros: γ ≡ H<sub>q<sub>0</sub></sub>(<u>min</u>,<u>min</u>) ∧ ∀s T<sub>0</sub> (s, <u>min</u>)</li>
</ul>
<ul>
<li>η states that in every configuration of M, each tape cell contains exactly one element of Δ: ∀s∀t(T<sub>0</sub>(s, t) → ¬ T<sub>1</sub>(s, t))</li>
</ul>
<ul>
<li>β imposes a basic consistency condition on the predicates H<sub>q</sub>'s: at any time the machine is in exactly one state:</li>
</ul>

<p>

<math display="block" id="Trakhtenbrot's_theorem:0">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mi>t</mi>
     <mrow>
      <mrow>
       <mo>∃</mo>
       <mo lspace="0pt" rspace="3.5pt">!</mo>
      </mrow>
      <mrow>
       <mi>s</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <munder>
          <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋁</mo>
          <mrow>
           <mi>q</mi>
           <mo>∈</mo>
           <mi>Q</mi>
          </mrow>
         </munder>
         <mrow>
          <msub>
           <mi>H</mi>
           <mi>q</mi>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>s</mi>
           <mo>,</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <mi>s</mi>
      <mrow>
       <mo>∃</mo>
       <mrow>
        <mi>t</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mrow>
           <munder>
            <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋁</mo>
            <mrow>
             <mrow>
              <mrow>
               <mi>q</mi>
               <mo>,</mo>
               <msup>
                <mi>q</mi>
                <mo>′</mo>
               </msup>
              </mrow>
              <mo>∈</mo>
              <mi>Q</mi>
             </mrow>
             <mo>,</mo>
             <mrow>
              <mi>q</mi>
              <mo>≠</mo>
              <mi>q</mi>
             </mrow>
            </mrow>
           </munder>
           <mrow>
            <msub>
             <mi>H</mi>
             <mi>q</mi>
            </msub>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>s</mi>
             <mo>,</mo>
             <mi>t</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mrow>
          <mo>∧</mo>
          <mrow>
           <msub>
            <mi>H</mi>
            <msup>
             <mi>q</mi>
             <mo>′</mo>
            </msup>
           </msub>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>s</mi>
            <mo>,</mo>
            <mi>t</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>t</ci>
      <apply>
       <apply>
        <factorial></factorial>
        <exists></exists>
       </apply>
       <apply>
        <times></times>
        <ci>s</ci>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <or></or>
          <apply>
           <in></in>
           <ci>q</ci>
           <ci>Q</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>H</ci>
           <ci>q</ci>
          </apply>
          <interval closure="open">
           <ci>s</ci>
           <ci>t</ci>
          </interval>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <ci>s</ci>
       <apply>
        <exists></exists>
        <apply>
         <times></times>
         <ci>t</ci>
         <apply>
          <and></and>
          <apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <or></or>
            <apply>
             <csymbol cd="ambiguous">formulae-sequence</csymbol>
             <apply>
              <in></in>
              <list>
               <ci>q</ci>
               <apply>
                <csymbol cd="ambiguous">superscript</csymbol>
                <ci>q</ci>
                <ci>normal-′</ci>
               </apply>
              </list>
              <ci>Q</ci>
             </apply>
             <apply>
              <neq></neq>
              <ci>q</ci>
              <ci>q</ci>
             </apply>
            </apply>
           </apply>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>H</ci>
             <ci>q</ci>
            </apply>
            <interval closure="open">
             <ci>s</ci>
             <ci>t</ci>
            </interval>
           </apply>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>H</ci>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <ci>q</ci>
             <ci>normal-′</ci>
            </apply>
           </apply>
           <interval closure="open">
            <ci>s</ci>
            <ci>t</ci>
           </interval>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall t\exists!s(\bigvee_{q\in Q}H_{q}(s,t))\land\neg\exists s\exists t(%
\bigvee_{q,q^{\prime}\in Q,q\neq q}H_{q}(s,t)\land H_{q^{\prime}}(s,t))
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>ζ states that at some point M is in a halting state:</li>
</ul>

<p>

<math display="block" id="Trakhtenbrot's_theorem:1">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mrow>
    <mi>s</mi>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <mi>t</mi>
      <mrow>
       <munder>
        <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋁</mo>
        <mrow>
         <mi>q</mi>
         <mo>∈</mo>
         <mrow>
          <msub>
           <mi>Q</mi>
           <mi>a</mi>
          </msub>
          <mo>∪</mo>
          <msub>
           <mi>Q</mi>
           <mi>r</mi>
          </msub>
         </mrow>
        </mrow>
       </munder>
       <mrow>
        <msub>
         <mi>H</mi>
         <mi>q</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>s</mi>
         <mo>,</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <apply>
     <times></times>
     <ci>s</ci>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <ci>t</ci>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <or></or>
         <apply>
          <in></in>
          <ci>q</ci>
          <apply>
           <union></union>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>Q</ci>
            <ci>a</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>Q</ci>
            <ci>r</ci>
           </apply>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>H</ci>
          <ci>q</ci>
         </apply>
         <interval closure="open">
          <ci>s</ci>
          <ci>t</ci>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists s\exists t\bigvee_{q\in Q_{a}\cup Q_{r}}H_{q}(s,t)
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>θ consists of a conjunction of sentences stating that T<sub>i</sub>'s and H<sub>q</sub>'s are well behaved with respect to the transitions of M. As an example, let δ(q,0)=(q',1, left) meanining that if M is in state q reading 0, then it writes 1, moves the head one position to the left and goes into the state q'. We represent this condition by the disjunction of θ<sub>0</sub> and θ<sub>1</sub>:</li>
</ul>

<p>

<math display="block" id="Trakhtenbrot's_theorem:2">
 <semantics>
  <mrow>
   <msub>
    <mi>θ</mi>
    <mn>0</mn>
   </msub>
   <mo>≡</mo>
   <mo>∀</mo>
   <mi>s</mi>
   <mo>∀</mo>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>≠</mo>
    <munder accentunder="true">
     <mrow>
      <mi>m</mi>
      <mi>i</mi>
      <mi>n</mi>
     </mrow>
     <mo>¯</mo>
    </munder>
    <mo>∧</mo>
    <msub>
     <mi>T</mi>
     <mn>0</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <msub>
     <mi>H</mi>
     <mi>q</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <msub>
    <mi>θ</mi>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <cn type="integer">0</cn>
    </apply>
    <equivalent></equivalent>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <neq></neq>
     <apply>
      <ci>normal-¯</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>i</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <cn type="integer">0</cn>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>q</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <cn type="integer">2</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{0}\equiv\forall s\forall t(s\neq\underline{min}\land T_{0}(s,t)\land H%
_{q}(s,t))\to\theta_{2}
  </annotation>
 </semantics>
</math>

</p>

<p>Where θ<sub>2</sub> is:</p>

<p>

<math display="block" id="Trakhtenbrot's_theorem:3">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo>+</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <msub>
    <mi>H</mi>
    <msup>
     <mi>q</mi>
     <mo>′</mo>
    </msup>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>-</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi>t</mi>
    <mo>+</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mo>∀</mo>
   <msup>
    <mi>s</mi>
    <mo>′</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>≠</mo>
    <msup>
     <mi>s</mi>
     <mo>′</mo>
    </msup>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <munder>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mrow>
        <mn>0</mn>
        <mo>,</mo>
        <mn>1</mn>
       </mrow>
      </mrow>
     </munder>
     <msub>
      <mi>T</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>s</mi>
       <mo>′</mo>
      </msup>
      <mo>,</mo>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>↔</mo>
     <msub>
      <mi>T</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>s</mi>
       <mo>′</mo>
      </msup>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">1</cn>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">t</csymbol>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>q</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <minus></minus>
     <cn type="integer">1</cn>
     <ci>normal-,</ci>
     <csymbol cd="unknown">t</csymbol>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>normal-′</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <neq></neq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <and></and>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <list>
         <cn type="integer">0</cn>
         <cn type="integer">1</cn>
        </list>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <ci>i</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>s</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>normal-,</ci>
       <csymbol cd="unknown">t</csymbol>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-↔</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <ci>i</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>s</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>normal-,</ci>
       <csymbol cd="unknown">t</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{1}(s,t+1)\land H_{q^{\prime}}(s-1,t+1)\land\forall s^{\prime}(s\neq s^{%
\prime}\to(\bigwedge_{i=0,1}T_{i}(s^{\prime},t+1)\leftrightarrow T_{i}(s^{%
\prime},t)))
  </annotation>
 </semantics>
</math>

</p>

<p>And:</p>

<p>

<math display="block" id="Trakhtenbrot's_theorem:4">
 <semantics>
  <mrow>
   <msub>
    <mi>θ</mi>
    <mn>1</mn>
   </msub>
   <mo>≡</mo>
   <mo>∀</mo>
   <mi>s</mi>
   <mo>∀</mo>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>=</mo>
    <munder accentunder="true">
     <mrow>
      <mi>m</mi>
      <mi>i</mi>
      <mi>n</mi>
     </mrow>
     <mo>¯</mo>
    </munder>
    <mo>∧</mo>
    <msub>
     <mi>T</mi>
     <mn>0</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <msub>
     <mi>H</mi>
     <mi>q</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>s</mi>
     <mo>,</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <msub>
    <mi>θ</mi>
    <mn>3</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <cn type="integer">1</cn>
    </apply>
    <equivalent></equivalent>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <eq></eq>
     <apply>
      <ci>normal-¯</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>i</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <cn type="integer">0</cn>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <ci>q</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <cn type="integer">3</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{1}\equiv\forall s\forall t(s=\underline{min}\land T_{0}(s,t)\land H_{q%
}(s,t))\to\theta_{3}
  </annotation>
 </semantics>
</math>

</p>

<p>Where θ<sub>3</sub> is:</p>

<p>

<math display="inline" id="Trakhtenbrot's_theorem:5">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo>+</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <msub>
    <mi>H</mi>
    <msup>
     <mi>q</mi>
     <mo>′</mo>
    </msup>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo>+</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mo>∀</mo>
   <msup>
    <mi>s</mi>
    <mo>′</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>≠</mo>
    <msup>
     <mi>s</mi>
     <mo>′</mo>
    </msup>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋀</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mrow>
        <mn>0</mn>
        <mo>,</mo>
        <mn>1</mn>
       </mrow>
      </mrow>
     </msub>
     <msub>
      <mi>T</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>s</mi>
       <mo>′</mo>
      </msup>
      <mo>,</mo>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>↔</mo>
     <msub>
      <mi>T</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>s</mi>
       <mo>′</mo>
      </msup>
      <mo>,</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">1</cn>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">t</csymbol>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>q</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">t</csymbol>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>normal-′</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">s</csymbol>
     <neq></neq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <and></and>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <list>
         <cn type="integer">0</cn>
         <cn type="integer">1</cn>
        </list>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <ci>i</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>s</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>normal-,</ci>
       <csymbol cd="unknown">t</csymbol>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-↔</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <ci>i</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>s</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>normal-,</ci>
       <csymbol cd="unknown">t</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{1}(s,t+1)\land H_{q^{\prime}}(s,t+1)\land\forall s^{\prime}(s\neq s^{\prime%
}\to(\bigwedge_{i=0,1}T_{i}(s^{\prime},t+1)\leftrightarrow T_{i}(s^{\prime},t)))
  </annotation>
 </semantics>
</math>

</p>

<p>s-1 and t+1 are first order definable abbreviations for the predecessor and successor according to the ordering &lt;. sentence="" the=""&gt;0 assures that the tape content in position s changes from 0 to 1, the state changes from q to q', the rest of the tape remains the same and that the head moves to s-1 (i. e. one position to the left), assuming s is not the first position in the tape. If it is, then all is handled by θ<sub>1</sub>: everything is the same, except the head does not move to the left but stays put.<!--.--></p>

<p>If φ<sub>M</sub> has a finite model, then such a model that represents a computation of M (that starts with the empty tape (i.e. tape containing all zeros) and ends in a halting state). If M halts on the empty input, then the set of all configurations of the halting computations of M (coded with i's and H<sub>q</sub>'s) is a model of φ<sub>M</sub>, which is finite, since the set of all configurations of halting computations is finite. It follows that M halts on the empty input iff φ<sub>M</sub> has a finite model. Since halting on the empty input is undecidable, so is the question of whether φ<sub>M</sub> has a finite model 

<math display="inline" id="Trakhtenbrot's_theorem:6">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 (equivalently, whether φ<sub>M</sub> is finitely satisfiable) is also undecidable (recursively enumerable, but not recursive). This concludes the proof.</p>

<p><strong>Corollary</strong></p>
<dl>
<dd>The set of finitely satisfiable sentences is recursively enumerable.
</dd>
</dl>

<p><strong>Proof</strong></p>

<p>Enumerate all pairs 

<math display="inline" id="Trakhtenbrot's_theorem:7">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mo>,</mo>
   <mi>ϕ</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>𝒜</ci>
    <ci>ϕ</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathcal{A},\phi)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Trakhtenbrot's_theorem:8">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒜</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒜</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>


 is finite and 

<math display="inline" id="Trakhtenbrot's_theorem:9">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒜</mi>
   <mo>⊧</mo>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">models</csymbol>
    <ci>𝒜</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}\models\phi
  </annotation>
 </semantics>
</math>

.</p>

<p><strong>Corollary</strong></p>
<dl>
<dd>For any vocabulary containing at least one binary relation symbol, the set of all finitely valid sentences is not recursively enumerable.
</dd>
</dl>

<p><strong>Proof</strong></p>

<p>From the previous lemma, the set of finitely satisfiable sentences is recursively enumerable. Assume that the set of all finitely valid sentences is recursively enumerable. Since ¬φ is finitely valid iff φ is not finitely satisfiable, we conclude that the set of sentences which are not finitely satisfiable is recursively enumerable. If both a set A and its complement are recursively enumerable, then A is recursive. It follows that the set of finitely satisfiable sentences is recursive, which contradicts Trakhtenbrot's theorem.</p>
<h2 id="references">References</h2>
<references>
</references>
<ul>
<li>Boolos, Burgess, Jeffrey. <em>Computability and Logic</em>, Cambridge University Press, 2002.</li>
<li>Simpson, S. "Theorems of Church and Trakhtenbrot". 2001.<a href="http://www.math.psu.edu/simpson/courses/math457/trakh.pdf">1</a></li>
</ul>

<p>"</p>

<p><a href="Category:Finite_model_theory" title="wikilink">Category:Finite model theory</a> <a href="Category:Computability_theory" title="wikilink">Category:Computability theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
