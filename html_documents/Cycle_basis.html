<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1138">Cycle basis</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Cycle basis</h1>
<hr/>

<p> In <a href="graph_theory" title="wikilink">graph theory</a>, a branch of mathematics, a <strong>cycle basis</strong> of an <a href="undirected_graph" title="wikilink">undirected graph</a> is a set of <a href="simple_cycle" title="wikilink">simple cycles</a> that forms a <a href="Basis_(linear_algebra)" title="wikilink">basis</a> of the <a href="cycle_space" title="wikilink">cycle space</a> of the graph. That is, it is a minimal set of cycles that allows every <a href="Eulerian_path" title="wikilink">Eulerian</a> subgraph to be expressed as a <a href="symmetric_difference" title="wikilink">symmetric difference</a> of basis cycles.</p>

<p>A <strong>fundamental cycle basis</strong> may be formed from any <a href="spanning_tree" title="wikilink">spanning tree</a> or spanning <a href="forest_(graph_theory)" title="wikilink">forest</a> of the given graph, by selecting the cycles formed by the combination of a path in the tree and a single edge outside the tree. Alternatively, if the edges of the graph have positive weights, the <strong>minimum weight cycle basis</strong> may be constructed in <a href="polynomial_time" title="wikilink">polynomial time</a>.</p>

<p>In <a href="planar_graph" title="wikilink">planar graphs</a>, the set of bounded cycles of an embedding of the graph forms a cycle basis. The minimum weight cycle basis of a <a href="planar_graph" title="wikilink">planar graph</a> corresponds to the <a href="Gomory–Hu_tree" title="wikilink">Gomory–Hu tree</a> of the <a href="dual_graph" title="wikilink">dual graph</a>.</p>
<h2 id="definitions">Definitions</h2>

<p>A <a href="Glossary_of_graph_theory#Subgraphs" title="wikilink">spanning subgraph</a> of a given graph <em>G</em> has the same set of <a href="Vertex_(graph_theory)" title="wikilink">vertices</a> as <em>G</em> itself but, possibly, fewer edges. A graph <em>G</em>, or one of its subgraphs, is said to be <a href="Eulerian_graph" title="wikilink">Eulerian</a> if each of its vertices has even <a href="Degree_(graph_theory)" title="wikilink">degree</a> (its number of incident edges). Every simple cycle in a graph is an Eulerian subgraph, but there may be others. The <a href="cycle_space" title="wikilink">cycle space</a> of a graph is the collection of its Eulerian subgraphs. It forms a <a href="vector_space" title="wikilink">vector space</a> over the two-element <a href="finite_field" title="wikilink">finite field</a>. The vector addition operation is the <a href="symmetric_difference" title="wikilink">symmetric difference</a> of two or more subgraphs, which forms another subgraph consisting of the edges that appear an odd number of times in the arguments to the symmetric difference operation.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>A cycle basis is a basis of this vector space in which each basis vector represents a simple cycle. It consists of a set of cycles that can be combined, using symmetric differences, to form every Eulerian subgraph, and that is minimal with this property. Every cycle basis of a given graph has the same number of cycles, which equals the dimension of its cycle space. This number is called the <a href="circuit_rank" title="wikilink">circuit rank</a> of the graph, and it equals 

<math display="inline" id="Cycle_basis:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>m</mi>
    <mo>-</mo>
    <mi>n</mi>
   </mrow>
   <mo>+</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <minus></minus>
     <ci>m</ci>
     <ci>n</ci>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m-n+c
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Cycle_basis:1">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 is the number of edges in the graph, 

<math display="inline" id="Cycle_basis:2">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is the number of vertices, and 

<math display="inline" id="Cycle_basis:3">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>


 is the number of <a href="Connected_component_(graph_theory)" title="wikilink">connected components</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="special-cycle-bases">Special cycle bases</h2>

<p>Several special types of cycle bases have been studied, including the fundamental cycle bases, weakly fundamental cycle bases, sparse (or 2-) cycle bases, and integral cycle bases.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h3 id="induced-cycles">Induced cycles</h3>

<p>Every graph has a cycle basis in which every cycle is an <a href="induced_cycle" title="wikilink">induced cycle</a>. In a <a href="k-vertex-connected_graph" title="wikilink">3-vertex-connected graph</a>, there always exists a basis consisting of <a href="peripheral_cycle" title="wikilink">peripheral cycles</a>, cycles whose removal does not separate the remaining graph.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> In any graph other than one formed by adding one edge to a cycle, a peripheral cycle must be an induced cycle.</p>
<h3 id="fundamental-cycles">Fundamental cycles</h3>

<p>If 

<math display="inline" id="Cycle_basis:4">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 is a <a href="spanning_tree" title="wikilink">spanning tree</a> or spanning forest of a given graph 

<math display="inline" id="Cycle_basis:5">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Cycle_basis:6">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 is an edge that does not belong to 

<math display="inline" id="Cycle_basis:7">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

, then the fundamental cycle 

<math display="inline" id="Cycle_basis:8">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>e</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{e}
  </annotation>
 </semantics>
</math>


 defined by 

<math display="inline" id="Cycle_basis:9">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 is the simple cycle consisting of 

<math display="inline" id="Cycle_basis:10">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 together with the path in 

<math display="inline" id="Cycle_basis:11">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 connecting the endpoints of 

<math display="inline" id="Cycle_basis:12">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

. There are exactly 

<math display="inline" id="Cycle_basis:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>m</mi>
    <mo>-</mo>
    <mi>n</mi>
   </mrow>
   <mo>+</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <minus></minus>
     <ci>m</ci>
     <ci>n</ci>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m-n+c
  </annotation>
 </semantics>
</math>


 fundamental cycles, one for each edge that does not belong to 

<math display="inline" id="Cycle_basis:14">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

. Each of them is <a href="linear_independence" title="wikilink">linearly independent</a> from the remaining cycles, because it includes an edge 

<math display="inline" id="Cycle_basis:15">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e
  </annotation>
 </semantics>
</math>

 that is not present in any other fundamental cycle. Therefore, the fundamental cycles form a basis for the cycle space.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> A cycle basis constructed in this way is called a <strong>fundamental cycle basis</strong> or <strong>strongly fundamental cycle basis</strong>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>It is also possible to characterize fundamental cycle bases without specifying the tree for which they are fundamental. There exists a tree for which a given cycle basis is fundamental if and only if each cycle contains an edge that is not included in any other basis cycle. It follows that a collection of cycles is a fundamental cycle basis if and only if it has the same property and has the correct number of cycles to be a basis.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h3 id="weakly-fundamental-cycles">Weakly fundamental cycles</h3>

<p>A cycle basis is called <strong>weakly fundamental</strong> if its cycles can be placed into a linear ordering such that each cycle includes at least one edge that is not included in any earlier cycle. A fundamental cycle basis is automatically weakly fundamental (for any edge ordering).<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> If every cycle basis of a graph is weakly fundamental, the same is true for every <a href="graph_minor" title="wikilink">minor</a> of the graph. Based on this property, the class of graphs (and <a href="multigraph" title="wikilink">multigraphs</a>) for which every cycle basis is weakly fundamental can be characterized by five <a href="Forbidden_graph_characterization" title="wikilink">forbidden minors</a>: the graph of the <a href="square_pyramid" title="wikilink">square pyramid</a>, the multigraph formed by doubling all edges of a four-vertex cycle, two multigraphs formed by doubling two edges of a <a class="uri" href="tetrahedron" title="wikilink">tetrahedron</a>, and the multigraph formed by tripling the edges of a triangle.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h3 id="face-cycles">Face cycles</h3>

<p>If a connected finite <a href="planar_graph" title="wikilink">planar graph</a> is embedded into the plane, each face of the embedding is bounded by a cycle of edges. One face is necessarily <a href="Bounded_set" title="wikilink">unbounded</a> (it includes points arbitrarily far from the vertices of the graph) and the remaining faces are bounded. By <a href="Euler_characteristic" title="wikilink">Euler's formula for planar graphs</a>, there are exactly 

<math display="inline" id="Cycle_basis:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>m</mi>
    <mo>-</mo>
    <mi>n</mi>
   </mrow>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <minus></minus>
     <ci>m</ci>
     <ci>n</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m-n+1
  </annotation>
 </semantics>
</math>

 bounded faces. The symmetric difference of any set of face cycles is the boundary of the corresponding set of faces, and different sets of bounded faces have different boundaries, so it is not possible to represent the same set as a symmetric difference of face cycles in more than one way; this means that the set of face cycles is linearly independent. As a linearly independent set of enough cycles, it necessarily forms a cycle basis.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> It is always a weakly fundamental cycle basis, and is fundamental if and only if the embedding of the graph is <a href="outerplanar_graph" title="wikilink">outerplanar</a>.</p>

<p>For graphs properly embedded onto other surfaces so that all faces of the embedding are topological disks, it is not in general true that there exists a cycle basis using only face cycles. The face cycles of these embeddings generate a proper subset of all Eulerian subgraphs. The <a href="homology_group" title="wikilink">homology group</a> 

<math display="inline" id="Cycle_basis:17">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>,</mo>
    <msub>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\Z</mtext>
     </merror>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">2</cn>
    </apply>
    <interval closure="open">
     <ci>S</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>\Z</mtext>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{2}(S,\Z_{2})
  </annotation>
 </semantics>
</math>

 of the given surface 

<math display="inline" id="Cycle_basis:18">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>


 characterizes the Eulerian subgraphs that cannot be represented as the boundary of a set of faces. <a href="Mac_Lane's_planarity_criterion" title="wikilink">Mac Lane's planarity criterion</a> uses this idea to characterize the planar graphs in terms of the cycle bases: a finite undirected graph is planar if and only if it has a <strong>sparse cycle basis</strong> or <strong>2-basis</strong>,<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> a basis in which each edge of the graph participates in at most two basis cycles. In a planar graph, the cycle basis formed by the set of bounded faces is necessarily sparse, and conversely, a sparse cycle basis of any graph necessarily forms the set of bounded faces of a planar embedding of its graph.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<h3 id="integral-bases">Integral bases</h3>

<p>The cycle space of a graph may be interpreted using the theory of <a href="homology_(mathematics)" title="wikilink">homology</a> as the <a href="homology_group" title="wikilink">homology group</a> 

<math display="inline" id="Cycle_basis:19">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mo>,</mo>
    <msub>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\Z</mtext>
     </merror>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">1</cn>
    </apply>
    <interval closure="open">
     <ci>G</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>\Z</mtext>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}(G,\Z_{2})
  </annotation>
 </semantics>
</math>

 of a <a href="simplicial_complex" title="wikilink">simplicial complex</a> with a point for each vertex of the graph and a line segment for each edge of the graph. This construction may be generalized to the homology group 

<math display="inline" id="Cycle_basis:20">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mo>,</mo>
    <mi>R</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">1</cn>
    </apply>
    <interval closure="open">
     <ci>G</ci>
     <ci>R</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}(G,R)
  </annotation>
 </semantics>
</math>

 over an arbitrary <a href="ring_(mathematics)" title="wikilink">ring</a> 

<math display="inline" id="Cycle_basis:21">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

. An important special case is the ring of <a href="integer" title="wikilink">integers</a>, for which the homology group 

<math display="inline" id="Cycle_basis:22">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mo>,</mo>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\Z</mtext>
    </merror>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">1</cn>
    </apply>
    <interval closure="open">
     <ci>G</ci>
     <mtext>\Z</mtext>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}(G,\Z)
  </annotation>
 </semantics>
</math>

 is a <a href="free_abelian_group" title="wikilink">free abelian group</a>, a subgroup of the free abelian group generated by the edges of the graph. Less abstractly, this group can be constructed by assigning an arbitrary <a href="orientation_(graph_theory)" title="wikilink">orientation</a> to the edges of the given graph; then the elements of 

<math display="inline" id="Cycle_basis:23">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mn>1</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>G</mi>
    <mo>,</mo>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\Z</mtext>
    </merror>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">1</cn>
    </apply>
    <interval closure="open">
     <ci>G</ci>
     <mtext>\Z</mtext>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{1}(G,\Z)
  </annotation>
 </semantics>
</math>


 are labelings of the edges of the graph by integers with the property that, at each vertex, the sum of the incoming edge labels equals the sum of the outgoing edge labels. The group operation is addition of these vectors of labels. An <strong>integral cycle basis</strong> is a set of simple cycles that generates this group.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<h2 id="minimum-weight">Minimum weight</h2>

<p>If the edges of a graph are given real number weights, the weight of a subgraph may be computed as the sum of the weights of its edges. The minimum weight basis of the cycle space is necessarily a cycle basis: by <a href="Veblen's_theorem" title="wikilink">Veblen's theorem</a>,<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> every Eulerian subgraph that is not itself a simple cycle can be decomposed into multiple simple cycles, which necessarily have smaller weight.</p>

<p>By standard properties of bases in vector spaces and matroids, the minimum weight cycle basis not only minimizes the sum of the weights of its cycles, it also minimizes any other monotonic combination of the cycle weights. For instance, it is the cycle basis that minimizes the weight of its longest cycle.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>
<h3 id="polynomial-time-algorithms">Polynomial time algorithms</h3>

<p>In any vector space, and more generally in any <a class="uri" href="matroid" title="wikilink">matroid</a>, a minimum weight basis may be found by a <a href="greedy_algorithm" title="wikilink">greedy algorithm</a> that considers potential basis elements one at a time, in sorted order by their weights, and that includes an element in the basis when it is linearly independent of the previously chosen basis elements. Testing for linear independence can be done by <a href="Gaussian_elimination" title="wikilink">Gaussian elimination</a>. However, an undirected graph may have an exponentially large set of simple cycles, so it would be computationally infeasible to generate and test all such cycles.</p>

<p>provided the first <a href="polynomial_time" title="wikilink">polynomial time</a> algorithm for finding a minimum weight basis, in graphs for which every edge weight is positive. His algorithm uses this generate-and-test approach, but restricts the generated cycles to a small set of 

<math display="inline" id="Cycle_basis:24">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>m</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(mn)
  </annotation>
 </semantics>
</math>

 cycles, called <em>Horton cycles</em>. A Horton cycle is a fundamental cycle of a <a href="shortest_path_tree" title="wikilink">shortest path tree</a> of the given graph. There are <em>n</em> different shortest path trees (one for each starting vertex) and each has fewer than <em>m</em> fundamental cycles, giving the bound on the total number of Horton cycles. As Horton showed, every cycle in the minimum weight cycle basis is a Horton cycle.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> Using <a href="Dijkstra's_algorithm" title="wikilink">Dijkstra's algorithm</a> to find each shortest path tree and then using Gaussian elimination to perform the testing steps of the greedy basis algorithm leads to a polynomial time algorithm for the minimum weight cycle basis. Subsequent researchers have developed improved algorithms for this problem,<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a><a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a><a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a><a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> reducing the <a href="Best,_worst_and_average_case" title="wikilink">worst-case time complexity</a> for finding a minimum weight cycle basis in a graph with 

<math display="inline" id="Cycle_basis:25">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 edges and 

<math display="inline" id="Cycle_basis:26">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 vertices to 

<math display="inline" id="Cycle_basis:27">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>m</mi>
       <mn>2</mn>
      </msup>
      <mi>n</mi>
     </mrow>
     <mo>/</mo>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>m</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(m^{2}n/\log n)
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></p>
<h3 id="np-hardness">NP-hardness</h3>

<p>Finding the fundamental basis with the minimum possible weight is closely related to the problem of finding a spanning tree that minimizes the average of the pairwise distances; both are <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> Finding a minimum weight weakly fundamental basis is also NP-hard,<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> and <a href="approximation_algorithm" title="wikilink">approximating</a> it is <a href="SNP_(complexity)" title="wikilink">MAXSNP-hard</a>.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> If negative weights and negatively weighted cycles are allowed, then finding a minimum cycle basis (without restriction) is also NP-hard, as it can be used to find a <a href="Hamiltonian_cycle" title="wikilink">Hamiltonian cycle</a>: if a graph is Hamiltonian, and all edges are given weight −1, then a minimum weight cycle basis necessarily includes at least one Hamiltonian cycle.</p>
<h3 id="in-planar-graphs">In planar graphs</h3>

<p>The minimum weight cycle basis for a planar graph is not necessarily the same as the basis formed by its bounded faces: it can include cycles that are not faces, and some faces may not be included as cycles in the minimum weight cycle basis. However, there exists a minimum weight cycle basis in which no two cycles cross each other: for every two cycles in the basis, either the cycles enclose disjoint subsets of the bounded faces, or one of the two cycles encloses the other one. This set of cycles corresponds, in the <a href="dual_graph" title="wikilink">dual graph</a> of the given planar graph, to a set of <a href="Cut_(graph_theory)" title="wikilink">cuts</a> that form a <a href="Gomory–Hu_tree" title="wikilink">Gomory–Hu tree</a> of the dual graph, the minimum weight basis of its <a href="cut_space" title="wikilink">cut space</a>.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> Based on this duality, an implicit representation of the minimum weight cycle basis in a planar graph can be constructed in time 

<math display="inline" id="Cycle_basis:28">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <msup>
       <mi>log</mi>
       <mn>4</mn>
      </msup>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <log></log>
       <cn type="integer">4</cn>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n\log^{4}n)
  </annotation>
 </semantics>
</math>


.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a></p>
<h2 id="applications">Applications</h2>

<p>Cycle bases have been used for solving periodic scheduling problems, such as the problem of determining the schedule for a public transportation system. In this application, the cycles of a cycle basis correspond to variables in an <a href="integer_program" title="wikilink">integer program</a> for solving the problem.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p>

<p>In the theory of <a href="structural_rigidity" title="wikilink">structural rigidity</a> and <a class="uri" href="kinematics" title="wikilink">kinematics</a>, cycle bases are used to guide the process of setting up a system of non-redundant equations that can be solved to predict the rigidity or motion of a structure. In this application, minimum or near-minimum weight cycle bases lead to simpler systems of equations.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a></p>

<p>In <a href="distributed_computing" title="wikilink">distributed computing</a>, cycle bases have been used to analyze the number of steps needed for an algorithm to stabilize.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></p>

<p>In <a class="uri" href="bioinformatics" title="wikilink">bioinformatics</a>, cycle bases have been used to determine <a class="uri" href="haplotype" title="wikilink">haplotype</a> information from genome sequence data.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> Cycle bases have also been used to analyze the <a href="Nucleic_acid_tertiary_structure" title="wikilink">tertiary structure</a> of <a class="uri" href="RNA" title="wikilink">RNA</a>.<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a></p>

<p>The minimum weight cycle basis of a <a href="nearest_neighbor_graph" title="wikilink">nearest neighbor graph</a> of points sampled from a three-dimensional surface can be used to obtain a reconstruction of the surface.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Algebraic_graph_theory" title="wikilink">Category:Algebraic graph theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">.<a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3">.<a href="#fnref3">↩</a></li>
<li id="fn4">, pp. 32, 65.<a href="#fnref4">↩</a></li>
<li id="fn5">. See in particular Theorem 2.5.<a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"></li>
<li id="fn9">.<a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11">.<a href="#fnref11">↩</a></li>
<li id="fn12">.<a href="#fnref12">↩</a></li>
<li id="fn13">, pp. 105–106.<a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16">.<a href="#fnref16">↩</a></li>
<li id="fn17"></li>
<li id="fn18">.<a href="#fnref18">↩</a></li>
<li id="fn19">.<a href="#fnref19">↩</a></li>
<li id="fn20">.<a href="#fnref20">↩</a></li>
<li id="fn21">.<a href="#fnref21">↩</a></li>
<li id="fn22">.<a href="#fnref22">↩</a></li>
<li id="fn23">.<a href="#fnref23">↩</a></li>
<li id="fn24">.<a href="#fnref24">↩</a></li>
<li id="fn25">.<a href="#fnref25">↩</a></li>
<li id="fn26">.<a href="#fnref26">↩</a></li>
<li id="fn27"></li>
<li id="fn28">.<a href="#fnref28">↩</a></li>
<li id="fn29">.<a href="#fnref29">↩</a></li>
<li id="fn30">.<a href="#fnref30">↩</a></li>
<li id="fn31">.<a href="#fnref31">↩</a></li>
<li id="fn32">.<a href="#fnref32">↩</a></li>
<li id="fn33">.<a href="#fnref33">↩</a></li>
<li id="fn34">.<a href="#fnref34">↩</a></li>
<li id="fn35">.<a href="#fnref35">↩</a></li>
<li id="fn36">.<a href="#fnref36">↩</a></li>
</ol>
</section>
</body>
</html>
