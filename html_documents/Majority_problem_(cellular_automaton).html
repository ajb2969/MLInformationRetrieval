<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1026">Majority problem (cellular automaton)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Majority problem (cellular automaton)</h1>
<hr/>

<p>The <strong>majority problem</strong>, or <strong>density classification task</strong> is the problem of finding one-dimensional <a href="cellular_automaton" title="wikilink">cellular automaton</a> rules that accurately perform <a href="majority_function" title="wikilink">majority voting</a>.</p>

<p>Using local transition rules, cells cannot know the total count of all the ones in system. In order to count the number of ones (or, by symmetry, the number of zeros), the system requires a logarithmic number of bits in the total size of the system. It also requires the system send messages over a distance linear in the size of the system and for the system to recognize a non-<a href="regular_language" title="wikilink">regular language</a>. Thus, this problem is an important test case in measuring the computational power of cellular automaton systems.</p>
<h2 id="problem-statement">Problem statement</h2>

<p>Given a configuration of a two-state cellular automata with <em>i</em> + <em>j</em> cells total, <em>i</em> of which are in the zero state and <em>j</em> of which are in the one state, a correct solution to the voting problem must eventually set all cells to zero if <em>i</em> &gt; <em>j</em> and must eventually set all cells to one if <em>i</em> \rho; a correct solution to the voting problem must eventually set all cells to zero if 

<math display="inline" id="Majority_problem_(cellular_automaton):0">
 <semantics>
  <mrow>
   <mfrac>
    <mi>j</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mi>j</mi>
    </mrow>
   </mfrac>
   <mo><</mo>
   <mi>ρ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <divide></divide>
     <ci>j</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <ci>ρ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{j}{i+j}<\rho
  </annotation>
 </semantics>
</math>

 and must eventually set all cells to one if 

<math display="inline" id="Majority_problem_(cellular_automaton):1">
 <semantics>
  <mrow>
   <mfrac>
    <mi>j</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mi>j</mi>
    </mrow>
   </mfrac>
   <mo>></mo>
   <mi>ρ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <divide></divide>
     <ci>j</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <ci>ρ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{j}{i+j}>\rho
  </annotation>
 </semantics>
</math>

. The desired eventual state is unspecified if 

<math display="inline" id="Majority_problem_(cellular_automaton):2">
 <semantics>
  <mrow>
   <mfrac>
    <mi>j</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mi>j</mi>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mi>ρ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>j</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <ci>ρ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{j}{i+j}=\rho
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="approximate-solutions">Approximate solutions</h2>

<p>Gács, Kurdyumov, and <a href="Leonid_Levin" title="wikilink">Levin</a> found an automaton that, although it does not always solve the majority problem correctly, does so in many cases.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> In their approach to the problem, the quality of a cellular automaton rule is measured by the fraction of the 

<math display="inline" id="Majority_problem_(cellular_automaton):3">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi>i</mi>
    <mo>+</mo>
    <mi>j</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <plus></plus>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{i+j}
  </annotation>
 </semantics>
</math>

 possible starting configurations that it correctly classifies.</p>

<p>The rule proposed by Gacs, Kurdyumov, and Levin sets the state of each cell as follows. If a cell is 0, its next state is formed as the majority among the values of itself, its immediate neighbor to the left, and its neighbor three spaces to the left. If, on the other hand, a cell is 1, its next state is formed symmetrically, as the majority among the values of itself, its immediate neighbor to the right, and its neighbor three spaces to the right. In randomly generated instances, this achieves about 78% accuracy in correctly determining the majority.</p>

<p>Das, <a href="Melanie_Mitchell" title="wikilink">Mitchell</a>, and Crutchfield showed that it is possible to develop better rules using <a href="genetic_algorithm" title="wikilink">genetic algorithms</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="impossibility-of-a-perfect-classifier">Impossibility of a perfect classifier</h2>

<p>In 1995, Land and Belew<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> showed that no two-state rule with radius <em>r</em> and density ρ correctly solves the voting problem on all starting configurations when the number of cells is sufficiently large (larger than about 4<em>r</em>/ρ).</p>

<p>Their argument shows that because the system is <a href="Deterministic_algorithm" title="wikilink">deterministic</a>, every cell surrounded entirely by zeros or ones must then become a zero. Likewise, any perfect rule can never make the ratio of ones go above 

<math display="inline" id="Majority_problem_(cellular_automaton):4">
 <semantics>
  <mi>ρ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ρ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

 if it was below (or vice versa). They then show that any assumed perfect rule will either cause an isolated one that pushed the ratio over 

<math display="inline" id="Majority_problem_(cellular_automaton):5">
 <semantics>
  <mi>ρ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ρ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

 to be cancelled out or, if the ratio of ones is less than 

<math display="inline" id="Majority_problem_(cellular_automaton):6">
 <semantics>
  <mi>ρ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ρ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

, will cause an isolated one to introduce spurious ones into a block of zeros causing the ratio of ones to be become greater than 

<math display="inline" id="Majority_problem_(cellular_automaton):7">
 <semantics>
  <mi>ρ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ρ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="exact-solution-with-alternative-termination-conditions">Exact solution with alternative termination conditions</h2>

<p>As observed by Capcarrere, Sipper, and Tomassini,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> the majority problem may be solved perfectly if one relaxes the definition by which the automaton is said to have recognized the majority. In particular, for the <a href="Rule_184" title="wikilink">Rule 184</a> automaton, when run on a finite universe with <a href="periodic_boundary_conditions" title="wikilink">cyclic boundary conditions</a>, each cell will infinitely often remain in the majority state for two consecutive steps while only finitely many times being in the minority state for two consecutive steps.</p>

<p>Alternatively, a hybrid automaton that runs Rule 184 for a number of steps linear in the size of the array, and then switches to the majority rule (Rule 232), that sets each cell to the majority of itself and its neighbors, solves the majority problem with the standard recognition criterion of either all zeros or all ones in the final state. However, this machine is not itself a cellular automaton.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Moreover, it has been shown that Fukś´ composite rule is very sensitive to noise and cannot outperform the noisy Gacs-Kurdyumov-Levin automaton, an imperfect classifier, for any level of noise (e.g., from the environment or from dynamical mistakes).<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Cellular_automata" title="wikilink">Category:Cellular automata</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
