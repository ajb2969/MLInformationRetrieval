<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1548">Randomized algorithms as zero-sum games</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Randomized algorithms as zero-sum games</h1>
<hr/>

<p><a href="Randomized_algorithms" title="wikilink">Randomized algorithms</a> are algorithms that employ a degree of randomness as part of their logic. These algorithms can be used to give good <a href="average_case_complexity" title="wikilink">average-case</a> results (complexity-wise) to problems which are hard to solve deterministically, or display poor <a class="uri" href="worst-case" title="wikilink">worst-case</a> complexity. An algorithmic <a href="game_theory" title="wikilink">game theoretic</a> approach can help explain why in the average case randomized algorithms may work better than deterministic algorithms.</p>
<h2 id="formalizing-the-game">Formalizing the game</h2>

<p>Consider a <a href="zero-sum_game" title="wikilink">zero-sum game</a> between player A, whose <a href="strategy_(game_theory)" title="wikilink">strategies</a> are deterministic algorithms, and player B, who’s strategies are inputs for A’s algorithms. The cost of a strategy profile is the running time of A’s chosen algorithm on B’s chosen input. Therefore, player A tries to minimize the cost, and player B tries to maximize it. In the world of pure strategies, for every algorithm that A chooses, B may choose the most costly input – this is the worst-case scenario, and can be found using standard <a href="complexity_analysis" title="wikilink">complexity analysis</a>.</p>

<p>But in the real world, inputs are normally not selected by an ‘evil opponent’ – rather, they come from some distribution over inputs. Since this is the case, if we allow the algorithms to also be drawn from some distribution, we may look at the game as one that allows <a href="mixed_strategy" title="wikilink">mixed strategies</a>. That is, each player chooses a distribution over its strategies.</p>
<h2 id="analysis">Analysis</h2>

<p>Incorporating mixed strategies into the game allows us to use <a href="John_von_Neumann" title="wikilink">von Neumann's</a> <a class="uri" href="minimax" title="wikilink">minimax</a> theorem:</p>

<p>

<math display="block" id="Randomized_algorithms_as_zero-sum_games:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <munder>
      <mi>min</mi>
      <mi>R</mi>
     </munder>
     <mrow>
      <munder>
       <mi>max</mi>
       <mi>D</mi>
      </munder>
      <mi>T</mi>
     </mrow>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>,</mo>
     <mi>D</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <munder>
      <mi>max</mi>
      <mi>D</mi>
     </munder>
     <mrow>
      <munder>
       <mi>min</mi>
       <mi>A</mi>
      </munder>
      <mi>T</mi>
     </mrow>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>,</mo>
     <mi>D</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <min></min>
       <ci>R</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <max></max>
        <ci>D</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <interval closure="open">
      <ci>A</ci>
      <ci>D</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <max></max>
       <ci>D</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <min></min>
        <ci>A</ci>
       </apply>
       <ci>T</ci>
      </apply>
     </apply>
     <interval closure="open">
      <ci>A</ci>
      <ci>D</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min_{R}\max_{D}T(A,D)=\max_{D}\min_{A}T(A,D)\,
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>R</em> is a distribution over the algorithms, <em>D</em> is a distribution over inputs, <em>A</em> is a single deterministic algorithm, and <em>T</em>(<em>A</em>, <em>D</em>) is the average running time of algorithm a on input <em>D</em>. More specifically:</p>

<p>

<math display="block" id="Randomized_algorithms_as_zero-sum_games:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>T</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo>,</mo>
      <mi>D</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo rspace="4.2pt">=</mo>
    <mrow>
     <munder accentunder="true">
      <mo>E</mo>
      <mrow>
       <mi>x</mi>
       <mo>∼</mo>
       <mi>D</mi>
      </mrow>
     </munder>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>T</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo>,</mo>
        <mi>X</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <interval closure="open">
      <ci>A</ci>
      <ci>D</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="latexml">similar-to</csymbol>
       <ci>x</ci>
       <ci>D</ci>
      </apply>
      <ci>normal-E</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>T</ci>
       <interval closure="open">
        <ci>A</ci>
        <ci>X</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(A,D)=\,\underset{x\sim D}{\operatorname{E}}[T(A,X)].\,
  </annotation>
 </semantics>
</math>

</p>

<p>If we limit the set of algorithms to a specific family (for instance, all deterministic choices for pivots in the <a href="quick_sort" title="wikilink">quick sort</a> algorithm), choosing an algorithm A from R is equivalent to running a randomized algorithm (for instance, running quick sort and randomly choosing the pivots at each step).</p>

<p>This gives us an insight on <a href="Yao's_principle" title="wikilink">Yao's principle</a>, which states that the <a href="expected_value" title="wikilink">expected</a> cost of any <a href="randomized_algorithm" title="wikilink">randomized algorithm</a> for solving a given problem, on the worst-case input for that algorithm, can be no better than the expected cost, for a worst-case random <a href="probability_distribution" title="wikilink">probability distribution</a> on the inputs, of the <a href="deterministic_algorithm" title="wikilink">deterministic algorithm</a> that performs best against that distribution.</p>

<p>"</p>

<p><a href="Category:Non-cooperative_games" title="wikilink">Category:Non-cooperative games</a> <a href="Category:Probabilistic_complexity_theory" title="wikilink">Category:Probabilistic complexity theory</a></p>
</body>
</html>
