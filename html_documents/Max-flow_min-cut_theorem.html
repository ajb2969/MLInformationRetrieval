<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="70">Max-flow min-cut theorem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Max-flow min-cut theorem</h1>
<hr/>

<p>In <a href="Optimization_(mathematics)" title="wikilink">optimization theory</a>, the <strong>max-flow min-cut theorem</strong> states that in a <a href="flow_network" title="wikilink">flow network</a>, the maximum amount of flow passing from the <a href="Glossary_of_graph_theory#Direction" title="wikilink"><em>source</em></a> to the <a href="Glossary_of_graph_theory#Direction" title="wikilink"><em>sink</em></a> is equal to the minimum capacity that, when removed in a specific way from the network, causes the situation that no flow can pass from the source to the sink.</p>

<p>The <strong>max-flow min-cut theorem</strong> is a special case of the <a href="dual_problem" title="wikilink">duality theorem</a> for <a href="linear_program" title="wikilink">linear programs</a> and can be used to derive <a href="Menger's_theorem" title="wikilink">Menger's theorem</a> and the <a href="König's_theorem_(graph_theory)" title="wikilink">König–Egerváry theorem</a>.</p>
<h2 id="definitions-and-statement">Definitions and statement</h2>

<p>Let 

<math display="inline" id="Max-flow_min-cut_theorem:0">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>N</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N=(V,E)
  </annotation>
 </semantics>
</math>

 be a network (directed graph) with 

<math display="inline" id="Max-flow_min-cut_theorem:1">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Max-flow_min-cut_theorem:2">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 being the source and the sink of 

<math display="inline" id="Max-flow_min-cut_theorem:3">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 respectively.</p>
<h3 id="maximum-flow">Maximum flow</h3>

<p><strong>Definition.</strong> The <strong>capacity</strong> of an edge is a mapping <mtpl></mtpl>, denoted by <mtpl></mtpl> or 

<math display="inline" id="Max-flow_min-cut_theorem:4">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>c</ci>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(u,v)
  </annotation>
 </semantics>
</math>

. It represents the maximum amount of flow that can pass through an edge.</p>

<p><strong>Definition.</strong> A <strong>flow</strong> is a mapping <mtpl></mtpl>, denoted by <mtpl></mtpl> or 

<math display="inline" id="Max-flow_min-cut_theorem:5">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(u,v)
  </annotation>
 </semantics>
</math>

, subject to the following two constraints:</p>
<dl>
<dd>1. Capacity Constraint:

<p>

<math display="block" id="Max-flow_min-cut_theorem:6">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>E</mi>
   <mo>:</mo>
   <msub>
    <mi>f</mi>
    <mrow>
     <mi>u</mi>
     <mi>v</mi>
    </mrow>
   </msub>
   <mo>≤</mo>
   <msub>
    <mi>c</mi>
    <mrow>
     <mi>u</mi>
     <mi>v</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <in></in>
    <csymbol cd="unknown">E</csymbol>
    <ci>normal-:</ci>
    <ci>italic-</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>u</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <apply>
      <times></times>
      <ci>u</ci>
      <ci>v</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall(u,v)\in E:\qquad f_{uv}\leq c_{uv}
  </annotation>
 </semantics>
</math>

</p>
</dd>
<dd>2. Conservation of Flows:

<p>

<math display="block" id="Max-flow_min-cut_theorem:7">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>v</mi>
   <mo>∈</mo>
   <mi>V</mi>
   <mo>∖</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>:</mo>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>u</mi>
     <mo>:</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo>,</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mi>E</mi>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </msub>
   <msub>
    <mi>f</mi>
    <mrow>
     <mi>u</mi>
     <mi>v</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>u</mi>
     <mo>:</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo>,</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mi>E</mi>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </msub>
   <msub>
    <mi>f</mi>
    <mrow>
     <mi>v</mi>
     <mi>u</mi>
    </mrow>
   </msub>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">v</csymbol>
    <in></in>
    <csymbol cd="unknown">V</csymbol>
    <setdiff></setdiff>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-}</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>italic-</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <ci>u</ci>
      <apply>
       <in></in>
       <interval closure="open">
        <ci>u</ci>
        <ci>v</ci>
       </interval>
       <ci>E</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>u</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <ci>u</ci>
      <apply>
       <in></in>
       <interval closure="open">
        <ci>v</ci>
        <ci>u</ci>
       </interval>
       <ci>E</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>v</ci>
      <ci>u</ci>
     </apply>
    </apply>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall v\in V\setminus\{s,t\}:\qquad\sum\nolimits_{\{u:(u,v)\in E\}}f_{uv}=%
\sum\nolimits_{\{u:(v,u)\in E\}}f_{vu}.
  </annotation>
 </semantics>
</math>

</p>
</dd>
</dl>

<p><strong>Definition.</strong> The <strong>value of flow</strong> is defined by</p>

<p>

<math display="block" id="Max-flow_min-cut_theorem:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>f</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>v</mi>
       <mo>∈</mo>
       <mi>V</mi>
      </mrow>
     </msub>
     <msub>
      <mi>f</mi>
      <mrow>
       <mi>s</mi>
       <mi>v</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <ci>f</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <ci>v</ci>
       <ci>V</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |f|=\sum\nolimits_{v\in V}f_{sv},
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Max-flow_min-cut_theorem:9">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 is the source of 

<math display="inline" id="Max-flow_min-cut_theorem:10">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

. It represents the amount of flow passing from the source to the sink.</p>
<dl>
<dd><strong><a href="maximum_flow_problem" title="wikilink">Maximum Flow Problem.</a></strong> Maximize 

<math display="inline" id="Max-flow_min-cut_theorem:11">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>f</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |f|
  </annotation>
 </semantics>
</math>

, that is, to route as much flow as possible from 

<math display="inline" id="Max-flow_min-cut_theorem:12">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Max-flow_min-cut_theorem:13">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
<h3 id="minimum-cut">Minimum cut</h3>

<p><strong>Definition.</strong> An <strong>s-t cut</strong> 

<math display="inline" id="Max-flow_min-cut_theorem:14">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <interval closure="open">
     <ci>S</ci>
     <ci>T</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=(S,T)
  </annotation>
 </semantics>
</math>

 is a partition of 

<math display="inline" id="Max-flow_min-cut_theorem:15">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Max-flow_min-cut_theorem:16">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mi mathvariant="normal">∈</mi>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>normal-∈</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s∈S
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Max-flow_min-cut_theorem:17">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mi mathvariant="normal">∈</mi>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>normal-∈</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t∈T
  </annotation>
 </semantics>
</math>

. The <strong>cut-set</strong> of 

<math display="inline" id="Max-flow_min-cut_theorem:18">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is the set</p>

<p>

<math display="block" id="Max-flow_min-cut_theorem:19">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∈</mo>
     <mpadded width="+5pt">
      <mi>E</mi>
     </mpadded>
    </mrow>
    <mo rspace="7.5pt">:</mo>
    <mrow>
     <mrow>
      <mi>u</mi>
      <mo>∈</mo>
      <mi>S</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>v</mi>
      <mo>∈</mo>
      <mi>T</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <in></in>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
     <ci>E</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <ci>u</ci>
      <ci>S</ci>
     </apply>
     <apply>
      <in></in>
      <ci>v</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(u,v)\in E\ :\ u\in S,v\in T\}.
  </annotation>
 </semantics>
</math>

 Note that if the edges in the cut-set of 

<math display="inline" id="Max-flow_min-cut_theorem:20">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 are removed, 

<math display="inline" id="Max-flow_min-cut_theorem:21">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>f</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <ci>f</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |f|=0
  </annotation>
 </semantics>
</math>

.</p>

<p><strong>Definition.</strong> The <strong>capacity</strong> of an <em>s-t cut</em> is defined by</p>

<p>

<math display="block" id="Max-flow_min-cut_theorem:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>c</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>S</mi>
      <mo>,</mo>
      <mi>T</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>u</mi>
        <mo>,</mo>
        <mi>v</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>∈</mo>
       <mrow>
        <mi>S</mi>
        <mo>×</mo>
        <mi>T</mi>
       </mrow>
      </mrow>
     </msub>
     <msub>
      <mi>c</mi>
      <mrow>
       <mi>u</mi>
       <mi>v</mi>
      </mrow>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>i</mi>
        <mo>,</mo>
        <mi>j</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <mo>∈</mo>
       <mi>E</mi>
      </mrow>
     </msub>
     <mrow>
      <msub>
       <mi>c</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <msub>
       <mi>d</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>c</ci>
      <interval closure="open">
       <ci>S</ci>
       <ci>T</ci>
      </interval>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <interval closure="open">
         <ci>u</ci>
         <ci>v</ci>
        </interval>
        <apply>
         <times></times>
         <ci>S</ci>
         <ci>T</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <apply>
        <times></times>
        <ci>u</ci>
        <ci>v</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <interval closure="open">
         <ci>i</ci>
         <ci>j</ci>
        </interval>
        <ci>E</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>d</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(S,T)=\sum\nolimits_{(u,v)\in S\times T}c_{uv}=\sum\nolimits_{(i,j)\in E}c_{%
ij}d_{ij},
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Max-flow_min-cut_theorem:23">
 <semantics>
  <mrow>
   <msub>
    <mi>d</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{ij}=1
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Max-flow_min-cut_theorem:24">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>i</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\in S
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Max-flow_min-cut_theorem:25">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>∈</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>j</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j\in T
  </annotation>
 </semantics>
</math>

, 0 otherwise.</p>
<dl>
<dd><strong>Minimum s-t Cut Problem.</strong> Minimize 

<math display="inline" id="Max-flow_min-cut_theorem:26">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>c</ci>
    <interval closure="open">
     <ci>S</ci>
     <ci>T</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(S,T)
  </annotation>
 </semantics>
</math>

, that is, to determine 

<math display="inline" id="Max-flow_min-cut_theorem:27">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Max-flow_min-cut_theorem:28">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 such that the capacity of the <em>S-T cut</em> is minimal.
</dd>
</dl>
<h3 id="statement">Statement</h3>
<dl>
<dd><strong>Max-flow min-cut theorem.</strong> The maximum value of an s-t flow is equal to the minimum capacity over all s-t cuts.
</dd>
</dl>
<h2 id="linear-program-formulation">Linear program formulation</h2>

<p>The max-flow problem and min-cut problem can be formulated as two primal-dual linear programs.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Max-flow (Primal)</p></th>
<th style="text-align: left;">
<p>Min-cut (Dual)</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>maximize 

<math display="inline" id="Max-flow_min-cut_theorem:29">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>f</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>=</mo>
   <msub>
    <mo>∇</mo>
    <mi>s</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <ci>f</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-∇</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |f|=\nabla_{s}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>minimize 

<math display="inline" id="Max-flow_min-cut_theorem:30">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>i</mi>
      <mo>,</mo>
      <mi>j</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∈</mo>
     <mi>E</mi>
    </mrow>
   </msub>
   <mrow>
    <msub>
     <mi>c</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <msub>
     <mi>d</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <interval closure="open">
       <ci>i</ci>
       <ci>j</ci>
      </interval>
      <ci>E</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{(i,j)\in E}c_{ij}d_{ij}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>subject to</p>

<p>

<math display="block" id="Max-flow_min-cut_theorem:31">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="right">
     <msub>
      <mi>f</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>≤</mo>
    </mtd>
    <mtd columnalign="left">
     <msub>
      <mi>c</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mtd>
    <mtd columnalign="right">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>i</mi>
       <mo>,</mo>
       <mi>j</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mi>E</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mrow>
       <munder>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>j</mi>
         <mo>:</mo>
         <mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>j</mi>
           <mo>,</mo>
           <mi>i</mi>
           <mo stretchy="false">)</mo>
          </mrow>
          <mo>∈</mo>
          <mi>E</mi>
         </mrow>
        </mrow>
       </munder>
       <msub>
        <mi>f</mi>
        <mrow>
         <mi>j</mi>
         <mi>i</mi>
        </mrow>
       </msub>
      </mrow>
      <mo>-</mo>
      <mrow>
       <munder>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>j</mi>
         <mo>:</mo>
         <mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>i</mi>
           <mo>,</mo>
           <mi>j</mi>
           <mo stretchy="false">)</mo>
          </mrow>
          <mo>∈</mo>
          <mi>E</mi>
         </mrow>
        </mrow>
       </munder>
       <msub>
        <mi>f</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
       </msub>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>≤</mo>
    </mtd>
    <mtd columnalign="left">
     <mn>0</mn>
    </mtd>
    <mtd columnalign="right">
     <mrow>
      <mrow>
       <mi>i</mi>
       <mo>∈</mo>
       <mi>V</mi>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>i</mi>
       <mo>≠</mo>
       <mrow>
        <mi>s</mi>
        <mo>,</mo>
        <mi>t</mi>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mrow>
       <msub>
        <mo>∇</mo>
        <mi>s</mi>
       </msub>
       <mo>+</mo>
       <mrow>
        <munder>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>j</mi>
          <mo>:</mo>
          <mrow>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>j</mi>
            <mo>,</mo>
            <mi>s</mi>
            <mo stretchy="false">)</mo>
           </mrow>
           <mo>∈</mo>
           <mi>E</mi>
          </mrow>
         </mrow>
        </munder>
        <msub>
         <mi>f</mi>
         <mrow>
          <mi>j</mi>
          <mi>s</mi>
         </mrow>
        </msub>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <munder>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>j</mi>
         <mo>:</mo>
         <mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>s</mi>
           <mo>,</mo>
           <mi>j</mi>
           <mo stretchy="false">)</mo>
          </mrow>
          <mo>∈</mo>
          <mi>E</mi>
         </mrow>
        </mrow>
       </munder>
       <msub>
        <mi>f</mi>
        <mrow>
         <mi>s</mi>
         <mi>j</mi>
        </mrow>
       </msub>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>≤</mo>
    </mtd>
    <mtd columnalign="left">
     <mn>0</mn>
    </mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mrow>
       <mrow>
        <mo>-</mo>
        <msub>
         <mo>∇</mo>
         <mi>s</mi>
        </msub>
       </mrow>
       <mo>+</mo>
       <mrow>
        <munder>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>j</mi>
          <mo>:</mo>
          <mrow>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>j</mi>
            <mo>,</mo>
            <mi>t</mi>
            <mo stretchy="false">)</mo>
           </mrow>
           <mo>∈</mo>
           <mi>E</mi>
          </mrow>
         </mrow>
        </munder>
        <msub>
         <mi>f</mi>
         <mrow>
          <mi>j</mi>
          <mi>t</mi>
         </mrow>
        </msub>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <munder>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>j</mi>
         <mo>:</mo>
         <mrow>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo>,</mo>
           <mi>j</mi>
           <mo stretchy="false">)</mo>
          </mrow>
          <mo>∈</mo>
          <mi>E</mi>
         </mrow>
        </mrow>
       </munder>
       <msub>
        <mi>f</mi>
        <mrow>
         <mi>t</mi>
         <mi>j</mi>
        </mrow>
       </msub>
      </mrow>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>≤</mo>
    </mtd>
    <mtd columnalign="left">
     <mn>0</mn>
    </mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <msub>
      <mi>f</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>≥</mo>
    </mtd>
    <mtd columnalign="left">
     <mn>0</mn>
    </mtd>
    <mtd columnalign="right">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>i</mi>
       <mo>,</mo>
       <mi>j</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mi>E</mi>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <leq></leq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <in></in>
      <interval closure="open">
       <ci>i</ci>
       <ci>j</ci>
      </interval>
      <ci>E</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <minus></minus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <ci>normal-:</ci>
         <ci>j</ci>
         <apply>
          <in></in>
          <interval closure="open">
           <ci>j</ci>
           <ci>i</ci>
          </interval>
          <ci>E</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <apply>
         <times></times>
         <ci>j</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <ci>normal-:</ci>
         <ci>j</ci>
         <apply>
          <in></in>
          <interval closure="open">
           <ci>i</ci>
           <ci>j</ci>
          </interval>
          <ci>E</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <in></in>
       <ci>i</ci>
       <ci>V</ci>
      </apply>
      <apply>
       <neq></neq>
       <ci>i</ci>
       <list>
        <ci>s</ci>
        <ci>t</ci>
       </list>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-∇</ci>
        <ci>s</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <ci>normal-:</ci>
          <ci>j</ci>
          <apply>
           <in></in>
           <interval closure="open">
            <ci>j</ci>
            <ci>s</ci>
           </interval>
           <ci>E</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <apply>
          <times></times>
          <ci>j</ci>
          <ci>s</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <ci>normal-:</ci>
         <ci>j</ci>
         <apply>
          <in></in>
          <interval closure="open">
           <ci>s</ci>
           <ci>j</ci>
          </interval>
          <ci>E</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <apply>
         <times></times>
         <ci>s</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <minus></minus>
      <apply>
       <plus></plus>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-∇</ci>
         <ci>s</ci>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <ci>normal-:</ci>
          <ci>j</ci>
          <apply>
           <in></in>
           <interval closure="open">
            <ci>j</ci>
            <ci>t</ci>
           </interval>
           <ci>E</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <apply>
          <times></times>
          <ci>j</ci>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <ci>normal-:</ci>
         <ci>j</ci>
         <apply>
          <in></in>
          <interval closure="open">
           <ci>t</ci>
           <ci>j</ci>
          </interval>
          <ci>E</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <apply>
         <times></times>
         <ci>t</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <leq></leq>
     <cn type="integer">0</cn>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <geq></geq>
     <cn type="integer">0</cn>
     <apply>
      <in></in>
      <interval closure="open">
       <ci>i</ci>
       <ci>j</ci>
      </interval>
      <ci>E</ci>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{rclr}f_{ij}&\leq&c_{ij}&(i,j)\in E\\
\sum_{j:(j,i)\in E}f_{ji}-\sum_{j:(i,j)\in E}f_{ij}&\leq&0&i\in V,i\neq s,t\\
\nabla_{s}+\sum_{j:(j,s)\in E}f_{js}-\sum_{j:(s,j)\in E}f_{sj}&\leq&0&\\
-\nabla_{s}+\sum_{j:(j,t)\in E}f_{jt}-\sum_{j:(t,j)\in E}f_{tj}&\leq&0&\\
f_{ij}&\geq&0&(i,j)\in E\\
\end{array}
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>subject to</p>

<p>

<math display="block" id="Max-flow_min-cut_theorem:32">
 <semantics>
  <mtable displaystyle="true">
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <mrow>
       <msub>
        <mi>d</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>p</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo>+</mo>
      <msub>
       <mi>p</mi>
       <mi>j</mi>
      </msub>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>≥</mo>
    </mtd>
    <mtd columnalign="left">
     <mn>0</mn>
    </mtd>
    <mtd columnalign="right">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>i</mi>
       <mo>,</mo>
       <mi>j</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mi>E</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>s</mi>
      </msub>
      <mo>-</mo>
      <msub>
       <mi>p</mi>
       <mi>t</mi>
      </msub>
     </mrow>
    </mtd>
    <mtd columnalign="center">
     <mo>≥</mo>
    </mtd>
    <mtd columnalign="left">
     <mn>1</mn>
    </mtd>
    <mtd></mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <msub>
      <mi>p</mi>
      <mi>i</mi>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>≥</mo>
    </mtd>
    <mtd columnalign="left">
     <mn>0</mn>
    </mtd>
    <mtd columnalign="right">
     <mrow>
      <mi>i</mi>
      <mo>∈</mo>
      <mi>V</mi>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="right">
     <msub>
      <mi>d</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mtd>
    <mtd columnalign="center">
     <mo>≥</mo>
    </mtd>
    <mtd columnalign="left">
     <mn>0</mn>
    </mtd>
    <mtd columnalign="right">
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>i</mi>
       <mo>,</mo>
       <mi>j</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mi>E</mi>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>d</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <geq></geq>
     <cn type="integer">0</cn>
     <apply>
      <in></in>
      <interval closure="open">
       <ci>i</ci>
       <ci>j</ci>
      </interval>
      <ci>E</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>s</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <geq></geq>
     <cn type="integer">1</cn>
     <cerror>
      <csymbol cd="ambiguous">missing-subexpression</csymbol>
     </cerror>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>i</ci>
     </apply>
     <geq></geq>
     <cn type="integer">0</cn>
     <apply>
      <in></in>
      <ci>i</ci>
      <ci>V</ci>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <geq></geq>
     <cn type="integer">0</cn>
     <apply>
      <in></in>
      <interval closure="open">
       <ci>i</ci>
       <ci>j</ci>
      </interval>
      <ci>E</ci>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{rclr}d_{ij}-p_{i}+p_{j}&\geq&0&(i,j)\in E\\
p_{s}-p_{t}&\geq&1&\\
p_{i}&\geq&0&i\in V\\
d_{ij}&\geq&0&(i,j)\in E\end{array}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>Note that for the given s-t cut 

<math display="inline" id="Max-flow_min-cut_theorem:33">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <interval closure="open">
     <ci>S</ci>
     <ci>T</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=(S,T)
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Max-flow_min-cut_theorem:34">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>∈</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>i</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\in S
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Max-flow_min-cut_theorem:35">
 <semantics>
  <mrow>
   <msub>
    <mi>p</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i}=1
  </annotation>
 </semantics>
</math>

 and 0 otherwise. Therefore 

<math display="inline" id="Max-flow_min-cut_theorem:36">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{s}
  </annotation>
 </semantics>
</math>

 should be 1 and 

<math display="inline" id="Max-flow_min-cut_theorem:37">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{t}
  </annotation>
 </semantics>
</math>

 shout be zero. The equality in the <strong>max-flow min-cut theorem</strong> follows from the <a href="strong_duality" title="wikilink">strong duality theorem</a> in <a href="linear_programming" title="wikilink">linear programming</a>, which states that if the primal program has an optimal solution, <em>x</em>*, then the dual program also has an optimal solution, <em>y</em>*, such that the optimal values formed by the two solutions are equal.</p>
<h2 id="example">Example</h2>

<p> The figure on the right is a network having a value of flow of 7. The vertex in white and the vertices in grey form the subsets 

<math display="inline" id="Max-flow_min-cut_theorem:38">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Max-flow_min-cut_theorem:39">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

 of an s-t cut, whose cut-set contains the dashed edges. Since the capacity of the s-t cut is 7, which equals to the value of flow, the max-flow min-cut theorem tells us that the value of flow and the capacity of the s-t cut are both optimal in this network.</p>
<h2 id="application">Application</h2>
<h3 id="generalized-max-flow-min-cut-theorem">Generalized max-flow min-cut theorem</h3>

<p>In addition to edge capacity, consider there is capacity at each vertex, that is, a mapping <mtpl></mtpl>, denoted by 

<math display="inline" id="Max-flow_min-cut_theorem:40">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>c</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(v)
  </annotation>
 </semantics>
</math>

, such that the flow 

<math display="inline" id="Max-flow_min-cut_theorem:41">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 has to satisfy not only the capacity constraint and the conservation of flows, but also the vertex capacity constraint</p>

<p>

<math display="block" id="Max-flow_min-cut_theorem:42">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>v</mi>
   <mo>∈</mo>
   <mi>V</mi>
   <mo>∖</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>:</mo>
   <msub>
    <mo largeop="true" symmetric="true">∑</mo>
    <mrow>
     <mi>i</mi>
     <mo>∈</mo>
     <mi>V</mi>
    </mrow>
   </msub>
   <msub>
    <mi>f</mi>
    <mrow>
     <mi>i</mi>
     <mi>v</mi>
    </mrow>
   </msub>
   <mo>≤</mo>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">v</csymbol>
    <in></in>
    <csymbol cd="unknown">V</csymbol>
    <setdiff></setdiff>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-}</ci>
    </cerror>
    <ci>normal-:</ci>
    <ci>italic-</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <sum></sum>
     <apply>
      <in></in>
      <ci>i</ci>
      <ci>V</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>v</ci>
     </apply>
    </apply>
    <leq></leq>
    <csymbol cd="unknown">c</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall v\in V\setminus\{s,t\}:\qquad\sum\nolimits_{i\in V}f_{iv}\leq c(v).
  </annotation>
 </semantics>
</math>

</p>

<p>In other words, the amount of <em>flow</em> passing through a vertex cannot exceed its capacity. Define an <em>s-t cut</em> to be the set of vertices and edges such that for any path from <em>s</em> to <em>t</em>, the path contains a member of the cut. In this case, the <em>capacity of the cut</em> is the sum the capacity of each edge and vertex in it.</p>

<p>In this new definition, the <strong>generalized max-flow min-cut theorem</strong> states that the maximum value of an s-t flow is equal to the minimum capacity of an s-t cut in the new sense.</p>
<h3 id="mengers-theorem">Menger's theorem</h3>

<p>In the undirected edge-disjoint paths problem, we are given an undirected graph 

<math display="inline" id="Max-flow_min-cut_theorem:43">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,E)
  </annotation>
 </semantics>
</math>

 and two vertices 

<math display="inline" id="Max-flow_min-cut_theorem:44">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Max-flow_min-cut_theorem:45">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, and we have to find the maximum number of edge-disjoint s-t paths in 

<math display="inline" id="Max-flow_min-cut_theorem:46">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

.</p>

<p>The <strong>Menger's theorem</strong> states that the maximum number of edge-disjoint s-t paths in an undirected graph is equal to the minimum number of edges in an s-t cut-set.</p>
<h3 id="project-selection-problem">Project selection problem</h3>

<p> In the project selection problem, there are 

<math display="inline" id="Max-flow_min-cut_theorem:47">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 projects and 

<math display="inline" id="Max-flow_min-cut_theorem:48">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 equipments. Each project <mtpl></mtpl> yields revenue <mtpl></mtpl> and each equipment <mtpl></mtpl> costs <mtpl></mtpl> to purchase. Each project requires a number of equipments and each equipment can be shared by several projects. The problem is to determine which projects and equipments should be selected and purchased respectively, so that the profit is maximized.</p>

<p>Let 

<math display="inline" id="Max-flow_min-cut_theorem:49">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 be the set of projects <em>not</em> selected and 

<math display="inline" id="Max-flow_min-cut_theorem:50">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 be the set of equipments purchased, then the problem can be formulated as,</p>

<p>

<math display="block" id="Max-flow_min-cut_theorem:51">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>max</mi>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>g</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mi>i</mi>
      </munder>
      <mrow>
       <mi>r</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>p</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <msub>
         <mi>p</mi>
         <mi>i</mi>
        </msub>
        <mo>∈</mo>
        <mi>P</mi>
       </mrow>
      </munder>
      <mrow>
       <mi>r</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>p</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <msub>
         <mi>q</mi>
         <mi>j</mi>
        </msub>
        <mo>∈</mo>
        <mi>Q</mi>
       </mrow>
      </munder>
      <mrow>
       <mi>c</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>q</mi>
         <mi>j</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <max></max>
     <ci>g</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <ci>i</ci>
      </apply>
      <apply>
       <times></times>
       <ci>r</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>i</ci>
        </apply>
        <ci>P</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>r</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>q</ci>
         <ci>j</ci>
        </apply>
        <ci>Q</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>c</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>q</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max\{g\}=\sum_{i}r(p_{i})-\sum_{p_{i}\in P}r(p_{i})-\sum_{q_{j}\in Q}c(q_{j}).
  </annotation>
 </semantics>
</math>

</p>

<p>Since the first term does not depend on the choice of 

<math display="inline" id="Max-flow_min-cut_theorem:52">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Max-flow_min-cut_theorem:53">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

, this maximization problem can be formulated as a minimization problem instead, that is,</p>

<p>

<math display="block" id="Max-flow_min-cut_theorem:54">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>min</mi>
     <mrow>
      <mo stretchy="false">{</mo>
      <msup>
       <mi>g</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <msub>
         <mi>p</mi>
         <mi>i</mi>
        </msub>
        <mo>∈</mo>
        <mi>P</mi>
       </mrow>
      </munder>
      <mrow>
       <mi>r</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>p</mi>
         <mi>i</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <msub>
         <mi>q</mi>
         <mi>j</mi>
        </msub>
        <mo>∈</mo>
        <mi>Q</mi>
       </mrow>
      </munder>
      <mrow>
       <mi>c</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>q</mi>
         <mi>j</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <min></min>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>i</ci>
        </apply>
        <ci>P</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>r</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>q</ci>
         <ci>j</ci>
        </apply>
        <ci>Q</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>c</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>q</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min\{g^{\prime}\}=\sum_{p_{i}\in P}r(p_{i})+\sum_{q_{j}\in Q}c(q_{j}).
  </annotation>
 </semantics>
</math>

</p>

<p>The above minimization problem can then be formulated as a minimum-cut problem by constructing a network, where the source is connected to the projects with capacity <mtpl></mtpl>, and the sink is connected by the equipments with capacity <mtpl></mtpl>. An edge <mtpl></mtpl> with <em>infinite</em> capacity is added if project <mtpl></mtpl> requires equipment <mtpl></mtpl>. The s-t cut-set represents the projects and equipments in 

<math display="inline" id="Max-flow_min-cut_theorem:55">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Max-flow_min-cut_theorem:56">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 respectively. By the max-flow min-cut theorem, one can solve the problem as a <a href="maximum_flow_problem" title="wikilink">maximum flow problem</a>.</p>

<p>The figure on the right gives a network formulation of the following project selection problem:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">
<p>Project <mtpl></mtpl></p></th>
<th style="text-align: left;">
<p>Equipment <mtpl></mtpl></p></th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>100</p></td>
<td style="text-align: left;">
<p>200</p></td>
<td style="text-align: left;">
<p>Project 1 requires equipments 1 and 2.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>200</p></td>
<td style="text-align: left;">
<p>100</p></td>
<td style="text-align: left;">
<p>Project 2 requires equipment 2.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>150</p></td>
<td style="text-align: left;">
<p>50</p></td>
<td style="text-align: left;">
<p>Project 3 requires equipment 3.</p></td>
</tr>
</tbody>
</table>

<p>The minimum capacity of a s-t cut is 250 and the sum of the revenue of each project is 450; therefore the maximum profit <em>g</em> is 450 − 250 = 200, by selecting projects <mtpl></mtpl> and <mtpl></mtpl>.</p>

<p>The idea here is to 'flow' the project profits through the 'pipes' of the equipment. If we cannot fill the pipe, the equipment's return is less than its cost, and the min cut algorithm will find it cheaper to cut the project's profit edge instead of the equipment's cost edge.</p>
<h3 id="image-segmentation-problem">Image segmentation problem</h3>

<p> In the image segmentation problem, there are 

<math display="inline" id="Max-flow_min-cut_theorem:57">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 pixels. Each pixel 

<math display="inline" id="Max-flow_min-cut_theorem:58">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 can be assigned a foreground value <mtpl></mtpl> or a background value <mtpl></mtpl>. There is a penalty of <mtpl></mtpl> if pixels 

<math display="inline" id="Max-flow_min-cut_theorem:59">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>,</mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>i</ci>
    <ci>j</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i,j
  </annotation>
 </semantics>
</math>

 are adjacent and have different assignments. The problem is to assign pixels to foreground or background such that the sum of their values minus the penalties is maximum.</p>

<p>Let 

<math display="inline" id="Max-flow_min-cut_theorem:60">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 be the set of pixels assigned to foreground and 

<math display="inline" id="Max-flow_min-cut_theorem:61">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 be the set of points assigned to background, then the problem can be formulated as,</p>

<p>

<math display="block" id="Max-flow_min-cut_theorem:62">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>max</mi>
     <mrow>
      <mo stretchy="false">{</mo>
      <mi>g</mi>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <munder>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>i</mi>
         <mo>∈</mo>
         <mi>P</mi>
        </mrow>
       </munder>
       <msub>
        <mi>f</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo>+</mo>
      <mrow>
       <munder>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>i</mi>
         <mo>∈</mo>
         <mi>Q</mi>
        </mrow>
       </munder>
       <msub>
        <mi>b</mi>
        <mi>i</mi>
       </msub>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <munder>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mrow>
         <mrow>
          <mi>i</mi>
          <mo>∈</mo>
          <mi>P</mi>
         </mrow>
         <mo>,</mo>
         <mrow>
          <mi>j</mi>
          <mo>∈</mo>
          <mrow>
           <mi>Q</mi>
           <mi>j</mi>
          </mrow>
          <mo>∈</mo>
          <mi>P</mi>
         </mrow>
        </mrow>
        <mo>,</mo>
        <mrow>
         <mi>i</mi>
         <mo>∈</mo>
         <mi>Q</mi>
        </mrow>
       </mrow>
      </munder>
      <msub>
       <mi>p</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <max></max>
     <ci>g</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <in></in>
         <ci>i</ci>
         <ci>P</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <in></in>
         <ci>i</ci>
         <ci>Q</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <csymbol cd="ambiguous">formulae-sequence</csymbol>
        <apply>
         <csymbol cd="ambiguous">formulae-sequence</csymbol>
         <apply>
          <in></in>
          <ci>i</ci>
          <ci>P</ci>
         </apply>
         <apply>
          <and></and>
          <apply>
           <in></in>
           <ci>j</ci>
           <apply>
            <times></times>
            <ci>Q</ci>
            <ci>j</ci>
           </apply>
          </apply>
          <apply>
           <in></in>
           <share href="#.cmml">
           </share>
           <ci>P</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <in></in>
         <ci>i</ci>
         <ci>Q</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \max\{g\}=\sum_{i\in P}f_{i}+\sum_{i\in Q}b_{i}-\sum_{i\in P,j\in Qj\in P,i\in
Q%
}p_{ij}.
  </annotation>
 </semantics>
</math>

</p>

<p>This maximization problem can be formulated as a minimization problem instead, that is,</p>

<p>

<math display="block" id="Max-flow_min-cut_theorem:63">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>min</mi>
     <mrow>
      <mo stretchy="false">{</mo>
      <msup>
       <mi>g</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mrow>
        <mrow>
         <mi>i</mi>
         <mo>∈</mo>
         <mi>P</mi>
        </mrow>
        <mo>,</mo>
        <mrow>
         <mi>j</mi>
         <mo>∈</mo>
         <mrow>
          <mi>Q</mi>
          <mi>j</mi>
         </mrow>
         <mo>∈</mo>
         <mi>P</mi>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi>i</mi>
        <mo>∈</mo>
        <mi>Q</mi>
       </mrow>
      </mrow>
     </munder>
     <msub>
      <mi>p</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <min></min>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <csymbol cd="ambiguous">formulae-sequence</csymbol>
        <apply>
         <in></in>
         <ci>i</ci>
         <ci>P</ci>
        </apply>
        <apply>
         <and></and>
         <apply>
          <in></in>
          <ci>j</ci>
          <apply>
           <times></times>
           <ci>Q</ci>
           <ci>j</ci>
          </apply>
         </apply>
         <apply>
          <in></in>
          <share href="#.cmml">
          </share>
          <ci>P</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <in></in>
        <ci>i</ci>
        <ci>Q</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min\{g^{\prime}\}=\sum_{i\in P,j\in Qj\in P,i\in Q}p_{ij}.
  </annotation>
 </semantics>
</math>

</p>

<p>The above minimization problem can be formulated as a minimum-cut problem by constructing a network where the source (orange node) is connected to all the pixels with capacity <mtpl></mtpl>, and the sink (purple node) is connected by all the pixels with capacity <mtpl></mtpl>. Two edges (

<math display="inline" id="Max-flow_min-cut_theorem:64">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>,</mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>i</ci>
    <ci>j</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i,j
  </annotation>
 </semantics>
</math>

) and (

<math display="inline" id="Max-flow_min-cut_theorem:65">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>,</mo>
   <mi>i</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>j</ci>
    <ci>i</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j,i
  </annotation>
 </semantics>
</math>

) with <mtpl></mtpl> capacity are added between two adjacent pixels. The s-t cut-set then represents the pixels assigned to the foreground in 

<math display="inline" id="Max-flow_min-cut_theorem:66">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and pixels assigned to background in 

<math display="inline" id="Max-flow_min-cut_theorem:67">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="history">History</h2>

<p>The <strong>max-flow min-cut theorem</strong> was proven by <a href="Peter_Elias" title="wikilink">P. Elias</a>, A. Feinstein, and <a href="C.E._Shannon" title="wikilink">C.E. Shannon</a> in 1956, and independently also by <a href="L.R._Ford,_Jr." title="wikilink">L.R. Ford, Jr.</a> and <a href="D.R._Fulkerson" title="wikilink">D.R. Fulkerson</a> in the same year.</p>
<h2 id="proof">Proof</h2>

<p>Let 

<math display="inline" id="Max-flow_min-cut_theorem:68">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,E)
  </annotation>
 </semantics>
</math>

 be a network (directed graph) with 

<math display="inline" id="Max-flow_min-cut_theorem:69">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Max-flow_min-cut_theorem:70">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 being the source and the sink of 

<math display="inline" id="Max-flow_min-cut_theorem:71">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 respectively.</p>

<p>Consider the flow 

<math display="inline" id="Max-flow_min-cut_theorem:72">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 computed for 

<math display="inline" id="Max-flow_min-cut_theorem:73">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 by <a href="Ford–Fulkerson_algorithm" title="wikilink">Ford–Fulkerson algorithm</a>. In the residual graph <mtpl></mtpl> obtained for 

<math display="inline" id="Max-flow_min-cut_theorem:74">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 (after the final flow assignment by <a href="Ford–Fulkerson_algorithm" title="wikilink">Ford–Fulkerson algorithm</a>), define two subsets of vertices as follows:</p>
<ol>
<li>

<math display="inline" id="Max-flow_min-cut_theorem:75">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

: the set of vertices reachable from 

<math display="inline" id="Max-flow_min-cut_theorem:76">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 in <mtpl></mtpl></li>
<li><mtpl></mtpl>: the set of remaining vertices i.e. 

<math display="inline" id="Max-flow_min-cut_theorem:77">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mi mathvariant="normal">−</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>normal-−</ci>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V−A
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p><strong>Claim.</strong> <mtpl> <em>c</em>(<em>A</em>, <em>A<sup>c</sup></em>)}}</mtpl>, where the <strong>capacity</strong> of an <em>s-t cut</em> is defined by</p>

<p>

<math display="block" id="Max-flow_min-cut_theorem:78">
 <semantics>
  <mrow>
   <mrow>
    <mi>c</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo>,</mo>
     <mi>T</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo>,</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>∈</mo>
      <mrow>
       <mi>S</mi>
       <mo>×</mo>
       <mi>T</mi>
      </mrow>
     </mrow>
    </msub>
    <msub>
     <mi>c</mi>
     <mrow>
      <mi>u</mi>
      <mi>v</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>c</ci>
     <interval closure="open">
      <ci>S</ci>
      <ci>T</ci>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <in></in>
       <interval closure="open">
        <ci>u</ci>
        <ci>v</ci>
       </interval>
       <apply>
        <times></times>
        <ci>S</ci>
        <ci>T</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <apply>
       <times></times>
       <ci>u</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(S,T)=\sum\nolimits_{(u,v)\in S\times T}c_{uv}
  </annotation>
 </semantics>
</math>

.</p>

<p>Now, we know, 

<math display="inline" id="Max-flow_min-cut_theorem:79">
 <semantics>
  <mrow>
   <mrow>
    <mi>v</mi>
    <mi>a</mi>
    <mi>l</mi>
    <mi>u</mi>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>f</mi>
      <mrow>
       <mi>o</mi>
       <mi>u</mi>
       <mi>t</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msub>
      <mi>f</mi>
      <mrow>
       <mi>i</mi>
       <mi>n</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>A</mi>
       <mi>c</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>v</ci>
     <ci>a</ci>
     <ci>l</ci>
     <ci>u</ci>
     <ci>e</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <apply>
        <times></times>
        <ci>o</ci>
        <ci>u</ci>
        <ci>t</ci>
       </apply>
      </apply>
      <ci>A</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>A</ci>
       <ci>c</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   value(f)=f_{out}(A)-f_{in}(A^{c})
  </annotation>
 </semantics>
</math>

 for any subset of vertices, 

<math display="inline" id="Max-flow_min-cut_theorem:80">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

. Therefore for <mtpl> <em>c</em>(<em>A</em>, <em>A<sup>c</sup></em>)}}</mtpl> we need:</p>
<ul>
<li>All <em>outgoing edges</em> from the cut must be <strong>fully saturated</strong>.</li>
<li>All <em>incoming edges</em> to the cut must have <strong>zero flow</strong>.</li>
</ul>

<p>To prove the above claim we consider two cases:</p>
<ul>
<li>In 

<math display="inline" id="Max-flow_min-cut_theorem:81">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, there exists an <em>outgoing edge</em> 

<math display="inline" id="Max-flow_min-cut_theorem:82">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>,</mo>
     <mi>x</mi>
    </mrow>
    <mo>∈</mo>
    <mi>A</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>y</mi>
    <mo>∈</mo>
    <msup>
     <mi>A</mi>
     <mi>c</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <list>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
      <ci>x</ci>
     </list>
     <ci>A</ci>
    </apply>
    <apply>
     <in></in>
     <ci>y</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y),x\in A,y\in A^{c}
  </annotation>
 </semantics>
</math>

 such that it is not saturated, i.e., <mtpl></mtpl>. This implies, that there exists a <strong>forward edge</strong> from 

<math display="inline" id="Max-flow_min-cut_theorem:83">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Max-flow_min-cut_theorem:84">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 in <mtpl></mtpl>, therefore there exists a path from 

<math display="inline" id="Max-flow_min-cut_theorem:85">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Max-flow_min-cut_theorem:86">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 in <mtpl></mtpl>, which is a contradiction. Hence, any outgoing edge 

<math display="inline" id="Max-flow_min-cut_theorem:87">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)
  </annotation>
 </semantics>
</math>

 is fully saturated.</li>
</ul>
<ul>
<li>In 

<math display="inline" id="Max-flow_min-cut_theorem:88">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

, there exists an <em>incoming edge</em> 

<math display="inline" id="Max-flow_min-cut_theorem:89">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>,</mo>
     <mi>x</mi>
    </mrow>
    <mo>∈</mo>
    <mi>A</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>y</mi>
    <mo>∈</mo>
    <msup>
     <mi>A</mi>
     <mi>c</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <in></in>
     <list>
      <interval closure="open">
       <ci>y</ci>
       <ci>x</ci>
      </interval>
      <ci>x</ci>
     </list>
     <ci>A</ci>
    </apply>
    <apply>
     <in></in>
     <ci>y</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>A</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (y,x),x\in A,y\in A^{c}
  </annotation>
 </semantics>
</math>

 such that it carries some non-zero flow, i.e., 

<math display="inline" id="Max-flow_min-cut_theorem:90">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)>0
  </annotation>
 </semantics>
</math>

. This implies, that there exists a <strong>backward edge</strong> from 

<math display="inline" id="Max-flow_min-cut_theorem:91">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Max-flow_min-cut_theorem:92">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 in <mtpl></mtpl>, therefore there exists a path from 

<math display="inline" id="Max-flow_min-cut_theorem:93">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Max-flow_min-cut_theorem:94">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 in <mtpl></mtpl>, which is again a contradiction. Hence, any incoming edge 

<math display="inline" id="Max-flow_min-cut_theorem:95">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)
  </annotation>
 </semantics>
</math>

 must have zero flow.</li>
</ul>

<p>Both of the above statements prove that the capacity of cut obtained in the above described manner is equal to the flow obtained in the network. Also, the flow was obtained by <a href="Ford-Fulkerson_algorithm" title="wikilink">Ford-Fulkerson algorithm</a>, so it is the <a class="uri" href="max-flow" title="wikilink">max-flow</a> of the network as well.</p>
<dl>
<dd>Also, since <em>any flow in the network is always less than or equal to capacity of every cut possible in a network</em>, the above described cut is also the <a class="uri" href="min-cut" title="wikilink">min-cut</a> which obtains the <a class="uri" href="max-flow" title="wikilink">max-flow</a>.
</dd>
</dl>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Linear_programming" title="wikilink">Linear programming</a></li>
<li><a href="Maximum_flow" title="wikilink">Maximum flow</a></li>
<li><a href="Minimum_cut" title="wikilink">Minimum cut</a></li>
<li><a href="Flow_network" title="wikilink">Flow network</a></li>
<li><a href="Edmonds–Karp_algorithm" title="wikilink">Edmonds–Karp algorithm</a></li>
<li><a href="Ford–Fulkerson_algorithm" title="wikilink">Ford–Fulkerson algorithm</a></li>
</ul>
<h2 id="references">References</h2>
<ol>
<li></li>
<li></li>
<li></li>
</ol>

<p>"</p>

<p><a href="Category:Combinatorial_optimization" title="wikilink">Category:Combinatorial optimization</a> <a href="Category:Theorems_in_graph_theory" title="wikilink">Category:Theorems in graph theory</a></p>
</body>
</html>
