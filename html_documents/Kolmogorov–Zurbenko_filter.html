<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1303">Kolmogorov–Zurbenko filter</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Kolmogorov–Zurbenko filter</h1>
<hr/>

<p>The <strong>Kolmogorov–Zurbenko (KZ) Filter</strong> was first proposed by A. N. <a class="uri" href="Kolmogorov" title="wikilink">Kolmogorov</a> and formally defined by Zurbenko<sup>[1]</sup>. It is a series of <a href="iteration" title="wikilink">iterations</a> of a <a href="moving_average" title="wikilink">moving average</a> filter of length <em>m</em>, where <em>m</em> is a positive, odd integer number. The KZ filter belongs to the class of <a href="Low-pass_filter" title="wikilink">Low-pass filters</a>. The KZ filter has two parameters, the length <em>m</em> of the moving average window and the number of iterations <em>k</em> of the moving average itself. It also can be considered as a special <a href="window_function" title="wikilink">window function</a> designed to eliminate spectral leakage.  </p>
<h2 id="background">Background</h2>

<p>A. N. Kolmogorov had the original idea for the KZ filter during a study of <a class="uri" href="turbulence" title="wikilink">turbulence</a> in the Pacific Ocean<sup>[1]</sup>. Kolmogorov had just received the International <a href="Balzan_Prize" title="wikilink">Balzan Prize</a> for his <a href="Turbulence#Kolmogorov.27s_theory_of_1941" title="wikilink">law of 5/3 in the energy spectra of turbulence</a>. Surprisingly the 5/3 law was not obeyed in the Pacific Ocean, causing great concern. Standard <a href="Fast_Fourier_Transform" title="wikilink">Fast Fourier Transform</a> (FFT) was completely fooled by the noisy and non-stationary ocean environment. KZ filtration resolved the problem and enabled proof of Kolmogorov's law in that domain. Filter construction relied on the main concepts of the continuous <a href="Fourier_transform" title="wikilink">Fourier transform</a> and their discrete analogues. The <a class="uri" href="algorithm" title="wikilink">algorithm</a> of the KZ filter came from the definition of higher-order derivatives for discrete functions as higher-order differences. Believing that infinite smoothness in the <a href="Gaussian_window" title="wikilink">Gaussian window</a> was a beautiful but unrealistic approximation of a truly discrete world, Kolmogorov chose a finitely <a class="uri" href="differentiable" title="wikilink">differentiable</a> tapering window with finite support, and created this mathematical construction for the discrete case<sup>[1]</sup>. The KZ filter is robust and nearly optimal. Because its operation is a simple Moving Average (MA), the KZ filter performs well in a missing data environment, especially in multidimensional time series where missing data problem arises from spatial sparseness. Another nice feature of the KZ filter is that the two parameters have clear interpretation so that it can be easily adopted by specialists in different areas. A few software packages for time series, longitudinal and spatial data have been developed in the popular statistical software R, which facilitate the use of the KZ filter and its extensions in different areas.</p>
<h2 id="definition">Definition</h2>

<p><strong>KZ Filter</strong></p>

<p>Let 

<math display="inline" id="Kolmogorov–Zurbenko_filter:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>X</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>t</mi>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mo>±</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo>±</mo>
     <mn>2</mn>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <list>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>t</ci>
      </apply>
      <ci>t</ci>
     </list>
     <cn type="integer">0</cn>
    </apply>
    <list>
     <apply>
      <csymbol cd="latexml">plus-or-minus</csymbol>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">plus-or-minus</csymbol>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {X(t)},t=0,\pm 1,\pm 2,\dots
  </annotation>
 </semantics>
</math>

 be a <a href="Real-valued_function" title="wikilink">real-valued</a> <a href="time_series" title="wikilink">time series</a>, the KZ filter with <a href="parameter" title="wikilink">parameters</a> 

<math display="inline" id="Kolmogorov–Zurbenko_filter:1">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Kolmogorov–Zurbenko_filter:2">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is defined as</p>

<p>

<math display="inline" id="Kolmogorov–Zurbenko_filter:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <msub>
     <mi>Z</mi>
     <mrow>
      <mi>m</mi>
      <mo>,</mo>
      <mi>k</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>X</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>s</mi>
      <mo>=</mo>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mrow>
         <mi>k</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>m</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
     </mrow>
     <mrow>
      <mrow>
       <mi>k</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>m</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </munderover>
    <mrow>
     <mrow>
      <mi>X</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>t</mi>
        <mo>+</mo>
        <mi>s</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>×</mo>
     <msubsup>
      <mi>a</mi>
      <mi>s</mi>
      <mrow>
       <mi>m</mi>
       <mo>,</mo>
       <mi>k</mi>
      </mrow>
     </msubsup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <list>
       <ci>m</ci>
       <ci>k</ci>
      </list>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>s</ci>
        <apply>
         <minus></minus>
         <apply>
          <divide></divide>
          <apply>
           <times></times>
           <ci>k</ci>
           <apply>
            <minus></minus>
            <ci>m</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>k</ci>
        <apply>
         <minus></minus>
         <ci>m</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>X</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <ci>s</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>s</ci>
       </apply>
       <list>
        <ci>m</ci>
        <ci>k</ci>
       </list>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   KZ_{m,k}[X(t)]=\sum\limits_{s=-k(m-1)/2}^{k(m-1)/2}{X(t+s)\times{a_{s}^{m,k}}}
  </annotation>
 </semantics>
</math>

</p>

<p>where coefficients</p>

<p>

<math display="inline" id="Kolmogorov–Zurbenko_filter:4">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>a</mi>
     <mi>s</mi>
     <mrow>
      <mi>m</mi>
      <mo>,</mo>
      <mi>k</mi>
     </mrow>
    </msubsup>
    <mo>=</mo>
    <mfrac>
     <msubsup>
      <mi>c</mi>
      <mi>s</mi>
      <mrow>
       <mi>k</mi>
       <mo>,</mo>
       <mi>m</mi>
      </mrow>
     </msubsup>
     <msup>
      <mi>m</mi>
      <mi>k</mi>
     </msup>
    </mfrac>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>s</mi>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>k</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>m</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mn>2</mn>
     </mfrac>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mfrac>
      <mrow>
       <mi>k</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>m</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mn>2</mn>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>s</ci>
      </apply>
      <list>
       <ci>m</ci>
       <ci>k</ci>
      </list>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>s</ci>
       </apply>
       <list>
        <ci>k</ci>
        <ci>m</ci>
       </list>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>m</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>s</ci>
     <list>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>k</ci>
         <apply>
          <minus></minus>
          <ci>m</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>k</ci>
        <apply>
         <minus></minus>
         <ci>m</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{s}^{m,k}=\frac{c_{s}^{k,m}}{m^{k}},s=\frac{-k(m-1)}{2},\dots,\frac{k(m-1)}{2}
  </annotation>
 </semantics>
</math>

 are given by the <a class="uri" href="polynomial" title="wikilink">polynomial</a> <a href="coefficient" title="wikilink">coefficients</a> obtained from equation</p>

<p>

<math display="inline" id="Kolmogorov–Zurbenko_filter:5">
 <semantics>
  <mrow>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>r</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>k</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>m</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </munderover>
    <mrow>
     <msup>
      <mi>z</mi>
      <mi>r</mi>
     </msup>
     <msubsup>
      <mi>c</mi>
      <mrow>
       <mi>r</mi>
       <mo>-</mo>
       <mrow>
        <mrow>
         <mi>k</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>m</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
      <mrow>
       <mi>k</mi>
       <mo>,</mo>
       <mi>m</mi>
      </mrow>
     </msubsup>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>+</mo>
      <mi>z</mi>
      <mo>+</mo>
      <mi mathvariant="normal">…</mi>
      <mo>+</mo>
      <msup>
       <mi>z</mi>
       <mrow>
        <mi>m</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>k</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>r</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>k</ci>
       <apply>
        <minus></minus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <ci>r</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <apply>
         <minus></minus>
         <ci>r</ci>
         <apply>
          <divide></divide>
          <apply>
           <times></times>
           <ci>k</ci>
           <apply>
            <minus></minus>
            <ci>m</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
       <list>
        <ci>k</ci>
        <ci>m</ci>
       </list>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <ci>z</ci>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>z</ci>
       <apply>
        <minus></minus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum\limits_{r=0}^{k(m-1)}{z^{r}c_{r-k(m-1)/2}^{k,m}=(1+z+\dots+z^{m-1})^{k}}
  </annotation>
 </semantics>
</math>

</p>

<p>From another point of view, the KZ filter with parameters 

<math display="inline" id="Kolmogorov–Zurbenko_filter:6">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Kolmogorov–Zurbenko_filter:7">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 can be defined as 

<math display="inline" id="Kolmogorov–Zurbenko_filter:8">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 time iterations of a moving average (MA) filter of 

<math display="inline" id="Kolmogorov–Zurbenko_filter:9">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 points. It can be obtained through iterations.</p>

<p>First iteration is to apply a MA filter over process 

<math display="inline" id="Kolmogorov–Zurbenko_filter:10">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(t)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Kolmogorov–Zurbenko_filter:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <msub>
     <mi>Z</mi>
     <mrow>
      <mrow>
       <mi>m</mi>
       <mo>,</mo>
       <mi>k</mi>
      </mrow>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>X</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>s</mi>
      <mo>=</mo>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>m</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
     </mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>m</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </munderover>
    <mrow>
     <mrow>
      <mi>X</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>t</mi>
        <mo>+</mo>
        <mi>s</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>×</mo>
     <mfrac>
      <mn>1</mn>
      <mi>m</mi>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Z</ci>
      <apply>
       <eq></eq>
       <list>
        <ci>m</ci>
        <ci>k</ci>
       </list>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>s</ci>
        <apply>
         <minus></minus>
         <apply>
          <divide></divide>
          <apply>
           <minus></minus>
           <ci>m</ci>
           <cn type="integer">1</cn>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>X</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <ci>s</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   KZ_{m,k=1}[X(t)]=\sum\limits_{s=-(m-1)/2}^{(m-1)/2}{X(t+s)}\times\frac{1}{m}
  </annotation>
 </semantics>
</math>

</p>

<p>The second iteration is to apply the MA operation to the result of the first iteration,</p>

<p>

<math display="inline" id="Kolmogorov–Zurbenko_filter:12">
 <semantics>
  <mtable>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mrow>
       <mi>K</mi>
       <msub>
        <mi>Z</mi>
        <mrow>
         <mrow>
          <mi>m</mi>
          <mo>,</mo>
          <mi>k</mi>
         </mrow>
         <mo>=</mo>
         <mn>2</mn>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">[</mo>
        <mrow>
         <mi>X</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">]</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>s</mi>
         <mo>=</mo>
         <mrow>
          <mo>-</mo>
          <mrow>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>m</mi>
             <mo>-</mo>
             <mn>1</mn>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
           <mo>/</mo>
           <mn>2</mn>
          </mrow>
         </mrow>
        </mrow>
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>m</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>/</mo>
         <mn>2</mn>
        </mrow>
       </munderover>
       <mrow>
        <mrow>
         <mi>K</mi>
         <msub>
          <mi>Z</mi>
          <mrow>
           <mrow>
            <mi>m</mi>
            <mo>,</mo>
            <mi>k</mi>
           </mrow>
           <mo>=</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mrow>
          <mo stretchy="false">[</mo>
          <mrow>
           <mi>X</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>t</mi>
             <mo>+</mo>
             <mi>s</mi>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
          <mo stretchy="false">]</mo>
         </mrow>
        </mrow>
        <mo>×</mo>
        <mfrac>
         <mn>1</mn>
         <mi>m</mi>
        </mfrac>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
   <mtr>
    <mtd columnalign="left">
     <mrow>
      <mi></mi>
      <mo>=</mo>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>s</mi>
         <mo>=</mo>
         <mrow>
          <mo>-</mo>
          <mrow>
           <mrow>
            <mn>2</mn>
            <mrow>
             <mo stretchy="false">(</mo>
             <mrow>
              <mi>m</mi>
              <mo>-</mo>
              <mn>1</mn>
             </mrow>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo>/</mo>
           <mn>2</mn>
          </mrow>
         </mrow>
        </mrow>
        <mrow>
         <mrow>
          <mn>2</mn>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>m</mi>
            <mo>-</mo>
            <mn>1</mn>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>/</mo>
         <mn>2</mn>
        </mrow>
       </munderover>
       <mrow>
        <mrow>
         <mi>X</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>t</mi>
           <mo>+</mo>
           <mi>s</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>×</mo>
        <msubsup>
         <mi>a</mi>
         <mi>s</mi>
         <mrow>
          <mrow>
           <mi>m</mi>
           <mo>,</mo>
           <mi>k</mi>
          </mrow>
          <mo>=</mo>
          <mn>2</mn>
         </mrow>
        </msubsup>
       </mrow>
      </mrow>
     </mrow>
    </mtd>
   </mtr>
  </mtable>
  <annotation-xml encoding="MathML-Content">
   <matrix>
    <matrixrow>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>K</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Z</ci>
        <apply>
         <eq></eq>
         <list>
          <ci>m</ci>
          <ci>k</ci>
         </list>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">delimited-[]</csymbol>
        <apply>
         <times></times>
         <ci>X</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>s</ci>
          <apply>
           <minus></minus>
           <apply>
            <divide></divide>
            <apply>
             <minus></minus>
             <ci>m</ci>
             <cn type="integer">1</cn>
            </apply>
            <cn type="integer">2</cn>
           </apply>
          </apply>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <minus></minus>
          <ci>m</ci>
          <cn type="integer">1</cn>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <times></times>
         <ci>K</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>Z</ci>
          <apply>
           <eq></eq>
           <list>
            <ci>m</ci>
            <ci>k</ci>
           </list>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <times></times>
           <ci>X</ci>
           <apply>
            <plus></plus>
            <ci>t</ci>
            <ci>s</ci>
           </apply>
          </apply>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <ci>m</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </matrixrow>
    <matrixrow>
     <apply>
      <eq></eq>
      <csymbol cd="latexml">absent</csymbol>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>s</ci>
          <apply>
           <minus></minus>
           <apply>
            <divide></divide>
            <apply>
             <times></times>
             <cn type="integer">2</cn>
             <apply>
              <minus></minus>
              <ci>m</ci>
              <cn type="integer">1</cn>
             </apply>
            </apply>
            <cn type="integer">2</cn>
           </apply>
          </apply>
         </apply>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <apply>
           <minus></minus>
           <ci>m</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <times></times>
         <ci>X</ci>
         <apply>
          <plus></plus>
          <ci>t</ci>
          <ci>s</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <ci>s</ci>
         </apply>
         <apply>
          <eq></eq>
          <list>
           <ci>m</ci>
           <ci>k</ci>
          </list>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </matrixrow>
   </matrix>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{array}[]{l}KZ_{m,k=2}[X(t)]=\sum\limits_{s=-(m-1)/2}^{(m-1)/2}{KZ_{m,k=%
1}[X(t+s)]\times\frac{1}{m}}\\
=\sum\limits_{s=-2(m-1)/2}^{2(m-1)/2}{X(t+s)\times{a_{s}^{m,k=2}}}\end{array}
  </annotation>
 </semantics>
</math>

</p>

<p>Generally the <em>kth</em> iteration is an application of the MA filter to the <em>(k-1)th</em> iteration. The iteration process of a simple operation of MA is very convenient computationally.</p>
<h2 id="properties">Properties</h2>

<p>The impulse response function of the product of filters is the convolution of impulse responses. The coefficients of the KZ filter <mtpl></mtpl>, can be interpreted as a <a href="Distribution_(mathematics)" title="wikilink">distribution</a> obtained by the <a class="uri" href="convolution" title="wikilink">convolution</a> of <em>k</em> uniform discrete distributions on the interval 

<math display="inline" id="Kolmogorov–Zurbenko_filter:13">
 <semantics>
  <mrow>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>m</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>m</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <minus></minus>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <ci>m</ci>
      <cn type="integer">1</cn>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -(m-1)/2,(m-1)/2
  </annotation>
 </semantics>
</math>

 where <em>m</em> is an odd integer. Therefore, the coefficient <mtpl></mtpl> forms a <a href="Tapering_(mathematics)" title="wikilink">tapering window</a> which has <a href="finite_support" title="wikilink">finite support</a> 

<math display="inline" id="Kolmogorov–Zurbenko_filter:14">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>m</mi>
      <mi mathvariant="normal">−</mi>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>k</mi>
   </mrow>
   <mo>+</mo>
   <mn>11</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>normal-−</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>k</ci>
    </apply>
    <cn type="integer">11</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (m−1)k+11
  </annotation>
 </semantics>
</math>

. The KZ filter <mtpl></mtpl> has main weight concentrated on a length of <mtpl></mtpl> with weights vanishing to zero outside. The impulse response function of the KZ filter has 

<math display="inline" id="Kolmogorov–Zurbenko_filter:15">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mi mathvariant="normal">−</mi>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>k</ci>
    <ci>normal-−</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k−2
  </annotation>
 </semantics>
</math>

 continuous derivatives and is asymptotically Gaussian distributed. Zero derivatives at the edges for the <a href="impulse_response_function" title="wikilink">impulse response function</a> make from it a sharply declining function, what is resolving in high frequency resolution. The energy <a href="transfer_function" title="wikilink">transfer function</a> of the KZ filter is</p>

<p>

<math display="inline" id="Kolmogorov–Zurbenko_filter:16">
 <semantics>
  <mrow>
   <msup>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <msub>
       <mi>B</mi>
       <mrow>
        <mi>m</mi>
        <mo>,</mo>
        <mi>k</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ω</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mn>2</mn>
   </msup>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo>{</mo>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mi>m</mi>
      </mfrac>
      <mfrac>
       <mrow>
        <mi>sin</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>π</mi>
          <mi>m</mi>
          <mi>ω</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mi>sin</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>π</mi>
          <mi>ω</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
     </mrow>
     <mo>}</mo>
    </mrow>
    <mrow>
     <mn>2</mn>
     <mi>k</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <list>
         <ci>m</ci>
         <ci>k</ci>
        </list>
       </apply>
       <ci>ω</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <set>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <ci>m</ci>
       </apply>
       <apply>
        <divide></divide>
        <apply>
         <sin></sin>
         <apply>
          <times></times>
          <ci>π</ci>
          <ci>m</ci>
          <ci>ω</ci>
         </apply>
        </apply>
        <apply>
         <sin></sin>
         <apply>
          <times></times>
          <ci>π</ci>
          <ci>ω</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </set>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |B_{m,k}(\omega)|^{2}=\left\{\frac{1}{m}\frac{\sin(\pi m\omega)}{\sin(\pi%
\omega)}\right\}^{2k}
  </annotation>
 </semantics>
</math>

.</p>

<p>It is a low-pass filter with a cut-off frequency of 

<math display="inline" id="Kolmogorov–Zurbenko_filter:17">
 <semantics>
  <mrow>
   <msub>
    <mi>ω</mi>
    <mn>0</mn>
   </msub>
   <mo>≈</mo>
   <mrow>
    <mfrac>
     <msqrt>
      <mn>6</mn>
     </msqrt>
     <mi>π</mi>
    </mfrac>
    <msqrt>
     <mfrac>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mn>1</mn>
          <mo>/</mo>
          <mn>2</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mrow>
          <mn>1</mn>
          <mo>/</mo>
          <mn>2</mn>
         </mrow>
         <mi>k</mi>
        </mrow>
       </msup>
      </mrow>
      <mrow>
       <msup>
        <mi>m</mi>
        <mn>2</mn>
       </msup>
       <mo>-</mo>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mn>1</mn>
          <mo>/</mo>
          <mn>2</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mrow>
          <mn>1</mn>
          <mo>/</mo>
          <mn>2</mn>
         </mrow>
         <mi>k</mi>
        </mrow>
       </msup>
      </mrow>
     </mfrac>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <root></root>
       <cn type="integer">6</cn>
      </apply>
      <ci>π</ci>
     </apply>
     <apply>
      <root></root>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <times></times>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <cn type="integer">2</cn>
          </apply>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>m</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <times></times>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <cn type="integer">2</cn>
          </apply>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{0}\approx\frac{\sqrt{6}}{\pi}\sqrt{\frac{1-(1/2)^{1/2k}}{m^{2}-(1/2)^{%
1/2k}}}
  </annotation>
 </semantics>
</math>

.</p>

<p> Compared to a MA filter, the KZ filter has much better performance in terms of attenuating the frequency components above the cutoff frequency. The KZ filter is essentially a repetitive MA filter. It is easy to compute and allows for a straight forward way to deal with missing data. The main piece of this procedure is a simple average of available information within the interval of m points disregarding the missing observations within the interval. The same idea can be easily extended to spatial data analysis. It has been shown that missing values have very little effect on the transfer function of the KZ filter.</p>

<p>Arbitrary <em>k</em> will provide <em>k</em> power of this transfer function and will reduce side lobe value to <mtpl></mtpl>. It will be a perfect low pass filter. For practical purposes a choice of <em>k</em> within a range 3 to 5 is usually sufficient, when regular MA <em>(k=1)</em> is providing strong spectral leakage of about 5%.</p>
<h2 id="optimality">Optimality</h2>

<p>The KZ filter is robust and nearly optimal. Because its operation is a simple moving average, the KZ filter performs well in a missing data environment, especially in multidimensional time and space where missing data can cause problems arising from spatial sparseness. Another nice feature of the KZ filter is that the two parameters each have clear interpretations so that it can be easily adopted by specialists in different areas. Software implementations for time series, longitudinal and spatial data have been developed in the popular statistical package <a href="R_(programming_language)" title="wikilink">R</a>, which facilitate the use of the KZ filter and its extensions in different areas.</p>

<p>KZ filter can be used to smooth the <a class="uri" href="periodogram" title="wikilink">periodogram</a>. For a class of <a href="stochastic_process" title="wikilink">stochastic processes</a>, Zurbenko<sup>[1]</sup> considered the worst-case scenario where the only information available about a process is its spectral density and smoothness quantified by <a href="Hölder_condition" title="wikilink">Hölder condition</a>. He derived the optimal bandwidth of the spectral window, which is dependent upon the underlying smoothness of the spectral density. Zurbenko<sup>[1]</sup> compared the performance of Kolmogorov-Zurbenko (KZ) window to the other typically used spectral windows including <a href="Bartlett_window" title="wikilink">Bartlett window</a>, <a href="Parzen_window" title="wikilink">Parzen window</a>, <a href="Hamming_window" title="wikilink">Tukey-Hamming window</a> and uniform window and showed that the result from KZ window is closest to optimum.</p>

<p>Developed as an abstract discrete construction, KZ filtration is robust and statistically nearly optimal<sup>[1]</sup>. At the same time, because of its natural form, it has computational advantages, permitting analysis of space/time problems with data that has much as 90% of observations missing, and which represent a messy combination of several different physical phenomena<sup>[2]</sup>. Clear answers can often be found for "unsolvable" problems.<sup>[2],[3]</sup> Unlike some mathematical developments, KZ is adaptable by specialists in different areas because it has a clear physical interpretation behind it.<sup>[2],[3],[4],[5]</sup></p>
<h2 id="extensions">Extensions</h2>

<p> </p>

<p>Extensions of KZ filter include KZ adaptive (KZA) filter<sup>[1]</sup>, spatial KZ filter and KZ Fourier transform (KZFT). Yang and Zurbenko<sup>[2]</sup> provided a detailed review of KZ filter and its extensions. R packages are also available to implement KZ filtration<sup>[3],[4],[5],[6][10][11]</sup>.</p>

<p><strong>KZFT</strong></p>

<p>KZFT filter is design for a reconstruction of periodic signals or seasonality covered by heavy noise. Seasonality is one of the key forms of nonstationarity that is often seen in time series. It is usually defined as the periodic components within the time series. Spectral analysis is a powerful tool to analyze time series with seasonality. If a process is stationary, its spectrum is a continuous form as well. It can be treated parametrically for simplicity of prediction. If a spectrum contains lines, it indicates that the process is not stationary and contains periodicities. In this situation, parametric fitting generally results in seasonal residuals with reduced energies. This is due to the season to season variations. To avoid this problem, nonparametric approaches including band pass filters are recommended<sup>[3]</sup>. Kolmogorov-Zurbenko Fourier Transform (KZFT) is one of such filters. The purpose of many applications is to reconstruct high resolution wavelet from the noisy environment. It was proven that KZFT provides the best possible resolution in spectral domain. It permits the separation of two signals on the edge of a theoretically smallest distance, or reconstruct periodic signals covered by heavy noise and irregularly observed in time<sup>[3],[7]</sup> .Because of this, KZFT provides a unique opportunity for various applications. A computer algorithm to implement the KZFT has been provided in the R software<sup>[4],[5]</sup> .The KZFT is essentially a band pass filter that belongs to the category of <a href="Short-time_Fourier_transform" title="wikilink">Short-time Fourier transform</a> (STFT) with a unique time window.</p>

<p>KZFT readily uncovers small deviations from a constant spectral density of <a href="white_noise" title="wikilink">white noise</a> resulting from computer <a href="Random_number_generation" title="wikilink">random numbers generator</a>. Such computer random number generations become predictable in the long run. <a href="Kolmogorov_complexity" title="wikilink">Kolmogorov complexity</a> provides the opportunity to generate unpredictable sequences of random numbers, as shown in the paper<sup>[12]</sup>.</p>

<p>Formally, we have a process <mtpl></mtpl>,<mtpl> ...,-1,0,1,...}}</mtpl> , the KZFT filter with parameters <em>m</em> and <em>k</em>, computed at frequency ν<sub>0</sub> , produces an output process , which is defined as following:</p>

<p>

<math display="inline" id="Kolmogorov–Zurbenko_filter:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mi>Z</mi>
    <mi>F</mi>
    <msub>
     <mi>T</mi>
     <mrow>
      <mi>m</mi>
      <mo>,</mo>
      <mi>k</mi>
      <mo>,</mo>
      <msub>
       <mi>ν</mi>
       <mn>0</mn>
      </msub>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>X</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>s</mi>
      <mo>=</mo>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mrow>
         <mi>k</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>m</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
     </mrow>
     <mrow>
      <mrow>
       <mi>k</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>m</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </munderover>
    <mrow>
     <mrow>
      <mi>X</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>t</mi>
        <mo>+</mo>
        <mi>s</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>×</mo>
     <msubsup>
      <mi>a</mi>
      <mi>s</mi>
      <mrow>
       <mi>m</mi>
       <mo>,</mo>
       <mi>k</mi>
      </mrow>
     </msubsup>
     <mo>×</mo>
     <msup>
      <mi>e</mi>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mi>i</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mn>2</mn>
          <mi>m</mi>
          <msub>
           <mi>ν</mi>
           <mn>0</mn>
          </msub>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>s</mi>
       </mrow>
      </mrow>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <ci>Z</ci>
     <ci>F</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <list>
       <ci>m</ci>
       <ci>k</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ν</ci>
        <cn type="integer">0</cn>
       </apply>
      </list>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>X</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>s</ci>
        <apply>
         <minus></minus>
         <apply>
          <divide></divide>
          <apply>
           <times></times>
           <ci>k</ci>
           <apply>
            <minus></minus>
            <ci>m</ci>
            <cn type="integer">1</cn>
           </apply>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>k</ci>
        <apply>
         <minus></minus>
         <ci>m</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>X</ci>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <ci>s</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>s</ci>
       </apply>
       <list>
        <ci>m</ci>
        <ci>k</ci>
       </list>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>i</ci>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>m</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>ν</ci>
           <cn type="integer">0</cn>
          </apply>
         </apply>
         <ci>s</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   KZFT_{m,k,\nu_{0}}[X(t)]=\sum\limits_{s=-k(m-1)/2}^{k(m-1)/2}{X(t+s)\times{a_{%
s}^{m,k}\times{e^{-i(2m\nu_{0})s}}}}
  </annotation>
 </semantics>
</math>

</p>

<p>where <mtpl></mtpl> is defined as: <mtpl>  }}</mtpl>, <mtpl>  }}</mtpl>,...,<mtpl></mtpl> and the polynomial coefficients <mtpl></mtpl> is given by <mtpl> (<em>1</em>+<em>z</em>+...+<em>z</em><sup>(m-1)</sup>)<sup><em>k</em></sup> }}</mtpl>. Apparently <mtpl></mtpl> filter is equivalent to the application of <mtpl></mtpl> filter to the process <mtpl></mtpl>. Similarly, the KZFT filter can be obtained through iterations in the same way as KZ filter.</p>

<p>The average of the square of KZFT in time over S periods of <mtpl>  }}</mtpl> will provide an estimate of the square amplitude of the wave at frequency ν<sub>0</sub> or KZ periodogram (KZP) based on 2Sρ<sub>0</sub> observations around moment t:</p>

<p>

<math display="inline" id="Kolmogorov–Zurbenko_filter:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>K</mi>
    <mi>Z</mi>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo>,</mo>
     <mi>m</mi>
     <mo>,</mo>
     <mi>k</mi>
     <mo>,</mo>
     <msub>
      <mi>ν</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mrow>
        <mn>2</mn>
        <mi>S</mi>
        <msub>
         <mi>ρ</mi>
         <mn>0</mn>
        </msub>
       </mrow>
      </mfrac>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>τ</mi>
         <mo>=</mo>
         <mrow>
          <mo>-</mo>
          <mrow>
           <mi>S</mi>
           <msub>
            <mi>ρ</mi>
            <mn>0</mn>
           </msub>
          </mrow>
         </mrow>
        </mrow>
        <mrow>
         <mi>S</mi>
         <msub>
          <mi>ρ</mi>
          <mn>0</mn>
         </msub>
        </mrow>
       </munderover>
       <mrow>
        <mn>2</mn>
        <mi>R</mi>
        <mi>e</mi>
        <msup>
         <mrow>
          <mo stretchy="false">[</mo>
          <mrow>
           <mi>K</mi>
           <mi>Z</mi>
           <mi>F</mi>
           <msub>
            <mi>T</mi>
            <mrow>
             <mi>m</mi>
             <mo>,</mo>
             <mi>k</mi>
             <mo>,</mo>
             <mrow>
              <mi>ν</mi>
              <mo>+</mo>
              <mn>0</mn>
             </mrow>
            </mrow>
           </msub>
           <mrow>
            <mo stretchy="false">[</mo>
            <mrow>
             <mi>X</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <mrow>
               <mi>τ</mi>
               <mo>+</mo>
               <mi>t</mi>
              </mrow>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
            <mo stretchy="false">]</mo>
           </mrow>
          </mrow>
          <mo stretchy="false">]</mo>
         </mrow>
         <mn>2</mn>
        </msup>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>K</ci>
     <ci>Z</ci>
     <ci>P</ci>
     <vector>
      <ci>t</ci>
      <ci>m</ci>
      <ci>k</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ν</ci>
       <cn type="integer">0</cn>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>S</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>ρ</ci>
          <cn type="integer">0</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>τ</ci>
           <apply>
            <minus></minus>
            <apply>
             <times></times>
             <ci>S</ci>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>ρ</ci>
              <cn type="integer">0</cn>
             </apply>
            </apply>
           </apply>
          </apply>
         </apply>
         <apply>
          <times></times>
          <ci>S</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>ρ</ci>
           <cn type="integer">0</cn>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>R</ci>
         <ci>e</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="latexml">delimited-[]</csymbol>
           <apply>
            <times></times>
            <ci>K</ci>
            <ci>Z</ci>
            <ci>F</ci>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>T</ci>
             <list>
              <ci>m</ci>
              <ci>k</ci>
              <apply>
               <plus></plus>
               <ci>ν</ci>
               <cn type="integer">0</cn>
              </apply>
             </list>
            </apply>
            <apply>
             <csymbol cd="latexml">delimited-[]</csymbol>
             <apply>
              <times></times>
              <ci>X</ci>
              <apply>
               <plus></plus>
               <ci>τ</ci>
               <ci>t</ci>
              </apply>
             </apply>
            </apply>
           </apply>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   KZP(t,m,k,\nu_{0})=2|\frac{1}{2S\rho_{0}}\sum\limits_{\tau=-S\rho_{0}}^{S\rho_%
{0}}2Re[KZFT_{m,k,\nu+{0}}[X(\tau+t)]]^{2}|
  </annotation>
 </semantics>
</math>

</p>

<p>Transfer function of KZFT is provided in Figure 2 has a very sharp frequency resolution with bandwidth limited by 

<math display="inline" id="Kolmogorov–Zurbenko_filter:20">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>/</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>m</mi>
     <msqrt>
      <mi>k</mi>
     </msqrt>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>c</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <apply>
      <root></root>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c/(m\sqrt{k})
  </annotation>
 </semantics>
</math>

. For a complex-valued process <mtpl> <em>e</em><sup><em>i(2mν<sub>0</sub>)t</em></sup> }}</mtpl>, the <mtpl></mtpl> outcome is unchanged. For a real-valued process, it distributes energy evenly over the real and complex domains. In other words, <mtpl></mtpl> reconstructs a cosine or sine wave at the same frequency ν<sub>0</sub>. It follows that <mtpl></mtpl> correctly reconstructs the amplitude and phase of an unknown wave with frequency ν<sub>0</sub>. Figure below is providing power transfer function of KZFT filtration. It clearly display that it perfectly captured frequency of interest ν<sub>0</sub> = 0.4 and provide practically no spectral leakage from a side lobes which control by parameter <em>k</em> of filtration. For practical purposes choice of <em>k</em> within range 3-5 is usually sufficient, when regular FFT (k=1) is providing strong leakage of about 5%.</p>

<p><strong>Example:</strong> Simulated Signal<br/>


<math display="inline" id="Kolmogorov–Zurbenko_filter:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>s</mi>
    <mi>i</mi>
    <mi>n</mi>
    <mn>2</mn>
    <mi>π</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0.10</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>t</mi>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mrow>
     <mi>s</mi>
     <mi>i</mi>
     <mi>n</mi>
     <mn>2</mn>
     <mi>π</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0.02</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>t</mi>
    </mrow>
    <mo>+</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>i</ci>
     <ci>n</ci>
     <cn type="integer">2</cn>
     <ci>π</ci>
     <cn type="float">0.10</cn>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">limit-from</csymbol>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>i</ci>
      <ci>n</ci>
      <cn type="integer">2</cn>
      <ci>π</ci>
      <cn type="float">0.02</cn>
      <ci>t</ci>
     </apply>
     <plus></plus>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   sin2π(0.10)t+sin2π(0.02)t+
  </annotation>
 </semantics>
</math>

 normal random noise N(0,16) was used to test the KZFT algorithm’s ability to accurately determine spectra of datasets with missing values. For practical considerations, the percentage of missing values was used at p=70% to determine if the spectrum could continue to capture the dominant frequencies. Using a wider window length of m=600 and k=3 iterations, adaptively smoothed KZP algorithm was used to determine the spectrum for the simulated longitudinal dataset. It is apparent in Figure 3 that the dominant frequencies of 0.08 and 0.10 cycles per unit time are identifiable as the signal’s inherent frequencies.</p>

<p>KZFT reconstruction of original signal embedded in the high noise of longitudinal observations ( missing rate 60%.) The KZFT filter in the KZA package of R-software has a parameter f=frequency. By defining this parameter for each of the known dominant frequencies found in the spectrum, KZFT filter with parameters m=300 and k=3 to reconstruct the signal about each frequency (0.08 and 0.10 cycles per unit time). The reconstructed signal was determined by applying the KZFT filter twice (once about each dominant frequency) and then the summing the results of each filter. The correlation between the true signal and the reconstructed signal was 96.4%; displayed in figure 4. The original observations provide no guess of the complex, hidden periodicity, which was perfectly reconstructed by the algorithm.</p>

<p>Raw data frequently contain hidden frequencies. Combinations of a few fixed frequency waves can complicate the recognition of the mixture of signals, but still remain predictable over time. Publications [3],[7] show that atmospheric pressure contains hidden periodicities resulting from the gravitational force of the moon and the daily period of the sun. The reconstruction of these periodic signals of atmospheric tidal waves allows for an explanation and prediction of many anomalies present in extreme weather. Similar tidal waves must exist on the sun resulting from the gravitational force of planets. The rotation of the sun around its axes will cause a current, similar to the equatorial current on the earth. Perturbations or eddies around the current will cause anomalies on the surface of the sun. Horizontal rotational eddies in highly magnetic plasma will create a vertical explosion which will transport deeper, hotter plasma to above the surface of the sun. Each planet creates a tidal wave with a specific frequency on the sun. At times any two of the waves will occur in phase and other times will be out of phase. The resulting amplitude will oscillate with a difference frequency. The estimation of the spectra of sunspot data using the DZ algorithm [3],[7] provides two sharp frequency lines with periodicities close to 9.9 and 11.7 years. These frequency lines can be considered as difference frequencies caused by Jupiter and Saturn (9.9) and Venus and Earth (11.7). The difference frequency between 9.9 and 11.7 yields a frequency with a 64-year period. All of these periods are identifiable in sunspot data. The 64-year period component is currently in a declining mode [3],[6] . This decline may cause a cooling effect on the earth in the near future. An examination of the joint effect of multiple planets may reveal some long periods in sun activity and help explain climate fluctuations on earth.</p>

<p><strong>KZA</strong></p>

<p>  Adaptive version of KZ filter, called KZ adaptive (KZA) filter, was developed for a search of breaks in nonparametric signals covered by heavy noise.. The KZA filter first identifies potential time intervals when a break occurs. It then examines these time intervals more carefully by reducing the window size so that the resolution of the smoothed outcome increases.</p>

<p>As an example of break point detection, we simulate a long-term trend containing a break buried in seasonality and noise. Figure 2 is a plot of a seasonal sine wave with amplitude of 1 unit, normally distributed noise (

<math display="inline" id="Kolmogorov–Zurbenko_filter:22">
 <semantics>
  <mrow>
   <mi>σ</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>σ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   σ=1
  </annotation>
 </semantics>
</math>

), and a base signal with a break. To make things more challenging, the base signal contains an overall downward trend of 1 unit and an upward break of 0.5 units. The downward trend and break are hardly visible in the original data. The base signal is a step function 

<math display="inline" id="Kolmogorov–Zurbenko_filter:23">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mn>7300</mn>
     </mfrac>
     <mi>t</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>s</mi>
     <mi>i</mi>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
       <mi>t</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">7300</cn>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>i</ci>
      <ci>n</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=\frac{-1}{7300}t+sin(2πt)
  </annotation>
 </semantics>
</math>

, with 

<math display="inline" id="Kolmogorov–Zurbenko_filter:24">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mn>7300</mn>
     </mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>t</mi>
       <mo>-</mo>
       <mn>3452</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>s</mi>
     <mi>i</mi>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>2</mn>
       <mi>π</mi>
       <mi>t</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <cn type="integer">7300</cn>
      </apply>
      <apply>
       <minus></minus>
       <ci>t</ci>
       <cn type="integer">3452</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>i</ci>
      <ci>n</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>π</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=\frac{-1}{7300}(t-3452)+sin(2πt)
  </annotation>
 </semantics>
</math>

</p>

<p> The KZA algorithm has all of the typical advantages of a nonparametric approach; it does not require any specific model of the time series under investigation. It searches for sudden changes over a low frequency signal of any nature covered by heavy noise. KZA shows very high sensitivity for break detection, even with a very low signal-to-noise ratio; the accuracy of the detection of the time of the break is also very high.</p>

<p>The KZA algorithm can be applied to restore noisy two-dimensional images. This could be a two-level function f(x,y) as a black-and-white picture damaged by strong noise, or a multilevel color picture. KZA can be applied line by line to detect the break (change of color), then the break points at different lines would be smoothed by the regular KZ filter<sup>[3]</sup>. Demonstration of spatial KZA is provided in Figure 7.</p>

<p>Determinations of sharp frequency lines in the spectra can be determine by adaptively smoothed periodogram <sup>[3],[5]</sup> . The central idea of the algorithm is adaptively smoothing the logarithm of a KZ periodogram. The range of smoothing is provided by some fixed percentage of <a href="conditional_entropy" title="wikilink">conditional entropy</a> from total <a href="Entropy_(information_theory)" title="wikilink">entropy</a>. Roughly speaking, the algorithm operates uniformly on an information scale rather than a frequency scale. This algorithm is also known for parameter k=1 in KZP as Dirienzo-Zurbenko algorithm and provided in software<sup>[4]</sup>.</p>

<p><strong>Spatial KZ Filter</strong></p>

<p>Spatial KZ filter can be applied to the variable recorded in time and space. Parameters of the filter can be chosen separately in time and space. Usually physical sense can be applied what scale of averaging is reasonable in space and what scale of averaging is reasonable in time. Parameter k is controlling sharpness of resolution of the filter or suppression of leak of frequencies. An algorithms for spatial KZ filter are available in R software. Outcome time parameter can be treated as virtual time, then images of results of filtration in space can be displayed as "movie" in virtual time. We may demonstrate application of 3D spatial KZ filter applied to the world records of temperature T(t, x, y) as a function of time t , longitude x and latitude y. To select Global climate fluctuations component parameters 25 month for time t, 3° for longitude and latitude were chosen<sup>[8]</sup> for KZ filtration. Parameter k were chosen equal 5 to accommodate resolutions of scales. Single slide of outcome "movie" is provided in Figure 8 below. Standard average cosine square temperature distribution low<sup>[6],[8]</sup> along latitudes were subtracted to identify fluctuations of climate in time and space.</p>
<figure><b>(Figure)</b>
<figcaption>Figure 8: Global Long-term Component on December 2007 KZ filter m = (3°, 3°, 25 months), k=5, adjusted for latitude and altitude effects.</figcaption>
</figure>

<p>We can see anomalies of temperature fluctuations from cosine square law over globe for 2007. Temperature anomalies are displayed over globe in the provided in figure scale on the right. It displays very high positive anomaly over Europe and North Africa, which were extending over last 100 years. Those anomalies are slowly changing in time in the outcome "movie" of KZ filtration, slow intensification of observed anomalies were identified in time. Different scales fluctuations like El Niño scale and others are also can be identified<sup>[6],[8]</sup> by spatial KZ filtration. High definition "movie" of those scales are provided in<sup>[6]</sup> over North America. Different scales can be selected by KZ filtration for a different variable and corresponding multivariate analysis [3], [7],[11]</p>

<p>can provide high efficiency results for investigating outcome variable over other covariates. KZ filter resolution performs exceptionally well compare to conventional methods and in fact is computationally optimal.</p>

<p>Maps of the concentration of atmospheric absolute humidity [8] display the vital role in the transmission of energy over the planet. Tropical areas permanently generate enormous amounts of humid vapor, which forces the air mass to expand to higher latitudes. As the expanded air mass reaches middle latitudes, Coriolis forces will push the air mass to the East to form the jet stream. The North American continent partially interrupts the expansion in spring and early summer and allows the diving pattern of the jet stream. This pattern creates a high risk of extreme weather formations in North America, such as tornados and floods [9].</p>
<h2 id="implementations">Implementations</h2>

<p>[1] R implementation of Brian Close and Igor Zurbenko (http://cran.r-project.org/web/packages/kza/)<br/>
[2] KZ and KZA Java implementation for 1-dimensional arrays of Andreas Weiler and Michael Grossniklaus (University of Konstanz, Germany) (http://dbis.uni-konstanz.de/research/social-media-stream-analysis/)</p>
<h2 id="references">References</h2>

<p>[1] I. Zurbenko. The Spectral Analysis of Time Series. North-Holland Series in Statistics and Probability, 1986.<br/>
[2] I. Zurbenko, P. Porter, S. Rao, J. Ku, R. Gui, and R. Eskridge. Detecting discontinuities in time series of upper air data: Development and demonstration of an adaptive filter technique. Journal of Climate, 9:3548-3560,1996.<br/>
[3] W. Yang and I. Zurbenko. Kolmogorov–Zurbenko filters. WIREs Comp Stat, 2:340-351, 2010.<br/>
[4] W. Yang and I. Zurbenko. kzft: Kolmogorov-Zurbenko Fourier transform and application. R package, 2006.<br/>
[5] B. Close and I. Zurbenko. kza: Kolmogorov-Zurbenko adaptive algorithm for the image detection. R package, 2013.<br/>
[6] I.G. Zurbenko and D.D. Cyr. Climate fluctuations in time and space. Clim Res, 46:67-76, 2011, Vol. 57: 93–94, 2013, doi: 10.3354/cr01168.<br/>
[7] I.G. Zurbenko and A.L. Potrzeba. Tides in the Atmosphere, Air Quality, Atmosphere and Health, March 2013, Volume 6, Issue 1, pp 39-46. DOI: 10.1007/s11869-011-0143-6. <a class="uri" href="http://www.springerlink.com/content/e124604331626295">http://www.springerlink.com/content/e124604331626295</a> Periods of excess energy in extreme weather events, Journal of Climatology, Volume 2013, <a class="uri" href="http://dx.doi.org/10.1155/2013/410898">http://dx.doi.org/10.1155/2013/410898</a></p>

<p>[8] Zurbenko, I. and Luo, M. (2015) Surface Humidity Changes in Different Temporal Scales. American Journal of Climate Change, 4, 226-238. doi: 10.4236/ajcc.2015.43018. Igor Zurbenko, Ming Luo, Restoration of Time-Spatial Scales in Global Temperature Data, American Journal of Climate Change, 2012, Vol.1,3, p. 154-163, <a class="uri" href="doi:10.4236/ajcc.2012">doi:10.4236/ajcc.2012</a>.<br/>
[9] Igor G. Zurbenko, Mingzeng Sun, Associations of Jet Streams with Tornado Outbreaks in the North America, Atmospheric and Climate Sciences, , 5, 336-344. <a class="uri" href="http://dx.doi.org/10.4236/acs.2015.53026">http://dx.doi.org/10.4236/acs.2015.53026</a>.</p>

<p>[10] B.Close, I.Zurbenko, Kolmogorov-Zurbenko adaptive algorithm, Proceedings JSM, 2011<br/>
[11] Edward Valachovic, Igor Zurbenko, Solar Irradiation and the Annual Component of Skin Cancer Incidence, Biometrics &amp; Biostatistics International Journal, 2014, 1,3, <a class="uri" href="http://medcraveonline.com/BBIJ/articles-in-press">http://medcraveonline.com/BBIJ/articles-in-press</a></p>

<p>K.Tsakiri, I.Zurbenko, 2011, Prediction of Ozone Concentrations using Atmospheric Variables, Journal Air Quality, Atmosphere &amp; Health, Volume 4, Number 2, 111-120, DOI: 10.1007/s11869-010-0084-5</p>

<p>[12] I.G. Zurbenko, On Weakly Correlated Random Number Generators, Journal of Statistical Computation and Simulation, 1993, 47:79-88.</p>

<p>"</p>

<p><a href="Category:Time_series_analysis" title="wikilink">Category:Time series analysis</a> <a href="Category:Filter_theory" title="wikilink">Category:Filter theory</a></p>
</body>
</html>
