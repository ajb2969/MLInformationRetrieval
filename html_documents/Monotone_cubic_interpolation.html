<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="365">Monotone cubic interpolation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Monotone cubic interpolation</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In the <a href="mathematics" title="wikilink">mathematical</a> subfield of <a href="numerical_analysis" title="wikilink">numerical analysis</a>, <strong>monotone cubic interpolation</strong> is a variant of <a href="cubic_interpolation" title="wikilink">cubic interpolation</a> that preserves <a href="Monotone_function" title="wikilink">monotonicity</a> of the <a href="data_set" title="wikilink">data set</a> being interpolated.</p>

<p>Monotonicity is preserved by <a href="linear_interpolation" title="wikilink">linear interpolation</a> but not guaranteed by <a href="cubic_interpolation" title="wikilink">cubic interpolation</a>.</p>
<h2 id="monotone-cubic-hermite-interpolation">Monotone cubic Hermite interpolation</h2>

<p> Monotone interpolation can be accomplished using <a href="cubic_Hermite_spline" title="wikilink">cubic Hermite spline</a> with the tangents 

<math display="inline" id="Monotone_cubic_interpolation:0">
 <semantics>
  <msub>
   <mi>m</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{i}
  </annotation>
 </semantics>
</math>

 modified to ensure the monotonicity of the resulting Hermite spline.</p>

<p>An algorithm is also available for monotone <a href="quintic_function" title="wikilink">quintic</a> Hermite interpolation.</p>
<h3 id="interpolant-selection">Interpolant selection</h3>

<p>There are several ways of selecting interpolating tangents for each data point. This section will outline the use of the Fritsch–Carlson method.</p>

<p>Let the data points be 

<math display="inline" id="Monotone_cubic_interpolation:1">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>x</mi>
    <mi>k</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mi>k</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>k</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{k},y_{k})
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Monotone_cubic_interpolation:2">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=1,...,n
  </annotation>
 </semantics>
</math>

</p>
<ol>
<li>Compute the slopes of the <a href="secant_line" title="wikilink">secant lines</a> between successive points:
<blockquote>

<p>

<math display="inline" id="Monotone_cubic_interpolation:3">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Δ</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>y</mi>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>y</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mrow>
     <msub>
      <mi>x</mi>
      <mrow>
       <mi>k</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>-</mo>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Δ</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <apply>
        <plus></plus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta_{k}=\frac{y_{k+1}-y_{k}}{x_{k+1}-x_{k}}
  </annotation>
 </semantics>
</math>

</p>
</blockquote>

<p>for 

<math display="inline" id="Monotone_cubic_interpolation:4">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=1,\dots,n-1
  </annotation>
 </semantics>
</math>

.</p></li>
<li>Initialize the tangents at every data point as the average of the secants,
<blockquote>

<p>

<math display="inline" id="Monotone_cubic_interpolation:5">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi mathvariant="normal">Δ</mi>
      <mrow>
       <mi>k</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>+</mo>
     <msub>
      <mi mathvariant="normal">Δ</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mn>2</mn>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Δ</ci>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Δ</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{k}=\frac{\Delta_{k-1}+\Delta_{k}}{2}
  </annotation>
 </semantics>
</math>

</p>
</blockquote>

<p>for 

<math display="inline" id="Monotone_cubic_interpolation:6">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <list>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=2,\dots,n-1
  </annotation>
 </semantics>
</math>

; if 

<math display="inline" id="Monotone_cubic_interpolation:7">
 <semantics>
  <msub>
   <mi mathvariant="normal">Δ</mi>
   <mrow>
    <mi>k</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Δ</ci>
    <apply>
     <minus></minus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta_{k-1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Monotone_cubic_interpolation:8">
 <semantics>
  <msub>
   <mi mathvariant="normal">Δ</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Δ</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta_{k}
  </annotation>
 </semantics>
</math>

 have different sign, set 

<math display="inline" id="Monotone_cubic_interpolation:9">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>k</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{k}=0
  </annotation>
 </semantics>
</math>

. These may be updated in further steps. For the endpoints, use one-sided differences:</p>
<blockquote>

<p>

<math display="inline" id="Monotone_cubic_interpolation:10">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>m</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi mathvariant="normal">Δ</mi>
      <mn>1</mn>
     </msub>
     <mtext>and</mtext>
    </mrow>
   </mrow>
   <mrow>
    <msub>
     <mi>m</mi>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi mathvariant="normal">Δ</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <cn type="integer">1</cn>
     </apply>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Δ</ci>
       <cn type="integer">1</cn>
      </apply>
      <mtext>and</mtext>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Δ</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{1}=\Delta_{1}\quad\text{and}\quad m_{n}=\Delta_{n-1}
  </annotation>
 </semantics>
</math>

</p>
</blockquote></li>
<li>For 

<math display="inline" id="Monotone_cubic_interpolation:11">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=1,\dots,n-1
  </annotation>
 </semantics>
</math>

, if 

<math display="inline" id="Monotone_cubic_interpolation:12">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Δ</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Δ</ci>
     <ci>k</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta_{k}=0
  </annotation>
 </semantics>
</math>

 (if two successive 

<math display="inline" id="Monotone_cubic_interpolation:13">
 <semantics>
  <mrow>
   <msub>
    <mi>y</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>y</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}=y_{k+1}
  </annotation>
 </semantics>
</math>

 are equal), then set 

<math display="inline" id="Monotone_cubic_interpolation:14">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>m</mi>
     <mi>k</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mi>m</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{k}=m_{k+1}=0,
  </annotation>
 </semantics>
</math>

 as the spline connecting these points must be flat to preserve monotonicity. Ignore step 4 and 5 for those 

<math display="inline" id="Monotone_cubic_interpolation:15">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

.</li>
<li>Let 

<math display="inline" id="Monotone_cubic_interpolation:16">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>m</mi>
     <mi>k</mi>
    </msub>
    <mo>/</mo>
    <msub>
     <mi mathvariant="normal">Δ</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Δ</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{k}=m_{k}/\Delta_{k}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Monotone_cubic_interpolation:17">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>m</mi>
     <mrow>
      <mi>k</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>/</mo>
    <msub>
     <mi mathvariant="normal">Δ</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <apply>
       <plus></plus>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Δ</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{k}=m_{k+1}/\Delta_{k}
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Monotone_cubic_interpolation:18">
 <semantics>
  <msub>
   <mi>α</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>α</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{k}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Monotone_cubic_interpolation:19">
 <semantics>
  <msub>
   <mi>β</mi>
   <mrow>
    <mi>k</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <apply>
     <minus></minus>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{k-1}
  </annotation>
 </semantics>
</math>

 are computed to be less than zero, then the input data points are not strictly monotone, and 

<math display="inline" id="Monotone_cubic_interpolation:20">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>x</mi>
    <mi>k</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>y</mi>
    <mi>k</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>k</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{k},y_{k})
  </annotation>
 </semantics>
</math>

 is a local extremum. In such cases, piecewise monotone curves can still be generated by choosing 

<math display="inline" id="Monotone_cubic_interpolation:21">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>k</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{k}=0
  </annotation>
 </semantics>
</math>

, although global strict monotonicity is not possible.</li>
<li>To prevent <a class="uri" href="overshoot" title="wikilink">overshoot</a> and ensure monotonicity, at least one of the following conditions must be met:
<ol>
<li>the function
<blockquote>

<p>

<math display="inline" id="Monotone_cubic_interpolation:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>α</mi>
     <mo>,</mo>
     <mi>β</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>α</mi>
    <mo>-</mo>
    <mfrac>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mrow>
          <mn>2</mn>
          <mi>α</mi>
         </mrow>
         <mo>+</mo>
         <mi>β</mi>
        </mrow>
        <mo>-</mo>
        <mn>3</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mrow>
      <mn>3</mn>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>α</mi>
         <mo>+</mo>
         <mi>β</mi>
        </mrow>
        <mo>-</mo>
        <mn>2</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <interval closure="open">
      <ci>α</ci>
      <ci>β</ci>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <ci>α</ci>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <plus></plus>
         <apply>
          <times></times>
          <cn type="integer">2</cn>
          <ci>α</ci>
         </apply>
         <ci>β</ci>
        </apply>
        <cn type="integer">3</cn>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <cn type="integer">3</cn>
       <apply>
        <minus></minus>
        <apply>
         <plus></plus>
         <ci>α</ci>
         <ci>β</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(\alpha,\beta)=\alpha-\frac{(2\alpha+\beta-3)^{2}}{3(\alpha+\beta-2)}
  </annotation>
 </semantics>
</math>

</p>
</blockquote>

<p>must have a value greater than or equal to zero;</p></li>
<li>

<math display="inline" id="Monotone_cubic_interpolation:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>α</mi>
     <mo>+</mo>
     <mrow>
      <mn>2</mn>
      <mi>β</mi>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mn>3</mn>
   </mrow>
   <mo>≤</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <ci>α</ci>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>β</ci>
      </apply>
     </apply>
     <cn type="integer">3</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha+2\beta-3\leq 0
  </annotation>
 </semantics>
</math>

; or</li>
<li>

<math display="inline" id="Monotone_cubic_interpolation:24">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mn>2</mn>
      <mi>α</mi>
     </mrow>
     <mo>+</mo>
     <mi>β</mi>
    </mrow>
    <mo>-</mo>
    <mn>3</mn>
   </mrow>
   <mo>≤</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <ci>α</ci>
      </apply>
      <ci>β</ci>
     </apply>
     <cn type="integer">3</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\alpha+\beta-3\leq 0
  </annotation>
 </semantics>
</math>

.</li>
</ol></li>
</ol>

<p>If monotonicity must be strict then 

<math display="inline" id="Monotone_cubic_interpolation:25">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>α</mi>
    <mo>,</mo>
    <mi>β</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <interval closure="open">
     <ci>α</ci>
     <ci>β</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(\alpha,\beta)
  </annotation>
 </semantics>
</math>

 must have a value strictly greater than zero.</p>

<p>One simple way to satisfy this constraint is to restrict the magnitude of vector 

<math display="inline" id="Monotone_cubic_interpolation:26">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>α</mi>
    <mi>k</mi>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>β</mi>
    <mi>k</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>k</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\alpha_{k},\beta_{k})
  </annotation>
 </semantics>
</math>

 to a circle of radius 3. That is, if 

<math display="inline" id="Monotone_cubic_interpolation:27">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>α</mi>
     <mi>k</mi>
     <mn>2</mn>
    </msubsup>
    <mo>+</mo>
    <msubsup>
     <mi>β</mi>
     <mi>k</mi>
     <mn>2</mn>
    </msubsup>
   </mrow>
   <mo>></mo>
   <mn>9</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>k</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>k</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <cn type="integer">9</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{k}^{2}+\beta_{k}^{2}>9
  </annotation>
 </semantics>
</math>

, then set 

<math display="inline" id="Monotone_cubic_interpolation:28">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>τ</mi>
     <mi>k</mi>
    </msub>
    <msub>
     <mi>α</mi>
     <mi>k</mi>
    </msub>
    <msub>
     <mi mathvariant="normal">Δ</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Δ</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{k}=\tau_{k}\alpha_{k}\Delta_{k}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Monotone_cubic_interpolation:29">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mrow>
     <mi>k</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>τ</mi>
     <mi>k</mi>
    </msub>
    <msub>
     <mi>β</mi>
     <mi>k</mi>
    </msub>
    <msub>
     <mi mathvariant="normal">Δ</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <apply>
      <plus></plus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>τ</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Δ</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{k+1}=\tau_{k}\beta_{k}\Delta_{k}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Monotone_cubic_interpolation:30">
 <semantics>
  <mrow>
   <msub>
    <mi>τ</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mn>3</mn>
    <msqrt>
     <mrow>
      <msubsup>
       <mi>α</mi>
       <mi>k</mi>
       <mn>2</mn>
      </msubsup>
      <mo>+</mo>
      <msubsup>
       <mi>β</mi>
       <mi>k</mi>
       <mn>2</mn>
      </msubsup>
     </mrow>
    </msqrt>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>τ</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <cn type="integer">3</cn>
     <apply>
      <root></root>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>α</ci>
         <ci>k</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>β</ci>
         <ci>k</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tau_{k}=\frac{3}{\sqrt{\alpha_{k}^{2}+\beta_{k}^{2}}}
  </annotation>
 </semantics>
</math>

.</p>

<p>Alternatively it is sufficient to restrict 

<math display="inline" id="Monotone_cubic_interpolation:31">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mi>k</mi>
   </msub>
   <mo>≤</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>k</ci>
    </apply>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{k}\leq 3
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Monotone_cubic_interpolation:32">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mi>k</mi>
   </msub>
   <mo>≤</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <ci>k</ci>
    </apply>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{k}\leq 3
  </annotation>
 </semantics>
</math>

. To accomplish this if 

<math display="inline" id="Monotone_cubic_interpolation:33">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mi>k</mi>
   </msub>
   <mo>></mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>k</ci>
    </apply>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{k}>3
  </annotation>
 </semantics>
</math>

, then set 

<math display="inline" id="Monotone_cubic_interpolation:34">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mn>3</mn>
    <mo>×</mo>
    <msub>
     <mi mathvariant="normal">Δ</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <cn type="integer">3</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Δ</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{k}=3\times\Delta_{k}
  </annotation>
 </semantics>
</math>

. Similarly for 

<math display="inline" id="Monotone_cubic_interpolation:35">
 <semantics>
  <mi>β</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>β</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta
  </annotation>
 </semantics>
</math>

.</p>

<p>Note that only one pass of the algorithm is required.</p>
<h3 id="cubic-interpolation">Cubic interpolation</h3>

<p>After the preprocessing, evaluation of the interpolated spline is equivalent to <a href="cubic_Hermite_spline" title="wikilink">cubic Hermite spline</a>, using the data 

<math display="inline" id="Monotone_cubic_interpolation:36">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Monotone_cubic_interpolation:37">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Monotone_cubic_interpolation:38">
 <semantics>
  <msub>
   <mi>m</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{k}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Monotone_cubic_interpolation:39">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=1,...,n
  </annotation>
 </semantics>
</math>

.</p>

<p>To evaluate at 

<math display="inline" id="Monotone_cubic_interpolation:40">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, find the smallest value larger than 

<math display="inline" id="Monotone_cubic_interpolation:41">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Monotone_cubic_interpolation:42">
 <semantics>
  <msub>
   <mi>x</mi>
   <mtext>upper</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <mtext>upper</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{\text{upper}}
  </annotation>
 </semantics>
</math>

, and the largest value smaller than 

<math display="inline" id="Monotone_cubic_interpolation:43">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Monotone_cubic_interpolation:44">
 <semantics>
  <msub>
   <mi>x</mi>
   <mtext>lower</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <mtext>lower</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{\text{lower}}
  </annotation>
 </semantics>
</math>

, among 

<math display="inline" id="Monotone_cubic_interpolation:45">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{k}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Monotone_cubic_interpolation:46">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mtext>lower</mtext>
   </msub>
   <mo>≤</mo>
   <mi>x</mi>
   <mo>≤</mo>
   <msub>
    <mi>x</mi>
    <mtext>upper</mtext>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <mtext>lower</mtext>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <mtext>upper</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{\text{lower}}\leq x\leq x_{\text{upper}}
  </annotation>
 </semantics>
</math>

. Calculate</p>

<p>

<math display="block" id="Monotone_cubic_interpolation:47">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mtext>upper</mtext>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>x</mi>
     <mtext>lower</mtext>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>h</ci>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <mtext>upper</mtext>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <mtext>lower</mtext>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h=x_{\text{upper}}-x_{\text{lower}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Monotone_cubic_interpolation:48">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>x</mi>
     <mo>-</mo>
     <msub>
      <mi>x</mi>
      <mtext>lower</mtext>
     </msub>
    </mrow>
    <mi>h</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>t</ci>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <mtext>lower</mtext>
      </apply>
     </apply>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=\frac{x-x_{\text{lower}}}{h}
  </annotation>
 </semantics>
</math>

 then the interpolant is</p>

<p>

<math display="block" id="Monotone_cubic_interpolation:49">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mtext>interpolated</mtext>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>y</mi>
      <mtext>lower</mtext>
     </msub>
     <msub>
      <mi>h</mi>
      <mn>00</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>h</mi>
     <msub>
      <mi>m</mi>
      <mtext>lower</mtext>
     </msub>
     <msub>
      <mi>h</mi>
      <mn>10</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mtext>upper</mtext>
     </msub>
     <msub>
      <mi>h</mi>
      <mn>01</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>h</mi>
     <msub>
      <mi>m</mi>
      <mtext>upper</mtext>
     </msub>
     <msub>
      <mi>h</mi>
      <mn>11</mn>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <mtext>interpolated</mtext>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <mtext>lower</mtext>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <cn type="integer">00</cn>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <mtext>lower</mtext>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <cn type="integer">10</cn>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <mtext>upper</mtext>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <cn type="integer">01</cn>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <mtext>upper</mtext>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>h</ci>
       <cn type="integer">11</cn>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{\text{interpolated}}(x)=y_{\text{lower}}h_{00}(t)+hm_{\text{lower}}h_{10}(t%
)+y_{\text{upper}}h_{01}(t)+hm_{\text{upper}}h_{11}(t)
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Monotone_cubic_interpolation:50">
 <semantics>
  <msub>
   <mi>h</mi>
   <mrow>
    <mi>i</mi>
    <mi>i</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{ii}
  </annotation>
 </semantics>
</math>

 are the basis functions for the <a href="cubic_Hermite_spline" title="wikilink">cubic Hermite spline</a>.</p>
<h2 id="example-implementation">Example implementation</h2>

<p>The following <a class="uri" href="JavaScript" title="wikilink">JavaScript</a> implementation takes a data set and produces a monotone cubic spline interpolant function:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">/* Monotone cubic spline interpolation</span>
<span class="co">   Usage example:</span>
<span class="co">    var f = createInterpolant([0, 1, 2, 3, 4], [0, 1, 4, 9, 16]);</span>
<span class="co">    var message = '';</span>
<span class="co">    for (var x = 0; x &lt;= 4; x += 0.5) {</span>
<span class="co">        var xSquared = f(x);</span>
<span class="co">        message += x + ' squared is about ' + xSquared + '\n';</span>
<span class="co">    }</span>
<span class="co">    alert(message);</span>
<span class="co">*/</span>
<span class="kw">var</span> createInterpolant <span class="op">=</span> <span class="kw">function</span>(xs<span class="op">,</span> ys) <span class="op">{</span>
    <span class="kw">var</span> i<span class="op">,</span> length <span class="op">=</span> <span class="va">xs</span>.<span class="at">length</span><span class="op">;</span>
    
    <span class="co">// Deal with length issues</span>
    <span class="cf">if</span> (length <span class="op">!=</span> <span class="va">ys</span>.<span class="at">length</span>) <span class="op">{</span> <span class="cf">throw</span> <span class="st">'Need an equal count of xs and ys.'</span><span class="op">;</span> <span class="op">}</span>
    <span class="cf">if</span> (length <span class="op">===</span> <span class="dv">0</span>) <span class="op">{</span> <span class="cf">return</span> <span class="kw">function</span>(x) <span class="op">{</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span> <span class="op">};</span> <span class="op">}</span>
    <span class="cf">if</span> (length <span class="op">===</span> <span class="dv">1</span>) <span class="op">{</span>
        <span class="co">// Impl: Precomputing the result prevents problems if ys is mutated later and allows garbage collection of ys</span>
        <span class="co">// Impl: Unary plus properly converts values to numbers</span>
        <span class="kw">var</span> result <span class="op">=</span> <span class="op">+</span>ys[<span class="dv">0</span>]<span class="op">;</span>
        <span class="cf">return</span> <span class="kw">function</span>(x) <span class="op">{</span> <span class="cf">return</span> result<span class="op">;</span> <span class="op">};</span>
    <span class="op">}</span>
    
    <span class="co">// Rearrange xs and ys so that xs is sorted</span>
    <span class="kw">var</span> indexes <span class="op">=</span> []<span class="op">;</span>
    <span class="cf">for</span> (i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> length<span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span> <span class="va">indexes</span>.<span class="at">push</span>(i)<span class="op">;</span> <span class="op">}</span>
    <span class="va">indexes</span>.<span class="at">sort</span>(<span class="kw">function</span>(a<span class="op">,</span> b) <span class="op">{</span> <span class="cf">return</span> xs[a] <span class="op">&lt;</span> xs[b] <span class="op">?</span> <span class="op">-</span><span class="dv">1</span> : <span class="dv">1</span><span class="op">;</span> <span class="op">}</span>)<span class="op">;</span>
    <span class="kw">var</span> oldXs <span class="op">=</span> xs<span class="op">,</span> oldYs <span class="op">=</span> ys<span class="op">;</span>
    <span class="co">// Impl: Creating new arrays also prevents problems if the input arrays are mutated later</span>
    xs <span class="op">=</span> []<span class="op">;</span> ys <span class="op">=</span> []<span class="op">;</span>
    <span class="co">// Impl: Unary plus properly converts values to numbers</span>
    <span class="cf">for</span> (i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> length<span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span> <span class="va">xs</span>.<span class="at">push</span>(<span class="op">+</span>oldXs[indexes[i]])<span class="op">;</span> <span class="va">ys</span>.<span class="at">push</span>(<span class="op">+</span>oldYs[indexes[i]])<span class="op">;</span> <span class="op">}</span>
    
    <span class="co">// Get consecutive differences and slopes</span>
    <span class="kw">var</span> dys <span class="op">=</span> []<span class="op">,</span> dxs <span class="op">=</span> []<span class="op">,</span> ms <span class="op">=</span> []<span class="op">;</span>
    <span class="cf">for</span> (i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> length <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span>
        <span class="kw">var</span> dx <span class="op">=</span> xs[i <span class="op">+</span> <span class="dv">1</span>] <span class="op">-</span> xs[i]<span class="op">,</span> dy <span class="op">=</span> ys[i <span class="op">+</span> <span class="dv">1</span>] <span class="op">-</span> ys[i]<span class="op">;</span>
        <span class="va">dxs</span>.<span class="at">push</span>(dx)<span class="op">;</span> <span class="va">dys</span>.<span class="at">push</span>(dy)<span class="op">;</span> <span class="va">ms</span>.<span class="at">push</span>(dy/dx)<span class="op">;</span>
    <span class="op">}</span>
    
    <span class="co">// Get degree-1 coefficients</span>
    <span class="kw">var</span> c1s <span class="op">=</span> [ms[<span class="dv">0</span>]]<span class="op">;</span>
    <span class="cf">for</span> (i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">dxs</span>.<span class="at">length</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span>
        <span class="kw">var</span> m <span class="op">=</span> ms[i]<span class="op">,</span> mNext <span class="op">=</span> ms[i <span class="op">+</span> <span class="dv">1</span>]<span class="op">;</span>
        <span class="cf">if</span> (m<span class="op">*</span>mNext <span class="op">&lt;=</span> <span class="dv">0</span>) <span class="op">{</span>
            <span class="va">c1s</span>.<span class="at">push</span>(<span class="dv">0</span>)<span class="op">;</span>
        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
            <span class="kw">var</span> dx <span class="op">=</span> dxs[i]<span class="op">,</span> dxNext <span class="op">=</span> dxs[i <span class="op">+</span> <span class="dv">1</span>]<span class="op">,</span> common <span class="op">=</span> dx <span class="op">+</span> dxNext<span class="op">;</span>
            <span class="va">c1s</span>.<span class="at">push</span>(<span class="dv">3</span><span class="op">*</span>common/((common <span class="op">+</span> dxNext)/m <span class="op">+</span> (common <span class="op">+</span> dx)/mNext))<span class="op">;</span>
        <span class="op">}</span>
    <span class="op">}</span>
    <span class="va">c1s</span>.<span class="at">push</span>(ms[<span class="va">ms</span>.<span class="at">length</span> <span class="op">-</span> <span class="dv">1</span>])<span class="op">;</span>
    
    <span class="co">// Get degree-2 and degree-3 coefficients</span>
    <span class="kw">var</span> c2s <span class="op">=</span> []<span class="op">,</span> c3s <span class="op">=</span> []<span class="op">;</span>
    <span class="cf">for</span> (i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">c1s</span>.<span class="at">length</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span>
        <span class="kw">var</span> c1 <span class="op">=</span> c1s[i]<span class="op">,</span> m <span class="op">=</span> ms[i]<span class="op">,</span> invDx <span class="op">=</span> <span class="dv">1</span>/dxs[i]<span class="op">,</span> common <span class="op">=</span> c1 <span class="op">+</span> c1s[i <span class="op">+</span> <span class="dv">1</span>] <span class="op">-</span> m <span class="op">-</span> m<span class="op">;</span>
        <span class="va">c2s</span>.<span class="at">push</span>((m <span class="op">-</span> c1 <span class="op">-</span> common)<span class="op">*</span>invDx)<span class="op">;</span> <span class="va">c3s</span>.<span class="at">push</span>(common<span class="op">*</span>invDx<span class="op">*</span>invDx)<span class="op">;</span>
    <span class="op">}</span>
    
    <span class="co">// Return interpolant function</span>
    <span class="cf">return</span> <span class="kw">function</span>(x) <span class="op">{</span>
        <span class="co">// The rightmost point in the dataset should give an exact result</span>
        <span class="kw">var</span> i <span class="op">=</span> <span class="va">xs</span>.<span class="at">length</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span>
        <span class="cf">if</span> (x <span class="op">==</span> xs[i]) <span class="op">{</span> <span class="cf">return</span> ys[i]<span class="op">;</span> <span class="op">}</span>
        
        <span class="co">// Search for the interval x is in, returning the corresponding y if x is one of the original xs</span>
        <span class="kw">var</span> low <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> mid<span class="op">,</span> high <span class="op">=</span> <span class="va">c3s</span>.<span class="at">length</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span>
        <span class="cf">while</span> (low <span class="op">&lt;=</span> high) <span class="op">{</span>
            mid <span class="op">=</span> <span class="va">Math</span>.<span class="at">floor</span>(<span class="fl">0.5</span><span class="op">*</span>(low <span class="op">+</span> high))<span class="op">;</span>
            <span class="kw">var</span> xHere <span class="op">=</span> xs[mid]<span class="op">;</span>
            <span class="cf">if</span> (xHere <span class="op">&lt;</span> x) <span class="op">{</span> low <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span>
            <span class="cf">else</span> <span class="cf">if</span> (xHere <span class="op">&gt;</span> x) <span class="op">{</span> high <span class="op">=</span> mid <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span>
            <span class="cf">else</span> <span class="op">{</span> <span class="cf">return</span> ys[mid]<span class="op">;</span> <span class="op">}</span>
        <span class="op">}</span>
        i <span class="op">=</span> <span class="va">Math</span>.<span class="at">max</span>(<span class="dv">0</span><span class="op">,</span> high)<span class="op">;</span>
        
        <span class="co">// Interpolate</span>
        <span class="kw">var</span> diff <span class="op">=</span> x <span class="op">-</span> xs[i]<span class="op">,</span> diffSq <span class="op">=</span> diff<span class="op">*</span>diff<span class="op">;</span>
        <span class="cf">return</span> ys[i] <span class="op">+</span> c1s[i]<span class="op">*</span>diff <span class="op">+</span> c2s[i]<span class="op">*</span>diffSq <span class="op">+</span> c3s[i]<span class="op">*</span>diff<span class="op">*</span>diffSq<span class="op">;</span>
    <span class="op">};</span>
<span class="op">};</span></code></pre></div>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="GPL" title="wikilink">GPLv</a>3 licensed <a class="uri" href="C++" title="wikilink">C++</a> implementation: <a href="https://github.com/OPM/opm-core/blob/master/opm/core/utility/MonotCubicInterpolator.cpp">MonotCubicInterpolator.cpp</a> <a href="https://github.com/OPM/opm-core/blob/master/opm/core/utility/MonotCubicInterpolator.hpp">MonotCubicInterpolator.hpp</a></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Interpolation" title="wikilink">Category:Interpolation</a> <a class="uri" href="Category:Splines" title="wikilink">Category:Splines</a></p>
</body>

