<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="67">Geohash</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Geohash</h1>
<hr/>

<p><strong>Geohash</strong> is a <a class="uri" href="latitude" title="wikilink">latitude</a>/<a class="uri" href="longitude" title="wikilink">longitude</a> <a href="Geocoding" title="wikilink">geocode</a> system invented by <a href="Gustavo_Niemeyer" title="wikilink">Gustavo Niemeyer</a> when writing the web service at <em><a href="http://geohash.org">geohash.org</a></em>, and put into the public domain. It is a hierarchical spatial data structure which subdivides space into buckets of <a href="Grid_(spatial_index)" title="wikilink">grid</a> shape.</p>

<p>Geohashes offer properties like arbitrary precision and the possibility of gradually removing characters from the end of the code to reduce its size (and gradually lose precision).</p>

<p>As a consequence of the gradual precision degradation, nearby places will often (but not always) present similar prefixes. The longer a shared prefix is, the closer the two places are.</p>
<h2 id="service">Service</h2>

<p>The purpose of the <em>geohash.org</em> service, launched in February 2008, is to offer short <a href="Uniform_Resource_Locator" title="wikilink">URLs</a> which uniquely identify positions on the <a class="uri" href="Earth" title="wikilink">Earth</a>, so that referencing them in <a href="email" title="wikilink">emails</a>, <a href="Internet_forum" title="wikilink">forums</a>, and <a href="website" title="wikilink">websites</a> is more convenient.</p>

<p>To obtain the Geohash, the user provides an address to be <a href="Geocoding" title="wikilink">geocoded</a>, or <a class="uri" href="latitude" title="wikilink">latitude</a> and <a class="uri" href="longitude" title="wikilink">longitude</a> coordinates, in a single input box (most commonly used formats for latitude and longitude pairs are accepted), and performs the request.</p>

<p>Besides showing the latitude and longitude corresponding to the given Geohash, users who navigate to a Geohash at geohash.org are also presented with an embedded map, and may download a <a href="GPX_(data_transfer)" title="wikilink">GPX</a> file, or transfer the waypoint directly to certain <a class="uri" href="GPS" title="wikilink">GPS</a> receivers. Links are also provided to external sites that may provide further details around the specified location.</p>

<p>For example, the coordinate pair <strong>57.64911,10.40744</strong> (near the tip of the <a class="uri" href="peninsula" title="wikilink">peninsula</a> of <a class="uri" href="Jutland" title="wikilink">Jutland</a>, in <a class="uri" href="Denmark" title="wikilink">Denmark</a>) produces a slightly shorter hash of <strong>u4pruydqqvj</strong>, which can be used in the URL <a class="uri" href="http://geohash.org/u4pruydqqvj">http://geohash.org/u4pruydqqvj</a></p>
<h2 id="uses">Uses</h2>

<p>The main usages of Geohashes are</p>
<ul>
<li>as a unique identifier.</li>
<li>represent point data e.g. in databases.</li>
</ul>

<p>Geohashes have also been proposed to be used for <a class="uri" href="geotagging" title="wikilink">geotagging</a>.</p>

<p>When used in a database, the structure of geohashed data has two advantages. First, data indexed by geohash will have all points for a given rectangular area in contiguous slices (the number of slices depends on the precision required and the presence of geohash "fault lines"). This is especially useful in database systems where queries on a single index are much easier or faster than multiple-index queries. Second, this index structure can be used for a quick-and-dirty proximity search - the closest points are often among the closest geohashes. Another system known as <a href="http://geozipcode.blogspot.com/2015/02/geozip.html">GeoZip</a> might provide a simpler way of achieving similar results if the application does not require the resulting code to be in a compressed format. This claim made by the GeoZip inventor has not been verified yet.</p>
<h2 id="example">Example</h2>

<p>Using the hash <em>ezs42</em> as an example, here is how it is decoded into a decimal latitude and longitude</p>
<h3 id="decode-from-base-32">Decode from base 32</h3>

<p>The first step is decoding it from <a href="Base32" title="wikilink">base 32</a> using the following character map:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Decimal</p></th>
<th style="text-align: left;">
<p>0</p></th>
<th style="text-align: left;">
<p>1</p></th>
<th style="text-align: left;">
<p>2</p></th>
<th style="text-align: left;">
<p>3</p></th>
<th style="text-align: left;">
<p>4</p></th>
<th style="text-align: left;">
<p>5</p></th>
<th style="text-align: left;">
<p>6</p></th>
<th style="text-align: left;">
<p>7</p></th>
<th style="text-align: left;">
<p>8</p></th>
<th style="text-align: left;">
<p>9</p></th>
<th style="text-align: left;">
<p>10</p></th>
<th style="text-align: left;">
<p>11</p></th>
<th style="text-align: left;">
<p>12</p></th>
<th style="text-align: left;">
<p>13</p></th>
<th style="text-align: left;">
<p>14</p></th>
<th style="text-align: left;">
<p>15</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Base 32</p></td>
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>8</p></td>
<td style="text-align: left;">
<p>9</p></td>
<td style="text-align: left;">
<p>b</p></td>
<td style="text-align: left;">
<p>c</p></td>
<td style="text-align: left;">
<p>d</p></td>
<td style="text-align: left;">
<p>e</p></td>
<td style="text-align: left;">
<p>f</p></td>
<td style="text-align: left;">
<p>g</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>style="font: 0.5em/0.5em serif;"  </p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Decimal</p></td>
<td style="text-align: left;">
<p>16</p></td>
<td style="text-align: left;">
<p>17</p></td>
<td style="text-align: left;">
<p>18</p></td>
<td style="text-align: left;">
<p>19</p></td>
<td style="text-align: left;">
<p>20</p></td>
<td style="text-align: left;">
<p>21</p></td>
<td style="text-align: left;">
<p>22</p></td>
<td style="text-align: left;">
<p>23</p></td>
<td style="text-align: left;">
<p>24</p></td>
<td style="text-align: left;">
<p>25</p></td>
<td style="text-align: left;">
<p>26</p></td>
<td style="text-align: left;">
<p>27</p></td>
<td style="text-align: left;">
<p>28</p></td>
<td style="text-align: left;">
<p>29</p></td>
<td style="text-align: left;">
<p>30</p></td>
<td style="text-align: left;">
<p>31</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Base 32</p></td>
<td style="text-align: left;">
<p>h</p></td>
<td style="text-align: left;">
<p>j</p></td>
<td style="text-align: left;">
<p>k</p></td>
<td style="text-align: left;">
<p>m</p></td>
<td style="text-align: left;">
<p>n</p></td>
<td style="text-align: left;">
<p>p</p></td>
<td style="text-align: left;">
<p>q</p></td>
<td style="text-align: left;">
<p>r</p></td>
<td style="text-align: left;">
<p>s</p></td>
<td style="text-align: left;">
<p>t</p></td>
<td style="text-align: left;">
<p>u</p></td>
<td style="text-align: left;">
<p>v</p></td>
<td style="text-align: left;">
<p>w</p></td>
<td style="text-align: left;">
<p>x</p></td>
<td style="text-align: left;">
<p>y</p></td>
<td style="text-align: left;">
<p>z</p></td>
</tr>
</tbody>
</table>

<p>This operation results in the <a href="bit" title="wikilink">bits</a> 01101 11111 11000 00100 00010. Assuming that counting starts at 0 in the left side, the even bits are taken for the longitude code (0111110000000), while the odd bits are taken for the latitude code (101111001001).</p>
<h3 id="decode-binary-to-decimal">Decode binary to decimal</h3>

<p>Each binary code is then used in a series of divisions, considering one bit at a time, again from the left to the right side. For the latitude value, the interval -90 to +90 is divided by 2, producing two intervals: -90 to 0, and 0 to +90. Since the first bit is 1, the higher interval is chosen, and becomes the current interval. The procedure is repeated for all bits in the code. Finally, the latitude value is the center of the resulting interval. Longitudes are processed in an equivalent way, keeping in mind that the initial interval is -180 to +180.</p>

<p>Finishing the procedure should yield approximately latitude 42.6 and longitude -5.6.</p>
<h3 id="worked-example">Worked example</h3>

<p>Here's a worked example decoding 101111001001 into 42.6. To start with, we know the latitude is somewhere in the range −90 to 90. With no bits, we'd have to guess the latitude was 0, giving us an error of ±90. With one bit, we can decide whether its in the range −90 to 0, or 0 to 90. The first bit is high, so we know our latitude is somewhere between 0 and 90. Without any more bits, we'd guess the latitude was 45, giving us an error of ±45.</p>

<p>Each subsequent bit halves this error. This table shows the effect of each bit. At each stage, the relevant half of the range is highlighted in green; a low bit selects the lower range, a high bit selects the upper range.</p>

<p>The last column shows the latitude, simply the mean value of the range. Each subsequent bit makes this value more precise.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>bit</p></th>
<th style="text-align: left;">
<p>min</p></th>
<th style="text-align: left;">
<p>mid</p></th>
<th style="text-align: left;">
<p>max</p></th>
<th style="text-align: left;">
<p>val</p></th>
<th style="text-align: left;">
<p>err</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>-90.000</p></td>
<td style="text-align: left;">
<p>0.000</p></td>
<td style="text-align: left;">
<p>90.000</p></td>
<td style="text-align: left;">
<p>45.000</p></td>
<td style="text-align: left;">
<p>45.000</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>0.000</p></td>
<td style="text-align: left;">
<p>45.000</p></td>
<td style="text-align: left;">
<p>90.000</p></td>
<td style="text-align: left;">
<p>22.500</p></td>
<td style="text-align: left;">
<p>22.500</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>0.000</p></td>
<td style="text-align: left;">
<p>22.500</p></td>
<td style="text-align: left;">
<p>45.000</p></td>
<td style="text-align: left;">
<p>33.750</p></td>
<td style="text-align: left;">
<p>11.250</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>22.500</p></td>
<td style="text-align: left;">
<p>33.750</p></td>
<td style="text-align: left;">
<p>45.000</p></td>
<td style="text-align: left;">
<p>39.375</p></td>
<td style="text-align: left;">
<p>5.625</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>33.750</p></td>
<td style="text-align: left;">
<p>39.375</p></td>
<td style="text-align: left;">
<p>45.000</p></td>
<td style="text-align: left;">
<p>42.188</p></td>
<td style="text-align: left;">
<p>2.813</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>39.375</p></td>
<td style="text-align: left;">
<p>42.188</p></td>
<td style="text-align: left;">
<p>45.000</p></td>
<td style="text-align: left;">
<p>43.594</p></td>
<td style="text-align: left;">
<p>1.406</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>42.188</p></td>
<td style="text-align: left;">
<p>43.594</p></td>
<td style="text-align: left;">
<p>45.000</p></td>
<td style="text-align: left;">
<p>42.891</p></td>
<td style="text-align: left;">
<p>0.703</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>42.188</p></td>
<td style="text-align: left;">
<p>42.891</p></td>
<td style="text-align: left;">
<p>43.594</p></td>
<td style="text-align: left;">
<p>42.539</p></td>
<td style="text-align: left;">
<p>0.352</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>42.188</p></td>
<td style="text-align: left;">
<p>42.539</p></td>
<td style="text-align: left;">
<p>42.891</p></td>
<td style="text-align: left;">
<p>42.715</p></td>
<td style="text-align: left;">
<p>0.176</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>42.539</p></td>
<td style="text-align: left;">
<p>42.715</p></td>
<td style="text-align: left;">
<p>42.891</p></td>
<td style="text-align: left;">
<p>42.627</p></td>
<td style="text-align: left;">
<p>0.088</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p>42.539</p></td>
<td style="text-align: left;">
<p>42.627</p></td>
<td style="text-align: left;">
<p>42.715</p></td>
<td style="text-align: left;">
<p>42.583</p></td>
<td style="text-align: left;">
<p>0.044</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>42.539</p></td>
<td style="text-align: left;">
<p>42.583</p></td>
<td style="text-align: left;">
<p>42.627</p></td>
<td style="text-align: left;">
<p>42.605</p></td>
<td style="text-align: left;">
<p>0.022</p></td>
</tr>
</tbody>
</table>

<p>(The numbers in the above table have been rounded to 3 decimal places for clarity)</p>

<p>Final rounding should be done carefully in a way that</p>

<p>

<math display="block" id="Geohash:0">
 <semantics>
  <mrow>
   <mi>min</mi>
   <mo>≤</mo>
   <mrow>
    <mi>round</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>v</mi>
      <mi>a</mi>
      <mi>l</mi>
      <mi>u</mi>
      <mi>e</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>max</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <min></min>
     <apply>
      <times></times>
      <ci>round</ci>
      <apply>
       <times></times>
       <ci>v</ci>
       <ci>a</ci>
       <ci>l</ci>
       <ci>u</ci>
       <ci>e</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <max></max>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min\leq\mathrm{round}(value)\leq\max
  </annotation>
 </semantics>
</math>

</p>

<p>So if rounding 42.605 to 42.61 or 42.6 is correct, rounding to 43 it is not.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>geohash length</p></th>
<th style="text-align: left;">
<p>lat bits</p></th>
<th style="text-align: left;">
<p>lng bits</p></th>
<th style="text-align: left;">
<p>lat error</p></th>
<th style="text-align: left;">
<p>lng error</p></th>
<th style="text-align: left;">
<p>km error</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>±23</p></td>
<td style="text-align: left;">
<p>±23</p></td>
<td style="text-align: left;">
<p>±2500</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>± 2.8</p></td>
<td style="text-align: left;">
<p>± 5.6</p></td>
<td style="text-align: left;">
<p>±630</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>8</p></td>
<td style="text-align: left;">
<p>± 0.70</p></td>
<td style="text-align: left;">
<p>± 0.7</p></td>
<td style="text-align: left;">
<p>±78</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>10</p></td>
<td style="text-align: left;">
<p>10</p></td>
<td style="text-align: left;">
<p>± 0.087</p></td>
<td style="text-align: left;">
<p>± 0.18</p></td>
<td style="text-align: left;">
<p>±20</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>12</p></td>
<td style="text-align: left;">
<p>13</p></td>
<td style="text-align: left;">
<p>± 0.022</p></td>
<td style="text-align: left;">
<p>± 0.022</p></td>
<td style="text-align: left;">
<p>±2.4</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;">
<p>15</p></td>
<td style="text-align: left;">
<p>15</p></td>
<td style="text-align: left;">
<p>± 0.0027</p></td>
<td style="text-align: left;">
<p>± 0.0055</p></td>
<td style="text-align: left;">
<p>±0.61</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>17</p></td>
<td style="text-align: left;">
<p>18</p></td>
<td style="text-align: left;">
<p>±0.00068</p></td>
<td style="text-align: left;">
<p>±0.00068</p></td>
<td style="text-align: left;">
<p>±0.076</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>8</p></td>
<td style="text-align: left;">
<p>20</p></td>
<td style="text-align: left;">
<p>20</p></td>
<td style="text-align: left;">
<p>±0.000085</p></td>
<td style="text-align: left;">
<p>±0.00017</p></td>
<td style="text-align: left;">
<p>±0.019</p></td>
</tr>
</tbody>
</table>
<h2 id="limitations">Limitations</h2>

<p>One limitation of the Geohash algorithm is in attempting to utilize it to find points in proximity to each other based on a common prefix. <a href="Edge_case" title="wikilink">Edge case</a> locations close to each other but on opposite sides of the 180 degree meridian will result in Geohash codes with no common prefix (different longitudes for near physical locations). Points close by at the North and South poles will have very different geohashes (different latitudes for near physical locations).</p>

<p>Two close locations on either side of the Equator (or Greenwich meridian) will not have a long common prefix since they belong to different 'halves' of the world. Put simply, one location's binary latitude (or longitude) will be 011111... and the other 100000...., so they will not have a common prefix and most bits will be flipped. This can also be seen as a consequence of relying on the <a href="Z-order_curve" title="wikilink">Z-order curve</a> for ordering the points, as two points close-by might be visited at very different times. However, two points with a long common prefix will be close-by.</p>

<p>In order to do a proximity search, one could compute the southwest corner (low geohash with low latitude and longitude) and northeast corner (high geohash with high latitude and longitude) of a bounding box and search for geohashes between those two. This will retrieve all points in the z-order curve between the two corners, which can be far too many points, this also breaks down at the 180 meridians and the poles. Solr uses a filter list of prefixes, by computing the prefixes of the nearest squares close to the geohash <a href="http://lucenerevolution.org/sites/default/files/Lucene%20Rev%20Preso%20Smiley%20Spatial%20Search.pdf">1</a>.</p>

<p>Thirdly, since a geohash (in this implementation) is based on <a href="Geographical_coordinate_system" title="wikilink">coordinates of longitude and latitude</a> the distance between two geohashes reflects the distance in latitude/longitude coordinates between two points, which does not translate to actual distance, see <a href="Haversine_formula" title="wikilink">Haversine formula</a>.</p>

<p>Example of non-linearity for latitude-longitude system:</p>
<ul>
<li>At the Equator (0 Degrees) the length of a degree of longitude is 111.320 km, while a degree of latitude measures 110.574 km, an error of 0.67%.</li>
<li>At 30 Degrees (Mid Latitudes) the error is 110.852/96.486 = 14.89%</li>
<li>At 60 Degrees (High Arctic) the error is 111.412/55.800 = 99.67%, reaching infinity at the poles.</li>
</ul>

<p>Note that these limitations are not due to geohashing, and not due to latitude-longitude coordinates, but due to the difficulty of mapping coordinates on a sphere (non linear and with wrapping of values, similar to modulo arithmetic) to two dimensional coordinates and the difficulty of exploring a two dimensional space uniformly. The first is related to <a href="Geographical_coordinate_system" title="wikilink">Geographical coordinate system</a> and <a href="Map_projection" title="wikilink">Map projection</a>, and the other to <a href="Hilbert_curve" title="wikilink">Hilbert curve</a> and <a href="z-order_curve" title="wikilink">z-order curve</a>. Once a coordinate system is found that represents points linearly in distance and wraps up at the edges, and can be explored uniformly, applying geohashing to those coordinates will not suffer from the limitations above.</p>

<p>While it is possible to apply geohashing to an area with a <a href="cartesian_coordinate_system" title="wikilink">cartesian coordinate system</a>, it would then only apply to the area where the coordinate system applies.</p>

<p>Despite those issues, there are possible workarounds, and the algorithm has been successfully used in Elasticsearch,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> MongoDB,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> HBase, and <a class="uri" href="Accumulo" title="wikilink">Accumulo</a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> to implement proximity searches.</p>

<p>An alternative to storing Geohashes as strings in a database are <a href="http://www.cs.umd.edu/~hjs/pubs/SametVisualComputer89.pdf">Locational codes</a>, which are also called spatial keys and similar to QuadTiles.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="license-and-patents">License and patents</h2>

<p>The Geohash geocode has been put in the <a href="public_domain" title="wikilink">public domain</a> by its inventor in the public announcement date, on February 26, 2008.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>While comparable algorithms have been successfully patented<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> and had copyright claimed upon,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> GeoHash is based on an entirely different algorithm and approach.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Geohash-36" title="wikilink">Geohash-36</a></li>
<li><a href="Grid_(spatial_index)" title="wikilink">Grid (spatial index)</a></li>
<li><a href="Morton_number_(number_theory)" title="wikilink">Morton number (number theory)</a></li>
<li><a href="Natural_Area_Code" title="wikilink">Natural Area Code</a></li>
<li><a href="Maidenhead_Locator_System" title="wikilink">Maidenhead Locator System</a></li>
<li><a href="Military_grid_reference_system" title="wikilink">Military grid reference system</a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://geohash.org">geohash.org</a></li>
<li><a href="http://www.elasticsearch.org/guide/en/elasticsearch/guide/current/geoloc.html">elasticsearch: the definitive guide - Geo</a></li>
<li><a href="http://www.bigdatamodeling.org/2013/01/intuitive-geohash.html">Visualizing Geohash</a></li>
<li>[<a class="uri" href="https://metacpan.org/module/Net">https://metacpan.org/module/Net</a>::Geohash Perl module to interact with geohash.org]</li>
<li>Libraries, packages and modules for encoding and decoding geohashes without interacting with geohash.org: <a href="https://github.com/lyokato/libgeohash">in C</a>, <a href="https://pypi.python.org/pypi/Geohash/">Python</a>, <a href="https://github.com/mariusaeriksen/geohash">Haskell</a>,</li>
</ul>

<p>[<a class="uri" href="https://metacpan.org/module/Geo">https://metacpan.org/module/Geo</a>::Hash Perl], <a href="http://geohash.rubyforge.org">Ruby (Gem)</a>, <a href="https://github.com/paulasmuth/redis_geohash/blob/master/lib/redis_geohash/geohash.rb">Ruby</a>, <a href="http://code.google.com/p/ocaml-geohash/">Ocaml</a>, <a href="https://clojars.org/geohash">Clojure</a>, <a href="https://github.com/the42/cartconvert/tree/master/cartconvert">Go</a>, <a href="https://github.com/lyokato/objc-geohash">Objective-C</a>, <a href="https://github.com/davetroy/geohash-js/">Javascript</a> (<a href="http://openlocation.org/geohash/geohash-js/">Demo</a>), <a href="http://blog.dixo.net/downloads/geohash-php-class/">PHP</a>, <a href="https://github.com/nowelium/geohash-mysql-func">MySQL</a>, <a href="http://www.postgis.org/docs/ST_GeoHash.html">PostGIS</a>, <a href="https://github.com/sunng87/node-geohash">nodejs</a>, <a href="https://github.com/maximveksler/GeohashKit">Swift</a></p>
<ul>
<li>Java classes for encoding and decoding geohashes: <a href="http://code.google.com/p/geospatialweb/source/browse/#svn/trunk/geohash/src">geospatialweb</a>, <a href="http://astrapi69.github.io/jgeohash/">jgeohash</a>, <a href="https://github.com/kungfoo/geohash-java">geohash-java</a>, and <a href="https://github.com/davidmoten/geo">geo</a></li>
<li><a href="http://api.prezzibenzina.it/geohash.kml">kml file for Google Earth displaying geohash grid</a></li>
<li><a href="http://geohash.2ch.to/">Area Check Tool</a></li>
<li><a href="http://www.geomesa.org">2</a> - <a class="uri" href="GeoMesa" title="wikilink">GeoMesa</a> - A spatio-temporal database using Geohashes and Accumulo</li>
<li><a href="http://geohash.co">Simple and fast conversion from geohash to latitude/longitude and from latitude/longitude to geohash</a></li>
</ul>
<h2 id="references">References</h2>

<p>{{-}} </p>

<p>"</p>

<p><a class="uri" href="Category:Geocodes" title="wikilink">Category:Geocodes</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/mapping-geo-shape-type.html">geo_shape Type Mapping in Elasticsearch</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="http://www.mongodb.org/display/DOCS/Geospatial+Indexing">Geospatial Indexing in MongoDB</a><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="http://geomesa.github.io/assets/outreach/SpatioTemporalIndexing_IEEEcopyright.pdf">Spatio-temporal Indexing in Non-relational Distributed Databases</a><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="http://karussell.wordpress.com/2012/05/23/spatial-keys-memory-efficient-geohashes/">Spatial Keys</a><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="http://wiki.openstreetmap.org/wiki/QuadTiles">QuadTiles</a><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="http://forums.groundspeak.com/GC/index.php?showtopic=186412">geohash.org announcement post in groundspeak.com forum</a><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="http://www.freepatentsonline.com/20050023524.html">Compact text encoding of latitude/longitude coordinates - Patent 20050023524</a><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="http://www.gps-practice-and-fun.com/nacgeo.html#Microsoft">Does Microsoft Infringe the Natural Area Coding System?</a><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="http://www.nacgeo.com/nacsite/licensing/">The Natural Area Coding System - Legal and Licensing</a><a href="#fnref9">↩</a></li>
</ol>
</section>
</body>
</html>
