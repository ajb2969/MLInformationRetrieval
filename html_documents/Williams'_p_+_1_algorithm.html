<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1738">Williams' p + 1 algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Williams' p + 1 algorithm</h1>
<hr/>

<p>In <a href="computational_number_theory" title="wikilink">computational number theory</a>, <strong>Williams' <em>p</em> + 1 algorithm</strong> is an <a href="integer_factorization" title="wikilink">integer factorization</a> algorithm, one of the family of <a href="algebraic-group_factorisation_algorithms" title="wikilink">algebraic-group factorisation algorithms</a>. It was invented by <a href="Hugh_C._Williams" title="wikilink">Hugh C. Williams</a> in 1982.</p>

<p>It works well if the number <em>N</em> to be factored contains one or more prime factors <em>p</em> such that</p>
<dl>
<dd><em>p</em> + 1
</dd>
</dl>

<p>is <a href="smooth_number" title="wikilink">smooth</a>, i.e. <em>p</em> + 1 contains only small factors. It uses <a href="Lucas_sequence" title="wikilink">Lucas sequences</a> to perform exponentiation in a <a href="quadratic_field" title="wikilink">quadratic field</a>.</p>

<p>It is analogous to <a href="Pollard's_p_-_1_algorithm" title="wikilink">Pollard's <em>p</em> − 1 algorithm</a>.</p>
<h2 id="algorithm">Algorithm</h2>

<p>Choose some integer <em>A</em> greater than 2 which characterizes the <a href="Lucas_sequence" title="wikilink">Lucas sequence</a>:</p>

<p>
<math display="block" id="Williams'_p_+_1_algorithm:0">
<semantics>
<mrow>
<mrow>
<msub>
<mi>V</mi>
<mn>0</mn>
</msub>
<mo>=</mo>
<mn>2</mn>
</mrow>
<mo>,</mo>
<mrow>
<mrow>
<msub>
<mi>V</mi>
<mn>1</mn>
</msub>
<mo>=</mo>
<mi>A</mi>
</mrow>
<mo>,</mo>
<mrow>
<msub>
<mi>V</mi>
<mi>j</mi>
</msub>
<mo>=</mo>
<mrow>
<mrow>
<mi>A</mi>
<msub>
<mi>V</mi>
<mrow>
<mi>j</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msub>
</mrow>
<mo>-</mo>
<msub>
<mi>V</mi>
<mrow>
<mi>j</mi>
<mo>-</mo>
<mn>2</mn>
</mrow>
</msub>
</mrow>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>V</ci>
<cn type="integer">0</cn>
</apply>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>V</ci>
<cn type="integer">1</cn>
</apply>
<ci>A</ci>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>V</ci>
<ci>j</ci>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<ci>A</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>V</ci>
<apply>
<minus></minus>
<ci>j</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>V</ci>
<apply>
<minus></minus>
<ci>j</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   V_{0}=2,V_{1}=A,V_{j}=AV_{j-1}-V_{j-2}
  </annotation>
</semantics>
</math>
</p>

<p>where all operations are performed modulo <em>N</em>.</p>

<p>Then any odd prime <em>p</em> divides 

<math display="inline" id="Williams'_p_+_1_algorithm:1">
<semantics>
<mrow>
<mi>gcd</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>N</mi>
<mo>,</mo>
<mrow>
<msub>
<mi>V</mi>
<mi>M</mi>
</msub>
<mo>-</mo>
<mn>2</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<gcd></gcd>
<ci>N</ci>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>V</ci>
<ci>M</ci>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \gcd(N,V_{M}-2)
  </annotation>
</semantics>
</math>

 whenever <em>M</em> is a multiple of 

<math display="inline" id="Williams'_p_+_1_algorithm:2">
<semantics>
<mrow>
<mi>p</mi>
<mo>-</mo>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>D</mi>
<mo>/</mo>
<mi>p</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<ci>p</ci>
<apply>
<divide></divide>
<ci>D</ci>
<ci>p</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p-(D/p)
  </annotation>
</semantics>
</math>

, where 

<math display="inline" id="Williams'_p_+_1_algorithm:3">
<semantics>
<mrow>
<mi>D</mi>
<mo>=</mo>
<mrow>
<msup>
<mi>A</mi>
<mn>2</mn>
</msup>
<mo>-</mo>
<mn>4</mn>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>D</ci>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>A</ci>
<cn type="integer">2</cn>
</apply>
<cn type="integer">4</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   D=A^{2}-4
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Williams'_p_+_1_algorithm:4">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>D</mi>
<mo>/</mo>
<mi>p</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<divide></divide>
<ci>D</ci>
<ci>p</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (D/p)
  </annotation>
</semantics>
</math>

 is the <a href="Jacobi_symbol" title="wikilink">Jacobi symbol</a>.</p>

<p>We require that 

<math display="inline" id="Williams'_p_+_1_algorithm:5">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>D</mi>
<mo>/</mo>
<mi>p</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>=</mo>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<divide></divide>
<ci>D</ci>
<ci>p</ci>
</apply>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (D/p)=-1
  </annotation>
</semantics>
</math>

, that is, <em>D</em> should be a <a href="quadratic_non-residue" title="wikilink">quadratic non-residue</a> modulo <em>p</em>. But as we don't know <em>p</em> beforehand, more than one value of <em>A</em> may be required before finding a solution. If 

<math display="inline" id="Williams'_p_+_1_algorithm:6">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>D</mi>
<mo>/</mo>
<mi>p</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>=</mo>
<mrow>
<mo>+</mo>
<mn>1</mn>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<divide></divide>
<ci>D</ci>
<ci>p</ci>
</apply>
<apply>
<plus></plus>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (D/p)=+1
  </annotation>
</semantics>
</math>

, this algorithm degenerates into a slow version of <a href="Pollard's_p_-_1_algorithm" title="wikilink">Pollard's p − 1 algorithm</a>.</p>

<p>So, for different values of <em>M</em> we calculate 

<math display="inline" id="Williams'_p_+_1_algorithm:7">
<semantics>
<mrow>
<mi>gcd</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>N</mi>
<mo>,</mo>
<mrow>
<msub>
<mi>V</mi>
<mi>M</mi>
</msub>
<mo>-</mo>
<mn>2</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<gcd></gcd>
<ci>N</ci>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>V</ci>
<ci>M</ci>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \gcd(N,V_{M}-2)
  </annotation>
</semantics>
</math>

, and when the result is not equal to 1 or to <em>N</em>, we have found a non-trivial factor of <em>N</em>.</p>

<p>The values of <em>M</em> used are successive factorials, and 

<math display="inline" id="Williams'_p_+_1_algorithm:8">
<semantics>
<msub>
<mi>V</mi>
<mi>M</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>V</ci>
<ci>M</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   V_{M}
  </annotation>
</semantics>
</math>

 is the <em>M</em>-th value of the sequence characterized by 

<math display="inline" id="Williams'_p_+_1_algorithm:9">
<semantics>
<msub>
<mi>V</mi>
<mrow>
<mi>M</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>V</ci>
<apply>
<minus></minus>
<ci>M</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   V_{M-1}
  </annotation>
</semantics>
</math>

.</p>

<p>To find the <em>M</em>-th element <em>V</em> of the sequence characterized by <em>B</em>, we proceed in a manner similar to left-to-right exponentiation:</p>

<p><code> x=B           </code><br/>
<code> y=(B^2-2) mod N     </code><br/>
<code> for each bit of M to the right of the most significant bit</code><br/>
<code>   if the bit is 1</code><br/>
<code>     x=(x*y-B) mod N </code><br/>
<code>     y=(y^2-2) mod N </code><br/>
<code>   else</code><br/>
<code>     y=(x*y-B) mod N </code><br/>
<code>     x=(x^2-2) mod N </code><br/>
<code> V=x</code></p>
<h2 id="example">Example</h2>

<p>With <em>N</em>=112729 and <em>A</em>=5, successive values of 

<math display="inline" id="Williams'_p_+_1_algorithm:10">
<semantics>
<msub>
<mi>V</mi>
<mi>M</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>V</ci>
<ci>M</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   V_{M}
  </annotation>
</semantics>
</math>

 are:</p>
<dl>
<dd>V<sub>1</sub> of seq(5) = V<sub>1!</sub> of seq(5) = 5
</dd>
</dl>
<dl>
<dd>V<sub>2</sub> of seq(5) = V<sub>2!</sub> of seq(5) = 23
</dd>
</dl>
<dl>
<dd>V<sub>3</sub> of seq(23) = V<sub>3!</sub> of seq(5) = 12098
</dd>
</dl>
<dl>
<dd>V<sub>4</sub> of seq(12098) = V<sub>4!</sub> of seq(5) = 87680
</dd>
</dl>
<dl>
<dd>V<sub>5</sub> of seq(87680) = V<sub>5!</sub> of seq(5) = 53242
</dd>
</dl>
<dl>
<dd>V<sub>6</sub> of seq(53242) = V<sub>6!</sub> of seq(5) = 27666
</dd>
</dl>
<dl>
<dd>V<sub>7</sub> of seq(27666) = V<sub>7!</sub> of seq(5) = 110229.
</dd>
</dl>

<p>At this point, gcd(110229-2,112729) = 139, so 139 is a non-trivial factor of 112729. Notice that p+1 = 140 = 2<sup>2</sup> × 5 × 7. The number 7! is the lowest factorial which is multiple of 140, so the proper factor 139 is found in this step.</p>

<p>Using another initial value, say <em>A</em> = 9, we get:</p>
<dl>
<dd>V<sub>1</sub> of seq(9) = V<sub>1!</sub> of seq(9) = 9
</dd>
</dl>
<dl>
<dd>V<sub>2</sub> of seq(9) = V<sub>2!</sub> of seq(9) = 79
</dd>
</dl>
<dl>
<dd>V<sub>3</sub> of seq(79) = V<sub>3!</sub> of seq(9) = 41886
</dd>
</dl>
<dl>
<dd>V<sub>4</sub> of seq(41886) = V<sub>4!</sub> of seq(9) = 79378
</dd>
</dl>
<dl>
<dd>V<sub>5</sub> of seq(79378) = V<sub>5!</sub> of seq(9) = 1934
</dd>
</dl>
<dl>
<dd>V<sub>6</sub> of seq(1934) = V<sub>6!</sub> of seq(9) = 10582
</dd>
</dl>
<dl>
<dd>V<sub>7</sub> of seq(10582) = V<sub>7!</sub> of seq(9) = 84241
</dd>
</dl>
<dl>
<dd>V<sub>8</sub> of seq(84241) = V<sub>8!</sub> of seq(9) = 93973
</dd>
</dl>
<dl>
<dd>V<sub>9</sub> of seq(93973) = V<sub>9!</sub> of seq(9) = 91645.
</dd>
</dl>

<p>At this point gcd(91645-2,112729) = 811, so 811 is a non-trivial factor of 112729. Notice that p-1 = 810 = 2 × 5 × 3<sup>4</sup>. The number 9! is the lowest factorial which is multiple of 810, so the proper factor 811 is found in this step. The factor 139 is not found this time because p-1 = 138 = 2 × 3 × 23 which is not a divisor of 9!</p>

<p>As can be seen in these examples we don't know in advance whether the prime that will be found has a smooth p+1 or p-1.</p>
<h2 id="generalization">Generalization</h2>

<p>Based on <a href="Pollard's_p_-_1_algorithm" title="wikilink">Pollard's <em>p</em>-1</a> and Williams' <em>p</em>+1 factoring algorithms, Eric Bach and Jeffrey Shallit developed techniques to factor <em>n</em> efficiently provided that it has a prime factor <em>p</em> such that any <em>k</em><sup>th</sup> <a href="cyclotomic_polynomial" title="wikilink">cyclotomic polynomial</a> <em>Φ<sub>k</sub>(p)</em> is <a href="Smooth_number" title="wikilink">smooth</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The first few cyclotomic polynomials are given by the sequence <em>Φ<sub>1</sub>(p) = p-1</em>, <em>Φ<sub>2</sub>(p) = p+1</em>, <em>Φ<sub>3</sub>(p) = p<sup>2</sup>+p+1</em>, and <em>Φ<sub>4</sub>(p) = p<sup>2</sup>+1</em>.</p>
<h2 id="references">References</h2>
<references>
</references>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.mersennewiki.org/index.php/P_Plus_1_Factorization_Method">P Plus 1 Factorization Method</a>, MersenneWiki.</li>
</ul>

<p>"</p>

<p><a href="Category:Integer_factorization_algorithms" title="wikilink">Category:Integer factorization algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
