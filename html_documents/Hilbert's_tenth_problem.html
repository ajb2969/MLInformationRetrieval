<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="232">Hilbert's tenth problem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Hilbert's tenth problem</h1>
<hr/>

<p><strong>Hilbert's tenth problem</strong> is the tenth on the list of <a href="Hilbert's_problems" title="wikilink">Hilbert's problems</a> of 1900. Its statement is as follows:</p>
<blockquote>

<p>Given a <a href="Diophantine_equation" title="wikilink">Diophantine equation</a> with any number of unknown quantities and with rational integral numerical coefficients: <em>To devise a process according to which it can be determined in a finite number of operations whether the equation is solvable in rational integers</em>.</p>
</blockquote>

<p>It took many years for the problem to be solved with a negative answer. Today, it is known that no such algorithm exists in the general case because of the Matiyasevich/MDRP theorem that states that <a href="recursively_enumerable" title="wikilink">recursively enumerable</a> sets are equivalent to <a href="diophantine_set" title="wikilink">diophantine sets</a>. This result is the combined work of <a href="Martin_Davis" title="wikilink">Martin Davis</a>, <a href="Yuri_Matiyasevich" title="wikilink">Yuri Matiyasevich</a>, <a href="Hilary_Putnam" title="wikilink">Hilary Putnam</a> and <a href="Julia_Robinson" title="wikilink">Julia Robinson</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> which spans 21 years, with Yuri Matiyasevich completing the theorem in 1970.</p>
<h2 id="formulation">Formulation</h2>

<p>The words "process" and "finite number of operations" have been taken to mean that Hilbert was asking for an <a class="uri" href="algorithm" title="wikilink">algorithm</a>. The term "rational integer" simply refers to the integers, positive, negative or zero: 0, ±1, ±2, ... . So Hilbert was asking for a general algorithm to decide whether a given polynomial <a href="Diophantine_equation" title="wikilink">Diophantine equation</a> with integer coefficients has a solution in integers. Such an equation has the following form:</p>

<p>

<math display="block" id="Hilbert's_tenth_problem:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x_{1},x_{2},\ldots,x_{n})=0.
  </annotation>
 </semantics>
</math>

</p>

<p>The answer to the problem is now known to be in the negative: no such general algorithm can exist. Although it is unlikely that Hilbert had conceived of such a possibility, before going on to list the problems, he did presciently remark:</p>
<blockquote>

<p>"Occasionally it happens that we seek the solution under insufficient hypotheses or in an incorrect sense, and for this reason do not succeed. The problem then arises: to show the impossibility of the solution under the given hypotheses or in the sense contemplated."</p>
</blockquote>

<p>The work on the problem has been in terms of solutions in natural numbers<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> rather than arbitrary integers. But it is easy to see that an algorithm in either case could be used to obtain one for the other. If one possessed an algorithm to determine solvability in natural numbers, it could be used to determine whether an equation in 

<math display="inline" id="Hilbert's_tenth_problem:1">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 unknowns,</p>

<p>

<math display="block" id="Hilbert's_tenth_problem:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x_{1},x_{2},\ldots,x_{n})=0,\,
  </annotation>
 </semantics>
</math>

</p>

<p>has an integer solution by applying the supposed algorithm to the 2<sup><em>n</em></sup> equations</p>

<p>

<math display="block" id="Hilbert's_tenth_problem:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>±</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mo>±</mo>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <mo>±</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>0.</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <vector>
      <apply>
       <csymbol cd="latexml">plus-or-minus</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">plus-or-minus</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="latexml">plus-or-minus</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </vector>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(\pm x_{1},\pm x_{2},\ldots,\pm x_{n})=0.\,
  </annotation>
 </semantics>
</math>

</p>

<p>Conversely, an algorithm to test for solvability in arbitrary integers could be used to test a given equation for solvability in natural numbers by applying that supposed algorithm to the equation obtained from the given equation by replacing each unknown by the sum of the squares of four new unknowns. This works because of <a href="Lagrange's_four-square_theorem" title="wikilink">Lagrange's four-square theorem</a>, to the effect that every natural number can be written as the sum of four squares.</p>
<h2 id="diophantine-sets">Diophantine sets</h2>

<p>Sets of natural numbers, of pairs of natural numbers (or even of <em>n</em>-tuples of natural numbers) that have Diophantine definitions are called <em><a href="Diophantine_set" title="wikilink">Diophantine sets</a></em>. Diophantine definitions can be provided by simultaneous systems of equations as well as by individual equations because the system</p>

<p>

<math display="block" id="Hilbert's_tenth_problem:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>p</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <mn>0</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>p</mi>
     <mi>k</mi>
    </msub>
    <mo>=</mo>
    <mpadded width="+1.7pt">
     <mn>0</mn>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
     <list>
      <cn type="integer">0</cn>
      <ci>normal-…</ci>
     </list>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>k</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1}=0,\ldots,p_{k}=0\,
  </annotation>
 </semantics>
</math>

</p>

<p>is equivalent to the single equation</p>

<p>

<math display="block" id="Hilbert's_tenth_problem:5">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>p</mi>
     <mn>1</mn>
     <mn>2</mn>
    </msubsup>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <msubsup>
     <mi>p</mi>
     <mi>k</mi>
     <mn>2</mn>
    </msubsup>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>0.</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>k</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{1}^{2}+\cdots+p_{k}^{2}=0.\,
  </annotation>
 </semantics>
</math>

</p>

<p>A <a href="recursively_enumerable_set" title="wikilink">recursively enumerable set</a> can be characterized as one for which there exists an <a class="uri" href="algorithm" title="wikilink">algorithm</a> that will ultimately halt when a member of the set is provided as input, but may continue indefinitely when the input is a non member. It was the development of <a href="computability_theory" title="wikilink">computability theory</a> (also known as <a href="recursion_theory" title="wikilink">recursion theory</a>) that provided a precise explication of the intutitive notion of algorithmic computability, thus making the notion of recursive enumerability perfectly rigorous. It is evident that Diophantine sets are recursively enumerable. This is because one can arrange all possible tuples of values of the unknowns in a sequence and then, for a given value of the parameter(s), test these tuples, one after another, to see whether they are solutions of the corresponding equation. The unsolvability of Hilbert's tenth problem is a consequence of the surprising fact that the converse is true:</p>
<blockquote>

<p><em>Every recursively enumerable set is Diophantine.</em></p>
</blockquote>

<p>This result is variously known as <a href="Matiyasevich's_theorem" title="wikilink">Matiyasevich's theorem</a> (because he provided the crucial step that completed the proof) and the <a href="MRDP_theorem" title="wikilink">MRDP theorem</a> (for <a href="Yuri_Matiyasevich" title="wikilink">Yuri Matiyasevich</a>, <a href="Julia_Robinson" title="wikilink">Julia Robinson</a>, <a href="Martin_Davis" title="wikilink">Martin Davis</a>, and <a href="Hilary_Putnam" title="wikilink">Hilary Putnam</a>). Because <em>there exists a recursively enumerable set that is not computable,</em> the unsolvability of Hilbert's tenth problem is an immediate consequence. In fact, more can be said: there is a polynomial</p>

<p>

<math display="block" id="Hilbert's_tenth_problem:6">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <vector>
     <ci>a</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(a,x_{1},\ldots,x_{n})
  </annotation>
 </semantics>
</math>

 with integer coefficients such that the set of values of 

<math display="inline" id="Hilbert's_tenth_problem:7">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 for which the equation</p>

<p>

<math display="block" id="Hilbert's_tenth_problem:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <vector>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(a,x_{1},\ldots,x_{n})=0
  </annotation>
 </semantics>
</math>

 has solutions in natural numbers is not computable. So, not only is there no general algorithm for testing Diophantine equations for solvability, even for this one parameter family of equations, there is no algorithm.</p>
<h2 id="history">History</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Year</p></th>
<th style="text-align: left;">
<p>Events</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>1944</p></td>
<td style="text-align: left;">
<p><a href="Emil_Leon_Post" title="wikilink">Emil Leon Post</a> declares that Hilbert's tenth problem "begs for an unsolvability proof".</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1949</p></td>
<td style="text-align: left;">
<p>Martin Davis uses <a href="Kurt_Gödel" title="wikilink">Kurt Gödel</a>'s method for applying the <a href="Chinese_Remainder_Theorem" title="wikilink">Chinese Remainder Theorem</a> as a coding trick to obtain his normal form for recursively enumerable sets:</p>

<p>

<math display="block" id="Hilbert's_tenth_problem:9">
 <semantics>
  <mrow>
   <mo rspace="4.2pt" stretchy="false">{</mo>
   <mi>a</mi>
   <mo>∣</mo>
   <mo>∃</mo>
   <mpadded width="+1.7pt">
    <mi>y</mi>
   </mpadded>
   <mo>∀</mo>
   <mpadded width="-1.7pt">
    <mi>k</mi>
   </mpadded>
   <mo>≤</mo>
   <mpadded width="+1.7pt">
    <mi>y</mi>
   </mpadded>
   <mo>∃</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>k</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
    <mo rspace="4.2pt" stretchy="false">]</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-{</ci>
    <csymbol cd="unknown">a</csymbol>
    <ci>normal-∣</ci>
    <exists></exists>
    <csymbol cd="unknown">y</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">k</csymbol>
    <leq></leq>
    <csymbol cd="unknown">y</csymbol>
    <exists></exists>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-,</ci>
    <ci>normal-…</ci>
    <ci>normal-,</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">k</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <ci>normal-…</ci>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <cn type="integer">0</cn>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-}</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\,a\mid\exists y\,\forall k\!\leq y\,\exists x_{1},\ldots,x_{n}[p(a,k,y,x_{1%
},\ldots,x_{n})=0]\,\}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Hilbert's_tenth_problem:10">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is a polynomial with integer coefficients. Purely formally, it is only the bounded universal quantifier that stands in the way of this being a Diophantine definition. Using a non-constructive but easy proof, he derives as a corollary to this normal form that the set of Diophantine sets is not closed under complementation, by showing that there exists a Diophantine set whose complement is not Diophantine. Because the recursively enumerable sets also are not closed under complementation, he conjectures that the two classes are identical.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1950</p></td>
<td style="text-align: left;">
<p><a href="Julia_Robinson" title="wikilink">Julia Robinson</a>, unaware of Davis's work, investigates the connection of the exponential function to the problem, and attempts to prove that EXP, the set of triplets 

<math display="inline" id="Hilbert's_tenth_problem:11">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo>,</mo>
   <mi>c</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <ci>a</ci>
    <ci>b</ci>
    <ci>c</ci>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,b,c)
  </annotation>
 </semantics>
</math>

 for which 

<math display="inline" id="Hilbert's_tenth_problem:12">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <msup>
    <mi>b</mi>
    <mi>c</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>b</ci>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=b^{c}
  </annotation>
 </semantics>
</math>

, is Diophantine. Not succeeding, she makes the following <em>hypothesis</em> (later called J.R.):<br/>
:<em>There is a Diophantine set</em> 

<math display="inline" id="Hilbert's_tenth_problem:13">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>


 <em>of pairs</em> 

<math display="inline" id="Hilbert's_tenth_problem:14">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>b</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>a</ci>
    <ci>b</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,b)
  </annotation>
 </semantics>
</math>

 <em>such that</em> 

<math display="inline" id="Hilbert's_tenth_problem:15">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>D</mi>
   <mo>⇒</mo>
   <mi>b</mi>
   <mo><</mo>
   <msup>
    <mi>a</mi>
    <mi>a</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <interval closure="open">
      <ci>a</ci>
      <ci>b</ci>
     </interval>
     <ci>D</ci>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <ci>b</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,b)\in D\Rightarrow b<a^{a}
  </annotation>
 </semantics>
</math>

 <em>and for every</em> 

<math display="inline" id="Hilbert's_tenth_problem:16">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>k</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k>0
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Hilbert's_tenth_problem:17">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mi>D</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <exists></exists>
     <interval closure="open">
      <ci>a</ci>
      <ci>b</ci>
     </interval>
    </apply>
    <ci>D</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists(a,b)\in D
  </annotation>
 </semantics>
</math>

 <em>such that</em> 

<math display="inline" id="Hilbert's_tenth_problem:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>b</mi>
    <mo>></mo>
    <msup>
     <mi>a</mi>
     <mi>k</mi>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>b</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b>a^{k}.
  </annotation>
 </semantics>
</math>


<br/>
Using properties of the Pell equation, she proves that J.R. implies that EXP is Diophantine, as well as the binomial coefficients, the factorial, and the primes.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1959</p></td>
<td style="text-align: left;">
<p>Working together, Davis and Putnam study <em>exponential Diophantine sets</em>: sets definable by Diophantine equations in which some of the exponents may be unknowns. Using the Davis normal form together with Robinson's methods, and assuming the then unproved conjecture that <em><a href="Green–Tao_theorem" title="wikilink">there are arbitrarily long arithmetic progressions consisting of prime numbers</a></em>, they prove that every recursively enumerable set is exponential Diophantine. They also prove as a corollary that J.R. implies that every recursively enumerable set is Diophantine, which in turn implies that Hilbert's tenth problem unsolvable.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1960</p></td>
<td style="text-align: left;">
<p>Robinson simplifies the proof of the theoretical result for exponential Diophantine sets, making it independent from the conjecture about primes and thus a formal theorem. This makes the J.R. hypothesis a sufficient condition for the unsolvability of Hilbert's tenth problem. However, many doubt that J.R. is true.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1961–1969</p></td>
<td style="text-align: left;">
<p>During this period, Davis and Putnam find various propositions that imply J.R. Robinson, having previously shown that J.R. implies that the set of primes is a Diophantine set, proves that this is an <a href="if_and_only_if" title="wikilink">if and only if</a> condition. <a href="Yuri_Matiyasevich" title="wikilink">Yuri Matiyasevich</a> publishes some reductions of Hilbert's tenth problem.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1970</p></td>
<td style="text-align: left;">
<p>Drawing from the recently published work of Nikolai Vorob'ev on Fibonacci numbers,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> <a href="Yuri_Matiyasevich" title="wikilink">Matiyasevich</a> proves that the set P = {(a,b)|a &gt; 0, b = F<sub>2a</sub>}, where F<sub>n</sub> is the n<sup>th</sup> <a href="Fibonacci_number" title="wikilink">Fibonacci number</a> is diophantine and exhibits exponential growth.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> This proves the J.R. hypothesis, which by then had been an open question for 20 years. Combining J.R. with the theorem that every recursively enumerable set is exponential diophantine, proves that diophantine sets are recursively enumerable. This makes Hilbert's tenth problem unsolvable.</p></td>
</tr>
</tbody>
</table>
<h2 id="applications">Applications</h2>

<p>The Matiyasevich/MRDP Theorem relates two notions — one from computability theory, the other from number theory — and has some surprising consequences. Perhaps the most surprising is the existence of a <em>universal</em> Diophantine equation:</p>
<dl>
<dd><em>There exists a polynomial</em> 

<math display="inline" id="Hilbert's_tenth_problem:19">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <vector>
     <ci>a</ci>
     <ci>n</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(a,n,x_{1},\ldots,x_{k})
  </annotation>
 </semantics>
</math>

 <em>such that, given any Diophantine set</em> 

<math display="inline" id="Hilbert's_tenth_problem:20">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 <em>there is a number</em> 

<math display="inline" id="Hilbert's_tenth_problem:21">
 <semantics>
  <msub>
   <mi>n</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{0}
  </annotation>
 </semantics>
</math>

 <em>such that</em>

<p>

<math display="block" id="Hilbert's_tenth_problem:22">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mo rspace="4.2pt" stretchy="false">{</mo>
    <mi>a</mi>
    <mo>∣</mo>
    <mo>∃</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <msub>
       <mi>n</mi>
       <mn>0</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>=</mo>
     <mn>0</mn>
     <mo rspace="4.2pt" stretchy="false">]</mo>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-∣</ci>
     <exists></exists>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-,</ci>
     <ci>normal-…</ci>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">p</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">a</csymbol>
       <ci>normal-,</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">0</cn>
       </apply>
       <ci>normal-,</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-,</ci>
       <ci>normal-…</ci>
       <ci>normal-,</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <eq></eq>
      <cn type="integer">0</cn>
      <ci>normal-]</ci>
     </cerror>
     <ci>normal-}</ci>
    </cerror>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=\{\,a\mid\exists x_{1},\ldots,x_{k}[p(a,n_{0},x_{1},\ldots,x_{k})=0]\,\}.
  </annotation>
 </semantics>
</math>

</p>
</dd>
</dl>

<p>This is true simply because Diophantine sets, being equal to recursively enumerable sets, are also equal to <a href="Turing_machine" title="wikilink">Turing machines</a>. It is a well known property of Turing machines that there exist universal Turing machines, capable of executing any algorithm.</p>

<p>Hilary Putnam has pointed out that for any Diophantine set 

<math display="inline" id="Hilbert's_tenth_problem:23">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>


 of positive integers, there is a polynomial</p>

<p>

<math display="block" id="Hilbert's_tenth_problem:24">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>q</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q(x_{0},x_{1},\ldots,x_{n})\,
  </annotation>
 </semantics>
</math>

</p>

<p>such that 

<math display="inline" id="Hilbert's_tenth_problem:25">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 consists of exactly the positive numbers among the values assumed by 

<math display="inline" id="Hilbert's_tenth_problem:26">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 as the variables</p>

<p>

<math display="block" id="Hilbert's_tenth_problem:27">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mpadded width="+1.7pt">
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0},x_{1},\ldots,x_{n}\,
  </annotation>
 </semantics>
</math>

</p>

<p>range over all natural numbers. This can be seen as follows: If</p>

<p>

<math display="block" id="Hilbert's_tenth_problem:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <vector>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(a,y_{1},\ldots,y_{n})=0\,
  </annotation>
 </semantics>
</math>

</p>

<p>provides a Diophantine definition of 

<math display="inline" id="Hilbert's_tenth_problem:29">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, then it suffices to set</p>

<p>

<math display="block" id="Hilbert's_tenth_problem:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>0</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>0</mn>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mrow>
        <mi>p</mi>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>x</mi>
           <mn>0</mn>
          </msub>
          <mo>,</mo>
          <msub>
           <mi>x</mi>
           <mn>1</mn>
          </msub>
          <mo>,</mo>
          <mi mathvariant="normal">…</mi>
          <mo>,</mo>
          <msub>
           <mi>x</mi>
           <mi>n</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
         <mn>2</mn>
        </msup>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>q</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <ci>p</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <vector>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <cn type="integer">0</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <cn type="integer">1</cn>
          </apply>
          <ci>normal-…</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>x</ci>
           <ci>n</ci>
          </apply>
         </vector>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q(x_{0},x_{1},\ldots,x_{n})=x_{0}[1-p(x_{0},x_{1},\ldots,x_{n})^{2}].\,
  </annotation>
 </semantics>
</math>

</p>

<p>So, for example, there is a polynomial for which the positive part of its range is exactly the prime numbers. (On the other hand no polynomial can only take on prime values.)</p>

<p>Other applications concern what logicians refer to as 

<math display="inline" id="Hilbert's_tenth_problem:31">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Π</mi>
   <mn>1</mn>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Π</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi^{0}_{1}
  </annotation>
 </semantics>
</math>

 propositions, sometimes also called propositions of <em>Goldbach type</em>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> These are like the <a href="Goldbach_Conjecture" title="wikilink">Goldbach Conjecture</a>, in stating that all natural numbers possess a certain property that is algorithmically checkable for each particular number.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> The Matiyasevich/MRDP Theorem implies that each such proposition is equivalent to a statement that asserts that some particular Diophantine equation has no solutions in natural numbers.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> A number of important and celebrated problems are of this form: in particular, <a href="Fermat's_Last_Theorem" title="wikilink">Fermat's Last Theorem</a>, the <a href="Riemann_Hypothesis" title="wikilink">Riemann Hypothesis</a>, and the <a href="Four_Color_Theorem" title="wikilink">Four Color Theorem</a>. In addition the assertion that particular <a href="formal_system" title="wikilink">formal systems</a> such as Peano Arithmetic or <a class="uri" href="ZFC" title="wikilink">ZFC</a> are consistent can be expressed as 

<math display="inline" id="Hilbert's_tenth_problem:32">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Π</mi>
   <mn>1</mn>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Π</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi^{0}_{1}
  </annotation>
 </semantics>
</math>

 sentences. The idea is to follow <a href="Kurt_Gödel" title="wikilink">Kurt Gödel</a> in coding proofs by natural numbers in such a way that the property of being the number representing a proof is algorithmically checkable.</p>

<p>

<math display="inline" id="Hilbert's_tenth_problem:33">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Π</mi>
   <mn>1</mn>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Π</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi^{0}_{1}
  </annotation>
 </semantics>
</math>


 sentences have the special property that if they are false, that fact will be provable in any of the usual formal systems. This is because the falsity amounts to the existence of a counter-example which can be verified by simple arithmetic. So if a 

<math display="inline" id="Hilbert's_tenth_problem:34">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Π</mi>
   <mn>1</mn>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Π</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi^{0}_{1}
  </annotation>
 </semantics>
</math>

 sentence is such that neither it nor its negation is provable in one of these systems, that sentence must be true.</p>

<p>A particularly striking form of <a href="Gödel's_incompleteness_theorem" title="wikilink">Gödel's incompleteness theorem</a> is also a consequence of the Matiyasevich/MRDP Theorem:</p>

<p><em>Let</em></p>

<p>

<math display="block" id="Hilbert's_tenth_problem:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <vector>
      <ci>a</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </vector>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(a,x_{1},\ldots,x_{k})=0\,
  </annotation>
 </semantics>
</math>

</p>

<p><em>provide a Diophantine definition of a non-computable set. Let</em> 

<math display="inline" id="Hilbert's_tenth_problem:36">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 <em>be an algorithm that outputs a sequence of natural numbers</em> 

<math display="inline" id="Hilbert's_tenth_problem:37">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 <em>such that the corresponding equation</em></p>

<p>

<math display="block" id="Hilbert's_tenth_problem:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <vector>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </vector>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(n,x_{1},\ldots,x_{k})=0\,
  </annotation>
 </semantics>
</math>

</p>

<p><em>has no solutions in natural numbers. Then there is a number</em> 

<math display="inline" id="Hilbert's_tenth_problem:39">
 <semantics>
  <msub>
   <mi>n</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{0}
  </annotation>
 </semantics>
</math>

 <em>which is not output by</em> 

<math display="inline" id="Hilbert's_tenth_problem:40">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 <em>while in fact the equation</em></p>

<p>

<math display="block" id="Hilbert's_tenth_problem:41">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>n</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </vector>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(n_{0},x_{1},\ldots,x_{k})=0\,
  </annotation>
 </semantics>
</math>

</p>

<p><em>has no solutions in natural numbers.</em></p>

<p>To see that the theorem is true, it suffices to notice that if there were no such number 

<math display="inline" id="Hilbert's_tenth_problem:42">
 <semantics>
  <msub>
   <mi>n</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{0}
  </annotation>
 </semantics>
</math>

, one could algorithmically test membership of a number 

<math display="inline" id="Hilbert's_tenth_problem:43">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


 in this non-computable set by simultaneously running the algorithm 

<math display="inline" id="Hilbert's_tenth_problem:44">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 to see whether 

<math display="inline" id="Hilbert's_tenth_problem:45">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is output while also checking all possible 

<math display="inline" id="Hilbert's_tenth_problem:46">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-tuples of natural numbers seeking a solution of the equation</p>

<p>

<math display="block" id="Hilbert's_tenth_problem:47">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <vector>
      <ci>n</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </vector>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(n,x_{1},\ldots,x_{k})=0.
  </annotation>
 </semantics>
</math>

</p>

<p>We may associate an algorithm 

<math display="inline" id="Hilbert's_tenth_problem:48">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>


 with any of the usual formal systems such as <a href="Peano_Arithmetic" title="wikilink">Peano Arithmetic</a> or <a class="uri" href="ZFC" title="wikilink">ZFC</a> by letting it systematically generate consequences of the axioms and then output a number 

<math display="inline" id="Hilbert's_tenth_problem:49">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 whenever a sentence of the form</p>

<p>

<math display="block" id="Hilbert's_tenth_problem:50">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mo>∃</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
    <mo rspace="4.2pt" stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <not></not>
    <exists></exists>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-,</ci>
    <ci>normal-…</ci>
    <ci>normal-,</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>k</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-,</ci>
      <ci>normal-…</ci>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <eq></eq>
     <cn type="integer">0</cn>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\exists x_{1},\ldots,x_{k}[p(n,x_{1},\ldots,x_{k})=0]\,
  </annotation>
 </semantics>
</math>

</p>

<p>is generated. Then the theorem tells us that either a false statement of this form is proved or a true one remains unproved in the system in question.</p>
<h2 id="further-results">Further results</h2>

<p>We may speak of the <em>degree</em> of a Diophantine set as being the least degree of a polynomial in an equation defining that set. Similarly, we can call the <em>dimension</em> of such a set the least number of unknowns in a defining equation. Because of the existence of a universal Diophantine equation, it is clear that there are absolute upper bounds to both of these quantities, and there has been much interest in determining these bounds.</p>

<p>Already in the 1920s <a href="Thoralf_Skolem" title="wikilink">Thoralf Skolem</a> showed that any Diophantine equation is equivalent to one of degree 4 or less. His trick was to introduce new unknowns by equations setting them equal to the square of an unknown or the product of two unknowns. Repetition of this process results in a system of second degree equations; then an equation of degree 4 is obtained by summing the squares. So every Diophantine set is trivially of degree 4 or less. It is not known whether this result is best possible.</p>

<p>Julia Robinson and Yuri Matiyasevich showed that every Diophantine set has dimension no greater than 13. Later, Matiyasevich sharpened their methods to show that 9 unknowns suffice. Although it may well be that this result is not the best possible, there has been no further progress.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> So, in particular, there is no algorithm for testing Diophantine equations with 9 or fewer unknowns for solvability in natural numbers. For the case of rational integer solutions (as Hilbert had originally posed it), the 4 squares trick shows that there is no algorithm for equations with no more than 36 unknowns. But <a href="Zhi_Wei_Sun" title="wikilink">Zhi Wei Sun</a> showed that the problem for integers is unsolvable even for equations with no more than 11 unknowns.</p>

<p>Martin Davis studied algorithmic questions involving the number of solutions of a Diophantine equation. Hilbert's tenth problem asks whether or not that number is 0. Let 

<math display="inline" id="Hilbert's_tenth_problem:51">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mn>3</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi mathvariant="normal">ℵ</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-ℵ</ci>
      <cn type="integer">0</cn>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\{0,1,2,3,\ldots,\aleph_{0}\}
  </annotation>
 </semantics>
</math>

 and let 

<math display="inline" id="Hilbert's_tenth_problem:52">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 be a proper non-empty subset of 

<math display="inline" id="Hilbert's_tenth_problem:53">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>


. Davis proved that there is no algorithm to test a given Diophantine equation to determine whether the number of its solutions is a member of the set 

<math display="inline" id="Hilbert's_tenth_problem:54">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

. Thus there is no algorithm to determine whether the number of solutions of a Diophantine equation is finite, odd, a perfect square, a prime, etc.</p>
<h2 id="extensions-of-hilberts-tenth-problem">Extensions of Hilbert's tenth problem</h2>

<p>Although Hilbert posed the problem for the rational integers, it can be just as well asked for many <a href="ring_(mathematics)" title="wikilink">rings</a> (in particular, for any ring whose elements are listable). Obvious examples are the rings of integers of <a href="algebraic_number_field" title="wikilink">algebraic number fields</a> as well as the rational numbers. An algorithm such as he was requesting could have been extended to cover these other domains. For example, the equation</p>

<p>

<math display="block" id="Hilbert's_tenth_problem:55">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>p</ci>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </vector>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(x_{1},\ldots,x_{k})=0\,
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Hilbert's_tenth_problem:56">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is a polynomial of degree 

<math display="inline" id="Hilbert's_tenth_problem:57">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 is solvable in non-negative rational numbers <a href="if_and_only_if" title="wikilink">if and only if</a></p>

<p>

<math display="block" id="Hilbert's_tenth_problem:58">
 <semantics>
  <mrow>
   <mrow>
    <mpadded width="+2.8pt">
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>z</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
     </msup>
    </mpadded>
    <mi>p</mi>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mrow>
       <mi>z</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </mfrac>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mfrac>
      <msub>
       <mi>x</mi>
       <mi>k</mi>
      </msub>
      <mrow>
       <mi>z</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </mfrac>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <ci>z</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>d</ci>
     </apply>
     <ci>p</ci>
     <vector>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <plus></plus>
        <ci>z</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <plus></plus>
        <ci>z</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </vector>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (z+1)^{d}\;p\left(\frac{x_{1}}{z+1},\ldots,\frac{x_{k}}{z+1}\right)=0
  </annotation>
 </semantics>
</math>

</p>

<p>is solvable in natural numbers. (If one possessed an algorithm to determine solvability in non-negative rational numbers, it could easily be used to determine solvability in the rationals.) However, knowing that there is no such algorithm as Hilbert had desired says nothing about these other domains.</p>

<p>There has been much work on Hilbert's tenth problem for the rings of integers of algebraic number fields. Basing themselves on earlier work by <a href="Jan_Denef" title="wikilink">Jan Denef</a> and Leonard Lipschitz and using class field theory, Harold N. Shapiro and Alexandra Shlapentokh were able to prove:</p>
<blockquote>

<p><em>Hilbert's tenth problem is unsolvable for the ring of integers of any algebraic number field whose Galois group over the rationals is abelian.</em></p>
</blockquote>

<p>Shlapentokh and Thanases Pheidas (independently of one another) obtained the same result for algebraic number fields admitting exactly one pair of complex conjugate embeddings.</p>

<p>The problem for the ring of integers of algebraic number fields other than those covered by the results above remains open. Likewise, despite much interest, the problem for equations over the rationals remains open. <a href="Barry_Mazur" title="wikilink">Barry Mazur</a> has conjectured that for any <a href="Algebraic_variety" title="wikilink">variety</a> over the rationals, the topological closure over the reals of the set of solutions has only finitely many components.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> This conjecture implies that the integers are not Diophantine over the rationals and so if this conjecture is true a negative answer to Hilbert's Tenth Problem would require a different approach than that used for other rings.</p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li><a href="Yuri_Matiyasevich" title="wikilink">Yuri V. Matiyasevich</a>, <em>Hilbert's Tenth Problem</em>, <a href="MIT_Press" title="wikilink">MIT Press</a>, Cambridge, Massachusetts, 1993.</li>
<li>

<p>Reprinted in <em>The Collected Works of Julia Robinson</em>, <a href="Solomon_Feferman" title="wikilink">Solomon Feferman</a>, editor, pp.269–378, American Mathematical Society 1996.</p></li>
<li><a href="Martin_Davis" title="wikilink">Martin Davis</a>, "Hilbert's Tenth Problem is Unsolvable," <em>American Mathematical Monthly</em>, vol.80(1973), pp. 233–269; reprinted as an appendix in Martin Davis, <em>Computability and Unsolvability</em>, Dover reprint 1982.</li>
<li></li>
<li><a href="Jan_Denef" title="wikilink">Jan Denef</a>, Leonard Lipschitz, Thanases Pheidas, Jan van Geel, editors, "Hilbert's Tenth Problem: Workshop at Ghent University, Belgium, November 2–5, 1999." <em>Contemporary Mathematics</em> vol. 270(2000), American Mathematical Society.</li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.goldenmuseum.com/1612Hilbert_engl.html">Hilbert's Tenth Problem: a History of Mathematical Discovery</a></li>
<li><a href="http://logic.pdmi.ras.ru/Hilbert10">Hilbert's Tenth Problem page!</a></li>
<li><a href="http://math.nju.edu.cn/~zwsun/htp.pdf">Zhi Wei Sun: On Hilbert's Tenth Problem and Related Topics</a></li>
<li></li>
</ul>

<p><a class="uri" href="zh:希爾伯特第十問題" title="wikilink">zh:希爾伯特第十問題</a>"</p>

<p><a href="Category:Hilbert's_problems" title="wikilink">#10</a> <a href="Category:Diophantine_equations" title="wikilink">Category:Diophantine equations</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="S._Barry_Cooper" title="wikilink">S. Barry Cooper</a>, <em>Computability theory</em>, p. 98<a href="#fnref1">↩</a></li>
<li id="fn2">Following the tradition in mathematical logic, 

<math display="inline" id="Hilbert's_tenth_problem:59">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

 is considered to be a natural number in this article.<a href="#fnref2">↩</a></li>
<li id="fn3">A review of the joint publication by Davis, Putnam, and Robinson in <a href="Mathematical_Reviews" title="wikilink">Mathematical Reviews</a> () conjectured, in effect, that J.R. was false.<a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6">

<math display="inline" id="Hilbert's_tenth_problem:60">
 <semantics>
  <msubsup>
   <mi mathvariant="normal">Π</mi>
   <mn>1</mn>
   <mn>0</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Π</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi^{0}_{1}
  </annotation>
 </semantics>
</math>

 sentences are at one of the lowest levels of the so-called <a href="arithmetical_hierarchy" title="wikilink">arithmetical hierarchy</a>.<a href="#fnref6">↩</a></li>
<li id="fn7">Thus, the Goldbach Conjecture itself can be expressed as saying that for each natural number 

<math display="inline" id="Hilbert's_tenth_problem:61">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 the number 

<math display="inline" id="Hilbert's_tenth_problem:62">
 <semantics>
  <mrow>
   <mrow>
    <mn>2</mn>
    <mi>n</mi>
   </mrow>
   <mo>+</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2n+4
  </annotation>
 </semantics>
</math>

 is the sum of two prime numbers. Of course there is a simple algorithm to test a given number for being the sum of two primes.<a href="#fnref7">↩</a></li>
<li id="fn8">In fact the equivalence is provable in <a href="Peano_Arithmetic" title="wikilink">Peano Arithmetic</a>.<a href="#fnref8">↩</a></li>
<li id="fn9">At this point, even 3 cannot be excluded as an absolute upper bound.<a href="#fnref9">↩</a></li>
<li id="fn10"><a class="uri" href="http://www-math.mit.edu/~poonen/papers/subrings.pdf">http://www-math.mit.edu/~poonen/papers/subrings.pdf</a><a href="#fnref10">↩</a></li>
</ol>
</section>
</body>
</html>
