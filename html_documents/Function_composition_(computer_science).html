<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1723">Function composition (computer science)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Function composition (computer science)</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, <strong>function composition</strong> (not to be confused with <a href="object_composition" title="wikilink">object composition</a>) is an act or mechanism to combine simple <a href="subroutine" title="wikilink">functions</a> to build more complicated ones. Like the usual <a href="function_composition" title="wikilink">composition of functions</a> in <a class="uri" href="mathematics" title="wikilink">mathematics</a>, the result of each function is passed as the argument of the next, and the result of the last one is the result of the whole.</p>

<p>Programmers frequently apply functions to results of other functions, and almost all programming languages allow it. In some cases, the composition of functions is interesting as a function in its own right, to be used later. Such a function can always be defined but languages with <a href="first-class_functions" title="wikilink">first-class functions</a> make it easier.</p>

<p>The ability to easily compose functions encourages <a href="code_refactoring" title="wikilink">factoring</a> (breaking apart) <a href="subroutine" title="wikilink">functions</a> for maintainability and <a href="code_reuse" title="wikilink">code reuse</a>. More generally, big systems might be built by composing whole programs.</p>

<p>Narrowly speaking, function composition applies to functions that operate on a finite amount of data, each step sequentially processing it before handing it to the next. Functions that operate on potentially infinite data (a <a href="Stream_(computing)" title="wikilink">stream</a> or other <a class="uri" href="codata" title="wikilink">codata</a>) are known as <a href="Filter_(software)" title="wikilink">filters</a>, and are instead connected in a <a href="Pipeline_(software)" title="wikilink">pipeline</a>, which is analogous to function composition and can execute <a href="concurrent_computing" title="wikilink">concurrently</a>.</p>
<h2 id="composing-function-calls">Composing function calls</h2>

<p>For example, suppose we have two <a href="function_(mathematics)" title="wikilink">functions</a> 

<math display="inline" id="Function_composition_(computer_science):0">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Function_composition_(computer_science):1">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

, as in 

<math display="inline" id="Function_composition_(computer_science):2">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>z</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z=f(y)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Function_composition_(computer_science):3">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=g(x)
  </annotation>
 </semantics>
</math>

. Composing them means we first compute 

<math display="inline" id="Function_composition_(computer_science):4">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=g(x)
  </annotation>
 </semantics>
</math>

, and then use 

<math display="inline" id="Function_composition_(computer_science):5">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 to compute 

<math display="inline" id="Function_composition_(computer_science):6">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>z</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z=f(y)
  </annotation>
 </semantics>
</math>

. Here is the example in the <a href="C_(programming_language)" title="wikilink">C language</a>:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">float</span> x, y, z;
<span class="co">// ...</span>
y = g(x);
z = f(y);</code></pre></div>

<p>The steps can be combined if we don't give a name to the intermediate result:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">z = f(g(x));</code></pre></div>

<p>Despite differences in length, these two implementations compute the same result. The second implementation requires only one line of code and is colloquially referred to as a "highly composed" form. Readability and hence maintainability is one advantage of highly composed forms, since they require fewer lines of code, minimizing a program's "surface area".<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> DeMarco and Lister empirically verify an inverse relationship between surface area and maintainability.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> On the other hand, it may be possible to overuse highly composed forms. A nesting of too many functions may have the opposite effect, making the code less maintainable.</p>

<p>In a <a href="stack-based_language" title="wikilink">stack-based language</a>, functional composition is even more natural: it is performed by <a class="uri" href="concatenation" title="wikilink">concatenation</a>, and is usually the primary method of program design. The above example in <a href="Forth_(programming_language)" title="wikilink">Forth</a>:</p>

<p><code>g f</code></p>

<p>Which will take whatever was on the stack before, apply g, then f, and leave the result on the stack. See <a href="function_composition#Alternative_notations" title="wikilink">postfix composition notation</a> for the corresponding mathematical notation.</p>
<h2 id="naming-the-composition-of-functions">Naming the composition of functions</h2>

<p>Now suppose that the combination of calling f() on the result of g() is frequently useful and we want to name foo() and use it as a function in its own right.</p>

<p>In most languages, we can define a new function implemented by composition. Example in <a href="C_(programming_language)" title="wikilink">C</a>:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">float</span> foo(<span class="dt">float</span> x) {
    <span class="kw">return</span> f(g(x));
}</code></pre></div>

<p>(the long form with intermediates would work as well.) Example in <a href="Forth_(programming_language)" title="wikilink">Forth</a>:</p>

<p><code>   : foo g f ;</code></p>

<p>In languages such as <a href="C_(programming_language)" title="wikilink">C</a>, the only way to create a new function is to define it in the program source, which means that functions can't be composed at <a href="Run_time_(program_lifecycle_phase)" title="wikilink">run time</a>.</p>
<h2 id="first-class-composition">First-class composition</h2>

<p>In functional programming languages, function composition can be naturally expressed as a <a href="higher-order_function" title="wikilink">higher-order function</a> or operator. In <a href="Haskell_(programming_language)" title="wikilink">Haskell</a>, the example given above becomes:</p>

<p><code>foo = f . g</code></p>

<p>using the built-in composition operator (.), which can be read as <em>f after g</em> or <em>g composed with f</em>.</p>

<p>The composition operator itself can be defined in Haskell using a <a href="Lambda_calculus" title="wikilink">lambda expression</a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c
f <span class="fu">.</span> g <span class="fu">=</span> \x <span class="ot">-&gt;</span> f (g x)</code></pre></div>

<p>The first lines describes the type of (.) - it takes a pair of functions and returns a function. Note that Haskell doesn't require specification of the exact input and output types of f and g, only the relations between them (f must accept what g returns). This makes (.) a <a href="polymorphism_(computer_science)" title="wikilink">polymorphic</a> operator.</p>

<p>Variants of <a href="Lisp_(programming_language)" title="wikilink">Lisp</a>, especially <a href="Scheme_(programming_language)" title="wikilink">Scheme</a>, the <a href="homoiconic" title="wikilink">interchangeability of code and data</a> together with the treatment of functions lend themselves extremely well for a recursive definition of a <a class="uri" href="variadic" title="wikilink">variadic</a> compositional operator.</p>
<div class="sourceCode"><pre class="sourceCode Scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> </span>(compose . fs)
  (<span class="kw">if</span> (<span class="kw">null?</span> fs) (<span class="kw">lambda</span> (x) x) <span class="co">; if no argument is given, evaluates to the identity function</span>
      (<span class="kw">lambda</span> (x) ((<span class="kw">car</span> fs) ((apply compose (<span class="kw">cdr</span> fs)) x)))))

<span class="co">; examples</span>
(<span class="kw">define</span><span class="fu"> </span>(add-a-bang str)
  (<span class="kw">string-append</span> str <span class="st">"!"</span>))

(<span class="kw">define</span><span class="fu"> givebang</span>
  (compose <span class="kw">string-&gt;symbol</span> add-a-bang <span class="kw">symbol-&gt;string</span>))

(givebang 'set) <span class="co">; ===&gt; set!</span>

<span class="co">; anonymous composition</span>
((compose <span class="kw">sqrt</span> negate square) <span class="dv">5</span>) <span class="co">; ===&gt; 0+5i</span></code></pre></div>

<p>In <a class="uri" href="JavaScript" title="wikilink">JavaScript</a> we can define it as a function which takes two functions f and g, and produces a function:</p>
<div class="sourceCode"><pre class="sourceCode JavaScript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">o</span>(f<span class="op">,</span> g) <span class="op">{</span>
    <span class="cf">return</span> <span class="kw">function</span>(x) <span class="op">{</span>
        <span class="cf">return</span> <span class="at">f</span>(<span class="at">g</span>(x))<span class="op">;</span>
    <span class="op">}</span>
<span class="op">}</span></code></pre></div>

<p>In <a href="Python_(programming_language)" title="wikilink">Python</a>, a way to define the composition for any group of functions, is using <a href="fold_(higher-order_function)" title="wikilink">reduce</a> function (use functools.reduce in Python 3):</p>
<div class="sourceCode"><pre class="sourceCode Python"><code class="sourceCode python"><span class="kw">def</span> compose(<span class="op">*</span>funcs):
    <span class="co">"""Compose a group of functions (f(g(h(..)))) into a single composite func"""</span>
    <span class="cf">return</span> <span class="bu">reduce</span>(<span class="kw">lambda</span> f, g: <span class="kw">lambda</span> <span class="op">*</span>args, <span class="op">**</span>kwargs: f(g(<span class="op">*</span>args, <span class="op">**</span>kwargs)), funcs)

<span class="co"># Example</span>
f <span class="op">=</span> <span class="kw">lambda</span> x: x<span class="dv">+1</span>
g <span class="op">=</span> <span class="kw">lambda</span> x: x<span class="op">*</span><span class="dv">2</span>
h <span class="op">=</span> <span class="kw">lambda</span> x: x<span class="dv">-3</span>

<span class="co"># Call the function x=10 : ((x-3)*2)+1 = 15</span>
<span class="bu">print</span> (compose(f, g, h))(<span class="dv">10</span>)</code></pre></div>
<h2 id="research-survey">Research survey</h2>

<p>Notions of composition, including the <a href="principle_of_compositionality" title="wikilink">principle of compositionality</a> and <a class="uri" href="composability" title="wikilink">composability</a>, are so ubiquitous that numerous strands of research have separately evolved. The following is a sampling of the kind of research in which the notion of composition is central.</p>
<ul>
<li>

<p>directly applied function composition to the assemblage of building blocks known as '<a href="monad_(functional_programming)" title="wikilink">monads</a>' in the <a href="Haskell_(programming_language)" title="wikilink">Haskell programming language</a>.</p></li>
<li>

<p>addressed the <a href="code_reuse" title="wikilink">software reuse</a> problem in terms of composability.</p></li>
<li>

<p>formally defined a proof rule for functional composition that assures a program's safety and liveness.</p></li>
<li>

<p>identified a strengthened form of compositionality by placing it into a <a href="computational_semiotics" title="wikilink">semiotic</a> system and applying it to the problem of structural <a class="uri" href="ambiguity" title="wikilink">ambiguity</a> frequently encountered in <a href="computational_linguistics" title="wikilink">computational linguistics</a>.</p></li>
<li>

<p>examined the role of compositionality in analog aspects of natural language processing.</p></li>
<li>According to a review by , formal treatment of composition underlies validation of component assembly in visual programming languages like IBM's Visual Age for the <a href="Java_(programming_language)" title="wikilink">Java</a> language.</li>
</ul>
<h2 id="large-scale-composition">Large-scale composition</h2>

<p>Whole programs or systems can be treated as functions, which can be readily composed if their inputs and outputs are well-defined<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> <a href="pipeline_(software)" title="wikilink">pipelines</a> allowing easy composition of <a href="filter_(software)" title="wikilink">filters</a> were so successful that it become a <a href="pipeline_(software)" title="wikilink">design pattern</a> of operating systems.</p>

<p><a href="imperative_programming" title="wikilink">Imperative procedures</a> with side effects violate <a href="Referential_transparency_(computer_science)" title="wikilink">referential transparency</a> and therefore are not cleanly composable. However if you consider the "state of the world" before and after running the code as its input and output, you get a clean function. Composition of such functions corresponds to running the procedures one after the other. The <a href="monad_(functional_programming)" title="wikilink">Monads</a> formalism uses this idea to incorporate side effects and I/O into functional languages.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Functional_decomposition" title="wikilink">Functional decomposition</a></li>
<li><a href="Implementation_inheritance" title="wikilink">Implementation inheritance</a></li>
<li><a href="Inheritance_semantics" title="wikilink">Inheritance semantics</a></li>
<li><a href="Pipeline_(Unix)" title="wikilink">Pipeline (Unix)</a></li>
<li><a class="uri" href="Iteratee" title="wikilink">Iteratee</a></li>
<li><a href="Principle_of_compositionality" title="wikilink">Principle of compositionality</a></li>
<li><a href="Virtual_inheritance" title="wikilink">Virtual inheritance</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>

<p>"</p>

<p><a href="Category:Programming_language_topics" title="wikilink">Category:Programming language topics</a> <a href="Category:Higher-order_functions" title="wikilink">Category:Higher-order functions</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">, pp. 15–17<a href="#fnref1">↩</a></li>
<li id="fn2">, pp. 133–135.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>

