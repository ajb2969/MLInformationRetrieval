<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="181">P versus NP problem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>P versus NP problem</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Diagram of complexity classes provided that <strong>P</strong> <a class="uri" href="≠" title="wikilink">≠</a> <strong>NP</strong>. The existence of problems within <strong>NP</strong> but outside both <strong>P</strong> and <strong>NP</strong>-complete, under that assumption, was established by <a href="NP-intermediate" title="wikilink">Ladner's theorem</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></figcaption>
</figure>

<p>The <strong>P versus NP problem</strong> is a major <a href="List_of_unsolved_problems_in_computer_science" title="wikilink">unsolved problem in computer science</a>. Informally, it asks whether every problem whose solution can be quickly verified by a computer can also be quickly solved by a computer. It was essentially first mentioned in a 1956 letter written by <a href="Kurt_Gödel" title="wikilink">Kurt Gödel</a> to <a href="John_von_Neumann" title="wikilink">John von Neumann</a>. Gödel asked whether a certain <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> problem could be solved in quadratic or linear time.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The precise statement of the P versus NP problem was introduced in 1971 by <a href="Stephen_Cook" title="wikilink">Stephen Cook</a> in his seminal paper "The complexity of theorem proving procedures"<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and is considered by many to be the most important open problem in the field.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> It is one of the seven <a href="Millennium_Prize_Problems" title="wikilink">Millennium Prize Problems</a> selected by the <a href="Clay_Mathematics_Institute" title="wikilink">Clay Mathematics Institute</a> to carry a US$1,000,000 prize for the first correct solution.</p>

<p>The informal term <em>quickly</em>, used above, means the existence of an algorithm for the task that runs in <a href="polynomial_time" title="wikilink">polynomial time</a>. The general class of questions for which some algorithm can provide an answer in polynomial time is called "class <strong>P</strong>" or just "<strong><a href="P_(complexity)" title="wikilink">P</a></strong>". For some questions, there is no known way to find an answer quickly, but if one is provided with information showing what the answer is, it is possible to verify the answer quickly. The class of questions for which an answer can be <em>verified</em> in polynomial time is called <strong><a href="NP_(complexity)" title="wikilink">NP</a></strong>.</p>

<p>Consider the <a href="subset_sum_problem" title="wikilink">subset sum problem</a>, an example of a problem that is easy to verify, but whose answer may be difficult to compute. Given a set of <a href="integer" title="wikilink">integers</a>, does some nonempty <a class="uri" href="subset" title="wikilink">subset</a> of them sum to 0? For instance, does a subset of the set  add up to 0? The answer "yes, because the subset  adds up to zero" can be quickly verified with three additions. However, there is no known algorithm to find such a subset in polynomial time (there is one, however, in <a href="exponential_time" title="wikilink">exponential time</a>, which consists of 2<sup><em>n</em></sup>-n-1 tries), but such an algorithm exists if <strong>P</strong> = <strong>NP</strong>; hence this problem is in <strong>NP</strong> (quickly checkable) but not necessarily in <strong>P</strong> (quickly solvable).</p>

<p>An answer to the <strong>P</strong> = <strong>NP</strong> question would determine whether problems that can be verified in polynomial time, like the subset-sum problem, can also be solved in polynomial time. If it turned out that <strong>P</strong> ≠ <strong>NP</strong>, it would mean that there are problems in <strong>NP</strong> (such as <a href="NP-complete" title="wikilink"><strong>NP</strong>-complete</a> problems) that are harder to compute than to verify: they could not be solved in polynomial time, but the answer could be verified in polynomial time.</p>

<p>Aside from being an important problem in computational theory, a proof either way would have profound implications for mathematics, cryptography, algorithm research, <a href="artificial_intelligence" title="wikilink">artificial intelligence</a>, <a href="game_theory" title="wikilink">game theory</a>, multimedia processing, <a class="uri" href="philosophy" title="wikilink">philosophy</a>, <a class="uri" href="economics" title="wikilink">economics</a> and many other fields.</p>
<h2 id="context">Context</h2>

<p>The relation between the <a href="complexity_class" title="wikilink">complexity classes</a> <strong>P</strong> and <strong>NP</strong> is studied in <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, the part of the <a href="theory_of_computation" title="wikilink">theory of computation</a> dealing with the resources required during computation to solve a given problem. The most common resources are time (how many steps it takes to solve a problem) and space (how much memory it takes to solve a problem).</p>

<p>In such analysis, a model of the computer for which time must be analyzed is required. Typically such models assume that the computer is <em><a href="Deterministic_computation" title="wikilink">deterministic</a></em> (given the computer's present state and any inputs, there is only one possible action that the computer might take) and <em>sequential</em> (it performs actions one after the other).</p>

<p>In this theory, the class <strong>P</strong> consists of all those <em><a href="decision_problem" title="wikilink">decision problems</a></em> (defined <a href="#Formal_definitions" title="wikilink">below</a>) that can be solved on a deterministic sequential machine in an amount of time that is <a class="uri" href="polynomial" title="wikilink">polynomial</a> in the size of the input; the class <strong><a href="NP_(complexity)" title="wikilink">NP</a></strong> consists of all those decision problems whose positive solutions can be verified in <a href="polynomial_time" title="wikilink">polynomial time</a> given the right information, or equivalently, whose solution can be found in polynomial time on a <a href="Non-deterministic_Turing_machine" title="wikilink">non-deterministic</a> machine.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Clearly, <strong>P</strong> ⊆ <strong>NP</strong>. Arguably the biggest open question in <a href="theoretical_computer_science" title="wikilink">theoretical computer science</a> concerns the relationship between those two classes:</p>
<dl>
<dd>Is <strong>P</strong> equal to <strong>NP</strong>?
</dd>
</dl>

<p>In a 2002 poll of 100 researchers, 61 believed the answer to be no, 9 believed the answer is yes, and 22 were unsure; 8 believed the question may be <a href="independent_(mathematical_logic)" title="wikilink">independent</a> of the currently accepted axioms and therefore is impossible to prove or disprove.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>In 2012, 10 years later, the same poll was repeated. The number of researchers who answered was 151: 126 (83%) believed the answer to be no, 12 (9%) believed the answer is yes, 5 (3%) believed the question may be <a href="independent_(mathematical_logic)" title="wikilink">independent</a> of the currently accepted axioms and therefore is impossible to prove or disprove, 8 (5%) said either don't know or don't care or don't want the answer to be yes nor the problem to be resolved.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="np-complete">NP-complete</h2>

<p>  To attack the <strong>P</strong> = <strong>NP</strong> question, the concept of <strong>NP</strong>-completeness is very useful. <strong>NP</strong>-complete problems are a set of problems to each of which any other <strong>NP</strong>-problem can be reduced in polynomial time, and whose solution may still be verified in polynomial time. That is, any <strong>NP</strong> problem can be transformed into any of the <strong>NP</strong>-complete problems. Informally, an <strong>NP</strong>-complete problem is an '''NP '''problem that is at least as "tough" as any other problem in <strong>NP</strong>.</p>

<p><a href="NP-hard" title="wikilink"><strong>NP</strong>-hard</a> problems are those at least as hard as <strong>NP</strong> problems, i.e., all <strong>NP</strong> problems can be reduced (in polynomial time) to them. <strong>NP</strong>-hard problems need not be in <strong>NP</strong>, i.e., they need not have solutions verifiable in polynomial time.</p>

<p>For instance, the <a href="Boolean_satisfiability_problem" title="wikilink">Boolean satisfiability problem</a> is <strong>NP</strong>-complete by the <a href="Cook–Levin_theorem" title="wikilink">Cook–Levin theorem</a>, so <em>any</em> instance of <em>any</em> problem in <strong>NP</strong> can be transformed mechanically into an instance of the Boolean satisfiability problem in polynomial time. The Boolean satisfiability problem is one of many such <strong>NP</strong>-complete problems. If any <strong>NP</strong>-complete problem is in <strong>P</strong>, then it would follow that <strong>P</strong> = <strong>NP</strong>. Unfortunately, many important problems have been shown to be <strong>NP</strong>-complete, and not a single fast algorithm for any of them is known.</p>

<p>Based on the definition alone it is not obvious that <strong>NP</strong>-complete problems exist, a trivial and contrived <strong>NP</strong>-complete problem can be formulated as: given a description of a Turing machine M guaranteed to halt in polynomial time, does there exist a polynomial-size input that M will accept?<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> It is in <strong>NP</strong> because (given an input) it is simple to check whether M accepts the input by simulating M; it is <strong>NP</strong>-complete because the verifier for any particular instance of a problem in <strong>NP</strong> can be encoded as a polynomial-time machine M that takes the solution to be verified as input. Then the question of whether the instance is a yes or no instance is determined by whether a valid input exists.</p>

<p>The first natural problem proven to be <strong>NP</strong>-complete was the <a href="Boolean_satisfiability_problem" title="wikilink">Boolean satisfiability problem</a>. As noted above, this is the <a href="Cook–Levin_theorem" title="wikilink">Cook–Levin theorem</a>; its proof that satisfiability is <strong>NP</strong>-complete contains technical details about Turing machines as they relate to the definition of <strong>NP</strong>. However, after this problem was proved to be <strong>NP</strong>-complete, <a href="reduction_(complexity)" title="wikilink">proof by reduction</a> provided a simpler way to show that many other problems are also <strong>NP</strong>-complete, including the <a href="subset-sum_problem" title="wikilink">subset-sum problem</a> discussed earlier. Thus, a vast class of seemingly unrelated problems are all reducible to one another, and are in a sense "the same problem".</p>
<h2 id="harder-problems">Harder problems</h2>

<p>Although it is unknown whether <strong>P</strong> = <strong>NP</strong>, problems outside of <strong>P</strong> are known. A number of succinct problems (problems that operate not on normal input, but on a computational description of the input) are known to be <a href="EXPTIME#EXPTIME-complete" title="wikilink"><strong>EXPTIME</strong>-complete</a>. Because it can be shown that <strong>P</strong> ⊊ <strong><a class="uri" href="EXPTIME" title="wikilink">EXPTIME</a></strong>, these problems are outside <strong>P</strong>, and so require more than polynomial time. In fact, by the <a href="time_hierarchy_theorem" title="wikilink">time hierarchy theorem</a>, they cannot be solved in significantly less than exponential time. Examples include finding a perfect strategy for chess (on an <em>N</em> × <em>N</em> board)<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> and some other board games.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>The problem of deciding the truth of a statement in <a href="Presburger_arithmetic" title="wikilink">Presburger arithmetic</a> requires even more time. Fischer and <a href="Michael_O._Rabin" title="wikilink">Rabin</a> proved in 1974 that every algorithm that decides the truth of Presburger statements has a runtime of at least 

<math display="inline" id="P_versus_NP_problem:0">
 <semantics>
  <msup>
   <mn>2</mn>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>c</mi>
     <mi>n</mi>
    </mrow>
   </msup>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <times></times>
      <ci>c</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{2^{cn}}
  </annotation>
 </semantics>
</math>

 for some constant <em>c</em>. Here, <em>n</em> is the length of the Presburger statement. Hence, the problem is known to need more than exponential run time. Even more difficult are the <a href="undecidable_problem" title="wikilink">undecidable problems</a>, such as the <a href="halting_problem" title="wikilink">halting problem</a>. They cannot be completely solved by any algorithm, in the sense that for any particular algorithm there is at least one input for which that algorithm will not produce the right answer; it will either produce the wrong answer, finish without giving a conclusive answer, or otherwise run forever without producing any answer at all.</p>
<h2 id="problems-in-np-not-known-to-be-in-p-or-np-complete">Problems in NP not known to be in P or NP-complete</h2>

<p>It was shown by Ladner that if <strong>P</strong> ≠ <strong>NP</strong> then there exist problems in <strong>NP</strong> that are neither in <strong>P</strong> nor <strong>NP</strong>-complete.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> Such problems are called <strong>NP</strong>-intermediate problems. The <a href="graph_isomorphism_problem" title="wikilink">graph isomorphism problem</a>, the <a href="discrete_logarithm_problem" title="wikilink">discrete logarithm problem</a> and the <a href="integer_factorization_problem" title="wikilink">integer factorization problem</a> are examples of problems believed to be <strong>NP</strong>-intermediate. They are some of the very few <strong>NP</strong> problems not known to be in <strong>P</strong> or to be <strong>NP</strong>-complete.</p>

<p>The <a href="graph_isomorphism_problem" title="wikilink">graph isomorphism problem</a> is the computational problem of determining whether two finite <a href="Graph_(mathematics)" title="wikilink">graphs</a> are <a href="graph_isomorphism" title="wikilink">isomorphic</a>. An important unsolved problem in complexity theory is whether the graph isomorphism problem is in <strong>P</strong>, <strong>NP</strong>-complete, or <strong>NP</strong>-intermediate. The answer is not known, but it is believed that the problem is at least not <strong>NP</strong>-complete.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> If graph isomorphism is <strong>NP</strong>-complete, the <a href="polynomial_time_hierarchy" title="wikilink">polynomial time hierarchy</a> collapses to its second level.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> Since it is widely believed that the polynomial hierarchy does not collapse to any finite level, it is believed that graph isomorphism is not <strong>NP</strong>-complete. The best algorithm for this problem, due to <a href="Laszlo_Babai" title="wikilink">Laszlo Babai</a> and <a href="Eugene_Luks" title="wikilink">Eugene Luks</a> has run time 2<sup>O(√<em>n</em>log(<em>n</em>))</sup> for graphs with <em>n</em> vertices.</p>

<p>The <a href="integer_factorization_problem" title="wikilink">integer factorization problem</a> is the computational problem of determining the <a href="prime_factorization" title="wikilink">prime factorization</a> of a given integer. Phrased as a decision problem, it is the problem of deciding whether the input has a factor less than <em>k</em>. No efficient integer factorization algorithm is known, and this fact forms the basis of several modern cryptographic systems, such as the <a href="RSA_(algorithm)" title="wikilink">RSA</a> algorithm. The integer factorization problem is in <strong>NP</strong> and in <strong><a class="uri" href="co-NP" title="wikilink">co-NP</a></strong> (and even in <strong>UP</strong> and <strong>co-UP</strong><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a>). If the problem is <strong>NP</strong>-complete, the polynomial time hierarchy will collapse to its first level (i.e., <strong>NP</strong> = <strong>co-NP</strong>). The best known algorithm for integer factorization is the <a href="general_number_field_sieve" title="wikilink">general number field sieve</a>, which takes expected time</p>

<p>

<math display="block" id="P_versus_NP_problem:1">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mi>exp</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <msup>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mstyle displaystyle="false">
           <mfrac>
            <mrow>
             <mn>64</mn>
             <mi>n</mi>
            </mrow>
            <mn>9</mn>
           </mfrac>
          </mstyle>
          <mrow>
           <mi>log</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mn>2</mn>
            <mo stretchy="false">)</mo>
           </mrow>
          </mrow>
         </mrow>
         <mo>)</mo>
        </mrow>
        <mfrac>
         <mn>1</mn>
         <mn>3</mn>
        </mfrac>
       </msup>
       <msup>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mi>log</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi>n</mi>
            <mrow>
             <mi>log</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <mn>2</mn>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>)</mo>
        </mrow>
        <mfrac>
         <mn>2</mn>
         <mn>3</mn>
        </mfrac>
       </msup>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <exp></exp>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <times></times>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <cn type="integer">64</cn>
          <ci>n</ci>
         </apply>
         <cn type="integer">9</cn>
        </apply>
        <apply>
         <log></log>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <log></log>
        <apply>
         <times></times>
         <ci>n</ci>
         <apply>
          <log></log>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">2</cn>
        <cn type="integer">3</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O\left(\exp\left(\left(\tfrac{64n}{9}\log(2)\right)^{\frac{1}{3}}\left(\log(n%
\log(2))\right)^{\frac{2}{3}}\right)\right)
  </annotation>
 </semantics>
</math>

</p>

<p>to factor an <em>n</em>-bit integer. However, the best known <a href="quantum_algorithm" title="wikilink">quantum algorithm</a> for this problem, <a href="Shor's_algorithm" title="wikilink">Shor's algorithm</a>, does run in polynomial time. Unfortunately, this fact doesn't say much about where the problem lies with respect to non-quantum complexity classes.</p>
<h2 id="does-p-mean-easy">Does P mean "easy"?</h2>

<p> All of the above discussion has assumed that <strong>P</strong> means "easy" and "not in <strong>P</strong>" means "hard", an assumption known as <em><a href="Cobham's_thesis" title="wikilink">Cobham's thesis</a></em>. It is a common and reasonably accurate assumption in complexity theory; however, it has some caveats.</p>

<p>First, it is not always true in practice. A theoretical polynomial algorithm may have extremely large constant factors or exponents thus rendering it impractical. On the other hand, even if a problem is shown to be <strong>NP</strong>-complete, and even if <strong>P</strong> ≠ <strong>NP</strong>, there may still be effective approaches to tackling the problem in practice. There are algorithms for many <strong>NP</strong>-complete problems, such as the <a href="knapsack_problem" title="wikilink">knapsack problem</a>, the <a href="traveling_salesman_problem" title="wikilink">traveling salesman problem</a> and the <a href="Boolean_satisfiability_problem" title="wikilink">Boolean satisfiability problem</a>, that can solve to optimality many real-world instances in reasonable time. The empirical <a href="average-case_complexity" title="wikilink">average-case complexity</a> (time vs. problem size) of such algorithms can be surprisingly low. An example is the <a href="simplex_algorithm" title="wikilink">simplex algorithm</a> in <a href="linear_programming" title="wikilink">linear programming</a>, which works surprisingly well in practice; despite having exponential worst-case <a href="time_complexity" title="wikilink">time complexity</a> it runs on par with the best known polynomial-time algorithms.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>

<p>Second, there are types of computations which do not conform to the Turing machine model on which <strong>P</strong> and <strong>NP</strong> are defined, such as <a href="quantum_computation" title="wikilink">quantum computation</a> and <a href="randomized_algorithm" title="wikilink">randomized algorithms</a>.</p>
<h2 id="reasons-to-believe-p-np">Reasons to believe P ≠ NP</h2>

<p>According to polls,<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> many computer scientists believe that <strong>P</strong> ≠ <strong>NP</strong>. A key reason for this belief is that after decades of studying these problems no one has been able to find a polynomial-time algorithm for any of more than 3000 important known <strong>NP</strong>-complete problems (see <a href="List_of_NP-complete_problems" title="wikilink">List of <strong>NP</strong>-complete problems</a>). These algorithms were sought long before the concept of <strong>NP</strong>-completeness was even defined (<a href="Karp's_21_NP-complete_problems" title="wikilink">Karp's 21 <strong>NP</strong>-complete problems</a>, among the first found, were all well-known existing problems at the time they were shown to be <strong>NP</strong>-complete). Furthermore, the result <strong>P</strong> = <strong>NP</strong> would imply many other startling results that are currently believed to be false, such as <strong>NP</strong> = <strong><a class="uri" href="co-NP" title="wikilink">co-NP</a></strong> and <strong>P</strong> = <strong><a href="PH_(complexity)" title="wikilink">PH</a></strong>.</p>

<p>It is also intuitively argued that the existence of problems that are hard to solve but for which the solutions are easy to verify matches real-world experience.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> <mtpl></mtpl></p>

<p>On the other hand, some researchers believe that there is overconfidence in believing <strong>P</strong> ≠ <strong>NP</strong> and that researchers should explore proofs of <strong>P</strong> = <strong>NP</strong> as well. For example, in 2002 these statements were made:<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> </p>
<h2 id="consequences-of-solution">Consequences of solution</h2>

<p>One of the reasons the problem attracts so much attention is the consequences of the answer. Either direction of resolution would advance theory enormously, and perhaps have huge practical consequences as well.</p>

<p>===P = NP=== A proof that <strong>P</strong> = <strong>NP</strong> could have stunning practical consequences, if the proof leads to efficient methods for solving some of the important problems in <strong>NP</strong>. It is also possible that a proof would not lead directly to efficient methods, perhaps if the proof is <a href="non-constructive_proof" title="wikilink">non-constructive</a>, or the size of the bounding polynomial is too big to be efficient in practice. The consequences, both positive and negative, arise since various <strong>NP</strong>-complete problems are fundamental in many fields.</p>

<p>Cryptography, for example, relies on certain problems being difficult. A constructive and efficient solution<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> to an <strong>NP</strong>-complete problem such as <a href="Boolean_satisfiability_problem#3-satisfiability" title="wikilink">3-SAT</a> would break most existing cryptosystems including:</p>
<ul>
<li><a href="public-key_cryptography" title="wikilink">public-key cryptography</a>,<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> a foundation for many modern security applications such as secure financial transactions over the Internet; and</li>
<li><a href="symmetric_cipher" title="wikilink">symmetric ciphers</a> such as <a href="Advanced_Encryption_Standard" title="wikilink">AES</a> or <a href="Triple_DES" title="wikilink">3DES</a>,<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> used for the encryption of communications data.</li>
<li><a href="one-way_function" title="wikilink">one-way functions</a> used in <a href="hash_function" title="wikilink">cryptographic hashing</a>. The problem of finding a pre-image that hashes to a given value<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> must be difficult to be useful, and ideally should require exponential time. However, if P=NP, then finding a pre-image M can be done in polynomial time, through reduction to SAT.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></li>
</ul>

<p>These would need to be modified or replaced by <a href="information-theoretic_security" title="wikilink">information-theoretically secure</a> solutions not inherently based on P-NP equivalence.</p>

<p>On the other hand, there are enormous positive consequences that would follow from rendering tractable many currently mathematically intractable problems. For instance, many problems in <a href="operations_research" title="wikilink">operations research</a> are <strong>NP</strong>-complete, such as some types of <a href="integer_programming" title="wikilink">integer programming</a> and the <a href="travelling_salesman_problem" title="wikilink">travelling salesman problem</a>. Efficient solutions to these problems would have enormous implications for logistics. Many other important problems, such as some problems in <a href="protein_structure_prediction" title="wikilink">protein structure prediction</a>, are also <strong>NP</strong>-complete;<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> if these problems were efficiently solvable it could spur considerable advances in biology.</p>

<p>But such changes may pale in significance compared to the revolution an efficient method for solving <strong>NP</strong>-complete problems would cause in mathematics itself. Gödel, in his early thoughts on computational complexity, noted that a mechanical method that could solve any problem would revolutionize mathematics:<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a><a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> <mtpl></mtpl> Similarly, <a href="Stephen_Cook" title="wikilink">Stephen Cook</a> says<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> </p>

<p>Research mathematicians spend their careers trying to prove theorems, and some proofs have taken decades or even centuries to find after problems have been stated—for instance, <a href="Fermat's_Last_Theorem" title="wikilink">Fermat's Last Theorem</a> took over three centuries to prove. A method that is guaranteed to find proofs to theorems, should one exist of a "reasonable" size, would essentially end this struggle.</p>

<p><a href="Donald_Knuth" title="wikilink">Donald Knuth</a> has stated that he has come to believe that P = NP, but is reserved about the impact of a possible proof:<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> </p>
<h3 id="p-np">P ≠ NP</h3>

<p>A proof that showed that <strong>P</strong> ≠ <strong>NP</strong> would lack the practical computational benefits of a proof that <strong>P</strong> = <strong>NP</strong>, but would nevertheless represent a very significant advance in computational complexity theory and provide guidance for future research. It would allow one to show in a formal way that many common problems cannot be solved efficiently, so that the attention of researchers can be focused on partial solutions or solutions to other problems. Due to widespread belief in <strong>P</strong> ≠ <strong>NP</strong>, much of this focusing of research has already taken place.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p>

<p>Also <strong>P</strong> ≠ <strong>NP</strong> still leaves open the <a href="average-case_complexity" title="wikilink">average-case complexity</a> of hard problems in <strong>NP</strong>. For example, it is possible that SAT requires exponential time in the worst case, but that almost all randomly selected instances of it are efficiently solvable. <a href="Russell_Impagliazzo" title="wikilink">Russell Impagliazzo</a> has described five hypothetical "worlds" that could result from different possible resolutions to the average-case complexity question.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> These range from "Algorithmica", where <strong>P</strong> = <strong>NP</strong> and problems like SAT can be solved efficiently in all instances, to "Cryptomania", where <strong>P</strong> ≠ <strong>NP</strong> and generating hard instances of problems outside <strong>P</strong> is easy, with three intermediate possibilities reflecting different possible distributions of difficulty over instances of <strong>NP-hard</strong> problems. The "world" where <strong>P</strong> ≠ <strong>NP</strong> but all problems in <strong>NP</strong> are tractable in the average case is called "Heuristica" in the paper. A <a href="Princeton_University" title="wikilink">Princeton University</a> workshop in 2009 studied the status of the five worlds.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></p>
<h2 id="results-about-difficulty-of-proof">Results about difficulty of proof</h2>

<p>Although the <strong>P</strong> = <strong>NP</strong>? problem itself remains open despite a million-dollar prize and a huge amount of dedicated research, efforts to solve the problem have led to several new techniques. In particular, some of the most fruitful research related to the <strong>P</strong> = <strong>NP</strong> problem has been in showing that existing proof techniques are not powerful enough to answer the question, thus suggesting that novel technical approaches are required.</p>

<p>As additional evidence for the difficulty of the problem, essentially all known proof techniques in <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a> fall into one of the following classifications, each of which is known to be insufficient to prove that <strong>P</strong> ≠ <strong>NP</strong>:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Classification</p></th>
<th style="text-align: left;">
<p>Definition</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="Relativizing_proof" title="wikilink">Relativizing proofs</a></p></td>
<td style="text-align: left;">
<p>Imagine a world where every algorithm is allowed to make queries to some fixed subroutine called an <a href="oracle_machine" title="wikilink">oracle</a>, and the running time of the oracle is not counted against the running time of the algorithm. Most proofs (especially classical ones) apply uniformly in a world with oracles regardless of what the oracle does. These proofs are called <em>relativizing</em>. In 1975, Baker, Gill, and <a href="Robert_M._Solovay" title="wikilink">Solovay</a> showed that <strong>P</strong> = <strong>NP</strong> with respect to some oracles, while <strong>P</strong> ≠ <strong>NP</strong> for other oracles.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> Since relativizing proofs can only prove statements that are uniformly true with respect to all possible oracles, this showed that relativizing techniques cannot resolve <strong>P</strong> = <strong>NP</strong>.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Natural_proof" title="wikilink">Natural proofs</a></p></td>
<td style="text-align: left;">
<p>In 1993, <a href="Alexander_Razborov" title="wikilink">Alexander Razborov</a> and <a href="Steven_Rudich" title="wikilink">Steven Rudich</a> defined a general class of proof techniques for circuit complexity lower bounds, called <em><a href="natural_proof" title="wikilink">natural proofs</a></em>. At the time all previously known circuit lower bounds were natural, and circuit complexity was considered a very promising approach for resolving <strong>P</strong> = <strong>NP</strong>. However, Razborov and Rudich showed that, if <a href="one-way_functions" title="wikilink">one-way functions</a> exist, then no natural proof method can distinguish between <strong>P</strong> and <strong>NP</strong>. Although one-way functions have never been formally proven to exist, most mathematicians believe that they do, and a proof or disproof of their existence would be a much stronger statement than the quantification of <strong>P</strong> relative to <strong>NP</strong>. Thus it is unlikely that natural proofs alone can resolve <strong>P</strong> = <strong>NP</strong>.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Algebrizing proofs</p></td>
<td style="text-align: left;">
<p>After the Baker-Gill-Solovay result, new non-relativizing proof techniques were successfully used to prove that <a href="IP_(complexity)" title="wikilink">IP</a> = <a class="uri" href="PSPACE" title="wikilink">PSPACE</a>. However, in 2008, <a href="Scott_Aaronson" title="wikilink">Scott Aaronson</a> and <a href="Avi_Wigderson" title="wikilink">Avi Wigderson</a> showed that the main technical tool used in the <strong>IP</strong> = <strong>PSPACE</strong> proof, known as <em>arithmetization</em>, was also insufficient to resolve <strong>P</strong> = <strong>NP</strong>.<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a></p></td>
</tr>
</tbody>
</table>

<p>These barriers are another reason why <strong>NP</strong>-complete problems are useful: if a polynomial-time algorithm can be demonstrated for an <strong>NP</strong>-complete problem, this would solve the <strong>P</strong> = <strong>NP</strong> problem in a way not excluded by the above results.</p>

<p>These barriers have also led some computer scientists to suggest that the <strong>P</strong> versus <strong>NP</strong> problem may be <a href="Independence_(mathematical_logic)" title="wikilink">independent</a> of standard axiom systems like <a class="uri" href="ZFC" title="wikilink">ZFC</a> (cannot be proved or disproved within them). The interpretation of an independence result could be that either no polynomial-time algorithm exists for any <strong>NP</strong>-complete problem, and such a proof cannot be constructed in (e.g.) ZFC, or that polynomial-time algorithms for <strong>NP</strong>-complete problems may exist, but it's impossible to prove in ZFC that such algorithms are correct.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> However, if it can be shown, using techniques of the sort that are currently known to be applicable, that the problem cannot be decided even with much weaker assumptions extending the <a href="Peano_axioms" title="wikilink">Peano axioms</a> (PA) for integer arithmetic, then there would necessarily exist nearly-polynomial-time algorithms for every problem in <strong>NP</strong>.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> Therefore, if one believes (as most complexity theorists do) that not all problems in <strong>NP</strong> have efficient algorithms, it would follow that proofs of independence using those techniques cannot be possible. Additionally, this result implies that proving independence from PA or ZFC using currently known techniques is no easier than proving the existence of efficient algorithms for all problems in <strong>NP</strong>.</p>

<p>It should also be noted that there are statements which are independent in ZFC and cannot be verified as such by any Turing machine, and so in this sense it is possible for a problem to never possibly be proven true, false, or even independent of ZFC. It is not currently known whether or not <strong>P</strong> = <strong>NP</strong> is such a problem.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a></p>
<h2 id="claimed-solutions">Claimed solutions <span id="Deolalikar"></span></h2>

<p>While the <strong>P</strong> versus <strong>NP</strong> problem is generally considered unsolved,<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a> many amateur and some professional researchers have claimed solutions. Woeginger has a comprehensive list.<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a> An August 2010 claim of proof that <strong>P</strong> ≠ <strong>NP</strong>, by Vinay Deolalikar, researcher at <a href="HP_Labs" title="wikilink">HP Labs</a>, <a href="Palo_Alto" title="wikilink">Palo Alto</a>, received heavy Internet and press attention after being initially described as " to be a relatively serious attempt" by two leading specialists.<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> The proof has been reviewed publicly by academics,<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a><a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> and <a href="Neil_Immerman" title="wikilink">Neil Immerman</a>, an expert in the field, had pointed out two possibly fatal errors in the proof.<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a> In September 2010, Deolalikar was reported to be working on a detailed expansion of his attempted proof.<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a> However, opinions expressed by several notable theoretical computer scientists indicate that the attempted proof is neither correct nor a significant advancement in the understanding of the problem.<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a> This assessment prompted a May 2013 <em><a href="The_New_Yorker" title="wikilink">The New Yorker</a></em> article to call the proof attempt "thoroughly discredited."<a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a></p>
<h2 id="logical-characterizations">Logical characterizations</h2>

<p>The <strong>P</strong> = <strong>NP</strong> problem can be restated in terms of expressible certain classes of logical statements, as a result of work in <a href="descriptive_complexity" title="wikilink">descriptive complexity</a>.</p>

<p>Consider all language of finite structures with a fixed <a href="signature_(logic)" title="wikilink">signature</a> including a <a href="linear_order" title="wikilink">linear order</a> relation. Then, all such languages in <strong>P</strong> can be expressed in <a href="first-order_logic" title="wikilink">first-order logic</a> with the addition of a suitable least <a href="fixed-point_combinator" title="wikilink">fixed-point combinator</a>. Effectively, this, in combination with the order, allows the definition of recursive functions. As long as the signature contains at least one predicate or function in addition to the distinguished order relation, so that the amount of space taken to store such finite structures is actually polynomial in the number of elements in the structure, this precisely characterizes <strong>P</strong>.</p>

<p>Similarly, <strong>NP</strong> is the set of languages expressible in existential <a href="second-order_logic" title="wikilink">second-order logic</a>—that is, second-order logic restricted to exclude <a href="universal_quantification" title="wikilink">universal quantification</a> over relations, functions, and subsets. The languages in the <a href="polynomial_hierarchy" title="wikilink">polynomial hierarchy</a>, <strong><a href="PH_(complexity)" title="wikilink">PH</a></strong>, correspond to all of second-order logic. Thus, the question "is <strong>P</strong> a proper subset of <strong>NP</strong>" can be reformulated as "is existential second-order logic able to describe languages (of finite linearly ordered structures with nontrivial signature) that first-order logic with least fixed point cannot?".<a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a> The word "existential" can even be dropped from the previous characterization, since <strong>P</strong> = <strong>NP</strong> if and only if <strong>P</strong> = <strong>PH</strong> (as the former would establish that <strong>NP</strong> = <strong>co-NP</strong>, which in turn implies that <strong>NP</strong> = <strong>PH</strong>).</p>
<h2 id="polynomial-time-algorithms">Polynomial-time algorithms</h2>

<p>No algorithm for any <strong>NP</strong>-complete problem is known to run in polynomial time. However, there are algorithms for <strong>NP</strong>-complete problems with the property that if <strong>P</strong> = <strong>NP</strong>, then the algorithm runs in polynomial time (although with enormous constants, making the algorithm impractical). The following algorithm, due to <a href="Leonid_Levin" title="wikilink">Levin</a> (without any citation), is such an example below. It correctly accepts the <strong>NP</strong>-complete language <a href="subset_sum_problem" title="wikilink">SUBSET-SUM</a>. It runs in polynomial time if and only if <strong>P</strong> = <strong>NP</strong>:</p>

<p><code>// Algorithm that accepts the </code><strong><code>NP</code></strong><code>-complete language SUBSET-SUM.</code><br/>
<code>//</code><br/>
<code>// this is a polynomial-time algorithm if and only if </code><strong><code>P</code></strong><code> = </code><strong><code>NP</code></strong><code>.</code><br/>
<code>//</code><br/>
<code>// "Polynomial-time" means it returns "yes" in polynomial time when</code><br/>
<code>// the answer should be "yes", and runs forever when it is "no".</code><br/>
<code>//</code><br/>
<code>// Input: S = a finite set of integers</code><br/>
<code>// Output: "yes" if any subset of S adds up to 0.</code><br/>
<code>// Runs forever with no output otherwise.</code><br/>
<code>// Note: "Program number P" is the program obtained by</code><br/>
<code>// writing the integer P in binary, then</code><br/>
<code>// considering that string of bits to be a</code><br/>
<code>// program. Every possible program can be</code><br/>
<code>// generated this way, though most do nothing</code><br/>
<code>// because of syntax errors. </code><br/>
<code> FOR N = 1...∞</code><br/>
<code>  FOR P = 1...N</code><br/>
<code>    Run program number P for N steps with input S</code><br/>
<code>    IF the program outputs a list of distinct integers</code><br/>
<code>      AND the integers are all in S</code><br/>
<code>      AND the integers sum to 0</code><br/>
<code>     THEN</code><br/>
<code>      OUTPUT "yes" and HALT</code></p>

<p>If, and only if, <strong>P</strong> = <strong>NP</strong>, then this is a polynomial-time algorithm accepting an <strong>NP</strong>-complete language. "Accepting" means it gives "yes" answers in polynomial time, but is allowed to run forever when the answer is "no" (also known as a <em>semi-algorithm</em>).</p>

<p>This algorithm is enormously impractical, even if <strong>P</strong> = <strong>NP</strong>. If the shortest program that can solve SUBSET-SUM in polynomial time is <em>b</em> bits long, the above algorithm will try at least 2<sup><em>b</em></sup>−1 other programs first.</p>
<h2 id="formal-definitions">Formal definitions</h2>
<h3 id="p-and-np">P and NP</h3>

<p>Conceptually speaking, a <em>decision problem</em> is a problem that takes as input some <a href="String_(computer_science)" title="wikilink">string</a> <em>w</em> over an alphabet Σ, and outputs "yes" or "no". If there is an <a class="uri" href="algorithm" title="wikilink">algorithm</a> (say a <a href="Turing_machine" title="wikilink">Turing machine</a>, or a <a href="Computer_programming" title="wikilink">computer program</a> with unbounded memory) that can produce the correct answer for any input string of length <em>n</em> in at most <em>cn<sup>k</sup></em> steps, where <em>k</em> and <em>c</em> are constants independent of the input string, then we say that the problem can be solved in <em>polynomial time</em> and we place it in the class <strong>P</strong>. Formally, <strong>P</strong> is defined as the set of all languages that can be decided by a deterministic polynomial-time Turing machine. That is,</p>

<p>

<math display="block" id="P_versus_NP_problem:2">
 <semantics>
  <mrow>
   <mi>𝐏</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>L</mi>
    <mo>:</mo>
    <mrow>
     <mi>L</mi>
     <mo>=</mo>
     <mrow>
      <mi>L</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>M</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mtext>for some deterministic polynomial-time Turing machine</mtext>
      <mi>M</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐏</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>L</ci>
     <apply>
      <eq></eq>
      <ci>L</ci>
      <apply>
       <times></times>
       <ci>L</ci>
       <ci>M</ci>
       <mtext>for some deterministic polynomial-time Turing machine</mtext>
       <ci>M</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{P}=\{L:L=L(M)\text{ for some deterministic polynomial-time Turing %
machine }M\}
  </annotation>
 </semantics>
</math>

 where</p>

<p>

<math display="block" id="P_versus_NP_problem:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>M</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>w</mi>
     <mo>∈</mo>
     <msup>
      <mi mathvariant="normal">Σ</mi>
      <mo>*</mo>
     </msup>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mi>M</mi>
     <mtext>accepts</mtext>
     <mi>w</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>L</ci>
     <ci>M</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>w</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-Σ</ci>
       <times></times>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>M</ci>
      <mtext>accepts</mtext>
      <ci>w</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(M)=\{w\in\Sigma^{*}:M\text{ accepts }w\}
  </annotation>
 </semantics>
</math>

 and a deterministic polynomial-time Turing machine is a deterministic Turing machine <em>M</em> that satisfies the following two conditions:</p>
<ol>
<li><em>M</em> halts on all input <em>w</em> and</li>
<li>there exists 

<math display="inline" id="P_versus_NP_problem:4">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>∈</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>k</ci>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\in N
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="P_versus_NP_problem:5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>T</mi>
     <mi>M</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>n</mi>
      <mi>k</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>M</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{M}(n)\in O(n^{k})
  </annotation>
 </semantics>
</math>

, where <em>O</em> refers to the <a href="Big_O_notation#Formal_definition" title="wikilink">big O notation</a> and</li>
</ol>
<dl>
<dd><dl>
<dd>

<math display="inline" id="P_versus_NP_problem:6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>T</mi>
     <mi>M</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>max</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>t</mi>
        <mi>M</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>w</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>:</mo>
      <mrow>
       <mrow>
        <mi>w</mi>
        <mo>∈</mo>
        <msup>
         <mi mathvariant="normal">Σ</mi>
         <mo>*</mo>
        </msup>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">|</mo>
         <mi>w</mi>
         <mo stretchy="false">|</mo>
        </mrow>
        <mo>=</mo>
        <mi>n</mi>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>T</ci>
      <ci>M</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <max></max>
     <apply>
      <ci>normal-:</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>M</ci>
       </apply>
       <ci>w</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <in></in>
        <ci>w</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-Σ</ci>
         <times></times>
        </apply>
       </apply>
       <apply>
        <eq></eq>
        <apply>
         <abs></abs>
         <ci>w</ci>
        </apply>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{M}(n)=\max\{t_{M}(w):w\in\Sigma^{*},|w|=n\}
  </annotation>
 </semantics>
</math>


</dd>
<dd>

<math display="inline" id="P_versus_NP_problem:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>t</mi>
      <mi>M</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>w</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mtext>number of steps</mtext>
     <mi>M</mi>
     <mtext>takes to halt on input</mtext>
     <mi>w</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>M</ci>
     </apply>
     <ci>w</ci>
    </apply>
    <apply>
     <times></times>
     <mtext>number of steps</mtext>
     <ci>M</ci>
     <mtext>takes to halt on input</mtext>
     <ci>w</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{M}(w)=\text{ number of steps }M\text{ takes to halt on input }w.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p><strong>NP</strong> can be defined similarly using nondeterministic Turing machines (the traditional way). However, a modern approach to define <strong>NP</strong> is to use the concept of <em><a href="Certificate_(complexity)" title="wikilink">certificate</a></em> and <em>verifier</em>. Formally, <strong>NP</strong> is defined as the set of languages over a finite alphabet that have a verifier that runs in polynomial time, where the notion of "verifier" is defined as follows.</p>

<p>Let <em>L</em> be a language over a finite alphabet, Σ.</p>

<p><em>L</em> ∈ <strong>NP</strong> if, and only if, there exists a binary relation 

<math display="inline" id="P_versus_NP_problem:8">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>⊂</mo>
   <mrow>
    <msup>
     <mi mathvariant="normal">Σ</mi>
     <mo>*</mo>
    </msup>
    <mo>×</mo>
    <msup>
     <mi mathvariant="normal">Σ</mi>
     <mo>*</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>R</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Σ</ci>
      <times></times>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Σ</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R\subset\Sigma^{*}\times\Sigma^{*}
  </annotation>
 </semantics>
</math>


 and a positive integer <em>k</em> such that the following two conditions are satisfied:</p>
<ol>
<li>For all 

<math display="inline" id="P_versus_NP_problem:9">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msup>
    <mi mathvariant="normal">Σ</mi>
    <mo>*</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Σ</ci>
     <times></times>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\Sigma^{*}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="P_versus_NP_problem:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>∈</mo>
    <mi>L</mi>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mrow>
     <mo>∃</mo>
     <mi>y</mi>
    </mrow>
    <mo>∈</mo>
    <msup>
     <mi mathvariant="normal">Σ</mi>
     <mo>*</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <apply>
     <in></in>
     <ci>x</ci>
     <ci>L</ci>
    </apply>
    <apply>
     <in></in>
     <apply>
      <exists></exists>
      <ci>y</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Σ</ci>
      <times></times>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in L\Leftrightarrow\exists y\in\Sigma^{*}
  </annotation>
 </semantics>
</math>

 such that (<em>x</em>, <em>y</em>) ∈ <em>R</em> and 

<math display="inline" id="P_versus_NP_problem:11">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>x</mi>
       <mo stretchy="false">|</mo>
      </mrow>
      <mi>k</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <abs></abs>
     <ci>y</ci>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <ci>x</ci>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |y|\in O(|x|^{k})
  </annotation>
 </semantics>
</math>

; and</li>
<li>the language 

<math display="inline" id="P_versus_NP_problem:12">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mi>R</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>x</mi>
     <mi mathvariant="normal">#</mi>
     <mi>y</mi>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∈</mo>
     <mi>R</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>R</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>normal-#</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <in></in>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
      <ci>R</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{R}=\{x\#y:(x,y)\in R\}
  </annotation>
 </semantics>
</math>

 over 

<math display="inline" id="P_versus_NP_problem:13">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Σ</mi>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi mathvariant="normal">#</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>normal-Σ</ci>
    <set>
     <ci>normal-#</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma\cup\{\#\}
  </annotation>
 </semantics>
</math>


 is decidable by a Turing machine in polynomial time.</li>
</ol>

<p>A Turing machine that decides <em>L<sub>R</sub></em> is called a <em>verifier</em> for <em>L</em> and a <em>y</em> such that (<em>x</em>, <em>y</em>) ∈ <em>R</em> is called a <em>certificate of membership</em> of <em>x</em> in <em>L</em>.</p>

<p>In general, a verifier does not have to be polynomial-time. However, for <em>L</em> to be in <strong>NP</strong>, there must be a verifier that runs in polynomial time.</p>
<h4 id="example">Example</h4>

<p>Let</p>

<p>

<math display="block" id="P_versus_NP_problem:14">
 <semantics>
  <mrow>
   <mi>COMPOSITE</mi>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mrow>
     <mi>x</mi>
     <mo>∈</mo>
     <mi>ℕ</mi>
    </mrow>
    <mo>∣</mo>
    <mrow>
     <mrow>
      <mi>x</mi>
      <mo>=</mo>
      <mrow>
       <mi>p</mi>
       <mi>q</mi>
       <mtext>for integers</mtext>
       <mi>p</mi>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>q</mi>
      <mo>></mo>
      <mn>1</mn>
     </mrow>
    </mrow>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>COMPOSITE</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>x</ci>
      <ci>ℕ</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <eq></eq>
       <ci>x</ci>
       <apply>
        <times></times>
        <ci>p</ci>
        <ci>q</ci>
        <mtext>for integers</mtext>
        <ci>p</ci>
       </apply>
      </apply>
      <apply>
       <gt></gt>
       <ci>q</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{COMPOSITE}=\left\{x\in\mathbb{N}\mid x=pq\text{ for integers }p,q>1\right\}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="inline" id="P_versus_NP_problem:15">
 <semantics>
  <mrow>
   <msup>
    <mi>L</mi>
    <mo>′</mo>
   </msup>
   <msub>
    <mo>≤</mo>
    <mi>p</mi>
   </msub>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <leq></leq>
     <ci>p</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>L</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{\prime}\leq_{p}L
  </annotation>
 </semantics>
</math>

), where 

<math display="block" id="P_versus_NP_problem:16">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mrow>
     <mi>w</mi>
     <mo>∈</mo>
     <msup>
      <mi>L</mi>
      <mo>′</mo>
     </msup>
    </mrow>
    <mo>⇔</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>w</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∈</mo>
     <mi>L</mi>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <apply>
     <in></in>
     <ci>w</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>w</ci>
     </apply>
     <ci>L</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (w\in L^{\prime}\Leftrightarrow f(w)\in L)
  </annotation>
 </semantics>
</math>

 if, and only if, the following two conditions are satisfied:</p>
<ol>
<li><ol>
<li>There exists <em>f</em> : Σ* → Σ* such that for all <em>w</em> in Σ* we have

<math display="inline" id="P_versus_NP_problem:17">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>N</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>N</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(N^{2})
  </annotation>
 </semantics>
</math>

; and</li>
<li>there exists a polynomial-time Turing machine that halts with <em>f</em>(<em>w</em>) on its tape on any input <em>w</em>.</li>
</ol></li>
</ol>
<h2 id="popular-culture">Popular culture</h2>
<ul>
<li>The film <em><a href="Travelling_Salesman_(2012_film)" title="wikilink">Travelling Salesman</a></em>, by director Timothy Lanzone, is the story of four mathematicians hired by the US government to solve the P vs. NP problem.<a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a></li>
<li>In the <a class="uri" href="Netflix" title="wikilink">Netflix</a> drama series <a href="Elementary_(TV_series)" title="wikilink">Elementary</a>, episode 2 of season 2, Inspector Sherlock Holmes finds that a double <a class="uri" href="homicide" title="wikilink">homicide</a> is connected to the solving of the P versus NP problem. It is suggested that the solution to this problem would have major implications for the cracking of modern <a class="uri" href="encryption" title="wikilink">encryption</a>, thus making the solution highly valuable.<a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a></li>
<li>In the crime show <a class="uri" href="Numb3rs" title="wikilink">Numb3rs</a>, Charlie Epps is often consumed with trying to solve the P vs. NP problem.</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Game_complexity" title="wikilink">Game complexity</a></li>
<li><a href="Unique_games_conjecture" title="wikilink">Unique games conjecture</a></li>
<li><a href="Unsolved_problems_in_computer_science" title="wikilink">Unsolved problems in computer science</a></li>
<li><a href="Unsolved_problems_in_mathematics" title="wikilink">Unsolved problems in mathematics</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
<li></li>
<li>

<p><a href="http://www.wisdom.weizmann.ac.il/~oded/bc-drafts.html">Online drafts</a></p></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>Fortnow, Lance. <em><a href="http://press.princeton.edu/titles/9937.html">The Golden Ticket: P, NP, and the Search for the Impossible</a></em> ISBN 9780691156491. Princeton University Press. Princeton, NJ (2013)</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.claymath.org/millennium-problems">The Clay Mathematics Institute Millennium Prize Problems</a></li>
<li></li>
<li>Gerhard J. Woeginger. <a href="http://www.win.tue.nl/~gwoegi/P-versus-NP.htm">The P-versus-NP page</a>. A list of links to a number of purported solutions to the problem. Some of these links state that P equals NP, some of them state the opposite. It is probable that all these alleged solutions are incorrect.</li>
<li><a href="Scott_Aaronson" title="wikilink">Scott Aaronson</a> <a href="http://scottaaronson.com/blog/?p=122">'s Shtetl Optimized blog: Reasons to believe</a>, a list of justifications for the belief that P ≠ NP</li>
</ul>

<p>"</p>

<p><a href="Category:Structural_complexity_theory" title="wikilink">Category:Structural complexity theory</a> <a href="Category:Mathematical_optimization" title="wikilink">Category:Mathematical optimization</a> <a class="uri" href="Category:Conjectures" title="wikilink">Category:Conjectures</a> <a href="Category:Unsolved_problems_in_mathematics" title="wikilink">Category:Unsolved problems in mathematics</a> <a href="Category:Unsolved_problems_in_computer_science" title="wikilink">Category:Unsolved problems in computer science</a> <a href="Category:Millennium_Prize_Problems" title="wikilink">Category:Millennium Prize Problems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">R. E. Ladner "On the structure of polynomial time reducibility," <a href="Journal_of_the_ACM" title="wikilink">Journal of the ACM</a>, 22, pp. 151–171, 1975. Corollary 1.1. [<a class="uri" href="http://portal.acm.org/citation.cfm?id=321877&amp;dl">http://portal.acm.org/citation.cfm?id=321877&amp;dl;</a>;=ACM&amp;coll;=&amp;CFID;=15151515&amp;CFTOKEN;=6184618 ACM site].<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">Sipser, Michael: <em>Introduction to the Theory of Computation, Second Edition, International Edition</em>, page 270. Thomson Course Technology, 2006. Definition 7.19 and Theorem 7.20.<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="Lance_Fortnow" title="wikilink">Lance Fortnow</a>. Computational Complexity Blog: <a href="http://weblog.fortnow.com/2002/09/complexity-class-of-week-factoring.html">Complexity Class of the Week: Factoring</a>. 13 September 2002.<a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19">, point 9.<a href="#fnref19">↩</a></li>
<li id="fn20"></li>
<li id="fn21">Exactly how efficient a solution must be to pose a threat to cryptography depends on the details. A solution of 

<math display="inline" id="P_versus_NP_problem:18">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>N</mi>
     <mn>4</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ω</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>N</ci>
     <cn type="integer">4</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(N^{4})
  </annotation>
 </semantics>
</math>


 or better and a reasonable constant term would be disastrous. On the other hand, a solution that is <span class="LaTeX">$\Omega(N^4)$</span> or worse in almost all cases would not pose an immediate practical danger.<a href="#fnref21">↩</a></li>
<li id="fn22">See  for a reduction of factoring to SAT. A 512 bit factoring problem (8400 MIPS-years when factored) translates to a SAT problem of 63,652 variables and 406,860 clauses.<a href="#fnref22">↩</a></li>
<li id="fn23">See, for example,  in which an instance of DES is encoded as a SAT problem with 10336 variables and 61935 clauses. A 3DES problem instance would be about 3 times this size.<a href="#fnref23">↩</a></li>
<li id="fn24">Find a message<em>M</em> that when hashed by the function <em>H()</em> gives a digest <em>h</em>, or <em>H(M)=h</em><a href="#fnref24">↩</a></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27">History of this letter and its translation from <a href="#fnref27">↩</a></li>
<li id="fn28"> From pages 359–376 of Optimization Stories, M. Grötschel (editor), a special issue of ¨ Documenta Mathematica, published in August 2012 and distributed to attendees at the 21st International Symposium on Mathematical Programming in Berlin.<a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
<li id="fn31"><a href="#fnref31">↩</a></li>
<li id="fn32">R. Impagliazzo, <a href="http://cseweb.ucsd.edu/~russell/average.ps">"A personal view of average-case complexity,"</a> sct, pp.134, 10th Annual Structure in Complexity Theory Conference (SCT'95), 1995<a href="#fnref32">↩</a></li>
<li id="fn33"><a href="#fnref33">↩</a></li>
<li id="fn34">T. P. Baker, J. Gill, R. Solovay. <em>Relativizations of the <strong>P</strong> =? <strong>NP</strong> Question</em>. <a href="SIAM_Journal_on_Computing" title="wikilink">SIAM Journal on Computing</a>, 4(4): 431–442 (1975)<a href="#fnref34">↩</a></li>
<li id="fn35"><a href="#fnref35">↩</a></li>
<li id="fn36">.<a href="#fnref36">↩</a></li>
<li id="fn37">.<a href="#fnref37">↩</a></li>
<li id="fn38">.<a href="#fnref38">↩</a></li>
<li id="fn39"><a href="#fnref39">↩</a></li>
<li id="fn40"><a href="#fnref40">↩</a></li>
<li id="fn41"><a href="#fnref41">↩</a></li>
<li id="fn42"><a href="#fnref42">↩</a></li>
<li id="fn43">Science News, <a href="http://www.sciencenews.org/index/generic/activity/view/id/63252/title/Crowdsourcing_peer_review">"Crowdsourcing peer review"</a><a href="#fnref43">↩</a></li>
<li id="fn44"><a href="#fnref44">↩</a></li>
<li id="fn45"><a href="#fnref45">↩</a></li>
<li id="fn46">Gödel’s Lost Letter and P=NP, <a href="http://rjlipton.wordpress.com/2010/08/10/update-on-deolalikars-proof-that-p%E2%89%A0np/#comment-4885">Update on Deolalikar’s Proof that P≠NP</a><a href="#fnref46">↩</a></li>
<li id="fn47"><a href="#fnref47">↩</a></li>
<li id="fn48">Elvira Mayordomo. <a href="http://www.unizar.es/acz/05Publicaciones/Monografias/MonografiasPublicadas/Monografia26/057Mayordomo.pdf">"P versus NP"</a> <em>Monografías de la Real Academia de Ciencias de Zaragoza</em> <strong>26</strong>: 57–68 (2004).<a href="#fnref48">↩</a></li>
<li id="fn49"><a href="#fnref49">↩</a></li>
<li id="fn50"><a href="#fnref50">↩</a></li>
</ol>
</section>
</body>
</html>
