<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="290">Cut (graph theory)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Cut (graph theory)</h1>
<hr/>

<p>In <a href="graph_theory" title="wikilink">graph theory</a>, a <strong>cut</strong> is a <a href="Partition_of_a_set" title="wikilink">partition</a> of the <a href="Vertex_(graph_theory)" title="wikilink">vertices</a> of a graph into two <a href="Disjoint_set" title="wikilink">disjoint subsets</a>. Any cut determines a <strong>cut-set</strong>, the set of edges that have one endpoint in each subset of the partition. These edges are said to <strong>cross</strong> the cut. In a <a href="connected_graph" title="wikilink">connected graph</a>, each cut-set determines a unique cut, and in some cases cuts are identified with their cut-sets rather than with their vertex partitions.</p>

<p>In a <a href="flow_network" title="wikilink">flow network</a>, an <strong>s-t cut</strong> is a cut that requires the <a href="Glossary_of_graph_theory#Direction" title="wikilink"><em>source</em></a> and the <a href="Glossary_of_graph_theory#Direction" title="wikilink"><em>sink</em></a> to be in different subsets, and its <em>cut-set</em> only consists of edges going from the source's side to the sink's side. The <em>capacity</em> of an s-t cut is defined as the sum of <a href="Capacity_of_a_set" title="wikilink">capacity</a> of each edge in the <em>cut-set</em>.</p>
<h2 id="definition">Definition</h2>

<p>A <strong>cut</strong> 

<math display="inline" id="Cut_(graph_theory):0">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <interval closure="open">
     <ci>S</ci>
     <ci>T</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=(S,T)
  </annotation>
 </semantics>
</math>

 is a partition of 

<math display="inline" id="Cut_(graph_theory):1">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 of a graph 

<math display="inline" id="Cut_(graph_theory):2">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <interval closure="open">
     <ci>V</ci>
     <ci>E</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=(V,E)
  </annotation>
 </semantics>
</math>

 into two subsets <em>S</em> and <em>T</em>. The <strong>cut-set</strong> of a cut 

<math display="inline" id="Cut_(graph_theory):3">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>S</mi>
    <mo>,</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <interval closure="open">
     <ci>S</ci>
     <ci>T</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=(S,T)
  </annotation>
 </semantics>
</math>

 is the set 

<math display="inline" id="Cut_(graph_theory):4">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <mi>E</mi>
   </mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <mrow>
     <mi>u</mi>
     <mo>∈</mo>
     <mi>S</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>v</mi>
     <mo>∈</mo>
     <mi>T</mi>
    </mrow>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <in></in>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
     <ci>E</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <in></in>
      <ci>u</ci>
      <ci>S</ci>
     </apply>
     <apply>
      <in></in>
      <ci>v</ci>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{(u,v)\in E|u\in S,v\in T\}
  </annotation>
 </semantics>
</math>

 of edges that have one endpoint in <em>S</em> and the other endpoint in <em>T</em>. If <em>s</em> and <em>t</em> are specified vertices of the graph <em>G</em>, then an <strong><em>s</em>–<em>t</em> cut</strong> is a cut in which <em>s</em> belongs to the set <em>S</em> and <em>t</em> belongs to the set <em>T</em>.</p>

<p>In an unweighted undirected graph, the <em>size</em> or <em>weight</em> of a cut is the number of edges crossing the cut. In a <a href="Graph_(mathematics)#Weighted_graph" title="wikilink">weighted graph</a>, the <strong>value</strong> or <strong>weight</strong> is defined by the sum of the weights of the edges crossing the cut.</p>

<p>A <strong>bond</strong> is a cut-set that does not have any other cut-set as a proper subset.</p>
<h2 id="minimum-cut">Minimum cut</h2>

<p> </p>

<p>A cut is <em>minimum</em> if the size or weight of the cut is not larger than the size of any other cut. The illustration on the right shows a minimum cut: the size of this cut is 2, and there is no cut of size 1 because the graph is <a href="Bridge_(graph_theory)" title="wikilink">bridgeless</a>.</p>

<p>The <a href="max-flow_min-cut_theorem" title="wikilink">max-flow min-cut theorem</a> proves that the maximum <a href="flow_network" title="wikilink">network flow</a> and the sum of the cut-edge weights of any minimum cut that separates the source and the sink are equal. There are <a href="polynomial_time" title="wikilink">polynomial-time</a> methods to solve the min-cut problem, notably the <a href="Edmonds-Karp_algorithm" title="wikilink">Edmonds-Karp algorithm</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="maximum-cut">Maximum cut</h2>

<p> </p>

<p>A cut is <em>maximum</em> if the size of the cut is not smaller than the size of any other cut. The illustration on the right shows a maximum cut: the size of the cut is equal to 5, and there is no cut of size 6, or |<em>E</em>| (the number of edges), because the graph is not <a href="Bipartite_graph" title="wikilink">bipartite</a> (there is an <a href="Cycle_graph#Terminology" title="wikilink">odd cycle</a>).</p>

<p>In general, finding a maximum cut is computationally hard.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> The max-cut problem is one of <a href="Karp's_21_NP-complete_problems" title="wikilink">Karp's 21 NP-complete problems</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> The max-cut problem is also <a href="Constant-factor_approximation_algorithm" title="wikilink">APX-hard</a>, meaning that there is no polynomial-time approximation scheme for it unless P = NP.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> However, it can be approximated to within a constant <a href="approximation_ratio" title="wikilink">approximation ratio</a> using <a href="semidefinite_programming" title="wikilink">semidefinite programming</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>Note that min-cut and max-cut are <em>not</em> <a href="Linear_programming#Duality" title="wikilink">dual</a> problems in the <a href="linear_programming" title="wikilink">linear programming</a> sense, even though one gets from one problem to other by changing min to max in the <a href="objective_function" title="wikilink">objective function</a>. The max-flow problem is the dual of the min-cut problem.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<h2 id="sparsest-cut">Sparsest cut</h2>

<p>The <strong>sparsest cut problem</strong> is to bipartition the vertices so as to minimize the ratio of the number of edges across the cut divided by the number of vertices in the smaller half of the partition. This objective function favors solutions that are both sparse (few edges crossing the cut) and balanced (close to a bisection). The problem is known to be NP-Hard, and the best known algorithm is an 

<math display="inline" id="Cut_(graph_theory):5">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msqrt>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </msqrt>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <root></root>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\sqrt{\log n})
  </annotation>
 </semantics>
</math>

 approximation due to .<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="cut-space">Cut space</h2>

<p>The family of all cut sets of an undirected graph is known as the <strong>cut space</strong> of the graph. It forms a <a href="vector_space" title="wikilink">vector space</a> over the two-element <a href="finite_field" title="wikilink">finite field</a> of arithmetic modulo two, with the <a href="symmetric_difference" title="wikilink">symmetric difference</a> of two cut sets as the vector addition operation, and is the <a href="orthogonal_complement" title="wikilink">orthogonal complement</a> of the <a href="cycle_space" title="wikilink">cycle space</a>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> If the edges of the graph are given positive weights, the minimum weight <a href="Basis_(linear_algebra)" title="wikilink">basis</a> of the cut space can be described by a <a href="tree_(graph_theory)" title="wikilink">tree</a> on the same vertex set as the graph, called the <a href="Gomory–Hu_tree" title="wikilink">Gomory–Hu tree</a>.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> Each edge of this tree is associated with a bond in the original graph, and the minimum cut between two nodes <em>s</em> and <em>t</em> is the minimum weight bond among the ones associated with the path from <em>s</em> to <em>t</em> in the tree.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Connectivity_(graph_theory)" title="wikilink">Connectivity (graph theory)</a></li>
<li><a href="Graph_cuts_in_computer_vision" title="wikilink">Graph cuts in computer vision</a></li>
<li><a href="Vertex_separator" title="wikilink">Vertex separator</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Graph_connectivity" title="wikilink">Category:Graph connectivity</a> <a href="Category:Combinatorial_optimization" title="wikilink">Category:Combinatorial optimization</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">.<a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3">.<a href="#fnref3">↩</a></li>
<li id="fn4">.<a href="#fnref4">↩</a></li>
<li id="fn5">.<a href="#fnref5">↩</a></li>
<li id="fn6">.<a href="#fnref6">↩</a></li>
<li id="fn7">.<a href="#fnref7">↩</a></li>
<li id="fn8">.<a href="#fnref8">↩</a></li>
<li id="fn9">.<a href="#fnref9">↩</a></li>
<li id="fn10">.<a href="#fnref10">↩</a></li>
</ol>
</section>
</body>
</html>
