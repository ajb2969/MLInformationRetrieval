<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1718">Decision tree learning</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Decision tree learning</h1>
<hr/>

<p><strong>Decision tree learning</strong> uses a <a href="decision_tree" title="wikilink">decision tree</a> as a <a href="Predictive_modelling" title="wikilink">predictive model</a> which maps observations about an item to conclusions about the item's target value. It is one of the predictive modelling approaches used in <a class="uri" href="statistics" title="wikilink">statistics</a>, <a href="data_mining" title="wikilink">data mining</a> and <a href="machine_learning" title="wikilink">machine learning</a>. Tree models where the target variable can take a finite set of values are called <strong>classification trees</strong>. In these tree structures, <a href="leaf_node" title="wikilink">leaves</a> represent class labels and branches represent <a href="Logical_conjunction" title="wikilink">conjunctions</a> of features that lead to those class labels. Decision trees where the target variable can take continuous values (typically <a href="real_numbers" title="wikilink">real numbers</a>) are called <strong>regression trees</strong>.</p>

<p>In decision analysis, a decision tree can be used to visually and explicitly represent decisions and <a href="decision_making" title="wikilink">decision making</a>. In <a href="data_mining" title="wikilink">data mining</a>, a decision tree describes data but not decisions; rather the resulting classification tree can be an input for <a href="decision_making" title="wikilink">decision making</a>. This page deals with decision trees in <a href="data_mining" title="wikilink">data mining</a>.</p>
<h2 id="general">General</h2>

<p> Decision tree learning is a method commonly used in data mining.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The goal is to create a model that predicts the value of a target variable based on several input variables. An example is shown on the right. Each <a href="interior_node" title="wikilink">interior node</a> corresponds to one of the input variables; there are edges to children for each of the possible values of that input variable. Each leaf represents a value of the target variable given the values of the input variables represented by the path from the root to the leaf.</p>

<p>A decision tree is a simple representation for classifying examples. Decision tree learning is one of the most successful techniques for supervised classification learning. For this section, assume that all of the features have finite discrete domains, and there is a single target feature called the classification. Each element of the domain of the classification is called a class. A decision tree or a classification tree is a tree in which each internal (non-leaf) node is labeled with an input feature. The arcs coming from a node labeled with a feature are labeled with each of the possible values of the feature. Each leaf of the tree is labeled with a class or a probability distribution over the classes.</p>

<p>A tree can be "learned" by splitting the source <a href="Set_(mathematics)" title="wikilink">set</a> into subsets based on an attribute value test. This process is repeated on each derived subset in a recursive manner called <a href="recursive_partitioning" title="wikilink">recursive partitioning</a>. The <a class="uri" href="recursion" title="wikilink">recursion</a> is completed when the subset at a node has all the same value of the target variable, or when splitting no longer adds value to the predictions. This process of <em>top-down induction of decision trees</em> (TDIDT) <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> is an example of a <a href="greedy_algorithm" title="wikilink">greedy algorithm</a>, and it is by far the most common strategy for learning decision trees from data.</p>

<p>In <a href="data_mining" title="wikilink">data mining</a>, decision trees can be described also as the combination of mathematical and computational techniques to aid the description, categorisation and generalisation of a given set of data.</p>

<p>Data comes in records of the form:</p>

<p>

<math display="block" id="Decision_tree_learning:0">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mtext>ùê±</mtext>
    <mo>,</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>3</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>k</mi>
    </msub>
    <mo>,</mo>
    <mi>Y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <mtext>x</mtext>
     <ci>Y</ci>
    </interval>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">3</cn>
     </apply>
     <ci>normal-‚Ä¶</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
     <ci>Y</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\textbf{x},Y)=(x_{1},x_{2},x_{3},...,x_{k},Y)
  </annotation>
 </semantics>
</math>

</p>

<p>The dependent variable, Y, is the target variable that we are trying to understand, classify or generalize. The vector <strong>x</strong> is composed of the input variables, x<sub>1</sub>, x<sub>2</sub>, x<sub>3</sub> etc., that are used for that task.</p>
<h2 id="types">Types</h2>

<p>Decision trees used in <a href="data_mining" title="wikilink">data mining</a> are of two main types:</p>
<ul>
<li><strong><a href="Classification_tree" title="wikilink">Classification tree</a></strong> analysis is when the predicted outcome is the class to which the data belongs.</li>
<li><strong>Regression tree</strong> analysis is when the predicted outcome can be considered a real number (e.g. the price of a house, or a patient‚Äôs length of stay in a hospital).</li>
</ul>

<p>The term <strong>Classification And Regression Tree (CART)</strong> analysis is an <a href="umbrella_term" title="wikilink">umbrella term</a> used to refer to both of the above procedures, first introduced by <a href="Leo_Breiman" title="wikilink">Breiman</a> et al.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Trees used for regression and trees used for classification have some similarities - but also some differences, such as the procedure used to determine where to split.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Some techniques, often called <em>ensemble</em> methods, construct more than one decision tree:</p>
<ul>
<li><strong><a href="Bootstrap_aggregating" title="wikilink">Bagging</a></strong> decision trees, an early ensemble method, builds multiple decision trees by repeatedly resampling training data with replacement, and voting the trees for a consensus prediction.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
<li>A <strong><a href="Random_forest" title="wikilink">Random Forest</a></strong> classifier uses a number of decision trees, in order to improve the classification rate.</li>
<li><strong><a href="Gradient_boosted_trees" title="wikilink">Boosted Trees</a></strong> can be used for regression-type and classification-type problems.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></li>
<li><strong><a href="Rotation_forest" title="wikilink">Rotation forest</a></strong> - in which every decision tree is trained by first applying <a href="principal_component_analysis" title="wikilink">principal component analysis</a> (PCA) on a random subset of the input features.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></li>
</ul>

<p><strong>Decision tree learning</strong> is the construction of a decision tree from class-labeled training tuples. A decision tree is a flow-chart-like structure, where each internal (non-leaf) node denotes a test on an attribute, each branch represents the outcome of a test, and each leaf (or terminal) node holds a class label. The topmost node in a tree is the root node.</p>

<p>There are many specific decision-tree algorithms. Notable ones include:</p>
<ul>
<li><a href="ID3_algorithm" title="wikilink">ID3</a> (Iterative Dichotomiser 3)</li>
<li><a href="C4.5_algorithm" title="wikilink">C4.5</a> (successor of ID3)</li>
<li><a href="Predictive_analytics#Classification_and_regression_trees" title="wikilink">CART</a> (Classification And Regression Tree)</li>
<li><a class="uri" href="CHAID" title="wikilink">CHAID</a> (CHi-squared Automatic Interaction Detector). Performs multi-level splits when computing classification trees.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></li>
<li><a href="Multivariate_adaptive_regression_splines" title="wikilink">MARS</a>: extends decision trees to handle numerical data better.</li>
<li><a href="Conditional_Inference_Trees" title="wikilink">Conditional Inference Trees</a>. Statistics-based approach that uses non-parametric tests as splitting criteria, corrected for multiple testing to avoid overfitting. This approach results in unbiased predictor selection and does not require pruning.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a><a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></li>
</ul>

<p>ID3 and CART were invented independently at around the same time (between 1970 and 1980), yet follow a similar approach for learning decision tree from training tuples.</p>
<h2 id="metrics">Metrics</h2>

<p>Algorithms for constructing decision trees usually work top-down, by choosing a variable at each step that best splits the set of items.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> Different algorithms use different metrics for measuring "best". These generally measure the homogeneity of the target variable within the subsets. Some examples are given below. These metrics are applied to each candidate subset, and the resulting values are combined (e.g., averaged) to provide a measure of the quality of the split.</p>
<h3 id="gini-impurity">Gini impurity</h3>

<p>Used by the CART (classification and regression tree) algorithm, Gini impurity is a measure of how often a randomly chosen element from the set would be incorrectly labeled if it were randomly labeled according to the distribution of labels in the subset. Gini impurity can be computed by summing the probability of each item being chosen times the probability of a mistake in categorizing that item. It reaches its minimum (zero) when all cases in the node fall into a single target category.</p>

<p>To compute Gini impurity for a set of items, suppose 

<math display="inline" id="Decision_tree_learning:1">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>‚àà</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <mi>m</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>i</ci>
    <set>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <ci>normal-‚Ä¶</ci>
     <ci>m</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\in\{1,2,...,m\}
  </annotation>
 </semantics>
</math>

, and let 

<math display="inline" id="Decision_tree_learning:2">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{i}
  </annotation>
 </semantics>
</math>

 be the fraction of items labeled with value 

<math display="inline" id="Decision_tree_learning:3">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 in the set.</p>

<p>

<math display="inline" id="Decision_tree_learning:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>I</mi>
     <mi>G</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">‚àë</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>m</mi>
    </msubsup>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <msub>
        <mi>f</mi>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">‚àë</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>m</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>f</mi>
       <mi>i</mi>
      </msub>
      <mo>-</mo>
      <mmultiscripts>
       <mi>f</mi>
       <mi>i</mi>
       <none></none>
       <none></none>
       <mn>2</mn>
      </mmultiscripts>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">‚àë</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>m</mi>
     </msubsup>
     <msub>
      <mi>f</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">‚àë</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>m</mi>
     </msubsup>
     <mmultiscripts>
      <mi>f</mi>
      <mi>i</mi>
      <none></none>
      <none></none>
      <mn>2</mn>
     </mmultiscripts>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">‚àë</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>m</mi>
     </msubsup>
     <mmultiscripts>
      <mi>f</mi>
      <mi>i</mi>
      <none></none>
      <none></none>
      <mn>2</mn>
     </mmultiscripts>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">‚àë</mo>
     <mrow>
      <mi>i</mi>
      <mo>‚â†</mo>
      <mi>k</mi>
     </mrow>
    </msub>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>f</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>I</ci>
       <ci>G</ci>
      </apply>
      <ci>f</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>m</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>m</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>i</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>m</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>m</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>i</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <sum></sum>
         <ci>m</ci>
        </apply>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>i</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <neq></neq>
        <ci>i</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{G}(f)=\sum_{i=1}^{m}f_{i}(1-f_{i})=\sum_{i=1}^{m}(f_{i}-{f_{i}}^{2})=\sum_{%
i=1}^{m}f_{i}-\sum_{i=1}^{m}{f_{i}}^{2}=1-\sum^{m}_{i=1}{f_{i}}^{2}=\sum_{i%
\neq k}f_{i}f_{k}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="information-gain">Information gain</h3>

<p>Used by the <a href="ID3_algorithm" title="wikilink">ID3</a>, <a href="C4.5_algorithm" title="wikilink">C4.5</a> and C5.0 tree-generation algorithms. <a href="Information_gain_in_decision_trees" title="wikilink">Information gain</a> is based on the concept of <a href="information_entropy" title="wikilink">entropy</a> from <a href="information_theory" title="wikilink">information theory</a>.</p>

<p>

<math display="inline" id="Decision_tree_learning:5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>I</mi>
     <mi>E</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">‚àë</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>m</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>f</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <msub>
        <mi>log</mi>
        <mn>2</mn>
       </msub>
       <msub>
        <mi>f</mi>
        <mi>i</mi>
       </msub>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>E</ci>
     </apply>
     <ci>f</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <sum></sum>
        <ci>m</ci>
       </apply>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <log></log>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{E}(f)=-\sum^{m}_{i=1}f_{i}\log_{2}f_{i}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="variance-reduction">Variance reduction</h3>

<p>Introduced in CART,<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> variance reduction is often employed in cases where the target variable is continuous (regression tree), meaning that use of many other metrics would first require discretization before being applied. The variance reduction of a node 

<math display="inline" id="Decision_tree_learning:6">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 is defined as the total reduction of the variance of the target variable 

<math display="inline" id="Decision_tree_learning:7">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 due to the split at this node:</p>

<p>

<math display="inline" id="Decision_tree_learning:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>I</mi>
     <mi>V</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <msup>
       <mrow>
        <mo stretchy="false">|</mo>
        <mi>S</mi>
        <mo stretchy="false">|</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mfrac>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">‚àë</mo>
       <mrow>
        <mi>i</mi>
        <mo>‚àà</mo>
        <mi>S</mi>
       </mrow>
      </msub>
      <mrow>
       <msub>
        <mo largeop="true" symmetric="true">‚àë</mo>
        <mrow>
         <mi>j</mi>
         <mo>‚àà</mo>
         <mi>S</mi>
        </mrow>
       </msub>
       <mrow>
        <mfrac>
         <mn>1</mn>
         <mn>2</mn>
        </mfrac>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <msub>
            <mi>x</mi>
            <mi>i</mi>
           </msub>
           <mo>-</mo>
           <msub>
            <mi>x</mi>
            <mi>j</mi>
           </msub>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mn>2</mn>
        </msup>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <msup>
         <mrow>
          <mo stretchy="false">|</mo>
          <msub>
           <mi>S</mi>
           <mi>t</mi>
          </msub>
          <mo stretchy="false">|</mo>
         </mrow>
         <mn>2</mn>
        </msup>
       </mfrac>
       <mrow>
        <msub>
         <mo largeop="true" symmetric="true">‚àë</mo>
         <mrow>
          <mi>i</mi>
          <mo>‚àà</mo>
          <msub>
           <mi>S</mi>
           <mi>t</mi>
          </msub>
         </mrow>
        </msub>
        <mrow>
         <msub>
          <mo largeop="true" symmetric="true">‚àë</mo>
          <mrow>
           <mi>j</mi>
           <mo>‚àà</mo>
           <msub>
            <mi>S</mi>
            <mi>t</mi>
           </msub>
          </mrow>
         </msub>
         <mrow>
          <mfrac>
           <mn>1</mn>
           <mn>2</mn>
          </mfrac>
          <msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <msub>
              <mi>x</mi>
              <mi>i</mi>
             </msub>
             <mo>-</mo>
             <msub>
              <mi>x</mi>
              <mi>j</mi>
             </msub>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
           <mn>2</mn>
          </msup>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mfrac>
        <mn>1</mn>
        <msup>
         <mrow>
          <mo stretchy="false">|</mo>
          <msub>
           <mi>S</mi>
           <mi>f</mi>
          </msub>
          <mo stretchy="false">|</mo>
         </mrow>
         <mn>2</mn>
        </msup>
       </mfrac>
       <mrow>
        <msub>
         <mo largeop="true" symmetric="true">‚àë</mo>
         <mrow>
          <mi>i</mi>
          <mo>‚àà</mo>
          <msub>
           <mi>S</mi>
           <mi>f</mi>
          </msub>
         </mrow>
        </msub>
        <mrow>
         <msub>
          <mo largeop="true" symmetric="true">‚àë</mo>
          <mrow>
           <mi>j</mi>
           <mo>‚àà</mo>
           <msub>
            <mi>S</mi>
            <mi>f</mi>
           </msub>
          </mrow>
         </msub>
         <mrow>
          <mfrac>
           <mn>1</mn>
           <mn>2</mn>
          </mfrac>
          <msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <msub>
              <mi>x</mi>
              <mi>i</mi>
             </msub>
             <mo>-</mo>
             <msub>
              <mi>x</mi>
              <mi>j</mi>
             </msub>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
           <mn>2</mn>
          </msup>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <ci>V</ci>
     </apply>
     <ci>N</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <abs></abs>
         <ci>S</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <in></in>
         <ci>i</ci>
         <ci>S</ci>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <in></in>
          <ci>j</ci>
          <ci>S</ci>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <divide></divide>
          <cn type="integer">1</cn>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <minus></minus>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>i</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>x</ci>
            <ci>j</ci>
           </apply>
          </apply>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <abs></abs>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>S</ci>
           <ci>t</ci>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <in></in>
          <ci>i</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>S</ci>
           <ci>t</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <in></in>
           <ci>j</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>S</ci>
            <ci>t</ci>
           </apply>
          </apply>
         </apply>
         <apply>
          <times></times>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <minus></minus>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <ci>i</ci>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <ci>j</ci>
            </apply>
           </apply>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <abs></abs>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>S</ci>
           <ci>f</ci>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <in></in>
          <ci>i</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>S</ci>
           <ci>f</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <in></in>
           <ci>j</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>S</ci>
            <ci>f</ci>
           </apply>
          </apply>
         </apply>
         <apply>
          <times></times>
          <apply>
           <divide></divide>
           <cn type="integer">1</cn>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <minus></minus>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <ci>i</ci>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>x</ci>
             <ci>j</ci>
            </apply>
           </apply>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I_{V}(N)=\frac{1}{|S|^{2}}\sum_{i\in S}\sum_{j\in S}\frac{1}{2}(x_{i}-x_{j})^{%
2}-\left(\frac{1}{|S_{t}|^{2}}\sum_{i\in S_{t}}\sum_{j\in S_{t}}\frac{1}{2}(x_%
{i}-x_{j})^{2}+\frac{1}{|S_{f}|^{2}}\sum_{i\in S_{f}}\sum_{j\in S_{f}}\frac{1}%
{2}(x_{i}-x_{j})^{2}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Decision_tree_learning:9">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Decision_tree_learning:10">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{t}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Decision_tree_learning:11">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{f}
  </annotation>
 </semantics>
</math>

 are the set of presplit sample indices, set of sample indices for which the split test is true, and set of sample indices for which the split test is false, respectively. Each of the above summands are indeed <a class="uri" href="variance" title="wikilink">variance</a> estimates, though, written in a form without directly referring to the mean.</p>
<h2 id="decision-tree-advantages">Decision tree advantages</h2>

<p>Amongst other data mining methods, decision trees have various advantages:</p>
<ul>
<li><strong>Simple to understand and interpret.</strong> People are able to understand decision tree models after a brief explanation.</li>
<li><strong>Requires little data preparation.</strong> Other techniques often require data normalisation, <a href="dummy_variable_(statistics)" title="wikilink">dummy variables</a> need to be created and blank values to be removed.</li>
<li><strong>Able to handle both numerical and <a href="Categorical_variable" title="wikilink">categorical</a> data.</strong> Other techniques are usually specialised in analysing datasets that have only one type of variable. (For example, relation rules can be used only with nominal variables while neural networks can be used only with numerical variables.)</li>
<li><strong>Uses a <a href="white_box_(software_engineering)" title="wikilink">white box</a> model.</strong> If a given situation is observable in a model the explanation for the condition is easily explained by boolean logic. (An example of a black box model is an <a href="artificial_neural_network" title="wikilink">artificial neural network</a> since the explanation for the results is difficult to understand.)</li>
<li><strong>Possible to validate a model using statistical tests.</strong> That makes it possible to account for the reliability of the model.</li>
<li><strong><a href="Robust_statistics" title="wikilink">Robust</a>.</strong> Performs well even if its assumptions are somewhat violated by the true model from which the data were generated.</li>
<li><strong>Performs well with large datasets.</strong> Large amounts of data can be analysed using standard computing resources in reasonable time.</li>
</ul>
<h2 id="limitations">Limitations</h2>
<ul>
<li>The problem of learning an optimal decision tree is known to be <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> under several aspects of optimality and even for simple concepts.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> Consequently, practical decision-tree learning algorithms are based on heuristics such as the <a href="greedy_algorithm" title="wikilink">greedy algorithm</a> where locally-optimal decisions are made at each node. Such algorithms cannot guarantee to return the globally-optimal decision tree. To reduce the greedy effect of local-optimality some methods such as the dual information distance (DID) tree were proposed.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> <a href="http://www.eng.tau.ac.il/~bengal/DID.pdf">1</a></li>
</ul>
<ul>
<li>Decision-tree learners can create over-complex trees that do not generalise well from the training data. (This is known as <a class="uri" href="overfitting" title="wikilink">overfitting</a>.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a>) Mechanisms such as <a href="Pruning_(decision_trees)" title="wikilink">pruning</a> are necessary to avoid this problem (with the exception of some algorithms such as the Conditional Inference approach, that does not require pruning <a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a><a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a>).</li>
<li>There are concepts that are hard to learn because decision trees do not express them easily, such as <a class="uri" href="XOR" title="wikilink">XOR</a>, <a href="parity_bit#Parity" title="wikilink">parity</a> or <a class="uri" href="multiplexer" title="wikilink">multiplexer</a> problems. In such cases, the decision tree becomes prohibitively large. Approaches to solve the problem involve either changing the representation of the problem domain (known as propositionalisation)<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> or using learning algorithms based on more expressive representations (such as <a href="statistical_relational_learning" title="wikilink">statistical relational learning</a> or <a href="inductive_logic_programming" title="wikilink">inductive logic programming</a>).</li>
<li>For data including categorical variables with different numbers of levels, <a href="information_gain_in_decision_trees" title="wikilink">information gain in decision trees</a> is biased in favor of those attributes with more levels.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> However, the issue of biased predictor selection is avoided by the Conditional Inference approach.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></li>
</ul>
<h2 id="extensions">Extensions</h2>
<h3 id="decision-graphs">Decision graphs</h3>

<p>In a decision tree, all paths from the root node to the leaf node proceed by way of conjunction, or <em>AND</em>. In a decision graph, it is possible to use disjunctions (ORs) to join two more paths together using <a href="Minimum_message_length" title="wikilink">Minimum message length</a> (MML).<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> Decision graphs have been further extended to allow for previously unstated new attributes to be learnt dynamically and used at different places within the graph.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> The more general coding scheme results in better predictive accuracy and log-loss probabilistic scoring. In general, decision graphs infer models with fewer leaves than decision trees.</p>
<h3 id="alternative-search-methods">Alternative search methods</h3>

<p>Evolutionary algorithms have been used to avoid local optimal decisions and search the decision tree space with little <em>a priori</em> bias.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a><a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>

<p>It is also possible for a tree to be sampled using MCMC.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>

<p>The tree can be searched for in a bottom-up fashion.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Decision-tree_pruning" title="wikilink">Decision tree pruning</a></li>
<li><a href="Binary_decision_diagram" title="wikilink">Binary decision diagram</a></li>
<li><a class="uri" href="CHAID" title="wikilink">CHAID</a></li>
<li><a href="Predictive_analytics#Classification_and_regression_trees" title="wikilink">CART</a></li>
<li><a href="ID3_algorithm" title="wikilink">ID3 algorithm</a></li>
<li><a href="C4.5_algorithm" title="wikilink">C4.5 algorithm</a></li>
<li><a href="Decision_stump" title="wikilink">Decision stump</a></li>
<li><a href="Incremental_decision_tree" title="wikilink">Incremental decision tree</a></li>
<li><a href="Alternating_decision_tree" title="wikilink">Alternating decision tree</a></li>
<li><a href="Structured_data_analysis_(statistics)" title="wikilink">Structured data analysis (statistics)</a></li>
<li><a href="Logistic_model_tree" title="wikilink">Logistic model tree</a></li>
</ul>
<h2 id="implementations">Implementations</h2>

<p>Many data mining software packages provide implementations of one or more decision tree algorithms. Several examples include Salford Systems CART (which licensed the proprietary code of the original CART authors<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a>), <a href="SPSS_Modeler" title="wikilink">IBM SPSS Modeler</a>, <a class="uri" href="RapidMiner" title="wikilink">RapidMiner</a>, <a href="SAS_(software)#Components" title="wikilink">SAS Enterprise Miner</a>, <a class="uri" href="Matlab" title="wikilink">Matlab</a>, <a href="R_(programming_language)" title="wikilink">R</a> (an open source software environment for statistical computing which includes several CART implementations such as rpart, party and randomForest packages), <a href="Weka_(machine_learning)" title="wikilink">Weka</a> (a free and open-source data mining suite, contains many decision tree algorithms), <a href="Orange_(software)" title="wikilink">Orange</a> (a free data mining software suite, which includes the tree module <a href="http://www.ailab.si/orange/doc/modules/orngTree.htm">orngTree</a>), <a class="uri" href="KNIME" title="wikilink">KNIME</a>, <a href="Microsoft_SQL_Server" title="wikilink">Microsoft SQL Server</a> <a href="http://technet.microsoft.com/en-us/library/cc645868.aspx">2</a>, and <a class="uri" href="scikit-learn" title="wikilink">scikit-learn</a> (a free and open-source machine learning library for the <a href="Python_(programming_language)" title="wikilink">Python</a> programming language).</p>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://onlamp.com/lpt/a/6464">Building Decision Trees in Python</a> From O'Reilly.</li>
<li><a href="http://www.oreillynet.com/mac/blog/2007/06/an_addendum_to_building_decisi.html">An Addendum to "Building Decision Trees in Python"</a> From O'Reilly.</li>
<li><a href="http://people.revoledu.com/kardi/tutorial/DecisionTree/index.html">Decision Trees Tutorial</a> using Microsoft Excel.</li>
<li><a href="http://aitopics.org/topic/decision-tree-learning">Decision Trees page at aitopics.org</a>, a page with commented links.</li>
<li><a href="http://ai4r.org/index.html">Decision tree implementation in Ruby (AI4R)</a></li>
<li><a href="http://www.cs.uwaterloo.ca/~mgrzes/code/evoldectrees/">Evolutionary Learning of Decision Trees in C++</a></li>
<li><a href="https://github.com/kobaj/JavaDecisionTree">Java implementation of Decision Trees based on Information Gain</a></li>
<li><a href="http://christianherta.de/lehre/dataScience/machineLearning/decision-trees.html">A very explicit explanation of information gain as splitting criterion</a></li>
</ul>

<p>"</p>

<p><a href="Category:Decision_trees" title="wikilink">Category:Decision trees</a> <a href="Category:Classification_algorithms" title="wikilink">Category:Classification algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">‚Ü©</a></li>
<li id="fn2">Quinlan, J. R., (1986). Induction of Decision Trees. Machine Learning 1: 81-106, Kluwer Academic Publishers<a href="#fnref2">‚Ü©</a></li>
<li id="fn3"><a href="#fnref3">‚Ü©</a></li>
<li id="fn4"></li>
<li id="fn5">Breiman, L. (1996). Bagging Predictors. "Machine Learning, 24": pp. 123-140.<a href="#fnref5">‚Ü©</a></li>
<li id="fn6">Friedman, J. H. (1999). <em>Stochastic gradient boosting.</em> Stanford University.<a href="#fnref6">‚Ü©</a></li>
<li id="fn7">Hastie, T., Tibshirani, R., Friedman, J. H. (2001). <em>The elements of statistical learning : Data mining, inference, and prediction.</em> New York: Springer Verlag.<a href="#fnref7">‚Ü©</a></li>
<li id="fn8">Rodriguez, J.J. and Kuncheva, L.I. and Alonso, C.J. (2006), Rotation forest: A new classifier ensemble method, IEEE Transactions on Pattern Analysis and Machine Intelligence, 28(10):1619-1630.<a href="#fnref8">‚Ü©</a></li>
<li id="fn9"><a href="#fnref9">‚Ü©</a></li>
<li id="fn10"><a href="#fnref10">‚Ü©</a></li>
<li id="fn11"><a href="#fnref11">‚Ü©</a></li>
<li id="fn12"><a href="#fnref12">‚Ü©</a></li>
<li id="fn13"></li>
<li id="fn14"><a href="#fnref14">‚Ü©</a></li>
<li id="fn15">Murthy S. (1998). Automatic construction of decision trees from data: A multidisciplinary survey. <em>Data Mining and Knowledge Discovery</em><a href="#fnref15">‚Ü©</a></li>
<li id="fn16"><a href="#fnref16">‚Ü©</a></li>
<li id="fn17"><a href="#fnref17">‚Ü©</a></li>
<li id="fn18"></li>
<li id="fn19"></li>
<li id="fn20"><a href="#fnref20">‚Ü©</a></li>
<li id="fn21"><a href="#fnref21">‚Ü©</a></li>
<li id="fn22"></li>
<li id="fn23"><a class="uri" href="http://citeseer.ist.psu.edu/oliver93decision.html">http://citeseer.ist.psu.edu/oliver93decision.html</a><a href="#fnref23">‚Ü©</a></li>
<li id="fn24"><a href="http://www.csse.monash.edu.au/~dld/Publications/2003/Tan+Dowe2003_MMLDecisionGraphs.pdf">Tan &amp; Dowe (2003)</a><a href="#fnref24">‚Ü©</a></li>
<li id="fn25">Papagelis A., Kalles D.(2001). Breeding Decision Trees Using Evolutionary Techniques, Proceedings of the Eighteenth International Conference on Machine Learning, p.393-400, June 28-July 01, 2001<a href="#fnref25">‚Ü©</a></li>
<li id="fn26">Barros, Rodrigo C., Basgalupp, M. P., Carvalho, A. C. P. L. F., Freitas, Alex A. (2011). <a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=5928432">A Survey of Evolutionary Algorithms for Decision-Tree Induction</a>. IEEE Transactions on Systems, Man and Cybernetics, Part C: Applications and Reviews, vol. 42, n. 3, p. 291-312, May 2012.<a href="#fnref26">‚Ü©</a></li>
<li id="fn27">Chipman, Hugh A., Edward I. George, and Robert E. McCulloch. "Bayesian CART model search." Journal of the American Statistical Association 93.443 (1998): 935-948.<a href="#fnref27">‚Ü©</a></li>
<li id="fn28">Barros R. C., Cerri R., Jaskowiak P. A., Carvalho, A. C. P. L. F., <a href="http://dx.doi.org/10.1109/ISDA.2011.6121697">A bottom-up oblique decision tree induction algorithm</a>. Proceedings of the 11th International Conference on Intelligent Systems Design and Applications (ISDA 2011).<a href="#fnref28">‚Ü©</a></li>
<li id="fn29"></li>
</ol>
</section>
</body>
</html>
