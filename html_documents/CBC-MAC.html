<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1355">CBC-MAC</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>CBC-MAC</h1>
<hr/>

<p>In <a class="uri" href="cryptography" title="wikilink">cryptography</a>, a <strong>cipher block chaining message authentication code</strong> (<strong>CBC-MAC</strong>) is a technique for constructing a <a href="message_authentication_code" title="wikilink">message authentication code</a> from a <a href="block_cipher" title="wikilink">block cipher</a>. The message is encrypted with some block cipher algorithm in <a href="block_cipher_modes_of_operation" title="wikilink">CBC mode</a> to create a chain of blocks such that each block depends on the proper encryption of the previous block. This interdependence ensures that a change to any of the plaintext bits will cause the final encrypted block to change in a way that cannot be predicted or counteracted without knowing the key to the block cipher.</p>

<p>To calculate the CBC-MAC of message 

<math display="inline" id="CBC-MAC:0">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 one encrypts 

<math display="inline" id="CBC-MAC:1">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 in CBC mode with zero <a href="initialization_vector" title="wikilink">initialization vector</a>. The following figure sketches the computation of the CBC-MAC of a message comprising blocks 

<math display="inline" id="CBC-MAC:2">
 <semantics>
  <mrow>
   <msub>
    <mi>m</mi>
    <mn>1</mn>
   </msub>
   <mo>∥</mo>
   <msub>
    <mi>m</mi>
    <mn>2</mn>
   </msub>
   <mo>∥</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>∥</mo>
   <msub>
    <mi>m</mi>
    <mi>x</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">1</cn>
    </apply>
    <csymbol cd="latexml">parallel-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <cn type="integer">2</cn>
    </apply>
    <csymbol cd="latexml">parallel-to</csymbol>
    <ci>normal-⋯</ci>
    <csymbol cd="latexml">parallel-to</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>m</ci>
     <ci>x</ci>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{1}\|m_{2}\|\cdots\|m_{x}
  </annotation>
 </semantics>
</math>

 using a secret key 

<math display="inline" id="CBC-MAC:3">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 and a block cipher 

<math display="inline" id="CBC-MAC:4">
 <semantics>
  <mi>E</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>E</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E
  </annotation>
 </semantics>
</math>

:</p>
<figure><b>(Figure)</b>
<figcaption>CBC-MAC structure (en).svg</figcaption>
</figure>
<h2 id="security-with-fixed-and-variable-length-messages">Security with fixed and variable-length messages</h2>

<p>If the block cipher used is secure (meaning that it is a <a href="pseudorandom_permutation" title="wikilink">pseudorandom permutation</a>), then CBC-MAC is secure for fixed-length messages.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> However, by itself, it is not secure for variable-length messages. Thus, any single key must only be used for messages of a fixed and known length. This is because an attacker who knows the correct message-tag (i.e. CBC-MAC) pairs for two messages 

<math display="inline" id="CBC-MAC:5">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>m</mi>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="unknown">m</csymbol>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (m,
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="CBC-MAC:6">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="CBC-MAC:7">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msup>
    <mi>m</mi>
    <mo>′</mo>
   </msup>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>m</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (m^{\prime},
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="CBC-MAC:8">
 <semantics>
  <mrow>
   <msup>
    <mi>t</mi>
    <mo>′</mo>
   </msup>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>t</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{\prime})
  </annotation>
 </semantics>
</math>

 can generate a third message 

<math display="inline" id="CBC-MAC:9">
 <semantics>
  <msup>
   <mi>m</mi>
   <mi>′′</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>m</ci>
    <ci>′′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m^{\prime\prime}
  </annotation>
 </semantics>
</math>

 whose CBC-MAC will also be 

<math display="inline" id="CBC-MAC:10">
 <semantics>
  <msup>
   <mi>t</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>t</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{\prime}
  </annotation>
 </semantics>
</math>

. This is simply done by XORing the first block of 

<math display="inline" id="CBC-MAC:11">
 <semantics>
  <msup>
   <mi>m</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>m</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m^{\prime}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="CBC-MAC:12">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 and then concatenating 

<math display="inline" id="CBC-MAC:13">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 with this modified 

<math display="inline" id="CBC-MAC:14">
 <semantics>
  <msup>
   <mi>m</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>m</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m^{\prime}
  </annotation>
 </semantics>
</math>

; i.e., by making 

<math display="inline" id="CBC-MAC:15">
 <semantics>
  <mrow>
   <msup>
    <mi>m</mi>
    <mi>′′</mi>
   </msup>
   <mo>=</mo>
   <mi>m</mi>
   <mo>∥</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>m</mi>
      <mn>1</mn>
      <mo>′</mo>
     </msubsup>
     <mo>⊕</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∥</mo>
    <msubsup>
     <mi>m</mi>
     <mn>2</mn>
     <mo>′</mo>
    </msubsup>
    <mo>∥</mo>
    <mi mathvariant="normal">…</mi>
    <mo>∥</mo>
    <msubsup>
     <mi>m</mi>
     <mi>x</mi>
     <mo>′</mo>
    </msubsup>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>m</ci>
     <ci>′′</ci>
    </apply>
    <eq></eq>
    <csymbol cd="unknown">m</csymbol>
    <csymbol cd="latexml">parallel-to</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-′</ci>
      </apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <csymbol cd="unknown">t</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="latexml">parallel-to</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-′</ci>
     </apply>
     <csymbol cd="latexml">parallel-to</csymbol>
     <ci>normal-…</ci>
     <csymbol cd="latexml">parallel-to</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <ci>x</ci>
      </apply>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m^{\prime\prime}=m\|[(m_{1}^{\prime}\oplus t)\|m_{2}^{\prime}\|\dots\|m_{x}^{%
\prime}]
  </annotation>
 </semantics>
</math>

. When computing the MAC for the message 

<math display="inline" id="CBC-MAC:16">
 <semantics>
  <msup>
   <mi>m</mi>
   <mi>′′</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>m</ci>
    <ci>′′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m^{\prime\prime}
  </annotation>
 </semantics>
</math>

, it follows that we compute the MAC for 

<math display="inline" id="CBC-MAC:17">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 in the usual manner as 

<math display="inline" id="CBC-MAC:18">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, but when this value is chained forwards to the stage computing 

<math display="inline" id="CBC-MAC:19">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <msub>
     <mi>K</mi>
     <mtext>MAC</mtext>
    </msub>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msubsup>
      <mi>m</mi>
      <mn>1</mn>
      <mo>′</mo>
     </msubsup>
     <mo>⊕</mo>
     <mi>t</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <mtext>MAC</mtext>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-′</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{K_{\text{MAC}}}(m_{1}^{\prime}\oplus t)
  </annotation>
 </semantics>
</math>

 we will perform an exclusive OR operation with the value derived for the MAC of the first message. The presence of that tag in the new message means it will cancel, leaving no contribution to the MAC from the blocks of plain text in the first message 

<math display="inline" id="CBC-MAC:20">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>



<math display="block" id="CBC-MAC:21">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>E</mi>
     <msub>
      <mi>K</mi>
      <mtext>MAC</mtext>
     </msub>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msubsup>
       <mi>m</mi>
       <mn>1</mn>
       <mo>′</mo>
      </msubsup>
      <mo>⊕</mo>
      <mi>t</mi>
      <mo>⊕</mo>
      <mi>t</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>E</mi>
     <msub>
      <mi>K</mi>
      <mtext>MAC</mtext>
     </msub>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>m</mi>
      <mn>1</mn>
      <mo>′</mo>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <mtext>MAC</mtext>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-′</ci>
      </apply>
      <ci>t</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <mtext>MAC</mtext>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{K_{\text{MAC}}}(m_{1}^{\prime}\oplus t\oplus t)=E_{K_{\text{MAC}}}(m_{1}^{%
\prime})
  </annotation>
 </semantics>
</math>

 and thus the tag for 

<math display="inline" id="CBC-MAC:22">
 <semantics>
  <msup>
   <mi>m</mi>
   <mi>′′</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>m</ci>
    <ci>′′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m^{\prime\prime}
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="CBC-MAC:23">
 <semantics>
  <msup>
   <mi>t</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>t</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{\prime}
  </annotation>
 </semantics>
</math>

.</p>

<p>This problem cannot be solved by adding a message-size block to the end.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> There are three main ways of modifying CBC-MAC so that it is secure for variable length messages: 1) Input-length key separation; 2) Length-prepending; 3) Encrypt last block.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> In such a case, it may also be recommended to use a different mode of operation, for example, <a class="uri" href="CMAC" title="wikilink">CMAC</a> or <a class="uri" href="HMAC" title="wikilink">HMAC</a> to protect the integrity of variable-length messages.</p>
<h3 id="length-prepending">Length prepending</h3>

<p>One solution is to include the length of the message in the first block;<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> in fact CBC-MAC has been proven secure as long as no two messages that are prefixes of each other are ever used and prepending the length is a special case of this.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> This can be problematic if the message length may not be known when processing begins.</p>
<h3 id="encrypt-last-block">Encrypt-last-block</h3>

<p>Encrypt-last-block CBC-MAC (ECBC-MAC)<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> is defined as 

<math display="inline" id="CBC-MAC:24">
 <semantics>
  <mrow>
   <mrow>
    <mtext>CBC-MAC-ELB</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo>,</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>k</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>k</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>k</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mrow>
      <mtext>CBC-MAC</mtext>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>k</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <mi>m</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <mtext>CBC-MAC-ELB</mtext>
     <interval closure="open">
      <ci>m</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>k</ci>
        <cn type="integer">2</cn>
       </apply>
      </interval>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <times></times>
       <mtext>CBC-MAC</mtext>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>m</ci>
       </interval>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \text{CBC-MAC-ELB}(m,(k_{1},k_{2}))=E(k_{2},\text{CBC-MAC}(k_{1},m))
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> Compared to the other discussed methods of extending CBC-MAC to variable-length messages, encrypt-last-block has the advantage of not needing to know the length of the message until the end of the computation.</p>
<figure><b>(Figure)</b>
<figcaption>Computation of CBC-MAC Encrypt-last-block.</figcaption>
</figure>
<h2 id="attack-methods">Attack methods</h2>

<p>As with many cryptographic schemes, naïve use of ciphers and other protocols may lead to attacks being possible, reducing the effectiveness of the cryptographic protection (or even rendering it useless). We present attacks which are possible due to using the CBC-MAC incorrectly.</p>
<h3 id="using-the-same-key-for-encryption-and-authentication">Using the same key for encryption and authentication</h3>

<p>One common mistake is to reuse the same key 

<math display="inline" id="CBC-MAC:25">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 for CBC encryption and CBC-MAC. Although a reuse of a key for different purposes is a bad practice in general, in this particular case the mistake leads to a spectacular attack:</p>

<p>Suppose Alice has sent to Bob the cipher text blocks 

<math display="inline" id="CBC-MAC:26">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <msub>
      <mi>C</mi>
      <mn>1</mn>
     </msub>
    </mpadded>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mrow>
       <mo rspace="7.5pt" stretchy="false">|</mo>
       <mpadded width="+5pt">
        <msub>
         <mi>C</mi>
         <mn>2</mn>
        </msub>
       </mpadded>
       <mo stretchy="false">|</mo>
      </mrow>
      <mrow>
       <mo rspace="7.5pt" stretchy="false">|</mo>
       <mpadded width="+5pt">
        <mi mathvariant="normal">…</mi>
       </mpadded>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">|</mo>
    </mrow>
    <msub>
     <mi>C</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <apply>
        <abs></abs>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>C</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <abs></abs>
        <ci>normal-…</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=C_{1}\ ||\ C_{2}\ ||\ \dots\ ||\ C_{n}
  </annotation>
 </semantics>
</math>

. During the transmission process, Eve can tamper with any of the 

<math display="inline" id="CBC-MAC:27">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>C</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{1},\dots,C_{n-1}
  </annotation>
 </semantics>
</math>

 cipher-text blocks and adjust any of the bits therein as she chooses, provided that the final block, 

<math display="inline" id="CBC-MAC:28">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{n}
  </annotation>
 </semantics>
</math>

, remains the same. We assume, for the purposes of this example and without loss of generality, that the initialisation vector used for the encryption process is a vector of zeroes.</p>

<p>When Bob receives the message, he will first decrypt the message by reversing the encryption process which Alice applied, using the cipher text blocks 

<math display="inline" id="CBC-MAC:29">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <msub>
      <mi>C</mi>
      <mn>1</mn>
     </msub>
    </mpadded>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mrow>
       <mo rspace="7.5pt" stretchy="false">|</mo>
       <mpadded width="+5pt">
        <msub>
         <mi>C</mi>
         <mn>2</mn>
        </msub>
       </mpadded>
       <mo stretchy="false">|</mo>
      </mrow>
      <mrow>
       <mo rspace="7.5pt" stretchy="false">|</mo>
       <mpadded width="+5pt">
        <mi mathvariant="normal">⋯</mi>
       </mpadded>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">|</mo>
    </mrow>
    <msub>
     <mi>C</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <apply>
        <abs></abs>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>C</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <abs></abs>
        <ci>normal-⋯</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=C_{1}\ ||\ C_{2}\ ||\ \cdots\ ||\ C_{n}
  </annotation>
 </semantics>
</math>

. During the transmission process, Eve can tamper with any of the 

<math display="inline" id="CBC-MAC:30">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>C</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{1},\dots,C_{n-1}
  </annotation>
 </semantics>
</math>

 cipher text blocks and adjust any of the bits therein as she chooses, provided that the final block, 

<math display="inline" id="CBC-MAC:31">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{n}
  </annotation>
 </semantics>
</math>

, remains the same. Her tampered version, later delivered to Bob in replacement of Alice's original, is 

<math display="inline" id="CBC-MAC:32">
 <semantics>
  <mrow>
   <msup>
    <mi>C</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mpadded width="+5pt">
     <msubsup>
      <mi>C</mi>
      <mn>1</mn>
      <mo>′</mo>
     </msubsup>
    </mpadded>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mrow>
       <mo rspace="7.5pt" stretchy="false">|</mo>
       <mpadded width="+5pt">
        <mi mathvariant="normal">…</mi>
       </mpadded>
       <mo stretchy="false">|</mo>
      </mrow>
      <mrow>
       <mo rspace="7.5pt" stretchy="false">|</mo>
       <mpadded width="+5pt">
        <msubsup>
         <mi>C</mi>
         <mrow>
          <mi>n</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo>′</mo>
        </msubsup>
       </mpadded>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
     <mo rspace="7.5pt" stretchy="false">|</mo>
    </mrow>
    <msub>
     <mi>C</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>C</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <apply>
        <abs></abs>
        <ci>normal-…</ci>
       </apply>
       <apply>
        <abs></abs>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>C</ci>
          <apply>
           <minus></minus>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C^{\prime}=C_{1}^{\prime}\ ||\ \dots\ ||\ C_{n-1}^{\prime}\ ||\ C_{n}
  </annotation>
 </semantics>
</math>

.</p>

<p>Bob first decrypts the message received using the shared secret key 

<math display="inline" id="CBC-MAC:33">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 to obtain corresponding plain text. Note that all plain text produced will be different from that which Alice originally sent, because Eve has modified all but the last cipher text block. In particular, the final plain text, 

<math display="inline" id="CBC-MAC:34">
 <semantics>
  <msubsup>
   <mi>P</mi>
   <mi>n</mi>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>n</ci>
    </apply>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{n}^{\prime}
  </annotation>
 </semantics>
</math>

, differs from the original, 

<math display="inline" id="CBC-MAC:35">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{n}
  </annotation>
 </semantics>
</math>

, which Alice sent; although 

<math display="inline" id="CBC-MAC:36">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{n}
  </annotation>
 </semantics>
</math>

 is the same, 

<math display="inline" id="CBC-MAC:37">
 <semantics>
  <mrow>
   <msubsup>
    <mi>C</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo>′</mo>
   </msubsup>
   <mo>≠</mo>
   <msub>
    <mi>C</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{n-1}^{\prime}\not=C_{n-1}
  </annotation>
 </semantics>
</math>

, so a different plain text 

<math display="inline" id="CBC-MAC:38">
 <semantics>
  <msubsup>
   <mi>P</mi>
   <mi>n</mi>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>n</ci>
    </apply>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{n}^{\prime}
  </annotation>
 </semantics>
</math>

 is produced when chaining the previous cipher text block into the exclusive-OR after decryption of 

<math display="inline" id="CBC-MAC:39">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{n}
  </annotation>
 </semantics>
</math>



<math display="block" id="CBC-MAC:40">
 <semantics>
  <mrow>
   <msubsup>
    <mi>P</mi>
    <mi>n</mi>
    <mo>′</mo>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>C</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo>′</mo>
    </msubsup>
    <mo>⊕</mo>
    <mrow>
     <msubsup>
      <mi>E</mi>
      <mi>K</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>C</mi>
       <mi>n</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <apply>
        <minus></minus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <ci>K</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{n}^{\prime}=C_{n-1}^{\prime}\oplus E_{K}^{-1}(C_{n})
  </annotation>
 </semantics>
</math>

.</p>

<p>It follows that Bob will now compute the authentication tag using CBC-MAC over all the values of plain text which he decoded. The tag for the new message, 

<math display="inline" id="CBC-MAC:41">
 <semantics>
  <msup>
   <mi>t</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>t</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{\prime}
  </annotation>
 </semantics>
</math>

, is given by:</p>

<p>

<math display="inline" id="CBC-MAC:42">
 <semantics>
  <mrow>
   <msup>
    <mi>t</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>E</mi>
     <mi>K</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msubsup>
       <mi>P</mi>
       <mi>n</mi>
       <mo>′</mo>
      </msubsup>
      <mo>⊕</mo>
      <mrow>
       <msub>
        <mi>E</mi>
        <mi>K</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msubsup>
          <mi>P</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo>′</mo>
         </msubsup>
         <mo>⊕</mo>
         <mrow>
          <msub>
           <mi>E</mi>
           <mi>K</mi>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mi mathvariant="normal">…</mi>
            <mo>⊕</mo>
            <mrow>
             <msub>
              <mi>E</mi>
              <mi>K</mi>
             </msub>
             <mrow>
              <mo stretchy="false">(</mo>
              <msubsup>
               <mi>P</mi>
               <mn>1</mn>
               <mo>′</mo>
              </msubsup>
              <mo stretchy="false">)</mo>
             </mrow>
            </mrow>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>t</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>K</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <ci>n</ci>
       </apply>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <ci>K</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">direct-sum</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>P</ci>
          <apply>
           <minus></minus>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>normal-′</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>E</ci>
          <ci>K</ci>
         </apply>
         <apply>
          <csymbol cd="latexml">direct-sum</csymbol>
          <ci>normal-…</ci>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>E</ci>
            <ci>K</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>P</ci>
             <cn type="integer">1</cn>
            </apply>
            <ci>normal-′</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{\prime}=E_{K}(P_{n}^{\prime}\oplus E_{K}(P_{n-1}^{\prime}\oplus E_{K}(\dots%
\oplus E_{K}(P_{1}^{\prime}))))
  </annotation>
 </semantics>
</math>

</p>

<p>Notice that this expression is equal to</p>

<p>

<math display="inline" id="CBC-MAC:43">
 <semantics>
  <mrow>
   <msup>
    <mi>t</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>E</mi>
     <mi>K</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msubsup>
       <mi>P</mi>
       <mi>n</mi>
       <mo>′</mo>
      </msubsup>
      <mo>⊕</mo>
      <msubsup>
       <mi>C</mi>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo>′</mo>
      </msubsup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>t</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>K</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <ci>n</ci>
       </apply>
       <ci>normal-′</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{\prime}=E_{K}(P_{n}^{\prime}\oplus C_{n-1}^{\prime})
  </annotation>
 </semantics>
</math>

</p>

<p>which is exactly 

<math display="inline" id="CBC-MAC:44">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{n}
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="inline" id="CBC-MAC:45">
 <semantics>
  <mrow>
   <msup>
    <mi>t</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>E</mi>
     <mi>K</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msubsup>
       <mi>C</mi>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo>′</mo>
      </msubsup>
      <mo>⊕</mo>
      <mrow>
       <msubsup>
        <mi>E</mi>
        <mi>K</mi>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msubsup>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>C</mi>
         <mi>n</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>⊕</mo>
      <msubsup>
       <mi>C</mi>
       <mrow>
        <mi>n</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo>′</mo>
      </msubsup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>E</mi>
     <mi>K</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msubsup>
       <mi>E</mi>
       <mi>K</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>C</mi>
        <mi>n</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>C</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>K</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">direct-sum</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>C</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>E</ci>
          <ci>K</ci>
         </apply>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>C</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>C</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>K</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>E</ci>
         <ci>K</ci>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{\prime}=E_{K}(C_{n-1}^{\prime}\oplus E_{K}^{-1}(C_{n})\oplus C_{n-1}^{%
\prime})=E_{K}(E_{K}^{-1}(C_{n}))=C_{n}
  </annotation>
 </semantics>
</math>

</p>

<p>and it follows that 

<math display="inline" id="CBC-MAC:46">
 <semantics>
  <mrow>
   <msup>
    <mi>t</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <msub>
    <mi>C</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{\prime}=C_{n}=t
  </annotation>
 </semantics>
</math>

.</p>

<p>Therefore, Eve was able to modify the cipher text in transit (without necessarily knowing what plain text it corresponds to) such that an entirely different message, 

<math display="inline" id="CBC-MAC:47">
 <semantics>
  <msup>
   <mi>P</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>P</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{\prime}
  </annotation>
 </semantics>
</math>

, was produced, but the tag for this message matched the tag of the original, and Bob was unaware that the contents had been modified in transit. By definition, a Message Authentication Code is <em>broken</em> if we can find a different message (a sequence of plain-text pairs 

<math display="inline" id="CBC-MAC:48">
 <semantics>
  <msup>
   <mi>P</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>P</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P^{\prime}
  </annotation>
 </semantics>
</math>

) which produces the same tag as the previous message, 

<math display="inline" id="CBC-MAC:49">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, with 

<math display="inline" id="CBC-MAC:50">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mo>≠</mo>
   <msup>
    <mi>P</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <ci>P</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>P</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P\not=P^{\prime}
  </annotation>
 </semantics>
</math>

. It follows that the message authentication protocol, in this usage scenario, has been broken, and Bob has been deceived into believing Alice sent him a message which she did not produce.</p>

<p>If, instead, we use different keys for the encryption and authentication stages, say 

<math display="inline" id="CBC-MAC:51">
 <semantics>
  <msub>
   <mi>K</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="CBC-MAC:52">
 <semantics>
  <msub>
   <mi>K</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{2}
  </annotation>
 </semantics>
</math>

, respectively, this attack is foiled. The decryption of the modified cipher-text blocks 

<math display="inline" id="CBC-MAC:53">
 <semantics>
  <msubsup>
   <mi>C</mi>
   <mi>i</mi>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>i</ci>
    </apply>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i}^{\prime}
  </annotation>
 </semantics>
</math>

 obtains some plain text string 

<math display="inline" id="CBC-MAC:54">
 <semantics>
  <msubsup>
   <mi>P</mi>
   <mi>i</mi>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>i</ci>
    </apply>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}^{\prime}
  </annotation>
 </semantics>
</math>

. However, due to the MAC's usage of a different key 

<math display="inline" id="CBC-MAC:55">
 <semantics>
  <msub>
   <mi>K</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{2}
  </annotation>
 </semantics>
</math>

, we cannot "undo" the decryption process in the forward step of the computation of the message authentication code so as to produce the same tag; each modified 

<math display="inline" id="CBC-MAC:56">
 <semantics>
  <msubsup>
   <mi>P</mi>
   <mi>i</mi>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>i</ci>
    </apply>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}^{\prime}
  </annotation>
 </semantics>
</math>

 will now be encrypted by 

<math display="inline" id="CBC-MAC:57">
 <semantics>
  <msub>
   <mi>K</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>K</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{2}
  </annotation>
 </semantics>
</math>

 in the CBC-MAC process to some value 

<math display="inline" id="CBC-MAC:58">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mi>A</mi>
    <msub>
     <mi>C</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>≠</mo>
   <msubsup>
    <mi>C</mi>
    <mi>i</mi>
    <mo>′</mo>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <ci>M</ci>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   MAC_{i}\not=C_{i}^{\prime}
  </annotation>
 </semantics>
</math>

.</p>

<p>This example also shows that a CBC-MAC cannot be used as a collision resistant one-way function: given a key it is trivial to create a different message which "hashes" to the same tag.</p>
<h3 id="allowing-the-initialisation-vector-to-vary-in-value">Allowing the initialisation vector to vary in value</h3>

<p>When encrypting data using a block cipher in <a href="cipher_block_chaining" title="wikilink">cipher block chaining</a> (or another) mode, it is common to introduce an <a href="initialization_vector" title="wikilink">initialization vector</a> to the first stage of the encryption process. It is typically required that this vector be chosen randomly (a <a class="uri" href="nonce" title="wikilink">nonce</a>) and that it is not repeated for any given secret key under which the block cipher operates. This provides semantic security, by means of ensuring the same plain text is not encrypted to the same cipher text, allowing an attacker to infer a relationship exists.</p>

<p>When computing a message authentication code, such as by CBC-MAC, the use of an initialisation vector is a possible attack vector.</p>

<p>In the operation of a cipher block chaining cipher, the first block of plain text is mixed with the initialisation vector using an exclusive OR (

<math display="inline" id="CBC-MAC:59">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mn>1</mn>
   </msub>
   <mo>⊕</mo>
   <mrow>
    <mi>I</mi>
    <mi>V</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">direct-sum</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <ci>I</ci>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{1}\oplus IV
  </annotation>
 </semantics>
</math>

). The result of this operation is the input to the block cipher for encryption.</p>

<p>However, when performing encryption and decryption, we are required to send the initialisation vector in plain text - typically as the block immediately preceding the first block of cipher text - such that the first block of plain text can be decrypted and recovered successfully. If computing a MAC, we will also need to transmit the initialisation vector to the other party in plain text so that they can verify the tag on the message matches the value they have computed.</p>

<p>If we allow the initialisation vector to be selected arbitrarily, it follows that the first block of plain text can potentially be modified (transmitting a different message) while producing the same message tag.</p>

<p>Consider a message 

<math display="inline" id="CBC-MAC:60">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>P</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo stretchy="false">|</mo>
     <msub>
      <mi>P</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">|</mo>
    </mrow>
    <mi mathvariant="normal">…</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{1}=P_{1}|P_{2}|\dots
  </annotation>
 </semantics>
</math>

. In particular, when computing the message tag for CBC-MAC, suppose we choose an initialisation vector 

<math display="inline" id="CBC-MAC:61">
 <semantics>
  <mrow>
   <mi>I</mi>
   <msub>
    <mi>V</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   IV_{1}
  </annotation>
 </semantics>
</math>

 such that computation of the MAC begins with 

<math display="inline" id="CBC-MAC:62">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mi>K</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>I</mi>
      <msub>
       <mi>V</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>⊕</mo>
     <msub>
      <mi>P</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>K</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <times></times>
      <ci>I</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>V</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{K}(IV_{1}\oplus P_{1})
  </annotation>
 </semantics>
</math>

. This produces a (message, tag) pair 

<math display="inline" id="CBC-MAC:63">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>M</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>T</mi>
    <mn>1</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <cn type="integer">1</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (M_{1},T_{1})
  </annotation>
 </semantics>
</math>

.</p>

<p>Now produce the message 

<math display="inline" id="CBC-MAC:64">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mi>P</mi>
     <mn>1</mn>
     <mo>′</mo>
    </msubsup>
    <mrow>
     <mo stretchy="false">|</mo>
     <msub>
      <mi>P</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">|</mo>
    </mrow>
    <mi mathvariant="normal">…</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{2}=P_{1}^{\prime}|P_{2}|\dots
  </annotation>
 </semantics>
</math>

. For each bit modified in 

<math display="inline" id="CBC-MAC:65">
 <semantics>
  <msubsup>
   <mi>P</mi>
   <mn>1</mn>
   <mo>′</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{1}^{\prime}
  </annotation>
 </semantics>
</math>

, flip the corresponding bit in the initialisation vector to produce the initialisation vector 

<math display="inline" id="CBC-MAC:66">
 <semantics>
  <mrow>
   <mi>I</mi>
   <msubsup>
    <mi>V</mi>
    <mn>1</mn>
    <mo>′</mo>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   IV_{1}^{\prime}
  </annotation>
 </semantics>
</math>

. It follows that to compute the MAC for this message, we begin the computation by 

<math display="inline" id="CBC-MAC:67">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mi>K</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msubsup>
      <mi>P</mi>
      <mn>1</mn>
      <mo>′</mo>
     </msubsup>
     <mo>⊕</mo>
     <mrow>
      <mi>I</mi>
      <msubsup>
       <mi>V</mi>
       <mn>1</mn>
       <mo>′</mo>
      </msubsup>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>K</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <times></times>
      <ci>I</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>V</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{K}(P_{1}^{\prime}\oplus IV_{1}^{\prime})
  </annotation>
 </semantics>
</math>

. As bits in both the plain text and initialisation vector have been flipped in the same places, the modification is cancelled in this first stage, meaning the input to the block cipher is identical to that for 

<math display="inline" id="CBC-MAC:68">
 <semantics>
  <msub>
   <mi>M</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{1}
  </annotation>
 </semantics>
</math>

. If no further changes are made to the plain text, the same tag will be derived despite a different message being transmitted.</p>

<p>If the freedom to select an initialisation vector is removed and all implementations of CBC-MAC fix themselves on a particular initialisation vector (often the vector of zeroes, but in theory, it could be anything provided all implementations agree), this attack cannot proceed.</p>
<h2 id="standards-that-define-the-algorithm">Standards that define the algorithm</h2>

<p><a href="FIPS_PUB_113" title="wikilink">FIPS PUB 113</a> <em>Computer Data Authentication</em> is a (now obsolete) <a href="Federal_Information_Processing_Standard" title="wikilink">U.S. government standard</a> that specified the CBC-MAC algorithm using <a href="Data_Encryption_Standard" title="wikilink">DES</a> as the block cipher.</p>

<p>The CBC-MAC algorithm is equivalent to <a href="ISO/IEC_9797-1" title="wikilink">ISO/IEC 9797-1</a> MAC Algorithm 1.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="CMAC" title="wikilink">CMAC</a> – A block-cipher–based MAC algorithm which is secure for messages of different lengths (recommended by <a class="uri" href="NIST" title="wikilink">NIST</a>).</li>
<li><a href="One-key_MAC" title="wikilink">OMAC</a> and <a href="PMAC_(cryptography)" title="wikilink">PMAC</a> – Other methods to turn block ciphers into message authentication codes (MACs).</li>
<li><a href="One-way_compression_function" title="wikilink">One-way compression function</a> – Hash functions can be made from block ciphers. But note, there are significant differences in function and uses for security between <a href="Message_authentication_code" title="wikilink">MACs</a> (such as CBC-MAC) and <a href="Cryptographic_hash_function" title="wikilink">hashes</a>.</li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Message_authentication_codes" title="wikilink">Category:Message authentication codes</a> <a href="Category:Block_cipher_modes_of_operation" title="wikilink">Category:Block cipher modes of operation</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">M. Bellare, J. Kilian and P. Rogaway. <a href="http://www.cs.ucdavis.edu/research/tech-reports/1997/CSE-97-15.pdf">The security of the cipher block chaining message authentication code.</a> JCSS 61(3):362–399, 2000.<a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3"></li>
<li id="fn4"><a href="http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=30656">ISO/IEC 9797-1:1999 <em>Information technology – Security techniques – Message Authentication Codes (MACs) – Part 1: Mechanisms using a block cipher</em></a>, clause 6.1.3 Padding Method 3<a href="#fnref4">↩</a></li>
<li id="fn5">C. Rackoff and S. Gorbunov. On the Security of Block Chaining Message Authentication Code.<a href="#fnref5">↩</a></li>
<li id="fn6"><a class="uri" href="http://spark-university.s3.amazonaws.com/stanford-crypto/slides/05.3-integrity-cbc-mac-and-nmac.pptx">http://spark-university.s3.amazonaws.com/stanford-crypto/slides/05.3-integrity-cbc-mac-and-nmac.pptx</a><a href="#fnref6">↩</a></li>
<li id="fn7">See Section 5 of Bellare, et al.<a href="#fnref7">↩</a></li>
</ol>
</section>
</body>
</html>
