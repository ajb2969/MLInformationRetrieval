<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1860">Large sieve</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Large sieve</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, the <strong>large sieve</strong> is a method (or family of methods and related ideas) in <a href="analytic_number_theory" title="wikilink">analytic number theory</a>.</p>

<p>Its name comes from its original application: given a set 

<math display="inline" id="Large_sieve:0">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>⊂</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>,</mo>
    <mi>N</mi>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <set>
     <cn type="integer">1</cn>
     <ci>normal-⋯</ci>
     <ci>N</ci>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subset\{1,\cdots,N\}
  </annotation>
 </semantics>
</math>

 such that the elements of <em>S</em> are forbidden to lie in a set <em>A<sub>p</sub></em> ⊂ <strong>Z</strong>/<em>p</em> <strong>Z</strong> modulo every prime <em>p</em>, how large can <em>S</em> be? Here <em>A<sub>p</sub></em> is thought of as being large, i.e., at least as large as a constant times <em>p</em>; if this is not the case, we speak of a <em>small sieve</em>. (The term "sieve" is seen as alluding to, say, sifting ore for gold: we "sift out" the integers falling in one of the forbidden congruence classes modulo <em>p</em>, and ask ourselves how much is left at the end.)</p>
<h2 id="development">Development</h2>

<p>Large-sieve methods have been developed enough that they are applicable to small-sieve situations as well. By now, something is seen as related to the large sieve not necessarily in terms of whether it related to the kind situation outlined above, but, rather, if it involves one of the two methods of proof traditionally used to yield a large-sieve result:</p>
<h3 id="approximate-plancherel-inequality">Approximate Plancherel inequality</h3>

<p>If a set 'S' is ill-distributed modulo <em>p</em> (by virtue, for example, of being excluded from the congruence classes <em>A<sub>p</sub></em>) then the Fourier coefficients 

<math display="inline" id="Large_sieve:1">
 <semantics>
  <mrow>
   <mover accent="true">
    <msub>
     <mi>f</mi>
     <mi>p</mi>
    </msub>
    <mo>^</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>p</ci>
     </apply>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{f_{p}}(a)
  </annotation>
 </semantics>
</math>

 of the characteristic function <em>f<sub>p</sub></em> of the set <em>S</em> mod <em>p</em> are in average large. These coefficients can be lifted to values 

<math display="inline" id="Large_sieve:2">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>f</mi>
    <mo>^</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>a</mi>
     <mo>/</mo>
     <mi>p</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <divide></divide>
     <ci>a</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{f}(a/p)
  </annotation>
 </semantics>
</math>

 of the Fourier transform 

<math display="inline" id="Large_sieve:3">
 <semantics>
  <mover accent="true">
   <mi>f</mi>
   <mo>^</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-^</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{f}
  </annotation>
 </semantics>
</math>

 of the characteristic function <em>f</em> of the set <em>S</em> (i.e.,</p>

<p>

<math display="block" id="Large_sieve:4">
 <semantics>
  <mrow>
   <mrow>
    <mover accent="true">
     <mi>f</mi>
     <mo>^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mo>/</mo>
      <mi>p</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mover accent="true">
     <msub>
      <mi>f</mi>
      <mi>p</mi>
     </msub>
     <mo>^</mo>
    </mover>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <ci>f</ci>
     </apply>
     <apply>
      <divide></divide>
      <ci>a</ci>
      <ci>p</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <ci>normal-^</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>p</ci>
      </apply>
     </apply>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{f}(a/p)=\widehat{f_{p}}(a)
  </annotation>
 </semantics>
</math>

).</p>

<p>By bounding derivatives, we can see that 

<math display="inline" id="Large_sieve:5">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>f</mi>
    <mo>^</mo>
   </mover>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <ci>normal-^</ci>
     <ci>f</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \widehat{f}(x)
  </annotation>
 </semantics>
</math>

 must be large, on average, for all <em>x</em> near rational numbers of the form <em>a/p</em>. <em>Large</em> here means "a relatively large constant times <em>|S|</em>". Since</p>

<p>

<math display="block" id="Large_sieve:6">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>f</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <msqrt>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>S</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <abs></abs>
      <ci>f</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <root></root>
     <apply>
      <abs></abs>
      <ci>S</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |f|_{2}=\sqrt{|S|}
  </annotation>
 </semantics>
</math>

,</p>

<p>we get a contradiction with the Plancherel identity</p>

<p>

<math display="block" id="Large_sieve:7">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo stretchy="false">|</mo>
     <mover accent="true">
      <mi>f</mi>
      <mo>^</mo>
     </mover>
     <mo stretchy="false">|</mo>
    </mrow>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>f</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mn>2</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <abs></abs>
      <apply>
       <ci>normal-^</ci>
       <ci>f</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <abs></abs>
      <ci>f</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\widehat{f}|_{2}=|f|_{2}
  </annotation>
 </semantics>
</math>

</p>

<p>unless <em>|S|</em> is small. (In practice, to optimise bounds, people nowadays modify the Plancherel identity into an equality rather than bound derivatives as above.)</p>
<h3 id="duality-principle">Duality principle</h3>

<p>One can prove a strong large-sieve result easily by noting the following basic fact from functional analysis: the norm of a linear operator (i.e.,</p>

<p>

<math display="block" id="Large_sieve:8">
 <semantics>
  <mrow>
   <munder>
    <mo movablelimits="false">sup</mo>
    <mi>v</mi>
   </munder>
   <mrow>
    <msub>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <mi>A</mi>
       <mi>v</mi>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mi>W</mi>
    </msub>
    <mo>/</mo>
    <msub>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>v</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mi>V</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">supremum</csymbol>
     <ci>v</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>v</ci>
       </apply>
      </apply>
      <ci>W</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <abs></abs>
       <ci>v</ci>
      </apply>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sup_{v}|Av|_{W}/|v|_{V}
  </annotation>
 </semantics>
</math>

,</p>

<p>where <em>A</em> is an operator from a linear space <em>V</em> to a linear space <em>W</em>) equals the norm of its adjoint i.e.,</p>

<p>

<math display="block" id="Large_sieve:9">
 <semantics>
  <mrow>
   <munder>
    <mo movablelimits="false">sup</mo>
    <mi>w</mi>
   </munder>
   <mrow>
    <msubsup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <msup>
        <mi>A</mi>
        <mo>*</mo>
       </msup>
       <mi>w</mi>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mi>V</mi>
     <mo>*</mo>
    </msubsup>
    <mo>/</mo>
    <msubsup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>w</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mi>W</mi>
     <mo>*</mo>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <csymbol cd="latexml">supremum</csymbol>
     <ci>w</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>A</ci>
          <times></times>
         </apply>
         <ci>w</ci>
        </apply>
       </apply>
       <times></times>
      </apply>
      <ci>V</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <ci>w</ci>
       </apply>
       <times></times>
      </apply>
      <ci>W</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sup_{w}|A^{*}w|^{*}_{V}/|w|^{*}_{W}
  </annotation>
 </semantics>
</math>

).</p>

<p>This principle itself has come to acquire the name "large sieve" in some of the mathematical literature.</p>

<p>It is also possible to derive the large sieve from majorants in the style of Selberg (see Selberg, <em>Collected Works</em>, vol II, Lectures on sieves).</p>
<h2 id="history">History</h2>

<p>The early history of the large sieve traces back to work of <a href="Yuri_Linnik" title="wikilink"> Yu. B. Linnik</a>, in 1941, working on the problem of the <a href="least_quadratic_non-residue" title="wikilink">least quadratic non-residue</a>. Subsequently <a href="Alfréd_Rényi" title="wikilink">Alfréd Rényi</a> worked on it, using probability methods. It was only two decades later, after quite a number of contributions by others, that the large sieve was formulated in a way that was more definitive. This happened in the early 1960s, in independent work of <a href="Klaus_Roth" title="wikilink">Klaus Roth</a> and <a href="Enrico_Bombieri" title="wikilink">Enrico Bombieri</a>. It is also around that time that the connection with the duality principle became better understood.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Bombieri–Vinogradov_theorem" title="wikilink">Bombieri–Vinogradov theorem</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Sieve_theory" title="wikilink">Category:Sieve theory</a></p>
</body>
</html>
