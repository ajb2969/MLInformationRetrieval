<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="208">Ordinal arithmetic</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Ordinal arithmetic</h1>
<hr/>

<p>In the mathematical field of <a href="set_theory" title="wikilink">set theory</a>, <strong>ordinal arithmetic</strong> describes the three usual operations on <a href="ordinal_number" title="wikilink">ordinal numbers</a>: addition, multiplication, and exponentiation. Each can be defined in essentially two different ways: either by constructing an explicit <a href="well-order" title="wikilink">well-ordered set</a> which represents the operation or by using <a href="transfinite_recursion" title="wikilink">transfinite recursion</a>. Cantor normal form provides a standardized way of writing ordinals. The so-called "natural" arithmetical operations retain <a href="commutative_property" title="wikilink">commutativity</a> at the expense of <a href="continuous_function" title="wikilink">continuity</a>.</p>
<h2 id="addition">Addition</h2>

<p>The union of two disjoint well-ordered sets <em>S</em> and <em>T</em> can be well-ordered. The <a class="uri" href="order-type" title="wikilink">order-type</a> of that union is the ordinal which results from adding the order-types of <em>S</em> and <em>T</em>. If two well-ordered sets are not already disjoint, then they can be replaced by order-isomorphic disjoint sets, e.g. replace <em>S</em> by {0} × <em>S</em> and <em>T</em> by {1} × <em>T</em>. This way, the well-ordered set <em>S</em> is written "to the left" of the well-ordered set <em>T</em>, meaning one defines an order on <em>S</em> 

<math display="inline" id="Ordinal_arithmetic:0">
 <semantics>
  <mo>∪</mo>
  <annotation-xml encoding="MathML-Content">
   <union></union>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \cup
  </annotation>
 </semantics>
</math>

 <em>T</em> in which every element of <em>S</em> is smaller than every element of <em>T</em>. The sets <em>S</em> and <em>T</em> themselves keep the ordering they already have. This addition of the order-types is <a class="uri" href="associative" title="wikilink">associative</a> and generalizes the addition of <a href="natural_numbers" title="wikilink">natural numbers</a>.</p>

<p>The first transfinite ordinal is ω, the set of all natural numbers. For example, the ordinal ω + ω is obtained by two copies of the natural numbers ordered in the usual fashion and the second copy completely to the right of the first. Writing 0' \alpha  but the analogous relation does not hold for the left argument; instead we only have:</p>

<p>

<math display="block" id="Ordinal_arithmetic:1">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo><</mo>
   <mi>β</mi>
   <mo>⇒</mo>
   <mrow>
    <mi>α</mi>
    <mo>+</mo>
    <mi>γ</mi>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mi>β</mi>
    <mo>+</mo>
    <mi>γ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <ci>α</ci>
     <ci>β</ci>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <ci>α</ci>
      <ci>γ</ci>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <ci>β</ci>
      <ci>γ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha<\beta\Rightarrow\alpha+\gamma\leq\beta+\gamma
  </annotation>
 </semantics>
</math>

</p>

<p>Ordinal addition is <a class="uri" href="left-cancellative" title="wikilink">left-cancellative</a>: if <em>α</em> + <em>β</em> = <em>α</em> + <em>γ</em>, then <em>β</em> = <em>γ</em>. Furthermore, one can define <a href="left_division" title="wikilink">left subtraction</a> for ordinals <em>β</em> ≤ <em>α</em>: there is a unique <em>γ</em> such that <em>α</em> = <em>β</em> + <em>γ</em>. On the other hand, right cancellation does not work:</p>

<p>

<math display="block" id="Ordinal_arithmetic:2">
 <semantics>
  <mrow>
   <mrow>
    <mn>3</mn>
    <mo>+</mo>
    <mi>ω</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>+</mo>
    <mi>ω</mi>
   </mrow>
   <mo>=</mo>
   <mi>ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <cn type="integer">3</cn>
      <ci>ω</ci>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">0</cn>
      <ci>ω</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>ω</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3+\omega=0+\omega=\omega
  </annotation>
 </semantics>
</math>

 but 

<math display="inline" id="Ordinal_arithmetic:3">
 <semantics>
  <mrow>
   <mn>3</mn>
   <mo>≠</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <cn type="integer">3</cn>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3\neq 0
  </annotation>
 </semantics>
</math>

 Nor does right subtraction, even when <em>β</em> ≤ <em>α</em>: for example, there does not exist any <em>γ</em> such that <em>γ</em> + 42 = ω.</p>

<p>If the ordinals less than α are closed under addition and contain 0 then α is occasionally called a γ-number (see <a href="additively_indecomposable_ordinal" title="wikilink">additively indecomposable ordinal</a>). These are exactly the ordinals of the form ω<sup>β</sup>.</p>
<h2 id="multiplication">Multiplication</h2>

<p>The <a href="Cartesian_product" title="wikilink">Cartesian product</a>, <em>S×T</em>, of two well-ordered sets <em>S</em> and <em>T</em> can be well-ordered by a variant of <a href="lexicographical_order" title="wikilink">lexicographical order</a> that puts the least significant position first. Effectively, each element of <em>T</em> is replaced by a disjoint copy of <em>S</em>. The order-type of the Cartesian product is the ordinal which results from multiplying the order-types of <em>S</em> and <em>T</em>. Again, this operation is associative and generalizes the multiplication of natural numbers.</p>

<p>Here is ω·2:</p>
<dl>
<dd>0<sub>0</sub> 0 0 0 1 1 1 1 &lt; ...
</dd>
</dl>

<p>which has the same order type as ω + ω. In contrast, 2·ω looks like this:</p>
<dl>
<dd>0<sub>0</sub> 0 1 1 2 2 3 3 &lt; ...
</dd>
</dl>

<p>and after relabeling, this looks just like ω. Thus, ω·2 = ω+ω ≠ ω = 2·ω, showing that multiplication of ordinals is not commutative. More generally, a natural number greater than 1 never commutes with any infinite ordinal, and two infinite ordinals α, β commute if and only if α<sup><em>m</em></sup> = β<sup><em>n</em></sup> for some positive natural numbers <em>m</em> and <em>n</em>. The relation "α commutes with β" is an equivalence relation on the ordinals greater than 1, and all equivalence classes are countably infinite.</p>

<p><a class="uri" href="Distributivity" title="wikilink">Distributivity</a> partially holds for ordinal arithmetic: <em>R</em>(<em>S</em>+<em>T</em>) = <em>RS</em>+<em>RT</em>. However, the other distributive law (<em>T</em>+<em>U</em>)<em>R</em> = <em>TR</em>+<em>UR</em> is <em>not</em> generally true: (1+1)·ω = 2·ω = ω while 1·ω+1·ω = ω+ω which is different. Therefore, the ordinal numbers form a left <a class="uri" href="near-semiring" title="wikilink">near-semiring</a>, but do <em>not</em> form a <a href="ring_(algebra)" title="wikilink">ring</a>.</p>

<p>The definition of multiplication can also be given inductively (the following induction is on <em>β</em>):</p>
<ul>
<li><em>α</em>·0 = 0,</li>
<li><em>α</em>·(<em>β</em>+1) = (<em>α</em>·<em>β</em>)+<em>α</em>,</li>
<li>and if <em>β</em> is a limit ordinal then <em>α</em>·<em>β</em> is the limit of the <em>α</em>·<em>δ</em> for <em>δ</em> &lt; <em>β</em>.</li>
</ul>

<p>The main properties of the product are:</p>
<ul>
<li><em>α</em>·0 = 0·<em>α</em> = 0.</li>
</ul>
<ul>
<li>One (1) is a multiplicative identity <em>α</em>·1 = 1·<em>α</em> = <em>α</em>.</li>
</ul>
<ul>
<li>Multiplication is associative (<em>α</em>·<em>β</em>)·<em>γ</em> = <em>α</em>·(<em>β</em>·<em>γ</em>).</li>
</ul>
<ul>
<li>Multiplication is strictly increasing and continuous in the right argument: (<em>α</em>  0) 

<math display="inline" id="Ordinal_arithmetic:4">
 <semantics>
  <mo>⇒</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⇒</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Rightarrow
  </annotation>
 </semantics>
</math>

 <em>γ</em>·<em>α</em> &lt; <em>γ</em>·<em>β</em></li>
</ul>
<ul>
<li>Multiplication is <em>not</em> strictly increasing in the left argument, for example, 1 \Rightarrow <em>α</em>·<em>γ</em> ≤ <em>β</em>·<em>γ</em>.</li>
</ul>
<ul>
<li>There is a <a href="left-cancellative" title="wikilink">left cancellation</a> law: If <em>α</em> &gt; 0 and <em>α</em>·<em>β</em> = <em>α</em>·<em>γ</em>, then <em>β</em> = <em>γ</em>.</li>
</ul>
<ul>
<li>Right cancellation does not work, e.g. 1·ω = 2·ω = ω, but 1 and 2 are different.</li>
</ul>
<ul>
<li><em>α</em>·<em>β</em> = 0 

<math display="inline" id="Ordinal_arithmetic:5">
 <semantics>
  <mo>⇒</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-⇒</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Rightarrow
  </annotation>
 </semantics>
</math>

 <em>α</em> = 0 or <em>β</em> = 0.</li>
</ul>
<ul>
<li>Distributive law on the left: <em>α</em>·(<em>β</em>+<em>γ</em>) = <em>α</em>·<em>β</em>+<em>α</em>·<em>γ</em></li>
</ul>
<ul>
<li>No distributive law on the right: e.g. (ω+1)·2 = ω+1+ω+1 = ω+ω+1 = ω·2+1 which is not ω·2+2.</li>
</ul>
<ul>
<li><a href="Left_division" title="wikilink">Left division</a> with <a class="uri" href="remainder" title="wikilink">remainder</a>: for all <em>α</em> and <em>β</em>, if <em>β</em> &gt; 0, then there are unique <em>γ</em> and <em>δ</em> such that <em>α</em> = <em>β</em>·<em>γ</em>+<em>δ</em> and <em>δ</em> &lt; <em>β</em>. (This does not however mean the ordinals are a <a href="Euclidean_domain" title="wikilink">Euclidean domain</a>, since they are not even a ring, and the Euclidean "norm" is ordinal-valued.)</li>
</ul>
<ul>
<li>Right division does not work: there is no <em>α</em> such that <em>α</em>·ω ≤ ω<sup>ω</sup> ≤ (<em>α</em>+1)·ω.</li>
</ul>

<p>A δ-number (see <a href="additively_indecomposable_ordinal#Multiplicatively_indecomposable" title="wikilink">additively indecomposable ordinal#Multiplicatively indecomposable</a>) is an ordinal greater than 1 such that αδ=δ whenever 0&lt;α&lt;δ. These are exactly the ordinals of the form ω<sup>ω<sup>β</sup></sup>.</p>
<h2 id="exponentiation">Exponentiation</h2>

<p>The definition of ordinal <a class="uri" href="exponentiation" title="wikilink">exponentiation</a> for finite exponents is straightforward. If the exponent is a finite number, the power is the result of iterated multiplication. For instance, ω<sup>2</sup> = ω·ω using the operation of ordinal multiplication. Note that ω·ω can be defined using the set of functions from 2 = {0,1} to ω = {0,1,2,...}, ordered <a href="Lexicographical_order" title="wikilink">lexicographically</a> with the least significant position first:</p>
<dl>
<dd>(0,0) &lt; (1,0) &lt; (2,0) &lt; (3,0) &lt; ... &lt; (0,1) &lt; (1,1) &lt; (2,1) &lt; (3,1) &lt; ... &lt; (0,2) &lt; (1,2) &lt; (2,2) &lt; ...
</dd>
</dl>

<p>Here for brevity, we have replaced the function {(0,<em>k</em>), (1,<em>m</em>)} by the <a href="ordered_pair" title="wikilink">ordered pair</a> (<em>k</em>, <em>m</em>).</p>

<p>Similarly, for any finite exponent <em>n</em>, 

<math display="inline" id="Ordinal_arithmetic:6">
 <semantics>
  <msup>
   <mi>ω</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ω</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega^{n}
  </annotation>
 </semantics>
</math>

 can be defined using the set of functions from <em>n</em> (the domain) to the natural numbers (the range). These functions can be abbreviated as <a href="tuple" title="wikilink"><em>n</em>-tuples</a> of natural numbers.</p>

<p>But for infinite exponents, the definition may not be obvious. A limit ordinal, such as ω<sup>ω</sup>, is the supremum of all smaller ordinals. It might seem natural to define ω<sup>ω</sup> using the set of all infinite sequences of natural numbers. However, we find that any <a href="absoluteness_(mathematical_logic)" title="wikilink">absolutely</a> defined ordering on this set is not well-ordered. To deal with this issue we can use the variant lexicographical ordering again. We restrict the set to sequences which are nonzero for only a finite number of arguments. This is naturally motivated as the limit of the finite powers of the base (similar to the concept of <a class="uri" href="coproduct" title="wikilink">coproduct</a> in algebra). This can also be thought of as the <a href="infinite_union" title="wikilink">infinite union</a> 

<math display="inline" id="Ordinal_arithmetic:7">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋃</mo>
    <mrow>
     <mi>n</mi>
     <mo><</mo>
     <mi>ω</mi>
    </mrow>
   </msub>
   <msup>
    <mi>ω</mi>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <union></union>
     <apply>
      <lt></lt>
      <ci>n</ci>
      <ci>ω</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ω</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigcup_{n<\omega}\omega^{n}
  </annotation>
 </semantics>
</math>

.</p>

<p>Each of those sequences corresponds to an ordinal less than 

<math display="inline" id="Ordinal_arithmetic:8">
 <semantics>
  <msup>
   <mi>ω</mi>
   <mi>ω</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ω</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega^{\omega}
  </annotation>
 </semantics>
</math>

 such as 

<math display="inline" id="Ordinal_arithmetic:9">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>ω</mi>
     <msub>
      <mi>n</mi>
      <mn>1</mn>
     </msub>
    </msup>
    <msub>
     <mi>c</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>+</mo>
   <mrow>
    <msup>
     <mi>ω</mi>
     <msub>
      <mi>n</mi>
      <mn>2</mn>
     </msub>
    </msup>
    <msub>
     <mi>c</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>+</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>+</mo>
   <mrow>
    <msup>
     <mi>ω</mi>
     <msub>
      <mi>n</mi>
      <mi>k</mi>
     </msub>
    </msup>
    <msub>
     <mi>c</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ω</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ω</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ω</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega^{n_{1}}c_{1}+\omega^{n_{2}}c_{2}+\cdots+\omega^{n_{k}}c_{k}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Ordinal_arithmetic:10">
 <semantics>
  <msup>
   <mi>ω</mi>
   <mi>ω</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ω</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega^{\omega}
  </annotation>
 </semantics>
</math>

 is the supremum of all those smaller ordinals.</p>

<p>The lexicographical order on this set is a well ordering that resembles the ordering of natural numbers written in decimal notation, except with digit positions reversed, and with arbitrary natural numbers instead of just the digits 0–9:</p>
<dl>
<dd>(0,0,0,...) &lt; (1,0,0,0,...) &lt; (2,0,0,0,...) &lt; ... &lt;
</dd>
<dd>(0,1,0,0,0,...) &lt; (1,1,0,0,0,...) &lt; (2,1,0,0,0,...) &lt; ... &lt;
</dd>
<dd>(0,2,0,0,0,...) &lt; (1,2,0,0,0,...) &lt; (2,2,0,0,0,...)
<dl>
<dd>&lt; ... &lt;
</dd>
</dl>
</dd>
<dd>(0,0,1,0,0,0,...) &lt; (1,0,1,0,0,0,...) &lt; (2,0,1,0,0,0,...)
<dl>
<dd>&lt; ...
</dd>
</dl>
</dd>
</dl>

<p>In general, any ordinal <em>α</em> can be raised to the power of another ordinal <em>β</em> in the same way to get <em>α</em><sup><em>β</em></sup>.</p>

<p>It is easiest to explain this using <a href="Ordinal_number#Von_Neumann_definition_of_ordinals" title="wikilink">Von Neumann's definition of an ordinal as the set of all smaller ordinals</a>. Then, to construct a set of order type <em>α</em><sup><em>β</em></sup> consider all functions from <em>β</em> to <em>α</em> such that only a finite number of elements of the domain <em>β</em> map to a non zero element of <em>α</em> (essentially, we consider the functions with finite <a href="Support_(mathematics)" title="wikilink">support</a>). The order is lexicographic with the least significant position first. We find</p>
<ul>
<li>1<sup>ω</sup> = 1,</li>
<li>2<sup>ω</sup> = ω,</li>
<li>2<sup>ω+1</sup> = ω·2 = ω+ω.</li>
</ul>

<p>The definition of exponentiation can also be given inductively (the following induction is on <em>β</em>, the exponent):</p>
<ul>
<li><em>α</em><sup>0</sup> = 1,</li>
<li><em>α</em><sup><em>β</em>+1</sup> = (<em>α</em><sup><em>β</em></sup>)·<em>α</em>, and</li>
<li>if <em>δ</em> is limit, then <em>α</em><sup><em>δ</em></sup> is the limit of the <em>α</em><sup><em>β</em></sup> for all <em>β</em> &lt; <em>δ</em>.</li>
</ul>

<p>Properties of ordinal exponentiation:</p>
<ul>
<li><em>α</em><sup>0</sup> = 1.</li>
<li>If 0 <em>α</em> = 0.</li>
<li>1<sup><em>α</em></sup> = 1.</li>
<li><em>α</em><sup>1</sup> = <em>α</em>.</li>
<li><em>α</em><sup><em>β</em></sup>·<em>α</em><sup><em>γ</em></sup> = <em>α</em><sup><em>β</em> + <em>γ</em></sup>.</li>
<li>(<em>α</em><sup><em>β</em></sup>)<sup><em>γ</em></sup> = <em>α</em><sup><em>β</em>·<em>γ</em></sup>.</li>
<li>There are <em>α</em>, <em>β</em>, and <em>γ</em> for which (<em>α</em>·<em>β</em>)<sup><em>γ</em></sup> ≠ <em>α</em><sup><em>γ</em></sup>·<em>β</em><sup><em>γ</em></sup>. For instance, (ω·2)<sup>2</sup> = ω·2·ω·2 = ω<sup>2</sup>·2 ≠ ω<sup>2</sup>·4.</li>
<li>Ordinal exponentiation is strictly increasing and continuous in the right argument: If <em>γ</em> &gt; 1 and <em>α</em> <em>α</em> <em>β</em>.</li>
<li>If <em>α</em> <em>γ</em> ≤ <em>β</em><sup><em>γ</em></sup>. Note, for instance, that 2 ω = 3<sup>ω</sup> = ω.</li>
<li>If <em>α</em> &gt; 1 and <em>α</em><sup><em>β</em></sup> = <em>α</em><sup><em>γ</em></sup>, then <em>β</em> = <em>γ</em>. If <em>α</em> = 1 or <em>α</em> = 0 this is not the case.</li>
<li>For all <em>α</em> and <em>β</em>, if <em>β</em> &gt; 1 and <em>α</em> &gt; 0 then there exist unique <em>γ</em>, <em>δ</em>, and <em>ρ</em> such that <em>α</em> = <em>β</em><sup><em>γ</em></sup>·<em>δ</em> + <em>ρ</em> such that 0 <em>γ</em>.</li>
</ul>

<p><strong>Warning:</strong> Ordinal exponentiation is quite different from cardinal exponentiation. For example, the ordinal exponentiation 2<sup>ω</sup> = ω, but the cardinal exponentiation 

<math display="inline" id="Ordinal_arithmetic:11">
 <semantics>
  <msup>
   <mn>2</mn>
   <msub>
    <mi mathvariant="normal">ℵ</mi>
    <mn>0</mn>
   </msub>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-ℵ</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{\aleph_{0}}
  </annotation>
 </semantics>
</math>

 is the <a href="cardinality_of_the_continuum" title="wikilink">cardinality of the continuum</a> which is larger than 

<math display="inline" id="Ordinal_arithmetic:12">
 <semantics>
  <msub>
   <mi mathvariant="normal">ℵ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-ℵ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \aleph_{0}
  </annotation>
 </semantics>
</math>

. To avoid confusing ordinal exponentiation with cardinal exponentiation, one can use symbols for ordinals (e.g. ω) in the former and symbols for cardinals (e.g. 

<math display="inline" id="Ordinal_arithmetic:13">
 <semantics>
  <msub>
   <mi mathvariant="normal">ℵ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-ℵ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \aleph_{0}
  </annotation>
 </semantics>
</math>

) in the latter.</p>

<p>Jacobsthal showed that the only solutions of α<sup>β</sup> = β<sup>α</sup> with α≤β are given by α=β, or α=2 β=4, or α is any limit ordinal and β=εα where ε is an ε-number larger than α.</p>
<h2 id="cantor-normal-form">Cantor normal form</h2>

<p>Every ordinal number <em>α</em> can be uniquely written as 

<math display="inline" id="Ordinal_arithmetic:14">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>ω</mi>
     <msub>
      <mi>β</mi>
      <mn>1</mn>
     </msub>
    </msup>
    <msub>
     <mi>c</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>+</mo>
   <mrow>
    <msup>
     <mi>ω</mi>
     <msub>
      <mi>β</mi>
      <mn>2</mn>
     </msub>
    </msup>
    <msub>
     <mi>c</mi>
     <mn>2</mn>
    </msub>
   </mrow>
   <mo>+</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>+</mo>
   <mrow>
    <msup>
     <mi>ω</mi>
     <msub>
      <mi>β</mi>
      <mi>k</mi>
     </msub>
    </msup>
    <msub>
     <mi>c</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ω</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ω</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ω</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega^{\beta_{1}}c_{1}+\omega^{\beta_{2}}c_{2}+\cdots+\omega^{\beta_{k}}c_{k}
  </annotation>
 </semantics>
</math>

, where <em>k</em> is a natural number, 

<math display="inline" id="Ordinal_arithmetic:15">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>c</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>c</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{1},c_{2},\ldots,c_{k}
  </annotation>
 </semantics>
</math>

 are positive integers, and 

<math display="inline" id="Ordinal_arithmetic:16">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mn>1</mn>
   </msub>
   <mo>></mo>
   <msub>
    <mi>β</mi>
    <mn>2</mn>
   </msub>
   <mo>></mo>
   <mi mathvariant="normal">…</mi>
   <mo>></mo>
   <msub>
    <mi>β</mi>
    <mi>k</mi>
   </msub>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <gt></gt>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <gt></gt>
     <share href="#.cmml">
     </share>
     <ci>normal-…</ci>
    </apply>
    <apply>
     <gt></gt>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{1}>\beta_{2}>\ldots>\beta_{k}\geq 0
  </annotation>
 </semantics>
</math>

 are ordinal numbers. This decomposition of <em>α</em> is called the <strong>Cantor normal form</strong> of <em>α</em>, and can be considered the base-ω <a href="positional_numeral_system" title="wikilink">positional numeral system</a>. The highest exponent 

<math display="inline" id="Ordinal_arithmetic:17">
 <semantics>
  <msub>
   <mi>β</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{1}
  </annotation>
 </semantics>
</math>

 is called the degree of 

<math display="inline" id="Ordinal_arithmetic:18">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

, and satisfies 

<math display="inline" id="Ordinal_arithmetic:19">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mn>1</mn>
   </msub>
   <mo>≤</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{1}\leq\alpha
  </annotation>
 </semantics>
</math>

. The equality 

<math display="inline" id="Ordinal_arithmetic:20">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{1}=\alpha
  </annotation>
 </semantics>
</math>

 applies if and only if 

<math display="inline" id="Ordinal_arithmetic:21">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>=</mo>
   <msup>
    <mi>ω</mi>
    <mi>α</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>α</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ω</ci>
     <ci>α</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha=\omega^{\alpha}
  </annotation>
 </semantics>
</math>

. In that case Cantor normal form does not express the ordinal in terms of smaller ones; this can happen as explained below.</p>

<p>A minor variation of Cantor normal form, which is usually slightly easier to work with, is to set all the numbers <em>c</em><sub><em>i</em></sub> equal to 1 and allow the exponents to be equal. In other words, every ordinal number α can be uniquely written as 

<math display="inline" id="Ordinal_arithmetic:22">
 <semantics>
  <mrow>
   <msup>
    <mi>ω</mi>
    <msub>
     <mi>β</mi>
     <mn>1</mn>
    </msub>
   </msup>
   <mo>+</mo>
   <msup>
    <mi>ω</mi>
    <msub>
     <mi>β</mi>
     <mn>2</mn>
    </msub>
   </msup>
   <mo>+</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>+</mo>
   <msup>
    <mi>ω</mi>
    <msub>
     <mi>β</mi>
     <mi>k</mi>
    </msub>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ω</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ω</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ω</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega^{\beta_{1}}+\omega^{\beta_{2}}+\cdots+\omega^{\beta_{k}}
  </annotation>
 </semantics>
</math>

, where <em>k</em> is a natural number, and 

<math display="inline" id="Ordinal_arithmetic:23">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mn>1</mn>
   </msub>
   <mo>≥</mo>
   <msub>
    <mi>β</mi>
    <mn>2</mn>
   </msub>
   <mo>≥</mo>
   <mi mathvariant="normal">…</mi>
   <mo>≥</mo>
   <msub>
    <mi>β</mi>
    <mi>k</mi>
   </msub>
   <mo>≥</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <ci>normal-…</ci>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{1}\geq\beta_{2}\geq\ldots\geq\beta_{k}\geq 0
  </annotation>
 </semantics>
</math>

 are ordinal numbers.</p>

<p>Another variation of the Cantor normal form is the "base δ expansion", where ω is replaced by any ordinal δ&gt;1, and the numbers <em>c</em><sub><em>i</em></sub> are positive ordinals less than δ.</p>

<p>The Cantor normal form allows us to uniquely express—and order—the ordinals <em>α</em> that are built from the natural numbers by a finite number of arithmetical operations of addition, multiplication and exponentiation base-

<math display="inline" id="Ordinal_arithmetic:24">
 <semantics>
  <mi>ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega
  </annotation>
 </semantics>
</math>

: in other words, assuming 

<math display="inline" id="Ordinal_arithmetic:25">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mn>1</mn>
   </msub>
   <mo><</mo>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>β</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{1}<\alpha
  </annotation>
 </semantics>
</math>

 in the Cantor normal form, we can also express the exponents 

<math display="inline" id="Ordinal_arithmetic:26">
 <semantics>
  <msub>
   <mi>β</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{i}
  </annotation>
 </semantics>
</math>

 in Cantor normal form, and making the same assumption for the 

<math display="inline" id="Ordinal_arithmetic:27">
 <semantics>
  <msub>
   <mi>β</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{i}
  </annotation>
 </semantics>
</math>

 as for α and so on recursively, we get a system of notation for these ordinals (for example,</p>

<p>

<math display="block" id="Ordinal_arithmetic:28">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>ω</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <msup>
         <mi>ω</mi>
         <mrow>
          <mo>(</mo>
          <mrow>
           <mrow>
            <msup>
             <mi>ω</mi>
             <mn>7</mn>
            </msup>
            <mo>⋅</mo>
            <mn>6</mn>
           </mrow>
           <mo>+</mo>
           <mi>ω</mi>
           <mo>+</mo>
           <mn>42</mn>
          </mrow>
          <mo>)</mo>
         </mrow>
        </msup>
        <mo>⋅</mo>
        <mn>1729</mn>
       </mrow>
       <mo>+</mo>
       <msup>
        <mi>ω</mi>
        <mn>9</mn>
       </msup>
       <mo>+</mo>
       <mn>88</mn>
      </mrow>
      <mo>)</mo>
     </mrow>
    </msup>
    <mo>⋅</mo>
    <mn>3</mn>
   </mrow>
   <mo>+</mo>
   <mrow>
    <msup>
     <mi>ω</mi>
     <mrow>
      <mo>(</mo>
      <msup>
       <mi>ω</mi>
       <mi>ω</mi>
      </msup>
      <mo>)</mo>
     </mrow>
    </msup>
    <mo>⋅</mo>
    <mn>5</mn>
   </mrow>
   <mo>+</mo>
   <mn>65537</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ω</ci>
      <apply>
       <plus></plus>
       <apply>
        <ci>normal-⋅</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ω</ci>
         <apply>
          <plus></plus>
          <apply>
           <ci>normal-⋅</ci>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>ω</ci>
            <cn type="integer">7</cn>
           </apply>
           <cn type="integer">6</cn>
          </apply>
          <ci>ω</ci>
          <cn type="integer">42</cn>
         </apply>
        </apply>
        <cn type="integer">1729</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ω</ci>
        <cn type="integer">9</cn>
       </apply>
       <cn type="integer">88</cn>
      </apply>
     </apply>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ω</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ω</ci>
       <ci>ω</ci>
      </apply>
     </apply>
     <cn type="integer">5</cn>
    </apply>
    <cn type="integer">65537</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega^{\left(\omega^{\left(\omega^{7}\cdot 6+\omega+42\right)}\cdot 1729+%
\omega^{9}+88\right)}\cdot 3+\omega^{\left(\omega^{\omega}\right)}\cdot 5+65537
  </annotation>
 </semantics>
</math>

</p>

<p>denotes an ordinal).</p>

<p>The ordinal ε<sub>0</sub> (<a href="Epsilon_numbers_(mathematics)" title="wikilink">epsilon nought</a>) is the set of ordinal values α of the finite-length arithmetical expressions of Cantor normal form that are hereditarily non-trivial where non-trivial means β<sub>1</sub>&lt;α when 0&lt;α. It is the smallest ordinal that does not have a finite arithmetical expression in terms of ω, and the smallest ordinal such that 

<math display="inline" id="Ordinal_arithmetic:29">
 <semantics>
  <mrow>
   <msub>
    <mi>ε</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <msup>
    <mi>ω</mi>
    <msub>
     <mi>ε</mi>
     <mn>0</mn>
    </msub>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ε</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ω</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ε</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon_{0}=\omega^{\varepsilon_{0}}
  </annotation>
 </semantics>
</math>

, i.e. in Cantor normal form the exponent is not smaller than the ordinal itself. It is the limit of the sequence</p>

<p>

<math display="block" id="Ordinal_arithmetic:30">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mn>0</mn>
      <mo>,</mo>
      <mn>1</mn>
     </mrow>
     <mo>=</mo>
     <msup>
      <mi>ω</mi>
      <mn>0</mn>
     </msup>
    </mrow>
    <mo rspace="4.2pt">,</mo>
    <mrow>
     <mi>ω</mi>
     <mo>=</mo>
     <mrow>
      <msup>
       <mi>ω</mi>
       <mn>1</mn>
      </msup>
      <mo rspace="4.2pt">,</mo>
      <msup>
       <mi>ω</mi>
       <mi>ω</mi>
      </msup>
      <mo rspace="4.2pt">,</mo>
      <msup>
       <mi>ω</mi>
       <msup>
        <mi>ω</mi>
        <mi>ω</mi>
       </msup>
      </msup>
      <mo rspace="4.2pt">,</mo>
      <mpadded width="+1.7pt">
       <mi mathvariant="normal">…</mi>
      </mpadded>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <list>
      <cn type="integer">0</cn>
      <cn type="float">1</cn>
     </list>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ω</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>ω</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ω</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ω</ci>
       <ci>ω</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ω</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ω</ci>
        <ci>ω</ci>
       </apply>
      </apply>
      <ci>normal-…</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0,\,1=\omega^{0},\,\omega=\omega^{1},\,\omega^{\omega},\,\omega^{\omega^{%
\omega}},\,\ldots\,.
  </annotation>
 </semantics>
</math>

</p>

<p>The ordinal ε<sub>0</sub> is important for various reasons in arithmetic (essentially because it measures the <a href="proof-theoretic_strength" title="wikilink">proof-theoretic strength</a> of the <a href="First-order_logic" title="wikilink">first-order</a> <a href="Peano_axioms" title="wikilink">Peano arithmetic</a>: that is, Peano's axioms can show transfinite induction up to any ordinal less than ε<sub>0</sub> but not up to ε<sub>0</sub> itself).</p>

<p>The Cantor normal form also allows us to compute sums and products of ordinals: to compute the sum, for example, one need merely know that</p>

<p>

<math display="block" id="Ordinal_arithmetic:31">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msup>
       <mi>ω</mi>
       <mi>β</mi>
      </msup>
      <mi>c</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msup>
       <mi>ω</mi>
       <msup>
        <mi>β</mi>
        <mo>′</mo>
       </msup>
      </msup>
      <msup>
       <mi>c</mi>
       <mo>′</mo>
      </msup>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>ω</mi>
      <msup>
       <mi>β</mi>
       <mo>′</mo>
      </msup>
     </msup>
     <mpadded width="+1.7pt">
      <msup>
       <mi>c</mi>
       <mo>′</mo>
      </msup>
     </mpadded>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ω</ci>
       <ci>β</ci>
      </apply>
      <ci>c</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ω</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>β</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>c</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ω</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>β</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>c</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega^{\beta}c+\omega^{\beta^{\prime}}c^{\prime}=\omega^{\beta^{\prime}}c^{%
\prime}\,,
  </annotation>
 </semantics>
</math>

</p>

<p>if 

<math display="inline" id="Ordinal_arithmetic:32">
 <semantics>
  <mrow>
   <msup>
    <mi>β</mi>
    <mo>′</mo>
   </msup>
   <mo>></mo>
   <mi>β</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>β</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta^{\prime}>\beta
  </annotation>
 </semantics>
</math>

 (if 

<math display="inline" id="Ordinal_arithmetic:33">
 <semantics>
  <mrow>
   <msup>
    <mi>β</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mi>β</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>β</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta^{\prime}=\beta
  </annotation>
 </semantics>
</math>

 one can obviously rewrite this as 

<math display="inline" id="Ordinal_arithmetic:34">
 <semantics>
  <mrow>
   <msup>
    <mi>ω</mi>
    <mi>β</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>c</mi>
     <mo>+</mo>
     <msup>
      <mi>c</mi>
      <mo>′</mo>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ω</ci>
     <ci>β</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>c</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>c</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega^{\beta}(c+c^{\prime})
  </annotation>
 </semantics>
</math>

, and if 

<math display="inline" id="Ordinal_arithmetic:35">
 <semantics>
  <mrow>
   <msup>
    <mi>β</mi>
    <mo>′</mo>
   </msup>
   <mo><</mo>
   <mi>β</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>β</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>β</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta^{\prime}<\beta
  </annotation>
 </semantics>
</math>

 the expression is already in Cantor normal form); and to compute products, the essential facts are that when 

<math display="inline" id="Ordinal_arithmetic:36">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo><</mo>
   <mi>α</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>ω</mi>
      <msub>
       <mi>β</mi>
       <mn>1</mn>
      </msub>
     </msup>
     <msub>
      <mi>c</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <mrow>
     <msup>
      <mi>ω</mi>
      <msub>
       <mi>β</mi>
       <mi>k</mi>
      </msub>
     </msup>
     <msub>
      <mi>c</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <cn type="integer">0</cn>
     <ci>α</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ω</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>β</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ω</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>β</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0<\alpha=\omega^{\beta_{1}}c_{1}+\cdots+\omega^{\beta_{k}}c_{k}
  </annotation>
 </semantics>
</math>

 is in Cantor normal form and 

<math display="inline" id="Ordinal_arithmetic:37">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo><</mo>
   <msup>
    <mi>β</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <cn type="integer">0</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>β</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0<\beta^{\prime}
  </annotation>
 </semantics>
</math>

, then</p>

<p>

<math display="block" id="Ordinal_arithmetic:38">
 <semantics>
  <mrow>
   <mrow>
    <mi>α</mi>
    <msup>
     <mi>ω</mi>
     <msup>
      <mi>β</mi>
      <mo>′</mo>
     </msup>
    </msup>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <msup>
     <mi>ω</mi>
     <mrow>
      <msub>
       <mi>β</mi>
       <mn>1</mn>
      </msub>
      <mo>+</mo>
      <msup>
       <mi>β</mi>
       <mo>′</mo>
      </msup>
     </mrow>
    </msup>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>α</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ω</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>β</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ω</ci>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>β</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\omega^{\beta^{\prime}}=\omega^{\beta_{1}+\beta^{\prime}}\,
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Ordinal_arithmetic:39">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>α</mi>
     <mi>n</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>ω</mi>
       <msub>
        <mi>β</mi>
        <mn>1</mn>
       </msub>
      </msup>
      <msub>
       <mi>c</mi>
       <mn>1</mn>
      </msub>
      <mi>n</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msup>
       <mi>ω</mi>
       <msub>
        <mi>β</mi>
        <mn>2</mn>
       </msub>
      </msup>
      <msub>
       <mi>c</mi>
       <mn>2</mn>
      </msub>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>+</mo>
     <mrow>
      <msup>
       <mi>ω</mi>
       <msub>
        <mi>β</mi>
        <mi>k</mi>
       </msub>
      </msup>
      <mpadded width="+1.7pt">
       <msub>
        <mi>c</mi>
        <mi>k</mi>
       </msub>
      </mpadded>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>α</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ω</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>β</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ω</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>β</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ω</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>β</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha n=\omega^{\beta_{1}}c_{1}n+\omega^{\beta_{2}}c_{2}+\cdots+\omega^{\beta%
_{k}}c_{k}\,,
  </annotation>
 </semantics>
</math>

</p>

<p>if n is a non-zero natural number.</p>

<p>To compare two ordinals written in Cantor normal form, first compare 

<math display="inline" id="Ordinal_arithmetic:40">
 <semantics>
  <msub>
   <mi>β</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{1}
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Ordinal_arithmetic:41">
 <semantics>
  <msub>
   <mi>c</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{1}
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Ordinal_arithmetic:42">
 <semantics>
  <msub>
   <mi>β</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>β</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{2}
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Ordinal_arithmetic:43">
 <semantics>
  <msub>
   <mi>c</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>c</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{2}
  </annotation>
 </semantics>
</math>

, etc.. At the first difference, the ordinal that has the larger component is the larger ordinal. If they are the same until one terminates before the other, then the one that terminates first is smaller.</p>
<h2 id="factorization-into-primes">Factorization into primes</h2>

<p><a href="Ernst_Jacobsthal" title="wikilink">Ernst Jacobsthal</a> showed that the ordinals satisfy a form of the unique factorization theorem: every nonzero ordinal can be written as a product of a finite number of prime ordinals. This factorization into prime ordinals is in general not unique, but there is a "minimal" factorization into primes that is unique up to changing the order of finite prime factors .</p>

<p>A prime ordinal is an ordinal greater than 1 that cannot be written as a product of two smaller ordinals. Some of the first primes are 2, 3, 5, ... , ω, ω+1, ω<sup>2</sup>+1, ω<sup>3</sup>+1, ..., ω<sup>ω</sup>, ω<sup>ω</sup>+1, ω<sup>ω+1</sup>+1, ... There are three sorts of prime ordinals:</p>
<ul>
<li>The finite primes 2, 3, 5, ...</li>
<li>The ordinals of the form ω<sup>ω<sup>α</sup></sup> for any ordinal α. These are the prime ordinals that are limits, and are the <a href="delta_number" title="wikilink">delta numbers</a>.</li>
<li>The ordinals of the form ω<sup>α</sup>+1 for any ordinal α&gt;0. These are the infinite successor primes, and are the successors of <a href="Additively_indecomposable_ordinal" title="wikilink">gamma numbers</a>, the additively indecomposable ordinals.</li>
</ul>

<p>Factorization into primes is not unique: for example, 2×3=3×2, 2×ω=ω, (ω+1)×ω=ω×ω and ω×ω<sup>ω</sup> = ω<sup>ω</sup>. However there is a unique factorization into primes satisfying the following additional conditions:</p>
<ul>
<li>Every limit prime occurs before every successor prime</li>
<li>If two consecutive primes of the prime factorization are both limits or both finite, then the second one is at most the first one.</li>
</ul>

<p>This prime factorization can easily be read off using the Cantor normal form as follows:</p>
<ul>
<li>First write the ordinal as a product αβ where α is the smallest power of ω in the Cantor normal form and β is a successor.</li>
<li>If α=ω<sup>γ</sup> then writing γ in Cantor normal form gives an expansion of α as a product of limit primes.</li>
<li>Now look at the Cantor normal form of β. If β = ω<sup>λ</sup>m + ω<sup>μ</sup><em>n</em>+ smaller terms then β = (ω<sup>μ</sup><em>n</em>+ smaller terms)(ω<sup>λ−μ</sup> + 1)<em>m</em> is a product of a smaller ordinal and a prime and an integer <em>m</em>. Repeating this and factorizing the integers into primes gives the prime factorization of β.</li>
</ul>

<p>So the factorization of the Cantor normal form ordinal</p>

<p>

<math display="block" id="Ordinal_arithmetic:44">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>ω</mi>
     <msub>
      <mi>α</mi>
      <mn>1</mn>
     </msub>
    </msup>
    <msub>
     <mi>n</mi>
     <mn>1</mn>
    </msub>
   </mrow>
   <mo>+</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>+</mo>
   <mrow>
    <msup>
     <mi>ω</mi>
     <msub>
      <mi>α</mi>
      <mi>k</mi>
     </msub>
    </msup>
    <msub>
     <mi>n</mi>
     <mi>k</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ω</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ω</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega^{\alpha_{1}}n_{1}+\cdots+\omega^{\alpha_{k}}n_{k}
  </annotation>
 </semantics>
</math>

 (with 

<math display="inline" id="Ordinal_arithmetic:45">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mn>1</mn>
   </msub>
   <mo>></mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>></mo>
   <msub>
    <mi>α</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <gt></gt>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <gt></gt>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{1}>\cdots>\alpha_{k}
  </annotation>
 </semantics>
</math>

) into a minimal product of infinite primes and integers is</p>

<p>

<math display="block" id="Ordinal_arithmetic:46">
 <semantics>
  <mrow>
   <msup>
    <mi>ω</mi>
    <msup>
     <mi>ω</mi>
     <msub>
      <mi>β</mi>
      <mn>1</mn>
     </msub>
    </msup>
   </msup>
   <mi mathvariant="normal">⋯</mi>
   <msup>
    <mi>ω</mi>
    <msup>
     <mi>ω</mi>
     <msub>
      <mi>β</mi>
      <mi>m</mi>
     </msub>
    </msup>
   </msup>
   <msub>
    <mi>n</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>ω</mi>
      <mrow>
       <msub>
        <mi>α</mi>
        <mrow>
         <mi>k</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>α</mi>
        <mi>k</mi>
       </msub>
      </mrow>
     </msup>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <msub>
    <mi>n</mi>
    <mrow>
     <mi>k</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mi mathvariant="normal">⋯</mi>
   <msub>
    <mi>n</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>ω</mi>
      <mrow>
       <msub>
        <mi>α</mi>
        <mn>1</mn>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>α</mi>
        <mn>2</mn>
       </msub>
      </mrow>
     </msup>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <msub>
    <mi>n</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ω</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ω</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ω</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ω</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ω</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <apply>
         <minus></minus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <apply>
      <minus></minus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>normal-⋯</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ω</ci>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>α</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega^{\omega^{\beta_{1}}}\cdots\omega^{\omega^{\beta_{m}}}n_{k}(\omega^{%
\alpha_{k-1}-\alpha_{k}}+1)n_{k-1}\cdots n_{2}(\omega^{\alpha_{1}-\alpha_{2}}+%
1)n_{1}
  </annotation>
 </semantics>
</math>

 where each <em>n</em><sub><em>i</em></sub> should be replaced by its factorization into a non-increasing sequence of finite primes and</p>

<p>

<math display="block" id="Ordinal_arithmetic:47">
 <semantics>
  <mrow>
   <msub>
    <mi>α</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>ω</mi>
     <msub>
      <mi>β</mi>
      <mn>1</mn>
     </msub>
    </msup>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <msup>
     <mi>ω</mi>
     <msub>
      <mi>β</mi>
      <mi>m</mi>
     </msub>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ω</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ω</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>β</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{k}=\omega^{\beta_{1}}+\cdots+\omega^{\beta_{m}}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Ordinal_arithmetic:48">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mn>1</mn>
   </msub>
   <mo>≥</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo>≥</mo>
   <msub>
    <mi>β</mi>
    <mi>m</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <geq></geq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{1}\geq\cdots\geq\beta_{m}
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="large-countable-ordinals">Large countable ordinals</h2>

<p>As discussed above, the Cantor Normal Form of ordinals below 

<math display="inline" id="Ordinal_arithmetic:49">
 <semantics>
  <msub>
   <mi>ϵ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϵ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{0}
  </annotation>
 </semantics>
</math>

 can be expressed in an alphabet containing only the function symbols for addition, multiplication and exponentiation, as well as constant symbols for each natural number and for 

<math display="inline" id="Ordinal_arithmetic:50">
 <semantics>
  <mi>ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega
  </annotation>
 </semantics>
</math>

. We can do away with the infinitely many numerals by using just the constant symbol 0 and the operation of successor, 

<math display="inline" id="Ordinal_arithmetic:51">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 (for example, the integer 4 may be expressed as 

<math display="inline" id="Ordinal_arithmetic:52">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>S</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>S</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>S</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mn>0</mn>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <times></times>
      <ci>S</ci>
      <apply>
       <times></times>
       <ci>S</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(S(S(S(0))))
  </annotation>
 </semantics>
</math>

). This describes an <em><a href="ordinal_notation" title="wikilink">ordinal notation</a></em>: a system for naming ordinals over a finite alphabet. This particular system of ordinal notation is called the collection of <em>arithmetical</em> ordinal expressions, and can express all ordinals below 

<math display="inline" id="Ordinal_arithmetic:53">
 <semantics>
  <msub>
   <mi>ϵ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϵ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{0}
  </annotation>
 </semantics>
</math>

, but cannot express 

<math display="inline" id="Ordinal_arithmetic:54">
 <semantics>
  <msub>
   <mi>ϵ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϵ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{0}
  </annotation>
 </semantics>
</math>

. There are other ordinal notations capable of capturing ordinals well past 

<math display="inline" id="Ordinal_arithmetic:55">
 <semantics>
  <msub>
   <mi>ϵ</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϵ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon_{0}
  </annotation>
 </semantics>
</math>

, but because there are only countably many strings over any finite alphabet, for any given ordinal notation there will be ordinals below 

<math display="inline" id="Ordinal_arithmetic:56">
 <semantics>
  <msub>
   <mi>ω</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ω</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{1}
  </annotation>
 </semantics>
</math>

 that are not expressible. Such ordinals are known as <a href="large_countable_ordinal" title="wikilink">large countable ordinals</a>.</p>

<p>The operations of addition, multiplication and exponentiation are all examples of <a href="primitive_recursive_ordinal_function" title="wikilink">primitive recursive ordinal functions</a>, and more general primitive recursive ordinal functions can be used to describe larger ordinals.</p>
<h2 id="natural-operations">Natural operations</h2>

<p>The <strong>natural sum</strong> and <strong>natural product</strong> operations on ordinals were defined in 1906 by <a href="Gerhard_Hessenberg" title="wikilink">Gerhard Hessenberg</a>, and are sometimes called the <strong>Hessenberg sum</strong> (or product) . These are the same as the addition and multiplication (restricted to ordinals) of John Conway's <a href="Field_(mathematics)" title="wikilink">field</a> of <a href="surreal_numbers" title="wikilink">surreal numbers</a>. They have the advantage that they are associative and commutative, and natural product distributes over natural sum. The cost of making these operations commutative is that they lose the continuity in the right argument which is a property of the ordinary sum and product. The natural sum of α and β is sometimes denoted by α # β, and the natural product by a sort of doubled × sign: α ⨳ β. (Other common notation is α ⊕ β and α ⊗ β). To define the natural sum of two ordinals, consider once again the disjoint union 

<math display="inline" id="Ordinal_arithmetic:57">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>∪</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>S</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\cup T
  </annotation>
 </semantics>
</math>

 of two well-ordered sets having these order types. Start by putting a partial order on this disjoint union by taking the orders on <em>S</em> and <em>T</em> separately but imposing no relation between <em>S</em> and <em>T</em>. Now consider the order types of <em>all</em> well-orders on 

<math display="inline" id="Ordinal_arithmetic:58">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>∪</mo>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>S</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\cup T
  </annotation>
 </semantics>
</math>

 which extend this partial order: the least upper bound of all these ordinals (which is, actually, not merely a least upper bound but actually a greatest element) is the natural sum.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Alternatively, we can define the natural sum of <em>α</em> and <em>β</em> inductively (by simultaneous induction on <em>α</em> and <em>β</em>) as the smallest ordinal greater than the natural sum of <em>α</em> and <em>γ</em> for all <em>γ</em> 1 &gt; … &gt; γ<sub>n</sub> and two sequences (<em>k</em><sub>1</sub>, …, <em>k</em><sub>n</sub>) and (<em>j</em><sub>1</sub>, …, <em>j</em><sub>n</sub>) of natural numbers (including zero, but satisfying <em>k</em><sub><em>i</em></sub> + <em>j</em><sub><em>i</em></sub> &gt; 0 for all <em>i</em>) such that</p>

<p>

<math display="block" id="Ordinal_arithmetic:59">
 <semantics>
  <mrow>
   <mi>α</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>ω</mi>
      <msub>
       <mi>γ</mi>
       <mn>1</mn>
      </msub>
     </msup>
     <mo>⋅</mo>
     <msub>
      <mi>k</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <mrow>
     <msup>
      <mi>ω</mi>
      <msub>
       <mi>γ</mi>
       <mi>n</mi>
      </msub>
     </msup>
     <mo>⋅</mo>
     <msub>
      <mi>k</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>α</ci>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ω</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ω</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha=\omega^{\gamma_{1}}\cdot k_{1}+\cdots+\omega^{\gamma_{n}}\cdot k_{n}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Ordinal_arithmetic:60">
 <semantics>
  <mrow>
   <mi>β</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msup>
      <mi>ω</mi>
      <msub>
       <mi>γ</mi>
       <mn>1</mn>
      </msub>
     </msup>
     <mo>⋅</mo>
     <msub>
      <mi>j</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <mrow>
     <msup>
      <mi>ω</mi>
      <msub>
       <mi>γ</mi>
       <mi>n</mi>
      </msub>
     </msup>
     <mo>⋅</mo>
     <msub>
      <mi>j</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>β</ci>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ω</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ω</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>j</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta=\omega^{\gamma_{1}}\cdot j_{1}+\cdots+\omega^{\gamma_{n}}\cdot j_{n}
  </annotation>
 </semantics>
</math>

 and defines</p>

<p>

<math display="block" id="Ordinal_arithmetic:61">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>α</mi>
     <mi mathvariant="normal">#</mi>
     <mi>β</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>ω</mi>
       <msub>
        <mi>γ</mi>
        <mn>1</mn>
       </msub>
      </msup>
      <mo>⋅</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>k</mi>
         <mn>1</mn>
        </msub>
        <mo>+</mo>
        <msub>
         <mi>j</mi>
         <mn>1</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mi mathvariant="normal">⋯</mi>
     <mo>+</mo>
     <mrow>
      <msup>
       <mi>ω</mi>
       <msub>
        <mi>γ</mi>
        <mi>n</mi>
       </msub>
      </msup>
      <mo>⋅</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>k</mi>
         <mi>n</mi>
        </msub>
        <mo>+</mo>
        <msub>
         <mi>j</mi>
         <mi>n</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>α</ci>
     <ci>normal-#</ci>
     <ci>β</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ω</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>j</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>ω</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>k</ci>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>j</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha\#\beta=\omega^{\gamma_{1}}\cdot(k_{1}+j_{1})+\cdots+\omega^{\gamma_{n}}%
\cdot(k_{n}+j_{n}).
  </annotation>
 </semantics>
</math>

</p>

<p>Under natural addition, the ordinals can be identified with the elements of the free abelian group with basis the gamma numbers ω<sup>α</sup> that have non-negative integer coefficients. Under natural addition and multiplication, the ordinals can be identified with the elements of the (commutative) polynomial ring generated by the delta numbers ω<sup>ω<sup>α</sup></sup> that have non-negative integer coefficients. The ordinals do not have unique factorization into primes under the natural product. While the full polynomial ring does have unique factorization, the subset of polynomials with non-negative coefficients does not: for example, if <em>x</em> is any delta number, then</p>

<p>

<math display="block" id="Ordinal_arithmetic:62">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>x</mi>
     <mn>5</mn>
    </msup>
    <mo>+</mo>
    <msup>
     <mi>x</mi>
     <mn>4</mn>
    </msup>
    <mo>+</mo>
    <msup>
     <mi>x</mi>
     <mn>3</mn>
    </msup>
    <mo>+</mo>
    <msup>
     <mi>x</mi>
     <mn>2</mn>
    </msup>
    <mo>+</mo>
    <mi>x</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>x</mi>
       <mn>4</mn>
      </msup>
      <mo>+</mo>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>x</mi>
       <mn>2</mn>
      </msup>
      <mo>+</mo>
      <mi>x</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>x</mi>
       <mn>3</mn>
      </msup>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">5</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">4</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">3</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">4</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <cn type="integer">3</cn>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x^{5}+x^{4}+x^{3}+x^{2}+x+1=(x+1)(x^{4}+x^{2}+1)=(x^{2}+x+1)(x^{3}+1)
  </annotation>
 </semantics>
</math>

 has two incompatible expressions as a natural product of polynomials with non-negative coefficients that cannot be decomposed further.</p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>Jech, Thomas, 2003. <em>Set Theory: The Third Millennium Edition, Revised and Expanded</em>. Springer. ISBN 3-540-44085-2.</li>
<li>Kunen, Kenneth, 1980. <em>Set Theory: An Introduction to Independence Proofs</em>. Elsevier. ISBN 0-444-86839-9.</li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.volny.cz/behounek/logic/papers/ordcalc/index.html">Ordinal calculator</a> for download (MS-DOS executable or Borland C++ source)</li>
</ul>

<p>"</p>

<p><a href="Category:Set_theory" title="wikilink">Category:Set theory</a> <a href="Category:Ordinal_numbers" title="wikilink">Category:Ordinal numbers</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Philip W. Carruth, Arithmetic of ordinals with applications to the theory of ordered Abelian groups, Bull. Amer. Math. Soc. 48 (1942), 262–271. See Theorem 1. Available <a href="http://www.ams.org/journals/bull/1942-48-04/S0002-9904-1942-07649-X/S0002-9904-1942-07649-X.pdf">here</a><a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
