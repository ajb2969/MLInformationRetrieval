<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="505">Element distinctness problem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Element distinctness problem</h1>
<hr/>

<p>In <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>, the <strong>element distinctness problem</strong> or <strong>element uniqueness problem</strong> is the problem of determining whether all the elements of a list are distinct.</p>

<p>It is a well studied problem in many different models of computation. The problem may be solved by <a class="uri" href="sorting" title="wikilink">sorting</a> the list and then checking if there are any consecutive equal elements; it may also be solved in linear expected time by a <a href="randomized_algorithm" title="wikilink">randomized algorithm</a> that inserts each item into a <a href="hash_table" title="wikilink">hash table</a> and compares only those elements that are placed in the same hash table cell.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>It is known that, for lists of numbers, the problem's <a href="time_complexity" title="wikilink">time complexity</a> is <a href="Big_O_notation" title="wikilink">Θ</a>(<em>n</em> log <em>n</em>), i.e., both the upper and lower bounds on its time complexity are of order of the <a href="linearithmic_function" title="wikilink">linearithmic function</a> in the <a href="algebraic_decision_tree" title="wikilink">algebraic decision tree</a> <a href="model_of_computation" title="wikilink">model of computation</a>,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> a model of computation in which the elements may not be used to index the computer's memory (as in the hash table solution) but may only be accessed by computing and comparing simple algebraic functions of their values. In other words, an <a href="asymptotically_optimal" title="wikilink">asymptotically optimal</a> algorithm of linearithmic time complexity is known for this model. The algebraic computation tree model basically means that the allowable algorithms are only the ones that can perform polynomial operations of bounded degree on the input data and comparisons of the results of these computations.</p>

<p>The same lower bound was later proved for the <a href="randomized_complexity" title="wikilink">randomized</a> <a href="algebraic_decision_tree" title="wikilink">algebraic decision tree</a> model.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>It is also known that <a href="quantum_algorithm" title="wikilink">quantum algorithms</a> can solve this problem faster in 

<math display="inline" id="Element_distinctness_problem:0">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo>(</mo>
    <msup>
     <mi>n</mi>
     <mrow>
      <mn>2</mn>
      <mo>/</mo>
      <mn>3</mn>
     </mrow>
    </msup>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <divide></divide>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta\left(n^{2/3}\right)
  </annotation>
 </semantics>
</math>

 queries. The optimal algorithm is by <a href="Andris_Ambainis" title="wikilink">Andris Ambainis</a>.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> <a href="Yaoyun_Shi" title="wikilink">Yaoyun Shi</a> first proved a tight lower bound when the size of the range is sufficiently large.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Ambainis<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> and Kutin<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> independently (and via different proofs) extended his work to obtain the lower bound for all functions.</p>

<p>Several lower bounds in computational complexity are proved by reducing the element distinctness problem to the problem in question, i.e., by demonstrating that the solution of the element uniqueness problem may be quickly found after solving the problem in question.</p>
<h2 id="restrictions">Restrictions</h2>

<p><a href="Decision_tree_model" title="wikilink">Decision tree models</a> are inapplicable for determining lower bounds for algorithmic problems for objects that have some <em>a priori</em> properties which can be exploited in construction of algorithms. For example, if it is known that the <em>n</em> objects are <a href="integer" title="wikilink">integers</a> in the range [1..<em>n</em>], then the element uniqueness problem may be solved in <a href="Big_O_notation" title="wikilink">O</a>(<em>n</em>) time by a modification of <a href="bucket_sort" title="wikilink">bucket sort</a>.</p>
<h2 id="generalization-finding-repeated-elements">Generalization: Finding repeated elements</h2>

<p>Elements that occur more than <em>n</em>/<em>k</em> times in a multiset of size n may be found in time O(<em>n</em> log <em>k</em>). The element distinctness problem is a special case of <em>k</em>=<em>n</em>. This algorithm is optimal under the <a href="decision_tree_model" title="wikilink">decision tree model</a> of computation.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>The algorithm is a generalization of the one for a special case of <em>k</em>=2, which had a rather convoluted history of publication.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>The above algorithms rely only on the test of identity of the elements. If sorting is allowed, previously known <a href="order_statistics" title="wikilink">order statistics</a> finding algorithms may be exploited. For example, for <em>k</em>=2, a <a class="uri" href="median" title="wikilink">median</a> may be found first in <a href="linear_time" title="wikilink">linear time</a>, and then it may be easily tested whether there are more than <em>n</em>/2 median elements. However the above algorithms require fewer comparisons than the order statistics algorithms.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Collision_problem" title="wikilink">Collision problem</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Articles_with_inconsistent_citation_formats" title="wikilink">Category:Articles with inconsistent citation formats</a> <a href="Category:Polynomial-time_problems" title="wikilink">Category:Polynomial-time problems</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">.<a href="#fnref1">↩</a></li>
<li id="fn2">.<a href="#fnref2">↩</a></li>
<li id="fn3">.<a href="#fnref3">↩</a></li>
<li id="fn4">.<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9">.<a href="#fnref9">↩</a></li>
<li id="fn10">.<a href="#fnref10">↩</a></li>
<li id="fn11"></li>
</ol>
</section>
</body>
</html>
