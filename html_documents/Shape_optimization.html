<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="204">Shape optimization</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Shape optimization</h1>
<hr/>

<p><strong>Shape optimization</strong> is part of the field of <a href="optimal_control" title="wikilink">optimal control</a> theory. The typical problem is to find the <a class="uri" href="shape" title="wikilink">shape</a> which is optimal in that it minimizes a certain cost <a href="functional_(mathematics)" title="wikilink">functional</a> while satisfying given <a href="constraint_(mathematics)" title="wikilink">constraints</a>. In many cases, the functional being solved depends on the solution of a given partial differential equation defined on the variable domain.</p>

<p><a href="Topology_optimization" title="wikilink">Topology optimization</a> is, in addition, concerned with the number of connected components/boundaries belonging to the domain. Such methods are needed since typically shape optimization methods work in a subset of allowable shapes which have fixed topological properties, such as having a fixed number of holes in them. Topological optimization techniques can then help work around the limitations of pure shape optimization.</p>
<h2 id="definition">Definition</h2>

<p><a href="Mathematics" title="wikilink">Mathematically</a>, shape optimization can be posed as the problem of finding a <a href="bounded_set" title="wikilink">bounded set</a> 

<math display="inline" id="Shape_optimization:0">
 <semantics>
  <mi mathvariant="normal">Œ©</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Œ©</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

, <a href="maxima_and_minima" title="wikilink">minimizing</a> a <a href="functional_(mathematics)" title="wikilink">functional</a></p>

<p>

<math display="block" id="Shape_optimization:1">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">‚Ñ±</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Œ©</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>‚Ñ±</ci>
    <ci>normal-Œ©</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}(\Omega)
  </annotation>
 </semantics>
</math>

, possibly subject to a <a href="constraint_(mathematics)" title="wikilink">constraint</a> of the form</p>

<p>

<math display="block" id="Shape_optimization:2">
 <semantics>
  <mrow>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ùí¢</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">Œ©</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ùí¢</ci>
     <ci>normal-Œ©</ci>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{G}(\Omega)=0.
  </annotation>
 </semantics>
</math>

 Usually we are interested in sets 

<math display="inline" id="Shape_optimization:3">
 <semantics>
  <mi mathvariant="normal">Œ©</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Œ©</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega
  </annotation>
 </semantics>
</math>

 which are <a href="Lipschitz_continuity" title="wikilink">Lipschitz</a> or C<sup>1</sup> <a href="Boundary_(topology)" title="wikilink">boundary</a> and consist of finitely many <a href="connected_component_(analysis)" title="wikilink">components</a>, which is a way of saying that we would like to find a rather pleasing shape as a solution, not some jumble of rough bits and pieces. Sometimes additional constraints need to be imposed to that end to ensure well-posedness of the problem and uniqueness of the solution.</p>

<p>Shape optimization is an <a href="infinite-dimensional_optimization" title="wikilink">infinite-dimensional optimization</a> problem. Furthermore, the space of allowable shapes over which the optimization is performed does not admit a <a href="vector_space" title="wikilink">vector space</a> structure, making application of traditional optimization methods more difficult.</p>
<h2 id="examples">Examples</h2>
<h2 id="techniques">Techniques</h2>

<p>Shape optimization problems are usually solved <a href="numerical_analysis" title="wikilink">numerically</a>, by using <a href="iterative_method" title="wikilink">iterative methods</a>. That is, one starts with an initial guess for a shape, and then gradually evolves it, until it morphs into the optimal shape.</p>
<h3 id="keeping-track-of-the-shape">Keeping track of the shape</h3>

<p>  To solve a shape optimization problem, one needs to find a way to represent a shape in the <a href="Computer_storage" title="wikilink">computer memory</a>, and follow its evolution. Several approaches are usually used.</p>

<p>One approach is to follow the boundary of the shape. For that, one can sample the shape boundary in a relatively dense and uniform manner, that is, to consider enough points to get a sufficiently accurate outline of the shape. Then, one can evolve the shape by gradually moving the boundary points. This is called the <em>Lagrangian approach</em>.</p>

<p>Another approach is to consider a <a href="function_(mathematics)" title="wikilink">function</a> defined on a rectangular box around the shape, which is positive inside of the shape, zero on the boundary of the shape, and negative outside of the shape. One can then evolve this function instead of the shape itself. One can consider a rectangular grid on the box and sample the function at the grid points. As the shape evolves, the grid points do not change; only the function values at the grid points change. This approach, of using a fixed grid, is called the <em>Eulerian approach</em>. The idea of using a function to represent the shape is at the basis of the <a href="level_set_method" title="wikilink">level set method</a>.</p>

<p>A third approach is to think of the shape evolution as of a flow problem. That is, one can imagine that the shape is made of a plastic material gradually deforming such that any point inside or on the boundary of the shape can be always traced back to a point of the original shape in a one-to-one fashion. Mathematically, if 

<math display="inline" id="Shape_optimization:4">
 <semantics>
  <msub>
   <mi mathvariant="normal">Œ©</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Œ©</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega_{0}
  </annotation>
 </semantics>
</math>

 is the initial shape, and 

<math display="inline" id="Shape_optimization:5">
 <semantics>
  <msub>
   <mi mathvariant="normal">Œ©</mi>
   <mi>t</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Œ©</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega_{t}
  </annotation>
 </semantics>
</math>

 is the shape at time <em>t</em>, one considers the <a href="diffeomorphism" title="wikilink">diffeomorphisms</a></p>

<p>

<math display="block" id="Shape_optimization:6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>f</mi>
     <mi>t</mi>
    </msub>
    <mo>:</mo>
    <mrow>
     <mrow>
      <msub>
       <mi mathvariant="normal">Œ©</mi>
       <mn>0</mn>
      </msub>
      <mo>‚Üí</mo>
      <msub>
       <mi mathvariant="normal">Œ©</mi>
       <mi>t</mi>
      </msub>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mrow>
       <mtext>for</mtext>
       <mn>0</mn>
      </mrow>
      <mo>‚â§</mo>
      <mi>t</mi>
      <mo>‚â§</mo>
      <msub>
       <mi>t</mi>
       <mn>0</mn>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <ci>normal-‚Üí</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Œ©</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Œ©</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <and></and>
      <apply>
       <leq></leq>
       <apply>
        <times></times>
        <mtext>for</mtext>
        <cn type="integer">0</cn>
       </apply>
       <ci>t</ci>
      </apply>
      <apply>
       <leq></leq>
       <share href="#.cmml">
       </share>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{t}:\Omega_{0}\to\Omega_{t},\mbox{ for }0\leq t\leq t_{0}.
  </annotation>
 </semantics>
</math>

</p>

<p>The idea is again that shapes are difficult entities to be dealt with directly, so manipulate them by means of a function.</p>
<h3 id="iterative-methods-using-shape-gradients">Iterative methods using shape gradients</h3>

<p>Consider a smooth velocity field 

<math display="inline" id="Shape_optimization:7">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 and the family of transformations 

<math display="inline" id="Shape_optimization:8">
 <semantics>
  <msub>
   <mi>T</mi>
   <mi>s</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{s}
  </annotation>
 </semantics>
</math>

 of the initial domain 

<math display="inline" id="Shape_optimization:9">
 <semantics>
  <msub>
   <mi mathvariant="normal">Œ©</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Œ©</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega_{0}
  </annotation>
 </semantics>
</math>

 under the velocity field 

<math display="inline" id="Shape_optimization:10">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

:</p>

<p>

<math display="block" id="Shape_optimization:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo>‚àà</mo>
    <msub>
     <mi mathvariant="normal">Œ©</mi>
     <mn>0</mn>
    </msub>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mrow>
     <mrow>
      <msup>
       <mi>x</mi>
       <mo>‚Ä≤</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>V</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>s</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mrow>
      <mrow>
       <msub>
        <mi>T</mi>
        <mi>s</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>x</mi>
         <mn>0</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <mrow>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo rspace="12.5pt">,</mo>
     <mrow>
      <mi>s</mi>
      <mo>‚â•</mo>
      <mn>0</mn>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <in></in>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Œ©</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>x</ci>
        <ci>normal-‚Ä≤</ci>
       </apply>
       <ci>s</ci>
      </apply>
      <apply>
       <times></times>
       <ci>V</ci>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>s</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>T</ci>
         <ci>s</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>x</ci>
        <ci>s</ci>
       </apply>
      </apply>
      <apply>
       <geq></geq>
       <ci>s</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(0)=x_{0}\in\Omega_{0},\quad x^{\prime}(s)=V(x(s)),\quad T_{s}(x_{0})=x(s),%
\quad s\geq 0
  </annotation>
 </semantics>
</math>

,</p>

<p>and denote</p>

<p>

<math display="block" id="Shape_optimization:12">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Œ©</mi>
     <mn>0</mn>
    </msub>
    <mo>‚Ü¶</mo>
    <mrow>
     <msub>
      <mi>T</mi>
      <mi>s</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi mathvariant="normal">Œ©</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi mathvariant="normal">Œ©</mi>
     <mi>s</mi>
    </msub>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Œ©</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <ci>s</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Œ©</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Œ©</ci>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega_{0}\mapsto T_{s}(\Omega_{0})=\Omega_{s}.
  </annotation>
 </semantics>
</math>

</p>

<p>Then the G√¢teaux or shape derivative of 

<math display="inline" id="Shape_optimization:13">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">‚Ñ±</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Œ©</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>‚Ñ±</ci>
    <ci>normal-Œ©</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}(\Omega)
  </annotation>
 </semantics>
</math>

 at 

<math display="inline" id="Shape_optimization:14">
 <semantics>
  <msub>
   <mi mathvariant="normal">Œ©</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>normal-Œ©</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega_{0}
  </annotation>
 </semantics>
</math>

 with respect to the shape is the limit of</p>

<p>

<math display="block" id="Shape_optimization:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mi class="ltx_font_mathcaligraphic">‚Ñ±</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi mathvariant="normal">Œ©</mi>
      <mn>0</mn>
     </msub>
     <mo>;</mo>
     <mi>V</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo movablelimits="false">lim</mo>
     <mrow>
      <mi>s</mi>
      <mo>‚Üí</mo>
      <mn>0</mn>
     </mrow>
    </munder>
    <mfrac>
     <mrow>
      <mrow>
       <mi class="ltx_font_mathcaligraphic">‚Ñ±</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi mathvariant="normal">Œ©</mi>
         <mi>s</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi class="ltx_font_mathcaligraphic">‚Ñ±</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi mathvariant="normal">Œ©</mi>
         <mn>0</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mi>s</mi>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>‚Ñ±</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Œ©</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>V</ci>
     </list>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <limit></limit>
      <apply>
       <ci>normal-‚Üí</ci>
       <ci>s</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>‚Ñ±</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-Œ©</ci>
         <ci>s</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>‚Ñ±</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-Œ©</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
      </apply>
      <ci>s</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\mathcal{F}(\Omega_{0};V)=\lim_{s\to 0}\frac{\mathcal{F}(\Omega_{s})-\mathcal%
{F}(\Omega_{0})}{s}
  </annotation>
 </semantics>
</math>

</p>

<p>if this limit exists. If in addition the derivative is linear with respect to 

<math display="inline" id="Shape_optimization:16">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

, there is a unique element of 

<math display="inline" id="Shape_optimization:17">
 <semantics>
  <mrow>
   <mrow>
    <mo>‚àá</mo>
    <mi class="ltx_font_mathcaligraphic">‚Ñ±</mi>
   </mrow>
   <mo>‚àà</mo>
   <mrow>
    <msup>
     <mi>L</mi>
     <mn>2</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>‚àÇ</mo>
      <msub>
       <mi mathvariant="normal">Œ©</mi>
       <mn>0</mn>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <ci>normal-‚àá</ci>
     <ci>‚Ñ±</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Œ©</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla\mathcal{F}\in L^{2}(\partial\Omega_{0})
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="block" id="Shape_optimization:18">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mi class="ltx_font_mathcaligraphic">‚Ñ±</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi mathvariant="normal">Œ©</mi>
      <mn>0</mn>
     </msub>
     <mo>;</mo>
     <mi>V</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mrow>
     <mo stretchy="false">‚ü®</mo>
     <mrow>
      <mo>‚àá</mo>
      <mi class="ltx_font_mathcaligraphic">‚Ñ±</mi>
     </mrow>
     <mo>,</mo>
     <mi>V</mi>
     <mo stretchy="false">‚ü©</mo>
    </mrow>
    <mrow>
     <mo>‚àÇ</mo>
     <msub>
      <mi mathvariant="normal">Œ©</mi>
      <mn>0</mn>
     </msub>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>‚Ñ±</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Œ©</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>V</ci>
     </list>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <list>
      <apply>
       <ci>normal-‚àá</ci>
       <ci>‚Ñ±</ci>
      </apply>
      <ci>V</ci>
     </list>
     <apply>
      <partialdiff></partialdiff>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Œ©</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\mathcal{F}(\Omega_{0};V)=\langle\nabla\mathcal{F},V\rangle_{\partial\Omega_{%
0}}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Shape_optimization:19">
 <semantics>
  <mrow>
   <mo>‚àá</mo>
   <mi class="ltx_font_mathcaligraphic">‚Ñ±</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-‚àá</ci>
    <ci>‚Ñ±</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nabla\mathcal{F}
  </annotation>
 </semantics>
</math>

 is called the shape gradient. This gives a natural idea of <a href="gradient_descent" title="wikilink">gradient descent</a>, where the boundary 

<math display="inline" id="Shape_optimization:20">
 <semantics>
  <mrow>
   <mo>‚àÇ</mo>
   <mi mathvariant="normal">Œ©</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <partialdiff></partialdiff>
    <ci>normal-Œ©</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \partial\Omega
  </annotation>
 </semantics>
</math>

 is evolved in the direction of negative shape gradient in order to reduce the value of the cost functional. Higher order derivatives can be similarly defined, leading to Newtonlike methods.</p>

<p>Typically, gradient descent is preferred, even if requires a large number of iterations, because, it can be hard to compute the second-order derivative (that is, the <a href="Hessian_matrix" title="wikilink">Hessian</a>) of the objective functional 

<math display="inline" id="Shape_optimization:21">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">‚Ñ±</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>‚Ñ±</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

.</p>

<p>If the shape optimization problem has constraints, that is, the functional 

<math display="inline" id="Shape_optimization:22">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùí¢</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùí¢</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{G}
  </annotation>
 </semantics>
</math>

 is present, one has to find ways to convert the constrained problem into an unconstrained one. Sometimes ideas based on <a href="Lagrange_multipliers" title="wikilink">Lagrange multipliers</a> can work.</p>
<h3 id="geometry-parametrization">Geometry parametrization</h3>

<p>Shape optimization can be faced using standard optimization methods if a parametrization of the geometry is defined. Such parametrization is very important in CAE field where goal functions are usually complex functions evaluated using numerical models (CFD, FEA,...). A convenient approach, suitable for a wide class of problems, consists in the parametrization of the CAD model coupled with a full automation of all the process required for function evaluation (meshing, solving and result processing). <a href="Mesh_morphing" title="wikilink">Mesh morphing</a> is a valid choice for complex problems. In this case the parametrization is defined after the meshing stage acting directly on the numerical model used for calculation that is changed using mesh updating methods. There are several algorithms available for mesh morphing (<a href="deforming_volume" title="wikilink">deforming volumes</a>, <a href="pseudosolid" title="wikilink">pseudosolids</a>, <a href="radial_basis_function" title="wikilink">radial basis functions</a>). The selection of the parametrization approach depends mainly on the size of the problem: the CAD approach is preferred for small-to-medium sized models whilst the mesh morphing approach is the best (and sometimes the only feasible one) for large and very large models.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Topological_derivative" title="wikilink">Topological derivative</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Allaire, G. (2002) <em>Shape optimization by the homogenization method</em>. Applied Mathematical Sciences 146, Springer Verlag. ISBN 0-387-95298-5</li>
<li>Ashok D. Belegundu, Tirupathi R. Chandrupatla. (2003) <em>Optimization Concepts and applications in Engineering</em> Prentice Hall. ISBN 0-13-031279-7.</li>
<li>Bends√∏e M. P.; Sigmund O. (2003) <em>Topology Optimization: Theory, Methods and Applications</em>. Springer. ISBN 3-540-42992-1.</li>
<li>Burger, M.; Osher, S.L. (2005) <em>A Survey on Level Set Methods for Inverse Problems and Optimal Design</em>. European Journal of Applied Mathematics, vol.16 pp.¬†263‚Äì301.</li>
<li>Delfour, M.C.; Zolesio, J.-P. (2001) <em>Shapes and Geometries - Analysis, Differential Calculus, and Optimization</em>. SIAM. ISBN 0-89871-489-3.</li>
<li>Haslinger, J.; M√§kinen, R. (2003) <em>Introduction to Shape Optimization: Theory, Approximation and Computation</em>. Society for Industrial and Applied Mathematic. ISBN 0-89871-536-9.</li>
<li>Laporte, E.; Le Tallec, P. (2003) <em>Numerical Methods in Sensitivity Analysis and Shape Optimization</em>. Birkh√§user. ISBN 0-8176-4322-2.</li>
<li>Mohammadi, B.; Pironneau, O. (2001) <em>Applied Shape Optimization for Fluids</em>. Oxford University Press. ISBN 0-19-850743-7.</li>
<li>Simon J. (1980) <em>Differentiation with respect to the domain in boundary value problems</em>. Numer. Fuct. Anal. and Optimiz., 2(7&amp;8), 649-687 (1980).</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cmap.polytechnique.fr/~optopo">Optopo Group</a> ‚Äî Simulations and bibliography of the optopo group at Ecole Polytechnique (France). Homogenization method and level set method.</li>
</ul>

<p>"</p>

<p><a href="Category:Mathematical_optimization" title="wikilink">Category:Mathematical optimization</a></p>
</body>
</html>
