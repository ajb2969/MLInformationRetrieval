<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1824">Algorithmic inference</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Algorithmic inference</h1>
<hr/>

<p><strong>Algorithmic inference</strong> gathers new developments in the <a href="statistical_inference" title="wikilink">statistical inference</a> methods made feasible by the powerful computing devices widely available to any data analyst. Cornerstones in this field are <a href="computational_learning_theory" title="wikilink">computational learning theory</a>, <a href="granular_computing" title="wikilink">granular computing</a>, <a class="uri" href="bioinformatics" title="wikilink">bioinformatics</a>, and, long ago, structural probability . The main focus is on the algorithms which compute statistics rooting the study of a random phenomenon, along with the amount of data they must feed on to produce reliable results. This shifts the interest of mathematicians from the study of the <a href="probability_distribution" title="wikilink">distribution laws</a> to the functional properties of the <a class="uri" href="statistics" title="wikilink">statistics</a>, and the interest of computer scientists from the algorithms for processing data to the <a class="uri" href="information" title="wikilink">information</a> they process.</p>
<h2 id="the-fisher-parametric-inference-problem">The Fisher parametric inference problem</h2>

<p>Concerning the identification of the parameters of a distribution law, the mature reader may recall lengthy disputes in the mid 20th century about the interpretation of their variability in terms of <a href="fiducial_distribution" title="wikilink">fiducial distribution</a> , structural probabilities , priors/posteriors , and so on. From an <a href="epistemologic" title="wikilink">epistemology</a> viewpoint, this entailed a companion dispute as to the nature of <a class="uri" href="probability" title="wikilink">probability</a>: is it a physical feature of phenomena to be described through <a href="random_variables" title="wikilink">random variables</a> or a way of synthesizing data about a phenomenon? Opting for the latter, Fisher defines a <em>fiducial distribution</em> law of parameters of a given random variable that he deduces from a sample of its specifications. With this law he computes, for instance “the probability that μ (mean of a <a href="Normal_distribution" title="wikilink">Gaussian variable</a> – our note) is less than any assigned value, or the probability that it lies between any assigned values, or, in short, its probability distribution, in the light of the sample observed”.</p>
<h2 id="the-classic-solution">The classic solution</h2>

<p>Fisher fought hard to defend the difference and superiority of his notion of parameter distribution in comparison to analogous notions, such as Bayes' <a href="posterior_distribution" title="wikilink">posterior distribution</a>, Fraser's constructive probability and Neyman's <a href="confidence_intervals" title="wikilink">confidence intervals</a>. For half a century, Neyman's confidence intervals won out for all practical purposes, crediting the phenomenological nature of probability. With this perspective, when you deal with a Gaussian variable, its mean μ is fixed by the physical features of the phenomenon you are observing, where the observations are random operators, hence the observed values are specifications of a <a href="random_sample" title="wikilink">random sample</a>. Because of their randomness, you may compute from the sample specific intervals containing the fixed μ with a given probability that you denote <em>confidence</em>.</p>
<h3 id="example">Example</h3>

<p>Let <em>X</em> be a Gaussian variable<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> with parameters 

<math display="inline" id="Algorithmic_inference:0">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Algorithmic_inference:1">
 <semantics>
  <msup>
   <mi>σ</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>σ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Algorithmic_inference:2">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>X</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>X</mi>
    <mi>m</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>m</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{X_{1},\ldots,X_{m}\}
  </annotation>
 </semantics>
</math>

 a sample drawn from it. Working with statistics</p>

<p>

<math display="block" id="Algorithmic_inference:3">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mi>μ</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>m</mi>
    </munderover>
    <msub>
     <mi>X</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>μ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{\mu}=\sum_{i=1}^{m}X_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Algorithmic_inference:4">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>S</mi>
     <msup>
      <mi>σ</mi>
      <mn>2</mn>
     </msup>
    </msub>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>m</mi>
     </munderover>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>X</mi>
         <mi>i</mi>
        </msub>
        <mo>-</mo>
        <mover accent="true">
         <mi>X</mi>
         <mo>¯</mo>
        </mover>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mtext>where</mtext>
     <mover accent="true">
      <mi>X</mi>
      <mo>¯</mo>
     </mover>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <msub>
      <mi>S</mi>
      <mi>μ</mi>
     </msub>
     <mi>m</mi>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>σ</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>m</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <ci>normal-¯</ci>
         <ci>X</ci>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <mtext>where</mtext>
      <apply>
       <ci>normal-¯</ci>
       <ci>X</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <ci>μ</ci>
      </apply>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{\sigma^{2}}=\sum_{i=1}^{m}(X_{i}-\overline{X})^{2},\text{ where }\overline{%
X}=\frac{S_{\mu}}{m}
  </annotation>
 </semantics>
</math>

</p>

<p>is the sample mean, we recognize that</p>

<p>

<math display="block" id="Algorithmic_inference:5">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mrow>
      <msub>
       <mi>S</mi>
       <mi>μ</mi>
      </msub>
      <mo>-</mo>
      <mrow>
       <mi>m</mi>
       <mi>μ</mi>
      </mrow>
     </mrow>
     <msqrt>
      <msub>
       <mi>S</mi>
       <msup>
        <mi>σ</mi>
        <mn>2</mn>
       </msup>
      </msub>
     </msqrt>
    </mfrac>
    <msqrt>
     <mfrac>
      <mrow>
       <mi>m</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mi>m</mi>
     </mfrac>
    </msqrt>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mover accent="true">
      <mi>X</mi>
      <mo>¯</mo>
     </mover>
     <mo>-</mo>
     <mi>μ</mi>
    </mrow>
    <msqrt>
     <mrow>
      <msub>
       <mi>S</mi>
       <msup>
        <mi>σ</mi>
        <mn>2</mn>
       </msup>
      </msub>
      <mo>/</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>m</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>m</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msqrt>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>T</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>S</ci>
         <ci>μ</ci>
        </apply>
        <apply>
         <times></times>
         <ci>m</ci>
         <ci>μ</ci>
        </apply>
       </apply>
       <apply>
        <root></root>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>S</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>σ</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <root></root>
       <apply>
        <divide></divide>
        <apply>
         <minus></minus>
         <ci>m</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <ci>normal-¯</ci>
        <ci>X</ci>
       </apply>
       <ci>μ</ci>
      </apply>
      <apply>
       <root></root>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>S</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>σ</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <times></times>
         <ci>m</ci>
         <apply>
          <minus></minus>
          <ci>m</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T=\frac{S_{\mu}-m\mu}{\sqrt{S_{\sigma^{2}}}}\sqrt{\frac{m-1}{m}}=\frac{%
\overline{X}-\mu}{\sqrt{S_{\sigma^{2}}/(m(m-1))}}
  </annotation>
 </semantics>
</math>

</p>

<p>follows a <a href="Student's_t_distribution" title="wikilink">Student's t distribution</a>  with parameter (degrees of freedom) <em>m</em> − 1, so that</p>

<p>

<math display="block" id="Algorithmic_inference:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>f</mi>
      <mi>T</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mi mathvariant="normal">Γ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>m</mi>
         <mo>/</mo>
         <mn>2</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <mi mathvariant="normal">Γ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>m</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mo>/</mo>
         <mn>2</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mfrac>
     <mfrac>
      <mn>1</mn>
      <msqrt>
       <mrow>
        <mi>π</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>m</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </msqrt>
     </mfrac>
     <msup>
      <mrow>
       <mo>(</mo>
       <mrow>
        <mn>1</mn>
        <mo>+</mo>
        <mfrac>
         <msup>
          <mi>t</mi>
          <mn>2</mn>
         </msup>
         <mrow>
          <mi>m</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
        </mfrac>
       </mrow>
       <mo>)</mo>
      </mrow>
      <mrow>
       <mi>m</mi>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>T</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>normal-Γ</ci>
       <apply>
        <divide></divide>
        <ci>m</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>normal-Γ</ci>
       <apply>
        <divide></divide>
        <apply>
         <minus></minus>
         <ci>m</ci>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <apply>
        <times></times>
        <ci>π</ci>
        <apply>
         <minus></minus>
         <ci>m</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <divide></divide>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>t</ci>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <minus></minus>
         <ci>m</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <ci>m</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{T}(t)=\frac{\Gamma(m/2)}{\Gamma((m-1)/2)}\frac{1}{\sqrt{\pi(m-1)}}\left(1+%
\frac{t^{2}}{m-1}\right)^{m/2}.
  </annotation>
 </semantics>
</math>

</p>

<p>Gauging <em>T</em> between two quantiles and inverting its expression as a function of 

<math display="inline" id="Algorithmic_inference:7">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 you obtain confidence intervals for 

<math display="inline" id="Algorithmic_inference:8">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

.</p>

<p>With the sample specification:</p>

<p>

<math display="block" id="Algorithmic_inference:9">
 <semantics>
  <mrow>
   <mi>𝐱</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>7.14</mn>
    <mo>,</mo>
    <mn>6.3</mn>
    <mo>,</mo>
    <mn>3.9</mn>
    <mo>,</mo>
    <mn>6.46</mn>
    <mo>,</mo>
    <mn>0.2</mn>
    <mo>,</mo>
    <mn>2.94</mn>
    <mo>,</mo>
    <mn>4.14</mn>
    <mo>,</mo>
    <mn>4.69</mn>
    <mo>,</mo>
    <mn>6.02</mn>
    <mo>,</mo>
    <mn>1.58</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐱</ci>
    <set>
     <cn type="float">7.14</cn>
     <cn type="float">6.3</cn>
     <cn type="float">3.9</cn>
     <cn type="float">6.46</cn>
     <cn type="float">0.2</cn>
     <cn type="float">2.94</cn>
     <cn type="float">4.14</cn>
     <cn type="float">4.69</cn>
     <cn type="float">6.02</cn>
     <cn type="float">1.58</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}=\{7.14,6.3,3.9,6.46,0.2,2.94,4.14,4.69,6.02,1.58\}
  </annotation>
 </semantics>
</math>

</p>

<p>having size <em>m</em> = 10, you compute the statistics 

<math display="inline" id="Algorithmic_inference:10">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>μ</mi>
   </msub>
   <mo>=</mo>
   <mn>43.37</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>μ</ci>
    </apply>
    <cn type="float">43.37</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{\mu}=43.37
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Algorithmic_inference:11">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <msup>
     <mi>σ</mi>
     <mn>2</mn>
    </msup>
   </msub>
   <mo>=</mo>
   <mn>46.07</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>σ</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <cn type="float">46.07</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{\sigma^{2}}=46.07
  </annotation>
 </semantics>
</math>

, and obtain a 0.90 confidence interval for 

<math display="inline" id="Algorithmic_inference:12">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 with extremes (3.03, 5.65). </p>
<h2 id="inferring-functions-with-the-help-of-a-computer">Inferring functions with the help of a computer</h2>

<p>From a modeling perspective the entire dispute looks like a chicken-egg dilemma: either fixed data by first and probability distribution of their properties as a consequence, or fixed properties by first and probability distribution of the observed data as a corollary. The classic solution has one benefit and one drawback. The former was appreciated particularly back when people still did computations with sheet and pencil. Per se, the task of computing a Neyman confidence interval for the fixed parameter θ is hard: you don’t know θ, but you look for disposing around it an interval with a possibly very low probability of failing. The analytical solution is allowed for a very limited number of theoretical cases. <em>Vice versa</em> a large variety of instances may be quickly solved in an <em>approximate way</em> via the <a href="central_limit_theorem" title="wikilink">central limit theorem</a> in terms of confidence interval around a Gaussian distribution – that's the benefit. The drawback is that the central limit theorem is applicable when the sample size is sufficiently large. Therefore it is less and less applicable with the sample involved in modern inference instances. The fault is not in the sample size on its own part. Rather, this size is not sufficiently large because of the <a class="uri" href="complexity" title="wikilink">complexity</a> of the inference problem.</p>

<p>With the availability of large computing facilities, scientists refocused from isolated parameters inference to complex functions inference, i.e. re sets of highly nested parameters identifying functions. In these cases we speak about <em>learning of functions</em> (in terms for instance of <a href="regression_analysis" title="wikilink">regression</a>, <a href="Neuro-fuzzy" title="wikilink">neuro-fuzzy system</a> or <a href="computational_learning_theory" title="wikilink">computational learning</a>) on the basis of highly informative samples. A first effect of having a complex structure linking data is the reduction of the number of sample <a href="Degrees_of_freedom_(statistics)" title="wikilink">degrees of freedom</a>, i.e. the burning of a part of sample points, so that the effective sample size to be considered in the central limit theorem is too small. Focusing on the sample size ensuring a limited learning error with a given <a href="confidence_level" title="wikilink">confidence level</a>, the consequence is that the lower bound on this size grows with <a href="complexity_index" title="wikilink">complexity indices</a> such as <a href="VC_dimension" title="wikilink">VC dimension</a> or <a href="Complexity_index#Detail" title="wikilink">detail of a class</a> to which the function we want to learn belongs.</p>
<h3 id="example-1">Example</h3>

<p>A sample of 1,000 independent bits is enough to ensure an absolute error of at most 0.081 on the estimation of the parameter <em>p</em> of the underlying Bernoulli variable with a confidence of at least 0.99. The same size cannot guarantee a threshold less than 0.088 with the same confidence 0.99 when the error is identified with the probability that a 20-year-old man living in New York does not fit the ranges of height, weight and waistline observed on 1,000 Big Apple inhabitants. The accuracy shortage occurs because both the VC dimension and the detail of the class of parallelepipeds, among which the one observed from the 1,000 inhabitants' ranges falls, are equal to 6. </p>
<h2 id="the-general-inversion-problem-solving-the-fisher-question">The general inversion problem solving the Fisher question</h2>

<p>With insufficiently large samples, the approach: <em>fixed sample – random properties</em> suggests inference procedures in three steps:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p>1.</p></td>
<td style="text-align: left;">
<p><strong>Sampling mechanism</strong>. It consists of a pair 

<math display="inline" id="Algorithmic_inference:13">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>Z</mi>
   <mo>,</mo>
   <msub>
    <mi>g</mi>
    <mi>𝜽</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>Z</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <ci>𝜽</ci>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Z,g_{\boldsymbol{\theta}})
  </annotation>
 </semantics>
</math>

, where the seed <em>Z</em> is a random variable without unknown parameters, while the explaining function 

<math display="inline" id="Algorithmic_inference:14">
 <semantics>
  <msub>
   <mi>g</mi>
   <mi>𝜽</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>g</ci>
    <ci>𝜽</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{\boldsymbol{\theta}}
  </annotation>
 </semantics>
</math>

 is a function mapping from samples of <em>Z</em> to samples of the random variable <em>X</em> we are interested in. The parameter vector 

<math display="inline" id="Algorithmic_inference:15">
 <semantics>
  <mi>𝜽</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝜽</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\theta}
  </annotation>
 </semantics>
</math>

 is a specification of the random parameter 

<math display="inline" id="Algorithmic_inference:16">
 <semantics>
  <mi>𝚯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\Theta}
  </annotation>
 </semantics>
</math>

. Its components are the parameters of the <em>X</em> distribution law. The Integral Transform Theorem ensures the existence of such a mechanism for each (scalar or vector) <em>X</em> when the seed coincides with the random variable <em>U</em> <a href="Uniform_distribution_(continuous)" title="wikilink">uniformly</a> distributed in 

<math display="inline" id="Algorithmic_inference:17">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="closed">
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [0,1]
  </annotation>
 </semantics>
</math>

.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">

<p>''Example. ''</p></td>
<td style="text-align: left;">
<p>For <em>X</em> following a <a href="Pareto_distribution" title="wikilink">Pareto distribution</a> with parameters <em>a</em> and <em>k</em>, i.e.</p>

<p>

<math display="block" id="Algorithmic_inference:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>F</mi>
      <mi>X</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <msup>
        <mfrac>
         <mi>k</mi>
         <mi>x</mi>
        </mfrac>
        <mi>a</mi>
       </msup>
      </mrow>
      <mo>)</mo>
     </mrow>
     <msub>
      <mi>I</mi>
      <mrow>
       <mo stretchy="false">[</mo>
       <mi>k</mi>
       <mo>,</mo>
       <mi mathvariant="normal">∞</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>X</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <divide></divide>
        <ci>k</ci>
        <ci>x</ci>
       </apply>
       <ci>a</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>I</ci>
      <interval closure="closed-open">
       <ci>k</ci>
       <infinity></infinity>
      </interval>
     </apply>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{X}(x)=\left(1-\frac{k}{x}^{a}\right)I_{[k,\infty)}(x),
  </annotation>
 </semantics>
</math>

 a sampling mechanism 

<math display="inline" id="Algorithmic_inference:19">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>U</mi>
   <mo>,</mo>
   <msub>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>U</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>g</ci>
     <interval closure="open">
      <ci>a</ci>
      <ci>k</ci>
     </interval>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (U,g_{(a,k)})
  </annotation>
 </semantics>
</math>

 for <em>X</em> with seed <em>U</em> reads:</p>

<p>

<math display="block" id="Algorithmic_inference:20">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo>,</mo>
       <mi>k</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>k</mi>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mi>u</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mfrac>
        <mn>1</mn>
        <mi>a</mi>
       </mfrac>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <interval closure="open">
       <ci>a</ci>
       <ci>k</ci>
      </interval>
     </apply>
     <ci>u</ci>
    </apply>
    <apply>
     <times></times>
     <ci>k</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>u</ci>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <ci>a</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{(a,k)}(u)=k(1-u)^{-\frac{1}{a}},
  </annotation>
 </semantics>
</math>

 or, equivalently, 

<math display="inline" id="Algorithmic_inference:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>g</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo>,</mo>
       <mi>k</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>k</mi>
     <msup>
      <mi>u</mi>
      <mrow>
       <mo>-</mo>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mi>a</mi>
       </mrow>
      </mrow>
     </msup>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <interval closure="open">
       <ci>a</ci>
       <ci>k</ci>
      </interval>
     </apply>
     <ci>u</ci>
    </apply>
    <apply>
     <times></times>
     <ci>k</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>u</ci>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <ci>a</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{(a,k)}(u)=ku^{-1/a}.
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr class="even">
<td style="text-align: left;">

<p>2.</p></td>
<td style="text-align: left;">
<p><strong>Master equations</strong>. The actual connection between the model and the observed data is tossed in terms of a set of relations between statistics on the data and unknown parameters that come as a corollary of the sampling mechanisms. We call these relations <em>master equations</em>. Pivoting around the statistic 

<math display="inline" id="Algorithmic_inference:22">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>m</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>g</mi>
       <mi>𝜽</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>z</mi>
        <mn>1</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>g</mi>
       <mi>𝜽</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>z</mi>
        <mi>m</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>s</ci>
     <apply>
      <times></times>
      <ci>h</ci>
      <vector>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>m</ci>
       </apply>
      </vector>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>h</ci>
      <vector>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <ci>𝜽</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>g</ci>
         <ci>𝜽</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <ci>m</ci>
        </apply>
       </apply>
      </vector>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=h(x_{1},\ldots,x_{m})=h(g_{\boldsymbol{\theta}}(z_{1}),\ldots,g_{\boldsymbol%
{\theta}}(z_{m}))
  </annotation>
 </semantics>
</math>

, the general form of a master equation is:</p>

<p>

<math display="block" id="Algorithmic_inference:23">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <mi>ρ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>𝜽</mi>
     <mo>;</mo>
     <msub>
      <mi>z</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>z</mi>
      <mi>m</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <apply>
     <times></times>
     <ci>ρ</ci>
     <list>
      <ci>𝜽</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <ci>m</ci>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=\rho(\boldsymbol{\theta};z_{1},\ldots,z_{m})
  </annotation>
 </semantics>
</math>

.</p>

<p>With these relations we may inspect the values of the parameters that could have generated a sample with the observed statistic from a particular setting of the seeds representing the seed of the sample. Hence, to the population of sample seeds corresponds a population of parameters. In order to ensure this population clean properties, it is enough to draw randomly the seed values and involve either <a href="sufficient_statistics" title="wikilink">sufficient statistics</a> or, simply, <a href="well-behaved_statistic" title="wikilink">well-behaved statistics</a> w.r.t. the parameters, in the master equations.</p>

<p>For example, the statistics 

<math display="inline" id="Algorithmic_inference:24">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>m</mi>
    </msubsup>
    <mrow>
     <mi>log</mi>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <log></log>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{1}=\sum_{i=1}^{m}\log x_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Algorithmic_inference:25">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mn>2</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>min</mi>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mrow>
       <mn>1</mn>
       <mo>,</mo>
       <mi mathvariant="normal">…</mi>
       <mo>,</mo>
       <mi>m</mi>
      </mrow>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">{</mo>
     <msub>
      <mi>x</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <list>
        <cn type="integer">1</cn>
        <ci>normal-…</ci>
        <ci>m</ci>
       </list>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{2}=\min_{i=1,\ldots,m}\{x_{i}\}
  </annotation>
 </semantics>
</math>

 prove to be sufficient for parameters <em>a</em> and <em>k</em> of a Pareto random variable <em>X</em>. Thanks to the (equivalent form of the) sampling mechanism 

<math display="inline" id="Algorithmic_inference:26">
 <semantics>
  <msub>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>g</ci>
    <interval closure="open">
     <ci>a</ci>
     <ci>k</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g_{(a,k)}
  </annotation>
 </semantics>
</math>

 we may read them as</p>

<p>

<math display="block" id="Algorithmic_inference:27">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mn>1</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>m</mi>
     <mrow>
      <mi>log</mi>
      <mi>k</mi>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mi>a</mi>
     </mrow>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>m</mi>
      </munderover>
      <mrow>
       <mi>log</mi>
       <msub>
        <mi>u</mi>
        <mi>i</mi>
       </msub>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>m</ci>
      <apply>
       <log></log>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>a</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>m</ci>
       </apply>
       <apply>
        <log></log>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{1}=m\log k+1/a\sum_{i=1}^{m}\log u_{i}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Algorithmic_inference:28">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>s</mi>
     <mn>2</mn>
    </msub>
    <mo>=</mo>
    <mrow>
     <munder>
      <mi>min</mi>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mrow>
        <mn>1</mn>
        <mo>,</mo>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <mi>m</mi>
       </mrow>
      </mrow>
     </munder>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mi>k</mi>
       <msubsup>
        <mi>u</mi>
        <mi>i</mi>
        <mrow>
         <mo>-</mo>
         <mfrac>
          <mn>1</mn>
          <mi>a</mi>
         </mfrac>
        </mrow>
       </msubsup>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <list>
        <cn type="integer">1</cn>
        <ci>normal-…</ci>
        <ci>m</ci>
       </list>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>k</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <ci>a</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{2}=\min_{i=1,\ldots,m}\{ku_{i}^{-\frac{1}{a}}\},
  </annotation>
 </semantics>
</math>

 respectively.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>3.</p></td>
<td style="text-align: left;">
<p><strong>Parameter population</strong>. Having fixed a set of master equations, you may map sample seeds into parameters either numerically through a <a href="bootstrapping_populations" title="wikilink">population bootstrap</a>, or analytically through a <a href="Twisting_properties#twisting_argument" title="wikilink">twisting argument</a>. Hence from a population of seeds you obtain a population of parameters.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>''Example. ''</p></td>
<td style="text-align: left;">
<p>From the above master equation we can draw a pair of parameters, 

<math display="inline" id="Algorithmic_inference:29">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>a</mi>
   <mo>,</mo>
   <mi>k</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>a</ci>
    <ci>k</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a,k)
  </annotation>
 </semantics>
</math>

, <em>compatible</em> with the observed sample by solving the following system of equations:</p>

<p>

<math display="block" id="Algorithmic_inference:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mrow>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>log</mi>
        <msub>
         <mi>u</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>m</mi>
       <mrow>
        <mi>log</mi>
        <mrow>
         <mi>min</mi>
         <mrow>
          <mo stretchy="false">{</mo>
          <msub>
           <mi>u</mi>
           <mi>i</mi>
          </msub>
          <mo stretchy="false">}</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
     <mrow>
      <msub>
       <mi>s</mi>
       <mn>1</mn>
      </msub>
      <mo>-</mo>
      <mrow>
       <mi>m</mi>
       <mrow>
        <mi>log</mi>
        <msub>
         <mi>s</mi>
         <mn>2</mn>
        </msub>
       </mrow>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <apply>
     <divide></divide>
     <apply>
      <minus></minus>
      <apply>
       <sum></sum>
       <apply>
        <log></log>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>m</ci>
       <apply>
        <log></log>
        <apply>
         <min></min>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>u</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <times></times>
       <ci>m</ci>
       <apply>
        <log></log>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>s</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=\frac{\sum\log u_{i}-m\log\min\{u_{i}\}}{s_{1}-m\log s_{2}}.
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Algorithmic_inference:31">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <msup>
    <mi mathvariant="normal">e</mi>
    <mfrac>
     <mrow>
      <mrow>
       <mi>a</mi>
       <msub>
        <mi>s</mi>
        <mn>1</mn>
       </msub>
      </mrow>
      <mo>-</mo>
      <mstyle scriptlevel="-2">
       <mrow>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mi>log</mi>
         <msub>
          <mi>u</mi>
          <mi>i</mi>
         </msub>
        </mrow>
       </mrow>
      </mstyle>
     </mrow>
     <mrow>
      <mi>m</mi>
      <mi>a</mi>
     </mrow>
    </mfrac>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-e</ci>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>a</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>s</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <sum></sum>
        <apply>
         <log></log>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>u</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>a</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=\mathrm{e}^{\frac{as_{1}-\sum\log u_{i}}{ma}}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Algorithmic_inference:32">
 <semantics>
  <msub>
   <mi>s</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{1}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Algorithmic_inference:33">
 <semantics>
  <msub>
   <mi>s</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{2}
  </annotation>
 </semantics>
</math>

 are the observed statistics and 

<math display="inline" id="Algorithmic_inference:34">
 <semantics>
  <mrow>
   <msub>
    <mi>u</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>u</mi>
    <mi>m</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>m</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{1},\ldots,u_{m}
  </annotation>
 </semantics>
</math>

 a set of uniform seeds. Transferring to the parameters the probability (density) affecting the seeds, you obtain the distribution law of the random parameters <em>A</em> and <em>K</em> compatible with the statistics you have observed.</p></td>
</tr>
</tbody>
</table>

<p>Compatibility denotes parameters of compatible populations, i.e. of populations that <em>could have generated</em> a sample giving rise to the observed statistics. You may formalize this notion as follows:</p></td>
</tr>
</tbody>
</table>
<h3 id="definition">Definition</h3>

<p>For a random variable and a sample drawn from it a <em>compatible distribution</em> is a distribution having the same <a href="Algorithmic_inference#Sampling_mechanism" title="wikilink">sampling mechanism</a> 

<math display="inline" id="Algorithmic_inference:35">
 <semantics>
  <mrow>
   <msub>
    <mi class="ltx_font_mathcaligraphic">ℳ</mi>
    <mi>X</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Z</mi>
    <mo>,</mo>
    <msub>
     <mi>g</mi>
     <mi>𝜽</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ℳ</ci>
     <ci>X</ci>
    </apply>
    <interval closure="open">
     <ci>Z</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <ci>𝜽</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{M}_{X}=(Z,g_{\boldsymbol{\theta}})
  </annotation>
 </semantics>
</math>

 of <em>X</em> with a value 

<math display="inline" id="Algorithmic_inference:36">
 <semantics>
  <mi>𝜽</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝜽</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \boldsymbol{\theta}
  </annotation>
 </semantics>
</math>

 of the random parameter 

<math display="inline" id="Algorithmic_inference:37">
 <semantics>
  <mi>𝚯</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝚯</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{\Theta}
  </annotation>
 </semantics>
</math>

 derived from a master equation rooted on a well-behaved statistic <em>s</em>.</p>
<h3 id="example-2">Example</h3>

<p>You may find the distribution law of the Pareto parameters <em>A</em> and <em>K</em> as an implementation example of the <a href="bootstrapping_populations" title="wikilink">population bootstrap</a> method as in the figure on the left.</p>

<p>Implementing the <a href="Twisting_properties#twisting_argument" title="wikilink">twisting argument</a> method, you get the distribution law 

<math display="inline" id="Algorithmic_inference:38">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mi>M</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>μ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>M</ci>
    </apply>
    <ci>μ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{M}(\mu)
  </annotation>
 </semantics>
</math>

 of the mean <em>M</em> of a Gaussian variable <em>X</em> on the basis of the statistic 

<math display="inline" id="Algorithmic_inference:39">
 <semantics>
  <mrow>
   <msub>
    <mi>s</mi>
    <mi>M</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>m</mi>
    </msubsup>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>M</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{M}=\sum_{i=1}^{m}x_{i}
  </annotation>
 </semantics>
</math>

 when 

<math display="inline" id="Algorithmic_inference:40">
 <semantics>
  <msup>
   <mi mathvariant="normal">Σ</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Σ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{2}
  </annotation>
 </semantics>
</math>

 is known to be equal to 

<math display="inline" id="Algorithmic_inference:41">
 <semantics>
  <msup>
   <mi>σ</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>σ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma^{2}
  </annotation>
 </semantics>
</math>

 . Its expression is:</p>

<p>

<math display="block" id="Algorithmic_inference:42">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>F</mi>
      <mi>M</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>μ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mrow>
        <mrow>
         <mi>m</mi>
         <mi>μ</mi>
        </mrow>
        <mo>-</mo>
        <msub>
         <mi>s</mi>
         <mi>M</mi>
        </msub>
       </mrow>
       <mrow>
        <mi>σ</mi>
        <msqrt>
         <mi>m</mi>
        </msqrt>
       </mrow>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>M</ci>
     </apply>
     <ci>μ</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-Φ</ci>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>μ</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>s</ci>
        <ci>M</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>σ</ci>
       <apply>
        <root></root>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{M}(\mu)=\Phi\left(\frac{m\mu-s_{M}}{\sigma\sqrt{m}}\right),
  </annotation>
 </semantics>
</math>

</p>

<p>shown in the figure on the right, where 

<math display="inline" id="Algorithmic_inference:43">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 is the <a href="cumulative_distribution_function" title="wikilink">cumulative distribution function</a> of a <a href="standard_normal_distribution" title="wikilink">standard normal distribution</a>.</p>

<p> Computing a <a href="confidence_interval" title="wikilink">confidence interval</a> for <em>M</em> given its distribution function is straightforward: we need only find two quantiles (for instance 

<math display="inline" id="Algorithmic_inference:44">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>δ</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta/2
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Algorithmic_inference:45">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mrow>
    <mi>δ</mi>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <divide></divide>
     <ci>δ</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\delta/2
  </annotation>
 </semantics>
</math>

 quantiles in case we are interested in a confidence interval of level δ symmetric in the tail's probabilities) as indicated on the left in the diagram showing the behavior of the two bounds for different values of the statistic <em>s</em><sub><em>m</em></sub>.</p>

<p>The Achilles heel of Fisher's approach lies in the joint distribution of more than one parameter, say mean and variance of a Gaussian distribution. On the contrary, with the last approach (and above-mentioned methods: <a href="bootstrapping_populations" title="wikilink">population bootstrap</a> and <a href="Twisting_properties#twisting_argument" title="wikilink">twisting argument</a>) we may learn the joint distribution of many parameters. For instance, focusing on the distribution of two or many more parameters, in the figures below we report two confidence regions where the function to be learnt falls with a confidence of 90%. The former concerns the probability with which an extended <a href="support_vector_machine" title="wikilink">support vector machine</a> attributes a binary label 1 to the points of the 

<math display="inline" id="Algorithmic_inference:46">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)
  </annotation>
 </semantics>
</math>

 plane. The two surfaces are drawn on the basis of a set of sample points in turn labelled according to a specific distribution law . The latter concerns the confidence region of the hazard rate of breast cancer recurrence computed from a censored sample .</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>thunbail|100px|90% confidence region for the family of support vector machines endowed with hyperbolic tangent profile function</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>thunbail|100px|90% confidence region for the hazard function of breast cancer recurrence computed from the censored sample 

<math display="inline" id="Algorithmic_inference:47">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>9</mn>
    <mo>,</mo>
    <mn>13</mn>
    <mo>,</mo>
    <mo>></mo>
    <mn>13</mn>
    <mo>,</mo>
    <mn>18</mn>
    <mo>,</mo>
    <mn>12</mn>
    <mo>,</mo>
    <mn>23</mn>
    <mo>,</mo>
    <mn>31</mn>
    <mo>,</mo>
    <mn>34</mn>
    <mo>,</mo>
    <mo>></mo>
    <mn>45</mn>
    <mo>,</mo>
    <mn>48</mn>
    <mo>,</mo>
    <mo>></mo>
    <mn>161</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo rspace="4.2pt">,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">t</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">9</cn>
     <ci>normal-,</ci>
     <cn type="integer">13</cn>
     <ci>normal-,</ci>
     <gt></gt>
     <cn type="integer">13</cn>
     <ci>normal-,</ci>
     <cn type="integer">18</cn>
     <ci>normal-,</ci>
     <cn type="integer">12</cn>
     <ci>normal-,</ci>
     <cn type="integer">23</cn>
     <ci>normal-,</ci>
     <cn type="integer">31</cn>
     <ci>normal-,</ci>
     <cn type="integer">34</cn>
     <ci>normal-,</ci>
     <gt></gt>
     <cn type="integer">45</cn>
     <ci>normal-,</ci>
     <cn type="integer">48</cn>
     <ci>normal-,</ci>
     <gt></gt>
     <cn type="integer">161</cn>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t=(9,13,>13,18,12,23,31,34,>45,48,>161),\,
  </annotation>
 </semantics>
</math>

 with &gt; <em>t</em> denoting a censored time</figcaption>
</figure></td>
</tr>
</tbody>
</table>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Algorithmic_inference" title="wikilink"> </a> <a href="Category:Machine_learning" title="wikilink">Category:Machine learning</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">By default, capital letters (such as <em>U</em>, <em>X</em>) will denote random variables and small letters (<em>u</em>, <em>x</em>) their corresponding specifications.<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
