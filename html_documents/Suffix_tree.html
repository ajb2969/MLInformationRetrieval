<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="695">Suffix tree</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Suffix tree</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Suffix tree for the text <code>BANANA</code>. Each substring is terminated with special character <code>$</code>. The six paths from the root to the leaves (shown as boxes) correspond to the six suffixes <code>A$</code>, <code>NA$</code>, <code>ANA$</code>, <code>NANA$</code>, <code>ANANA$</code> and <code>BANANA$</code>. The numbers in the leaves give the start position of the corresponding suffix. Suffix links, drawn dashed, are used during construction.</figcaption>
</figure>

<p>In <a href="computer_science" title="wikilink">computer science</a>, a <strong>suffix tree</strong> (also called <strong>PAT tree</strong> or, in an earlier form, <strong>position tree</strong>) is a compressed <a class="uri" href="trie" title="wikilink">trie</a> containing all the <a href="suffix_(computer_science)" title="wikilink">suffixes</a> of the given text as their keys and positions in the text as their values. Suffix trees allow particularly fast implementations of many important string operations.</p>

<p>The construction of such a tree for the string 

<math display="inline" id="Suffix_tree:0">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 takes time and space linear in the length of 

<math display="inline" id="Suffix_tree:1">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

. Once constructed, several operations can be performed quickly, for instance locating a <a class="uri" href="substring" title="wikilink">substring</a> in 

<math display="inline" id="Suffix_tree:2">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

, locating a substring if a certain number of mistakes are allowed, locating matches for a <a href="regular_expression" title="wikilink">regular expression</a> pattern etc. Suffix trees also provide one of the first linear-time solutions for the <a href="longest_common_substring_problem" title="wikilink">longest common substring problem</a>. These speedups come at a cost: storing a string's suffix tree typically requires significantly more space than storing the string itself.</p>
<h2 id="history">History</h2>

<p>The concept was first introduced by , which <a href="Donald_Knuth" title="wikilink">Donald Knuth</a> subsequently characterized as "Algorithm of the Year 1973". The construction was greatly simplified by  , and also by . Ukkonen provided the first online-construction of suffix trees, now known as <a href="Ukkonen's_algorithm" title="wikilink">Ukkonen's algorithm</a>, with running time that matched the then fastest algorithms. These algorithms are all linear-time for a constant-size alphabet, and have worst-case running time of 

<math display="inline" id="Suffix_tree:3">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n\log n)
  </annotation>
 </semantics>
</math>


 in general.</p>

<p>gave the first suffix tree construction algorithm that is optimal for all alphabets. In particular, this is the first linear-time algorithm for strings drawn from an alphabet of integers in a polynomial range. Farach's algorithm has become the basis for new algorithms for constructing both suffix trees and <a href="suffix_array" title="wikilink">suffix arrays</a>, for example, in external memory, compressed, succinct, etc.</p>
<h2 id="definition">Definition</h2>

<p>The suffix tree for the string 

<math display="inline" id="Suffix_tree:4">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 of length 

<math display="inline" id="Suffix_tree:5">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is defined as a tree such that:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<ul>
<li>The tree has exactly n leaves numbered from 1 to n.</li>
<li>Except for the root, every internal node has at least two children.</li>
<li>Each edge is labeled with a non-empty substring of S.</li>
<li>No two edges starting out of a node can have string-labels beginning with the same character.</li>
<li>The string obtained by concatenating all the string-labels found on the path from the root to leaf i spells out suffix S[i..n], for i from 1 to n.</li>
</ul>

<p>Since such a tree does not exist for all strings, 

<math display="inline" id="Suffix_tree:6">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is padded with a terminal symbol not seen in the string (usually denoted <code>$</code>). This ensures that no suffix is a prefix of another, and that there will be 

<math display="inline" id="Suffix_tree:7">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 leaf nodes, one for each of the 

<math display="inline" id="Suffix_tree:8">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


 suffixes of 

<math display="inline" id="Suffix_tree:9">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

. Since all internal non-root nodes are branching, there can be at most <em>n</em> −  1 such nodes, and <em>n</em> + (<em>n</em> − 1) + 1 = 2<em>n</em> nodes in total (<em>n</em> leaves, <em>n</em> − 1 internal non-root nodes, 1 root).</p>

<p><strong>Suffix links</strong> are a key feature for older linear-time construction algorithms, although most newer algorithms, which are based on <a href="Farach's_algorithm" title="wikilink">Farach's algorithm</a>, dispense with suffix links. In a complete suffix tree, all internal non-root nodes have a suffix link to another internal node. If the path from the root to a node spells the string 

<math display="inline" id="Suffix_tree:10">
 <semantics>
  <mrow>
   <mi>χ</mi>
   <mi>α</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>χ</ci>
    <ci>α</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \chi\alpha
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Suffix_tree:11">
 <semantics>
  <mi>χ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>χ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \chi
  </annotation>
 </semantics>
</math>

 is a single character and 

<math display="inline" id="Suffix_tree:12">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>

 is a string (possibly empty), it has a suffix link to the internal node representing 

<math display="inline" id="Suffix_tree:13">
 <semantics>
  <mi>α</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>α</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha
  </annotation>
 </semantics>
</math>


. See for example the suffix link from the node for <code>ANA</code> to the node for <code>NA</code> in the figure above. Suffix links are also used in some algorithms running on the tree.</p>
<h2 id="generalized-suffix-tree">Generalized suffix tree</h2>

<p>A <a href="generalized_suffix_tree" title="wikilink">generalized suffix tree</a> is a suffix tree made for a set of words instead of only for a single word. It represents all suffixes from this set of words. Each word must be terminated by a different termination symbol or word.</p>
<h2 id="functionality">Functionality</h2>

<p>A suffix tree for a string 

<math display="inline" id="Suffix_tree:14">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 of length 

<math display="inline" id="Suffix_tree:15">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 can be built in 

<math display="inline" id="Suffix_tree:16">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(n)
  </annotation>
 </semantics>
</math>

 time, if the letters come from an alphabet of integers in a polynomial range (in particular, this is true for constant-sized alphabets). For larger alphabets, the running time is dominated by first <a href="Sorting_algorithm" title="wikilink">sorting</a> the letters to bring them into a range of size 

<math display="inline" id="Suffix_tree:17">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

; in general, this takes 

<math display="inline" id="Suffix_tree:18">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n\log n)
  </annotation>
 </semantics>
</math>


 time. The costs below are given under the assumption that the alphabet is constant.</p>

<p>Assume that a suffix tree has been built for the string 

<math display="inline" id="Suffix_tree:19">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 of length 

<math display="inline" id="Suffix_tree:20">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, or that a <a href="generalised_suffix_tree" title="wikilink">generalised suffix tree</a> has been built for the set of strings 

<math display="inline" id="Suffix_tree:21">
 <semantics>
  <mrow>
   <mi>D</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>S</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mi>K</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>D</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <ci>K</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D=\{S_{1},S_{2},\dots,S_{K}\}
  </annotation>
 </semantics>
</math>

 of total length 

<math display="inline" id="Suffix_tree:22">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <msub>
      <mi>n</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <msub>
      <mi>n</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>+</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>+</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <msub>
      <mi>n</mi>
      <mi>K</mi>
     </msub>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <plus></plus>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>K</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=|n_{1}|+|n_{2}|+\cdots+|n_{K}|
  </annotation>
 </semantics>
</math>

. You can:</p>
<ul>
<li>Search for strings:
<ul>
<li>Check if a string 

<math display="inline" id="Suffix_tree:23">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>


 of length 

<math display="inline" id="Suffix_tree:24">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 is a substring in 

<math display="inline" id="Suffix_tree:25">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(m)
  </annotation>
 </semantics>
</math>

 time.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></li>
<li>Find the first occurrence of the patterns 

<math display="inline" id="Suffix_tree:26">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>P</mi>
    <mi>q</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>q</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{1},\dots,P_{q}
  </annotation>
 </semantics>
</math>

 of total length 

<math display="inline" id="Suffix_tree:27">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 as substrings in 

<math display="inline" id="Suffix_tree:28">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(m)
  </annotation>
 </semantics>
</math>


 time.</li>
<li>Find all 

<math display="inline" id="Suffix_tree:29">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 occurrences of the patterns 

<math display="inline" id="Suffix_tree:30">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>P</mi>
    <mi>q</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>q</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{1},\dots,P_{q}
  </annotation>
 </semantics>
</math>

 of total length 

<math display="inline" id="Suffix_tree:31">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 as substrings in 

<math display="inline" id="Suffix_tree:32">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>m</mi>
     <mo>+</mo>
     <mi>z</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <plus></plus>
     <ci>m</ci>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(m+z)
  </annotation>
 </semantics>
</math>

 time.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></li>
</ul></li>
</ul>
<ul>
<li><ul>
<li>Search for a <a href="regular_expression" title="wikilink">regular expression</a> <em>P</em> in time expected <a href="Sublinear_time_algorithm" title="wikilink">sublinear</a> in 

<math display="inline" id="Suffix_tree:33">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


.</li>
<li>Find for each suffix of a pattern 

<math display="inline" id="Suffix_tree:34">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

, the length of the longest match between a prefix of 

<math display="inline" id="Suffix_tree:35">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>i</mi>
     <mi mathvariant="normal">…</mi>
     <mi>m</mi>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>normal-…</ci>
      <ci>m</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P[i\dots m]
  </annotation>
 </semantics>
</math>

 and a substring in 

<math display="inline" id="Suffix_tree:36">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Suffix_tree:37">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>m</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(m)
  </annotation>
 </semantics>
</math>

 time.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> This is termed the <strong>matching statistics</strong> for 

<math display="inline" id="Suffix_tree:38">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>


.</li>
</ul></li>
<li>Find properties of the strings:
<ul>
<li>Find the <a href="longest_common_substring_problem" title="wikilink">longest common substrings</a> of the string 

<math display="inline" id="Suffix_tree:39">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Suffix_tree:40">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{j}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Suffix_tree:41">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>n</mi>
      <mi>i</mi>
     </msub>
     <mo>+</mo>
     <msub>
      <mi>n</mi>
      <mi>j</mi>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(n_{i}+n_{j})
  </annotation>
 </semantics>
</math>

 time.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></li>
<li>Find all <a href="maximal_pair" title="wikilink">maximal pairs</a>, maximal repeats or supermaximal repeats in 

<math display="inline" id="Suffix_tree:42">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mi>z</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(n+z)
  </annotation>
 </semantics>
</math>

 time.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></li>
<li>Find the <a class="uri" href="Lempel–Ziv" title="wikilink">Lempel–Ziv</a> decomposition in 

<math display="inline" id="Suffix_tree:43">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(n)
  </annotation>
 </semantics>
</math>


 time.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></li>
<li>Find the <a href="longest_repeated_substring_problem" title="wikilink">longest repeated substrings</a> in 

<math display="inline" id="Suffix_tree:44">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(n)
  </annotation>
 </semantics>
</math>

 time.</li>
<li>Find the most frequently occurring substrings of a minimum length in 

<math display="inline" id="Suffix_tree:45">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(n)
  </annotation>
 </semantics>
</math>

 time.</li>
<li>Find the shortest strings from 

<math display="inline" id="Suffix_tree:46">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

 that do not occur in 

<math display="inline" id="Suffix_tree:47">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

, in 

<math display="inline" id="Suffix_tree:48">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mi>z</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n+z)
  </annotation>
 </semantics>
</math>


 time, if there are 

<math display="inline" id="Suffix_tree:49">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 such strings.</li>
<li>Find the shortest substrings occurring only once in 

<math display="inline" id="Suffix_tree:50">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(n)
  </annotation>
 </semantics>
</math>

 time.</li>
<li>Find, for each 

<math display="inline" id="Suffix_tree:51">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

, the shortest substrings of 

<math display="inline" id="Suffix_tree:52">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{i}
  </annotation>
 </semantics>
</math>

 not occurring elsewhere in 

<math display="inline" id="Suffix_tree:53">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>


 in 

<math display="inline" id="Suffix_tree:54">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(n)
  </annotation>
 </semantics>
</math>

 time.</li>
</ul></li>
</ul>

<p>The suffix tree can be prepared for constant time <a href="lowest_common_ancestor" title="wikilink">lowest common ancestor</a> retrieval between nodes in 

<math display="inline" id="Suffix_tree:55">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(n)
  </annotation>
 </semantics>
</math>

 time.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> One can then also:</p>
<ul>
<li>Find the longest common prefix between the suffixes 

<math display="inline" id="Suffix_tree:56">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>p</mi>
    <mo>.</mo>
    <mo>.</mo>
    <msub>
     <mi>n</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>i</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-.</ci>
     <ci>normal-.</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{i}[p..n_{i}]
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Suffix_tree:57">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mi>j</mi>
   </msub>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>q</mi>
    <mo>.</mo>
    <mo>.</mo>
    <msub>
     <mi>n</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>j</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">q</csymbol>
     <ci>normal-.</ci>
     <ci>normal-.</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>j</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{j}[q..n_{j}]
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Suffix_tree:58">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(1)
  </annotation>
 </semantics>
</math>


.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></li>
<li>Search for a pattern <em>P</em> of length <em>m</em> with at most <em>k</em> mismatches in 

<math display="inline" id="Suffix_tree:59">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>k</mi>
      <mi>n</mi>
     </mrow>
     <mo>+</mo>
     <mi>z</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>k</ci>
      <ci>n</ci>
     </apply>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(kn+z)
  </annotation>
 </semantics>
</math>

 time, where <em>z</em> is the number of hits.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></li>
<li>Find all 

<math display="inline" id="Suffix_tree:60">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 maximal <a href="palindrome" title="wikilink">palindromes</a> in 

<math display="inline" id="Suffix_tree:61">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(n)
  </annotation>
 </semantics>
</math>

,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> or 

<math display="inline" id="Suffix_tree:62">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(gn)
  </annotation>
 </semantics>
</math>

 time if gaps of length 

<math display="inline" id="Suffix_tree:63">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>


 are allowed, or 

<math display="inline" id="Suffix_tree:64">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>k</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <apply>
     <times></times>
     <ci>k</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(kn)
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="Suffix_tree:65">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 mismatches are allowed.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></li>
<li>Find all 

<math display="inline" id="Suffix_tree:66">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

 <a href="tandem_repeats" title="wikilink">tandem repeats</a> in 

<math display="inline" id="Suffix_tree:67">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>n</mi>
      <mrow>
       <mi>log</mi>
       <mi>n</mi>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mi>z</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n\log n+z)
  </annotation>
 </semantics>
</math>

, and <em>k</em>-mismatch tandem repeats in 

<math display="inline" id="Suffix_tree:68">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>k</mi>
      <mi>n</mi>
      <mrow>
       <mi>log</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>/</mo>
         <mi>k</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mi>z</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>k</ci>
      <ci>n</ci>
      <apply>
       <log></log>
       <apply>
        <divide></divide>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <ci>z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(kn\log(n/k)+z)
  </annotation>
 </semantics>
</math>


.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></li>
<li>Find the <a href="longest_common_substring_problem" title="wikilink">longest common substrings</a> to at least 

<math display="inline" id="Suffix_tree:69">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 strings in 

<math display="inline" id="Suffix_tree:70">
 <semantics>
  <mi>D</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>D</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Suffix_tree:71">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>K</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <list>
     <cn type="integer">2</cn>
     <ci>normal-…</ci>
     <ci>K</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=2,\dots,K
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Suffix_tree:72">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(n)
  </annotation>
 </semantics>
</math>

 time.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></li>
<li>Find the <a href="longest_palindromic_substring" title="wikilink">longest palindromic substring</a> of a given string (using the generalized suffix tree of the string and its reverse) in linear time.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></li>
</ul>
<h2 id="applications">Applications</h2>

<p>Suffix trees can be used to solve a large number of string problems that occur in text-editing, free-text search, computational biology and other application areas.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> Primary applications include:<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>
<ul>
<li><a href="String_search#Index_methods" title="wikilink">String search</a>, in <em>O(m)</em> complexity, where <em>m</em> is the length of the sub-string (but with initial <em>O(n)</em> time required to build the suffix tree for the string)</li>
<li>Finding the longest repeated substring</li>
<li>Finding the longest common substring</li>
<li>Finding the longest <a class="uri" href="palindrome" title="wikilink">palindrome</a> in a string</li>
</ul>

<p>Suffix trees are often used in <a class="uri" href="bioinformatics" title="wikilink">bioinformatics</a> applications, searching for patterns in <a class="uri" href="DNA" title="wikilink">DNA</a> or <a class="uri" href="protein" title="wikilink">protein</a> sequences (which can be viewed as long strings of characters). The ability to search efficiently with mismatches might be considered their greatest strength. Suffix trees are also used in <a href="data_compression" title="wikilink">data compression</a>; they can be used to find repeated data, and can be used for the sorting stage of the <a href="Burrows–Wheeler_transform" title="wikilink">Burrows–Wheeler transform</a>. Variants of the <a class="uri" href="LZW" title="wikilink">LZW</a> compression schemes use suffix trees (<a class="uri" href="LZSS" title="wikilink">LZSS</a>). A suffix tree is also used in <a href="suffix_tree_clustering" title="wikilink">suffix tree clustering</a>, a <a href="data_clustering" title="wikilink">data clustering</a> algorithm used in some search engines.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h2 id="implementation">Implementation</h2>

<p>If each node and edge can be represented in 

<math display="inline" id="Suffix_tree:73">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(1)
  </annotation>
 </semantics>
</math>


 space, the entire tree can be represented in 

<math display="inline" id="Suffix_tree:74">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(n)
  </annotation>
 </semantics>
</math>

 space. The total length of all the strings on all of the edges in the tree is 

<math display="inline" id="Suffix_tree:75">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n^{2})
  </annotation>
 </semantics>
</math>

, but each edge can be stored as the position and length of a substring of <em>S</em>, giving a total space usage of 

<math display="inline" id="Suffix_tree:76">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(n)
  </annotation>
 </semantics>
</math>

 computer words. The worst-case space usage of a suffix tree is seen with a <a href="fibonacci_word" title="wikilink">fibonacci word</a>, giving the full 

<math display="inline" id="Suffix_tree:77">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2n
  </annotation>
 </semantics>
</math>

 nodes.</p>

<p>An important choice when making a suffix tree implementation is the parent-child relationships between nodes. The most common is using <a href="linked_list" title="wikilink">linked lists</a> called <strong>sibling lists</strong>. Each node has a pointer to its first child, and to the next node in the child list it is a part of. Other implementations with efficient running time properties use <a href="hash_map" title="wikilink">hash maps</a>, sorted or unsorted <a href="array_data_structure" title="wikilink">arrays</a> (with <a href="dynamic_array" title="wikilink">array doubling</a>), or <a href="Self-balancing_binary_search_tree" title="wikilink">balanced search trees</a>. We are interested in:</p>
<ul>
<li>The cost of finding the child on a given character.</li>
<li>The cost of inserting a child.</li>
<li>The cost of enlisting all children of a node (divided by the number of children in the table below).</li>
</ul>

<p>Let 

<math display="inline" id="Suffix_tree:78">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>


 be the size of the alphabet. Then you have the following costs:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">
<p>Lookup</p></th>
<th style="text-align: left;">
<p>Insertion</p></th>
<th style="text-align: left;">
<p>Traversal</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Sibling lists / unsorted arrays</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Suffix_tree:79">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>σ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\sigma)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Suffix_tree:80">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(1)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Suffix_tree:81">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(1)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Bitwise sibling trees</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Suffix_tree:82">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>σ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log\sigma)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Suffix_tree:83">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(1)
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Suffix_tree:84">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(1)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Hash maps</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Suffix_tree:85">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(1)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Suffix_tree:86">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Θ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Θ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Theta(1)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Suffix_tree:87">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>σ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\sigma)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Balanced search tree</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Suffix_tree:88">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>σ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log\sigma)
  </annotation>
 </semantics>
</math>


</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Suffix_tree:89">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>σ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log\sigma)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Suffix_tree:90">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Sorted arrays</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Suffix_tree:91">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>σ</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>σ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log\sigma)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Suffix_tree:92">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>σ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>σ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\sigma)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Suffix_tree:93">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1)
  </annotation>
 </semantics>
</math>


</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Hash maps + sibling lists</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Suffix_tree:94">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Suffix_tree:95">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Suffix_tree:96">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(1)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>Note that the insertion cost is amortised, and that the costs for hashing are given for perfect hashing.</p>

<p>The large amount of information in each edge and node makes the suffix tree very expensive, consuming about 10 to 20 times the memory size of the source text in good implementations. The <a href="suffix_array" title="wikilink">suffix array</a> reduces this requirement to a factor of 8 (for array including <a href="LCP_array" title="wikilink">LCP</a> values built within 32-bit address space and 8-bit characters.) This factor depends on the properties and may reach 2 with usage of 4-byte wide characters (needed to contain any symbol in some UNIX-like systems, see <a href="wchar_t" title="wikilink">wchar t</a>) on 32-bit systems. Researchers have continued to find smaller indexing structures.</p>
<h2 id="external-construction">External construction</h2>

<p>Though linear, the memory usage of a suffix tree is significantly higher than the actual size of the sequence collection. For a large text, construction may require external memory approaches.</p>

<p>There are theoretical results for constructing suffix trees in external memory. The algorithm by  is theoretically optimal, with an I/O complexity equal to that of sorting. However the overall intricacy of this algorithm has prevented, so far, its practical implementation.</p>

<p>On the other hand, there have been practical works for constructing disk-based suffix trees which scale to (few) GB/hours. The state of the art methods are TDD,<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> TRELLIS,<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> DiGeST,<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> and B<sup>2</sup>ST.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>

<p>TDD and TRELLIS scale up to the entire human genome – approximately 3GB – resulting in a disk-based suffix tree of a size in the tens of gigabytes.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a><a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> However, these methods cannot handle efficiently collections of sequences exceeding 3GB.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> DiGeST performs significantly better and is able to handle collections of sequences in the order of 6GB in about 6 hours.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> . All these methods can efficiently build suffix trees for the case when the tree does not fit in main memory, but the input does. The most recent method, B<sup>2</sup>ST,<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> scales to handle inputs that do not fit in main memory. ERA is a recent parallel suffix tree construction method that is significantly faster. ERA can index the entire human genome in 19 minutes on an 8-core desktop computer with 16GB RAM. On a simple Linux cluster with 16 nodes (4GB RAM per node), ERA can index the entire human genome in less than 9 minutes.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Suffix_array" title="wikilink">Suffix array</a></li>
<li><a href="Generalised_suffix_tree" title="wikilink">Generalised suffix tree</a></li>
<li><a class="uri" href="Trie" title="wikilink">Trie</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cise.ufl.edu/~sahni/dsaaj/enrich/c16/suffix.htm">Suffix Trees</a> by <a href="Sartaj_Sahni" title="wikilink">Sartaj Sahni</a></li>
<li><a href="http://www.allisons.org/ll/AlgDS/Tree/Suffix/">Suffix Trees</a> by Lloyd Allison</li>
<li><a href="http://www.nist.gov/dads/HTML/suffixtree.html">NIST's Dictionary of Algorithms and Data Structures: Suffix Tree</a></li>
<li><a href="http://mila.cs.technion.ac.il/~yona/suffix_tree/">suffix_tree</a> ANSI C implementation of a Suffix Tree</li>
<li><a href="http://www.cl.cam.ac.uk/~cpk25/libstree/">libstree</a>, a generic suffix tree library written in C</li>
<li>[<a class="uri" href="https://metacpan.org/module/Tree">https://metacpan.org/module/Tree</a>::Suffix Tree::Suffix], a Perl binding to libstree</li>
<li><a href="http://www.cs.ucdavis.edu/~gusfield/strmat.html">Strmat</a> a faster generic suffix tree library written in C (uses arrays instead of linked lists)</li>
<li><a href="http://hkn.eecs.berkeley.edu/~dyoo/python/suffix_trees/">SuffixTree</a> a Python binding to Strmat</li>
<li><a href="http://www.balkenhol.net/papers/t1043.pdf.gz">Universal Data Compression Based on the Burrows-Wheeler Transformation: Theory and Practice</a>, application of suffix trees in the BWT</li>
<li><a href="http://www.cs.helsinki.fi/group/suds/">Theory and Practice of Succinct Data Structures</a>, C++ implementation of a compressed suffix tree</li>
<li><a href="http://code.google.com/p/patl/">Practical Algorithm Template Library</a>, a C++ library with suffix tree implementation on PATRICIA trie, by Roman S. Klyujkov</li>
<li><a href="http://en.literateprograms.org/Suffix_tree_(Java)">A Java implementation</a></li>
<li><a href="http://code.google.com/p/concurrent-trees/">A Java implementation of Concurrent Suffix Tree</a></li>
<li><a href="http://code.google.com/p/text-indexing/">Text-Indexing project</a> (linear-time construction of suffix trees, suffix arrays, LCP array and Burrows-Wheeler Transform)</li>
<li>Ukkonen's Suffix Tree Implementation in C <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-1/">Part 1</a> <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-2/">Part 2</a> <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-3/">Part 3</a> <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-4/">Part 4</a> <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-5/">Part 5</a> <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-6/">Part 6</a></li>
</ul>

<p>"</p>

<p><a href="Category:Trees_(data_structures)" title="wikilink">Category:Trees (data structures)</a> <a href="Category:Substring_indices" title="wikilink">Category:Substring indices</a> <a href="Category:String_data_structures" title="wikilink">Category:String data structures</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a class="uri" href="http://www.cs.uoi.gr/~kblekas/courses/bioinformatics/Suffix_Trees1.pdf">http://www.cs.uoi.gr/~kblekas/courses/bioinformatics/Suffix_Trees1.pdf</a><a href="#fnref1">↩</a></li>
<li id="fn2">, p.92.<a href="#fnref2">↩</a></li>
<li id="fn3">, p.123.<a href="#fnref3">↩</a></li>
<li id="fn4">, p.132.<a href="#fnref4">↩</a></li>
<li id="fn5">, p.125.<a href="#fnref5">↩</a></li>
<li id="fn6">, p.144.<a href="#fnref6">↩</a></li>
<li id="fn7">, p.166.<a href="#fnref7">↩</a></li>
<li id="fn8">, Chapter 8.<a href="#fnref8">↩</a></li>
<li id="fn9">, p.196.<a href="#fnref9">↩</a></li>
<li id="fn10">, p.200.<a href="#fnref10">↩</a></li>
<li id="fn11">, p.198.<a href="#fnref11">↩</a></li>
<li id="fn12">, p.201.<a href="#fnref12">↩</a></li>
<li id="fn13">, p.204.<a href="#fnref13">↩</a></li>
<li id="fn14">, p.205.<a href="#fnref14">↩</a></li>
<li id="fn15">, pp.197–199.<a href="#fnref15">↩</a></li>
<li id="fn16"></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18">First introduced by .<a href="#fnref18">↩</a></li>
<li id="fn19">.<a href="#fnref19">↩</a></li>
<li id="fn20">.<a href="#fnref20">↩</a></li>
<li id="fn21">.<a href="#fnref21">↩</a></li>
<li id="fn22">.<a href="#fnref22">↩</a></li>
<li id="fn23"></li>
<li id="fn24"></li>
<li id="fn25"></li>
<li id="fn26"></li>
<li id="fn27"></li>
</ol>
</section>
</body>
</html>
