<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1522">TP model transformation in control theory</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>TP model transformation in control theory</h1>
<hr/>

<p>Baranyi and Yam proposed the <a href="TP_model_transformation" title="wikilink">TP model transformation</a> <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> as a new concept in quasi-LPV (qLPV) based control, which plays a central role in the highly desirable bridging between identification and polytopic systems theories. It is uniquely effective in manipulating the <a href="convex_hull" title="wikilink">convex hull</a> of <a href="polytope" title="wikilink">polytopic forms</a>, and, hence, has revealed and proved the fact that convex hull manipulation is a necessary and crucial step in achieving optimal solutions and decreasing conservativeness in modern <a href="linear_matrix_inequality" title="wikilink">linear matrix inequality based control theory</a>. Thus, although it is a transformation in a mathematical sense, it has established a conceptually new direction in control theory and has laid the ground for further new approaches towards optimality.</p>

<p>For details please visit: <a href="TP_model_transformation" title="wikilink">TP model transformation</a></p>
<h2 id="key-features-for-control-analysis-and-design">Key features for control analysis and design</h2>
<ul>
<li>The TP model transformation transforms a given qLPV model into a (tensor product type) polytopic form, irrespective of whether the model is given in the form of analytical equations resulting from physical considerations, or as an outcome of soft computing based identification techniques (such as <a href="neural_network" title="wikilink">neural networks</a> or <a href="fuzzy_logic" title="wikilink">fuzzy logic</a> based methods, or as a result of a <a class="uri" href="black-box" title="wikilink">black-box</a> identification).</li>
<li>Further the TP model transformation is capable of manipulating the convex hull defined by the polytopic form that is a necessary step in polytopic qLPV model based control analysis and design theories.</li>
</ul>
<h2 id="related-definitions">Related definitions</h2>
<dl>
<dt>Linear Parameter-Varying (LPV) state-space model:</dt>
</dl>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\begin{pmatrix}</p>

<p><code> {{\mathbf{{\dot{x}}}}}(t) \\</code><br/>
<code> {\mathbf{y}}(t)</code></p>

<p>\end{pmatrix}={\mathbf{S}}({\mathbf{p}}(t))\begin{pmatrix}</p>

<p><code> {\mathbf{x}}(t) \\</code><br/>
<code> {\mathbf{u}}(t)</code></p>

<p>\end{pmatrix}, </p>

<p>with input 

<math display="inline" id="TP_model_transformation_in_control_theory:0">
 <semantics>
  <mrow>
   <mi>𝐮</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐮</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{u}}(t)
  </annotation>
 </semantics>
</math>

, output 

<math display="inline" id="TP_model_transformation_in_control_theory:1">
 <semantics>
  <mrow>
   <mi>𝐲</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐲</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{y}}(t)
  </annotation>
 </semantics>
</math>

 and state vector 

<math display="inline" id="TP_model_transformation_in_control_theory:2">
 <semantics>
  <mrow>
   <mi>𝐱</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐱</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{x}}(t)
  </annotation>
 </semantics>
</math>

. The system matrix 

<math display="inline" id="TP_model_transformation_in_control_theory:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐒</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>𝐩</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <msup>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\R</mtext>
    </merror>
    <mrow>
     <msub>
      <mi>L</mi>
      <mn>1</mn>
     </msub>
     <mo>×</mo>
     <msub>
      <mi>L</mi>
      <mn>2</mn>
     </msub>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>𝐒</ci>
     <apply>
      <times></times>
      <ci>𝐩</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <mtext>\R</mtext>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{S}}({\mathbf{p}}(t))\in\R^{L_{1}\times L_{2}}
  </annotation>
 </semantics>
</math>


 is a parameter-varying object, where 

<math display="inline" id="TP_model_transformation_in_control_theory:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐩</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>𝐩</ci>
     <ci>t</ci>
    </apply>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{p}}(t)\in\Omega
  </annotation>
 </semantics>
</math>

 is a time varying 

<math display="inline" id="TP_model_transformation_in_control_theory:5">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

-dimensional parameter vector which is an element of closed hypercube 

<math display="inline" id="TP_model_transformation_in_control_theory:6">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>×</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>a</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>b</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>×</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>×</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>a</mi>
      <mi>N</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>b</mi>
      <mi>N</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>⊂</mo>
   <msup>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\R</mtext>
    </merror>
    <mi>N</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>normal-Ω</ci>
     <apply>
      <times></times>
      <interval closure="closed">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">1</cn>
       </apply>
      </interval>
      <interval closure="closed">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">2</cn>
       </apply>
      </interval>
      <ci>normal-⋯</ci>
      <interval closure="closed">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>N</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>N</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <mtext>\R</mtext>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega=[a_{1},b_{1}]\times[a_{2},b_{2}]\times\cdots\times[a_{N},b_{N}]\subset%
\R^{N}
  </annotation>
 </semantics>
</math>

. As a matter of fact, further parameter dependent channels can be inserted to 

<math display="inline" id="TP_model_transformation_in_control_theory:7">
 <semantics>
  <mrow>
   <mi>𝐒</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>𝐩</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐒</ci>
    <apply>
     <times></times>
     <ci>𝐩</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{S}}({\mathbf{p}}(t))
  </annotation>
 </semantics>
</math>

 that represent various control performance requirements.</p>
<dl>
<dt>quasi Linear Parameter-Varying (qLPV) state-space model:</dt>
</dl>

<p>

<math display="inline" id="TP_model_transformation_in_control_theory:8">
 <semantics>
  <mrow>
   <mi>𝐩</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐩</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{p}}(t)
  </annotation>
 </semantics>
</math>

 in the above LPV model can also include some elements of the state vector 

<math display="inline" id="TP_model_transformation_in_control_theory:9">
 <semantics>
  <mrow>
   <mi>𝐱</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐱</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{x}}(t)
  </annotation>
 </semantics>
</math>

, and, hence this model belongs to the class of non-linear systems, and is also referred to as a quasi LPV (qLPV) model.</p>
<dl>
<dt>TP type polytopic Linear Parameter-Varying (LPV) state-space model:</dt>
</dl>
<dl>
<dd><dl>
<dd><math>
</math></dd>
</dl>
</dd>
</dl>

<p>\begin{pmatrix}</p>

<p><code> {{\mathbf{{\dot{x}}}}}(t) \\</code><br/>
<code> {\mathbf{y}}(t)</code></p>

<p>\end{pmatrix}=\mathcal{S}\boxtimes_{n=1}^N\mathbf{w}_n(p_n(t))\begin{pmatrix}</p>

<p><code> {\mathbf{x}}(t) \\</code><br/>
<code> {\mathbf{u}}(t)</code></p>

<p>\end{pmatrix}, </p>

<p>with input 

<math display="inline" id="TP_model_transformation_in_control_theory:10">
 <semantics>
  <mrow>
   <mi>𝐮</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐮</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{u}}(t)
  </annotation>
 </semantics>
</math>

, output 

<math display="inline" id="TP_model_transformation_in_control_theory:11">
 <semantics>
  <mrow>
   <mi>𝐲</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐲</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{y}}(t)
  </annotation>
 </semantics>
</math>

 and state vector 

<math display="inline" id="TP_model_transformation_in_control_theory:12">
 <semantics>
  <mrow>
   <mi>𝐱</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐱</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{x}}(t)
  </annotation>
 </semantics>
</math>

. The system matrix 

<math display="inline" id="TP_model_transformation_in_control_theory:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐒</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>𝐩</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">𝒮</mi>
     <msubsup>
      <mo>⊠</mo>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </msubsup>
     <mi>𝐰</mi>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <msup>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\R</mtext>
    </merror>
    <mrow>
     <msub>
      <mi>L</mi>
      <mn>1</mn>
     </msub>
     <mo>×</mo>
     <msub>
      <mi>L</mi>
      <mn>2</mn>
     </msub>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>𝐒</ci>
      <apply>
       <times></times>
       <ci>𝐩</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-⊠</ci>
         <apply>
          <eq></eq>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>N</ci>
       </apply>
       <ci>𝒮</ci>
       <ci>𝐰</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>n</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <mtext>\R</mtext>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{S}}({\mathbf{p}}(t))=\mathcal{S}\boxtimes_{n=1}^{N}\mathbf{w}(p_{n}(t%
))\in\R^{L_{1}\times L_{2}}
  </annotation>
 </semantics>
</math>

 is a parameter-varying object, where 

<math display="inline" id="TP_model_transformation_in_control_theory:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐩</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>𝐩</ci>
     <ci>t</ci>
    </apply>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{p}}(t)\in\Omega
  </annotation>
 </semantics>
</math>

 is a time varying 

<math display="inline" id="TP_model_transformation_in_control_theory:15">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

-dimensional parameter vector which is an element of closed hypercube 

<math display="inline" id="TP_model_transformation_in_control_theory:16">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ω</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>a</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>b</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>×</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>a</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>b</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>×</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>×</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>a</mi>
      <mi>N</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>b</mi>
      <mi>N</mi>
     </msub>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>⊂</mo>
   <msup>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\R</mtext>
    </merror>
    <mi>N</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>normal-Ω</ci>
     <apply>
      <times></times>
      <interval closure="closed">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">1</cn>
       </apply>
      </interval>
      <interval closure="closed">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <cn type="integer">2</cn>
       </apply>
      </interval>
      <ci>normal-⋯</ci>
      <interval closure="closed">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>N</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>b</ci>
        <ci>N</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <mtext>\R</mtext>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega=[a_{1},b_{1}]\times[a_{2},b_{2}]\times\cdots\times[a_{N},b_{N}]\subset%
\R^{N}
  </annotation>
 </semantics>
</math>

, and the weighting functions 

<math display="inline" id="TP_model_transformation_in_control_theory:17">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>n</mi>
      <mo>,</mo>
      <msub>
       <mi>i</mi>
       <mi>n</mi>
      </msub>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <list>
       <ci>n</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <ci>n</ci>
       </apply>
      </list>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{n,i_{n}}(p_{n}(t))\in[0,1]
  </annotation>
 </semantics>
</math>

 are the elements of vector 

<math display="inline" id="TP_model_transformation_in_control_theory:18">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐰</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>p</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐰</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>n</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{w}_{n}(p_{n}(t))
  </annotation>
 </semantics>
</math>

. Core tensor contains elements 

<math display="inline" id="TP_model_transformation_in_control_theory:19">
 <semantics>
  <msub>
   <mi>𝐒</mi>
   <mrow>
    <msub>
     <mi>i</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>i</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>i</mi>
     <mi>N</mi>
    </msub>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐒</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>i</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>i</ci>
      <ci>N</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{S}_{i_{1},i_{2},\ldots,i_{N}}
  </annotation>
 </semantics>
</math>

 which are the vertexes of the system. As a matter of fact, further parameter dependent channels can be inserted to 

<math display="inline" id="TP_model_transformation_in_control_theory:20">
 <semantics>
  <mrow>
   <mi>𝐒</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>𝐩</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐒</ci>
    <apply>
     <times></times>
     <ci>𝐩</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\mathbf{S}}({\mathbf{p}}(t))
  </annotation>
 </semantics>
</math>

 that represent various control performance requirements. Here</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="TP_model_transformation_in_control_theory:21">
 <semantics>
  <mrow>
   <mrow>
    <mo>∀</mo>
    <mi>n</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <msub>
        <mi>i</mi>
        <mi>n</mi>
       </msub>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <msub>
       <mi>I</mi>
       <mi>n</mi>
      </msub>
     </msubsup>
     <mrow>
      <msub>
       <mi>w</mi>
       <mrow>
        <mi>n</mi>
        <mo>,</mo>
        <msub>
         <mi>i</mi>
         <mi>n</mi>
        </msub>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>p</mi>
         <mi>n</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>1.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>n</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>i</ci>
          <ci>n</ci>
         </apply>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>I</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <list>
         <ci>n</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>i</ci>
          <ci>n</ci>
         </apply>
        </list>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>n</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
     <cn type="float">1.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall n:\sum_{i_{n}=1}^{I_{n}}w_{n,i_{n}}(p_{n}(t))=1.
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="TP_model_transformation_in_control_theory:22">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>w</mi>
      <mrow>
       <mi>n</mi>
       <mo>,</mo>
       <msub>
        <mi>i</mi>
        <mi>n</mi>
       </msub>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>p</mi>
        <mi>n</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <list>
       <ci>n</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>i</ci>
        <ci>n</ci>
       </apply>
      </list>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
    <interval closure="closed">
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{n,i_{n}}(p_{n}(t))\in[0,1].
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>This means that 

<math display="inline" id="TP_model_transformation_in_control_theory:23">
 <semantics>
  <mrow>
   <mi>𝐒</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>𝐩</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐒</ci>
    <apply>
     <times></times>
     <ci>𝐩</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{S}({\mathbf{p}}(t))
  </annotation>
 </semantics>
</math>

 is within the vertexes 

<math display="inline" id="TP_model_transformation_in_control_theory:24">
 <semantics>
  <msub>
   <mi>𝐒</mi>
   <mrow>
    <msub>
     <mi>i</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>i</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>i</mi>
     <mi>N</mi>
    </msub>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐒</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>i</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>i</ci>
      <ci>N</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{S}_{i_{1},i_{2},\ldots,i_{N}}
  </annotation>
 </semantics>
</math>

 of the system (within the convex hull defined by the vertexes) for all 

<math display="inline" id="TP_model_transformation_in_control_theory:25">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐩</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mi mathvariant="normal">Ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>𝐩</ci>
     <ci>t</ci>
    </apply>
    <ci>normal-Ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{p}(t)\in\Omega
  </annotation>
 </semantics>
</math>

. Note that the TP type polytopic model can always be given in the form</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="TP_model_transformation_in_control_theory:26">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝐒</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>𝐩</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>r</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>R</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>𝐒</mi>
       <mi>r</mi>
      </msub>
      <msub>
       <mi>w</mi>
       <mi>r</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>𝐩</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝐒</ci>
     <apply>
      <times></times>
      <ci>𝐩</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>r</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>R</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐒</ci>
       <ci>r</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>r</ci>
      </apply>
      <apply>
       <times></times>
       <ci>𝐩</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{S}(\mathbf{p}(t))=\sum_{r=1}^{R}\mathbf{S}_{r}w_{r}(\mathbf{p}(t)),
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where the vertexes are the same as in the TP type polytopic form and the multi variable weighting functions are the product of the one variable weighting functions according to the TP type polytopic form, and r is the linear index equivalent of the multi-linear indexing 

<math display="inline" id="TP_model_transformation_in_control_theory:27">
 <semantics>
  <mrow>
   <msub>
    <mi>i</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>i</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mrow>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>i</mi>
     <mi>N</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>i</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>i</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i_{1},i_{2},\ldots i_{N}
  </annotation>
 </semantics>
</math>

.</p>
<dl>
<dt>TP model transformation for qLPV models:</dt>
</dl>

<p>Assume a given qLPV model 

<math display="inline" id="TP_model_transformation_in_control_theory:28">
 <semantics>
  <mrow>
   <mi>𝐒</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>𝐩</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐒</ci>
    <apply>
     <times></times>
     <ci>𝐩</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{S}(\mathbf{p}(t))
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="TP_model_transformation_in_control_theory:29">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐩</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mi mathvariant="normal">Ω</mi>
   <mo>⊂</mo>
   <msup>
    <mi>R</mi>
    <mi>N</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <apply>
      <times></times>
      <ci>𝐩</ci>
      <ci>t</ci>
     </apply>
     <ci>normal-Ω</ci>
    </apply>
    <apply>
     <subset></subset>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>R</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{p}(t)\in\Omega\subset R^{N}
  </annotation>
 </semantics>
</math>

, whose TP polytopic structure may be unknown (e.g. it is given by neural networks). The TP model transformation determines its TP polytopic structure as</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="TP_model_transformation_in_control_theory:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐒</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>𝐩</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">𝒮</mi>
     <msubsup>
      <mo>⊠</mo>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>N</mi>
     </msubsup>
     <msub>
      <mi>𝐰</mi>
      <mi>n</mi>
     </msub>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>p</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝐒</ci>
     <apply>
      <times></times>
      <ci>𝐩</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-⊠</ci>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <ci>𝒮</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐰</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{S}(\mathbf{p}(t))=\mathcal{S}\boxtimes_{n=1}^{N}\mathbf{w}_{n}(p_{n}(t))
  </annotation>
 </semantics>
</math>

,
</dd>
</dl>
</dd>
</dl>

<p>namely it generates core tensor 

<math display="inline" id="TP_model_transformation_in_control_theory:31">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

 and weighting functions of 

<math display="inline" id="TP_model_transformation_in_control_theory:32">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐰</mi>
    <mi>n</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>p</mi>
      <mi>n</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐰</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>n</ci>
     </apply>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{w}_{n}(p_{n}(t))
  </annotation>
 </semantics>
</math>

 for all 

<math display="inline" id="TP_model_transformation_in_control_theory:33">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">…</mi>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>n</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=1\ldots N
  </annotation>
 </semantics>
</math>

. Its free MATLAB implementation is downloadable at <a href="http://tptool.sztaki.hu/">1</a> or at MATLAB Central <a href="http://www.mathworks.com/matlabcentral/fileexchange/25514-tp-tool">2</a>.</p>

<p>If the given model does not have (finite element) TP polytopic structure, then the TP model transformation determines its approximation:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="TP_model_transformation_in_control_theory:34">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝐒</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>𝐩</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≈</mo>
    <mrow>
     <mrow>
      <mi class="ltx_font_mathcaligraphic">𝒮</mi>
      <msubsup>
       <mo>⊠</mo>
       <mrow>
        <mi>n</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>N</mi>
      </msubsup>
      <msub>
       <mi>𝐰</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>p</mi>
        <mi>n</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>𝐒</ci>
     <apply>
      <times></times>
      <ci>𝐩</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-⊠</ci>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <ci>𝒮</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐰</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{S}(\mathbf{p}(t))\approx\mathcal{S}\boxtimes_{n=1}^{N}\mathbf{w}_{n}(p%
_{n}(t)),
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where trade-off is offered by the TP model transformation between complexity (number of vertexes stored in the core tensor or the number of weighting functions) and the approximation accuracy.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The TP model can be generated according to various constrains. Typical TP models generated by the TP model transformation are:</p>
<ul>
<li>HOSVD canonical form of qLPV models,</li>
<li>Various kinds of TP type polytopic form (this feature is very important in control performance optimization).</li>
</ul>
<h2 id="tp-model-based-control-design">TP model based control design</h2>
<dl>
<dt>Key methodology:</dt>
</dl>

<p>Since the TP type polytopic model is a subset of the polytopic model representations, the analysis and design methodologies developed for polytopic representations are applicable for the TP type polytopic models as well. One typical way is to search the nonlinear controller in the form:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="TP_model_transformation_in_control_theory:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>𝐅</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>𝐩</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>𝐱</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>r</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>R</mi>
      </msubsup>
      <mrow>
       <msub>
        <mi>F</mi>
        <mi>r</mi>
       </msub>
       <msub>
        <mi>w</mi>
        <mi>r</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>𝐩</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>t</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>𝐱</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>u</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>𝐅</ci>
       <apply>
        <times></times>
        <ci>𝐩</ci>
        <ci>t</ci>
       </apply>
       <ci>𝐱</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>r</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>R</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>F</ci>
         <ci>r</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <ci>r</ci>
        </apply>
        <apply>
         <times></times>
         <ci>𝐩</ci>
         <ci>t</ci>
        </apply>
        <ci>𝐱</ci>
        <ci>t</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u=-\mathbf{F}(\mathbf{p}(t))\mathbf{x}(t)=-\sum_{r=1}^{R}F_{r}w_{r}(\mathbf{p}%
(t))\mathbf{x}(t),
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where the vertexes 

<math display="inline" id="TP_model_transformation_in_control_theory:36">
 <semantics>
  <msub>
   <mi>𝐅</mi>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐅</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{F}_{r}
  </annotation>
 </semantics>
</math>

 of the controller is calculated from 

<math display="inline" id="TP_model_transformation_in_control_theory:37">
 <semantics>
  <msub>
   <mi>𝐒</mi>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐒</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{S}_{r}
  </annotation>
 </semantics>
</math>

. Typically, the vertexes 

<math display="inline" id="TP_model_transformation_in_control_theory:38">
 <semantics>
  <msub>
   <mi>𝐒</mi>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐒</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{S}_{r}
  </annotation>
 </semantics>
</math>

 are substituted into Linear Matrix Inequalities in order to determine 

<math display="inline" id="TP_model_transformation_in_control_theory:39">
 <semantics>
  <msub>
   <mi>𝐅</mi>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐅</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{F}_{r}
  </annotation>
 </semantics>
</math>

.</p>

<p>In TP type polytopic form the controller is:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="TP_model_transformation_in_control_theory:40">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>𝐅</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>𝐩</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>𝐱</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <mi class="ltx_font_mathcaligraphic">ℱ</mi>
       <msubsup>
        <mo>⊠</mo>
        <mrow>
         <mi>n</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>N</mi>
       </msubsup>
       <msub>
        <mi>𝐰</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>p</mi>
         <mi>n</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>𝐱</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>u</ci>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>𝐅</ci>
       <apply>
        <times></times>
        <ci>𝐩</ci>
        <ci>t</ci>
       </apply>
       <ci>𝐱</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>normal-⊠</ci>
          <apply>
           <eq></eq>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>N</ci>
        </apply>
        <ci>ℱ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐰</ci>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>n</ci>
        </apply>
        <ci>t</ci>
       </apply>
       <ci>𝐱</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u=-\mathbf{F}(\mathbf{p}(t))\mathbf{x}(t)=-\mathcal{F}\boxtimes_{n=1}^{N}%
\mathbf{w}_{n}(p_{n}(t))\mathbf{x}(t),
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where the vertexes 

<math display="inline" id="TP_model_transformation_in_control_theory:41">
 <semantics>
  <msub>
   <mi>𝐅</mi>
   <mrow>
    <msub>
     <mi>i</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>i</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>i</mi>
     <mi>N</mi>
    </msub>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐅</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>i</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>i</ci>
      <ci>N</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{F}_{i_{1},i_{2},\ldots,i_{N}}
  </annotation>
 </semantics>
</math>

 stored in the core tensor 

<math display="inline" id="TP_model_transformation_in_control_theory:42">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

 are determined from the vertexes 

<math display="inline" id="TP_model_transformation_in_control_theory:43">
 <semantics>
  <msub>
   <mi>𝐒</mi>
   <mrow>
    <msub>
     <mi>i</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>i</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>i</mi>
     <mi>N</mi>
    </msub>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐒</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>i</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>i</ci>
      <ci>N</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{S}_{i_{1},i_{2},\ldots,i_{N}}
  </annotation>
 </semantics>
</math>

 stored in 

<math display="inline" id="TP_model_transformation_in_control_theory:44">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

. Note that the polytopic observer or other components can be generated in similar way, such as these vertexes are also generated from 

<math display="inline" id="TP_model_transformation_in_control_theory:45">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

.</p>
<dl>
<dt>Convex hull manipulation based optimization:</dt>
</dl>

<p>The polytopic representation of a given qLPV model is not invariant. I.e. a given 

<math display="inline" id="TP_model_transformation_in_control_theory:46">
 <semantics>
  <mrow>
   <mi>𝐒</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>𝐩</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐒</ci>
    <apply>
     <times></times>
     <ci>𝐩</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{S}(\mathbf{p}(t))
  </annotation>
 </semantics>
</math>

 has 

<math display="inline" id="TP_model_transformation_in_control_theory:47">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>=</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>Z</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z=\infty
  </annotation>
 </semantics>
</math>

 number of different representation as:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="TP_model_transformation_in_control_theory:48">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝐒</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>𝐩</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi class="ltx_font_mathcaligraphic">𝒮</mi>
       <mi>z</mi>
      </msub>
      <msubsup>
       <mo>⊠</mo>
       <mrow>
        <mi>n</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>N</mi>
      </msubsup>
      <msub>
       <mi>𝐰</mi>
       <mrow>
        <mi>z</mi>
        <mo>,</mo>
        <mi>n</mi>
       </mrow>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>p</mi>
        <mi>n</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝐒</ci>
     <apply>
      <times></times>
      <ci>𝐩</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-⊠</ci>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝒮</ci>
       <ci>z</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐰</ci>
       <list>
        <ci>z</ci>
        <ci>n</ci>
       </list>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{S}(\mathbf{p}(t))=\mathcal{S}_{z}\boxtimes_{n=1}^{N}\mathbf{w}_{z,n}(p%
_{n}(t)),
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where 

<math display="inline" id="TP_model_transformation_in_control_theory:49">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">…</mi>
    <mi>Z</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>z</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>Z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z=1\ldots Z
  </annotation>
 </semantics>
</math>

. In order to generate an optimal control of the given model 

<math display="inline" id="TP_model_transformation_in_control_theory:50">
 <semantics>
  <mrow>
   <mi>𝐒</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>𝐩</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐒</ci>
    <apply>
     <times></times>
     <ci>𝐩</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{S}(\mathbf{p}(t))
  </annotation>
 </semantics>
</math>

 we apply, for instance LMIs. Thus, if we apply the selected LMIs to the above polytopic model we arrive at:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="TP_model_transformation_in_control_theory:51">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>u</mi>
     <mi>z</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>𝐅</mi>
       <mi>z</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>𝐩</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>𝐱</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <msub>
        <mi class="ltx_font_mathcaligraphic">ℱ</mi>
        <mi>z</mi>
       </msub>
       <msubsup>
        <mo>⊠</mo>
        <mrow>
         <mi>n</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>N</mi>
       </msubsup>
       <msub>
        <mi>𝐰</mi>
        <mrow>
         <mi>z</mi>
         <mo>,</mo>
         <mi>n</mi>
        </mrow>
       </msub>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>p</mi>
         <mi>n</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>𝐱</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>u</ci>
      <ci>z</ci>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐅</ci>
        <ci>z</ci>
       </apply>
       <apply>
        <times></times>
        <ci>𝐩</ci>
        <ci>t</ci>
       </apply>
       <ci>𝐱</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>normal-⊠</ci>
          <apply>
           <eq></eq>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>N</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ℱ</ci>
         <ci>z</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐰</ci>
         <list>
          <ci>z</ci>
          <ci>n</ci>
         </list>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>n</ci>
        </apply>
        <ci>t</ci>
       </apply>
       <ci>𝐱</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{z}=-\mathbf{F}_{z}(\mathbf{p}(t))\mathbf{x}(t)=-\mathcal{F}_{z}\boxtimes_{n%
=1}^{N}\mathbf{w}_{z,n}(p_{n}(t))\mathbf{x}(t).
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>Since the LMIs realize a non-linear mapping between the vertexes in 

<math display="inline" id="TP_model_transformation_in_control_theory:52">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">𝒮</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝒮</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{S}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="TP_model_transformation_in_control_theory:53">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ℱ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ℱ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{F}
  </annotation>
 </semantics>
</math>

 we may find very different controllers for each 

<math display="inline" id="TP_model_transformation_in_control_theory:54">
 <semantics>
  <mrow>
   <mi>z</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">…</mi>
    <mi>Z</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>z</ci>
    <apply>
     <times></times>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>Z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z=1\ldots Z
  </annotation>
 </semantics>
</math>

. This means that we have 

<math display="inline" id="TP_model_transformation_in_control_theory:55">
 <semantics>
  <mi>Z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z
  </annotation>
 </semantics>
</math>

 different number of "optimal" controllers to the same system 

<math display="inline" id="TP_model_transformation_in_control_theory:56">
 <semantics>
  <mrow>
   <mi>𝐒</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>𝐩</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐒</ci>
    <apply>
     <times></times>
     <ci>𝐩</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{S}(\mathbf{p}(t))
  </annotation>
 </semantics>
</math>

. Thus, the question is: which one of the "optimal" controllers is really the optimal one. The TP model transformation let us to manipulate the weighting functions systematically that is equivalent to the manipulation of the vertexes. The geometrical meaning of this manipulation is the manipulation of the convex hull defined by the vertexes. We can easily demonstrate the following facts:</p>
<ul>
<li>Tightening the convex hull typically decreases the conservativeness of the solution, so as may lead to better control performance. For instance, if we have a polytopic representation</li>
</ul>
<dl>
<dd><dl>
<dd>

<math display="inline" id="TP_model_transformation_in_control_theory:57">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>𝐒</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>𝐩</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi class="ltx_font_mathcaligraphic">𝒮</mi>
      <msubsup>
       <mo>⊠</mo>
       <mrow>
        <mi>n</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>N</mi>
      </msubsup>
      <msub>
       <mi>𝐰</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>p</mi>
        <mi>n</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>𝐒</ci>
     <apply>
      <times></times>
      <ci>𝐩</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-⊠</ci>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <ci>𝒮</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐰</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{S}(\mathbf{p}(t))=\mathcal{S}\boxtimes_{n=1}^{N}\mathbf{w}_{n}(p_{n}(t%
)),
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>of a given model 

<math display="inline" id="TP_model_transformation_in_control_theory:58">
 <semantics>
  <mrow>
   <mi>𝐒</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>𝐩</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝐒</ci>
    <apply>
     <times></times>
     <ci>𝐩</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{S}(\mathbf{p}(t))
  </annotation>
 </semantics>
</math>

, then we can generate a controller as</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="TP_model_transformation_in_control_theory:59">
 <semantics>
  <mrow>
   <mrow>
    <mi>u</mi>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <mi class="ltx_font_mathcaligraphic">ℱ</mi>
       <msubsup>
        <mo>⊠</mo>
        <mrow>
         <mi>n</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>N</mi>
       </msubsup>
       <msub>
        <mi>𝐰</mi>
        <mi>n</mi>
       </msub>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>p</mi>
         <mi>n</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>𝐱</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>u</ci>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-⊠</ci>
         <apply>
          <eq></eq>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>N</ci>
       </apply>
       <ci>ℱ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐰</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>n</ci>
       </apply>
       <ci>t</ci>
      </apply>
      <ci>𝐱</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u=-\mathcal{F}\boxtimes_{n=1}^{N}\mathbf{w}_{n}(p_{n}(t))\mathbf{x}(t),
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>then we solved the control problem of all systems 

<math display="inline" id="TP_model_transformation_in_control_theory:60">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mi mathvariant="normal">…</mi>
    <mi>K</mi>
   </mrow>
   <mo>=</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>k</ci>
     <apply>
      <times></times>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <ci>K</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <infinity></infinity>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=1\ldots K=\infty
  </annotation>
 </semantics>
</math>

 that can be given by the same vertexes, but with different weighting functions as:</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="TP_model_transformation_in_control_theory:61">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>𝐒</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>𝐩</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi class="ltx_font_mathcaligraphic">𝒮</mi>
      <msubsup>
       <mo>⊠</mo>
       <mrow>
        <mi>n</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>N</mi>
      </msubsup>
      <msub>
       <mi>𝐰</mi>
       <mrow>
        <mi>k</mi>
        <mo>,</mo>
        <mi>n</mi>
       </mrow>
      </msub>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>p</mi>
        <mi>n</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐒</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <ci>𝐩</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>normal-⊠</ci>
        <apply>
         <eq></eq>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <ci>𝒮</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐰</ci>
       <list>
        <ci>k</ci>
        <ci>n</ci>
       </list>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>n</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{S}_{k}(\mathbf{p}(t))=\mathcal{S}\boxtimes_{n=1}^{N}\mathbf{w}_{k,n}(p%
_{n}(t)),
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>where</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="TP_model_transformation_in_control_theory:62">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>u</mi>
     <mi>k</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <mi class="ltx_font_mathcaligraphic">ℱ</mi>
       <msubsup>
        <mo>⊠</mo>
        <mrow>
         <mi>n</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>N</mi>
       </msubsup>
       <msub>
        <mi>𝐰</mi>
        <mrow>
         <mi>k</mi>
         <mo>,</mo>
         <mi>n</mi>
        </mrow>
       </msub>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>p</mi>
         <mi>n</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>𝐱</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-⊠</ci>
         <apply>
          <eq></eq>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>N</ci>
       </apply>
       <ci>ℱ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐰</ci>
        <list>
         <ci>k</ci>
         <ci>n</ci>
        </list>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>n</ci>
       </apply>
       <ci>t</ci>
      </apply>
      <ci>𝐱</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{k}=-\mathcal{F}\boxtimes_{n=1}^{N}\mathbf{w}_{k,n}(p_{n}(t))\mathbf{x}(t).
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>If one of these systems are very hardly controllable (or even uncontrollable) then we arrive at a very conservative solution (or unfeasible LMIs). Therefore we expect that during tightening the convex hull we exclude such problematic systems.</p>
<ul>
<li>It can also be easily demonstrated that the observer design is typically needs large convex hull. So, as when we design controller and observer we need to find the optimal convex hull between the tight one and the large one. Same papers also demonstrate that using different convex hulls (if the separation principal is applicable) for observer and controller may lead to even better solution.</li>
</ul>
<h2 id="properties-of-the-tp-model-transformation-in-qlpv-theories">Properties of the TP model transformation in qLPV theories</h2>
<ul>
<li>It can be executed uniformly (irrespective of whether the model is given in the form of analytical equations resulting from physical considerations, or as an outcome of soft computing based identification techniques (such as neural networks or fuzzy logic based methods, or as a result of a black-box identification), without analytical interaction, within a reasonable amount of time. Thus, the transformation replaces the analytical and in many cases complex and not obvious conversions to numerical, tractable, straightforward operations that can be carried out in a routine fashion.</li>
</ul>
<ul>
<li>It generates the HOSVD-based canonical form of qLPV models, which is a unique representation. This form extracts the unique structure of a given qLPV model in the same sense as the HOSVD does for tensors and matrices, in a way such that:</li>
</ul>

<p>:* the number of LTI components are minimized;</p>

<p>:* the weighting functions are one variable functions of the parameter vector in an orthonormed system for each parameter (singular functions);</p>

<p>:* the LTI components (vertex components) are also in orthogonal positions;</p>

<p>:* the LTI systems and the weighting functions are ordered according to the higher-order singular values of the parameter vector;</p>

<p>:* it has a unique form (except for some special cases);</p>

<p>:* introduces and defines the rank of the qLPV model by the dimensions of the parameter vector;</p>
<ul>
<li>The core step of the TP model transformation was extended to generate different types of convex polytopic models, in order to focus on the systematic (numerical and automatic) modification of the convex hull instead of developing new LMI equations for feasible controller design (this is the widely adopted approach). It is worth noting that both the TP model transformation and the LMI-based control design methods are numerically executable one after the other, and this makes the resolution of a wide class of problems possible in a straightforward and tractable, numerical way.</li>
</ul>
<ul>
<li>Based on the higher-order singular values (which express the rank properties of the given qLPV model, see above, for each element of the parameter vector in 

<math display="inline" id="TP_model_transformation_in_control_theory:63">
 <semantics>
  <msub>
   <mi>L</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{2}
  </annotation>
 </semantics>
</math>

 norm), the TP model transformation offers a trade-off between the complexity of the TP model (polytopic form),<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> hence, the LMI design and the accuracy of the resulting TP model.</li>
</ul>
<ul>
<li>The TP model transformation is executed before utilizing the LMI design. This means that when we start the LMI design we already have the global weighting functions and during control we do not need to determine a local weighting of the LTI systems for feedback gains to compute the control value at every point of the hyperspace the system should go through. Having predefined continuous weighting functions also ensures that there is no friction in the weighting during control.</li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>'</p>

<p><a href="Category:Control_theory" title="wikilink">Category:Control theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">P. Baranyi (April 2004). "TP model transformation as a way to LMI based controller design". IEEE Transaction on Industrial Electronics 51 (2): 387–400.<a href="#fnref1">↩</a></li>
<li id="fn2">P. Baranyi and D. Tikk and Y. Yam and R. J. Patton (2003). "From Differential Equations to PDC Controller Design via Numerical Transformation". Computers in Industry, Elsevier Science 51: 281–297.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
</ol>
</section>
</body>
</html>
