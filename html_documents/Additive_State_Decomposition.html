<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1651">Additive State Decomposition</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Additive State Decomposition</h1>
<hr/>

<p><strong>Additive state decomposition</strong> occurs when a <a class="uri" href="system" title="wikilink">system</a> is decomposed into two or more <a href="subsystem" title="wikilink">subsystems</a> with the same <a class="uri" href="dimension" title="wikilink">dimension</a> as that of the original system. A commonly-used decomposition in the control field is to decompose a system into two or more lower-order subsystems, called lower-order subsystem decomposition here. In contrast, additive state decomposition is to decompose a system into two or more subsystems with the same dimension as that of the original system.</p>

<p>Taking a system <mtpl></mtpl> for example, it is decomposed into two subsystems: <mtpl></mtpl> and <mtpl></mtpl>, where <mtpl> <var>n<sub>p</sub></var>}}</mtpl> and <mtpl> <var>n<sub>s</sub></var>}}</mtpl>, respectively. The lower-order subsystem decomposition satisfies</p>

<p>

<math display="block" id="Additive_State_Decomposition:0">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>n</mi>
     <mi>p</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>n</mi>
      <mi>s</mi>
     </msub>
     <mtext>and</mtext>
     <mi>P</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>P</mi>
     <mi>p</mi>
    </msub>
    <mo>⊕</mo>
    <msub>
     <mi>P</mi>
     <mi>s</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>n</ci>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>s</ci>
       </apply>
       <mtext>and</mtext>
       <ci>P</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=n_{p}+n_{s}\text{ and }P=P_{p}\oplus P_{s}
  </annotation>
 </semantics>
</math>

</p>

<p>By contrast, the additive state decomposition satisfies</p>

<p>

<math display="block" id="Additive_State_Decomposition:1">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>=</mo>
   <msub>
    <mi>n</mi>
    <mi>p</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>n</mi>
     <mi>s</mi>
    </msub>
    <mtext>and</mtext>
    <mi>P</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>P</mi>
     <mi>p</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>P</mi>
     <mi>s</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>n</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>p</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>s</ci>
      </apply>
      <mtext>and</mtext>
      <ci>P</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>p</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <ci>s</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n=n_{p}=n_{s}\text{ and }P=P_{p}+P_{s}
  </annotation>
 </semantics>
</math>

<br/>
<br/>
</p>
<h2 id="additive-state-decomposition-on-a-dynamical-control-system">Additive state decomposition on a dynamical control system</h2>

<p>Consider an ‘original’ system as follows:  where 

<math display="inline" id="Additive_State_Decomposition:2">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msup>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\R</mtext>
    </merror>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <mtext>\R</mtext>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\R^{n}
  </annotation>
 </semantics>
</math>

.</p>

<p>First, a ‘primary’ system is brought in, having the same dimension as the original system:  where 

<math display="inline" id="Additive_State_Decomposition:3">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>p</mi>
    </msub>
    <mo>∈</mo>
    <msup>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\R</mtext>
     </merror>
     <mi>n</mi>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>p</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <mtext>\R</mtext>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{p}\in\R^{n}.
  </annotation>
 </semantics>
</math>

</p>

<p>From the original system and the primary system, the following ‘secondary’ system is derived:</p>

<p>

<math display="block" id="Additive_State_Decomposition:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mover accent="true">
      <mi>x</mi>
      <mo>˙</mo>
     </mover>
     <mo>-</mo>
     <msub>
      <mover accent="true">
       <mi>x</mi>
       <mo>˙</mo>
      </mover>
      <mi>p</mi>
     </msub>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <mi>x</mi>
       <mo>,</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>f</mi>
       <mi>p</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mi>p</mi>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>u</mi>
        <mi>p</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <minus></minus>
      <apply>
       <ci>normal-˙</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <ci>normal-˙</ci>
        <ci>x</ci>
       </apply>
       <ci>p</ci>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>f</ci>
       <vector>
        <ci>t</ci>
        <ci>x</ci>
        <ci>u</ci>
       </vector>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>p</ci>
       </apply>
       <vector>
        <ci>t</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>p</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>p</ci>
        </apply>
       </vector>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{x}-\dot{x}_{p}=f(t,x,u)-f_{p}(t,x_{p},u_{p}),x(0)=x_{0}
  </annotation>
 </semantics>
</math>

 New variables 

<math display="inline" id="Additive_State_Decomposition:5">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>s</mi>
   </msub>
   <mo>∈</mo>
   <msup>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\R</mtext>
    </merror>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>s</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <mtext>\R</mtext>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{s}\in\R^{n}
  </annotation>
 </semantics>
</math>

 are defined as follows:  Then the secondary system can be further written as follows:  From the definition (), it follows</p>

<p>

<math display="block" id="Additive_State_Decomposition:6">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>p</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mi>s</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>p</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>s</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(t)=x_{p}(t)+x_{s}(t),
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Additive_State_Decomposition:7">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>≥</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>t</ci>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\geq 0.
  </annotation>
 </semantics>
</math>

</p>

<p>The process is shown in this picture:<br/>
</p>
<h2 id="examples">Examples</h2>
<h3 id="example1">Example1</h3>

<p>In fact, the idea of the additive state decomposition has been implicitly mentioned in existing literature. An existing example is the tracking controller design, which often requires a reference system to derive error dynamics. The reference system (primary system) is assumed to be given as follows:</p>

<p>

<math display="block" id="Additive_State_Decomposition:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>x</mi>
      <mo>˙</mo>
     </mover>
     <mi>r</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo>,</mo>
      <msub>
       <mi>x</mi>
       <mi>r</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>u</mi>
       <mi>r</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-˙</ci>
      <ci>x</ci>
     </apply>
     <ci>r</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <vector>
      <ci>t</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>r</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>r</ci>
      </apply>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{x}_{r}=f(t,x_{r},u_{r}),
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Additive_State_Decomposition:9">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>r</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mrow>
     <mi>r</mi>
     <mo>,</mo>
     <mn>0</mn>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>r</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <list>
      <ci>r</ci>
      <cn type="integer">0</cn>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{r}(0)=x_{r,0}
  </annotation>
 </semantics>
</math>

 Based on the reference system, the error dynamics (secondary system) are derived as follows:</p>

<p>

<math display="block" id="Additive_State_Decomposition:10">
 <semantics>
  <msub>
   <mover accent="true">
    <mi>x</mi>
    <mo>˙</mo>
   </mover>
   <mi>e</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <ci>normal-˙</ci>
     <ci>x</ci>
    </apply>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{x}_{e}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Additive_State_Decomposition:11">
 <semantics>
  <mrow>
   <mrow>
    <mi></mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mi>e</mi>
        </msub>
        <mo>+</mo>
        <msub>
         <mi>x</mi>
         <mi>r</mi>
        </msub>
       </mrow>
       <mo>,</mo>
       <mi>u</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <msub>
        <mi>x</mi>
        <mi>r</mi>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>u</mi>
        <mi>r</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>f</ci>
      <vector>
       <ci>t</ci>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>e</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>r</ci>
        </apply>
       </apply>
       <ci>u</ci>
      </vector>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <vector>
       <ci>t</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>r</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <ci>r</ci>
       </apply>
      </vector>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   =f(t,x_{e}+x_{r},u)-f(t,x_{r},u_{r}),
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Additive_State_Decomposition:12">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>x</mi>
     <mi>e</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>0</mn>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>x</mi>
     <mrow>
      <mi>r</mi>
      <mo>,</mo>
      <mn>0</mn>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>e</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <list>
       <ci>r</ci>
       <cn type="integer">0</cn>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{e}(0)=x_{0}-x_{r,0}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Additive_State_Decomposition:13">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>e</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mo>-</mo>
    <msub>
     <mi>x</mi>
     <mi>r</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>e</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{e}=x-x_{r}
  </annotation>
 </semantics>
</math>

</p>

<p>This is a commonly-used step to transform a tracking problem to a stabilization problem when adaptive control is used.</p>
<h3 id="example2">Example2</h3>

<p>Consider a class of systems as follows:</p>

<p>Choose () as the original system and design the primary system as follows:</p>

<p>Then the secondary system is determined by the rule ():</p>

<p>By additive state decomposition</p>

<p>

<math display="block" id="Additive_State_Decomposition:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>e</mi>
      <mi>p</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>e</mi>
      <mi>s</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>p</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>s</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e(t)=e_{p}(t)+e_{s}(t)
  </annotation>
 </semantics>
</math>

</p>

<p>Since</p>

<p>

<math display="block" id="Additive_State_Decomposition:15">
 <semantics>
  <mrow>
   <mrow>
    <mo>∥</mo>
    <mrow>
     <mi>e</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∥</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <msub>
       <mi>e</mi>
       <mi>p</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <msub>
       <mi>e</mi>
       <mi>s</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <times></times>
      <ci>e</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <ci>p</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>e</ci>
        <ci>s</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|e(t)\|\leq\|e_{p}(t)\|+\|e_{s}(t)\|
  </annotation>
 </semantics>
</math>

 the tracking error <mtpl></mtpl> can be analyzed by <mtpl> and <mtpl></mtpl> separately. If <mtpl> and <mtpl></mtpl> are bounded and small, then so is <mtpl></mtpl>. Fortunately, note that () is a linear time-invariant system and is independent of the secondary system (), for the analysis of which many tools such as the transfer function are available. By contrast, the transfer function tool cannot be directly applied to the original system () as it is time-varying.</mtpl></mtpl></p>
<h3 id="example-3">Example 3</h3>

<p>Consider a class of nonlinear systems as follows:</p>

<p>where <mtpl></mtpl> represent the state, output and input, respectively; the function <mtpl></mtpl> is nonlinear. The objective is to design <mtpl></mtpl> such that <mtpl></mtpl> as <mtpl></mtpl>. Choose () as the original system and design the primary system as follows:</p>

<p>Then the secondary system is determined by the rule ():</p>

<p>where <mtpl> <var>u<sub>p</sub></var>}}</mtpl>. Then <mtpl> <var>x<sub>p</sub></var> + <var>x<sub>s</sub></var>}}</mtpl> and <mtpl> <var>y<sub>p</sub></var> + <var>y<sub>s</sub></var>}}</mtpl>. Here, the task <mtpl></mtpl> is assigned to the linear time-invariant system () (a linear time-invariant system being simpler than a nonlinear one). On ther other hand, the task <mtpl></mtpl> is assigned to the nonlinear system () (a stabilizing control problem is simpler than a tracking problem). If the two tasks are accomplished, then <mtpl> <var>y<sub>p</sub></var> + <var>y<sub>s</sub></var> → 0}}</mtpl>. The basic idea is to decompose an original system into two subsystems in charge of simpler subtasks. Then one designs controllers for two subtasks, and finally combines them to achieve the original control task.The process is shown in this picture:<br/>
</p>
<h2 id="comparison-with-superposition-principle">Comparison with <a href="superposition_principle" title="wikilink">superposition principle</a></h2>

<p>A well-known example implicitly using additive state decomposition is the Superposition Principle, widely used in physics and engineering.<br/>
<a href="superposition_principle" title="wikilink">superposition principle</a>: For all linear systems, the net response at a given place and time caused by two or more stimuli is the sum of the responses which would have been caused by each stimulus individually. For a simple linear system:</p>

<p>

<math display="block" id="Additive_State_Decomposition:16">
 <semantics>
  <mrow>
   <mover accent="true">
    <mi>x</mi>
    <mo>˙</mo>
   </mover>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>A</mi>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>B</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>u</mi>
        <mn>1</mn>
       </msub>
       <mo>+</mo>
       <msub>
        <mi>u</mi>
        <mn>2</mn>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>normal-˙</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>B</ci>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{x}=Ax+B(u_{1}+u_{2})
  </annotation>
 </semantics>
</math>

 , 

<math display="inline" id="Additive_State_Decomposition:17">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(0)=0
  </annotation>
 </semantics>
</math>

 the statement of the superposition principle means <mtpl> <var>x<sub>p</sub></var> + <var>x<sub>s</sub></var>}}</mtpl>, where</p>

<p>

<math display="block" id="Additive_State_Decomposition:18">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>x</mi>
      <mo>˙</mo>
     </mover>
     <mi>p</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>A</mi>
      <msub>
       <mi>x</mi>
       <mi>p</mi>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>B</mi>
      <msub>
       <mi>u</mi>
       <mn>1</mn>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>p</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-˙</ci>
       <ci>x</ci>
      </apply>
      <ci>p</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>A</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>p</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>B</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>p</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{x}_{p}=Ax_{p}+Bu_{1},x_{p}(0)=0
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Additive_State_Decomposition:19">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mover accent="true">
      <mi>x</mi>
      <mo>˙</mo>
     </mover>
     <mi>s</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>A</mi>
      <msub>
       <mi>x</mi>
       <mi>s</mi>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>B</mi>
      <msub>
       <mi>u</mi>
       <mn>2</mn>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>x</mi>
      <mi>s</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <ci>normal-˙</ci>
       <ci>x</ci>
      </apply>
      <ci>s</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>A</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>s</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>B</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>u</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>s</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \dot{x}_{s}=Ax_{s}+Bu_{2},x_{s}(0)=0
  </annotation>
 </semantics>
</math>

</p>

<p>Obviously, this result can also be derived from the additive state decomposition. Moreover, the superposition principle and additive state decomposition have the following relationship. From Table 1, additive state decomposition can be applied not only to linear systems but also nonlinear systems.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">
<p>Suitable Systems</p></th>
<th style="text-align: left;">
<p>Emphasis</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Superposition Principle</p></td>
<td style="text-align: left;">
<p>Linear</p></td>
<td style="text-align: left;">
<p>Superposition</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Additive State Decomposition</p></td>
<td style="text-align: left;">
<p>Linear\Nonlinear</p></td>
<td style="text-align: left;">
<p>Decomposition</p></td>
</tr>
<tr class="odd">
</tr>
</tbody>
</table>
<h2 id="applications">Applications</h2>

<p>Additive state decomposition is used in stabilizing control,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and can be extended to additive output decomposition.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Quan, Quan and Kai-Yuan Cai (2009). "Additive Decomposition and Its applications to Internal-Model-Based Tracking,". <em>Joint 48th IEEE Conference on Decision and Control and 28th Chinese Control Conference</em>, Shanghai, China. 817-822.</li>
<li>Quan Quan, Hai Lin, Kai-Yuan Cai (2014). "Output Feedback Tracking Control by Additive State Decomposition for a Class of Uncertain Systems," <em>International Journal of Systems Science</em> <strong>45</strong>(9): 1799–1813.</li>
<li>Quan Quan, Kai-Yuan Cai, Hai Lin (2015). "Additive-State-Decomposition-Based Tracking Control Framework for a Class of Nonminimum Phase Systems with Measurable Nonlinearities and Unknown Disturbances," <em>International Journal of Robust and Nonlinear Control</em> <strong>25</strong>(2):163-178</li>
<li>Quan Quan, Lu Jiang, Kai-Yuan Cai. <a href="http://arxiv.org/abs/1401.1577">"Discrete-Time Output-Feedback Robust Repetitive Control for a Class of Nonlinear Systems by Additive State Decomposition"</a></li>
</ul>

<p>"</p>

<p><a href="Category:Nonlinear_systems" title="wikilink">Control theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Quan Quan, Guangxun Du, Kai-Yuan Cai. "Additive-State-Decomposition Dynamic Inversion Stabilized Control for a Class of Uncertain MIMO Systems," <a class="uri" href="http://arxiv.org/abs/1211.6821">http://arxiv.org/abs/1211.6821</a><a href="#fnref1">↩</a></li>
<li id="fn2">Quan Quan, Kai-Yuan Cai. "Additive-Output-Decomposition-Based Dynamic Inversion Tracking Control for a Class of Uncertain Linear Time-Invariant Systems," The 51st IEEE Conference on Decision and Control, 2012, Maui, Hawaii, USA, 2866-2871.<a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
