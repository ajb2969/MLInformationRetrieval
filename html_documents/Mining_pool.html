<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1079">Mining pool</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Mining pool</h1>
<hr/>

<p>In the context of <a class="uri" href="cryptocurrency" title="wikilink">cryptocurrency</a> mining, a <strong>mining pool</strong> is the pooling of resources by miners, who share their processing power over a network, to split the reward equally, according to the amount of work they contributed to solving a block. A "share" is awarded to members of the mining pool who present a valid proof of work that their miner solved. Mining in pools began when the difficulty for mining increased to the point where it could take years for slower miners to generate a block. The solution to this problem was for miners to pool their resources so they could generate blocks more quickly and therefore receive a portion of the block reward on a consistent basis, rather than randomly once every few years.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="mining-pool-methods">Mining pool methods</h2>

<p>In all these schemes 

<math display="inline" id="Mining_pool:0">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 stands for a block reward minus pool fee and 

<math display="inline" id="Mining_pool:1">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 is a probability of finding a block in a share attempt (

<math display="inline" id="Mining_pool:2">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>p</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p=1/D
  </annotation>
 </semantics>
</math>

, where D is current block difficulty). A pool can support "variable share difficulty" feature, which means that a miner can select the share target (the lower bound of share difficulty) on his own and change 

<math display="inline" id="Mining_pool:3">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 accordingly.</p>
<h3 id="pay-per-share">Pay-per-Share</h3>

<p>The Pay-per-Share (PPS) approach offers an instant, guaranteed payout for each share that is solved by a miner. Miners are paid out from the pools existing balance and can withdraw their payout immediately. This model allows for the least possible variance in payment for miners while also transferring much of the risk to the pool's operator.</p>

<p>Each share costs exactly the expected value of each hash attempt 

<math display="inline" id="Mining_pool:4">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mrow>
    <mi>B</mi>
    <mo>⋅</mo>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <apply>
     <ci>normal-⋅</ci>
     <ci>B</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=B\cdot p
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="proportional">Proportional</h3>

<p>Miners earn shares until the pool finds a block (the end of the mining round). After that each user gets reward 

<math display="inline" id="Mining_pool:5">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>=</mo>
   <mrow>
    <mi>B</mi>
    <mo>⋅</mo>
    <mfrac>
     <mi>n</mi>
     <mi>N</mi>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>R</ci>
    <apply>
     <ci>normal-⋅</ci>
     <ci>B</ci>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <ci>N</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R=B\cdot\frac{n}{N}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Mining_pool:6">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is amount of his own shares, and 

<math display="inline" id="Mining_pool:7">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 is amount of all shares in this round. In other words, all shares are equal, but its cost is calculated only in the end of a round.</p>
<h3 id="bitcoin-pooled-mining">Bitcoin Pooled mining</h3>

<p>Bitcoin Pooled mining (BPM), also known as "slush's system", due to its first use on a pool called "slush's pool', uses a system where older shares from the beginning of a block round are given less weight than more recent shares. This reduces the ability to cheat the mining pool system by switching pools during a round, to maximise profit,</p>
<h3 id="pay-per-last-n-shares">Pay-per-last-N-shares</h3>

<p>PPLNS method is similar to <strong>Proportional</strong>, but the miner's reward is calculated on a basis of N last shares, instead of all shares for the last round. Therefore, if the round was short enough all miners get more profit, and vice versa.</p>
<h3 id="geometric-method">Geometric method</h3>

<p>GM was invented by Meni Rosenfeld.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> It is based on the same "score" idea, as Slush's method: the score granted for every new share, relatively to already existing score and the score of future shares, is always the same, thus there is no advantage to mining early or late in the round.</p>

<p>The method goes as follows:</p>
<ul>
<li>Choose parameters 

<math display="inline" id="Mining_pool:8">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Mining_pool:9">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 (fixed and variable fee).</li>
<li>At the start of every round, set 

<math display="inline" id="Mining_pool:10">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=1
  </annotation>
 </semantics>
</math>

. For every worker 

<math display="inline" id="Mining_pool:11">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, let 

<math display="inline" id="Mining_pool:12">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{k}
  </annotation>
 </semantics>
</math>

 be the worker’s score for this round, and set 

<math display="inline" id="Mining_pool:13">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>k</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{k}=0
  </annotation>
 </semantics>
</math>

.</li>
<li>Set 

<math display="inline" id="Mining_pool:14">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>1</mn>
     <mo>-</mo>
     <mi>p</mi>
    </mrow>
    <mo>+</mo>
    <mfrac>
     <mi>p</mi>
     <mi>c</mi>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>r</ci>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>p</ci>
     </apply>
     <apply>
      <divide></divide>
      <ci>p</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=1-p+\frac{p}{c}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Mining_pool:15">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mi>D</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>p</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p=1/D
  </annotation>
 </semantics>
</math>

. If the difficulty changes during the round, 

<math display="inline" id="Mining_pool:16">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 needs to be updated.</li>
<li>When worker 

<math display="inline" id="Mining_pool:17">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 submits a share, set 

<math display="inline" id="Mining_pool:18">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>S</mi>
     <mi>k</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mi>s</mi>
     <mi>p</mi>
     <mi>B</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>p</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{k}=S_{k}+spB
  </annotation>
 </semantics>
</math>

, and then 

<math display="inline" id="Mining_pool:19">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <mi>s</mi>
    <mi>r</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=sr
  </annotation>
 </semantics>
</math>

.</li>
<li>If the share is a valid block, end the round. For every worker 

<math display="inline" id="Mining_pool:20">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 pay 

<math display="inline" id="Mining_pool:21">
 <semantics>
  <mfrac>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>f</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>r</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>S</mi>
     <mi>k</mi>
    </msub>
   </mrow>
   <mrow>
    <mi>s</mi>
    <mi>p</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>f</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>r</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{(1-f)(r-1)S_{k}}{sp}
  </annotation>
 </semantics>
</math>

</li>
</ul>
<h3 id="double-geometric-method">Double Geometric method</h3>

<p>Generalized version of Geometric and PPLNS methods.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> It involves new parameter

<math display="block" id="Mining_pool:22">
 <semantics>
  <mi>o</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>o</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o
  </annotation>
 </semantics>
</math>

 ("cross-round leakage"). When 

<math display="inline" id="Mining_pool:23">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>o</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o=0
  </annotation>
 </semantics>
</math>

 this becomes the Geometric method. When 

<math display="inline" id="Mining_pool:24">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>o</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o=1
  </annotation>
 </semantics>
</math>

 this becomes a variant of PPLNS, with exponential decay instead of a step function.</p>
<ul>
<li>Choose parameters 

<math display="inline" id="Mining_pool:25">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Mining_pool:26">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Mining_pool:27">
 <semantics>
  <mi>o</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>o</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o
  </annotation>
 </semantics>
</math>

.</li>
<li>When the pool first starts running, initialize 

<math display="inline" id="Mining_pool:28">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=1
  </annotation>
 </semantics>
</math>

. For every worker 

<math display="inline" id="Mining_pool:29">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, let 

<math display="inline" id="Mining_pool:30">
 <semantics>
  <msub>
   <mi>S</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{k}
  </annotation>
 </semantics>
</math>

 be the worker’s score, and set 

<math display="inline" id="Mining_pool:31">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>k</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{k}=0
  </annotation>
 </semantics>
</math>

.</li>
<li>Set 

<math display="inline" id="Mining_pool:32">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mfrac>
     <mrow>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mi>c</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>-</mo>
        <mi>o</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mi>c</mi>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>r</ci>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>p</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>c</ci>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <ci>o</ci>
       </apply>
      </apply>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=1+\frac{p(1-c)(1-o)}{c}
  </annotation>
 </semantics>
</math>

. If at any point the difficulty or the parameters change, 

<math display="inline" id="Mining_pool:33">
 <semantics>
  <mi>r</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>r</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r
  </annotation>
 </semantics>
</math>

 should be recalculated.</li>
<li>When worker 

<math display="inline" id="Mining_pool:34">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 submits a share, set 

<math display="inline" id="Mining_pool:35">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>S</mi>
     <mi>k</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>f</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mn>1</mn>
       <mo>-</mo>
       <mi>c</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>s</mi>
     <mi>p</mi>
     <mi>B</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>f</ci>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <ci>c</ci>
      </apply>
      <ci>s</ci>
      <ci>p</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{k}=S_{k}+(1-f)(1-c)spB
  </annotation>
 </semantics>
</math>

 (where 

<math display="inline" id="Mining_pool:36">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is the block reward at the time it was submitted), and then 

<math display="inline" id="Mining_pool:37">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <mrow>
    <mi>s</mi>
    <mi>r</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <apply>
     <times></times>
     <ci>s</ci>
     <ci>r</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=sr
  </annotation>
 </semantics>
</math>

.</li>
<li>If the share is a valid block, then also do the following for each worker 

<math display="inline" id="Mining_pool:38">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

: Give him a payout of 

<math display="inline" id="Mining_pool:39">
 <semantics>
  <mfrac>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mi>o</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>S</mi>
     <mi>k</mi>
    </msub>
   </mrow>
   <msub>
    <mi>c</mi>
    <mi>s</mi>
   </msub>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <ci>o</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>s</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{(1-o)S_{k}}{c_{s}}
  </annotation>
 </semantics>
</math>

, and then set 

<math display="inline" id="Mining_pool:40">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>S</mi>
     <mi>k</mi>
    </msub>
    <mo>⋅</mo>
    <mi>o</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <ci>normal-⋅</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <ci>k</ci>
     </apply>
     <ci>o</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{k}=S_{k}\cdot o
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<h2 id="multipool-mining">Multipool mining</h2>

<p>Multipools switch between different altcoins and constantly calculate which coin is at that moment the most profitable to mine. Two key factors are involved in the <a class="uri" href="algorithm" title="wikilink">algorithm</a> that calculates profitability, the blocktime and the price on the exchanges. To make sure you don’t need 100 different wallets for all possible minable coins, almost all multipools now automatically exchange the mined coin to a coin that is accepted in the mainstream (for example <a class="uri" href="Bitcoin" title="wikilink">Bitcoin</a>).<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Using this method, because the "most profitable" coins are being mined and then sold for the intended coin, you generally receive more coins in the intended currency than you would by mining that currency alone. This method also increases demand on the intended coin, which has the side effect of increasing or stabilizing the value of the intended coin.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Bitcoin_protocol" title="wikilink">Bitcoin protocol</a></li>
<li><a class="uri" href="Cryptocurrency" title="wikilink">Cryptocurrency</a></li>
<li><a href="Cryptographic_protocol" title="wikilink">Cryptographic protocol</a></li>
<li><a href="Digital_currency_exchanger" title="wikilink">Digital currency exchanger</a></li>
<li><a href="Digital_currency" title="wikilink">Digital currency</a></li>
<li><a href="Electronic_money" title="wikilink">Electronic money</a></li>
<li><a href="Virtual_currency" title="wikilink">Virtual currency</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://en.bitcoin.it/wiki/Pooled_mining">Bitcoin Wiki on Pooled mining</a></li>
</ul>

<p>"</p>

<p><a href="Category:Cryptocurrencies" title="wikilink">*</a> <a class="uri" href="Category:Bitcoin" title="wikilink">Category:Bitcoin</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
</ol>
</section>
</body>
</html>
