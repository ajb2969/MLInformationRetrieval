<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="847">Ward's method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Ward's method</h1>
<hr>In [[statistics]], '''Ward's method''' is a criterion appli
<p>ed in <a href="Hierarchical_clustering" title="wikilink">hierarchical cluster analysis</a>. <strong>Ward's minimum variance method</strong> <sup>inaccurate, see talk</sup> is a special case of the <a href="objective_function" title="wikilink">objective function</a> approach originally presented by Joe H. Ward, Jr.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Ward suggested a general <a href="agglomerative_hierarchical_clustering" title="wikilink">agglomerative hierarchical clustering</a> procedure, where the criterion for choosing the pair of clusters to merge at each step is based on the optimal value of an objective function. This objective function could be "any function that reflects the investigator's purpose." Many of the standard clustering procedures are contained in this very general class. To illustrate the procedure, Ward used the example where the objective function is the <a href="Lack-of-fit_sum_of_squares" title="wikilink">error sum of squares</a>, and this example is known as <em>Ward's method</em> or more precisely <em>Ward's minimum variance method</em>.</p>
<h2 id="the-minimum-variance-criterion">The minimum variance criterion</h2>

<p>Ward's minimum variance criterion minimizes the total within-cluster variance. At each step the pair of clusters with minimum between-cluster distance are merged. To implement this method, at each step find the pair of clusters that leads to minimum increase in total within-cluster variance after merging. This increase is a weighted squared distance between cluster centers. At the initial step, all clusters are singletons (clusters containing a single point). To apply a <a href="recursive_algorithm" title="wikilink">recursive algorithm</a> under this <a href="objective_function" title="wikilink">objective function</a>, the initial distance between individual objects must be (proportional to) squared <a href="Euclidean_distance" title="wikilink">Euclidean distance</a>.</p>

<p>The initial cluster distances in Ward's minimum variance method are therefore defined to be the squared Euclidean distance between points:</p>

<p>

<math display="block" id="Ward's_method:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>d</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <msub>
        <mi>X</mi>
        <mi>i</mi>
       </msub>
       <mo stretchy="false">}</mo>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <msub>
        <mi>X</mi>
        <mi>j</mi>
       </msub>
       <mo stretchy="false">}</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <msup>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <msub>
        <mi>X</mi>
        <mi>i</mi>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>X</mi>
        <mi>j</mi>
       </msub>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <interval closure="open">
       <set>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>i</ci>
        </apply>
       </set>
       <set>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>j</ci>
        </apply>
       </set>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>X</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{ij}=d(\{X_{i}\},\{X_{j}\})={\|X_{i}-X_{j}\|^{2}}.
  </annotation>
 </semantics>
</math>

</p>

<p>Note: In software that implements Ward's method, it is important to check whether the function arguments should specify Euclidean distances or squared Euclidean distances.</p>
<h2 id="lancewilliams-algorithms">Lance–Williams algorithms</h2>

<p>Ward's minimum variance method can be defined and implemented recursively by a Lance–Williams algorithm.[2] The Lance–Williams algorithms are an infinite family of agglomerative hierarchical clustering algorithms which are represented by a recursive formula for updating cluster distances at each step (each time a pair of clusters is merged). At each step, it is necessary to optimize the objective function (find the optimal pair of clusters to merge). The recursive formula simplifies finding the optimal pair.</p>

<p>Suppose that clusters 

<math display="inline" id="Ward's_method:1">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Ward's_method:2">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{j}
  </annotation>
 </semantics>
</math>

 were next to be merged. At this point all of the current pairwise cluster distances are known. The recursive formula gives the updated cluster distances following the pending merge of clusters 

<math display="inline" id="Ward's_method:3">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i}
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Ward's_method:4">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{j}
  </annotation>
 </semantics>
</math>

. Let</p>
<ul>
<li>

<math display="inline" id="Ward's_method:5">
 <semantics>
  <msub>
   <mi>d</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{ij}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Ward's_method:6">
 <semantics>
  <msub>
   <mi>d</mi>
   <mrow>
    <mi>i</mi>
    <mi>k</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{ik}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Ward's_method:7">
 <semantics>
  <msub>
   <mi>d</mi>
   <mrow>
    <mi>j</mi>
    <mi>k</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <apply>
     <times></times>
     <ci>j</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{jk}
  </annotation>
 </semantics>
</math>

 be the pairwise distances between clusters 

<math display="inline" id="Ward's_method:8">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i}
  </annotation>
 </semantics>
</math>


, 

<math display="inline" id="Ward's_method:9">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{j}
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Ward's_method:10">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{k}
  </annotation>
 </semantics>
</math>

, respectively,</li>
<li>

<math display="inline" id="Ward's_method:11">
 <semantics>
  <msub>
   <mi>d</mi>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>k</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{(ij)k}
  </annotation>
 </semantics>
</math>

 be the distance between the new cluster 

<math display="inline" id="Ward's_method:12">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>i</mi>
   </msub>
   <mo>∪</mo>
   <msub>
    <mi>C</mi>
    <mi>j</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i}\cup C_{j}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Ward's_method:13">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{k}
  </annotation>
 </semantics>
</math>


.</li>
</ul>

<p>An algorithm belongs to the Lance-Williams family if the updated cluster distance 

<math display="inline" id="Ward's_method:14">
 <semantics>
  <msub>
   <mi>d</mi>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>k</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{(ij)k}
  </annotation>
 </semantics>
</math>

 can be computed recursively by</p>

<p>

<math display="block" id="Ward's_method:15">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>d</mi>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>k</mi>
     </mrow>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>α</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>d</mi>
       <mrow>
        <mi>i</mi>
        <mi>k</mi>
       </mrow>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msub>
       <mi>α</mi>
       <mi>j</mi>
      </msub>
      <msub>
       <mi>d</mi>
       <mrow>
        <mi>j</mi>
        <mi>k</mi>
       </mrow>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>β</mi>
      <msub>
       <mi>d</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>γ</mi>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <msub>
         <mi>d</mi>
         <mrow>
          <mi>i</mi>
          <mi>k</mi>
         </mrow>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>d</mi>
         <mrow>
          <mi>j</mi>
          <mi>k</mi>
         </mrow>
        </msub>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>d</ci>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>α</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <apply>
        <times></times>
        <ci>j</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>β</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>γ</ci>
      <apply>
       <abs></abs>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>d</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>d</ci>
         <apply>
          <times></times>
          <ci>j</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{(ij)k}=\alpha_{i}d_{ik}+\alpha_{j}d_{jk}+\beta d_{ij}+\gamma|d_{ik}-d_{jk}|,
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Ward's_method:16">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>α</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>α</mi>
     <mi>j</mi>
    </msub>
    <mo>,</mo>
    <mi>β</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>α</ci>
     <ci>j</ci>
    </apply>
    <ci>β</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{i},\alpha_{j},\beta,
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Ward's_method:17">
 <semantics>
  <mi>γ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>γ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma
  </annotation>
 </semantics>
</math>

 are parameters, which may depend on cluster sizes, that together with the cluster distance function 

<math display="inline" id="Ward's_method:18">
 <semantics>
  <msub>
   <mi>d</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{ij}
  </annotation>
 </semantics>
</math>


 determine the clustering algorithm. Several standard clustering algorithms such as <a href="Single-linkage_clustering" title="wikilink">single linkage</a>, <a href="Complete-linkage_clustering" title="wikilink">complete linkage</a>, and group average method have a recursive formula of the above type. A table of parameters for standard methods is given by several authors.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>Ward's minimum variance method can be implemented by the Lance–Williams formula. For disjoint clusters 

<math display="inline" id="Ward's_method:19">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>C</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>C</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>j</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i},C_{j},
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Ward's_method:20">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{k}
  </annotation>
 </semantics>
</math>

 with sizes 

<math display="inline" id="Ward's_method:21">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>n</mi>
     <mi>i</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>n</mi>
     <mi>j</mi>
    </msub>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>n</ci>
     <ci>j</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{i},n_{j},
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Ward's_method:22">
 <semantics>
  <msub>
   <mi>n</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{k}
  </annotation>
 </semantics>
</math>

 respectively:</p>

<p>

<math display="block" id="Ward's_method:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>C</mi>
        <mi>i</mi>
       </msub>
       <mo>∪</mo>
       <msub>
        <mi>C</mi>
        <mi>j</mi>
       </msub>
      </mrow>
      <mo>,</mo>
      <msub>
       <mi>C</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <mpadded width="+2.8pt">
        <mfrac>
         <mrow>
          <msub>
           <mi>n</mi>
           <mi>i</mi>
          </msub>
          <mo>+</mo>
          <msub>
           <mi>n</mi>
           <mi>k</mi>
          </msub>
         </mrow>
         <mrow>
          <msub>
           <mi>n</mi>
           <mi>i</mi>
          </msub>
          <mo>+</mo>
          <msub>
           <mi>n</mi>
           <mi>j</mi>
          </msub>
          <mo>+</mo>
          <msub>
           <mi>n</mi>
           <mi>k</mi>
          </msub>
         </mrow>
        </mfrac>
       </mpadded>
       <mi>d</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>C</mi>
         <mi>i</mi>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>C</mi>
         <mi>k</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mpadded width="+2.8pt">
        <mfrac>
         <mrow>
          <msub>
           <mi>n</mi>
           <mi>j</mi>
          </msub>
          <mo>+</mo>
          <msub>
           <mi>n</mi>
           <mi>k</mi>
          </msub>
         </mrow>
         <mrow>
          <msub>
           <mi>n</mi>
           <mi>i</mi>
          </msub>
          <mo>+</mo>
          <msub>
           <mi>n</mi>
           <mi>j</mi>
          </msub>
          <mo>+</mo>
          <msub>
           <mi>n</mi>
           <mi>k</mi>
          </msub>
         </mrow>
        </mfrac>
       </mpadded>
       <mi>d</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>C</mi>
         <mi>j</mi>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>C</mi>
         <mi>k</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mpadded width="+2.8pt">
       <mfrac>
        <msub>
         <mi>n</mi>
         <mi>k</mi>
        </msub>
        <mrow>
         <msub>
          <mi>n</mi>
          <mi>i</mi>
         </msub>
         <mo>+</mo>
         <msub>
          <mi>n</mi>
          <mi>j</mi>
         </msub>
         <mo>+</mo>
         <msub>
          <mi>n</mi>
          <mi>k</mi>
         </msub>
        </mrow>
       </mfrac>
      </mpadded>
      <mi>d</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>C</mi>
        <mi>i</mi>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>C</mi>
        <mi>j</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>d</ci>
     <interval closure="open">
      <apply>
       <union></union>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>k</ci>
      </apply>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <ci>j</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
       <ci>d</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>C</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>C</ci>
         <ci>k</ci>
        </apply>
       </interval>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <ci>j</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <ci>j</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
       <ci>d</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>C</ci>
         <ci>j</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>C</ci>
         <ci>k</ci>
        </apply>
       </interval>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>n</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>n</ci>
         <ci>j</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>n</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <ci>d</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <ci>j</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(C_{i}\cup C_{j},C_{k})=\frac{n_{i}+n_{k}}{n_{i}+n_{j}+n_{k}}\;d(C_{i},C_{k})%
+\frac{n_{j}+n_{k}}{n_{i}+n_{j}+n_{k}}\;d(C_{j},C_{k})-\frac{n_{k}}{n_{i}+n_{j%
}+n_{k}}\;d(C_{i},C_{j}).
  </annotation>
 </semantics>
</math>

 Hence Ward's method can be implemented as a Lance–Williams algorithm with</p>

<p>

<math display="block" id="Ward's_method:24">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>α</mi>
     <mi>l</mi>
    </msub>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <msub>
       <mi>n</mi>
       <mi>i</mi>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>n</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mrow>
      <msub>
       <mi>n</mi>
       <mi>i</mi>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>n</mi>
       <mi>j</mi>
      </msub>
      <mo>+</mo>
      <msub>
       <mi>n</mi>
       <mi>k</mi>
      </msub>
     </mrow>
    </mfrac>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <mrow>
     <mi>β</mi>
     <mo>=</mo>
     <mfrac>
      <mrow>
       <mo>-</mo>
       <msub>
        <mi>n</mi>
        <mi>k</mi>
       </msub>
      </mrow>
      <mrow>
       <msub>
        <mi>n</mi>
        <mi>i</mi>
       </msub>
       <mo>+</mo>
       <msub>
        <mi>n</mi>
        <mi>j</mi>
       </msub>
       <mo>+</mo>
       <msub>
        <mi>n</mi>
        <mi>k</mi>
       </msub>
      </mrow>
     </mfrac>
    </mrow>
    <mo rspace="22.5pt">,</mo>
    <mrow>
     <mi>γ</mi>
     <mo>=</mo>
     <mn>0.</mn>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>α</ci>
      <ci>l</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>j</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <ci>β</ci>
      <apply>
       <divide></divide>
       <apply>
        <minus></minus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>n</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>n</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>n</ci>
         <ci>j</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>n</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <ci>γ</ci>
      <cn type="float">0.</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \alpha_{l}=\frac{n_{i}+n_{k}}{n_{i}+n_{j}+n_{k}},\qquad\beta=\frac{-n_{k}}{n_{%
i}+n_{j}+n_{k}},\qquad\gamma=0.
  </annotation>
 </semantics>
</math>

</p>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Everitt, B. S., Landau, S. and Leese, M. (2001), <em>Cluster Analysis, 4th Edition</em>, Oxford University Press, Inc., New York; Arnold, London. ISBN 0340761199</li>
<li>Hartigan, J. A. (1975), <em>Clustering Algorithms</em>, New York: Wiley.</li>
<li><a href="Anil_K._Jain_(computer_scientist,_born_1948)" title="wikilink">Jain, A. K.</a> and Dubes, R. C. (1988), <em>Algorithms for Clustering Data</em>, New Jersey: Prentice–Hall.</li>
<li>Kaufman, L. and Rousseeuw, P. J. (1990), <em>Finding Groups in Data: An Introduction to Cluster Analysis</em>, New York: Wiley.</li>
</ul>

<p>"</p>

<p><a href="Category:Data_clustering_algorithms" title="wikilink">Category:Data clustering algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Ward, J. H., Jr. (1963), "Hierarchical Grouping to Optimize an Objective Function", <em><a href="Journal_of_the_American_Statistical_Association" title="wikilink">Journal of the American Statistical Association</a></em>, 58, 236–244.<a href="#fnref1">↩</a></li>
<li id="fn2">Cormack, R. M. (1971), "A Review of Classification", <em><a href="Journal_of_the_Royal_Statistical_Society" title="wikilink">Journal of the Royal Statistical Society</a></em>, Series A'', 134(3), 321-367.<a href="#fnref2">↩</a></li>
<li id="fn3">Gordon, A. D. (1999), <em>Classification, 2nd Edition</em>, Chapman and Hall, Boca Raton.<a href="#fnref3">↩</a></li>
<li id="fn4">Milligan, G. W. (1979), "Ultrametric Hierarchical Clustering Algorithms", <em>Psychometrika</em>, 44(3), 343–346.<a href="#fnref4">↩</a></li>
</ol>
</section>
</hr></body>
</html>
