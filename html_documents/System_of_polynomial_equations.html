<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1995">System of polynomial equations</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>System of polynomial equations</h1>
<hr/>

<p>A <strong>system of polynomial equations</strong> is a set of simultaneous equations <em>f</em><sub>1</sub> = 0, ..., <em>f</em><sub><em>h</em></sub> = 0 where the <em>f</em><sub><em>i</em></sub> are <a href="Polynomial_ring" title="wikilink">polynomials</a> in several variables, say <em>x</em><sub>1</sub>, ..., <em>x</em><sub><em>n</em></sub>, over some <a href="Field_(mathematics)" title="wikilink">field</a> <em>k</em>.</p>

<p>Usually, the field <em>k</em> is either the field of <a href="rational_number" title="wikilink">rational numbers</a> or a <a href="finite_field" title="wikilink">finite field</a>, although most of the theory applies to any field.</p>

<p>A <em>solution</em> is a set of the values for the <em>x</em><sub><em>i</em></sub> which make all of the equations true and which belong to some <a href="algebraically_closed" title="wikilink">algebraically closed</a> <a href="field_extension" title="wikilink">field extension</a> <em>K</em> of <em>k</em>. When <em>k</em> is the field of <a href="rational_number" title="wikilink">rational numbers</a>, <em>K</em> is the field of <a href="complex_number" title="wikilink">complex numbers</a>.</p>
<h2 id="examples-and-extensions">Examples and extensions</h2>
<h3 id="trigonometric-equations">Trigonometric equations</h3>

<p>A trigonometric equation is an equation <em>g</em> = 0 where <em>g</em> is a <a href="trigonometric_polynomial" title="wikilink">trigonometric polynomial</a>. Such an equation may be converted into a polynomial system by expanding the sines and cosines in it, replacing sin(<em>x</em>) and cos(<em>x</em>) by two new variables <em>s</em> and <em>c</em> and adding the new equation <em>s</em><sup>2</sup> + <em>c</em><sup>2</sup> − 1 = 0.</p>

<p>For example the equation</p>

<p>
<math display="block" id="System_of_polynomial_equations:0">
<semantics>
<mrow>
<mi>sin</mi>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<mn>3</mn>
</msup>
<mo>+</mo>
<mi>cos</mi>
<mrow>
<mo stretchy="false">(</mo>
<mn>3</mn>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>=</mo>
<mpadded width="+1.7pt">
<mn>0</mn>
</mpadded>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<sin></sin>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">x</csymbol>
<ci>normal-)</ci>
</cerror>
<cn type="integer">3</cn>
</apply>
<plus></plus>
<cos></cos>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<cn type="integer">3</cn>
<csymbol cd="unknown">x</csymbol>
<ci>normal-)</ci>
</cerror>
<eq></eq>
<cn type="integer">0</cn>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   \sin(x)^{3}+\cos(3x)=0\,
  </annotation>
</semantics>
</math>
</p>

<p>is equivalent to the polynomial system</p>

<p>
<math display="block" id="System_of_polynomial_equations:1">
<semantics>
<mrow>
<mo>{</mo>
<mtable displaystyle="true">
<mtr>
<mtd columnalign="left">
<mrow>
<mrow>
<msup>
<mi>s</mi>
<mn>3</mn>
</msup>
<mo>+</mo>
<mrow>
<mn>4</mn>
<msup>
<mi>c</mi>
<mn>3</mn>
</msup>
</mrow>
</mrow>
<mo>-</mo>
<mrow>
<mn>3</mn>
<mi>c</mi>
</mrow>
</mrow>
</mtd>
<mtd columnalign="left">
<mrow>
<mi></mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
</mtd>
</mtr>
<mtr>
<mtd columnalign="left">
<mrow>
<mrow>
<msup>
<mi>s</mi>
<mn>2</mn>
</msup>
<mo>+</mo>
<msup>
<mi>c</mi>
<mn>2</mn>
</msup>
</mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</mtd>
<mtd columnalign="left">
<mrow>
<mi></mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
</mtd>
</mtr>
</mtable>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">cases</csymbol>
<apply>
<minus></minus>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>s</ci>
<cn type="integer">3</cn>
</apply>
<apply>
<times></times>
<cn type="integer">4</cn>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>c</ci>
<cn type="integer">3</cn>
</apply>
</apply>
</apply>
<apply>
<times></times>
<cn type="integer">3</cn>
<ci>c</ci>
</apply>
</apply>
<apply>
<eq></eq>
<csymbol cd="latexml">absent</csymbol>
<cn type="integer">0</cn>
</apply>
<apply>
<minus></minus>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>s</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>c</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<cn type="integer">1</cn>
</apply>
<apply>
<eq></eq>
<csymbol cd="latexml">absent</csymbol>
<cn type="integer">0</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \begin{cases}s^{3}+4c^{3}-3c&amp;=0\\
s^{2}+c^{2}-1&amp;=0\end{cases}
  </annotation>
</semantics>
</math>
</p>
<h3 id="solutions-in-a-finite-field">Solutions in a finite field</h3>

<p>When solving a system over a finite field <em>k</em> with <em>q</em> elements, one is primarily interested in the solutions in <em>k</em>. As the elements of <em>k</em> are exactly the solutions of the equation <em>x</em><sup><em>q</em></sup> − <em>x</em> = 0, it suffices, for restricting the solutions to <em>k</em>, to add the equation <em>x</em><sub><em>i</em></sub><sup><em>q</em></sup> − <em>x</em><sub><em>i</em></sub> = 0 for each variable <em>x</em><sub><em>i</em></sub>.</p>
<h3 id="coefficients-in-a-number-field-or-in-a-finite-field-with-non-prime-order">Coefficients in a number field or in a finite field with non-prime order</h3>

<p>The elements of a <a href="number_field" title="wikilink">number field</a> are usually represented as polynomials in a generator of the field which satisfies some univariate polynomial equation. To work with a polynomial system whose coefficients belong to a number field, it suffices to consider this generator as a new variable and to add the equation of the generator to the equations of the system. Thus solving a polynomial system over a number field is reduced to solving another system over the rational numbers.</p>

<p>For example, if a system contains 

<math display="inline" id="System_of_polynomial_equations:2">
<semantics>
<msqrt>
<mn>2</mn>
</msqrt>
<annotation-xml encoding="MathML-Content">
<apply>
<root></root>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \sqrt{2}
  </annotation>
</semantics>
</math>

, a system over the rational numbers is obtained by adding the equation <em>r</em><sub>2</sub><sup>2</sup> − 2 = 0 and replacing 

<math display="inline" id="System_of_polynomial_equations:3">
<semantics>
<msqrt>
<mn>2</mn>
</msqrt>
<annotation-xml encoding="MathML-Content">
<apply>
<root></root>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \sqrt{2}
  </annotation>
</semantics>
</math>

 by <em>r</em><sub>2</sub> in the other equations.</p>

<p>In the case of a finite field, the same transformation allows always to suppose that the field <em>k</em> has a prime order.</p>
<h2 id="basic-properties-and-definitions">Basic properties and definitions</h2>

<p>A system is <a href="Overdetermined_system" title="wikilink">overdetermined</a> if the number of equations is higher than the number of variables. A system is <a href="inconsistent_equations" title="wikilink">inconsistent</a> if it has no solutions. By <a href="Hilbert's_Nullstellensatz" title="wikilink">Hilbert's Nullstellensatz</a> this means that 1 is a linear combination (with polynomials as coefficients) of the first members of the equations. Most but not all overdetermined systems are inconsistent. For example the system  <em>x</em><sup>3</sup> − 1 = 0, <em>x</em><sup>2</sup> − 1 = 0 is overdetermined (having two equations but only one unknown), but it is not inconsistent since it has the solution <em>x</em> =1.</p>

<p>A system is <a href="Underdetermined_system" title="wikilink">underdetermined</a> if the number of equations is lower than the number of the variables. An underdetermined system is either inconsistent or has infinitely many solutions in an algebraically closed extension <em>K</em> of <em>k</em>.</p>

<p>A system is <a href="Zero-dimensional_space" title="wikilink">zero-dimensional</a> if it has a finite number of solutions in an algebraically closed extension <em>K</em> of <em>k</em>. This terminology comes from the fact that the <a href="algebraic_variety" title="wikilink">algebraic variety</a> of the solutions has <a href="Dimension_of_an_algebraic_variety" title="wikilink">dimension</a> zero. A system with infinitely many solutions is said to be <em>positive-dimensional</em>.</p>

<p>A zero-dimensional system with as many equations as variables is said to be <em>well-behaved</em>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> <a href="Bézout's_theorem" title="wikilink">Bézout's theorem</a> asserts that a well-behaved system whose equations have degrees <em>d</em><sub>1</sub>, ..., <em>d</em><sub><em>n</em></sub> has at most <em>d</em><sub>1</sub>...<em>d</em><sub><em>n</em></sub> solutions. This bound is sharp. If all the degrees are equal to <em>d</em>, this bound becomes <em>d</em><sup><em>n</em></sup> and is exponential in the number of variables.</p>

<p>This exponential behavior makes solving polynomial systems difficult and explains why there are few solvers that are able to automatically solve systems with Bézout's bound higher than, say, 25 (three equations of degree 3 or five equations of degree 2 are beyond this bound).</p>
<h2 id="what-is-solving">What is solving?</h2>

<p>The first thing to do for solving a polynomial system is to decide if it is inconsistent, zero-dimensional or positive dimensional. This may be done by the computation of a <a href="Gröbner_basis" title="wikilink">Gröbner basis</a> of the left-hand sides of the equations. The system is <em>inconsistent</em> if this Gröbner basis is reduced to 1. The system is <em>zero-dimensional</em> if, for every variable there is a <a href="Gröbner_basis" title="wikilink">leading monomial</a> of some element of the Gröbner basis which is a pure power of this variable. For this test, the best <a href="monomial_order" title="wikilink">monomial order</a> is usually the <a href="monomial_order#Graded_reverse_lexicographic_order" title="wikilink">graded reverse lexicographic</a> one (grevlex).</p>

<p>If the system is <em>positive-dimensional</em>, it has infinitely many solutions. It is thus not possible to enumerate them. It follows that, in this case, solving may only mean "finding a description of the solutions from which the relevant properties of the solutions are easy to extract". There is no commonly accepted such description. In fact there are many different "relevant properties", which involve almost every subfield of <a href="algebraic_geometry" title="wikilink">algebraic geometry</a>.</p>

<p>A natural example of an open question about solving positive-dimensional systems is the following: <em>decide if a polynomial system over the <a href="rational_number" title="wikilink">rational numbers</a> has a finite number of real solutions and compute them</em>. The only published algorithm which allows one to solve this question is <a href="cylindrical_algebraic_decomposition" title="wikilink">cylindrical algebraic decomposition</a>, which is not efficient enough, in practice, to be used for this.</p>

<p>For zero-dimensional systems, solving consists of computing all the solutions. There are two different ways of outputting the solutions. The most common, possible only for real or complex solutions, consists of outputting numeric approximations of the solutions. Such a solution is called <em>numeric</em>. A solution is <em>certified</em> if it is provided with a bound on the error of the approximations which separates the different solutions.</p>

<p>The other way to represent the solutions is said to be <em>algebraic</em>. It uses the fact that, for a zero-dimensional system, the solutions belong to the <a href="algebraic_closure" title="wikilink">algebraic closure</a> of the field <em>k</em> of the coefficients of the system. There are several ways to represent the solution in an algebraic closure, which are discussed below. All of them allow one to compute a numerical approximation of the solutions by solving one or several univariate equations. For this computation, the representation of the solutions which need only to solve only one univariate polynomial for each solution have to be preferred: computing the roots of a polynomial which has approximate coefficients is a highly unstable problem.</p>
<h2 id="algebraic-representation-of-the-solutions">Algebraic representation of the solutions</h2>
<h3 id="regular-chains">Regular chains</h3>

<p>The usual way of representing the solutions is through zero-dimensional regular chains. Such a chain consists of a sequence of polynomials <mtpl></mtpl>, <mtpl></mtpl>, ..., <mtpl></mtpl> such that, for every 

<math display="inline" id="System_of_polynomial_equations:4">
<semantics>
<mi>i</mi>
<annotation-xml encoding="MathML-Content">
<ci>i</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   i
  </annotation>
</semantics>
</math>

 such that 

<math display="inline" id="System_of_polynomial_equations:5">
<semantics>
<mrow>
<mn>1</mn>
<mi mathvariant="normal">≤</mi>
<mi>i</mi>
<mi mathvariant="normal">≤</mi>
<mi>n</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<cn type="integer">1</cn>
<ci>normal-≤</ci>
<ci>i</ci>
<ci>normal-≤</ci>
<ci>n</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   1≤i≤n
  </annotation>
</semantics>
</math>
</p>
<ul>
<li><mtpl></mtpl> is a polynomial in <mtpl></mtpl> only, which has a degree <mtpl></mtpl> in <mtpl></mtpl>;</li>
<li>the coefficient of <mtpl></mtpl> in <mtpl></mtpl> is a polynomial in <mtpl></mtpl> which does not have any common zero with <mtpl></mtpl>, ..., <mtpl></mtpl>.</li>
</ul>

<p>To such a <a href="regular_chain" title="wikilink">regular chain</a> is associated a <em>triangular system of equations</em></p>

<p>
<math display="block" id="System_of_polynomial_equations:6">
<semantics>
<mrow>
<mo>{</mo>
<mtable displaystyle="true">
<mtr>
<mtd columnalign="left">
<mrow>
<mrow>
<msub>
<mi>f</mi>
<mn>1</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
</mtd>
<mtd></mtd>
</mtr>
<mtr>
<mtd columnalign="left">
<mrow>
<mrow>
<msub>
<mi>f</mi>
<mn>2</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>x</mi>
<mn>2</mn>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
</mtd>
<mtd></mtd>
</mtr>
<mtr>
<mtd columnalign="left">
<mi mathvariant="normal">⋯</mi>
</mtd>
<mtd></mtd>
</mtr>
<mtr>
<mtd columnalign="left">
<mrow>
<mrow>
<msub>
<mi>f</mi>
<mi>n</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<msub>
<mi>x</mi>
<mn>2</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>x</mi>
<mi>n</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mn>0.</mn>
</mrow>
</mtd>
<mtd></mtd>
</mtr>
</mtable>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">cases</csymbol>
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<cn type="integer">0</cn>
</apply>
<mtext>otherwise</mtext>
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<cn type="integer">2</cn>
</apply>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
</interval>
</apply>
<cn type="integer">0</cn>
</apply>
<mtext>otherwise</mtext>
<ci>normal-⋯</ci>
<mtext>otherwise</mtext>
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<ci>n</ci>
</apply>
<vector>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>n</ci>
</apply>
</vector>
</apply>
<cn type="float">0.</cn>
</apply>
<mtext>otherwise</mtext>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \begin{cases}f_{1}(x_{1})=0\\
f_{2}(x_{1},x_{2})=0\\
\cdots\\
f_{n}(x_{1},x_{2},\ldots,x_{n})=0.\end{cases}
  </annotation>
</semantics>
</math>
</p>

<p>The solutions of this system are obtained by solving the first univariate equation, substituting the solutions in the other equations, then solving the second equation which is now univariate, and so on. The definition of regular chains implies that the univariate equation obtained from <mtpl></mtpl> has degree <mtpl></mtpl> and thus that the system has <mtpl></mtpl> solutions, provided that there is no multiple root in this resolution process (<a href="fundamental_theorem_of_algebra" title="wikilink">fundamental theorem of algebra</a>).</p>

<p>Every zero-dimensional system of polynomial equations is equivalent (i.e. has the same solutions) to a finite number of regular chains. Several regular chains may be needed, as it is the case for the following system which has three solutions.</p>

<p>
<math display="block" id="System_of_polynomial_equations:7">
<semantics>
<mrow>
<mo>{</mo>
<mtable displaystyle="true">
<mtr>
<mtd columnalign="left">
<mrow>
<mrow>
<msup>
<mi>x</mi>
<mn>2</mn>
</msup>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
</mtd>
<mtd></mtd>
</mtr>
<mtr>
<mtd columnalign="left">
<mrow>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>x</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>y</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
</mtd>
<mtd></mtd>
</mtr>
<mtr>
<mtd columnalign="left">
<mrow>
<mrow>
<msup>
<mi>y</mi>
<mn>2</mn>
</msup>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
</mtd>
<mtd></mtd>
</mtr>
</mtable>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">cases</csymbol>
<apply>
<eq></eq>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>x</ci>
<cn type="integer">2</cn>
</apply>
<cn type="integer">1</cn>
</apply>
<cn type="integer">0</cn>
</apply>
<mtext>otherwise</mtext>
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<minus></minus>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<minus></minus>
<ci>y</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<cn type="integer">0</cn>
</apply>
<mtext>otherwise</mtext>
<apply>
<eq></eq>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>y</ci>
<cn type="integer">2</cn>
</apply>
<cn type="integer">1</cn>
</apply>
<cn type="integer">0</cn>
</apply>
<mtext>otherwise</mtext>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \begin{cases}x^{2}-1=0\\
(x-1)(y-1)=0\\
y^{2}-1=0\end{cases}
  </annotation>
</semantics>
</math>
</p>

<p>There are several algorithms for computing a <a href="triangular_decomposition" title="wikilink">triangular decomposition</a> of an arbitrary polynomial system (not necessarily zero-dimensional)<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> into <a href="regular_chain" title="wikilink">regular chains</a> (or <a href="regular_semi-algebraic_system" title="wikilink">regular semi-algebraic systems</a>).</p>

<p>There is also an algorithm which is specific to the zero-dimensional case and is competitive, in this case, with the direct algorithms. It consists in computing first the <a href="Gröbner_basis" title="wikilink">Gröbner basis</a> for the <a href="monomial_order" title="wikilink">graded reverse lexicographic order (grevlex)</a>, then deducing the Gröbner basis by FGLM algorithm<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and finally applying the Lextriangular algorithm.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>This representation of the solutions are fully convenient for coefficients in a finite field. However, for rational coefficients, There are two problems:</p>
<ul>
<li>The output uses to involve huge integers which may make the computation and the use of the result problematic.</li>
<li>To deduce the numeric values of the solutions from the output, one has to solve univariate polynomials with approximate coefficients, which is a highly unstable problem.</li>
</ul>

<p>The first issue has been theoretically solved by Dahan and Schost:<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Among the sets of regular chains that represent a given set of solutions, there is a set for which the coefficients are explicitly bounded in terms of the size of the input system, with a nearly optimal bound. This set, called <em>equiprojectable decomposition</em>, depends only on the choice of the coordinates. This allows to use <a href="modular_arithmetic" title="wikilink">modular methods</a> for computing efficiently the equiprojectable decomposition.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>The second issue is generally solved by outputting regular chains of a special form, sometimes called <em>shape lemma</em>, for which all <mtpl></mtpl> but the first one are equal to 

<math display="inline" id="System_of_polynomial_equations:8">
<semantics>
<mn>1</mn>
<annotation-xml encoding="MathML-Content">
<cn type="integer">1</cn>
</annotation-xml>
<annotation encoding="application/x-tex">
   1
  </annotation>
</semantics>
</math>

. For getting such regular chains, one may have to add a further variable, called <em>separating variable</em>, which is given the index 

<math display="inline" id="System_of_polynomial_equations:9">
<semantics>
<mn>0</mn>
<annotation-xml encoding="MathML-Content">
<cn type="integer">0</cn>
</annotation-xml>
</semantics>
</math>

. The <em>rational univariate representation</em>, described below, allows to compute such a special regular chain, satisfying Dahan–Schost bound, by starting from either a regular chain or a Gröbner basis.</p>
<h3 id="rational-univariate-representation">Rational Univariate Representation</h3>

<p>The <em>rational univariate representation</em> or RUR is a representation of the solutions of a zero-dimensional polynomial system over the rational numbers which has been introduced by F. Rouillier <a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> for remedying to the above drawbacks of the regular chain representation.</p>

<p>A RUR of a zero-dimensional system consists in a linear combination <mtpl></mtpl> of the variables, called <em>separating variable</em>, and a system of equations<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>
<math display="block" id="System_of_polynomial_equations:10">
<semantics>
<mrow>
<mo>{</mo>
<mtable displaystyle="true">
<mtr>
<mtd columnalign="left">
<mrow>
<mrow>
<mi>h</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mn>0</mn>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
</mtd>
<mtd></mtd>
</mtr>
<mtr>
<mtd columnalign="left">
<mrow>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<mo>=</mo>
<mrow>
<mrow>
<mrow>
<msub>
<mi>g</mi>
<mn>1</mn>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mn>0</mn>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>/</mo>
<msub>
<mi>g</mi>
<mn>0</mn>
</msub>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mn>0</mn>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mtd>
<mtd></mtd>
</mtr>
<mtr>
<mtd columnalign="left">
<mi mathvariant="normal">⋯</mi>
</mtd>
<mtd></mtd>
</mtr>
<mtr>
<mtd columnalign="left">
<mrow>
<msub>
<mi>x</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<mrow>
<mrow>
<mrow>
<msub>
<mi>g</mi>
<mi>n</mi>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mn>0</mn>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>/</mo>
<msub>
<mi>g</mi>
<mn>0</mn>
</msub>
</mrow>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mn>0</mn>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
</mtd>
<mtd></mtd>
</mtr>
</mtable>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">cases</csymbol>
<apply>
<eq></eq>
<apply>
<times></times>
<ci>h</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<cn type="integer">0</cn>
</apply>
<mtext>otherwise</mtext>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">0</cn>
</apply>
</apply>
</apply>
<mtext>otherwise</mtext>
<ci>normal-⋯</ci>
<mtext>otherwise</mtext>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>n</ci>
</apply>
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<ci>n</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">0</cn>
</apply>
</apply>
</apply>
<mtext>otherwise</mtext>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \begin{cases}h(x_{0})=0\\
x_{1}=g_{1}(x_{0})/g_{0}(x_{0})\\
\cdots\\
x_{n}=g_{n}(x_{0})/g_{0}(x_{0})\end{cases}
  </annotation>
</semantics>
</math>

 where 

<math display="inline" id="System_of_polynomial_equations:11">
<semantics>
<mi>h</mi>
<annotation-xml encoding="MathML-Content">
<ci>h</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   h
  </annotation>
</semantics>
</math>

 is a univariate polynomial in <mtpl></mtpl> of degree 

<math display="inline" id="System_of_polynomial_equations:12">
<semantics>
<mi>D</mi>
<annotation-xml encoding="MathML-Content">
<ci>D</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   D
  </annotation>
</semantics>
</math>

 and <mtpl></mtpl> are univariate polynomials in <mtpl></mtpl> of degree less than 

<math display="inline" id="System_of_polynomial_equations:13">
<semantics>
<mi>D</mi>
<annotation-xml encoding="MathML-Content">
<ci>D</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   D
  </annotation>
</semantics>
</math>

.</p>

<p>Given a zero-dimensional polynomial system over the rational numbers, the RUR has the following properties.</p>
<ul>
<li>All but a finite number linear combinations of the variables are separating variables.</li>
<li>When the separating variable is chosen, the RUR exists and is unique. In particular 

<math display="inline" id="System_of_polynomial_equations:14">
<semantics>
<mi>h</mi>
<annotation-xml encoding="MathML-Content">
<ci>h</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   h
  </annotation>
</semantics>
</math>

 and the <mtpl></mtpl> are defined independently of any algorithm to compute them.</li>
<li>The solutions of the system are in one to one correspondence with the roots of 

<math display="inline" id="System_of_polynomial_equations:15">
<semantics>
<mi>h</mi>
<annotation-xml encoding="MathML-Content">
<ci>h</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   h
  </annotation>
</semantics>
</math>

 and the <a href="Multiplicity_(mathematics)" title="wikilink">multiplicity</a> of each root of 

<math display="inline" id="System_of_polynomial_equations:16">
<semantics>
<mi>h</mi>
<annotation-xml encoding="MathML-Content">
<ci>h</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   h
  </annotation>
</semantics>
</math>

 equals the multiplicity of the corresponding solution.</li>
<li>The solutions of the system are obtained by substituting the roots of 

<math display="inline" id="System_of_polynomial_equations:17">
<semantics>
<mi>h</mi>
<annotation-xml encoding="MathML-Content">
<ci>h</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   h
  </annotation>
</semantics>
</math>

 in the other equations.</li>
<li>If 

<math display="inline" id="System_of_polynomial_equations:18">
<semantics>
<mi>h</mi>
<annotation-xml encoding="MathML-Content">
<ci>h</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   h
  </annotation>
</semantics>
</math>

 does not have any multiple root then <mtpl></mtpl> is the <a href="formal_derivative" title="wikilink">derivative</a> of 

<math display="inline" id="System_of_polynomial_equations:19">
<semantics>
<mi>h</mi>
<annotation-xml encoding="MathML-Content">
<ci>h</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   h
  </annotation>
</semantics>
</math>

.</li>
</ul>

<p>For example, for above system, every linear combination of the variable, except the multiples of 

<math display="inline" id="System_of_polynomial_equations:20">
<semantics>
<mi>x</mi>
<annotation-xml encoding="MathML-Content">
<ci>x</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   x
  </annotation>
</semantics>
</math>

, 

<math display="inline" id="System_of_polynomial_equations:21">
<semantics>
<mi>y</mi>
<annotation-xml encoding="MathML-Content">
<ci>y</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   y
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="System_of_polynomial_equations:22">
<semantics>
<mrow>
<mi>x</mi>
<mo>+</mo>
<mi>y</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<plus></plus>
<ci>x</ci>
<ci>y</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x+y
  </annotation>
</semantics>
</math>

, is a separating variable. If one choose 

<math display="inline" id="System_of_polynomial_equations:23">
<semantics>
<mrow>
<mi>t</mi>
<mo>=</mo>
<mrow>
<mi>x</mi>
<mfrac>
<mi mathvariant="normal">–</mi>
<mi>y</mi>
</mfrac>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>t</ci>
<apply>
<times></times>
<ci>x</ci>
<apply>
<divide></divide>
<ci>normal-–</ci>
<ci>y</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   t=x\frac{–}{y}
  </annotation>
</semantics>
</math>

 as a separating variable, then the RUR is</p>

<p>
<math display="block" id="System_of_polynomial_equations:24">
<semantics>
<mrow>
<mo>{</mo>
<mtable displaystyle="true">
<mtr>
<mtd columnalign="left">
<mrow>
<mrow>
<msup>
<mi>t</mi>
<mn>3</mn>
</msup>
<mo>-</mo>
<mi>t</mi>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
</mtd>
<mtd></mtd>
</mtr>
<mtr>
<mtd columnalign="left">
<mrow>
<mi>x</mi>
<mo>=</mo>
<mstyle displaystyle="false">
<mfrac>
<mrow>
<mrow>
<msup>
<mi>t</mi>
<mn>2</mn>
</msup>
<mo>+</mo>
<mrow>
<mn>2</mn>
<mi>t</mi>
</mrow>
</mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mrow>
<mrow>
<mn>3</mn>
<msup>
<mi>t</mi>
<mn>2</mn>
</msup>
</mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</mfrac>
</mstyle>
</mrow>
</mtd>
<mtd></mtd>
</mtr>
<mtr>
<mtd columnalign="left">
<mrow>
<mi>y</mi>
<mo>=</mo>
<mstyle displaystyle="false">
<mfrac>
<mrow>
<msup>
<mi>t</mi>
<mn>2</mn>
</msup>
<mo>-</mo>
<mrow>
<mn>2</mn>
<mi>t</mi>
</mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mrow>
<mrow>
<mn>3</mn>
<msup>
<mi>t</mi>
<mn>2</mn>
</msup>
</mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
</mfrac>
</mstyle>
</mrow>
</mtd>
<mtd></mtd>
</mtr>
</mtable>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="latexml">cases</csymbol>
<apply>
<eq></eq>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>t</ci>
<cn type="integer">3</cn>
</apply>
<ci>t</ci>
</apply>
<cn type="integer">0</cn>
</apply>
<mtext>otherwise</mtext>
<apply>
<eq></eq>
<ci>x</ci>
<apply>
<divide></divide>
<apply>
<minus></minus>
<apply>
<plus></plus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>t</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>t</ci>
</apply>
</apply>
<cn type="integer">1</cn>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<cn type="integer">3</cn>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>t</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<mtext>otherwise</mtext>
<apply>
<eq></eq>
<ci>y</ci>
<apply>
<divide></divide>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>t</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<times></times>
<cn type="integer">2</cn>
<ci>t</ci>
</apply>
<cn type="integer">1</cn>
</apply>
<apply>
<minus></minus>
<apply>
<times></times>
<cn type="integer">3</cn>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>t</ci>
<cn type="integer">2</cn>
</apply>
</apply>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<mtext>otherwise</mtext>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \begin{cases}t^{3}-t=0\\
x=\frac{t^{2}+2t-1}{3t^{2}-1}\\
y=\frac{t^{2}-2t-1}{3t^{2}-1}\\
\end{cases}
  </annotation>
</semantics>
</math>
</p>

<p>The RUR is uniquely defined for a given separating variable, independently of any algorithm and, it preserves the multiplicities of the roots. This is a notable difference with triangular decompositions (even the equiprojectable decomposition), which, in general, do not preserve multiplicities. The RUR shares with equiprojectable decomposition the property of producing an output with coefficients of relatively small size.</p>

<p>For zero-dimensional systems, the RUR allows to get the numeric values of the solutions by solving a single univariate polynomial and substituting them in rational functions. This allows to provide certified approximations of the solutions to any given precision.</p>

<p>Moreover, the univariate polynomial <mtpl></mtpl> of the RUR may be factorized, and this gives a RUR for every irreducible factor. This provides the <em>prime decomposition</em> of the given ideal (that is the <a href="primary_decomposition" title="wikilink">primary decomposition</a> of the <a href="radical_of_an_ideal" title="wikilink">radical</a> of the ideal). In practice, this provides an output with much smaller coefficients, especially in the case of systems with high multiplicities.</p>

<p>Contrarily to triangular decompositions and equiprojectable decompositions, the RUR is not defined in positive dimension.</p>
<h2 id="algorithms-for-numerically-solving">Algorithms for numerically solving</h2>
<h3 id="general-solving-algorithms">General solving algorithms</h3>

<p>The general numerical algorithms which are designed for any system of <a href="simultaneous_equations" title="wikilink">simultaneous equations</a> work also for polynomial systems. However the specific methods will generally be preferred, as the general methods generally do not allow to find <em>all</em> solutions. Especially, when a general method does not find any solution, this is usually not an indication that there is no solution.</p>

<p>Nevertheless two methods deserve to be mentioned here.</p>
<ul>
<li><a href="Newton's_method" title="wikilink">Newton's method</a> may be used if the number of equations is equal to the number of variables. It does not allow to find all the solutions nor to prove that there is no solution. But it is very fast when starting from a point which is close to a solution. Therefore it is a basic tool for Homotopy Continuation method described below.</li>
</ul>
<ul>
<li><a href="Optimization_(mathematics)" title="wikilink">Optimization</a> is rarely used for solving polynomial systems, but it succeeded, around 1970, to show that a system of 81 quadratic equations in 56 variables is not inconsistent.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> With the other known methods this system remains beyond the possibilities of modern technology. This method consists simply in minimizing the sum of the squares of the equations. If zero is found as a local minimum, then it is attained at a solution. This method works for overdetermined systems, but outputs an empty information if all local minimums which are found are positive.</li>
</ul>
<h3 id="homotopy-continuation-method">Homotopy continuation method</h3>

<p>This is a semi-numeric method which supposes that the number of equations is equal to the number of variables. This method is relatively old but it has been dramatically improved in the last decades by J. Verschelde and his associates.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>This method divides into three steps. First an upper bound on the number of solutions is computed. This bound has to be as sharp as possible. Therefore it is computed by, at least, four different methods and the best value, say <em>N</em>, is kept.</p>

<p>In the second step, a system 

<math display="inline" id="System_of_polynomial_equations:25">
<semantics>
<mrow>
<mrow>
<msub>
<mi>g</mi>
<mn>1</mn>
</msub>
<mo>=</mo>
<mrow>
<mn>0</mn>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
</mrow>
</mrow>
<mo>,</mo>
<mrow>
<msub>
<mi>g</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<mn>0</mn>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<cn type="integer">1</cn>
</apply>
<list>
<cn type="integer">0</cn>
<ci>normal-…</ci>
</list>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<ci>n</ci>
</apply>
<cn type="integer">0</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   g_{1}=0,\ldots,g_{n}=0
  </annotation>
</semantics>
</math>

 of polynomial equations is generated which has exactly <em>N</em> solutions that are easy to compute. This new system has the same number <em>n</em> of variables and the same number <em>n</em> of equations and the same general structure as the system to solve, 

<math display="inline" id="System_of_polynomial_equations:26">
<semantics>
<mrow>
<mrow>
<msub>
<mi>f</mi>
<mn>1</mn>
</msub>
<mo>=</mo>
<mrow>
<mn>0</mn>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
</mrow>
</mrow>
<mo>,</mo>
<mrow>
<msub>
<mi>f</mi>
<mi>n</mi>
</msub>
<mo>=</mo>
<mn>0</mn>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<cn type="integer">1</cn>
</apply>
<list>
<cn type="integer">0</cn>
<ci>normal-…</ci>
</list>
</apply>
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<ci>n</ci>
</apply>
<cn type="integer">0</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f_{1}=0,\ldots,f_{n}=0
  </annotation>
</semantics>
</math>

.</p>

<p>Then a <a class="uri" href="homotopy" title="wikilink">homotopy</a> between the two systems is considered. It consists, for example, of the straight line between the two systems, but other paths may be considered, in particular to avoid some singularities, in the system</p>

<p>
<math display="block" id="System_of_polynomial_equations:27">
<semantics>
<mrow>
<mrow>
<mrow>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>t</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<msub>
<mi>g</mi>
<mn>1</mn>
</msub>
</mrow>
<mo>+</mo>
<mrow>
<mi>t</mi>
<msub>
<mi>f</mi>
<mn>1</mn>
</msub>
</mrow>
</mrow>
<mo>=</mo>
<mrow>
<mn>0</mn>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
</mrow>
</mrow>
<mo>,</mo>
<mrow>
<mrow>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>-</mo>
<mi>t</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<msub>
<mi>g</mi>
<mi>n</mi>
</msub>
</mrow>
<mo>+</mo>
<mrow>
<mi>t</mi>
<msub>
<mi>f</mi>
<mi>n</mi>
</msub>
</mrow>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<apply>
<eq></eq>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>t</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<times></times>
<ci>t</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<list>
<cn type="integer">0</cn>
<ci>normal-…</ci>
</list>
</apply>
<apply>
<eq></eq>
<apply>
<plus></plus>
<apply>
<times></times>
<apply>
<minus></minus>
<cn type="integer">1</cn>
<ci>t</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>g</ci>
<ci>n</ci>
</apply>
</apply>
<apply>
<times></times>
<ci>t</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>f</ci>
<ci>n</ci>
</apply>
</apply>
</apply>
<cn type="integer">0</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (1-t)g_{1}+tf_{1}=0,\ldots,(1-t)g_{n}+tf_{n}=0
  </annotation>
</semantics>
</math>

.</p>

<p>The homotopy continuation consists in deforming the parameter <em>t</em> from 0 to 1 and <em>following</em> the <em>N</em> solutions during this deformation. This gives the desired solutions for <em>t</em> = 1. <em>Following</em> means that, if 

<math display="inline" id="System_of_polynomial_equations:28">
<semantics>
<mrow>
<mi>t</mi>
<mo>=</mo>
<msub>
<mi>t</mi>
<mn>1</mn>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>t</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>t</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   t=t_{1}
  </annotation>
</semantics>
</math>

 are deduced from the solutions for 

<math display="inline" id="System_of_polynomial_equations:29">
<semantics>
<mrow>
<mrow>
<msub>
<mi>t</mi>
<mn>2</mn>
</msub>
<mo>-</mo>
<msub>
<mi>t</mi>
<mn>1</mn>
</msub>
</mrow>
<mo>:</mo>
<mi></mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>t</ci>
<cn type="integer">2</cn>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>t</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<csymbol cd="latexml">absent</csymbol>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   t_{2}-t_{1}:
  </annotation>
</semantics>
</math>

 by Newton's method. The difficulty here is to well choose the value of 

<math display="block" id="System_of_polynomial_equations:0">
 <semantics>
  <mrow>
   <mi>sin</mi>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>3</mn>
   </msup>
   <mo>+</mo>
   <mi>cos</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>3</mn>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <mn>0</mn>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <sin></sin>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cn type="integer">3</cn>
    </apply>
    <plus></plus>
    <cos></cos>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">3</cn>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cn type="integer">0</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sin(x)^{3}+\cos(3x)=0\,
  </annotation>
 </semantics>
</math>

 Too large, Newton's convergence may be slow and may even jump from a solution path to another one. Too small, and the number of steps slows down the method.</p>
<h3 id="numerically-solving-from-the-rational-univariate-representation">Numerically solving from the Rational Univariate Representation</h3>

<p>To deduce the numeric values of the solutions from a RUR seems easy: it suffices to compute the roots of the univariate polynomial and to substitute them in the other equations. This is not so easy because the evaluation of a polynomial at the roots of another polynomial is highly unstable.</p>

<p>The roots of the univariate polynomial have thus to be computed at a high precision which may not be defined once for all. There are two algorithms which fulfill this requirement.</p>
<ul>
<li><a href="Aberth_method" title="wikilink">Aberth method</a>, implemented in <a class="uri" href="MPSolve" title="wikilink">MPSolve</a> computes all the complex roots to any precision.</li>
<li>Uspensky's algorithm of Collins and Akritas,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> improved by Rouillier and Zimmermann <a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> and based on <a href="Descartes'_rule_of_signs" title="wikilink">Descartes' rule of signs</a>. This algorithms computes the real roots, isolated in intervals of arbitrary small width. It is implemented in <a href="Maple_(software)" title="wikilink">Maple</a> (functions <em>fsolve</em> and <em>RootFinding[Isolate]</em>).</li>
</ul>
<h2 id="software-packages">Software packages</h2>

<p>There are at least four software packages which can solve zero-dimensional systems automatically (by automatically, one means that no human intervention is needed between input and output, and thus that no knowledge of the method by the user is needed). There are also several other software packages which may be useful for solving zero-dimensional systems. Some of them are listed after the automatic solvers.</p>

<p>The <a href="Maple_(software)" title="wikilink">Maple</a> function <em>RootFinding[Isolate]</em> takes as input any polynomial system over the rational numbers (if some coefficients are <a href="floating_point" title="wikilink">floating point</a> numbers, they are converted to rational numbers) and outputs the real solutions represented either (optionally) as intervals of rational numbers or as floating point approximations of arbitrary precision. If the system is not zero dimensional, this is signaled as an error.</p>

<p>Internally, this solver, designed by F. Rouillier computes first a Gröbner basis and then a Rational Univariate Representation from which the required approximation of the solutions are deduced. It works routinely for systems having up to a few hundred complex solutions.</p>

<p>The rational univariate representation may be computed with <a href="Maple_(software)" title="wikilink">Maple</a> function <em>Groebner[RationalUnivariateRepresentation]</em>.</p>

<p>To extract all the complex solutions from a rational univariate representation, one may use <a class="uri" href="MPSolve" title="wikilink">MPSolve</a>, which computes the complex roots of univariate polynomials to any precision. It is recommended to run <a class="uri" href="MPSolve" title="wikilink">MPSolve</a> several times, doubling the precision each time, until solutions remain stable, as the substitution of the roots in the equations of the input variables can be highly unstable.</p>

<p>The second solver is PHCpack,<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a><a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> written under the direction of J. Verschelde. PHCpack implements the homotopy continuation method. This solver computes the isolated complex solutions of polynomial systems having as many equations as variables.</p>

<p>The third solver is Bertini,<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a><a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> written by D. J. Bates, J. D. Hauenstein, A. J. Sommese, and C. W. Wampler. Bertini uses numerical homotopy continuation with adaptive precision. In addition to computing zero-dimensional solution sets, both PHCpack and Bertini are capable of working with positive dimensional solution sets.</p>

<p>The fourth solver is the <a href="Maple_(software)" title="wikilink">Maple</a> command <em>RegularChains[RealTriangularize]</em>. For any zero-dimensional input system with rational number coefficients it returns those solutions whose coordinates are real algebraic numbers. Each of these real numbers is encoded by an isolation interval and a defining polynomial.</p>

<p>The command <em>RegularChains[RealTriangularize]</em> is part of the <a href="Maple_(software)" title="wikilink">Maple</a> library <a class="uri" href="RegularChains" title="wikilink">RegularChains</a>, written by Marc Moreno-Maza, his students and post-doctoral fellows (listed in chronological order of graduation) Francois Lemaire, Yuzhen Xie, Xin Li, Xiao Rong, Liyun Li, Wei Pan and Changbo Chen. Other contributors are Eric Schost, Bican Xia and Wenyuan Wu. This library provides a large set of functionalities for solving zero-dimensional and positive dimensional systems. In both cases, for input systems with rational number coefficients, routines for isolating the real solutions are available. For arbitrary input system of polynomial equations and inequations (with rational number coefficients or with coefficients in a prime field) one can use the command <em>RegularChains[Triangularize]</em> for computing the solutions whose coordinates are in the algebraic closure of the coefficient field. The underlying algorithms are based on the notion of a <a href="regular_chain" title="wikilink">regular chain</a>.</p>

<p>While the command RegularChains[RealTriangularize] is currently limited to zero-dimensional systems, a future release will be able to process any system of polynomial equations, inequations and inequalities. The corresponding new algorithm<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> is based on the concept of a <a href="regular_semi-algebraic_system" title="wikilink">regular semi-algebraic system</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Triangular_decomposition" title="wikilink">Triangular decomposition</a></li>
<li><a href="Wu's_method_of_characteristic_set" title="wikilink">Wu's method of characteristic set</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Equations" title="wikilink">Category:Equations</a> <a class="uri" href="Category:Algebra" title="wikilink">Category:Algebra</a> <a href="Category:Computer_algebra" title="wikilink">Category:Computer algebra</a> <a class="uri" href="Category:Polynomials" title="wikilink">Category:Polynomials</a> <a href="Category:Algebraic_geometry" title="wikilink">Category:Algebraic geometry</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Songxin Liang, J. Gerhard, D.J. Jeffrey, G. Moroz, <em>A Package for Solving Parametric Polynomial Systems</em>. Communications in Computer Algebra (2009)<a href="#fnref1">↩</a></li>
<li id="fn2">P. Aubry, M. Moreno Maza, <em>Triangular Sets for Solving Polynomial Systems: a Comparative Implementation of Four Methods</em>. J. Symb. Comput. <strong>28</strong>, 1999<a href="#fnref2">↩</a></li>
<li id="fn3">Faugère, J.C., Gianni, P., Lazard, D. and Mora, T., <em>Efficient Computation of Zero-Dimensional Gröbner Basis by Change of Ordering</em>. Journal of Symbolic Computation, <strong>16</strong>, 1993<a href="#fnref3">↩</a></li>
<li id="fn4">D. Lazard, <em>Solving zero-dimensional algebraic systems</em>. Journal of Symbolic Computation <strong>13</strong>, 1992<a href="#fnref4">↩</a></li>
<li id="fn5">Xavier Dahan and Eric Schost. <em>Sharp Estimates for Triangular Sets</em>. In proc. ISSAC'04, pages 103--110, ACM Press, 2004<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7">Changbo Chen and Marc Moreno-Maza. <em>Algorithms for Computing Triangular Decomposition of Polynomial Systems</em>.In proc. ISSAC'2011, pages 83-90, ACM Press, 2011 and Journal of Symbolic Computation (to appear)<a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10">Daniel Lazard, <em>Thirty years of Polynomial System Solving, and now?</em> J. Symb. Comput. <strong>44</strong> (2009)<a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12">George E. Collins and Alkiviadis G. Akritas, <em>Polynomial Real Root Isolation Using Descarte's Rule of Signs</em>. Proceedings of the 1976 ACM Symposium on Symbolic and Algebraic Computation<a href="#fnref12">↩</a></li>
<li id="fn13">F. Rouillier and P. Zimmerman, <em>Efficient isolation of polynomial's real roots</em>. Journal of Computational and Applied Mathematics <strong>162</strong> (2004)<a href="#fnref13">↩</a></li>
<li id="fn14"></li>
<li id="fn15"><a href="http://www.math.uic.edu/~jan/download.html">Release 2.3.86 of PHCpack</a><a href="#fnref15">↩</a></li>
<li id="fn16">Bates, D. J., Hauenstein, J. D., Sommese, A. J., &amp; Wampler, C. W. (2013). Numerically solving polynomial systems with Bertini (Vol. 25). SIAM.<a href="#fnref16">↩</a></li>
<li id="fn17"><a href="http://bertini.nd.edu/">Bertini: Software for Numerical Algebraic Geometry</a><a href="#fnref17">↩</a></li>
<li id="fn18">Changbo Chen, James H. Davenport, John P. May, Marc Moreno-Maza, Bican Xia, Rong Xiao. Triangular decomposition of semi-algebraic systems. Proceedings of 2010 International Symposium on Symbolic and Algebraic Computation (ISSAC 2010), ACM Press, pp. 187--194, 2010.<a href="#fnref18">↩</a></li>
</ol>
</section>
</body>
</html>
