<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1516">Sidi's generalized secant method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Sidi's generalized secant method</h1>
<hr/>

<p><strong>Sidi's generalized secant method</strong> is a <a href="root-finding_algorithm" title="wikilink">root-finding algorithm</a>, that is, a <a href="numerical_method" title="wikilink">numerical method</a> for solving <a class="uri" href="equations" title="wikilink">equations</a> of the form 

<math display="inline" id="Sidi's_generalized_secant_method:0">
<semantics>
<mrow>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>f</ci>
<ci>x</ci>
</apply>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f(x)=0
  </annotation>
</semantics>
</math>

 . The method was published by Avram Sidi.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The method is a generalization of the <a href="secant_method" title="wikilink">secant method</a>. Like the secant method, it is an <a href="iterative_method" title="wikilink">iterative method</a> which requires one evaluation of 

<math display="inline" id="Sidi's_generalized_secant_method:1">
<semantics>
<mi>f</mi>
<annotation-xml encoding="MathML-Content">
<ci>f</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   f
  </annotation>
</semantics>
</math>

 in each iteration and no <a href="derivative" title="wikilink">derivatives</a> of 

<math display="inline" id="Sidi's_generalized_secant_method:2">
<semantics>
<mi>f</mi>
<annotation-xml encoding="MathML-Content">
<ci>f</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   f
  </annotation>
</semantics>
</math>

. The method can converge much faster though, with an <a href="Rate_of_convergence" title="wikilink">order</a> which approaches 2 provided that 

<math display="inline" id="Sidi's_generalized_secant_method:3">
<semantics>
<mi>f</mi>
<annotation-xml encoding="MathML-Content">
<ci>f</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   f
  </annotation>
</semantics>
</math>

 satisfies the regularity conditions described below.</p>
<h2 id="algorithm">Algorithm</h2>

<p>We call 

<math display="inline" id="Sidi's_generalized_secant_method:4">
<semantics>
<mi>α</mi>
<annotation-xml encoding="MathML-Content">
<ci>α</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \alpha
  </annotation>
</semantics>
</math>

 the root of 

<math display="inline" id="Sidi's_generalized_secant_method:5">
<semantics>
<mi>f</mi>
<annotation-xml encoding="MathML-Content">
<ci>f</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   f
  </annotation>
</semantics>
</math>

, that is, 

<math display="inline" id="Sidi's_generalized_secant_method:6">
<semantics>
<mrow>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>α</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>f</ci>
<ci>α</ci>
</apply>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f(\alpha)=0
  </annotation>
</semantics>
</math>

. Sidi's method is an iterative method which generates a <a class="uri" href="sequence" title="wikilink">sequence</a>
<math display="inline" id="Sidi's_generalized_secant_method:7">
<semantics>
<mrow>
<mo stretchy="false">{</mo>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
<mo stretchy="false">}</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<set>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
</set>
</annotation-xml>
<annotation encoding="application/x-tex">
   \{x_{i}\}
  </annotation>
</semantics>
</math>

 of approximations of 

<math display="inline" id="Sidi's_generalized_secant_method:8">
<semantics>
<mi>α</mi>
<annotation-xml encoding="MathML-Content">
<ci>α</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \alpha
  </annotation>
</semantics>
</math>

. Starting with <em>k</em> + 1 initial approximations 

<math display="inline" id="Sidi's_generalized_secant_method:9">
<semantics>
<mrow>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>x</mi>
<mrow>
<mi>k</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<plus></plus>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{1},\dots,x_{k+1}
  </annotation>
</semantics>
</math>

, the approximation 

<math display="inline" id="Sidi's_generalized_secant_method:10">
<semantics>
<msub>
<mi>x</mi>
<mrow>
<mi>k</mi>
<mo>+</mo>
<mn>2</mn>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<plus></plus>
<ci>k</ci>
<cn type="integer">2</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{k+2}
  </annotation>
</semantics>
</math>

 is calculated in the first iteration, the approximation 

<math display="inline" id="Sidi's_generalized_secant_method:11">
<semantics>
<msub>
<mi>x</mi>
<mrow>
<mi>k</mi>
<mo>+</mo>
<mn>3</mn>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<plus></plus>
<ci>k</ci>
<cn type="integer">3</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{k+3}
  </annotation>
</semantics>
</math>

 is calculated in the second iteration, etc. Each iteration takes as input the last <em>k</em> + 1 approximations and the value of 

<math display="inline" id="Sidi's_generalized_secant_method:12">
<semantics>
<mi>f</mi>
<annotation-xml encoding="MathML-Content">
<ci>f</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   f
  </annotation>
</semantics>
</math>

 at those approximations. Hence the <em>n</em>th iteration takes as input the approximations 

<math display="inline" id="Sidi's_generalized_secant_method:13">
<semantics>
<mrow>
<msub>
<mi>x</mi>
<mi>n</mi>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>x</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mi>k</mi>
</mrow>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>n</ci>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<plus></plus>
<ci>n</ci>
<ci>k</ci>
</apply>
</apply>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{n},\dots,x_{n+k}
  </annotation>
</semantics>
</math>

 and the values 

<math display="inline" id="Sidi's_generalized_secant_method:14">
<semantics>
<mrow>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mi>n</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mi>k</mi>
</mrow>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<apply>
<times></times>
<ci>f</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>n</ci>
</apply>
</apply>
<ci>normal-…</ci>
<apply>
<times></times>
<ci>f</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<plus></plus>
<ci>n</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   f(x_{n}),\dots,f(x_{n+k})
  </annotation>
</semantics>
</math>

.</p>

<p>The number <em>k</em> must be 1 or larger: <em>k</em> = 1, 2, 3, .... It remains fixed during the execution of the algorithm. In order to obtain the starting approximations 

<math display="inline" id="Sidi's_generalized_secant_method:15">
<semantics>
<mrow>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>x</mi>
<mrow>
<mi>k</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<plus></plus>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{1},\dots,x_{k+1}
  </annotation>
</semantics>
</math>

 one could carry out a few initializing iterations with a lower value of <em>k</em>.</p>

<p>The approximation 

<math display="inline" id="Sidi's_generalized_secant_method:16">
<semantics>
<msub>
<mi>x</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mi>k</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<plus></plus>
<ci>n</ci>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{n+k+1}
  </annotation>
</semantics>
</math>

 is calculated as follows in the <em>n</em>th iteration. A <a href="Polynomial_interpolation" title="wikilink">polynomial of interpolation</a>
<math display="inline" id="Sidi's_generalized_secant_method:17">
<semantics>
<mrow>
<msub>
<mi>p</mi>
<mrow>
<mi>n</mi>
<mo>,</mo>
<mi>k</mi>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<list>
<ci>n</ci>
<ci>k</ci>
</list>
</apply>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p_{n,k}(x)
  </annotation>
</semantics>
</math>

 of <a href="Degree_of_a_polynomial" title="wikilink">degree</a> <em>k</em> is fitted to the <em>k</em> + 1 points 

<math display="inline" id="Sidi's_generalized_secant_method:18">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mi>n</mi>
</msub>
<mo>,</mo>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mi>n</mi>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>,</mo>
<mrow>
<mi mathvariant="normal">…</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mi>k</mi>
</mrow>
</msub>
<mo>,</mo>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mi>k</mi>
</mrow>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>n</ci>
</apply>
<apply>
<times></times>
<ci>f</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>n</ci>
</apply>
</apply>
</interval>
<apply>
<times></times>
<ci>normal-…</ci>
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<plus></plus>
<ci>n</ci>
<ci>k</ci>
</apply>
</apply>
<apply>
<times></times>
<ci>f</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<plus></plus>
<ci>n</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
</interval>
</apply>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   (x_{n},f(x_{n})),\dots(x_{n+k},f(x_{n+k}))
  </annotation>
</semantics>
</math>

. With this polynomial, the next approximation 

<math display="inline" id="Sidi's_generalized_secant_method:19">
<semantics>
<msub>
<mi>x</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mi>k</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<plus></plus>
<ci>n</ci>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{n+k+1}
  </annotation>
</semantics>
</math>

 of 

<math display="inline" id="Sidi's_generalized_secant_method:20">
<semantics>
<mi>α</mi>
<annotation-xml encoding="MathML-Content">
<ci>α</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \alpha
  </annotation>
</semantics>
</math>

 is calculated as</p>

<p>with 

<math display="inline" id="Sidi's_generalized_secant_method:21">
<semantics>
<mrow>
<msubsup>
<mi>p</mi>
<mrow>
<mi>n</mi>
<mo>,</mo>
<mi>k</mi>
</mrow>
<mo>′</mo>
</msubsup>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mi>k</mi>
</mrow>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<list>
<ci>n</ci>
<ci>k</ci>
</list>
</apply>
<ci>normal-′</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<plus></plus>
<ci>n</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p_{n,k}^{\prime}(x_{n+k})
  </annotation>
</semantics>
</math>

 the derivative of 

<math display="inline" id="Sidi's_generalized_secant_method:22">
<semantics>
<msub>
<mi>p</mi>
<mrow>
<mi>n</mi>
<mo>,</mo>
<mi>k</mi>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<list>
<ci>n</ci>
<ci>k</ci>
</list>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p_{n,k}
  </annotation>
</semantics>
</math>

 at 

<math display="inline" id="Sidi's_generalized_secant_method:23">
<semantics>
<msub>
<mi>x</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mi>k</mi>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<plus></plus>
<ci>n</ci>
<ci>k</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{n+k}
  </annotation>
</semantics>
</math>

. Having calculated 

<math display="inline" id="Sidi's_generalized_secant_method:24">
<semantics>
<msub>
<mi>x</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mi>k</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<plus></plus>
<ci>n</ci>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{n+k+1}
  </annotation>
</semantics>
</math>

 one calculates 

<math display="inline" id="Sidi's_generalized_secant_method:25">
<semantics>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>x</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mi>k</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>f</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<plus></plus>
<ci>n</ci>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f(x_{n+k+1})
  </annotation>
</semantics>
</math>

 and the algorithm can continue with the (<em>n</em> + 1)th iteration. Clearly, this method requires the function 

<math display="inline" id="Sidi's_generalized_secant_method:26">
<semantics>
<mi>f</mi>
<annotation-xml encoding="MathML-Content">
<ci>f</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   f
  </annotation>
</semantics>
</math>

 to be evaluated only once per iteration; it requires no derivatives of 

<math display="inline" id="Sidi's_generalized_secant_method:27">
<semantics>
<mi>f</mi>
<annotation-xml encoding="MathML-Content">
<ci>f</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   f
  </annotation>
</semantics>
</math>

.</p>

<p>The iterative cycle is stopped if an appropriate stop-criterion is met. Typically the criterion is that the last calculated approximation is close enough to the sought-after root 

<math display="inline" id="Sidi's_generalized_secant_method:28">
<semantics>
<mi>α</mi>
<annotation-xml encoding="MathML-Content">
<ci>α</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \alpha
  </annotation>
</semantics>
</math>

.</p>

<p>To execute the algorithm effectively, Sidi's method calculates the interpolating polynomial 

<math display="inline" id="Sidi's_generalized_secant_method:29">
<semantics>
<mrow>
<msub>
<mi>p</mi>
<mrow>
<mi>n</mi>
<mo>,</mo>
<mi>k</mi>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<list>
<ci>n</ci>
<ci>k</ci>
</list>
</apply>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p_{n,k}(x)
  </annotation>
</semantics>
</math>

 in its <a href="Newton_polynomial" title="wikilink">Newton form</a>.</p>
<h2 id="convergence">Convergence</h2>

<p>Sidi showed that if the function 

<math display="inline" id="Sidi's_generalized_secant_method:30">
<semantics>
<mi>f</mi>
<annotation-xml encoding="MathML-Content">
<ci>f</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   f
  </annotation>
</semantics>
</math>

 is (<em>k</em> + 1)-times <a href="Smooth_function" title="wikilink">continuously differentiable</a> in an <a href="open_interval" title="wikilink">open interval</a>
<math display="inline" id="Sidi's_generalized_secant_method:31">
<semantics>
<mi>I</mi>
<annotation-xml encoding="MathML-Content">
<ci>I</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   I
  </annotation>
</semantics>
</math>

 containing 

<math display="inline" id="Sidi's_generalized_secant_method:32">
<semantics>
<mi>α</mi>
<annotation-xml encoding="MathML-Content">
<ci>α</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \alpha
  </annotation>
</semantics>
</math>

 (that is, 

<math display="inline" id="Sidi's_generalized_secant_method:33">
<semantics>
<mrow>
<mi>f</mi>
<mo>∈</mo>
<mrow>
<msup>
<mi>C</mi>
<mrow>
<mi>k</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>I</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>f</ci>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>C</ci>
<apply>
<plus></plus>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>I</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f\in C^{k+1}(I)
  </annotation>
</semantics>
</math>

), 

<math display="inline" id="Sidi's_generalized_secant_method:34">
<semantics>
<mi>α</mi>
<annotation-xml encoding="MathML-Content">
<ci>α</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \alpha
  </annotation>
</semantics>
</math>

 is a simple root of 

<math display="inline" id="Sidi's_generalized_secant_method:35">
<semantics>
<mi>f</mi>
<annotation-xml encoding="MathML-Content">
<ci>f</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   f
  </annotation>
</semantics>
</math>

 (that is, 

<math display="inline" id="Sidi's_generalized_secant_method:36">
<semantics>
<mrow>
<mrow>
<msup>
<mi>f</mi>
<mo>′</mo>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>α</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>≠</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<neq></neq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>f</ci>
<ci>normal-′</ci>
</apply>
<ci>α</ci>
</apply>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f^{\prime}(\alpha)\neq 0
  </annotation>
</semantics>
</math>

) and the initial approximations 

<math display="inline" id="Sidi's_generalized_secant_method:37">
<semantics>
<mrow>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>x</mi>
<mrow>
<mi>k</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<list>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<plus></plus>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</list>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{1},\dots,x_{k+1}
  </annotation>
</semantics>
</math>

 are chosen close enough to 

<math display="inline" id="Sidi's_generalized_secant_method:38">
<semantics>
<mi>α</mi>
<annotation-xml encoding="MathML-Content">
<ci>α</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \alpha
  </annotation>
</semantics>
</math>

, then the sequence 

<math display="inline" id="Sidi's_generalized_secant_method:39">
<semantics>
<mrow>
<mo stretchy="false">{</mo>
<msub>
<mi>x</mi>
<mi>i</mi>
</msub>
<mo stretchy="false">}</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<set>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>i</ci>
</apply>
</set>
</annotation-xml>
<annotation encoding="application/x-tex">
   \{x_{i}\}
  </annotation>
</semantics>
</math>

 converges to 

<math display="inline" id="Sidi's_generalized_secant_method:40">
<semantics>
<mi>α</mi>
<annotation-xml encoding="MathML-Content">
<ci>α</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \alpha
  </annotation>
</semantics>
</math>

, meaning that the following <a href="Limit_of_a_sequence" title="wikilink">limit</a> holds

<math display="block" id="Sidi's_generalized_secant_method:41">
<semantics>
<mrow>
<mrow>
<munder>
<mo movablelimits="false">lim</mo>
<mrow>
<mi>n</mi>
<mo>→</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</munder>
<msub>
<mi>x</mi>
<mi>n</mi>
</msub>
</mrow>
<mo>=</mo>
<mi>α</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<limit></limit>
<apply>
<ci>normal-→</ci>
<ci>n</ci>
<infinity></infinity>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>n</ci>
</apply>
</apply>
<ci>α</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lim\limits_{n\to\infty}x_{n}=\alpha
  </annotation>
</semantics>
</math>

.</p>

<p>Sidi furthermore showed that</p>

<p>
<math display="block" id="Sidi's_generalized_secant_method:42">
<semantics>
<mrow>
<mrow>
<mrow>
<munder>
<mo movablelimits="false">lim</mo>
<mrow>
<mi>n</mi>
<mo>→</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</munder>
<mfrac>
<mrow>
<msub>
<mi>x</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>-</mo>
<mi>α</mi>
</mrow>
<mrow>
<msubsup>
<mo largeop="true" symmetric="true">∏</mo>
<mrow>
<mi>i</mi>
<mo>=</mo>
<mn>0</mn>
</mrow>
<mi>k</mi>
</msubsup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>x</mi>
<mrow>
<mi>n</mi>
<mo>-</mo>
<mi>i</mi>
</mrow>
</msub>
<mo>-</mo>
<mi>α</mi>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
</mrow>
<mo>=</mo>
<mi>L</mi>
<mo>=</mo>
<mrow>
<mfrac>
<msup>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mrow>
<mi>k</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msup>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>k</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo lspace="0pt" rspace="3.5pt">!</mo>
</mrow>
</mfrac>
<mfrac>
<mrow>
<msup>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mi>k</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>α</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mrow>
<msup>
<mi>f</mi>
<mo>′</mo>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>α</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mfrac>
</mrow>
</mrow>
<mo>,</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<limit></limit>
<apply>
<ci>normal-→</ci>
<ci>n</ci>
<infinity></infinity>
</apply>
</apply>
<apply>
<divide></divide>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<plus></plus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>α</ci>
</apply>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<csymbol cd="latexml">product</csymbol>
<ci>k</ci>
</apply>
<apply>
<eq></eq>
<ci>i</ci>
<cn type="integer">0</cn>
</apply>
</apply>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<minus></minus>
<ci>n</ci>
<ci>i</ci>
</apply>
</apply>
<ci>α</ci>
</apply>
</apply>
</apply>
</apply>
<ci>L</ci>
</apply>
<apply>
<eq></eq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<apply>
<divide></divide>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<minus></minus>
<cn type="integer">1</cn>
</apply>
<apply>
<plus></plus>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<factorial></factorial>
<apply>
<plus></plus>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</apply>
<apply>
<divide></divide>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>f</ci>
<apply>
<plus></plus>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>α</ci>
</apply>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>f</ci>
<ci>normal-′</ci>
</apply>
<ci>α</ci>
</apply>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lim_{n\to\infty}\frac{x_{n+1}-\alpha}{\prod^{k}_{i=0}(x_{n-i}-\alpha)}=L=%
\frac{(-1)^{k+1}}{(k+1)!}\frac{f^{(k+1)}(\alpha)}{f^{\prime}(\alpha)},
  </annotation>
</semantics>
</math>
</p>

<p>and that the sequence <a href="Rate_of_convergence" title="wikilink">converges</a> to 

<math display="inline" id="Sidi's_generalized_secant_method:43">
<semantics>
<mi>α</mi>
<annotation-xml encoding="MathML-Content">
<ci>α</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \alpha
  </annotation>
</semantics>
</math>

 of order 

<math display="inline" id="Sidi's_generalized_secant_method:44">
<semantics>
<msub>
<mi>ψ</mi>
<mi>k</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<ci>k</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \psi_{k}
  </annotation>
</semantics>
</math>

, i.e.</p>

<p>
<math display="block" id="Sidi's_generalized_secant_method:45">
<semantics>
<mrow>
<mrow>
<munder>
<mo movablelimits="false">lim</mo>
<mrow>
<mi>n</mi>
<mo>→</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</munder>
<mfrac>
<mrow>
<mo stretchy="false">|</mo>
<mrow>
<msub>
<mi>x</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<mo>-</mo>
<mi>α</mi>
</mrow>
<mo stretchy="false">|</mo>
</mrow>
<msup>
<mrow>
<mo stretchy="false">|</mo>
<mrow>
<msub>
<mi>x</mi>
<mi>n</mi>
</msub>
<mo>-</mo>
<mi>α</mi>
</mrow>
<mo stretchy="false">|</mo>
</mrow>
<msub>
<mi>ψ</mi>
<mi>k</mi>
</msub>
</msup>
</mfrac>
</mrow>
<mo>=</mo>
<msup>
<mrow>
<mo stretchy="false">|</mo>
<mi>L</mi>
<mo stretchy="false">|</mo>
</mrow>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<msub>
<mi>ψ</mi>
<mi>k</mi>
</msub>
<mo>-</mo>
<mn>1</mn>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>/</mo>
<mi>k</mi>
</mrow>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<limit></limit>
<apply>
<ci>normal-→</ci>
<ci>n</ci>
<infinity></infinity>
</apply>
</apply>
<apply>
<divide></divide>
<apply>
<abs></abs>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<plus></plus>
<ci>n</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>α</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<abs></abs>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<ci>n</ci>
</apply>
<ci>α</ci>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<ci>k</ci>
</apply>
</apply>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<abs></abs>
<ci>L</ci>
</apply>
<apply>
<divide></divide>
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<ci>k</ci>
</apply>
<cn type="integer">1</cn>
</apply>
<ci>k</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lim\limits_{n\to\infty}\frac{|x_{n+1}-\alpha|}{|x_{n}-\alpha|^{\psi_{k}}}=|L|%
^{(\psi_{k}-1)/k}
  </annotation>
</semantics>
</math>
</p>

<p>The order of convergence 

<math display="inline" id="Sidi's_generalized_secant_method:46">
<semantics>
<msub>
<mi>ψ</mi>
<mi>k</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<ci>k</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \psi_{k}
  </annotation>
</semantics>
</math>

 is the <a href="Descartes's_rule_of_signs" title="wikilink">only positive root</a> of the polynomial</p>

<p>
<math display="block" id="Sidi's_generalized_secant_method:47">
<semantics>
<mrow>
<msup>
<mi>s</mi>
<mrow>
<mi>k</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msup>
<mo>-</mo>
<msup>
<mi>s</mi>
<mi>k</mi>
</msup>
<mo>-</mo>
<msup>
<mi>s</mi>
<mrow>
<mi>k</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
</msup>
<mo>-</mo>
<mi mathvariant="normal">…</mi>
<mo>-</mo>
<mi>s</mi>
<mo>-</mo>
<mn>1</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<minus></minus>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>s</ci>
<apply>
<plus></plus>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>s</ci>
<ci>k</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>s</ci>
<apply>
<minus></minus>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
<ci>normal-…</ci>
<ci>s</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   s^{k+1}-s^{k}-s^{k-1}-\dots-s-1
  </annotation>
</semantics>
</math>
</p>

<p>We have e.g. 

<math display="inline" id="Sidi's_generalized_secant_method:48">
<semantics>
<mrow>
<msub>
<mi>ψ</mi>
<mn>1</mn>
</msub>
<mo>=</mo>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<mrow>
<mn>1</mn>
<mo>+</mo>
<msqrt>
<mn>5</mn>
</msqrt>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
<mo>/</mo>
<mn>2</mn>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<cn type="integer">1</cn>
</apply>
<apply>
<divide></divide>
<apply>
<plus></plus>
<cn type="integer">1</cn>
<apply>
<root></root>
<cn type="integer">5</cn>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \psi_{1}=(1+\sqrt{5})/2
  </annotation>
</semantics>
</math>

 ≈ 1.6180, 

<math display="inline" id="Sidi's_generalized_secant_method:49">
<semantics>
<msub>
<mi>ψ</mi>
<mn>2</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \psi_{2}
  </annotation>
</semantics>
</math>

 ≈ 1.8393 and 

<math display="inline" id="Sidi's_generalized_secant_method:50">
<semantics>
<msub>
<mi>ψ</mi>
<mn>3</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<cn type="integer">3</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \psi_{3}
  </annotation>
</semantics>
</math>

 ≈ 1.9276. The order approaches 2 from below if <em>k</em> becomes large

<math display="block" id="Sidi's_generalized_secant_method:51">
<semantics>
<mrow>
<mrow>
<munder>
<mo movablelimits="false">lim</mo>
<mrow>
<mi>k</mi>
<mo>→</mo>
<mi mathvariant="normal">∞</mi>
</mrow>
</munder>
<msub>
<mi>ψ</mi>
<mi>k</mi>
</msub>
</mrow>
<mo>=</mo>
<mn>2</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<limit></limit>
<apply>
<ci>normal-→</ci>
<ci>k</ci>
<infinity></infinity>
</apply>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>ψ</ci>
<ci>k</ci>
</apply>
</apply>
<cn type="integer">2</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \lim\limits_{k\to\infty}\psi_{k}=2
  </annotation>
</semantics>
</math>
<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="related-algorithms">Related algorithms</h2>

<p>Sidi's method reduces to the secant method if we take <em>k</em> = 1. In this case the polynomial 

<math display="inline" id="Sidi's_generalized_secant_method:52">
<semantics>
<mrow>
<msub>
<mi>p</mi>
<mrow>
<mi>n</mi>
<mo>,</mo>
<mn>1</mn>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<list>
<ci>n</ci>
<cn type="integer">1</cn>
</list>
</apply>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p_{n,1}(x)
  </annotation>
</semantics>
</math>

 is the linear approximation of 

<math display="inline" id="Sidi's_generalized_secant_method:53">
<semantics>
<mi>f</mi>
<annotation-xml encoding="MathML-Content">
<ci>f</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   f
  </annotation>
</semantics>
</math>

 around 

<math display="inline" id="Sidi's_generalized_secant_method:54">
<semantics>
<mi>α</mi>
<annotation-xml encoding="MathML-Content">
<ci>α</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \alpha
  </annotation>
</semantics>
</math>

 which is used in the <em>n</em>th iteration of the secant method.</p>

<p>We can expect that the larger we choose <em>k</em>, the better 

<math display="inline" id="Sidi's_generalized_secant_method:55">
<semantics>
<mrow>
<msub>
<mi>p</mi>
<mrow>
<mi>n</mi>
<mo>,</mo>
<mi>k</mi>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<list>
<ci>n</ci>
<ci>k</ci>
</list>
</apply>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p_{n,k}(x)
  </annotation>
</semantics>
</math>

 is an approximation of 

<math display="inline" id="Sidi's_generalized_secant_method:56">
<semantics>
<mrow>
<mi>f</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>f</ci>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f(x)
  </annotation>
</semantics>
</math>

 around 

<math display="inline" id="Sidi's_generalized_secant_method:57">
<semantics>
<mrow>
<mi>x</mi>
<mo>=</mo>
<mi>α</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>x</ci>
<ci>α</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x=\alpha
  </annotation>
</semantics>
</math>

. Also, the better 

<math display="inline" id="Sidi's_generalized_secant_method:58">
<semantics>
<mrow>
<msubsup>
<mi>p</mi>
<mrow>
<mi>n</mi>
<mo>,</mo>
<mi>k</mi>
</mrow>
<mo>′</mo>
</msubsup>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<list>
<ci>n</ci>
<ci>k</ci>
</list>
</apply>
<ci>normal-′</ci>
</apply>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p_{n,k}^{\prime}(x)
  </annotation>
</semantics>
</math>

 is an approximation of 

<math display="inline" id="Sidi's_generalized_secant_method:59">
<semantics>
<mrow>
<msup>
<mi>f</mi>
<mo>′</mo>
</msup>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>f</ci>
<ci>normal-′</ci>
</apply>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f^{\prime}(x)
  </annotation>
</semantics>
</math>

 around 

<math display="inline" id="Sidi's_generalized_secant_method:60">
<semantics>
<mrow>
<mi>x</mi>
<mo>=</mo>
<mi>α</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>x</ci>
<ci>α</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x=\alpha
  </annotation>
</semantics>
</math>

. If we replace 

<math display="inline" id="Sidi's_generalized_secant_method:61">
<semantics>
<msubsup>
<mi>p</mi>
<mrow>
<mi>n</mi>
<mo>,</mo>
<mi>k</mi>
</mrow>
<mo>′</mo>
</msubsup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<list>
<ci>n</ci>
<ci>k</ci>
</list>
</apply>
<ci>normal-′</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p_{n,k}^{\prime}
  </annotation>
</semantics>
</math>

 with 

<math display="inline" id="Sidi's_generalized_secant_method:62">
<semantics>
<msup>
<mi>f</mi>
<mo>′</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>f</ci>
<ci>normal-′</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f^{\prime}
  </annotation>
</semantics>
</math>

 in () we obtain that the next approximation in each iteration is calculated as</p>

<p>This is the <a href="Newton's_method" title="wikilink">Newton–Raphson method</a>. It starts off with a single approximation 

<math display="inline" id="Sidi's_generalized_secant_method:63">
<semantics>
<msub>
<mi>x</mi>
<mn>1</mn>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<cn type="integer">1</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{1}
  </annotation>
</semantics>
</math>

 so we can take <em>k</em> = 0 in (). It does not require an interpolating polynomial but instead one has to evaluate the derivative 

<math display="inline" id="Sidi's_generalized_secant_method:64">
<semantics>
<msup>
<mi>f</mi>
<mo>′</mo>
</msup>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>f</ci>
<ci>normal-′</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   f^{\prime}
  </annotation>
</semantics>
</math>

 in each iteration. Depending on the nature of 

<math display="inline" id="Sidi's_generalized_secant_method:65">
<semantics>
<mi>f</mi>
<annotation-xml encoding="MathML-Content">
<ci>f</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   f
  </annotation>
</semantics>
</math>

 this may not be possible or practical.</p>

<p>Once the interpolating polynomial 

<math display="inline" id="Sidi's_generalized_secant_method:66">
<semantics>
<mrow>
<msub>
<mi>p</mi>
<mrow>
<mi>n</mi>
<mo>,</mo>
<mi>k</mi>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<list>
<ci>n</ci>
<ci>k</ci>
</list>
</apply>
<ci>x</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p_{n,k}(x)
  </annotation>
</semantics>
</math>

 has been calculated, one can also calculate the next approximation 

<math display="inline" id="Sidi's_generalized_secant_method:67">
<semantics>
<msub>
<mi>x</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mi>k</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<plus></plus>
<ci>n</ci>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{n+k+1}
  </annotation>
</semantics>
</math>

 as a solution of 

<math display="inline" id="Sidi's_generalized_secant_method:68">
<semantics>
<mrow>
<mrow>
<msub>
<mi>p</mi>
<mrow>
<mi>n</mi>
<mo>,</mo>
<mi>k</mi>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<list>
<ci>n</ci>
<ci>k</ci>
</list>
</apply>
<ci>x</ci>
</apply>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p_{n,k}(x)=0
  </annotation>
</semantics>
</math>

 instead of using (). For <em>k</em> = 1 these two methods are identical: it is the secant method. For <em>k</em> = 2 this method is known as <a href="Muller's_method" title="wikilink">Muller's method</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> For <em>k</em> = 3 this approach involves finding the roots of a <a href="cubic_function" title="wikilink">cubic function</a>, which is unattractively complicated. This problem becomes worse for even larger values of <em>k</em>. An additional complication is that the equation 

<math display="inline" id="Sidi's_generalized_secant_method:69">
<semantics>
<mrow>
<mrow>
<msub>
<mi>p</mi>
<mrow>
<mi>n</mi>
<mo>,</mo>
<mi>k</mi>
</mrow>
</msub>
<mrow>
<mo stretchy="false">(</mo>
<mi>x</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mn>0</mn>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>p</ci>
<list>
<ci>n</ci>
<ci>k</ci>
</list>
</apply>
<ci>x</ci>
</apply>
<cn type="integer">0</cn>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   p_{n,k}(x)=0
  </annotation>
</semantics>
</math>

 will in general have <a href="Properties_of_polynomial_roots" title="wikilink">multiple solutions</a> and a prescription has to be given which of these solutions is the next approximation 

<math display="inline" id="Sidi's_generalized_secant_method:70">
<semantics>
<msub>
<mi>x</mi>
<mrow>
<mi>n</mi>
<mo>+</mo>
<mi>k</mi>
<mo>+</mo>
<mn>1</mn>
</mrow>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>x</ci>
<apply>
<plus></plus>
<ci>n</ci>
<ci>k</ci>
<cn type="integer">1</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   x_{n+k+1}
  </annotation>
</semantics>
</math>

. Muller does this for the case <em>k</em> = 2 but no such prescriptions appear to exist for <em>k</em> &gt; 2.</p>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Root-finding_algorithms" title="wikilink">Category:Root-finding algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Sidi, Avram, "Generalization Of The Secant Method For Nonlinear Equations", Applied Mathematics E-notes <strong>8</strong> (2008), 115–123, <a class="uri" href="http://www.math.nthu.edu.tw/~amen/2008/070227-1.pdf">http://www.math.nthu.edu.tw/~amen/2008/070227-1.pdf</a><a href="#fnref1">↩</a></li>
<li id="fn2">Traub, J.F., "Iterative Methods for the Solution of Equations", Prentice Hall, Englewood Cliffs, N.J. (1964)<a href="#fnref2">↩</a></li>
<li id="fn3">Muller, David E., "A Method for Solving Algebraic Equations Using an Automatic Computer", Mathematical Tables and Other Aids to Computation <strong>10</strong> (1956), 208–215<a href="#fnref3">↩</a></li>
<li id="fn4"></li>
</ol>
</section>
</body>
</html>
