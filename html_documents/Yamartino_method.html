<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1766">Yamartino method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Yamartino method</h1>
<hr/>

<p>The <strong>Yamartino method</strong> (introduced by Robert J. Yamartino in 1984) is an algorithm for calculating an approximation to the <a href="standard_deviation" title="wikilink">standard deviation</a> σ<sub>θ</sub> of <a href="wind_direction" title="wikilink">wind direction</a> θ during a single pass through the incoming data.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The standard deviation of wind direction is a measure of lateral <a class="uri" href="turbulence" title="wikilink">turbulence</a>, and is used in a method for estimating the <a href="Air_pollution_dispersion_terminology#The_Pasquill_atmospheric_stability_classes" title="wikilink">Pasquill stability category</a>.</p>

<p>The simple method for calculating standard deviation requires two passes through the list of values. The first pass determines the average of those values; the second pass determines the sum of the squares of the differences between the values and the average. This double-pass method requires access to all values. A <a href="Standard_deviation#Rapid_calculation_methods" title="wikilink">single-pass method</a> can be used for normal data but is unsuitable for <a href="Polar_coordinate_system" title="wikilink">angular</a> data such as wind direction where the 0°/360° (or +180°/-180°) discontinuity forces special consideration. For example, the directions 1°, 0°, and 359° (or -1°) should not average to the direction 120°!</p>

<p>The Yamartino method solves both problems. The <a href="United_States_Environmental_Protection_Agency" title="wikilink">United States Environmental Protection Agency</a> (EPA) has chosen it as the preferred way to compute the standard deviation of wind direction.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> A further discussion of the Yamartino method, along with other methods of estimating the standard deviation of wind direction can be found in Farrugia &amp; Micallef.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>It should be mentioned that it is also possible to calculate the exact standard deviation in one pass. However, that method needs slightly more calculation effort.</p>
<h2 id="algorithm">Algorithm</h2>

<p>Over the time interval to be averaged across, <em>n</em> measurements of wind direction (θ) will be made and two totals are accumulated without storage of the <em>n</em> individual values. At the end of the interval the calculations are as follows: with the average values of sinθ and cosθ defined as</p>

<p>

<math display="block" id="Yamartino_method:0">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>s</mi>
     <mi>a</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>n</mi>
     </mfrac>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <mi>sin</mi>
       <msub>
        <mi>θ</mi>
        <mi>i</mi>
       </msub>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>s</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <sin></sin>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{a}=\frac{1}{n}\sum_{i=1}^{n}\sin\theta_{i},
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Yamartino_method:1">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>c</mi>
     <mi>a</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>n</mi>
     </mfrac>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <mi>cos</mi>
       <msub>
        <mi>θ</mi>
        <mi>i</mi>
       </msub>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>n</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>n</ci>
      </apply>
      <apply>
       <cos></cos>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>θ</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{a}=\frac{1}{n}\sum_{i=1}^{n}\cos\theta_{i}.
  </annotation>
 </semantics>
</math>

</p>

<p>Then the average wind direction is given via the four-quadrant arctan(x,y) function as</p>

<p>

<math display="block" id="Yamartino_method:2">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>θ</mi>
     <mi>a</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mpadded width="+5pt">
      <mi>arctan</mi>
     </mpadded>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>c</mi>
       <mi>a</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>s</mi>
       <mi>a</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>θ</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <arctan></arctan>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>s</ci>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \theta_{a}=\arctan\ (c_{a},s_{a}).
  </annotation>
 </semantics>
</math>

</p>

<p>From twenty different functions for σ<sub>θ</sub> using variables obtained in a single-pass of the wind direction data, Yamartino found the best function to be</p>

<p>

<math display="block" id="Yamartino_method:3">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>σ</mi>
     <mi>θ</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>arcsin</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>ε</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mo>[</mo>
      <mrow>
       <mn>1</mn>
       <mo>+</mo>
       <mrow>
        <mrow>
         <mo>(</mo>
         <mrow>
          <mstyle displaystyle="false">
           <mfrac>
            <mn>2</mn>
            <msqrt>
             <mn>3</mn>
            </msqrt>
           </mfrac>
          </mstyle>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo>)</mo>
        </mrow>
        <msup>
         <mi>ε</mi>
         <mn>3</mn>
        </msup>
       </mrow>
      </mrow>
      <mo>]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>σ</ci>
     <ci>θ</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <arcsin></arcsin>
      <ci>ε</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <apply>
         <minus></minus>
         <apply>
          <divide></divide>
          <cn type="integer">2</cn>
          <apply>
           <root></root>
           <cn type="integer">3</cn>
          </apply>
         </apply>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ε</ci>
         <cn type="integer">3</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma_{\theta}=\arcsin(\varepsilon)\left[1+\left(\tfrac{2}{\sqrt{3}}-1\right)%
\varepsilon^{3}\right],
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>

<p>

<math display="block" id="Yamartino_method:4">
 <semantics>
  <mrow>
   <mrow>
    <mi>ε</mi>
    <mo>=</mo>
    <msqrt>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msubsup>
         <mi>s</mi>
         <mi>a</mi>
         <mn>2</mn>
        </msubsup>
        <mo>+</mo>
        <msubsup>
         <mi>c</mi>
         <mi>a</mi>
         <mn>2</mn>
        </msubsup>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msqrt>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ε</ci>
    <apply>
     <root></root>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>s</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>a</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>c</ci>
         <cn type="integer">2</cn>
        </apply>
        <ci>a</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon=\sqrt{1-(s^{2}_{a}+c^{2}_{a})}.
  </annotation>
 </semantics>
</math>

</p>

<p>The key here is to remember that sin<sup>2</sup>θ + cos<sup>2</sup>θ = 1 so that for example, with a constant wind direction at any value of θ, the value of 

<math display="inline" id="Yamartino_method:5">
 <semantics>
  <mi>ε</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ε</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

 will be zero, leading to a zero value for the standard deviation.</p>

<p>The use of 

<math display="inline" id="Yamartino_method:6">
 <semantics>
  <mi>ε</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ε</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

 alone produces a result close to that produced with a double-pass when the dispersion of angles is small (not crossing the discontinuity), but by construction it is always between 0 and 1. Taking the <a class="uri" href="arcsine" title="wikilink">arcsine</a> then produces the double-pass answer when there are just two equally common angles: in the extreme case of an oscillating wind blowing backwards and forwards, it produces a result of 

<math display="inline" id="Yamartino_method:7">
 <semantics>
  <mfrac>
   <mi>π</mi>
   <mn>2</mn>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>π</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{\pi}{2}
  </annotation>
 </semantics>
</math>

 radians, i.e. a <a href="right_angle" title="wikilink">right angle</a>. The final factor adjusts this figure upwards so that it produces the double-pass result of 

<math display="inline" id="Yamartino_method:8">
 <semantics>
  <mfrac>
   <mi>π</mi>
   <msqrt>
    <mn>3</mn>
   </msqrt>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>π</ci>
    <apply>
     <root></root>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \tfrac{\pi}{\sqrt{3}}
  </annotation>
 </semantics>
</math>

 radians for an almost uniform distribution of angles across all directions, while making minimal change to results for small dispersions.</p>

<p>The theoretical maximum error against the correct double-pass σ<sub>θ</sub> is therefore about 15% with an oscillating wind. Comparisons against Monte Carlo generated cases indicate that Yamartino's algorithm is within 2% for more realistic distributions.</p>

<p>A variant might be to weight each wind direction observation by the wind speed at that time.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Algorithms_for_calculating_variance" title="wikilink">Algorithms for calculating variance</a></li>
<li><a href="Directional_statistics" title="wikilink">Directional statistics</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Statistical_algorithms" title="wikilink">Category:Statistical algorithms</a> <a href="Category:Boundary_layer_meteorology" title="wikilink">Category:Boundary layer meteorology</a> <a href="Category:Atmospheric_dispersion_modeling" title="wikilink">Category:Atmospheric dispersion modeling</a> <a href="Category:Directional_statistics" title="wikilink">Category:Directional statistics</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="http://www.epa.gov/scram001/guidance/met/mmgrma.pdf">Meteorological Monitoring Guidance for Regulatory Modeling Applications (section 6.2.1)</a><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
