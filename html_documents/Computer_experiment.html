<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1426">Computer experiment</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Computer experiment</h1>
<hr/>

<p>A <strong>computer experiment</strong> or <strong>simulation experiment</strong> is an experiment used to study a computer simulation, also referred to as an <a href="in_silico" title="wikilink">in silico</a> system. This area includes <a href="computational_physics" title="wikilink">computational physics</a>, <a href="computational_chemistry" title="wikilink">computational chemistry</a>, <a href="computational_biology" title="wikilink">computational biology</a> and other similar disciplines.</p>
<h2 id="background">Background</h2>

<p><a href="Computer_simulation" title="wikilink">Computer simulations</a> are constructed to emulate a physical system. Because these are meant to replicate some aspect of a system in detail, they often do not yield an analytic solution. Therefore, methods such as <a href="discrete_event_simulation" title="wikilink">discrete event simulation</a> or <a href="finite_element" title="wikilink">finite element</a> solvers are used. A <a href="computer_model" title="wikilink">computer model</a> is used to make inferences about the system it replicates. For example, <a href="climate_models" title="wikilink">climate models</a> are often used because experimentation on an earth sized object is impossible.</p>
<h2 id="objectives">Objectives</h2>

<p>Computer experiments have been employed with many purposes in mind. Some of those include:</p>
<ul>
<li><a href="Uncertainty_quantification" title="wikilink">Uncertainty quantification</a>: Characterize the uncertainty present in a computer simulation arising from unknowns during the computer simulation's construction.</li>
<li><a href="Inverse_problem" title="wikilink">Inverse problems</a>: Discover the underlying properties of the system from the physical data.</li>
<li><strong>Bias correction</strong>: Use physical data to correct for bias in the simulation.</li>
<li><a href="Data_assimilation" title="wikilink">Data assimilation</a>: Combine multiple simulations and physical data sources into a complete predictive model.</li>
<li><a href="Systems_design" title="wikilink">Systems design</a>: Find inputs that result in optimal system performance measures.</li>
</ul>
<h2 id="computer-simulation-modeling">Computer simulation modeling</h2>

<p>Modeling of computer experiments typically uses a Bayesian framework. <a href="Bayesian_statistics" title="wikilink">Bayesian statistics</a> is an interpretation of the field of <a class="uri" href="statistics" title="wikilink">statistics</a> where which all evidence about the true state of the world is explicitly expressed in the form of <a class="uri" href="probabilities" title="wikilink">probabilities</a>. In the realm of computer experiments, the Bayesian interpretation would imply we must form a <a href="prior_distribution" title="wikilink">prior distribution</a> that represents our prior belief on the structure of the computer model. The use of this philosophy for computer experiments started in the 1980s and is nicely summarized by Sacks et al. (1989) [<a class="uri" href="http://projecteuclid.org/DPubS?service=UI&amp;version">http://projecteuclid.org/DPubS?service=UI&amp;version;</a>;=1.0&amp;verb;=Display&amp;handle;=euclid.ss/1177012413]. While the Bayesian approach is widely used, <a class="uri" href="frequentist" title="wikilink">frequentist</a> approaches have been recently discussed <a href="http://www2.isye.gatech.edu/~jeffwu/publications/calibration-may1.pdf">1</a>.</p>

<p>The basic idea of this framework is to model the computer simulation as an unknown function of a set of inputs. The computer simulation is implemented as a piece of computer code that can be evaluated to produce a collection of outputs. Examples of inputs to these simulations are coefficients in the underlying model, <a href="initial_conditions" title="wikilink">initial conditions</a> and <a href="Forcing_function_(differential_equations)" title="wikilink">forcing functions</a>. It is natural to see the simulation as a deterministic function that maps these <em>inputs</em> into a collection of <em>outputs</em>. On the basis of seeing our simulator this way, it is common to refer to the collection of inputs as 

<math display="inline" id="Computer_experiment:0">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

, the computer simulation itself as 

<math display="inline" id="Computer_experiment:1">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

, and the resulting output as 

<math display="inline" id="Computer_experiment:2">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

. Both 

<math display="inline" id="Computer_experiment:3">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Computer_experiment:4">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 are vector quantities, and they can be very large collections of values, often indexed by space, or by time, or by both space and time.</p>

<p>Although 

<math display="inline" id="Computer_experiment:5">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>⋅</mo>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>normal-⋅</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(\cdot)
  </annotation>
 </semantics>
</math>

 is known in principle, in practice this is not the case. Many simulators comprise tens of thousands of lines of high-level computer code, which is not accessible to intuition. For some simulations, such as climate models, evaluation of the output for a single set of inputs can require millions of computer hours <a href="http://amstat.tandfonline.com/doi/abs/10.1198/TECH.2009.0015#.UbixC_nFWHQ">2</a>.</p>
<h3 id="gaussian-process-prior">Gaussian process prior</h3>

<p>The typical model for a computer code output is a Gaussian process. For notational simplicity, assume 

<math display="inline" id="Computer_experiment:6">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 is a scalar. Owing to the Bayesian framework, we fix our belief that the function 

<math display="inline" id="Computer_experiment:7">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 follows a <a href="Gaussian_process" title="wikilink">Gaussian process</a>, 

<math display="inline" id="Computer_experiment:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mo>∼</mo>
    <mrow>
     <mo>GP</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>m</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mo>⋅</mo>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>C</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mo>⋅</mo>
        <mo>,</mo>
        <mo>⋅</mo>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <ci>f</ci>
    <apply>
     <ci>GP</ci>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>normal-⋅</ci>
     </apply>
     <apply>
      <times></times>
      <ci>C</ci>
      <interval closure="open">
       <ci>normal-⋅</ci>
       <ci>normal-⋅</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\sim\operatorname{GP}(m(\cdot),C(\cdot,\cdot)),
  </annotation>
 </semantics>
</math>


 where 

<math display="inline" id="Computer_experiment:9">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 is the mean function and 

<math display="inline" id="Computer_experiment:10">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is the covariance function. Popular mean functions are low order polynomials and a popular <a href="covariance_function" title="wikilink">covariance function</a> is <a href="Matern_covariance" title="wikilink">Matern covariance</a>, which includes both the exponential (

<math display="inline" id="Computer_experiment:11">
 <semantics>
  <mrow>
   <mi>ν</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ν</ci>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu=1/2
  </annotation>
 </semantics>
</math>

) and Gaussian covariances (as 

<math display="inline" id="Computer_experiment:12">
 <semantics>
  <mrow>
   <mi>ν</mi>
   <mo>→</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>ν</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \nu\rightarrow\infty
  </annotation>
 </semantics>
</math>

).</p>
<h2 id="design-of-computer-experiments">Design of computer experiments</h2>

<p>The design of computer experiments has considerable differences from <a href="design_of_experiments" title="wikilink">design of experiments</a> for parametric models. Since a Gaussian process prior has an infinite dimensional representation, the concepts of A and D criteria (see <a href="Optimal_design" title="wikilink">Optimal design</a>), which focus on reducing the error in the parameters, cannot be used. Replications would also be wasteful in cases when the computer simulation has no error. Criteria that are used to determine a good experimental design include integrated mean squared prediction error [<a class="uri" href="http://projecteuclid.org/DPubS?service=UI&amp;version">http://projecteuclid.org/DPubS?service=UI&amp;version;</a>;=1.0&amp;verb;=Display&amp;handle;=euclid.ss/1177012413] and distance based criteria <a href="http://www.sciencedirect.com/science/article/pii/037837589090122B">3</a>.</p>

<p>Popular strategies for design include <a href="latin_hypercube_sampling" title="wikilink">latin hypercube sampling</a> and <a href="low_discrepancy_sequences" title="wikilink">low discrepancy sequences</a>.</p>
<h3 id="problems-with-massive-sample-sizes">Problems with massive sample sizes</h3>

<p>Unlike physical experiments, it is not uncommon for computer experiments to have thousands of different input combinations. Because the standard inference requires <a href="Invertible_matrix" title="wikilink">matrix inversion</a> of a square matrix of the size of the number of samples (

<math display="inline" id="Computer_experiment:13">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>


), the cost grows on the 

<math display="inline" id="Computer_experiment:14">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">𝒪</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>n</mi>
     <mn>3</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>𝒪</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{O}(n^{3})
  </annotation>
 </semantics>
</math>

. Matrix inversion of large, dense matrices can also cause induce numerical inaccuracies. Currently, this problem is solved by greedy decision tree techniques, allowing effective computations for unlimited dimensionality and sample size [<a class="uri" href="http://www.google.com/patents/WO2013055257A1?cl=en&amp;hl">http://www.google.com/patents/WO2013055257A1?cl=en&amp;hl;</a>;=ru patent WO2013055257A1], or avoided by using approximation methods, e.g. <a href="http://www.stat.wisc.edu/~zhiguang/Multistep_AOS.pdf">4</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Simulation" title="wikilink">Simulation</a></li>
<li><a href="Uncertainty_quantification" title="wikilink">Uncertainty quantification</a></li>
<li><a href="Bayesian_statistics" title="wikilink">Bayesian statistics</a></li>
<li><a href="Gaussian_process_emulator" title="wikilink">Gaussian process emulator</a></li>
<li><a href="Design_of_experiments" title="wikilink">Design of experiments</a></li>
<li><a href="Monte_Carlo_method" title="wikilink">Monte Carlo method</a></li>
<li><a href="Surrogate_model" title="wikilink">Surrogate model</a></li>
<li><a href="Grey_box_completion_and_validation" title="wikilink">Grey box completion and validation</a></li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Computational_science" title="wikilink">Category:Computational science</a> <a class="uri" href="Category:Statistics" title="wikilink">Category:Statistics</a> <a class="uri" href="Category:Simulation" title="wikilink">Category:Simulation</a></p>
</body>
</html>
