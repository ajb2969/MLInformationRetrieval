<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1471">M-Theory (learning framework)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>M-Theory (learning framework)</h1>
<hr/>

<p>In <a href="Machine_Learning" title="wikilink">Machine Learning</a> and <a href="Computer_Vision" title="wikilink">Computer Vision</a>, <strong>M-Theory</strong> is a learning framework inspired by feed-forward processing in the <a href="Two-streams_hypothesis" title="wikilink">ventral stream</a> of <a href="visual_cortex" title="wikilink">visual cortex</a> and originally developed for recognition and classification of objects in visual scenes. M-Theory was later applied to other areas, such as <a href="speech_recognition" title="wikilink">speech recognition</a>. On certain image recognition tasks, algorithms based on a specific instantiation of M-Theory, HMAX, achieved human-level performance.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The core principle of M-Theory is extracting representations invariant to various transformations of images (translation, scale, 2D and 3D rotation and others). In contrast with other approaches using invariant representations, in M-Theory they are not hardcoded into the algorithms, but learned. M-Theory also shares some principles with <a href="Compressed_Sensing" title="wikilink">Compressed Sensing</a>. The theory proposes multilayered hierarchical learning architecture, similar to that of visual cortex.</p>
<h2 id="intuition">Intuition</h2>
<h3 id="invariant-representations">Invariant representations</h3>

<p>A great challenge in visual recognition tasks is that the same object can be seen in a variety of conditions. It can be seen from different distances, different viewpoints, under different lighting, partially occluded, etc. In addition, for particular classes objects, such as faces, highly complex specific transformations may be relevant, such as changing facial expressions. For learning to recognize images, it is greatly beneficial to factor out these variations. It results in much simpler classification problem and, consequently, in great reduction of <a href="sample_complexity" title="wikilink">sample complexity</a> of the model.</p>

<p>A simple computational experiment illustrates this idea. Two instances of a classifier were trained to distinguish images of planes from those of cars. For training and testing of the first instance, images with arbitrary viewpoints were used. Another instance received only images seen from a particular viewpoint, which was equivalent to training and testing the system on invariant representation of the images. One can see that the second classifier performed quite well even after receiving a single example from each category, while performance of the first classifier was close to random guess even after seeing 20 examples.</p>

<p>Invariant representations has been incorporated into several learning architectures, such as <a href="neocognitron" title="wikilink">neocognitrons</a>. Most of these architectures, however, provided invariance through custom-designed features or properties of architecture itself. While it helps to take into account some sorts of transformations, such as translations, it is very nontrivial to accommodate for other sorts of transformations, such as 3D rotations and changing facial expressions. M-Theory provides a framework of how such transformations can be learned. In addition to higher flexibility, this theory also suggests how human brain may have similar capabilities.</p>
<h3 id="templates">Templates</h3>

<p>Another core idea of M-Theory is close in spirit to ideas from the field of <a href="compressed_sensing" title="wikilink">compressed sensing</a>. An implication from <a href="Johnson–Lindenstrauss_lemma" title="wikilink">Johnson–Lindenstrauss lemma</a> says that a particular number of images can be embedded into a low-dimensional feature space with the same distances between images by using random projections. This result suggests that <a href="dot_product" title="wikilink">dot product</a> between the observed image and some other image stored in memory, called template, can be used as a feature helping to distinguish the image from other images. The template need not to be anyhow related to the image, it could be chosen randomly.</p>
<h3 id="combining-templates-and-invariant-representations">Combining templates and invariant representations</h3>

<p>The two ideas outlined in previous sections can be brought together to construct a framework for learning invariant representations. The key observation is how dot product between image 

<math display="inline" id="M-Theory_(learning_framework):0">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 and a template 

<math display="inline" id="M-Theory_(learning_framework):1">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 behaves when image is transformed (by such transformations as translations, rotations, scales, etc.). If transformation 

<math display="inline" id="M-Theory_(learning_framework):2">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 is a member of a <a href="unitary_group" title="wikilink">unitary group</a> of transformations, then the following holds:</p>

<p>

<math display="inline" id="M-Theory_(learning_framework):3">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mi>g</mi>
     <mi>I</mi>
    </mrow>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>I</mi>
     <mo>,</mo>
     <mrow>
      <msup>
       <mi>g</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <mi>t</mi>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <list>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>I</ci>
     </apply>
     <ci>t</ci>
    </list>
    <apply>
     <times></times>
     <list>
      <ci>I</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>g</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>t</ci>
      </apply>
     </list>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle gI,t\rangle=\langle I,g^{-1}t\rangle(1)
  </annotation>
 </semantics>
</math>

</p>

<p>In other words, the dot product of transformed image and a template is equal to the dot product of original image and inversely transformed template. For instance, for image rotated by 90 degrees, the inversely transformed template would be rotated by -90 degrees.</p>

<p>Consider the set of dot products of an image 

<math display="inline" id="M-Theory_(learning_framework):4">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 to all possible transformations of template

<math display="block" id="M-Theory_(learning_framework):5">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>I</mi>
    <mo>,</mo>
    <mrow>
     <msup>
      <mi>g</mi>
      <mo>′</mo>
     </msup>
     <mi>t</mi>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <msup>
     <mi>g</mi>
     <mo>′</mo>
    </msup>
    <mo>∈</mo>
    <mi>G</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <list>
     <ci>I</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </list>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\langle I,g^{\prime}t\rangle|g^{\prime}\in G\}
  </annotation>
 </semantics>
</math>

. If one applies a transformation 

<math display="inline" id="M-Theory_(learning_framework):6">
 <semantics>
  <mi>g</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>g</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="M-Theory_(learning_framework):7">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

, the set would become 

<math display="inline" id="M-Theory_(learning_framework):8">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mi>g</mi>
     <mi>I</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msup>
      <mi>g</mi>
      <mo>′</mo>
     </msup>
     <mi>t</mi>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <msup>
     <mi>g</mi>
     <mo>′</mo>
    </msup>
    <mo>∈</mo>
    <mi>G</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <list>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>I</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </list>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\langle gI,g^{\prime}t\rangle|g^{\prime}\in G\}
  </annotation>
 </semantics>
</math>

. But because of the property (1), this is equal to 

<math display="inline" id="M-Theory_(learning_framework):9">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>I</mi>
    <mo>,</mo>
    <mrow>
     <msup>
      <mi>g</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <msup>
      <mi>g</mi>
      <mo>′</mo>
     </msup>
     <mi>t</mi>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <msup>
     <mi>g</mi>
     <mo>′</mo>
    </msup>
    <mo>∈</mo>
    <mi>G</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <list>
     <ci>I</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>t</ci>
     </apply>
    </list>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\langle I,g^{-1}g^{\prime}t\rangle|g^{\prime}\in G\}
  </annotation>
 </semantics>
</math>

. The set 

<math display="inline" id="M-Theory_(learning_framework):10">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <msup>
     <mi>g</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <msup>
     <mi>g</mi>
     <mo>′</mo>
    </msup>
   </mrow>
   <mo stretchy="false">|</mo>
   <mrow>
    <msup>
     <mi>g</mi>
     <mo>′</mo>
    </msup>
    <mo>∈</mo>
    <mi>G</mi>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{g^{-1}g^{\prime}|g^{\prime}\in G\}
  </annotation>
 </semantics>
</math>

 is equal to just the set of all elements in 

<math display="inline" id="M-Theory_(learning_framework):11">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

. To see this, note that every 

<math display="inline" id="M-Theory_(learning_framework):12">
 <semantics>
  <mrow>
   <msup>
    <mi>g</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
   <msup>
    <mi>g</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>g</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>g</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g^{-1}g^{\prime}
  </annotation>
 </semantics>
</math>

 is in 

<math display="inline" id="M-Theory_(learning_framework):13">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 due to the closure property of <a href="group_(mathematics)" title="wikilink">groups</a>, and for every 

<math display="inline" id="M-Theory_(learning_framework):14">
 <semantics>
  <msup>
   <mi>g</mi>
   <mi>′′</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>g</ci>
    <ci>′′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g^{\prime\prime}
  </annotation>
 </semantics>
</math>

 in G there exist its prototype 

<math display="inline" id="M-Theory_(learning_framework):15">
 <semantics>
  <msup>
   <mi>g</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>g</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g^{\prime}
  </annotation>
 </semantics>
</math>

 such as 

<math display="inline" id="M-Theory_(learning_framework):16">
 <semantics>
  <mrow>
   <msup>
    <mi>g</mi>
    <mi>′′</mi>
   </msup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>g</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <msup>
     <mi>g</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>g</ci>
     <ci>′′</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g^{\prime\prime}=g^{-1}g^{\prime}
  </annotation>
 </semantics>
</math>

 (namely, 

<math display="inline" id="M-Theory_(learning_framework):17">
 <semantics>
  <mrow>
   <msup>
    <mi>g</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <msup>
     <mi>g</mi>
     <mi>′′</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>g</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <ci>′′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g^{\prime}=gg^{\prime\prime}
  </annotation>
 </semantics>
</math>

). Thus, 

<math display="inline" id="M-Theory_(learning_framework):18">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>I</mi>
     <mo>,</mo>
     <mrow>
      <msup>
       <mi>g</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <msup>
       <mi>g</mi>
       <mo>′</mo>
      </msup>
      <mi>t</mi>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msup>
      <mi>g</mi>
      <mo>′</mo>
     </msup>
     <mo>∈</mo>
     <mi>G</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>I</mi>
     <mo>,</mo>
     <mrow>
      <msup>
       <mi>g</mi>
       <mi>′′</mi>
      </msup>
      <mi>t</mi>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <msup>
      <mi>g</mi>
      <mi>′′</mi>
     </msup>
     <mo>∈</mo>
     <mi>G</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <list>
      <ci>I</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>g</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>g</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </list>
     <apply>
      <in></in>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>G</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <list>
      <ci>I</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>g</ci>
        <ci>′′</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </list>
     <apply>
      <in></in>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <ci>′′</ci>
      </apply>
      <ci>G</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{\langle I,g^{-1}g^{\prime}t\rangle|g^{\prime}\in G\}=\{\langle I,g^{\prime%
\prime}t\rangle|g^{\prime\prime}\in G\}
  </annotation>
 </semantics>
</math>

. One can see that the set of dot products remains the same despite that a transformation was applied to the image! This set by itself may serve as a (very cumbersome) invariant representation of an image. More practical representations can be derived from it.</p>

<p>In the introductory section, it was claimed that M-Theory allows to learn invariant representations. This is because templates and their transformed versions can be learned from visual experience - by exposing the system to sequences of transformations of objects. It is plausible that similar visual experiences occur in early period of human life, for instance when infants twiddle toys in their hands. Because templates may be totally unrelated to images that the system later will try to classify, memories of these visual experiences may serve as a basis for recognizing many different kinds of objects in later life. However, as it is shown later, for some kinds of transformations, specific templates are needed.</p>
<h2 id="theoretical-aspects">Theoretical aspects</h2>
<h3 id="from-orbits-to-distribution-measures">From orbits to distribution measures</h3>

<p>To implement the ideas described in previous sections, one need to know how to derive a computationally efficient invariant representation of an image. Such unique representation for each image can be characterized as it appears by a set of one-dimensional probability distributions (empirical distributions of the dot-products between image and a set of templates stored during unsupervised learning). These probability distributions in their turn can be described by either histograms or a set of statistical moments of it, as it will be shown below.</p>

<p>Orbit 

<math display="inline" id="M-Theory_(learning_framework):19">
 <semantics>
  <msub>
   <mi>O</mi>
   <mi>I</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>O</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O_{I}
  </annotation>
 </semantics>
</math>

 is a set of images 

<math display="inline" id="M-Theory_(learning_framework):20">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   gI
  </annotation>
 </semantics>
</math>

 generated from a single image 

<math display="inline" id="M-Theory_(learning_framework):21">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 under the action of the group 

<math display="inline" id="M-Theory_(learning_framework):22">
 <semantics>
  <mrow>
   <mrow>
    <mi>G</mi>
    <mo>,</mo>
    <mrow>
     <mo>∀</mo>
     <mi>g</mi>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <ci>G</ci>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>g</ci>
     </apply>
    </list>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G,\forall g\in G
  </annotation>
 </semantics>
</math>

.</p>

<p>In other words, images of an object and of its transformations correspond to a orbit 

<math display="inline" id="M-Theory_(learning_framework):23">
 <semantics>
  <msub>
   <mi>O</mi>
   <mi>I</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>O</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O_{I}
  </annotation>
 </semantics>
</math>

. If two orbits have a point in common they are identical everywhere,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> i.e. an orbit is an invariant and unique representation of an image. So, two images are called equivalent when they belong to the same orbit

<math display="block" id="M-Theory_(learning_framework):24">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mo>∼</mo>
   <msup>
    <mi>I</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <ci>I</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>I</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I\sim I^{\prime}
  </annotation>
 </semantics>
</math>

 if 

<math display="inline" id="M-Theory_(learning_framework):25">
 <semantics>
  <mrow>
   <mrow>
    <mo>∃</mo>
    <mi>g</mi>
   </mrow>
   <mo>∈</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <exists></exists>
     <ci>g</ci>
    </apply>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists g\in G
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="M-Theory_(learning_framework):26">
 <semantics>
  <mrow>
   <msup>
    <mi>I</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mi>g</mi>
    <mi>I</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>I</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <times></times>
     <ci>g</ci>
     <ci>I</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I^{\prime}=gI
  </annotation>
 </semantics>
</math>

. Conversely, two orbits are different if none of the images in one orbit coincide with any image in the other.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>A natural question arises: how can one compare two orbits? There are several possible approaches. One of them employs the fact that intuitively two empirical orbits are the same irrespective of the ordering of their points. Thus, one can consider a probability distribution 

<math display="inline" id="M-Theory_(learning_framework):27">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>I</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{I}
  </annotation>
 </semantics>
</math>

 induced by the group’s action on images 

<math display="inline" id="M-Theory_(learning_framework):28">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 (

<math display="inline" id="M-Theory_(learning_framework):29">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   gI
  </annotation>
 </semantics>
</math>

 can be seen as a realization of a random variable).</p>

<p>This probability distribution 

<math display="inline" id="M-Theory_(learning_framework):30">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>I</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{I}
  </annotation>
 </semantics>
</math>

 can be almost uniquely characterized by 

<math display="inline" id="M-Theory_(learning_framework):31">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 one-dimensional probability distributions 

<math display="inline" id="M-Theory_(learning_framework):32">
 <semantics>
  <msub>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>I</mi>
    <mo>,</mo>
    <msup>
     <mi>t</mi>
     <mi>k</mi>
    </msup>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <list>
     <ci>I</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <ci>k</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{\langle I,t^{k}\rangle}
  </annotation>
 </semantics>
</math>

 induced by the (one-dimensional) results of projections 

<math display="inline" id="M-Theory_(learning_framework):33">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>I</mi>
   <mo>,</mo>
   <msup>
    <mi>t</mi>
    <mi>k</mi>
   </msup>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>I</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>t</ci>
     <ci>k</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle I,t^{k}\rangle
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="M-Theory_(learning_framework):34">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>t</mi>
      <mi>k</mi>
     </msup>
     <mo>,</mo>
     <mi>k</mi>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>K</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <list>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>t</ci>
       <ci>k</ci>
      </apply>
      <ci>k</ci>
     </list>
     <cn type="integer">1</cn>
    </apply>
    <list>
     <ci>normal-…</ci>
     <ci>K</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{k},k=1,...,K
  </annotation>
 </semantics>
</math>

 are a set of templates (randomly chosen images) (based on the Cramer-Wold theorem <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> and concentration of measures).</p>

<p>Consider 

<math display="inline" id="M-Theory_(learning_framework):35">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 images 

<math display="inline" id="M-Theory_(learning_framework):36">
 <semantics>
  <mrow>
   <msub>
    <mi>X</mi>
    <mi>n</mi>
   </msub>
   <mo>∈</mo>
   <mi>X</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <ci>n</ci>
    </apply>
    <ci>X</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{n}\in X
  </annotation>
 </semantics>
</math>

. Let 

<math display="inline" id="M-Theory_(learning_framework):37">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>≥</mo>
   <mrow>
    <mfrac>
     <mn>2</mn>
     <mrow>
      <mi>c</mi>
      <msup>
       <mi>ϵ</mi>
       <mn>2</mn>
      </msup>
     </mrow>
    </mfrac>
    <mrow>
     <mi>log</mi>
     <mfrac>
      <mi>n</mi>
      <mi>δ</mi>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>K</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">2</cn>
      <apply>
       <times></times>
       <ci>c</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ϵ</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <log></log>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <ci>δ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\geq\frac{2}{c\epsilon^{2}}\log\frac{n}{\delta}
  </annotation>
 </semantics>
</math>

 , where 

<math display="inline" id="M-Theory_(learning_framework):38">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 is a universal constant. Then</p>

<p>

<math display="inline" id="M-Theory_(learning_framework):39">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mrow>
       <mi>d</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>P</mi>
         <mi>I</mi>
        </msub>
        <mo>,</mo>
        <msubsup>
         <mi>P</mi>
         <mi>I</mi>
         <mo>′</mo>
        </msubsup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <mi>d</mi>
       <mi>K</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>P</mi>
         <mi>I</mi>
        </msub>
        <mo>,</mo>
        <msubsup>
         <mi>P</mi>
         <mi>I</mi>
         <mo>′</mo>
        </msubsup>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>≤</mo>
    <mi>ϵ</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>d</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <ci>I</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>P</ci>
          <ci>I</ci>
         </apply>
         <ci>normal-′</ci>
        </apply>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>K</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <ci>I</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>P</ci>
          <ci>I</ci>
         </apply>
         <ci>normal-′</ci>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
    <ci>ϵ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |d(P_{I},P_{I}^{\prime})-dK(P_{I},P_{I}^{\prime})|\leq\epsilon,
  </annotation>
 </semantics>
</math>

</p>

<p>with probability 

<math display="inline" id="M-Theory_(learning_framework):40">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <msup>
    <mi>δ</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>δ</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\delta^{2}
  </annotation>
 </semantics>
</math>

, for all 

<math display="inline" id="M-Theory_(learning_framework):41">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mo>,</mo>
   <msup>
    <mi>I</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>I</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>I</ci>
     <ci>normal-′</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I,I^{\prime}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="M-Theory_(learning_framework):42">
 <semantics>
  <mo>∈</mo>
  <annotation-xml encoding="MathML-Content">
   <in></in>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \in
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="M-Theory_(learning_framework):43">
 <semantics>
  <msub>
   <mi>X</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>X</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{n}
  </annotation>
 </semantics>
</math>

.</p>

<p>This result (informally) says that an approximately invariant and unique representation of an image 

<math display="inline" id="M-Theory_(learning_framework):44">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 can be obtained from the estimates of 

<math display="inline" id="M-Theory_(learning_framework):45">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 1-D probability distributions 

<math display="inline" id="M-Theory_(learning_framework):46">
 <semantics>
  <msub>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>I</mi>
    <mo>,</mo>
    <msup>
     <mi>t</mi>
     <mi>k</mi>
    </msup>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <list>
     <ci>I</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <ci>k</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{\langle I,t^{k}\rangle}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="M-Theory_(learning_framework):47">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>K</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>K</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=1,...,K
  </annotation>
 </semantics>
</math>

. The number 

<math display="inline" id="M-Theory_(learning_framework):48">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 of projections needed to discriminate 

<math display="inline" id="M-Theory_(learning_framework):49">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 orbits, induced by 

<math display="inline" id="M-Theory_(learning_framework):50">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 images, up to precision 

<math display="inline" id="M-Theory_(learning_framework):51">
 <semantics>
  <mi>ϵ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϵ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 (and with confidence 

<math display="inline" id="M-Theory_(learning_framework):52">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <msup>
    <mi>δ</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>δ</ci>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\delta^{2}
  </annotation>
 </semantics>
</math>

) is 

<math display="inline" id="M-Theory_(learning_framework):53">
 <semantics>
  <mrow>
   <mi>K</mi>
   <mo>≥</mo>
   <mrow>
    <mfrac>
     <mn>2</mn>
     <mrow>
      <mi>c</mi>
      <msup>
       <mi>ϵ</mi>
       <mn>2</mn>
      </msup>
     </mrow>
    </mfrac>
    <mrow>
     <mi>log</mi>
     <mfrac>
      <mi>n</mi>
      <mi>δ</mi>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>K</ci>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">2</cn>
      <apply>
       <times></times>
       <ci>c</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>ϵ</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <log></log>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <ci>δ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K\geq\frac{2}{c\epsilon^{2}}\log\frac{n}{\delta}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="M-Theory_(learning_framework):54">
 <semantics>
  <mi>c</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>c</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c
  </annotation>
 </semantics>
</math>

 is a universal constant.</p>

<p>To classify an image, the following “recipe” can be used:</p>
<ol>
<li>Memorize a set of images/objects called templates;</li>
<li>Memorize observed transformations for each template;</li>
<li>Compute dot products of its transformations with image;</li>
<li>Compute histogram of the resulting values, called <em>signature</em> of the image;</li>
<li>Compare the obtained histogram with signatures stored in memory.</li>
</ol>

<p>Estimates of such one-dimensional probability density functions (PDFs) 

<math display="inline" id="M-Theory_(learning_framework):55">
 <semantics>
  <msub>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>I</mi>
    <mo>,</mo>
    <msup>
     <mi>t</mi>
     <mi>k</mi>
    </msup>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <list>
     <ci>I</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <ci>k</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{\langle I,t^{k}\rangle}
  </annotation>
 </semantics>
</math>

 can be written in terms of histograms as 

<math display="inline" id="M-Theory_(learning_framework):56">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>μ</mi>
     <mi>n</mi>
     <mi>k</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>I</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mrow>
      <mo>|</mo>
      <mi>G</mi>
      <mo>|</mo>
     </mrow>
    </mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mrow>
       <mo>|</mo>
       <mi>G</mi>
       <mo>|</mo>
      </mrow>
     </msubsup>
     <mrow>
      <msub>
       <mi>η</mi>
       <mi>n</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo stretchy="false">⟨</mo>
        <mi>I</mi>
        <mo>,</mo>
        <mrow>
         <msub>
          <mi>g</mi>
          <mi>i</mi>
         </msub>
         <msup>
          <mi>t</mi>
          <mi>k</mi>
         </msup>
        </mrow>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>μ</ci>
       <ci>k</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <ci>I</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <abs></abs>
       <ci>G</ci>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <abs></abs>
        <ci>G</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>η</ci>
        <ci>n</ci>
       </apply>
       <list>
        <ci>I</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>g</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>t</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </list>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu^{k}_{n}(I)=1/\left|G\right|\sum_{i=1}^{\left|G\right|}\eta_{n}(\langle I,g%
_{i}t^{k}\rangle)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="M-Theory_(learning_framework):57">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>η</mi>
      <mi>n</mi>
     </msub>
     <mo>,</mo>
     <mi>n</mi>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>η</ci>
       <ci>n</ci>
      </apply>
      <ci>n</ci>
     </list>
     <cn type="integer">1</cn>
    </apply>
    <list>
     <ci>normal-…</ci>
     <ci>N</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \eta_{n},n=1,...,N
  </annotation>
 </semantics>
</math>

 is a set of nonlinear functions. These 1-D probability distributions can be characterized with N-bin histograms or set of statistical moments. For example, HMAX represents an architecture in which pooling is done with a max operation.</p>
<h3 id="non-compact-groups-of-transformations">Non-compact groups of transformations</h3>

<p>In the "recipe" for image classification, groups of transformations are approximated with finite number of transformations. Such approximation is possible only when the group is <a href="compact_group" title="wikilink">compact</a>.</p>

<p>Such groups as all translations and all scalings of the image are not compact, as they allow arbitrarily big transformations. However, they are <a href="locally_compact_group" title="wikilink">locally compact</a>. For locally compact groups, invariance is achievable within certain range of transformations.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>Assume that 

<math display="inline" id="M-Theory_(learning_framework):58">
 <semantics>
  <msub>
   <mi>G</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{0}
  </annotation>
 </semantics>
</math>

 is a subset of transformations from 

<math display="inline" id="M-Theory_(learning_framework):59">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

 for which the transformed patterns exist in memory. For an image 

<math display="inline" id="M-Theory_(learning_framework):60">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 and template 

<math display="inline" id="M-Theory_(learning_framework):61">
 <semantics>
  <msub>
   <mi>t</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>t</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{k}
  </annotation>
 </semantics>
</math>

, assume that 

<math display="inline" id="M-Theory_(learning_framework):62">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>I</mi>
   <mo>,</mo>
   <mrow>
    <msup>
     <mi>g</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <msub>
     <mi>t</mi>
     <mi>k</mi>
    </msub>
   </mrow>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>I</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle I,g^{-1}t_{k}\rangle
  </annotation>
 </semantics>
</math>

 is equal to zero everywhere except some subset of 

<math display="inline" id="M-Theory_(learning_framework):63">
 <semantics>
  <msub>
   <mi>G</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{0}
  </annotation>
 </semantics>
</math>

. This subset is called <a href="support_(mathematics)" title="wikilink">support</a> of 

<math display="inline" id="M-Theory_(learning_framework):64">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>I</mi>
   <mo>,</mo>
   <mrow>
    <msup>
     <mi>g</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <msub>
     <mi>t</mi>
     <mi>k</mi>
    </msub>
   </mrow>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>I</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>g</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle I,g^{-1}t_{k}\rangle
  </annotation>
 </semantics>
</math>

 and denoted as 

<math display="inline" id="M-Theory_(learning_framework):65">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mi>u</mi>
   <mi>p</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>I</mi>
     <mo>,</mo>
     <mrow>
      <msup>
       <mi>g</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <msub>
       <mi>t</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>u</ci>
    <ci>p</ci>
    <ci>p</ci>
    <list>
     <ci>I</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   supp(\langle I,g^{-1}t_{k}\rangle)
  </annotation>
 </semantics>
</math>

. It can be proven that if for a transformation 

<math display="inline" id="M-Theory_(learning_framework):66">
 <semantics>
  <msup>
   <mi>g</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>g</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g^{\prime}
  </annotation>
 </semantics>
</math>

, support set will also lie within 

<math display="inline" id="M-Theory_(learning_framework):67">
 <semantics>
  <mrow>
   <msup>
    <mi>g</mi>
    <mo>′</mo>
   </msup>
   <msub>
    <mi>G</mi>
    <mn>0</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>g</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <cn type="integer">0</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g^{\prime}G_{0}
  </annotation>
 </semantics>
</math>

, then signature of 

<math display="inline" id="M-Theory_(learning_framework):68">
 <semantics>
  <mi>I</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>I</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   I
  </annotation>
 </semantics>
</math>

 is invariant with respect to 

<math display="inline" id="M-Theory_(learning_framework):69">
 <semantics>
  <msup>
   <mi>g</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>g</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g^{\prime}
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> This theorem determines the range of transformations for which invariance is guaranteed to hold.</p>

<p>One can see that the smaller is 

<math display="inline" id="M-Theory_(learning_framework):70">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mi>u</mi>
   <mi>p</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>I</mi>
     <mo>,</mo>
     <mrow>
      <msup>
       <mi>g</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <msub>
       <mi>t</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>u</ci>
    <ci>p</ci>
    <ci>p</ci>
    <list>
     <ci>I</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>g</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   supp(\langle I,g^{-1}t_{k}\rangle)
  </annotation>
 </semantics>
</math>

, the larger is the range of transformations for which invariance is guaranteed to hold. It means that for a group that is only locally compact, not all templates would work equally well anymore. Preferable templates are those with a reasonably small 

<math display="inline" id="M-Theory_(learning_framework):71">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mi>u</mi>
   <mi>p</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>g</mi>
      <mi>I</mi>
     </mrow>
     <mo>,</mo>
     <msub>
      <mi>t</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>u</ci>
    <ci>p</ci>
    <ci>p</ci>
    <list>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>I</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>k</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   supp(\langle gI,t_{k}\rangle)
  </annotation>
 </semantics>
</math>

 for a generic image. This property is called localization: templates are sensitive only to images within a small range of transformations. Note that although minimizing 

<math display="inline" id="M-Theory_(learning_framework):72">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mi>u</mi>
   <mi>p</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>g</mi>
      <mi>I</mi>
     </mrow>
     <mo>,</mo>
     <msub>
      <mi>t</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>s</ci>
    <ci>u</ci>
    <ci>p</ci>
    <ci>p</ci>
    <list>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>I</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>k</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   supp(\langle gI,t_{k}\rangle)
  </annotation>
 </semantics>
</math>

 is not absolutely necessary for the system to work, it improves approximation of invariance. Requiring localization simultaneously for translation and scale yields a very specific kind of templates: <a href="Gabor_function" title="wikilink">Gabor functions</a>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>The desirability of custom templates for non-compact group is in conflict with the principle of learning invariant representations. However, for certain kinds of regularly encountered image transformations, templates might be the result of evolutionary adaptations. Neurobiological data suggests that there is Gabor-like tuning in the first layer of visual cortex.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> The optimality of Gabor templates for translations and scales is a possible explanation of this phenomenon.</p>
<h3 id="non-group-transformations">Non-group transformations</h3>

<p>Many interesting transformations of images do not form groups. For instance, transformations of images associated with 3D rotation of corresponding 3D object do not form a group, because it is impossible to define an inverse transformation (two objects may looks the same from one angle but different from another angle). However, approximate invariance is still achievable even for non-group transformations, if localization condition for templates holds and transformation can be locally linearized.</p>

<p>As it was said in the previous section, for specific case of translations and scaling, localization condition can be satisfied by use of generic Gabor templates. However, for general case (non-group) transformation, localization condition can be satisfied only for specific class of objects.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> More specifically, in order to satisfy the condition, templates must be similar to the objects one would like to recognize. For instance, if one would like to build a system to recognize 3D rotated faces, one need to use other 3D rotated faces as templates. This may explain the existence of such specialized modules in the brain as one responsible for face recognition.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> Even with custom templates, a noise-like encoding of images and templates is necessary for localization. It can be naturally achieved if the non-group transformation is processed on any layer other than the first in hierarchical recognition architecture.</p>
<h3 id="hierarchical-architectures">Hierarchical architectures</h3>

<p>The previous section suggests one motivation for hierarchical image recognition architectures. However, they have other benefits as well.</p>

<p>Firstly, hierarchical architectures best accomplish the goal of ‘parsing’ a complex visual scene with many objects consisting of many parts, whose relative position may greatly vary. In this case, different elements of the system must react to different objects and parts. In hierarchical architectures, representations of parts at different levels of embedding hierarchy can be stored at different layers of hierarchy.</p>

<p>Secondly, hierarchical architectures which have invariant representations for parts of objects may facilitate learning of complex compositional concepts. This facilitation may happen through reusing of learned representations of parts that were constructed before in process of learning of other concepts. As a result, sample complexity of learning compositional concepts may be greatly reduced.</p>

<p>Finally, hierarchical architectures have better tolerance to clutter. Clutter problem arises when the target object is in front of a non-uniform background, which functions as a distractor for the visual task. Hierarchical architecture provides signatures for parts of target objects, which do not include parts of background and are not affected by background variations.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>In hierarchical architectures, one layer is not necessarily invariant to all transformations that are handled by the hierarchy as a whole. Some transformations may pass through that layer to upper layers, as in the case of non-group transformations described in the previous section. For other transformations, an element of the layer may produce invariant representations only within small range of transformations. For instance, elements of the lower layers in hierarchy have small visual field and thus can handle only a small range of translation. For such transformations, the layer should provide <em>covariant</em> rather than invariant, signatures. The property of covariance can be written as 

<math display="inline" id="M-Theory_(learning_framework):73">
 <semantics>
  <mrow>
   <mrow>
    <mi>d</mi>
    <mi>i</mi>
    <mi>s</mi>
    <mi>t</mi>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mrow>
       <msub>
        <mi>μ</mi>
        <mi>l</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>g</mi>
         <mi>I</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <msub>
        <mi>μ</mi>
        <mi>l</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>d</mi>
    <mi>i</mi>
    <mi>s</mi>
    <mi>t</mi>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mrow>
       <msub>
        <mi>μ</mi>
        <mi>l</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>I</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mrow>
       <msub>
        <mi>μ</mi>
        <mi>l</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msup>
          <mi>g</mi>
          <mrow>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msup>
         <mi>t</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>i</ci>
     <ci>s</ci>
     <ci>t</ci>
     <ci>r</ci>
     <list>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <ci>l</ci>
       </apply>
       <apply>
        <times></times>
        <ci>g</ci>
        <ci>I</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <ci>l</ci>
       </apply>
       <ci>t</ci>
      </apply>
     </list>
    </apply>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>i</ci>
     <ci>s</ci>
     <ci>t</ci>
     <ci>r</ci>
     <list>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <ci>l</ci>
       </apply>
       <ci>I</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>μ</ci>
        <ci>l</ci>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>g</ci>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   distr(\langle\mu_{l}(gI),\mu_{l}(t)\rangle)=distr(\langle\mu_{l}(I),\mu_{l}(g^%
{-1}t)\rangle)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="M-Theory_(learning_framework):74">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

 is a layer, 

<math display="inline" id="M-Theory_(learning_framework):75">
 <semantics>
  <mrow>
   <msub>
    <mi>μ</mi>
    <mi>l</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>I</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>μ</ci>
     <ci>l</ci>
    </apply>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu_{l}(I)
  </annotation>
 </semantics>
</math>

 is the signature of image on that layer, and 

<math display="inline" id="M-Theory_(learning_framework):76">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>i</mi>
   <mi>s</mi>
   <mi>t</mi>
   <mi>r</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>i</ci>
    <ci>s</ci>
    <ci>t</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   distr
  </annotation>
 </semantics>
</math>

 stands for "distribution of values of the expression for all 

<math display="inline" id="M-Theory_(learning_framework):77">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>∈</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>g</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g\in G
  </annotation>
 </semantics>
</math>

".</p>
<h2 id="relation-to-biology">Relation to biology</h2>

<p>M-theory is based on a quantitative theory of the ventral stream of visual cortex.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> Understanding how visual cortex works in object recognition is still a challenging task for neuroscience. Humans and primates are able to memorize and recognize objects after seeing just couple of examples unlike any state-of-the art machine vision systems that usually require a lot of data in order to recognize objects. Prior to , the use of visual neuroscience in computer vision has been limited to early vision for deriving stereo algorithms (e.g.,<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a>) and to justify the use of DoG (derivative-of-Gaussian) filters and more recently of Gabor filters.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> No real attention has been given to biologically plausible features of higher complexity. While mainstream computer vision has always been inspired and challenged by human vision, it seems to have never advanced past the very first stages of processing in the simple cells in V1 and V2. Although some of the systems inspired - to various degrees - by neuroscience, have been tested on at least some natural images, neurobiological models of object recognition in cortex have not yet been extended to deal with real-world image databases.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>

<p>M-theory learning framework employs a novel hypothesis about the main computational function of the ventral stream: the representation of new objects/images in terms of a signature, which is invariant to transformations learned during visual experience. This allows recognition from very few labeled examples - in the limit, just one.</p>

<p>Neuroscience suggests that natural functionals for a neuron to compute is a high-dimensional dot product between an “image patch” and another image patch (called template) which is stored in terms of synaptic weights (synapses per neuron). The standard computational model of a neuron is based on a dot product and a threshold. Another important feature of the visual cortex is that it consists of simple and complex cells. This idea was originally proposed by Hubel and Wiesel.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> M-theory employs this idea. Simple cells compute dot products of an image and transformations of templates 

<math display="inline" id="M-Theory_(learning_framework):78">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>I</mi>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>g</mi>
     <mi>i</mi>
    </msub>
    <msup>
     <mi>t</mi>
     <mi>k</mi>
    </msup>
   </mrow>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>I</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>g</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle I,g_{i}t^{k}\rangle
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="M-Theory_(learning_framework):79">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>G</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <apply>
      <abs></abs>
      <ci>G</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=1,...,|G|
  </annotation>
 </semantics>
</math>

 (

<math display="inline" id="M-Theory_(learning_framework):80">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>G</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |G|
  </annotation>
 </semantics>
</math>

 is a number of simple cells). Complex cells are responsible for pooling and computing empirical histograms or statistical moments of it. The following formula for constructing histogram can be computed by neurons:</p>

<p>

<math display="inline" id="M-Theory_(learning_framework):81">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>G</mi>
      <mo stretchy="false">|</mo>
     </mrow>
    </mfrac>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>G</mi>
       <mo stretchy="false">|</mo>
      </mrow>
     </msubsup>
     <mrow>
      <mi>σ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mo stretchy="false">⟨</mo>
         <mi>I</mi>
         <mo>,</mo>
         <mrow>
          <msub>
           <mi>g</mi>
           <mi>i</mi>
          </msub>
          <msup>
           <mi>t</mi>
           <mi>k</mi>
          </msup>
         </mrow>
         <mo stretchy="false">⟩</mo>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mi>n</mi>
         <mi mathvariant="normal">Δ</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <abs></abs>
      <ci>G</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <abs></abs>
       <ci>G</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>σ</ci>
      <apply>
       <plus></plus>
       <list>
        <ci>I</ci>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>g</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>t</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </list>
       <apply>
        <times></times>
        <ci>n</ci>
        <ci>normal-Δ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{|G|}\sum_{i=1}^{|G|}\sigma(\langle I,g_{i}t^{k}\rangle+n\Delta),
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="M-Theory_(learning_framework):82">
 <semantics>
  <mi>σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sigma
  </annotation>
 </semantics>
</math>

 is a smooth version of step function, 

<math display="inline" id="M-Theory_(learning_framework):83">
 <semantics>
  <mi mathvariant="normal">Δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta
  </annotation>
 </semantics>
</math>

 is the width of a histogram bin, and 

<math display="inline" id="M-Theory_(learning_framework):84">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is the number of the bin.</p>
<h2 id="applications">Applications</h2>
<h3 id="applications-to-computer-vision">Applications to computer vision</h3>

<p>In <a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> authors applied M-theory to unconstrained face recognition in natural photographs. Unlike the DAR (detection, alignment, and recognition) method, which handles clutter by detecting objects and cropping closely around them so that very little background remains, this approach accomplishes detection and alignment implicitly by storing transformations of training images (templates) rather than explicitly detecting and aligning or cropping faces at test time. This system is built according to the principles of a recent theory of invariance in hierarchical networks and can evade the clutter problem generally problematic for feedforward systems. The resulting end-to-end system achieves a drastic improvement in the state of the art on this end-to-end task, reaching the same level of performance as the best systems operating on aligned, closely cropped images (no outside training data). It also performs well on two newer datasets, similar to LFW, but more difficult: significantly jittered (misaligned) version of LFW and SUFR-W (for example, the model’s accuracy in the LFW “unaligned &amp; no outside data used” category is 87.55±1.41% compared to state-of-the-art APEM (adaptive probabilistic elastic matching): 81.70±1.78%).</p>

<p>The theory was also applied to a range of recognition tasks: from invariant single object recognition in clutter to multiclass categorization problems on publicly available data sets (CalTech5, CalTech101, MIT-CBCL) and complex (street) scene understanding tasks that requires the recognition of both shape-based as well as texture-based objects (on StreetScenes data set).<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> The approach performs really well: It has the capability of learning from only a few training examples and was shown to outperform several more complex state-of-the-art systems constellation models, the hierarchical SVM-based face- detection system). A key element in the approach is a new set of scale and position-tolerant feature detectors, which are biologically plausible and agree quantitatively with the tuning properties of cells along the ventral stream of visual cortex. These features are adaptive to the training set, though we also show that a universal feature set, learned from a set of natural images unrelated to any categorization task, likewise achieves good performance.</p>
<h3 id="applications-to-speech-recognition">Applications to speech recognition</h3>

<p>This theory can also be extended for the speech recognition domain. As an example, in<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a> an extension of a theory for unsupervised learning of invariant visual representations to the auditory domain and empirically evaluated its validity for voiced speech sound classification was proposed. Authors empirically demonstrated that a single-layer, phone-level representation, extracted from base speech features, improves segment classification accuracy and decreases the number of training examples in comparison with standard spectral and cepstral features for an acoustic classification task on TIMIT dataset.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Machine_learning" title="wikilink">Category:Machine learning</a> <a href="Category:Computer_vision" title="wikilink">Category:Computer vision</a> <a href="Category:Speech_recognition" title="wikilink">Category:Speech recognition</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Serre T., Oliva A., Poggio T. (2007) A feedforward architecture accounts for rapid categorization. <em>PNAS</em>, vol. 104, no. 15, pp. 6424-6429<a href="#fnref1">↩</a></li>
<li id="fn2">F Anselmi, JZ Leibo, L Rosasco, J Mutch, A Tacchetti, T Poggio (2014) <em>Unsupervised learning of invariant representations in hierarchical architectures</em> arXiv preprint arXiv:1311.4158<a href="#fnref2">↩</a></li>
<li id="fn3">H. Schulz-Mirbach. Constructing invariant features by averaging techniques. In Pattern Recognition, 1994. Vol. 2 - Conference B: Computer Vision amp; Image Processing., Proceedings of the 12th IAPR International. Conference on, volume 2, pages 387 –390 vol.2, 1994.<a href="#fnref3">↩</a></li>
<li id="fn4">H. Cramer and H. Wold. Some theorems on distribution functions. J. London Math. Soc., 4:290–294, 1936.<a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8">F. Anselmi, J.Z. Leibo, L. Rosasco, J. Mutch, A. Tacchetti, T. Poggio (2013) <em>Magic Materials: a theory of deep hierarchical architectures for learning sensory representations.</em> CBCL paper, Massachusetts Institute of Technology, Cambridge, MA<a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11">Liao Q., Leibo J., Mroueh Y., Poggio T. (2014) <em>Can a biologically-plausible hierarchy effectively replace face detection, alignment, and recognition pipelines?</em> CBMM Memo No. 003, Massachusetts Institute of Technology, Cambridge, MA<a href="#fnref11">↩</a></li>
<li id="fn12">M. Riesenhuber and T. Poggio <em>Hierarchical Models of Object Recognition in Cortex</em> (1999) Nature Neuroscience, vol. 2, no. 11, pp. 1019-1025, 1999.<a href="#fnref12">↩</a></li>
<li id="fn13">T. Serre, M. Kouh, C. Cadieu, U. Knoblich, G. Kreiman, and T. Poggio (2005) <em>A Theory of Object Recognition: Computations and Circuits in the Feedforward Path of the Ventral Stream in Primate Visual Cortex</em> AI Memo 2005-036/CBCL Memo 259, Massachusetts Inst. of Technology, Cambridge.<a href="#fnref13">↩</a></li>
<li id="fn14">D.H. Hubel and T.N. Wiesel (1962) <em>Receptive fields, binocular interaction and functional architecture in the cat’s visual cortex</em> The Journal of Physiology 160.<a href="#fnref14">↩</a></li>
<li id="fn15">D. Gabor (1946) <em>Theory of Communication</em> J. IEE, vol. 93, pp. 429-459.<a href="#fnref15">↩</a></li>
<li id="fn16">J.P. Jones and L.A. Palmer (1987) <em>An Evaluation of the Two-Dimensional Gabor Filter Model of Simple Receptive Fields in Cat Striate Cortex</em> J. Neurophysiology, vol. 58, pp. 1233-1258.<a href="#fnref16">↩</a></li>
<li id="fn17">Thomas Serre, Lior Wolf, Stanley Bileschi, Maximilian Riesenhuber, and Tomaso Poggio (2007) <em>Robust Object Recognition with Cortex-Like Mechanisms</em> IEEE Transactions on pattern analysis and machine intelligence, VOL. 29, NO. 3<a href="#fnref17">↩</a></li>
<li id="fn18"></li>
<li id="fn19">Qianli Liao, Joel Z Leibo, Youssef Mroueh, Tomaso Poggio (2014) <em>Can a biologically-plausible hierarchy effectively replace face detection, alignment, and recognition pipelines?</em> CBMM Memo No. 003<a href="#fnref19">↩</a></li>
<li id="fn20">Qianli Liao, Joel Z Leibo, and Tomaso Poggio (2014) <em>Learning invariant representations and applications to face verification</em> NIPS 2014<a href="#fnref20">↩</a></li>
<li id="fn21"></li>
<li id="fn22">Georgios Evangelopoulos, Stephen Voinea, Chiyuan Zhang, Lorenzo Rosasco, Tomaso Poggio (2014) <em>Learning An Invariant Speech Representation</em> CBMM Memo No. 022<a href="#fnref22">↩</a></li>
<li id="fn23"><a class="uri" href="https://catalog.ldc.upenn.edu/LDC93S1">https://catalog.ldc.upenn.edu/LDC93S1</a><a href="#fnref23">↩</a></li>
</ol>
</section>
</body>
</html>
