<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1861">Parameterized complexity</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Parameterized complexity</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a>, <strong>parameterized complexity</strong> is a branch of <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a> that focuses on classifying <a href="computational_problems" title="wikilink">computational problems</a> according to their inherent difficulty with respect to <em>multiple</em> parameters of the input. The complexity of a problem is then measured as a <a href="Function_(mathematics)" title="wikilink">function</a> in those parameters. This allows the classification of <a class="uri" href="NP-hard" title="wikilink">NP-hard</a> problems on a finer scale than in the classical setting, where the complexity of a problem is only measured by the number of bits in the input. The first systematic work on parameterized complexity was done by .</p>

<p>Under the assumption that <a href="P_versus_NP_problem" title="wikilink">P¬†‚â†¬†NP</a>, there exist many natural problems that require superpolynomial <a href="running_time" title="wikilink">running time</a> when complexity is measured in terms of the input size only, but that are computable in a time that is polynomial in the input size and exponential or worse in a parameter 

<math display="inline" id="Parameterized_complexity:0">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

. Hence, if 

<math display="inline" id="Parameterized_complexity:1">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is fixed at a small value and the growth of the function over 

<math display="inline" id="Parameterized_complexity:2">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is relatively small then such problems can still be considered "tractable" despite their traditional classification as "intractable".</p>

<p>The existence of efficient, exact, and deterministic solving algorithms for <a class="uri" href="NP-complete" title="wikilink">NP-complete</a>, or otherwise <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>, problems is considered unlikely, if input parameters are not fixed; all known solving algorithms for these problems require time that is <a href="Exponential_time" title="wikilink">exponential</a> (or at least superpolynomial) in the total size of the input. However, some problems can be solved by algorithms that are exponential only in the size of a fixed parameter while polynomial in the size of the input. Such an algorithm is called a <a href="fixed-parameter_tractable" title="wikilink">fixed-parameter tractable</a> (fpt-)algorithm, because the problem can be solved efficiently for small values of the fixed parameter.</p>

<p>Problems in which some parameter 

<math display="inline" id="Parameterized_complexity:3">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is fixed are called parameterized problems. A parameterized problem that allows for such an fpt-algorithm is said to be a <strong>fixed-parameter tractable</strong> problem and belongs to the class 

<math display="inline" id="Parameterized_complexity:4">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mi>P</mi>
   <mi>T</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <ci>P</ci>
    <ci>T</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   FPT
  </annotation>
 </semantics>
</math>

, and the early name of the theory of parameterized complexity was <strong>fixed-parameter tractability</strong>.</p>

<p>Many problems have the following form: given an object 

<math display="inline" id="Parameterized_complexity:5">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and a nonnegative integer 

<math display="inline" id="Parameterized_complexity:6">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, does 

<math display="inline" id="Parameterized_complexity:7">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 have some property that depends on 

<math display="inline" id="Parameterized_complexity:8">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

? For instance, for the <a href="vertex_cover_problem" title="wikilink">vertex cover problem</a>, the parameter can be the number of vertices in the cover. In many applications, for example when modelling error correction, one can assume the parameter to be "small" compared to the total input size. Then it is interesting to see whether we can find an algorithm which is exponential <em>only</em> in 

<math display="inline" id="Parameterized_complexity:9">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, and not in the input size.</p>

<p>In this way, parameterized complexity can be seen as <em>two-dimensional</em> complexity theory. This concept is formalized as follows:</p>
<dl>
<dd>A <em>parameterized problem</em> is a language 

<math display="inline" id="Parameterized_complexity:10">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>‚äÜ</mo>
   <mrow>
    <msup>
     <mi mathvariant="normal">Œ£</mi>
     <mo>*</mo>
    </msup>
    <mo>√ó</mo>
    <mi class="ltx_font_mathcaligraphic">ùí©</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>L</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Œ£</ci>
      <times></times>
     </apply>
     <ci>ùí©</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L\subseteq\Sigma^{*}\times\mathcal{N}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Parameterized_complexity:11">
 <semantics>
  <mi mathvariant="normal">Œ£</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Œ£</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

 is a finite alphabet. The second component is called the <em>parameter</em> of the problem.
</dd>
</dl>
<dl>
<dd>A parameterized problem 

<math display="inline" id="Parameterized_complexity:12">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is <em>fixed-parameter tractable</em> if the question ‚Äú

<math display="inline" id="Parameterized_complexity:13">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>‚àà</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>x</ci>
     <ci>k</ci>
    </interval>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,k)\in L
  </annotation>
 </semantics>
</math>

?‚Äù can be decided in running time 

<math display="inline" id="Parameterized_complexity:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚ãÖ</mo>
   <msup>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>x</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-‚ãÖ</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(k)\cdot|x|^{O(1)}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Parameterized_complexity:15">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 is an arbitrary function depending only on 

<math display="inline" id="Parameterized_complexity:16">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

. The corresponding complexity class is called <strong>FPT</strong>.
</dd>
</dl>

<p>For example, there is an algorithm which solves the vertex cover problem in 

<math display="inline" id="Parameterized_complexity:17">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>k</mi>
      <mi>n</mi>
     </mrow>
     <mo>+</mo>
     <msup>
      <mn>1.274</mn>
      <mi>k</mi>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>k</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="float">1.274</cn>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(kn+1.274^{k})
  </annotation>
 </semantics>
</math>

 time, <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> where 

<math display="inline" id="Parameterized_complexity:18">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is the number of vertices and 

<math display="inline" id="Parameterized_complexity:19">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is the size of the vertex cover. This means that vertex cover is fixed-parameter tractable with the size of the solution as the parameter.</p>
<h2 id="complexity-classes">Complexity classes</h2>
<h3 id="fpt">FPT</h3>

<p>FPT contains the <em>fixed parameter tractable</em> problems, which are those that can be solved in time 

<math display="inline" id="Parameterized_complexity:20">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚ãÖ</mo>
   <msup>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>x</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-‚ãÖ</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(k)\cdot{|x|}^{O(1)}
  </annotation>
 </semantics>
</math>

 for some computable function 

<math display="inline" id="Parameterized_complexity:21">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

. Typically, this function is thought of as single exponential, such as 

<math display="inline" id="Parameterized_complexity:22">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <times></times>
     <ci>O</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{O(k)}
  </annotation>
 </semantics>
</math>

 but the definition admits functions that grow even faster. This is essential for a large part of the early history of this class. The crucial part of the definition is to exclude functions of the form 

<math display="inline" id="Parameterized_complexity:23">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>n</ci>
     <ci>k</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(n,k)
  </annotation>
 </semantics>
</math>

, such as 

<math display="inline" id="Parameterized_complexity:24">
 <semantics>
  <msup>
   <mi>n</mi>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{k}
  </annotation>
 </semantics>
</math>

. The class <strong>FPL</strong> (fixed parameter linear) is the class of problems solvable in time 

<math display="inline" id="Parameterized_complexity:25">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>‚ãÖ</mo>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-‚ãÖ</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <abs></abs>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(k)\cdot|x|
  </annotation>
 </semantics>
</math>

 for some computable function 

<math display="inline" id="Parameterized_complexity:26">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 . FPL is thus a subclass of FPT.</p>

<p>An example is the <a class="uri" href="satisfiability" title="wikilink">satisfiability</a> problem, parameterised by the number of variables. A given formula of size 

<math display="inline" id="Parameterized_complexity:27">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Parameterized_complexity:28">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 variables can be checked by brute force in time 

<math display="inline" id="Parameterized_complexity:29">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>k</mi>
     </msup>
     <mi>m</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>k</ci>
     </apply>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(2^{k}m)
  </annotation>
 </semantics>
</math>

. A <a href="vertex_cover" title="wikilink">vertex cover</a> of size 

<math display="inline" id="Parameterized_complexity:30">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 in a graph of order 

<math display="inline" id="Parameterized_complexity:31">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 can be found in time 

<math display="inline" id="Parameterized_complexity:32">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mn>2</mn>
      <mi>k</mi>
     </msup>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>k</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(2^{k}n)
  </annotation>
 </semantics>
</math>

, so this problem is also in FPT.</p>

<p>An example of a problem that is thought not to be in FPT is <a href="graph_coloring" title="wikilink">graph coloring</a> parameterised by the number of colors. It is known that 3-coloring is <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>, and an algorithm for graph 

<math display="inline" id="Parameterized_complexity:33">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-colouring in time 

<math display="inline" id="Parameterized_complexity:34">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <msup>
    <mi>n</mi>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>k</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(k)n^{O(1)}
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Parameterized_complexity:35">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>=</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>k</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k=3
  </annotation>
 </semantics>
</math>

 would run in polynomial time in the size of the input. Thus, if graph coloring parameterised by the number of colors were in FPT, then <a href="P_versus_NP_problem" title="wikilink">P¬†=¬†NP</a>.</p>

<p>There are a number of alternative definitions of FPT. For example, the running time requirement can be replaced by 

<math display="inline" id="Parameterized_complexity:36">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <msup>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>x</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>O</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(k)+|x|^{O(1)}
  </annotation>
 </semantics>
</math>

. Also, a parameterised problem is in FPT if it has a so-called kernel. <a class="uri" href="Kernelization" title="wikilink">Kernelization</a> is a preprocessing technique that reduces the original instance to its "hard kernel", a possibly much smaller instance that is equivalent to the original instance but has a size that is bounded by a function in the parameter.</p>

<p>FPT is closed under a parameterised <a href="Reduction_(complexity)" title="wikilink">reduction</a> called <strong><em>fpt-reduction</em></strong>, which simultaneously preserves the instance size and the parameter.</p>

<p>Obviously, FPT contains all polynomial-time computable problems. Moreover, it contains all optimisation problems in NP that allow a <a href="Fully_polynomial-time_approximation_scheme" title="wikilink">Fully polynomial-time approximation scheme</a>.</p>
<h3 id="w-hierarchy"><em>W</em> hierarchy</h3>

<p>The <strong><em>W</em> hierarchy</strong> is a collection of computational complexity classes. A parameterised problem is in the class <em>W</em>[<em>i</em>], if every instance 

<math display="inline" id="Parameterized_complexity:37">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>k</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>k</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,k)
  </annotation>
 </semantics>
</math>

 can be transformed (in fpt-time) to a combinatorial circuit that has weft at most <em>i</em>, such that 

<math display="inline" id="Parameterized_complexity:38">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>k</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>‚àà</mo>
   <mi>L</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>x</ci>
     <ci>k</ci>
    </interval>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,k)\in L
  </annotation>
 </semantics>
</math>

 if and only if there is a satisfying assignment to the inputs, which assigns <em>1</em> to at most <em>k</em> inputs. The height thereby is the largest number of logical units with unbounded fan-in on any path from an input to the output. The number of logical units with bounded fan-in on the paths must be limited by a constant that holds for all instances of the problem.</p>

<p>Note that FPT¬†=¬†<em>W</em>[0] and W[<em>i</em>] 

<math display="inline" id="Parameterized_complexity:39">
 <semantics>
  <mo>‚äÜ</mo>
  <annotation-xml encoding="MathML-Content">
   <subset></subset>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \subseteq
  </annotation>
 </semantics>
</math>

 <em>W</em>[<em>j</em>] for all 

<math display="inline" id="Parameterized_complexity:40">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>‚â§</mo>
   <mi>j</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>i</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\leq j
  </annotation>
 </semantics>
</math>

. The classes in the <em>W</em> hierarchy are also closed under fpt-reduction.</p>

<p>Many natural computational problems occupy the lower levels, <em>W</em>[1] and <em>W</em>[2].</p>
<h4 id="w1"><em>W</em>[1]</h4>

<p>Examples of <em>W</em>[1]-complete problems include</p>
<ul>
<li>deciding if a given graph contains a <a href="Clique_(graph_theory)" title="wikilink">clique</a> of size <em>k</em></li>
<li>deciding if a given graph contains an <a href="Independent_set_(graph_theory)" title="wikilink">independent set</a> of size <em>k</em></li>
<li>deciding if a given nondeterministic single-tape Turing machine accepts within <em>k</em> steps ("short Turing machine acceptance" problem)</li>
</ul>
<h4 id="w2"><em>W</em>[2]</h4>

<p>Examples of <em>W</em>[2]-complete problems include</p>
<ul>
<li>deciding if a given graph contains a <a href="dominating_set" title="wikilink">dominating set</a> of size <em>k</em></li>
<li>deciding if a given nondeterministic <a href="Turing_machine_equivalents#Multi-tape_Turing_machines" title="wikilink">multi-tape Turing machine</a> accepts within <em>k</em> steps ("short multi-tape Turing machine acceptance" problem)</li>
</ul>
<h4 id="wt"><em>W</em>[<em>t</em>]</h4>

<p>

<math display="inline" id="Parameterized_complexity:41">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>t</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>W</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W[t]
  </annotation>
 </semantics>
</math>

 can be defined using the family of Weighted Weft-

<math display="inline" id="Parameterized_complexity:42">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

-Depth-

<math display="inline" id="Parameterized_complexity:43">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 SAT problems for 

<math display="inline" id="Parameterized_complexity:44">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>‚â•</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>d</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\geq t
  </annotation>
 </semantics>
</math>

: 

<math display="inline" id="Parameterized_complexity:45">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>t</mi>
    <mo>,</mo>
    <mi>d</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>W</ci>
    <interval closure="closed">
     <ci>t</ci>
     <ci>d</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W[t,d]
  </annotation>
 </semantics>
</math>

 is the class of parameterized problems that fpt-reduce to this problem, and 

<math display="inline" id="Parameterized_complexity:46">
 <semantics>
  <mrow>
   <mrow>
    <mi>W</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>t</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">‚ãÉ</mo>
     <mrow>
      <mi>d</mi>
      <mo>‚â•</mo>
      <mi>t</mi>
     </mrow>
    </msub>
    <mrow>
     <mi>W</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>t</mi>
      <mo>,</mo>
      <mi>d</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>W</ci>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <union></union>
      <apply>
       <geq></geq>
       <ci>d</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>W</ci>
      <interval closure="closed">
       <ci>t</ci>
       <ci>d</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W[t]=\bigcup_{d\geq t}W[t,d]
  </annotation>
 </semantics>
</math>

.</p>

<p>Here, <strong>Weighted Weft-

<math display="inline" id="Parameterized_complexity:47">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

-Depth-

<math display="inline" id="Parameterized_complexity:48">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 SAT</strong> is the following problem:</p>
<ul>
<li>Input: A Boolean formula of depth at most 

<math display="inline" id="Parameterized_complexity:49">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 and weft at most 

<math display="inline" id="Parameterized_complexity:50">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

, and a number 

<math display="inline" id="Parameterized_complexity:51">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

. The <em>depth</em> is the maximal number of gates on any path from the root to a leaf, and the <em>weft</em> is the maximal number of gates <em>of fan-in at least three</em> on any path from the root to a leaf.</li>
<li>Question: Does the formula have a satisfying assignment of Hamming weight at most 

<math display="inline" id="Parameterized_complexity:52">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

?</li>
</ul>

<p>It can be shown that the problem Weighted 

<math display="inline" id="Parameterized_complexity:53">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

-Normalize SAT is complete for 

<math display="inline" id="Parameterized_complexity:54">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>t</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>W</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W[t]
  </annotation>
 </semantics>
</math>

 under fpt-reductions.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Here, <strong>Weighted 

<math display="inline" id="Parameterized_complexity:55">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

-Normalize SAT</strong> is the following problem:</p>
<ul>
<li>Input: A Boolean formula of depth at most 

<math display="inline" id="Parameterized_complexity:56">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 with an AND-gate on top, and a number 

<math display="inline" id="Parameterized_complexity:57">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

.</li>
<li>Question: Does the formula have a satisfying assignment of Hamming weight at most 

<math display="inline" id="Parameterized_complexity:58">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

?</li>
</ul>
<h4 id="wp"><em>W</em>[<em>P</em>]</h4>

<p><em>W</em>[<em>P</em>] is the class of problems that can be decided by a nondeterministic polynomial-time Turing-machine that makes at most 

<math display="inline" id="Parameterized_complexity:59">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>k</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>‚ãÖ</mo>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <ci>normal-‚ãÖ</ci>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(f(k)\cdot\log n)
  </annotation>
 </semantics>
</math>

 nondeterministic choices in the computation on 

<math display="inline" id="Parameterized_complexity:60">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>k</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>k</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,k)
  </annotation>
 </semantics>
</math>

 (a <em>k</em>-restricted Turing-machine). </p>

<p>It is known that FPT is contained in W[P], and the inclusion is believed to be strict. However, resolving this issue would imply a solution to the <a href="P_versus_NP" title="wikilink">P versus NP</a> problem.</p>

<p>Other connections to unparameterised computational complexity are that FPT equals <em>W</em>[<em>P</em>] if and only if <a href="circuit_satisfiability" title="wikilink">circuit satisfiability</a> can be decided in time 

<math display="inline" id="Parameterized_complexity:61">
 <semantics>
  <mrow>
   <mrow>
    <mi>exp</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>o</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <msup>
    <mi>m</mi>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <exp></exp>
     <apply>
      <times></times>
      <ci>o</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>m</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exp(o(n))m^{O(1)}
  </annotation>
 </semantics>
</math>

, or if and only if there is a computable, nondecreasing, unbounded function f such that all languages recognised by a nondeterministic polynomial-time Turing machine using f(n)log n nondeterministic choices are in¬†<em>P</em>.</p>
<h3 id="xp">XP</h3>

<p><strong>XP</strong> is the class of parameterized problems that can be solved in time 

<math display="inline" id="Parameterized_complexity:62">
 <semantics>
  <msup>
   <mi>n</mi>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>k</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{f(k)}
  </annotation>
 </semantics>
</math>

 for some computable function 

<math display="inline" id="Parameterized_complexity:63">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="notes">Notes</h2>
<references>
</references>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li>The Computer Journal. Volume 51, Numbers 1 and 3 (2008). <a href="http://comjnl.oxfordjournals.org/">The Computer Journal</a>. Special Double Issue on Parameterized Complexity with 15 survey articles, book review, and a Foreword by Guest Editors R. Downey, M. Fellows and M. Langston.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://fpt.wikidot.com/">Wiki on parameterized complexity</a></li>
<li><a href="http://www.sprg.uniroma2.it/home/cesati/research/compendium/">Compendium of Parameterized Problems</a></li>
</ul>

<p>"</p>

<p><a href="Category:Computational_complexity_theory" title="wikilink">Category:Computational complexity theory</a> <a href="Category:Parameterized_complexity" title="wikilink"> </a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">‚Ü©</a></li>
<li id="fn2"><a href="#fnref2">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
