<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1622">McCarthy Formalism</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>McCarthy Formalism</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a> and <a href="recursion_theory" title="wikilink">recursion theory</a> the <strong>McCarthy Formalism</strong> (1963) of <a class="uri" href="computer" title="wikilink">computer</a> scientist <a href="John_McCarthy_(computer_scientist)" title="wikilink">John McCarthy</a> clarifies the notion of <a href="recursion_(computer_science)" title="wikilink">recursive functions</a> by use of the IF-THEN-ELSE construction common to computer science, together with four of the operators of <a href="primitive_recursive_function" title="wikilink">primitive recursive functions</a>: zero, successor, equality of numbers and composition. The conditional operator replaces both <a href="primitive_recursion" title="wikilink">primitive recursion</a> and the <a class="uri" href="mu-operator" title="wikilink">mu-operator</a>.</p>
<h2 id="introduction">Introduction</h2>
<h3 id="mccarthys-notion-of-conditional-expression">McCarthy's notion of <em>conditional expression</em></h3>

<p>McCarthy (1960) described his formalism this way:</p>
<dl>
<dd>"In this article, we first describe a formalism for defining functions recursively. We believe this formalism has advantages both as a programming language and as a vehicle for developing a theory of computation....
</dd>
<dd>" We shall need a number of mathematical ideas and notations concerning functions in general. Most of the ideas are well known, but the notion of <em>conditional expression</em> is believed to be new, and the use of <em>conditional expressions</em> permits functions to be defined recursively in a new and convenient way."
</dd>
</dl>
<h3 id="minskys-explanation-of-the-formalism">Minsky's explanation of the "formalism"</h3>

<p>In his 1967 <em>Computation: Finite and Infinite Machines</em>, <a href="Marvin_Minsky" title="wikilink">Marvin Minsky</a> in his §10.6 <strong>Conditional Expressions: The McCarthy Formalism</strong> describes the "formalism" as follows:</p>
<dl>
<dd>"Practical computer languages do not lend themselves to formal mathematical treatment--they are not designed to make it easy to prove theorems about the procedures they describe. In a paper by McCarthy [1963] we find a formalism that enhances the practical aspect of the recursive-function concept, while preserving and improving its mathematical clarity. ¶ McCarthy introduces "conditional expressions" of the form
<dl>
<dd>f = (<strong>if</strong> <em>p</em><sub>1</sub> <strong>then</strong> <em>e</em><sub>1</sub> <strong>else</strong> <em>e</em><sub>2</sub>)
</dd>
</dl>
</dd>
<dd>where the <em>e</em><sub>i</sub> are expressions and <em>p</em><sub>1</sub> is a statement (or equation) that may be true or false. ¶ This expression means
<dl>
<dd>See if <em>p</em><sub>1</sub> is true; if so the value of <em>f</em> is given by <em>e</em><sub>1</sub>.
</dd>
<dd>IF <em>p1</em> is false, the value of <em>f</em> is given by <em>e</em><sub>2</sub>.
</dd>
</dl>
</dd>
<dd>This conditional expression . . . has also the power of the minimization operator. . ..
</dd>
<dd>The McCarthy formalism is like the general recursive (Kleene) system, in being based on some basic functions, composition, and equality, but with the conditional expression alone replacing both the primitive-recursive scheme and the minimization operator." (Minsky 1967:192-193)
</dd>
</dl>

<p>Minsky uses the following operators in his demonstrations:<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<ul>
<li>Zero</li>
<li>Successor</li>
<li>Equality of numbers</li>
<li>Composition (substitution, replacement, assignment)<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></li>
<li>Conditional expression</li>
</ul>

<p>From these he shows how to derive the <em>predecessor</em> function (i.e. DECREMENT); with this tool he derives the minimization operator necessary for "general" <a class="uri" href="recursion" title="wikilink">recursion</a>, as well as primitive-recursive definitions.</p>
<h3 id="expansion-of-if-then-else-to-the-case-operator">Expansion of IF-THEN-ELSE to the CASE operator</h3>

<p>In his 1952 <em>Introduction of Meta-Mathematics</em> <a href="Stephen_Kleene" title="wikilink">Stephen Kleene</a> provides a definition of what it means to be a primitive recursive function:</p>
<dl>
<dd>"A function φ is <em>primitive recursive in</em> ψ<sub>1</sub>, ...,ψ<sub>l</sub> (briefly <strong>Ψ</strong>), if there is a finite sequence φ<sub>1</sub>, ...,φ<sub>k</sub> of (occurrences of) functions ... such that each function of the sequence is either one of the functions <strong>Ψ</strong> (the assumed functions), or an initial function, or an immediate dependent of preceding functions, and the last function φ<sub>k</sub> is φ." (Kleene 1952:224)
</dd>
</dl>

<p>In other words, given a "basis" function (it can be a constant such as 0), primitive recursion uses either the base or the previous value of the function to produce the value of the function; primitive recursion is sometimes called <a href="mathematical_induction" title="wikilink">mathematical induction</a></p>

<p>Minsky (above) is describing a two-CASE operator. A demonstration that the <em>nested</em> IF-THEN-ELSE—the "<a href="case_statement" title="wikilink">case statement</a>" (or "switch statement")--is <a href="primitive_recursive" title="wikilink">primitive recursive</a> can be found in Kleene 1952:229<ref>Kleene's 5 primitive recursion "schema" include the following:</ref></p>
<ul>
<li>(I) zero constant: 0 or may be 0()</li>
<li>(II) successor: S(0) = "1", S(1) = "2", etc.</li>
<li>(III) projection: U<sub>i</sub><sup>n</sup> ( x<sub>1</sub> , ..., x<sub>n</sub> ) = x<sub>i</sub>, the x<sub>i</sub>'s are "parameters" fixed throughout the calculation, and U<sub>i</sub><sup>n</sup> project one of them out, the notation 

<math display="inline" id="McCarthy_Formalism:0">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>π</mi>
     <mi>i</mi>
     <mi>n</mi>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>π</ci>
       <ci>i</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <vector>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
     </vector>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi_{i}^{n}(x_{1},\ldots,x_{n})=x_{i}
  </annotation>
 </semantics>
</math>

 is also used.</li>
<li>(IV) substitution φ( x<sub>1</sub> , ..., x<sub>n</sub> ) = ψ ( χ<sub>1</sub>( x<sub>1</sub> , ..., x<sub>n</sub> ), ..., χ<sub>m</sub>( x<sub>1</sub> , ..., x<sub>n</sub> ))</li>
<li>(V) primitive recursion; cf Kleene 1952:219. at "#F ('mutually-exclusive predicates')". The CASE operator behaves like a logical <a class="uri" href="multiplexer" title="wikilink">multiplexer</a> and is simply an extension of the simpler two-case logical operator sometimes called AND-OR-SELECT (see more at <a href="Propositional_formula" title="wikilink">Propositional formula</a>). The CASE operator for three cases would be verbally described as: "If X is CASE 1 then DO "p" else if X is CASE 2 then do "q" else if X is CASE "3" then do "r" else do "default".</li>
</ul>

<p>Boolos-Burgess-Jeffrey 2002 observe that in a particular instance the CASE operator, or a sequence of nested IF-THEN-ELSE statements, must be both <a href="mutually_exclusive" title="wikilink">mutually exclusive</a>, meaning that only one "case" holds (is true), and <a href="collectively_exhaustive" title="wikilink">collectively exhaustive</a>, meaning <em>every</em> possible situation or "case" is "covered". These requirements are a consequence of the determinacy of <a href="Propositional_logic" title="wikilink">Propositional logic</a>; the correct implementation requires the use of <a href="truth_table" title="wikilink">truth tables</a> and <a href="Karnaugh_map" title="wikilink">Karnaugh maps</a> to specify and simplify the cases; see more at <a href="Propositional_formula" title="wikilink">Propositional formula</a>. The authors point out the power of "definition by cases":</p>
<dl>
<dd>"...in more complicated examples, definition by cases makes it far easier to establish the (primitive) recursiveness of important functions. This is mainly because there are a variety of processes for defining new relations from old that can be shown to produce new (primitive) recursive relations when applied to (primitive) recursive relations." (Boolos-Burgess-Jeffrey 2002:74)
</dd>
</dl>

<p>They prove, in particular, that the processes of <a href="substitution_of_variables" title="wikilink">substitution</a>, <a href="graph_relation" title="wikilink">graph relation</a> (similar to the <a href="identity_relation" title="wikilink">identity relation</a> that plucks out (the value of) a particular variable from a list of variables), <a class="uri" href="negation" title="wikilink">negation</a> (logical NOT), <a href="Logical_conjunction" title="wikilink">conjunction</a> (logical AND), <a class="uri" href="disjunction" title="wikilink">disjunction</a> (logical OR), bounded <a href="universal_quantification" title="wikilink">universal quantification</a>, or bounded <a href="existential_quantification" title="wikilink">existential quantification</a> can be used together with definition by cases to create new primitive recursive functions (cf Boolos-Burgess-Jeffrey 2002:74-77).</p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li><a href="George_S._Boolos" title="wikilink">George S. Boolos</a>, <a href="John_P._Burgess" title="wikilink">John P. Burgess</a>, and <a href="Richard_C._Jeffrey" title="wikilink">Richard C. Jeffrey</a>, 2002, <em>Computability and Logic: Fourth Edition</em>, Cambridge University Press, Cambridge UK, ISBN 0-521-00758-5 paperback.</li>
<li><a href="John_McCarthy_(computer_scientist)" title="wikilink">John McCarthy</a> (1960), <em>Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I</em>, Communications of the ACM, 3, 184-195 (April 1960).</li>
<li><a href="John_McCarthy_(computer_scientist)" title="wikilink">John McCarthy</a> (1963), <em><a href="http://www-formal.stanford.edu/jmc/basis.html">A Basis for a Mathematical Theory of Computation</a></em>, Computer Programming and Formal Systems, pp. 33-70.</li>
<li><a href="Marvin_Minsky" title="wikilink">Marvin Minsky</a> (1967), <em>Computation: Finite and Infinite Machines</em>, Prentice-Hall Inc, Englewood Cliffs, NJ.</li>
</ul>

<p>"</p>

<p><a href="Category:Computability_theory" title="wikilink">Category:Computability theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Minsky (1967) does not include the identity operator in his description of <a href="primitive_recursive_function" title="wikilink">primitive recursive functions</a>. Why this is the case is not known.<a href="#fnref1">↩</a></li>
<li id="fn2">Various authors use various names for this operation. Kleene calls it: "the schema of <em>definition by substitution</em>. The expression for the ambiguous value of φ is obtained by substitution of expressions for the ambiguous values of χ<sub>1</sub>, . . ., χ<sub>m</sub> for the variables of ψ . . .. the function φ defined by an application of this schema we sometimes write ast <strong>S<sub>m</sub><sup>n</sup></strong>(ψ, <sub>1</sub>, . . ., χ<sub>m</sub>." (Kleene 1952:220). Knuth names it the "all-important <em>replacement</em> operation (sometimes called <em>assignment</em> or <em>substitution</em>)", and he symbolizes it with the " ← " arrow, e.g. "m ← n" means the value of variable <em>m</em> is to be replaced by the current value of variable <em>n</em>" (cf Knuth 1973:3).<a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
