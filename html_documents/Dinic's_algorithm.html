<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="789">Dinic's algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Dinic's algorithm</h1>
<hr/>

<p><strong>Dinitz's algorithm</strong> is a <a href="strongly_polynomial" title="wikilink">strongly polynomial</a> algorithm for computing the <a href="maximum_flow" title="wikilink">maximum flow</a> in a <a href="flow_network" title="wikilink">flow network</a>, conceived in 1970 by Israeli (formerly Soviet) computer scientist Yefim (Chaim) A. Dinitz.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The algorithm runs in 

<math display="inline" id="Dinic's_algorithm:0">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>V</mi>
      <mn>2</mn>
     </msup>
     <mi>E</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(V^{2}E)
  </annotation>
 </semantics>
</math>

 time and is similar to the <a href="Edmonds–Karp_algorithm" title="wikilink">Edmonds–Karp algorithm</a>, which runs in 

<math display="inline" id="Dinic's_algorithm:1">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>V</mi>
     <msup>
      <mi>E</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>V</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>E</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(VE^{2})
  </annotation>
 </semantics>
</math>

 time, in that it uses shortest augmenting paths. The introduction of the concepts of the <em>level graph</em> and <em>blocking flow</em> enable Dinic's algorithm to achieve its performance.</p>
<h2 id="history">History</h2>

<p>Yefim Dinitz invented this algorithm in response to a pre-class exercise in Adel'son-Vel'sky's (co-inventor of AVL trees) Algorithm class. At the time he was not aware of the basic facts regarding Ford-Fulkerson algorithm.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Dinitz mentions inventing his algorithm in January, 1969 which was published in 1970 in journal Doklady. In 1974, Shimon Even and (his then Ph.D. student) Alon Itai at the Technion, Haifa were very curious and intrigued by the Dinitz's algorithm as well as Alexander Karzanov's idea of blocking flow. However it was hard to decipher these two papers for them, each being limited to four pages to meet the restrictions of journal Doklady. However Even did not give up and after three days of effort managed to understand both papers except for the layered network maintenance issue. Over the next couple of years, Even gave lectures on "Dinic's algorithm" mispronouncing the name of the author while popularizing it. Even and Itai also contributed to this algorithm by combining BFS and DFS which is the current version of algorithm <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>For about 10 years of time after Ford–Fulkerson algorithm was invented, it was unknown if it can be made to terminate in polynomial time in the generic case of irrational edge capacities. This caused lack of any known polynomial time algorithm that solved max flow problem in generic case. Dinitz algorithm and the <a href="Edmonds–Karp_algorithm" title="wikilink">Edmonds–Karp algorithm</a>, which was published in 1972, independently showed that in the <a href="Ford–Fulkerson_algorithm" title="wikilink">Ford–Fulkerson algorithm</a>, if each augmenting path is the shortest one, the length of the augmenting paths is non-decreasing and it always terminated.</p>
<h2 id="definition">Definition</h2>

<p>Let 

<math display="inline" id="Dinic's_algorithm:2">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>V</mi>
     <mo>,</mo>
     <mi>E</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mi>c</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <vector>
     <interval closure="open">
      <ci>V</ci>
      <ci>E</ci>
     </interval>
     <ci>c</ci>
     <ci>s</ci>
     <ci>t</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=((V,E),c,s,t)
  </annotation>
 </semantics>
</math>

 be a network with 

<math display="inline" id="Dinic's_algorithm:3">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>c</ci>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c(u,v)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dinic's_algorithm:4">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(u,v)
  </annotation>
 </semantics>
</math>

 the capacity and the flow of the edge 

<math display="inline" id="Dinic's_algorithm:5">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>u</mi>
   <mo>,</mo>
   <mi>v</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>u</ci>
    <ci>v</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (u,v)
  </annotation>
 </semantics>
</math>

 respectively.</p>
<dl>
<dd>The <strong>residual capacity</strong> is a mapping 

<math display="inline" id="Dinic's_algorithm:6">
 <semantics>
  <mrow>
   <msub>
    <mi>c</mi>
    <mi>f</mi>
   </msub>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>V</mi>
     <mo>×</mo>
     <mi>V</mi>
    </mrow>
    <mo>→</mo>
    <msup>
     <mi>R</mi>
     <mo>+</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>c</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>V</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>R</ci>
      <plus></plus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{f}\colon V\times V\to R^{+}
  </annotation>
 </semantics>
</math>

 defined as,
<ol>
<li>if 

<math display="inline" id="Dinic's_algorithm:7">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <mi>E</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (u,v)\in E
  </annotation>
 </semantics>
</math>

,

<p>

<math display="block" id="Dinic's_algorithm:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>c</mi>
     <mi>f</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>c</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>f</ci>
     </apply>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>c</ci>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{f}(u,v)=c(u,v)-f(u,v)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Dinic's_algorithm:9">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>c</mi>
     <mi>f</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>v</mi>
     <mo>,</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>f</ci>
     </apply>
     <interval closure="open">
      <ci>v</ci>
      <ci>u</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{f}(v,u)=f(u,v)
  </annotation>
 </semantics>
</math>

</p></li>
<li>

<math display="inline" id="Dinic's_algorithm:10">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>c</mi>
     <mi>f</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <ci>f</ci>
     </apply>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c_{f}(u,v)=0
  </annotation>
 </semantics>
</math>

 otherwise.</li>
</ol>
</dd>
</dl>
<dl>
<dd>The <strong>residual graph</strong> is the graph 

<math display="inline" id="Dinic's_algorithm:11">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mi>f</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>V</mi>
     <mo>,</mo>
     <msub>
      <mi>E</mi>
      <mi>f</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <msub>
     <mrow>
      <msub>
       <mi>c</mi>
       <mi>f</mi>
      </msub>
      <mo fence="true">|</mo>
     </mrow>
     <msub>
      <mi>E</mi>
      <mi>f</mi>
     </msub>
    </msub>
    <mo>,</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>f</ci>
    </apply>
    <vector>
     <interval closure="open">
      <ci>V</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>f</ci>
      </apply>
     </interval>
     <apply>
      <csymbol cd="latexml">evaluated-at</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>f</ci>
      </apply>
     </apply>
     <ci>s</ci>
     <ci>t</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{f}=((V,E_{f}),c_{f}|_{E_{f}},s,t)
  </annotation>
 </semantics>
</math>

, where

<p>

<math display="block" id="Dinic's_algorithm:12">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mi>f</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∈</mo>
     <mrow>
      <mi>V</mi>
      <mo>×</mo>
      <mi>V</mi>
     </mrow>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>c</mi>
       <mi>f</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo>,</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>></mo>
     <mn>0</mn>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>f</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
      <apply>
       <times></times>
       <ci>V</ci>
       <ci>V</ci>
      </apply>
     </apply>
     <apply>
      <gt></gt>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>c</ci>
        <ci>f</ci>
       </apply>
       <interval closure="open">
        <ci>u</ci>
        <ci>v</ci>
       </interval>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{f}=\{(u,v)\in V\times V:c_{f}(u,v)>0\}
  </annotation>
 </semantics>
</math>

.</p>
</dd>
</dl>
<dl>
<dd>An <strong>augmenting path</strong> is an 

<math display="inline" id="Dinic's_algorithm:13">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>-</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>s</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s-t
  </annotation>
 </semantics>
</math>

 path in the residual graph 

<math display="inline" id="Dinic's_algorithm:14">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{f}
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>
<dl>
<dd>Define 

<math display="inline" id="Dinic's_algorithm:15">
 <semantics>
  <mrow>
   <mo>dist</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>dist</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{dist}(v)
  </annotation>
 </semantics>
</math>

 to be the length of the shortest path from 

<math display="inline" id="Dinic's_algorithm:16">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Dinic's_algorithm:17">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Dinic's_algorithm:18">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{f}
  </annotation>
 </semantics>
</math>

. Then the <strong>level graph</strong> of 

<math display="inline" id="Dinic's_algorithm:19">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{f}
  </annotation>
 </semantics>
</math>

 is the graph 

<math display="inline" id="Dinic's_algorithm:20">
 <semantics>
  <mrow>
   <msub>
    <mi>G</mi>
    <mi>L</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <msub>
     <mi>E</mi>
     <mi>L</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mrow>
      <msub>
       <mi>c</mi>
       <mi>f</mi>
      </msub>
      <mo fence="true">|</mo>
     </mrow>
     <msub>
      <mi>E</mi>
      <mi>L</mi>
     </msub>
    </msub>
    <mo>,</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>G</ci>
     <ci>L</ci>
    </apply>
    <vector>
     <ci>V</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>L</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">evaluated-at</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>c</ci>
       <ci>f</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>L</ci>
      </apply>
     </apply>
     <ci>s</ci>
     <ci>t</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{L}=(V,E_{L},c_{f}|_{E_{L}},s,t)
  </annotation>
 </semantics>
</math>

, where

<p>

<math display="block" id="Dinic's_algorithm:21">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mi>L</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∈</mo>
     <msub>
      <mi>E</mi>
      <mi>f</mi>
     </msub>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mo>dist</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mrow>
       <mo>dist</mo>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>u</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>L</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <interval closure="open">
       <ci>u</ci>
       <ci>v</ci>
      </interval>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>f</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <ci>dist</ci>
       <ci>v</ci>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <ci>dist</ci>
        <ci>u</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{L}=\{(u,v)\in E_{f}:\operatorname{dist}(v)=\operatorname{dist}(u)+1\}
  </annotation>
 </semantics>
</math>

.</p>
</dd>
</dl>
<dl>
<dd>A <strong>blocking flow</strong> is an 

<math display="inline" id="Dinic's_algorithm:22">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>-</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>s</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s-t
  </annotation>
 </semantics>
</math>

 flow 

<math display="inline" id="Dinic's_algorithm:23">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 such that the graph 

<math display="inline" id="Dinic's_algorithm:24">
 <semantics>
  <mrow>
   <msup>
    <mi>G</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>V</mi>
    <mo>,</mo>
    <msubsup>
     <mi>E</mi>
     <mi>L</mi>
     <mo>′</mo>
    </msubsup>
    <mo>,</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>G</ci>
     <ci>normal-′</ci>
    </apply>
    <vector>
     <ci>V</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>L</ci>
      </apply>
      <ci>normal-′</ci>
     </apply>
     <ci>s</ci>
     <ci>t</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G^{\prime}=(V,E_{L}^{\prime},s,t)
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Dinic's_algorithm:25">
 <semantics>
  <mrow>
   <msubsup>
    <mi>E</mi>
    <mi>L</mi>
    <mo>′</mo>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo>,</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo><</mo>
     <mrow>
      <msub>
       <mrow>
        <msub>
         <mi>c</mi>
         <mi>f</mi>
        </msub>
        <mo fence="true">|</mo>
       </mrow>
       <msub>
        <mi>E</mi>
        <mi>L</mi>
       </msub>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>u</mi>
       <mo>,</mo>
       <mi>v</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>L</ci>
     </apply>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <interval closure="open">
      <ci>u</ci>
      <ci>v</ci>
     </interval>
     <apply>
      <lt></lt>
      <apply>
       <times></times>
       <ci>f</ci>
       <interval closure="open">
        <ci>u</ci>
        <ci>v</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">evaluated-at</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>c</ci>
         <ci>f</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>E</ci>
         <ci>L</ci>
        </apply>
       </apply>
       <interval closure="open">
        <ci>u</ci>
        <ci>v</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{L}^{\prime}=\{(u,v):f(u,v)<c_{f}|_{E_{L}}(u,v)\}
  </annotation>
 </semantics>
</math>

 contains no 

<math display="inline" id="Dinic's_algorithm:26">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>-</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>s</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s-t
  </annotation>
 </semantics>
</math>

 path.
</dd>
</dl>
<h2 id="algorithm">Algorithm</h2>

<p><strong>Dinic's Algorithm</strong></p>
<dl>
<dd><em>Input</em>: A network 

<math display="inline" id="Dinic's_algorithm:27">
 <semantics>
  <mrow>
   <mi>G</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>V</mi>
     <mo>,</mo>
     <mi>E</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mi>c</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>G</ci>
    <vector>
     <interval closure="open">
      <ci>V</ci>
      <ci>E</ci>
     </interval>
     <ci>c</ci>
     <ci>s</ci>
     <ci>t</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G=((V,E),c,s,t)
  </annotation>
 </semantics>
</math>

.
</dd>
<dd><em>Output</em>: An 

<math display="inline" id="Dinic's_algorithm:28">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>-</mo>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>s</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s-t
  </annotation>
 </semantics>
</math>

 flow 

<math display="inline" id="Dinic's_algorithm:29">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 of maximum value.
</dd>
</dl>
<ol>
<li>Set 

<math display="inline" id="Dinic's_algorithm:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>e</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>e</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(e)=0
  </annotation>
 </semantics>
</math>

 for each 

<math display="inline" id="Dinic's_algorithm:31">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>∈</mo>
   <mi>E</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>e</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e\in E
  </annotation>
 </semantics>
</math>

.</li>
<li>Construct 

<math display="inline" id="Dinic's_algorithm:32">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>L</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{L}
  </annotation>
 </semantics>
</math>

 from 

<math display="inline" id="Dinic's_algorithm:33">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{f}
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Dinic's_algorithm:34">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="Dinic's_algorithm:35">
 <semantics>
  <mrow>
   <mrow>
    <mo>dist</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi mathvariant="normal">∞</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <ci>dist</ci>
     <ci>t</ci>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{dist}(t)=\infty
  </annotation>
 </semantics>
</math>

, stop and output 

<math display="inline" id="Dinic's_algorithm:36">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

.</li>
<li>Find a blocking flow 

<math display="inline" id="Dinic's_algorithm:37">
 <semantics>
  <msup>
   <mpadded width="+2.8pt">
    <mi>f</mi>
   </mpadded>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>f</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\;^{\prime}
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Dinic's_algorithm:38">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>L</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{L}
  </annotation>
 </semantics>
</math>

.</li>
<li>Augment flow 

<math display="inline" id="Dinic's_algorithm:39">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi>f</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ f
  </annotation>
 </semantics>
</math>

 by 

<math display="inline" id="Dinic's_algorithm:40">
 <semantics>
  <msup>
   <mpadded width="+2.8pt">
    <mi>f</mi>
   </mpadded>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>f</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f\;^{\prime}
  </annotation>
 </semantics>
</math>

 and go back to step 2.</li>
</ol>
<h2 id="analysis">Analysis</h2>

<p>It can be shown that the number of edges in each blocking flow increases by at least 1 each time and thus there are at most 

<math display="inline" id="Dinic's_algorithm:41">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-1
  </annotation>
 </semantics>
</math>

 blocking flows in the algorithm, where 

<math display="inline" id="Dinic's_algorithm:42">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is the number of vertices in the network. The level graph 

<math display="inline" id="Dinic's_algorithm:43">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>L</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{L}
  </annotation>
 </semantics>
</math>

 can be constructed by <a href="Breadth-first_search" title="wikilink">Breadth-first search</a> in 

<math display="inline" id="Dinic's_algorithm:44">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(E)
  </annotation>
 </semantics>
</math>

 time and a blocking flow in each level graph can be found in 

<math display="inline" id="Dinic's_algorithm:45">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>V</mi>
     <mi>E</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(VE)
  </annotation>
 </semantics>
</math>

 time. Hence, the running time of Dinic's algorithm is 

<math display="inline" id="Dinic's_algorithm:46">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>V</mi>
      <mn>2</mn>
     </msup>
     <mi>E</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>V</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(V^{2}E)
  </annotation>
 </semantics>
</math>

.</p>

<p>Using a data structure called <a href="dynamic_trees" title="wikilink">dynamic trees</a>, the running time of finding a blocking flow in each phase can be reduced to 

<math display="inline" id="Dinic's_algorithm:47">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>E</mi>
     <mrow>
      <mi>log</mi>
      <mi>V</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <log></log>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(E\log V)
  </annotation>
 </semantics>
</math>

 and therefore the running time of Dinic's algorithm can be improved to 

<math display="inline" id="Dinic's_algorithm:48">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>V</mi>
     <mi>E</mi>
     <mrow>
      <mi>log</mi>
      <mi>V</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>E</ci>
     <apply>
      <log></log>
      <ci>V</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(VE\log V)
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="special-cases">Special cases</h3>

<p>In networks with unit capacities, a much stronger time bound holds. Each blocking flow can be found in 

<math display="inline" id="Dinic's_algorithm:49">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>E</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>E</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(E)
  </annotation>
 </semantics>
</math>

 time, and it can be shown that the number of phases does not exceed 

<math display="inline" id="Dinic's_algorithm:50">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msqrt>
     <mi>E</mi>
    </msqrt>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <root></root>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\sqrt{E})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dinic's_algorithm:51">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>V</mi>
     <mrow>
      <mn>2</mn>
      <mo>/</mo>
      <mn>3</mn>
     </mrow>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>V</ci>
     <apply>
      <divide></divide>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(V^{2/3})
  </annotation>
 </semantics>
</math>

. Thus the algorithm runs in 

<math display="inline" id="Dinic's_algorithm:52">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mi>min</mi>
      <mrow>
       <mo stretchy="false">{</mo>
       <msup>
        <mi>V</mi>
        <mrow>
         <mn>2</mn>
         <mo>/</mo>
         <mn>3</mn>
        </mrow>
       </msup>
       <mo>,</mo>
       <msup>
        <mi>E</mi>
        <mrow>
         <mn>1</mn>
         <mo>/</mo>
         <mn>2</mn>
        </mrow>
       </msup>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
     <mi>E</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <min></min>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>V</ci>
       <apply>
        <divide></divide>
        <cn type="integer">2</cn>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>E</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\min\{V^{2/3},E^{1/2}\}E)
  </annotation>
 </semantics>
</math>

 time.</p>

<p>In networks arising during the solution of <a href="bipartite_matching" title="wikilink">bipartite matching</a> problem, the number of phases is bounded by 

<math display="inline" id="Dinic's_algorithm:53">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msqrt>
     <mi>V</mi>
    </msqrt>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <root></root>
     <ci>V</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\sqrt{V})
  </annotation>
 </semantics>
</math>

, therefore leading to the 

<math display="inline" id="Dinic's_algorithm:54">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msqrt>
      <mi>V</mi>
     </msqrt>
     <mi>E</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <apply>
      <root></root>
      <ci>V</ci>
     </apply>
     <ci>E</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\sqrt{V}E)
  </annotation>
 </semantics>
</math>

 time bound. The resulting algorithm is also known as <a href="Hopcroft–Karp_algorithm" title="wikilink">Hopcroft–Karp algorithm</a>. More generally, this bound holds for any <em>unit network</em> — a network in which each vertex, except for source and sink, either has a single entering edge of capacity one, or a single outgoing edge of capacity one, and all other capacities are arbitrary integers.</p>
<h2 id="example">Example</h2>

<p>The following is a simulation of Dinic's algorithm. In the level graph 

<math display="inline" id="Dinic's_algorithm:55">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>L</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{L}
  </annotation>
 </semantics>
</math>

, the vertices with labels in red are the values 

<math display="inline" id="Dinic's_algorithm:56">
 <semantics>
  <mrow>
   <mo>dist</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>dist</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \operatorname{dist}(v)
  </annotation>
 </semantics>
</math>

. The paths in blue form a blocking flow.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Dinic's_algorithm:57">
 <semantics>
  <mi>G</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>G</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Dinic's_algorithm:58">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{f}
  </annotation>
 </semantics>
</math>

</p></th>
<th style="text-align: left;">
<p>

<math display="inline" id="Dinic's_algorithm:59">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>L</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>L</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{L}
  </annotation>
 </semantics>
</math>

</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>1.</p></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Dinic algorithm G1.svg</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Dinic algorithm Gf1.svg</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Dinic algorithm GL1.svg</figcaption>
</figure></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>align="left" The blocking flow consists of</p>
<ol>
<li>

<math display="inline" id="Dinic's_algorithm:60">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>s</mi>
   <mo>,</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>3</mn>
   <mo>,</mo>
   <mi>t</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>s</ci>
    <cn type="integer">1</cn>
    <cn type="integer">3</cn>
    <ci>t</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{s,1,3,t\}
  </annotation>
 </semantics>
</math>

 with 4 units of flow,</li>
<li>

<math display="inline" id="Dinic's_algorithm:61">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>s</mi>
   <mo>,</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>4</mn>
   <mo>,</mo>
   <mi>t</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>s</ci>
    <cn type="integer">1</cn>
    <cn type="integer">4</cn>
    <ci>t</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{s,1,4,t\}
  </annotation>
 </semantics>
</math>

 with 6 units of flow, and</li>
<li>

<math display="inline" id="Dinic's_algorithm:62">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>s</mi>
   <mo>,</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mn>4</mn>
   <mo>,</mo>
   <mi>t</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>s</ci>
    <cn type="integer">2</cn>
    <cn type="integer">4</cn>
    <ci>t</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{s,2,4,t\}
  </annotation>
 </semantics>
</math>

 with 4 units of flow.</li>
</ol>

<p>Therefore the blocking flow is of 14 units and the value of flow 

<math display="inline" id="Dinic's_algorithm:63">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>f</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |f|
  </annotation>
 </semantics>
</math>

 is 14. Note that each augmenting path in the blocking flow has <em>3</em> edges.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>2.</p></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Dinic algorithm G2.svg</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Dinic algorithm Gf2.svg</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Dinic algorithm GL2.svg</figcaption>
</figure></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>align="left" The blocking flow consists of</p>
<ol>
<li>

<math display="inline" id="Dinic's_algorithm:64">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>s</mi>
   <mo>,</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mn>4</mn>
   <mo>,</mo>
   <mn>3</mn>
   <mo>,</mo>
   <mi>t</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <ci>s</ci>
    <cn type="integer">2</cn>
    <cn type="integer">4</cn>
    <cn type="integer">3</cn>
    <ci>t</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{s,2,4,3,t\}
  </annotation>
 </semantics>
</math>

 with 5 units of flow.</li>
</ol>

<p>Therefore the blocking flow is of 5 units and the value of flow 

<math display="inline" id="Dinic's_algorithm:65">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>f</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |f|
  </annotation>
 </semantics>
</math>

 is 14 + 5 = 19. Note that each augmenting path has 4 edges.</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>3.</p></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Dinic algorithm G3.svg</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Dinic algorithm Gf3.svg</figcaption>
</figure></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Dinic algorithm GL3.svg</figcaption>
</figure></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>align="left" Since 

<math display="inline" id="Dinic's_algorithm:66">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 cannot be reached in 

<math display="inline" id="Dinic's_algorithm:67">
 <semantics>
  <msub>
   <mi>G</mi>
   <mi>f</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>G</ci>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   G_{f}
  </annotation>
 </semantics>
</math>

. The algorithm terminates and returns a flow with maximum value of 19. Note that in each blocking flow, the number of edges in the augmenting path increases by at least 1.</p></td>
</tr>
<tr class="odd">
</tr>
</tbody>
</table>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Ford–Fulkerson_algorithm" title="wikilink">Ford–Fulkerson algorithm</a></li>
<li><a href="Maximum_flow_problem" title="wikilink">Maximum flow problem</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Network_flow" title="wikilink">Category:Network flow</a> <a href="Category:Graph_algorithms" title="wikilink">Category:Graph algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
