<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="400">Noisy-channel coding theorem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Noisy-channel coding theorem</h1>
<hr/>

<p>In <a href="information_theory" title="wikilink">information theory</a>, the <strong>noisy-channel coding theorem</strong> (sometimes <strong>Shannon's theorem</strong>), establishes that for any given degree of <a href="Noisy_channel_model" title="wikilink">noise contamination of a communication channel</a>, it is possible to communicate discrete data (digital <a class="uri" href="information" title="wikilink">information</a>) nearly error-free up to a computable maximum rate through the channel. This result was presented by <a href="Claude_Shannon" title="wikilink">Claude Shannon</a> in 1948 and was based in part on earlier work and ideas of <a href="Harry_Nyquist" title="wikilink">Harry Nyquist</a> and <a href="Ralph_Hartley" title="wikilink">Ralph Hartley</a>.</p>

<p>The <strong>Shannon limit</strong> or <strong>Shannon capacity</strong> of a communications channel is the theoretical maximum information transfer <a href="Code_rate" title="wikilink">rate</a> of the channel, for a particular noise level.</p>
<h2 id="overview">Overview</h2>

<p>Stated by <a href="Claude_Shannon" title="wikilink">Claude Shannon</a> in 1948, the theorem describes the maximum possible efficiency of <a href="error-correcting_code" title="wikilink">error-correcting methods</a> versus levels of noise interference and data corruption. Shannon's theorem has wide-ranging applications in both communications and <a href="data_storage_device" title="wikilink">data storage</a>. This theorem is of foundational importance to the modern field of <a href="information_theory" title="wikilink">information theory</a>. Shannon only gave an outline of the proof. The first rigorous proof for the discrete case is due to <a href="Amiel_Feinstein" title="wikilink">Amiel Feinstein</a> in 1954.</p>

<p>The Shannon theorem states that given a noisy channel with <a href="channel_capacity" title="wikilink">channel capacity</a> <em>C</em> and information transmitted at a rate <em>R</em>, then if 

<math display="inline" id="Noisy-channel_coding_theorem:0">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo><</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>R</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R<C
  </annotation>
 </semantics>
</math>

 there exist <a href="code" title="wikilink">codes</a> that allow the <a href="probability_of_error" title="wikilink">probability of error</a> at the receiver to be made arbitrarily small. This means that, theoretically, it is possible to transmit information nearly without error at any rate below a limiting rate, <em>C</em>.</p>

<p>The converse is also important. If 

<math display="inline" id="Noisy-channel_coding_theorem:1">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo>></mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>R</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R>C
  </annotation>
 </semantics>
</math>

, an arbitrarily small probability of error is not achievable. All codes will have a probability of error greater than a certain positive minimal level, and this level increases as the rate increases. So, information cannot be guaranteed to be transmitted reliably across a channel at rates beyond the channel capacity. The theorem does not address the rare situation in which rate and capacity are equal.</p>

<p>The channel capacity C can be calculated from the physical properties of a channel; for a band-limited channel with Gaussian noise, using the <a href="Shannon–Hartley_theorem" title="wikilink">Shannon–Hartley theorem</a>.</p>

<p>Simple schemes such as "send the message 3 times and use a best 2 out of 3 voting scheme if the copies differ" are inefficient error-correction methods, unable to asymptotically guarantee that a block of data can be communicated free of error. Advanced techniques such as <a href="Reed–Solomon_code" title="wikilink">Reed–Solomon codes</a> and, more recently, <a href="low-density_parity-check_code" title="wikilink">low-density parity-check</a> (LDPC) codes and <a href="turbo_code" title="wikilink">turbo codes</a>, come much closer to reaching the theoretical Shannon limit, but at a cost of high computational complexity. Using these highly efficient codes and with the computing power in today's <a href="digital_signal_processors" title="wikilink">digital signal processors</a>, it is now possible to reach very close to the Shannon limit. In fact, it was shown that LDPC codes can reach within 0.0045 dB of the Shannon limit (for binary AWGN channels, with very long block lengths).<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="mathematical-statement">Mathematical statement</h2>
<figure><b>(Figure)</b>
<figcaption>Comm Channel.svg</figcaption>
</figure>

<p>Theorem (Shannon, 1948):</p>
<dl>
<dd>1. For every discrete memoryless channel, the <a href="channel_capacity" title="wikilink">channel capacity</a>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Noisy-channel_coding_theorem:2">
 <semantics>
  <mrow>
   <mpadded lspace="5pt" width="+5pt">
    <mi>C</mi>
   </mpadded>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo>sup</mo>
     <msub>
      <mi>p</mi>
      <mi>X</mi>
     </msub>
    </msub>
    <mrow>
     <mi>I</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>X</mi>
      <mo>;</mo>
      <mi>Y</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">supremum</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>X</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>I</ci>
      <list>
       <ci>X</ci>
       <ci>Y</ci>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ C=\sup_{p_{X}}I(X;Y)\,
  </annotation>
 </semantics>
</math>

<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a>
</dd>
</dl>
</dd>
</dl>
<dl>
<dd>has the following property. For any ε &gt; 0 and <em>R &lt; C</em>, for large enough <em>N</em>, there exists a code of length <em>N</em> and rate ≥ <em>R</em> and a decoding algorithm, such that the maximal probability of block error is ≤ ε.
</dd>
</dl>
<dl>
<dd>2. If a probability of bit error <em>p<sub>b</sub></em> is acceptable, rates up to <em>R(p<sub>b</sub>)</em> are achievable, where
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Noisy-channel_coding_theorem:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>p</mi>
       <mi>b</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mi>C</mi>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>H</mi>
        <mn>2</mn>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>p</mi>
         <mi>b</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <ci>C</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>H</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>p</ci>
        <ci>b</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(p_{b})=\frac{C}{1-H_{2}(p_{b})}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>and 

<math display="inline" id="Noisy-channel_coding_theorem:4">
 <semantics>
  <mrow>
   <msub>
    <mi>H</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>p</mi>
     <mi>b</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>H</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{2}(p_{b})
  </annotation>
 </semantics>
</math>

 is the <em><a href="binary_entropy_function" title="wikilink">binary entropy function</a></em>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Noisy-channel_coding_theorem:5">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>H</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>p</mi>
      <mi>b</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>-</mo>
    <mrow>
     <mo>[</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>p</mi>
        <mi>b</mi>
       </msub>
       <mrow>
        <msub>
         <mi>log</mi>
         <mn>2</mn>
        </msub>
        <msub>
         <mi>p</mi>
         <mi>b</mi>
        </msub>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <msub>
          <mi>p</mi>
          <mi>b</mi>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <msub>
         <mi>log</mi>
         <mn>2</mn>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mn>1</mn>
          <mo>-</mo>
          <msub>
           <mi>p</mi>
           <mi>b</mi>
          </msub>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
     <mo>]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>H</ci>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>p</ci>
         <ci>b</ci>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <log></log>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <ci>b</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>p</ci>
          <ci>b</ci>
         </apply>
        </apply>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <log></log>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>p</ci>
           <ci>b</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{2}(p_{b})=-\left[p_{b}\log_{2}{p_{b}}+(1-p_{b})\log_{2}({1-p_{b}})\right]
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd>3. For any <em>p<sub>b</sub></em>, rates greater than <em>R</em>(<em>p</em><sub><em>b</em></sub>) are not achievable.
</dd>
</dl>

<p>(MacKay (2003), p. 162; cf Gallager (1968), ch.5; Cover and Thomas (1991), p. 198; Shannon (1948) thm. 11)</p>
<h2 id="outline-of-proof">Outline of proof</h2>

<p>As with several other major results in information theory, the proof of the noisy channel coding theorem includes an achievability result and a matching converse result. These two components serve to bound, in this case, the set of possible rates at which one can communicate over a noisy channel, and matching serves to show that these bounds are tight bounds.</p>

<p>The following outlines are only one set of many different styles available for study in information theory texts.</p>
<h3 id="achievability-for-discrete-memoryless-channels">Achievability for discrete memoryless channels</h3>

<p>This particular proof of achievability follows the style of proofs that make use of the <a href="asymptotic_equipartition_property" title="wikilink">asymptotic equipartition property</a> (AEP). Another style can be found in information theory texts using <a href="error_exponent" title="wikilink">error exponents</a>.</p>

<p>Both types of proofs make use of a random coding argument where the codebook used across a channel is randomly constructed - this serves to make the analysis simpler while still proving the existence of a code satisfying a desired low probability of error at any data rate below the <a href="channel_capacity" title="wikilink">channel capacity</a>.</p>

<p>By an AEP-related argument, given a channel, length 

<math display="inline" id="Noisy-channel_coding_theorem:6">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 strings of source symbols 

<math display="inline" id="Noisy-channel_coding_theorem:7">
 <semantics>
  <msubsup>
   <mi>X</mi>
   <mn>1</mn>
   <mi>n</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{1}^{n}
  </annotation>
 </semantics>
</math>

, and length 

<math display="inline" id="Noisy-channel_coding_theorem:8">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 strings of channel outputs 

<math display="inline" id="Noisy-channel_coding_theorem:9">
 <semantics>
  <msubsup>
   <mi>Y</mi>
   <mn>1</mn>
   <mi>n</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Y</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{1}^{n}
  </annotation>
 </semantics>
</math>

, we can define a <em>jointly typical set</em> by the following:</p>

<p>

<math display="block" id="Noisy-channel_coding_theorem:10">
 <semantics>
  <mrow>
   <msubsup>
    <mi>A</mi>
    <mi>ε</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>x</mi>
      <mi>n</mi>
     </msup>
     <mo>,</mo>
     <msup>
      <mi>y</mi>
      <mi>n</mi>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <msup>
     <mi class="ltx_font_mathcaligraphic">𝒳</mi>
     <mi>n</mi>
    </msup>
    <mo>×</mo>
    <msup>
     <mi class="ltx_font_mathcaligraphic">𝒴</mi>
     <mi>n</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>A</ci>
      <ci>ε</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝒳</ci>
      <ci>n</ci>
     </apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝒴</ci>
      <ci>n</ci>
     </apply>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A_{\varepsilon}^{(n)}=\{(x^{n},y^{n})\in\mathcal{X}^{n}\times\mathcal{Y}^{n}
  </annotation>
 </semantics>
</math>

</p>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Noisy-channel_coding_theorem:11">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>n</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>H</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>X</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mi>ε</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msup>
   <mo>≤</mo>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>X</mi>
      <mn>1</mn>
      <mi>n</mi>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>n</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>H</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>X</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mi>ε</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>n</ci>
        <apply>
         <plus></plus>
         <apply>
          <times></times>
          <ci>H</ci>
          <ci>X</ci>
         </apply>
         <ci>ε</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>p</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>n</ci>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>H</ci>
          <ci>X</ci>
         </apply>
         <ci>ε</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{-n(H(X)+\varepsilon)}\leq p(X_{1}^{n})\leq 2^{-n(H(X)-\varepsilon)}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Noisy-channel_coding_theorem:12">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>n</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>H</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>Y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mi>ε</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msup>
   <mo>≤</mo>
   <mrow>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>Y</mi>
      <mn>1</mn>
      <mi>n</mi>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>n</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>H</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>Y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mi>ε</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>n</ci>
        <apply>
         <plus></plus>
         <apply>
          <times></times>
          <ci>H</ci>
          <ci>Y</ci>
         </apply>
         <ci>ε</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>p</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <apply>
       <minus></minus>
       <apply>
        <times></times>
        <ci>n</ci>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <ci>H</ci>
          <ci>Y</ci>
         </apply>
         <ci>ε</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{-n(H(Y)+\varepsilon)}\leq p(Y_{1}^{n})\leq 2^{-n(H(Y)-\varepsilon)}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Noisy-channel_coding_theorem:13">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>n</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>H</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>X</mi>
          <mo>,</mo>
          <mi>Y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mi>ε</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msup>
   <mo>≤</mo>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>X</mi>
     <mn>1</mn>
     <mi>n</mi>
    </msubsup>
    <mo>,</mo>
    <msubsup>
     <mi>Y</mi>
     <mn>1</mn>
     <mi>n</mi>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≤</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>n</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>H</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>X</mi>
          <mo>,</mo>
          <mi>Y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mi>ε</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msup>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>n</ci>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>H</ci>
         <interval closure="open">
          <ci>X</ci>
          <ci>Y</ci>
         </interval>
        </apply>
        <ci>ε</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <leq></leq>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>X</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>n</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>n</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>H</ci>
         <interval closure="open">
          <ci>X</ci>
          <ci>Y</ci>
         </interval>
        </apply>
        <ci>ε</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <ci>normal-}</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {2^{-n(H(X,Y)+\varepsilon)}}\leq p(X_{1}^{n},Y_{1}^{n})\leq 2^{-n(H(X,Y)-%
\varepsilon)}\}
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>

<p>We say that two sequences 

<math display="inline" id="Noisy-channel_coding_theorem:14">
 <semantics>
  <msubsup>
   <mi>X</mi>
   <mn>1</mn>
   <mi>n</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>X</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {X_{1}^{n}}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Noisy-channel_coding_theorem:15">
 <semantics>
  <msubsup>
   <mi>Y</mi>
   <mn>1</mn>
   <mi>n</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Y</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{1}^{n}
  </annotation>
 </semantics>
</math>

 are <em>jointly typical</em> if they lie in the jointly typical set defined above.</p>

<p><strong>Steps</strong></p>
<ol>
<li>In the style of the random coding argument, we randomly generate 

<math display="inline" id="Noisy-channel_coding_theorem:16">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi>n</mi>
    <mi>R</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{nR}
  </annotation>
 </semantics>
</math>

 codewords of length n from a probability distribution Q.</li>
<li>This code is revealed to the sender and receiver. It is also assumed that one knows the transition matrix 

<math display="inline" id="Noisy-channel_coding_theorem:17">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p(y|x)
  </annotation>
 </semantics>
</math>

 for the channel being used.</li>
<li>A message W is chosen according to the uniform distribution on the set of codewords. That is, 

<math display="inline" id="Noisy-channel_coding_theorem:18">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>r</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>W</mi>
    <mo>=</mo>
    <mi>w</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>n</mi>
      <mi>R</mi>
     </mrow>
    </mrow>
   </msup>
   <mo>,</mo>
   <mi>w</mi>
   <mo>=</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>n</mi>
     <mi>R</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">r</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">W</csymbol>
     <eq></eq>
     <csymbol cd="unknown">w</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>R</ci>
      </apply>
     </apply>
    </apply>
    <ci>normal-,</ci>
    <csymbol cd="unknown">w</csymbol>
    <eq></eq>
    <cn type="integer">1</cn>
    <ci>normal-,</ci>
    <cn type="integer">2</cn>
    <ci>normal-,</ci>
    <ci>normal-…</ci>
    <ci>normal-,</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>R</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Pr(W=w)=2^{-nR},w=1,2,\dots,2^{nR}
  </annotation>
 </semantics>
</math>

.</li>
<li>The message W is sent across the channel.</li>
<li>The receiver receives a sequence according to 

<math display="inline" id="Noisy-channel_coding_theorem:19">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>y</mi>
     <mi>n</mi>
    </msup>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>x</mi>
     <mi>n</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <msubsup>
    <mo largeop="true" symmetric="true">∏</mo>
    <mrow>
     <mi>i</mi>
     <mo>=</mo>
     <mn>1</mn>
    </mrow>
    <mi>n</mi>
   </msubsup>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>y</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">|</mo>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">w</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">product</csymbol>
      <apply>
       <eq></eq>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>n</ci>
    </apply>
    <csymbol cd="unknown">p</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>i</ci>
     </apply>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">w</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(y^{n}|x^{n}(w))=\prod_{i=1}^{n}p(y_{i}|x_{i}(w))
  </annotation>
 </semantics>
</math>

</li>
<li>Sending these codewords across the channel, we receive 

<math display="inline" id="Noisy-channel_coding_theorem:20">
 <semantics>
  <msubsup>
   <mi>Y</mi>
   <mn>1</mn>
   <mi>n</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Y</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{1}^{n}
  </annotation>
 </semantics>
</math>

, and decode to some source sequence if there exists exactly 1 codeword that is jointly typical with Y. If there are no jointly typical codewords, or if there are more than one, an error is declared. An error also occurs if a decoded codeword doesn't match the original codeword. This is called <em>typical set decoding</em>.</li>
</ol>

<p>The probability of error of this scheme is divided into two parts:</p>
<ol>
<li>First, error can occur if no jointly typical X sequences are found for a received Y sequence</li>
<li>Second, error can occur if an incorrect X sequence is jointly typical with a received Y sequence.</li>
</ol>
<ul>
<li>By the randomness of the code construction, we can assume that the average probability of error averaged over all codes does not depend on the index sent. Thus, without loss of generality, we can assume <em>W</em> = 1.</li>
</ul>
<ul>
<li>From the joint AEP, we know that the probability that no jointly typical X exists goes to 0 as n grows large. We can bound this error probability by 

<math display="inline" id="Noisy-channel_coding_theorem:21">
 <semantics>
  <mi>ε</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ε</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varepsilon
  </annotation>
 </semantics>
</math>

.</li>
</ul>
<ul>
<li>Also from the joint AEP, we know the probability that a particular 

<math display="inline" id="Noisy-channel_coding_theorem:22">
 <semantics>
  <mrow>
   <msubsup>
    <mi>X</mi>
    <mn>1</mn>
    <mi>n</mi>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>X</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>n</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X_{1}^{n}(i)
  </annotation>
 </semantics>
</math>

 and the 

<math display="inline" id="Noisy-channel_coding_theorem:23">
 <semantics>
  <msubsup>
   <mi>Y</mi>
   <mn>1</mn>
   <mi>n</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Y</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y_{1}^{n}
  </annotation>
 </semantics>
</math>

 resulting from <em>W</em> = 1 are jointly typical is 

<math display="inline" id="Noisy-channel_coding_theorem:24">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>≤</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mi>n</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>I</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>X</mi>
          <mo>;</mo>
          <mi>Y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>-</mo>
        <mrow>
         <mn>3</mn>
         <mi>ε</mi>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <ci>n</ci>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>I</ci>
         <list>
          <ci>X</ci>
          <ci>Y</ci>
         </list>
        </apply>
        <apply>
         <times></times>
         <cn type="integer">3</cn>
         <ci>ε</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq 2^{-n(I(X;Y)-3\varepsilon)}
  </annotation>
 </semantics>
</math>

.</li>
</ul>

<p>Define

<math display="block" id="Noisy-channel_coding_theorem:25">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msubsup>
      <mi>X</mi>
      <mn>1</mn>
      <mi>n</mi>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>i</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>,</mo>
     <msubsup>
      <mi>Y</mi>
      <mn>1</mn>
      <mi>n</mi>
     </msubsup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∈</mo>
    <msubsup>
     <mi>A</mi>
     <mi>ε</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mo stretchy="false">}</mo>
   </mrow>
   <mo>,</mo>
   <mi>i</mi>
   <mo>=</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>n</mi>
     <mi>R</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>i</ci>
    </apply>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-{</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>X</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>n</ci>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">i</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>Y</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>n</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <in></in>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>A</ci>
       <ci>ε</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <ci>normal-}</ci>
    </cerror>
    <ci>normal-,</ci>
    <csymbol cd="unknown">i</csymbol>
    <eq></eq>
    <cn type="integer">1</cn>
    <ci>normal-,</ci>
    <cn type="integer">2</cn>
    <ci>normal-,</ci>
    <ci>normal-…</ci>
    <ci>normal-,</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>R</ci>
     </apply>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{i}=\{(X_{1}^{n}(i),Y_{1}^{n})\in A_{\varepsilon}^{(n)}\},i=1,2,\dots,2^{nR}
  </annotation>
 </semantics>
</math>

</p>

<p>as the event that message i is jointly typical with the sequence received when message 1 is sent.</p>

<p>

<math display="inline" id="Noisy-channel_coding_theorem:26">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mtext>error</mtext>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <mtext>error</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle P(\text{error})
  </annotation>
 </semantics>
</math>


</p>

<p>We can observe that as 

<math display="inline" id="Noisy-channel_coding_theorem:27">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 goes to infinity, if 

<math display="inline" id="Noisy-channel_coding_theorem:28">
 <semantics>
  <mrow>
   <mi>R</mi>
   <mo><</mo>
   <mrow>
    <mi>I</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>X</mi>
     <mo>;</mo>
     <mi>Y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <ci>R</ci>
    <apply>
     <times></times>
     <ci>I</ci>
     <list>
      <ci>X</ci>
      <ci>Y</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R<I(X;Y)
  </annotation>
 </semantics>
</math>

 for the channel, the probability of error will go to 0.</p>

<p>Finally, given that the average codebook is shown to be "good," we know that there exists a codebook whose performance is better than the average, and so satisfies our need for arbitrarily low error probability communicating across the noisy channel.</p>
<h3 id="weak-converse-for-discrete-memoryless-channels">Weak converse for discrete memoryless channels</h3>

<p>Suppose a code of 

<math display="inline" id="Noisy-channel_coding_theorem:29">
 <semantics>
  <msup>
   <mn>2</mn>
   <mrow>
    <mi>n</mi>
    <mi>R</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{nR}
  </annotation>
 </semantics>
</math>

 codewords. Let W be drawn uniformly over this set as an index. Let 

<math display="inline" id="Noisy-channel_coding_theorem:30">
 <semantics>
  <msup>
   <mi>X</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>X</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X^{n}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Noisy-channel_coding_theorem:31">
 <semantics>
  <msup>
   <mi>Y</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>Y</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y^{n}
  </annotation>
 </semantics>
</math>

 be the codewords and received codewords, respectively.</p>
<ol>
<li>

<math display="inline" id="Noisy-channel_coding_theorem:32">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mi>R</mi>
   <mo>=</mo>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>W</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>W</mi>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>Y</mi>
     <mi>n</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>W</mi>
    <mo>;</mo>
    <msup>
     <mi>Y</mi>
     <mi>n</mi>
    </msup>
    <mo rspace="5.3pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">n</csymbol>
    <csymbol cd="unknown">R</csymbol>
    <eq></eq>
    <csymbol cd="unknown">H</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">W</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">H</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">W</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Y</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <csymbol cd="unknown">I</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">W</csymbol>
     <ci>normal-;</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Y</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   nR=H(W)=H(W|Y^{n})+I(W;Y^{n})\;
  </annotation>
 </semantics>
</math>

 using identities involving entropy and mutual information</li>
<li>

<math display="inline" id="Noisy-channel_coding_theorem:33">
 <semantics>
  <mrow>
   <mo>≤</mo>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>W</mi>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>Y</mi>
     <mi>n</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>+</mo>
   <mi>I</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>X</mi>
     <mi>n</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>W</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>;</mo>
    <msup>
     <mi>Y</mi>
     <mi>n</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <leq></leq>
    <csymbol cd="unknown">H</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">W</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Y</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <plus></plus>
    <csymbol cd="unknown">I</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>X</ci>
      <ci>n</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">W</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-;</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Y</ci>
      <ci>n</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq H(W|Y^{n})+I(X^{n}(W);Y^{n})
  </annotation>
 </semantics>
</math>

 since X is a function of W</li>
<li>

<math display="inline" id="Noisy-channel_coding_theorem:34">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>≤</mo>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mi>P</mi>
      <mi>e</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mi>n</mi>
     <mi>R</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>I</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msup>
        <mi>X</mi>
        <mi>n</mi>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>W</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>;</mo>
      <msup>
       <mi>Y</mi>
       <mi>n</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <ci>e</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <ci>n</ci>
      <ci>R</ci>
     </apply>
     <apply>
      <times></times>
      <ci>I</ci>
      <list>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>X</ci>
         <ci>n</ci>
        </apply>
        <ci>W</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>Y</ci>
        <ci>n</ci>
       </apply>
      </list>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq 1+P_{e}^{(n)}nR+I(X^{n}(W);Y^{n})
  </annotation>
 </semantics>
</math>

 by the use of <a href="Fano's_Inequality" title="wikilink">Fano's Inequality</a></li>
<li>

<math display="inline" id="Noisy-channel_coding_theorem:35">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>≤</mo>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mrow>
     <msubsup>
      <mi>P</mi>
      <mi>e</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
     <mi>n</mi>
     <mi>R</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>n</mi>
     <mi>C</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <ci>e</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <ci>n</ci>
      <ci>R</ci>
     </apply>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>C</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leq 1+P_{e}^{(n)}nR+nC
  </annotation>
 </semantics>
</math>

 by the fact that capacity is maximized mutual information.</li>
</ol>

<p>The result of these steps is that 

<math display="inline" id="Noisy-channel_coding_theorem:36">
 <semantics>
  <mrow>
   <msubsup>
    <mi>P</mi>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo>≥</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mi>n</mi>
      <mi>R</mi>
     </mrow>
    </mfrac>
    <mo>-</mo>
    <mfrac>
     <mi>C</mi>
     <mi>R</mi>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>e</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>R</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <ci>C</ci>
      <ci>R</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{e}^{(n)}\geq 1-\frac{1}{nR}-\frac{C}{R}
  </annotation>
 </semantics>
</math>

. As the block length 

<math display="inline" id="Noisy-channel_coding_theorem:37">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 goes to infinity, we obtain 

<math display="inline" id="Noisy-channel_coding_theorem:38">
 <semantics>
  <msubsup>
   <mi>P</mi>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>e</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{e}^{(n)}
  </annotation>
 </semantics>
</math>

 is bounded away from 0 if R is greater than C - we can get arbitrarily low rates of error only if R is less than C.</p>
<h3 id="strong-converse-for-discrete-memoryless-channels">Strong converse for discrete memoryless channels</h3>

<p>A strong converse theorem, proven by Wolfowitz in 1957,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> states that,</p>

<p>

<math display="block" id="Noisy-channel_coding_theorem:39">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>e</mi>
   </msub>
   <mo>≥</mo>
   <mrow>
    <mn>1</mn>
    <mo>-</mo>
    <mfrac>
     <mrow>
      <mn>4</mn>
      <mi>A</mi>
     </mrow>
     <mrow>
      <mi>n</mi>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>R</mi>
         <mo>-</mo>
         <mi>C</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
    </mfrac>
    <mo>-</mo>
    <msup>
     <mi>e</mi>
     <mrow>
      <mo>-</mo>
      <mfrac>
       <mrow>
        <mi>n</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>R</mi>
          <mo>-</mo>
          <mi>C</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mn>2</mn>
      </mfrac>
     </mrow>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>e</ci>
    </apply>
    <apply>
     <minus></minus>
     <cn type="integer">1</cn>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <cn type="integer">4</cn>
       <ci>A</ci>
      </apply>
      <apply>
       <times></times>
       <ci>n</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <ci>R</ci>
         <ci>C</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>e</ci>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <ci>n</ci>
         <apply>
          <minus></minus>
          <ci>R</ci>
          <ci>C</ci>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{e}\geq 1-\frac{4A}{n(R-C)^{2}}-e^{-\frac{n(R-C)}{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>for some finite positive constant 

<math display="inline" id="Noisy-channel_coding_theorem:40">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

. While the weak converse states that the error probability is bounded away from zero as 

<math display="inline" id="Noisy-channel_coding_theorem:41">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 goes to infinity, the strong converse states that the error goes to 1. Thus, 

<math display="inline" id="Noisy-channel_coding_theorem:42">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is a sharp threshold between perfectly reliable and completely unreliable communication.</p>
<h2 id="channel-coding-theorem-for-non-stationary-memoryless-channels">Channel coding theorem for non-stationary memoryless channels</h2>

<p>We assume that the channel is memoryless, but its transition probabilities change with time, in a fashion known at the transmitter as well as the receiver.</p>

<p>Then the channel capacity is given by</p>

<p>

<math display="block" id="Noisy-channel_coding_theorem:43">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mo>=</mo>
    <mrow>
     <mo movablelimits="false">lim</mo>
     <mrow>
      <mo movablelimits="false">inf</mo>
      <mrow>
       <mrow>
        <munder>
         <mi>max</mi>
         <mrow>
          <mrow>
           <msup>
            <mi>p</mi>
            <mo stretchy="false">(</mo>
           </msup>
           <msub>
            <mi>X</mi>
            <mn>1</mn>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
          <mo>,</mo>
          <msup>
           <mi>p</mi>
           <mo stretchy="false">(</mo>
          </msup>
          <msub>
           <mi>X</mi>
           <mn>2</mn>
          </msub>
          <mo stretchy="false">)</mo>
          <mo>,</mo>
          <mi mathvariant="normal">…</mi>
         </mrow>
        </munder>
        <mfrac>
         <mn>1</mn>
         <mi>n</mi>
        </mfrac>
       </mrow>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>n</mi>
        </munderover>
        <mrow>
         <mi>I</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <msub>
           <mi>X</mi>
           <mi>i</mi>
          </msub>
          <mo>;</mo>
          <msub>
           <mi>Y</mi>
           <mi>i</mi>
          </msub>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <limit></limit>
     <apply>
      <csymbol cd="latexml">infimum</csymbol>
      <apply>
       <times></times>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <max></max>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <cerror>
           <csymbol cd="ambiguous">fragments</csymbol>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>p</ci>
            <ci>normal-(</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>X</ci>
            <cn type="integer">1</cn>
           </apply>
           <ci>normal-)</ci>
          </cerror>
          <ci>normal-,</ci>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>p</ci>
           <ci>normal-(</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>X</ci>
           <cn type="integer">2</cn>
          </apply>
          <ci>normal-)</ci>
          <ci>normal-,</ci>
          <ci>normal-…</ci>
         </cerror>
        </apply>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <ci>n</ci>
        </apply>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>n</ci>
        </apply>
        <apply>
         <times></times>
         <ci>I</ci>
         <list>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>X</ci>
           <ci>i</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>Y</ci>
           <ci>i</ci>
          </apply>
         </list>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=\lim\inf\max_{p^{(}X_{1}),p^{(}X_{2}),...}\frac{1}{n}\sum_{i=1}^{n}I(X_{i};Y%
_{i}).
  </annotation>
 </semantics>
</math>

</p>

<p>The maximum is attained at the capacity achieving distributions for each respective channel. That is, 

<math display="inline" id="Noisy-channel_coding_theorem:44">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mo>lim</mo>
    <mrow>
     <mo>inf</mo>
     <mrow>
      <mfrac>
       <mn>1</mn>
       <mi>n</mi>
      </mfrac>
      <mrow>
       <msubsup>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>n</mi>
       </msubsup>
       <msub>
        <mi>C</mi>
        <mi>i</mi>
       </msub>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <limit></limit>
     <apply>
      <csymbol cd="latexml">infimum</csymbol>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <ci>n</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>C</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=\lim\inf\frac{1}{n}\sum_{i=1}^{n}C_{i}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Noisy-channel_coding_theorem:45">
 <semantics>
  <msub>
   <mi>C</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>C</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{i}
  </annotation>
 </semantics>
</math>

 is the capacity of the i<em>th</em> channel.</p>
<h3 id="outline-of-the-proof">Outline of the proof</h3>

<p>The proof runs through in almost the same way as that of channel coding theorem. Achievability follows from random coding with each symbol chosen randomly from the capacity achieving distribution for that particular channel. Typicality arguments use the definition of typical sets for non-stationary sources defined in the <a href="asymptotic_equipartition_property" title="wikilink">asymptotic equipartition property</a> article.</p>

<p>The technicality of <a href="lim_inf" title="wikilink">lim inf</a> comes into play when 

<math display="inline" id="Noisy-channel_coding_theorem:46">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <mi>n</mi>
   </mfrac>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>n</mi>
    </msubsup>
    <msub>
     <mi>C</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <ci>n</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{n}\sum_{i=1}^{n}C_{i}
  </annotation>
 </semantics>
</math>

 does not converge.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Asymptotic_equipartition_property" title="wikilink">Asymptotic equipartition property</a> (AEP)</li>
<li><a href="Fano's_Inequality" title="wikilink">Fano's Inequality</a></li>
<li><a href="Rate–distortion_theory" title="wikilink">Rate–distortion theory</a></li>
<li><a href="Shannon's_source_coding_theorem" title="wikilink">Shannon's source coding theorem</a></li>
<li><a href="Shannon–Hartley_theorem" title="wikilink">Shannon–Hartley theorem</a></li>
<li><a href="Turbo_code" title="wikilink">Turbo code</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li><a href="Thomas_M._Cover" title="wikilink">Cover T. M.</a>, Thomas J. A., <em>Elements of Information Theory</em>, <a href="John_Wiley_&amp;_Sons" title="wikilink">John Wiley &amp; Sons</a>, 1991. ISBN 0-471-06259-6</li>
<li><a href="Fano" title="wikilink">Fano, R. A.</a>, <em>Transmission of information; a statistical theory of communications</em>, <a href="MIT_Press" title="wikilink">MIT Press</a>, 1961. ISBN 0-262-06001-9</li>
<li><a href="Amiel_Feinstein" title="wikilink">Feinstein, Amiel</a>, "A New basic theorem of information theory", <em><a href="IEEE_Transactions_on_Information_Theory" title="wikilink">IEEE Transactions on Information Theory</a></em>, 4(4): 2-22, 1954.</li>
<li><a href="MacKay" title="wikilink">MacKay, D. J. C.</a>, <em><a href="http://www.inference.phy.cam.ac.uk/mackay/itila/book.html">Information Theory, Inference, and Learning Algorithms</a></em>, <a href="Cambridge_University_Press" title="wikilink">Cambridge University Press</a>, 2003. ISBN 0-521-64298-1 [free online]</li>
<li><a href="Claude_E._Shannon" title="wikilink">Shannon, C. E.</a>, <a href="http://cm.bell-labs.com/cm/ms/what/shannonday/paper.html"><em>A Mathematical Theory of Communication</em></a> Urbana, IL: University of Illinois Press, 1949 (reprinted 1998).</li>
<li><a href="Wolfowitz" title="wikilink"> Wolfowitz, J.</a>, "The coding of messages subject to chance errors", <em>Illinois J. Math.</em>, 1: 591–606, 1957.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.iet.ntnu.no/projects/beats/Documents/LarsTelektronikk02.pdf">On Shannon and Shannon's law</a></li>
<li><a href="http://cnx.org/content/m10180/latest/">Shannon's Noisy Channel Coding Theorem</a></li>
</ul>

<p>"</p>

<p><a href="Category:Information_theory" title="wikilink">Category:Information theory</a> <a href="Category:Theorems_in_discrete_mathematics" title="wikilink">Category:Theorems in discrete mathematics</a> <a href="Category:Telecommunication_theory" title="wikilink">Category:Telecommunication theory</a> <a href="Category:Coding_theory" title="wikilink">Category:Coding theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="Sae-Young_Chung" title="wikilink">Sae-Young Chung</a>, <a href="G._David_Forney,_Jr." title="wikilink">G. David Forney, Jr.</a>, <a href="Thomas_J._Richardson" title="wikilink">Thomas J. Richardson</a>, and <a href="Rüdiger_Urbanke" title="wikilink">Rüdiger Urbanke</a>, "<a href="http://www.josephboutros.org/ldpc_vs_turbo/ldpc_Chung_CLfeb01.pdf">On the Design of Low-Density Parity-Check Codes within 0.0045 dB of the Shannon Limit</a>", <em><a href="IEEE_Communications_Letters" title="wikilink">IEEE Communications Letters</a></em>, 5: 58-60, Feb. 2001. ISSN 1089-7798<a href="#fnref1">↩</a></li>
<li id="fn2">For a description of the "sup" function, see <a class="uri" href="Supremum" title="wikilink">Supremum</a><a href="#fnref2">↩</a></li>
<li id="fn3">Robert Gallager. <em>Information Theory and Reliable Communication.</em> New York: <a href="John_Wiley_&amp;_Sons" title="wikilink">John Wiley &amp; Sons</a>, 1968. ISBN 0-471-29048-3<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
