<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1280">Yale shooting problem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Yale shooting problem</h1>
<hr/>

<p>The <strong>Yale shooting problem</strong> is a conundrum or scenario in formal situational <a class="uri" href="logic" title="wikilink">logic</a> on which early logical solutions to the <a href="frame_problem" title="wikilink">frame problem</a> fail. The name of this problem derives from its inventors, <a href="Steve_Hanks" title="wikilink">Steve Hanks</a> and <a href="Drew_McDermott" title="wikilink">Drew McDermott</a>, working at <a href="Yale_University" title="wikilink">Yale University</a> when they proposed it. In this scenario, Fred (later identified as a <a href="turkey_(bird)" title="wikilink">turkey</a>) is initially alive and a gun is initially unloaded. Loading the gun, waiting for a moment, and then shooting the gun at Fred is expected to kill Fred. However, if <a class="uri" href="inertia" title="wikilink">inertia</a> is formalized in logic by minimizing the changes in this situation, then it cannot be uniquely proved that Fred is dead after loading, waiting, and shooting. In one solution, Fred indeed dies; in another (also logically correct) solution, the gun becomes mysteriously unloaded and Fred survives.</p>

<p>Technically, this scenario is described by two <a href="fluent_(artificial_intelligence)" title="wikilink">fluents</a> (a fluent is a condition that can change <a href="truth_value" title="wikilink">truth value</a> over time)

<math display="block" id="Yale_shooting_problem:0">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi>l</mi>
   <mi>i</mi>
   <mi>v</mi>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>l</ci>
    <ci>i</ci>
    <ci>v</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   alive
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Yale_shooting_problem:1">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mi>o</mi>
   <mi>a</mi>
   <mi>d</mi>
   <mi>e</mi>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <ci>o</ci>
    <ci>a</ci>
    <ci>d</ci>
    <ci>e</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   loaded
  </annotation>
 </semantics>
</math>

. Initially, the first condition is true and the second is false. Then, the gun is loaded, some time passes, and the gun is fired. Such problems can be formalized in logic by considering four time points 

<math display="inline" id="Yale_shooting_problem:2">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

, 

<math display="inline" id="Yale_shooting_problem:3">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Yale_shooting_problem:4">
 <semantics>
  <mn>2</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">2</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Yale_shooting_problem:5">
 <semantics>
  <mn>3</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">3</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3
  </annotation>
 </semantics>
</math>

, and turning every fluent such as 

<math display="inline" id="Yale_shooting_problem:6">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi>l</mi>
   <mi>i</mi>
   <mi>v</mi>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>l</ci>
    <ci>i</ci>
    <ci>v</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   alive
  </annotation>
 </semantics>
</math>

 into a predicate 

<math display="inline" id="Yale_shooting_problem:7">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi>l</mi>
   <mi>i</mi>
   <mi>v</mi>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>l</ci>
    <ci>i</ci>
    <ci>v</ci>
    <ci>e</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   alive(t)
  </annotation>
 </semantics>
</math>

 depending on time. A direct formalization of the statement of the Yale shooting problem in logic is the following one:</p>

<p>

<math display="block" id="Yale_shooting_problem:8">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi>l</mi>
   <mi>i</mi>
   <mi>v</mi>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>l</ci>
    <ci>i</ci>
    <ci>v</ci>
    <ci>e</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   alive(0)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Yale_shooting_problem:9">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>l</mi>
   <mi>o</mi>
   <mi>a</mi>
   <mi>d</mi>
   <mi>e</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>l</ci>
    <ci>o</ci>
    <ci>a</ci>
    <ci>d</ci>
    <ci>e</ci>
    <ci>d</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg loaded(0)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Yale_shooting_problem:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mi>r</mi>
    <mi>u</mi>
    <mi>e</mi>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>l</mi>
    <mi>o</mi>
    <mi>a</mi>
    <mi>d</mi>
    <mi>e</mi>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>r</ci>
     <ci>u</ci>
     <ci>e</ci>
    </apply>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <ci>a</ci>
     <ci>d</ci>
     <ci>e</ci>
     <ci>d</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   true\rightarrow loaded(1)
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Yale_shooting_problem:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>l</mi>
    <mi>o</mi>
    <mi>a</mi>
    <mi>d</mi>
    <mi>e</mi>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>2</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>a</mi>
    <mi>l</mi>
    <mi>i</mi>
    <mi>v</mi>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>3</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <ci>a</ci>
     <ci>d</ci>
     <ci>e</ci>
     <ci>d</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>a</ci>
     <ci>l</ci>
     <ci>i</ci>
     <ci>v</ci>
     <ci>e</ci>
     <cn type="integer">3</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   loaded(2)\rightarrow\neg alive(3)
  </annotation>
 </semantics>
</math>

</p>

<p>The first two formulae represent the initial state. The third formula formalizes the effect of loading the gun at time 

<math display="inline" id="Yale_shooting_problem:12">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

. The fourth formula formalizes the effect of shooting at Fred at time 

<math display="inline" id="Yale_shooting_problem:13">
 <semantics>
  <mn>2</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">2</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2
  </annotation>
 </semantics>
</math>

. This is a simplified formalization in which action names are neglected and the effects of actions are directly specified for the time points in which the actions are executed. See <a href="situation_calculus" title="wikilink">situation calculus</a> for details.</p>

<p>The formulae above, while being direct formalizations of the known facts, do not suffice to correctly characterize the domain. Indeed, 

<math display="inline" id="Yale_shooting_problem:14">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>a</mi>
   <mi>l</mi>
   <mi>i</mi>
   <mi>v</mi>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>a</ci>
    <ci>l</ci>
    <ci>i</ci>
    <ci>v</ci>
    <ci>e</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg alive(1)
  </annotation>
 </semantics>
</math>

 is consistent with all these formulae, although there is no reason to believe that Fred dies before the gun has been shot. The problem is that the formulae above only include the effects of actions, but do not specify that all fluents not changed by the actions remain the same. In other words, a formula 

<math display="inline" id="Yale_shooting_problem:15">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mi>l</mi>
    <mi>i</mi>
    <mi>v</mi>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mi>a</mi>
    <mi>l</mi>
    <mi>i</mi>
    <mi>v</mi>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>l</ci>
     <ci>i</ci>
     <ci>v</ci>
     <ci>e</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <times></times>
     <ci>a</ci>
     <ci>l</ci>
     <ci>i</ci>
     <ci>v</ci>
     <ci>e</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   alive(0)\equiv alive(1)
  </annotation>
 </semantics>
</math>

 must be added to formalize the implicit assumption that loading the gun <em>only</em> changes the value of 

<math display="inline" id="Yale_shooting_problem:16">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mi>o</mi>
   <mi>a</mi>
   <mi>d</mi>
   <mi>e</mi>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <ci>o</ci>
    <ci>a</ci>
    <ci>d</ci>
    <ci>e</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   loaded
  </annotation>
 </semantics>
</math>

 and not the value of 

<math display="inline" id="Yale_shooting_problem:17">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi>l</mi>
   <mi>i</mi>
   <mi>v</mi>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>l</ci>
    <ci>i</ci>
    <ci>v</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   alive
  </annotation>
 </semantics>
</math>

. The necessity of a large number of formulae stating the obvious fact that conditions do not change unless an action changes them is known as the <a href="frame_problem" title="wikilink">frame problem</a>.</p>

<p>An early solution to the frame problem was based on minimizing the changes. In other words, the scenario is formalized by the formulae above (that specify only the effects of actions) and by the assumption that the changes in the fluents over time are as minimal as possible. The rationale is that the formulae above enforce all effect of actions to take place, while minimization should restrict the changes to exactly those due to the actions.</p>

<p>In the Yale shooting scenario, one possible evaluation of the fluents in which the changes are minimized is the following one.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Yale_shooting_problem:18">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi>l</mi>
   <mi>i</mi>
   <mi>v</mi>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>l</ci>
    <ci>i</ci>
    <ci>v</ci>
    <ci>e</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   alive(0)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Yale_shooting_problem:19">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi>l</mi>
   <mi>i</mi>
   <mi>v</mi>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>l</ci>
    <ci>i</ci>
    <ci>v</ci>
    <ci>e</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   alive(1)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Yale_shooting_problem:20">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi>l</mi>
   <mi>i</mi>
   <mi>v</mi>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>l</ci>
    <ci>i</ci>
    <ci>v</ci>
    <ci>e</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   alive(2)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Yale_shooting_problem:21">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>a</mi>
   <mi>l</mi>
   <mi>i</mi>
   <mi>v</mi>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>3</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>a</ci>
    <ci>l</ci>
    <ci>i</ci>
    <ci>v</ci>
    <ci>e</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg alive(3)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Yale_shooting_problem:22">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>l</mi>
   <mi>o</mi>
   <mi>a</mi>
   <mi>d</mi>
   <mi>e</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>l</ci>
    <ci>o</ci>
    <ci>a</ci>
    <ci>d</ci>
    <ci>e</ci>
    <ci>d</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg loaded(0)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Yale_shooting_problem:23">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mi>o</mi>
   <mi>a</mi>
   <mi>d</mi>
   <mi>e</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <ci>o</ci>
    <ci>a</ci>
    <ci>d</ci>
    <ci>e</ci>
    <ci>d</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   loaded(1)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Yale_shooting_problem:24">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mi>o</mi>
   <mi>a</mi>
   <mi>d</mi>
   <mi>e</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <ci>o</ci>
    <ci>a</ci>
    <ci>d</ci>
    <ci>e</ci>
    <ci>d</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   loaded(2)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Yale_shooting_problem:25">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mi>o</mi>
   <mi>a</mi>
   <mi>d</mi>
   <mi>e</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>3</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <ci>o</ci>
    <ci>a</ci>
    <ci>d</ci>
    <ci>e</ci>
    <ci>d</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   loaded(3)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>This is the expected solution. It contains two fluent changes

<math display="block" id="Yale_shooting_problem:26">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mi>o</mi>
   <mi>a</mi>
   <mi>d</mi>
   <mi>e</mi>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <ci>o</ci>
    <ci>a</ci>
    <ci>d</ci>
    <ci>e</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   loaded
  </annotation>
 </semantics>
</math>

 becomes true at time 1 and 

<math display="inline" id="Yale_shooting_problem:27">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi>l</mi>
   <mi>i</mi>
   <mi>v</mi>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>l</ci>
    <ci>i</ci>
    <ci>v</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   alive
  </annotation>
 </semantics>
</math>

 becomes false at time 3. The following evaluation also satisfies all formulae above.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Yale_shooting_problem:28">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi>l</mi>
   <mi>i</mi>
   <mi>v</mi>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>l</ci>
    <ci>i</ci>
    <ci>v</ci>
    <ci>e</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   alive(0)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Yale_shooting_problem:29">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi>l</mi>
   <mi>i</mi>
   <mi>v</mi>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>l</ci>
    <ci>i</ci>
    <ci>v</ci>
    <ci>e</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   alive(1)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Yale_shooting_problem:30">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi>l</mi>
   <mi>i</mi>
   <mi>v</mi>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>l</ci>
    <ci>i</ci>
    <ci>v</ci>
    <ci>e</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   alive(2)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Yale_shooting_problem:31">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi>l</mi>
   <mi>i</mi>
   <mi>v</mi>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>3</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>l</ci>
    <ci>i</ci>
    <ci>v</ci>
    <ci>e</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   alive(3)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Yale_shooting_problem:32">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>l</mi>
   <mi>o</mi>
   <mi>a</mi>
   <mi>d</mi>
   <mi>e</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>l</ci>
    <ci>o</ci>
    <ci>a</ci>
    <ci>d</ci>
    <ci>e</ci>
    <ci>d</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg loaded(0)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Yale_shooting_problem:33">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mi>o</mi>
   <mi>a</mi>
   <mi>d</mi>
   <mi>e</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <ci>o</ci>
    <ci>a</ci>
    <ci>d</ci>
    <ci>e</ci>
    <ci>d</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   loaded(1)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Yale_shooting_problem:34">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>l</mi>
   <mi>o</mi>
   <mi>a</mi>
   <mi>d</mi>
   <mi>e</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>l</ci>
    <ci>o</ci>
    <ci>a</ci>
    <ci>d</ci>
    <ci>e</ci>
    <ci>d</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg loaded(2)
  </annotation>
 </semantics>
</math>

</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Yale_shooting_problem:35">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>l</mi>
   <mi>o</mi>
   <mi>a</mi>
   <mi>d</mi>
   <mi>e</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>3</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>l</ci>
    <ci>o</ci>
    <ci>a</ci>
    <ci>d</ci>
    <ci>e</ci>
    <ci>d</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg loaded(3)
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
</tbody>
</table>

<p>In this evaluation, there are still two changes only

<math display="block" id="Yale_shooting_problem:36">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mi>o</mi>
   <mi>a</mi>
   <mi>d</mi>
   <mi>e</mi>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <ci>o</ci>
    <ci>a</ci>
    <ci>d</ci>
    <ci>e</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   loaded
  </annotation>
 </semantics>
</math>

 becomes true at time 1 and false at time 2. As a result, this evaluation is considered a valid description of the evolution of the state, although there is no valid reason to explain 

<math display="inline" id="Yale_shooting_problem:37">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mi>o</mi>
   <mi>a</mi>
   <mi>d</mi>
   <mi>e</mi>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <ci>o</ci>
    <ci>a</ci>
    <ci>d</ci>
    <ci>e</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   loaded
  </annotation>
 </semantics>
</math>

 being false at time 2. The fact that minimization of changes leads to wrong solution is the motivation for the introduction of the Yale shooting problem.</p>

<p>While the Yale shooting problem has been considered a severe obstacle to the use of logic for formalizing dynamical scenarios, solutions to it are known since the late 1980s. One solution involves the use of <a href="predicate_completion" title="wikilink">predicate completion</a> in the specification of actions: according to this solution, the fact that shooting causes Fred to die is formalized by the preconditions: <em>alive</em> and <em>loaded</em>, and the effect is that <em>alive</em> changes value (since <em>alive</em> was true before, this corresponds to <em>alive</em> becoming false). By turning this implication into an <em>if and only if</em> statement, the effects of shooting are correctly formalized. (Predicate completion is more complicated when there is more than one implication involved.)</p>

<p>A solution proposed by <a href="Erik_Sandewall" title="wikilink">Erik Sandewall</a> was to include a new condition of occlusion, which formalizes the “permission to change” for a fluent. The effect of an action that might change a fluent is therefore that the fluent has the new value, and that the occlusion is made (temporarily) true. What is minimized is not the set of changes, but the set of occlusions being true. Another constraint specifying that no fluent changes unless occlusion is true completes this solution.</p>

<p>The Yale shooting scenario is also correctly formalized by the <a href="Ray_Reiter" title="wikilink">Reiter</a> version of the <a href="situation_calculus" title="wikilink">situation calculus</a>, the <a href="fluent_calculus" title="wikilink">fluent calculus</a>, and the <a href="action_description_language" title="wikilink">action description languages</a>.</p>

<p>In 2005, the 1985 paper in which the Yale shooting scenario was first described received the <a href="AAAI_Classic_Paper_award" title="wikilink">AAAI Classic Paper award</a>. In spite of being a solved problem, that example is still sometimes mentioned in recent research papers, where it is used as an illustrative example (e.g., for explaining the syntax of a new logic for reasoning about actions), rather than being presented as a problem.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Circumscription_(logic)" title="wikilink">Circumscription (logic)</a></li>
<li><a href="Frame_problem" title="wikilink">Frame problem</a></li>
<li><a href="Situation_calculus" title="wikilink">Situation calculus</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>M. Gelfond and V. Lifschitz (1993). Representing action and change by logic programs. <em>Journal of Logic Programming</em>, 17:301-322.</li>
<li>S. Hanks and D. McDermott (1987). Nonmonotonic logic and temporal projection. <em>Artificial Intelligence</em>, 33(3):379-412.</li>
<li>J. McCarthy (1986). Applications of circumscription to formalizing common-sense knowledge. <em>Artificial Intelligence</em>, 28:89-116.</li>
<li>T. Mitchell and H. Levesque (2006). The 2005 AAAI Classic Paper awards. "AI Magazine", 26(4):98-99.</li>
<li>R. Reiter (1991). The frame problem in the situation calculus: a simple solution (sometimes) and a completeness result for goal regression. In Vladimir Lifschitz, editor, <em>Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy</em>, pages 359-380. Academic Press, New York.</li>
<li>E. Sandewall (1994). <em>Features and Fluents</em>. Oxford University Press.</li>
</ul>

<p>"</p>

<p><a href="Category:Logic_programming" title="wikilink">Category:Logic programming</a> <a href="Category:Knowledge_representation" title="wikilink">Category:Knowledge representation</a></p>
</body>
</html>
