<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="493">Heapsort</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Heapsort</h1>
<hr/>

<p>In <a href="computer_programming" title="wikilink">computer programming</a>, <strong>heapsort</strong> is a <a href="comparison_sort" title="wikilink">comparison-based</a> <a href="sorting_algorithm" title="wikilink">sorting algorithm</a>. Heapsort can be thought of as an improved <a href="selection_sort" title="wikilink">selection sort</a>: like that algorithm, it divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. The improvement consists of the use of a <a href="heap_(data_structure)" title="wikilink">heap</a> data structure rather than a linear-time search to find the maximum.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Although somewhat slower in practice on most machines than a well-implemented <a class="uri" href="quicksort" title="wikilink">quicksort</a>, it has the advantage of a more favorable worst-case <a href="big_O_notation" title="wikilink">O</a>(<em>n</em> log <em>n</em>) runtime. Heapsort is an <a href="in-place_algorithm" title="wikilink">in-place algorithm</a>, but it is not a <a href="stable_sort" title="wikilink">stable sort</a>.</p>

<p>Heapsort was invented by <a href="J._W._J._Williams" title="wikilink">J. W. J. Williams</a> in 1964.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> This was also the birth of the heap, presented already by Williams as a useful data structure in its own right.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> In the same year, <a href="Robert_Floyd" title="wikilink">R. W. Floyd</a> published an improved version that could sort an array in-place, continuing his earlier research into the <a class="uri" href="treesort" title="wikilink">treesort</a> algorithm.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="overview">Overview</h2>

<p>The heapsort algorithm can be divided into two parts.</p>

<p>In the first step, a <a href="Heap_(data_structure)" title="wikilink">heap</a> is <a href="Binary_heap#Building_a_heap" title="wikilink">built</a> out of the data. The heap is often placed in an array with the layout of a complete <a href="Binary_tree#Types_of_binary_trees" title="wikilink">binary tree</a>. The complete binary tree maps the binary tree structure into the array indices; each array index represents a node; the index of the node's parent, left child branch, or right child branch are simple expressions. For a zero-based array, the root node is stored at index 0; if <code>i</code> is the index of the current node, then</p>
<pre><code>  iParent     = floor((i-1) / 2)
  iLeftChild  = 2*i + 1
  iRightChild = 2*i + 2</code></pre>

<p>In the second step, a sorted array is created by repeatedly removing the largest element from the heap (the root of the heap), and inserting it into the array. The heap is updated after each removal to maintain the heap. Once all objects have been removed from the heap, the result is a sorted array.</p>

<p>Heapsort can be performed in place. The array can be split into two parts, the sorted array and the heap. The storage of heaps as arrays is diagrammed <a href="Binary_heap#Heap_implementation" title="wikilink">here</a>. The heap's invariant is preserved after each extraction, so the only cost is that of extraction.</p>
<h3 id="pseudocode">Pseudocode</h3>

<p>The following is a simple way to implement the algorithm in <a class="uri" href="pseudocode" title="wikilink">pseudocode</a>. Arrays are <a href="Comparison_of_programming_languages_(array)" title="wikilink">zero-based</a> and <code>swap</code> is used to exchange two elements of the array. Movement 'down' means from the root towards the leaves, or from lower indices to higher. Note that during the sort, the largest element is at the root of the heap at <code>a[0]</code>, while at the end of the sort, the largest element is in <code>a[end]</code>.</p>

<p><strong><code>procedure</code></strong><code> heapsort(a, count) </code><strong><code>is</code></strong><br/>
<code>    </code><strong><code>input:</code></strong><code> an unordered array </code><em><code>a</code></em><code> of length </code><em><code>count</code></em><br/>
<code> </code><br/>
<code>    </code><em><code>(Build</code> <code>the</code> <code>heap</code> <code>in</code> <code>array</code> <code>a</code> <code>so</code> <code>that</code> <code>largest</code> <code>value</code> <code>is</code> <code>at</code> <code>the</code> <code>root)</code></em><br/>
<code>    heapify(a, count)</code><br/>
<br/>
<code>    </code><em><code>(The</code> <code>following</code> <code>loop</code> <code>maintains</code> <code>the</code> <a href="Loop_invariant" title="wikilink"><code>invariants</code></a> <code>that</code> <code>a[0:end]</code> <code>is</code> <code>a</code> <code>heap</code> <code>and</code> <code>every</code> <code>element</code></em><br/>
<code>     </code><em><code>beyond</code> <code>end</code> <code>is</code> <code>greater</code> <code>than</code> <code>everything</code> <code>before</code> <code>it</code> <code>(so</code> <code>a[end:count]</code> <code>is</code> <code>in</code> <code>sorted</code> <code>order))</code></em><br/>
<code>    end ← count - 1</code><br/>
<code>    </code><strong><code>while</code></strong><code> end &gt; 0 </code><strong><code>do</code></strong><br/>
<code>        </code><em><code>(a[0]</code> <code>is</code> <code>the</code> <code>root</code> <code>and</code> <code>largest</code> <code>value.</code> <code>The</code> <code>swap</code> <code>moves</code> <code>it</code> <code>in</code> <code>front</code> <code>of</code> <code>the</code> <code>sorted</code> <code>elements.)</code></em><br/>
<code>        swap(a[end], a[0])</code><br/>
<code>        </code><em><code>(the</code> <code>heap</code> <code>size</code> <code>is</code> <code>reduced</code> <code>by</code> <code>one)</code></em><br/>
<code>        end ← end - 1</code><br/>
<code>        </code><em><code>(the</code> <code>swap</code> <code>ruined</code> <code>the</code> <code>heap</code> <code>property,</code> <code>so</code> <code>restore</code> <code>it)</code></em><br/>
<code>        siftDown(a, 0, end)</code></p>

<p>The sorting routine uses two subroutines, <code>heapify</code> and <code>siftDown</code>. The former is the common in-place heap construction routine, while the latter is a common subroutine for implementing <code>heapify</code>.</p>

<p><em><code>(Put</code> <code>elements</code> <code>of</code> <code>'a'</code> <code>in</code> <code>heap</code> <code>order,</code> <code>in-place)</code></em><br/>
<strong><code>procedure</code></strong><code> heapify(a, count) </code><strong><code>is</code></strong><br/>
<code>    </code><em><code>(start</code> <code>is</code> <code>assigned</code> <code>the</code> <code>index</code> <code>in</code> <code>'a'</code> <code>of</code> <code>the</code> <code>last</code> <code>parent</code> <code>node)</code></em><br/>
<code>    </code><em><code>(the</code> <code>last</code> <code>element</code> <code>in</code> <code>a</code> <code>0-based</code> <code>array</code> <code>is</code> <code>at</code> <code>index</code> <code>count-1;</code> <code>find</code> <code>the</code> <code>parent</code> <code>of</code> <code>that</code> <code>element)</code></em><br/>
<code>    start ← floor ((count - 2) / 2)</code><br/>
<code>    </code><br/>
<code>    </code><strong><code>while</code></strong><code> start ≥ 0 </code><strong><code>do</code></strong><br/>
<code>        </code><em><code>(sift</code> <code>down</code> <code>the</code> <code>node</code> <code>at</code> <code>index</code> <code>'start'</code> <code>to</code> <code>the</code> <code>proper</code> <code>place</code> <code>such</code> <code>that</code> <code>all</code> <code>nodes</code> <code>below</code></em><br/>
<code>        '' the start index are in heap order)''</code><br/>
<code>        siftDown(a, start, count - 1)</code><br/>
<code>        </code><em><code>(go</code> <code>to</code> <code>the</code> <code>next</code> <code>parent</code> <code>node)</code></em><br/>
<code>        start ← start - 1</code><br/>
<code>    </code><em><code>(after</code> <code>sifting</code> <code>down</code> <code>the</code> <code>root</code> <code>all</code> <code>nodes/elements</code> <code>are</code> <code>in</code> <code>heap</code> <code>order)</code></em><br/>
<br/>
<code>''(Repair the heap whose root element is at index 'start', assuming the heaps rooted at its children are valid)</code><br/>
<strong><code>procedure</code></strong><code> siftDown(a, start, end) </code><strong><code>is</code></strong><br/>
<code>    root ← start</code><br/>
<br/>
<code>    </code><strong><code>while</code></strong><code> root * 2 + 1 ≤ end </code><strong><code>do</code></strong><code>    </code><em><code>(While</code> <code>the</code> <code>root</code> <code>has</code> <code>at</code> <code>least</code> <code>one</code> <code>child)</code></em><br/>
<code>        child ← root * 2 + 1       </code><em><code>(Left</code> <code>child)</code></em><br/>
<code>        swap ← root                </code><em><code>(Keeps</code> <code>track</code> <code>of</code> <code>child</code> <code>to</code> <code>swap</code> <code>with)</code></em><br/>
<br/>
<code>        </code><strong><code>if</code></strong><code> a[swap] </code><code>heapify</code><code> procedure can be thought of as building a heap from the bottom up by successively sifting downward to establish the </code><a href="Heap_(data_structure)" title="wikilink"><code>heap</code> <code>property</code></a><code>. An alternative version (shown below) that builds the heap top-down and sifts upward may be simpler to understand. This </code><code>siftUp</code><code> version can be visualized as starting with an empty heap and successively inserting elements, whereas the </code><code>siftDown</code><code> version given above treats the entire input array as a full but "broken" heap and "repairs" it starting from the last non-trivial sub-heap (that is, the last parent node).</code></p>

<p> Also, the <code>siftDown</code> version of heapify <a href="Binary_heap#Building_a_heap" title="wikilink">has 

<math display="inline" id="Heapsort:0">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(n)
  </annotation>
 </semantics>
</math>

 time complexity</a>, while the <code>siftUp</code> version given below has 

<math display="inline" id="Heapsort:1">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nlogn)
  </annotation>
 </semantics>
</math>

 time complexity due to its equivalence with inserting each element, one at a time, into an empty heap.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> This may seem counter-intuitive since, at a glance, it is apparent that the former only makes half as many calls to its logarithmic-time sifting function as the latter; i.e., they seem to differ only by a constant factor, which never has an impact on asymptotic analysis.</p>

<p>To grasp the intuition behind this difference in complexity, note that the number of swaps that may occur during any one siftUp call <em>increases</em> with the depth of the node on which the call is made. The crux is that there are many (exponentially many) more "deep" nodes than there are "shallow" nodes in a heap, so that siftUp may have its full logarithmic running-time on the approximately linear number of calls made on the nodes at or near the "bottom" of the heap. On the other hand, the number of swaps that may occur during any one siftDown call <em>decreases</em> as the depth of the node on which the call is made increases. Thus, when the <code>siftDown</code> <code>heapify</code> begins and is calling <code>siftDown</code> on the bottom and most numerous node-layers, each sifting call will incur, at most, a number of swaps equal to the "height" (from the bottom of the heap) of the node on which the sifting call is made. In other words, about half the calls to siftDown will have at most only one swap, then about a quarter of the calls will have at most two swaps, etc.</p>

<p>The heapsort algorithm itself has 

<math display="inline" id="Heapsort:2">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mi>l</mi>
     <mi>o</mi>
     <mi>g</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(nlogn)
  </annotation>
 </semantics>
</math>

 time complexity using either version of heapify.</p>

<p><code> </code><strong><code>procedure</code></strong><code> heapify(a,count) is</code><br/>
<code>     </code><em><code>(end</code> <code>is</code> <code>assigned</code> <code>the</code> <code>index</code> <code>of</code> <code>the</code> <code>first</code> <code>(left)</code> <code>child</code> <code>of</code> <code>the</code> <code>root)</code></em><br/>
<code>     end := 1</code><br/>
<code>     </code><br/>
<code>     </code><strong><code>while</code></strong><code> end </code><code> start</code><br/>
<code>         parent := floor((child-1) / 2)</code><br/>
<code>         </code><strong><code>if</code></strong><code> a[parent] </code><code>2</code><code>(N) − e</code><sub><code>2</code></sub><code>(N), where s</code><sub><code>2</code></sub><code>(N) is the sum of all digits of the binary representation of N and e</code><sub><code>2</code></sub><code>(N) is the exponent of 2 in the prime factorization of N.</code><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>
<ul>
<li><a href="Ternary_heapsort" title="wikilink">Ternary heapsort</a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> uses a ternary heap instead of a binary heap; that is, each element in the heap has three children. It is more complicated to program, but does a constant number of times fewer swap and comparison operations. This is because each step in the shift operation of a ternary heap requires three comparisons and one swap, whereas in a binary heap two comparisons and one swap are required. The ternary heap does two steps in less time than the binary heap requires for three steps, which multiplies the index by a factor of 9 instead of the factor 8 of three binary steps.</li>
<li>The <strong><a class="uri" href="smoothsort" title="wikilink">smoothsort</a></strong> algorithm<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> is a variation of heapsort developed by <a href="Edsger_W._Dijkstra" title="wikilink">Edsger Dijkstra</a> in 1981. Like heapsort, smoothsort's upper bound is <a href="Big_O_notation" title="wikilink">O</a>(<em>n</em> log <em>n</em>). The advantage of smoothsort is that it comes closer to O(<em>n</em>) time if the <a href="Adaptive_sort" title="wikilink">input is already sorted to some degree</a>, whereas heapsort averages O(<em>n</em> log <em>n</em>) regardless of the initial sorted state. Due to its complexity, smoothsort is rarely used.</li>
<li>Levcopoulos and Petersson<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> describe a variation of heapsort based on a <a href="Cartesian_tree" title="wikilink">Cartesian tree</a> that does not add an element to the heap until smaller values on both sides of it have already been included in the sorted output. As they show, this modification can allow the algorithm to sort more quickly than O(<em>n</em> log <em>n</em>) for inputs that are already nearly sorted.</li>
</ul>
<h3 id="bottom-up-heapsort">Bottom-up heapsort</h3>

<p>Bottom-up heapsort was announced as beating quicksort (with median-of-three pivot selection) on arrays of size ≥16000.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> This version of heapsort keeps the linear-time heap-building phase, but changes the second phase, as follows. Ordinary heapsort extracts the top of the heap, 

<math display="inline" id="Heapsort:3">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mn>00</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <cn type="integer">00</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a00
  </annotation>
 </semantics>
</math>

, and fills the gap it leaves with 

<math display="inline" id="Heapsort:4">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mi>e</mi>
   <mi>n</mi>
   <mi>d</mi>
   <mi>e</mi>
   <mi>n</mi>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>e</ci>
    <ci>n</ci>
    <ci>d</ci>
    <ci>e</ci>
    <ci>n</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   aendend
  </annotation>
 </semantics>
</math>

, then sifts this latter element down the heap; but this element comes from the lowest level of the heap, meaning it is one of the smallest elements in the heap, so the sift-down will likely take many steps to move it back down. Bottom-up heapsort instead finds the element to fill the gap, by tracing a path of maximum children down the heap as before, but then sifts that element <em>up</em> the heap, which is likely to take fewer steps.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p><strong><code>function</code></strong><code> leafSearch(a, end, i) </code><strong><code>is</code></strong><br/>
<code>    j ← i</code><br/>
<code>    </code><strong><code>while</code></strong><code> 2×j ≤ end </code><strong><code>do</code></strong><br/>
<code>        </code><em><code>(Determine</code> <code>which</code> <code>of</code> <code>j's</code> <code>children</code> <code>is</code> <code>the</code> <code>greater)</code></em><br/>
<code>        </code><strong><code>if</code></strong><code> 2×j+1 </code><code> a[2×j] </code><strong><code>then</code></strong><br/>
<code>            j ← 2×j+1</code><br/>
<code>        </code><strong><code>else</code></strong><br/>
<code>            j ← 2×j</code><br/>
<code>    </code><strong><code>return</code></strong><code> j</code></p>

<p>The return value of the <code>leafSearch</code> is used in a replacement for the <code>siftDown</code> routine:<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p><strong><code>function</code></strong><code> siftDown(a, end, i) </code><strong><code>is</code></strong><br/>
<code>    j ← leafSearch(a, end, i)</code><br/>
<code>    </code><strong><code>while</code></strong><code> a[i] &gt; a[j] </code><strong><code>do</code></strong><br/>
<code>        j ← parent(j)</code><br/>
<code>    x ← a[j]</code><br/>
<code>    a[j] ← a[i]</code><br/>
<code>    </code><strong><code>while</code></strong><code> j &gt; i </code><strong><code>do</code></strong><br/>
<code>        swap x, a[parent(j)]</code><br/>
<code>        j ← parent(j)</code></p>

<p>Bottom-up heapsort requires only 

<math display="inline" id="Heapsort:5">
 <semantics>
  <mrow>
   <mrow>
    <mn>1.5</mn>
    <mi>n</mi>
    <mi>l</mi>
    <mi>o</mi>
    <mi>g</mi>
    <mi>n</mi>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <cn type="float">1.5</cn>
     <ci>n</ci>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1.5nlogn+O(n)
  </annotation>
 </semantics>
</math>

 comparisons in the worst case and 

<math display="inline" id="Heapsort:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>n</mi>
    <mi>l</mi>
    <mi>o</mi>
    <mi>g</mi>
    <mi>n</mi>
   </mrow>
   <mo>+</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>n</ci>
     <ci>l</ci>
     <ci>o</ci>
     <ci>g</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   nlogn+O(1)
  </annotation>
 </semantics>
</math>

 on average. A 2008 re-evaluation of this algorithm showed it to be no faster than ordinary heapsort, though, presumably because modern <a href="branch_prediction" title="wikilink">branch prediction</a> nullifies the cost of the comparisons that bottom-up heapsort manages to avoid.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h2 id="comparison-with-other-sorts">Comparison with other sorts</h2>

<p>Heapsort primarily competes with <a class="uri" href="quicksort" title="wikilink">quicksort</a>, another very efficient general purpose nearly-in-place comparison-based sort algorithm.</p>

<p>Quicksort is typically somewhat faster due to some factors, but the worst-case running time for quicksort is <a href="Big_O_notation" title="wikilink">O</a>(<em>n</em><sup>2</sup>), which is unacceptable for large data sets and can be deliberately triggered given enough knowledge of the implementation, creating a security risk. See <a class="uri" href="quicksort" title="wikilink">quicksort</a> for a detailed discussion of this problem and possible solutions.</p>

<p>Thus, because of the O(<em>n</em> log <em>n</em>) upper bound on heapsort's running time and constant upper bound on its auxiliary storage, embedded systems with real-time constraints or systems concerned with security often use heapsort.</p>

<p>Heapsort also competes with <a href="merge_sort" title="wikilink">merge sort</a>, which has the same time bounds. Merge sort requires Ω(n) auxiliary space, but heapsort requires only a constant amount. Heapsort typically runs faster in practice on machines with small or slow <a href="data_cache" title="wikilink">data caches</a>. On the other hand, merge sort has several advantages over heapsort:</p>
<ul>
<li>Merge sort on arrays has considerably better data cache performance, often outperforming heapsort on modern desktop computers because merge sort frequently accesses contiguous memory locations (good <a href="locality_of_reference" title="wikilink">locality of reference</a>); heapsort references are spread throughout the heap.</li>
<li>Heapsort is not a <a href="stable_sort" title="wikilink">stable sort</a>; merge sort is stable.</li>
<li>Merge sort <a href="parallel_algorithm" title="wikilink">parallelizes</a> well and can achieve close to <a href="linear_speedup" title="wikilink">linear speedup</a> with a trivial implementation; heapsort is not an obvious candidate for a parallel algorithm.</li>
<li>Merge sort can be adapted to operate on <strong>singly</strong> <a href="linked_list" title="wikilink">linked lists</a> with O(1) extra space. Heapsort can be adapted to operate on <strong>doubly</strong> linked lists with only O(1) extra space overhead.</li>
<li>Merge sort is used in <a href="external_sorting" title="wikilink">external sorting</a>; heapsort is not. Locality of reference is the issue.</li>
</ul>

<p><a class="uri" href="Introsort" title="wikilink">Introsort</a> is an alternative to heapsort that combines quicksort and heapsort to retain advantages of both: worst case speed of heapsort and average speed of quicksort.</p>
<h2 id="example">Example</h2>

<p>Let { 6, 5, 3, 1, 8, 7, 2, 4 } be the list that we want to sort from the smallest to the largest. (NOTE, for 'Building the Heap' step: Larger nodes don't stay below smaller node parents. They are swapped with parents, and then recursively checked if another swap is needed, to keep larger numbers above smaller numbers on the heap binary tree.)  <strong>1. Build the heap</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Heap</p></th>
<th style="text-align: left;">
<p>newly added element</p></th>
<th style="text-align: left;">
<p>swap elements</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>null</p></td>
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>6, 5</p></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>6, 5, 3</p></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>6, 5, 3, 1</p></td>
<td style="text-align: left;">
<p>8</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>6, <strong>5</strong>, 3, 1, '''8 '''</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>5, 8</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>6</strong>, <strong>8</strong>, 3, 1, 5</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>6, 8</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>8, 6, 3, 1, 5</p></td>
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>8, 6, <strong>3</strong>, 1, 5, <strong>7</strong></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>3, 7</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>8, 6, 7, 1, 5, 3</p></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>8, 6, 7, 1, 5, 3, 2</p></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>8, 6, 7, <strong>1</strong>, 5, 3, 2, <strong>4</strong></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>1, 4</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>8, 6, 7, 4, 5, 3, 2, 1</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>

<p><strong>2. Sorting.</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Heap</p></th>
<th style="text-align: left;">
<p>swap elements</p></th>
<th style="text-align: left;">
<p>delete element</p></th>
<th style="text-align: left;">
<p>sorted array</p></th>
<th style="text-align: left;">
<p>details</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>8</strong>, 6, 7, 4, 5, 3, 2, <strong>1</strong></p></td>
<td style="text-align: left;">
<p>8, 1</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>swap 8 and 1 in order to delete 8 from heap</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1, 6, 7, 4, 5, 3, 2, <strong>8</strong></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>8</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>delete 8 from heap and add to sorted array</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>1</strong>, 6, <strong>7</strong>, 4, 5, 3, 2</p></td>
<td style="text-align: left;">
<p>1, 7</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>8</p></td>
<td style="text-align: left;">
<p>swap 1 and 7 as they are not in order in the heap</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>7, 6, <strong>1</strong>, 4, 5, <strong>3</strong>, 2</p></td>
<td style="text-align: left;">
<p>1, 3</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>8</p></td>
<td style="text-align: left;">
<p>swap 1 and 3 as they are not in order in the heap</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>7</strong>, 6, 3, 4, 5, 1, <strong>2</strong></p></td>
<td style="text-align: left;">
<p>7, 2</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>8</p></td>
<td style="text-align: left;">
<p>swap 7 and 2 in order to delete 7 from heap</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>2, 6, 3, 4, 5, 1, <strong>7</strong></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>7</p></td>
<td style="text-align: left;">
<p>8</p></td>
<td style="text-align: left;">
<p>delete 7 from heap and add to sorted array</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>2</strong>, <strong>6</strong>, 3, 4, 5, 1</p></td>
<td style="text-align: left;">
<p>2, 6</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>7, 8</p></td>
<td style="text-align: left;">
<p>swap 2 and 6 as they are not in order in the heap</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>6, <strong>2</strong>, 3, 4, <strong>5</strong>, 1</p></td>
<td style="text-align: left;">
<p>2, 5</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>7, 8</p></td>
<td style="text-align: left;">
<p>swap 2 and 5 as they are not in order in the heap</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>6</strong>, 5, 3, 4, 2, <strong>1</strong></p></td>
<td style="text-align: left;">
<p>6, 1</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>7, 8</p></td>
<td style="text-align: left;">
<p>swap 6 and 1 in order to delete 6 from heap</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1, 5, 3, 4, 2, <strong>6</strong></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>6</p></td>
<td style="text-align: left;">
<p>7, 8</p></td>
<td style="text-align: left;">
<p>delete 6 from heap and add to sorted array</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>1</strong>, <strong>5</strong>, 3, 4, 2</p></td>
<td style="text-align: left;">
<p>1, 5</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>6, 7, 8</p></td>
<td style="text-align: left;">
<p>swap 1 and 5 as they are not in order in the heap</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>5, <strong>1</strong>, 3, <strong>4</strong>, 2</p></td>
<td style="text-align: left;">
<p>1, 4</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>6, 7, 8</p></td>
<td style="text-align: left;">
<p>swap 1 and 4 as they are not in order in the heap</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>5</strong>, 4, 3, 1, <strong>2</strong></p></td>
<td style="text-align: left;">
<p>5, 2</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>6, 7, 8</p></td>
<td style="text-align: left;">
<p>swap 5 and 2 in order to delete 5 from heap</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>2, 4, 3, 1, <strong>5</strong></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>5</p></td>
<td style="text-align: left;">
<p>6, 7, 8</p></td>
<td style="text-align: left;">
<p>delete 5 from heap and add to sorted array</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>2</strong>, <strong>4</strong>, 3, 1</p></td>
<td style="text-align: left;">
<p>2, 4</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>5, 6, 7, 8</p></td>
<td style="text-align: left;">
<p>swap 2 and 4 as they are not in order in the heap</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>4</strong>, 2, 3, <strong>1</strong></p></td>
<td style="text-align: left;">
<p>4, 1</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>5, 6, 7, 8</p></td>
<td style="text-align: left;">
<p>swap 4 and 1 in order to delete 4 from heap</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1, 2, 3, <strong>4</strong></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>4</p></td>
<td style="text-align: left;">
<p>5, 6, 7, 8</p></td>
<td style="text-align: left;">
<p>delete 4 from heap and add to sorted array</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>1</strong>, 2, <strong>3</strong></p></td>
<td style="text-align: left;">
<p>1, 3</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>4, 5, 6, 7, 8</p></td>
<td style="text-align: left;">
<p>swap 1 and 3 as they are not in order in the heap</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>3</strong>, 2, <strong>1</strong></p></td>
<td style="text-align: left;">
<p>3, 1</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>4, 5, 6, 7, 8</p></td>
<td style="text-align: left;">
<p>swap 3 and 1 in order to delete 3 from heap</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1, 2, <strong>3</strong></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>3</p></td>
<td style="text-align: left;">
<p>4, 5, 6, 7, 8</p></td>
<td style="text-align: left;">
<p>delete 3 from heap and add to sorted array</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>1</strong>, <strong>2</strong></p></td>
<td style="text-align: left;">
<p>1, 2</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>3, 4, 5, 6, 7, 8</p></td>
<td style="text-align: left;">
<p>swap 1 and 2 as they are not in order in the heap</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>2</strong>, <strong>1</strong></p></td>
<td style="text-align: left;">
<p>2, 1</p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>3, 4, 5, 6, 7, 8</p></td>
<td style="text-align: left;">
<p>swap 2 and 1 in order to delete 2 from heap</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1, <strong>2</strong></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p>3, 4, 5, 6, 7, 8</p></td>
<td style="text-align: left;">
<p>delete 2 from heap and add to sorted array</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>1</strong></p></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p>2, 3, 4, 5, 6, 7, 8</p></td>
<td style="text-align: left;">
<p>delete 1 from heap and add to sorted array</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">
<p>1, 2, 3, 4, 5, 6, 7, 8</p></td>
<td style="text-align: left;">
<p>completed</p></td>
</tr>
</tbody>
</table>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li><a href="Thomas_H._Cormen" title="wikilink">Thomas H. Cormen</a>, <a href="Charles_E._Leiserson" title="wikilink">Charles E. Leiserson</a>, <a href="Ronald_L._Rivest" title="wikilink">Ronald L. Rivest</a>, and <a href="Clifford_Stein" title="wikilink">Clifford Stein</a>. <em><a href="Introduction_to_Algorithms" title="wikilink">Introduction to Algorithms</a></em>, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Chapters 6 and 7 Respectively: Heapsort and Priority Queues</li>
<li><a href="http://www.cs.utexas.edu/users/EWD/ewd07xx/EWD796a.PDF">A PDF of Dijkstra's original paper on Smoothsort</a></li>
<li><a href="http://cis.stvincent.edu/html/tutorials/swd/heaps/heaps.html">Heaps and Heapsort Tutorial</a> by David Carlson, St. Vincent College</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.sorting-algorithms.com/heap-sort">Animated Sorting Algorithms: Heap Sort</a> – graphical demonstration and discussion of heap sort</li>
<li><a href="http://olli.informatik.uni-oldenburg.de/heapsort_SALA/english/start.html">Courseware on Heapsort from Univ. Oldenburg</a> - With text, animations and interactive exercises</li>
<li><a href="http://www.nist.gov/dads/HTML/heapSort.html">NIST's Dictionary of Algorithms and Data Structures: Heapsort</a></li>
<li><a href="http://www.codecodex.com/wiki/Heapsort">Heapsort implemented in 12 languages</a></li>
<li><a href="http://www.azillionmonkeys.com/qed/sort.html">Sorting revisited</a> by Paul Hsieh</li>
<li><a href="http://coderaptors.com/?HeapSort">A color graphical Java applet</a> that allows experimentation with initial state and shows statistics</li>
<li><a href="http://employees.oneonta.edu/zhangs/powerPointPlatform/index.php">A PowerPoint presentation demonstrating how Heap sort works</a> that is for educators.</li>
<li><a href="http://opendatastructures.org/versions/edition-0.1e/ods-java/11_1_Comparison_Based_Sorti.html#SECTION001413000000000000000">Open Data Structures - Section 11.1.3 - Heap-Sort</a></li>
</ul>

<p><a href="no:Sorteringsalgoritme#Heap_sort" title="wikilink">no:Sorteringsalgoritme#Heap sort</a>"</p>

<p><a href="Category:Sorting_algorithms" title="wikilink">Category:Sorting algorithms</a> <a href="Category:Comparison_sorts" title="wikilink">Category:Comparison sorts</a> <a href="Category:Heaps_(data_structures)" title="wikilink">Category:Heaps (data structures)</a> <a href="Category:Articles_with_example_pseudocode" title="wikilink">Category:Articles with example pseudocode</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7">"Data Structures Using Pascal", 1991, page 405, gives a ternary heapsort as a student exercise. "Write a sorting routine similar to the heapsort except that it uses a ternary heap."<a href="#fnref7">↩</a></li>
<li id="fn8"><a class="uri" href="http://www.cs.utexas.edu/users/EWD/ewd07xx/EWD796a.PDF">http://www.cs.utexas.edu/users/EWD/ewd07xx/EWD796a.PDF</a><a href="#fnref8">↩</a></li>
<li id="fn9"><a class="uri" href="http://www.cs.utexas.edu/~EWD/transcriptions/EWD07xx/EWD796a.html">http://www.cs.utexas.edu/~EWD/transcriptions/EWD07xx/EWD796a.html</a><a href="#fnref9">↩</a></li>
<li id="fn10">.<a href="#fnref10">↩</a></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
</ol>
</section>
</body>
</html>
