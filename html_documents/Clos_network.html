<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1792">Clos network</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Clos network</h1>
<hr>In the field of [[telecommunications]], a '''Clos network''' is a kind of multistage [[circuit switching]] network, first formalized by [[Charles Clos]] in 1952,<ref>{{cite journal|last=Clos|first=Charles|title=A study of non-blocking switching networks|journal=[[Bell Labs Technical Journal|Bell System Technical Journal]]|date=Mar 1953|volume=32|issue=2|pages=406–424|url=http://www.alcatel-lucent.com/bstj/vol32-1953/articles/bstj32-2-406.pdf|accessdate=22 March 2011|issn=00058580|doi=10.1002/j.1538-7305.1953.tb01433.x}}</ref> which represents a theoretical idealization of practical multi-stage telephone switching systems.  Clos networks are required when the physical 
<p>circuit switching needs to exceed the capacity of the largest feasible single <a href="crossbar_switch" title="wikilink">crossbar switch</a>. The key advantage of Clos networks is that the number of crosspoints (which make up each <a href="crossbar_switch" title="wikilink">crossbar switch</a>) required can be far fewer than would be the case if the entire switching system were implemented with one large crossbar switch. When the Clos network was first devised, the number of crosspoints was a reasonable approximate indication of the total cost of the switching system. While this was important for electromechanical crossbars, it became less relevant with the advent of <a href="Very-large-scale_integration" title="wikilink">VLSI</a>, wherein the interconnects often could be implemented either directly in silicon, or within a relatively small cluster of boards. However, the advent of complex data centers, with huge interconnect structures, each based on optical fiber links, means that they are again important. <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Clos networks have three stages: the ingress stage, middle stage, and the egress stage. Each stage is made up of a number of crossbar switches (see diagram below), often just called <em>crossbars</em>. Each call entering an ingress crossbar switch can be routed through any of the available middle stage crossbar switches, to the relevant egress crossbar switch. A middle stage crossbar is available for a particular new call if both the link connecting the ingress switch to the middle stage switch, and the link connecting the middle stage switch to the egress switch, are free.</p>
<figure><b>(Figure)</b>
<figcaption>Closnetwork.png</figcaption>
</figure>

<p>Clos networks are defined by three integers <em>n</em>, <em>m</em>, and <em>r</em>. <em>n</em> represents the number of sources which feed into each of <em>r</em> ingress stage crossbar switches. Each ingress stage crossbar switch has <em>m</em> outlets, and there are <em>m</em> middle stage crossbar switches. There is exactly one connection between each ingress stage switch and each middle stage switch. There are <em>r</em> egress stage switches, each with <em>m</em> inputs and <em>n</em> outputs. Each middle stage switch is connected exactly once to each egress stage switch. Thus, the ingress stage has r switches, each of which has n inputs and m outputs. The middle stage has m switches, each of which has r inputs and r outputs. The egress stage has r switches, each of which has m inputs and n outputs.</p>
<h2 id="blocking-characteristics">Blocking characteristics</h2>

<p>The relative values of <em>m</em> and <em>n</em> define the blocking characteristics of the Clos network.</p>
<h3 id="strict-sense-nonblocking-clos-networks-m-2n1-the-original-1953-clos-result">Strict-sense nonblocking Clos networks (<em>m</em> ≥ 2<em>n</em>−1): the original 1953 Clos result</h3>

<p>If <em>m</em> ≥ 2<em>n</em>−1, the Clos network is <em>strict-sense nonblocking</em>, meaning that an unused input on an ingress switch can always be connected to an unused output on an egress switch, <em>without having to re-arrange existing calls</em>. This is the result which formed the basis of Clos's classic 1953 paper. Assume that there is a free terminal on the input of an ingress switch, and this has to be connected to a free terminal on a particular egress switch. In the worst case, <em>n</em>−1 other calls are active on the ingress switch in question, and <em>n</em>−1 other calls are active on the egress switch in question. Assume, also in the worst case, that each of these calls passes through a different middle-stage switch. Hence in the worst case, 2<em>n</em>−2 of the middle stage switches are unable to carry the new call. Therefore, to ensure strict-sense nonblocking operation, another middle stage switch is required, making a total of 2<em>n</em>−1.</p>
<h3 id="rearrangeably-nonblocking-clos-networks-m-n">Rearrangeably nonblocking Clos networks (<em>m</em> ≥ <em>n</em>)</h3>

<p>If <em>m</em> ≥ <em>n</em>, the Clos network is <em>rearrangeably nonblocking</em>, meaning that an unused input on an ingress switch can always be connected to an unused output on an egress switch, but for this to take place, existing calls may have to be rearranged by assigning them to different centre stage switches in the Clos network.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> To prove this, it is sufficient to consider <em>m</em> = <em>n</em>, with the Clos network fully utilised; that is, <em>r</em>×<em>n</em> calls in progress. The proof shows how any permutation of these <em>r</em>×<em>n</em> input terminals onto <em>r</em>×<em>n</em> output terminals may be broken down into smaller permutations which may each be implemented by the individual crossbar switches in a Clos network with <em>m</em> = <em>n</em>.</p>

<p>The proof uses <a href="Hall's_marriage_theorem" title="wikilink">Hall's marriage theorem</a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> which is given this name because it is often explained as follows. Suppose there are <em>r</em> boys and <em>r</em> girls. The theorem states that if every subset of <em>k</em> boys (for each <em>k</em> such that 0 ≤ <em>k</em> ≤ <em>r</em>) between them know <em>k</em> or more girls, then each boy can be paired off with a girl that he knows. It is obvious that this is a necessary condition for pairing to take place; what is surprising is that it is sufficient.</p>

<p>In the context of a Clos network, each boy represents an ingress switch, and each girl represents an egress switch. A boy is said to know a girl if the corresponding ingress and egress switches carry the same call. Each set of <em>k</em> boys must know at least <em>k</em> girls because <em>k</em> ingress switches are carrying <em>k</em>×<em>n</em> calls and these cannot be carried by less than <em>k</em> egress switches. Hence each ingress switch can be paired off with an egress switch that carries the same call, via a one-to-one mapping. These <em>r</em> calls can be carried by one middle-stage switch. If this middle-stage switch is now removed from the Clos network, <em>m</em> is reduced by 1, and we are left with a smaller Clos network. The process then repeats itself until <em>m</em> = 1, and every call is assigned to a middle-stage switch.</p>
<h3 id="blocking-probabilities-the-lee-and-jacobaeus-approximations">Blocking probabilities: the Lee and Jacobaeus approximations</h3>

<p>Real telephone switching systems are rarely strict-sense nonblocking for reasons of cost, and they have a small probability of blocking, which may be evaluated by the Lee or <a href="Christian_Jacobaeus" title="wikilink">Jacobaeus</a> approximations,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> assuming no rearrangements of existing calls. Here, the potential number of other active calls on each ingress or egress switch is <em>u</em> = <em>n</em>−1.</p>

<p>In the Lee approximation, it is assumed that each internal link between stages is already occupied by a call with a certain probability <em>p</em>, and that this is completely independent between different links. This overestimates the blocking probability, particularly for small <em>r</em>. The probability that a given internal link is busy is <em>p</em> = <em>uq</em>/<em>m</em>, where <em>q</em> is the probability that an ingress or egress link is busy. Conversely, the probability that a link is free is 1−<em>p</em>. The probability that the path connecting an ingress switch to an egress switch via a particular middle stage switch is free is the probability that both links are free, (1−<em>p</em>)<sup>2</sup>. Hence the probability of it being unavailable is 1−(1−<em>p</em>)<sup>2</sup> = 2<em>p</em>−<em>p</em><sup>2</sup>. The probability of blocking, or the probability that no such path is free, is then [1−(1−<em>p</em>)<sup>2</sup>]<sup><em>m</em></sup>.</p>

<p>The Jacobaeus approximation is more accurate, and to see how it is derived, assume that some particular mapping of calls entering the Clos network (input calls) already exists onto middle stage switches. This reflects the fact that only the <em>relative</em> configurations of ingress switch and egress switches is of relevance. There are <em>i</em> input calls entering via the same ingress switch as the free input terminal to be connected, and there are <em>j</em> calls leaving the Clos network (output calls) via the same egress switch as the free output terminal to be connected. Hence 0 ≤ <em>i</em> ≤ <em>u</em>, and 0 ≤ <em>j</em> ≤ <em>u</em>.</p>

<p>Let <em>A</em> be the number of ways of assigning the <em>j</em> output calls to the <em>m</em> middle stage switches. Let <em>B</em> be the number of these assignments which result in blocking. This is the number of cases in which the remaining <em>m</em>−<em>j</em> middle stage switches coincide with <em>m</em>−<em>j</em> of the <em>i</em> input calls, which is the number of subsets containing <em>m</em>−<em>j</em> of these calls. Then the probability of blocking is:</p>

<p>

<math display="block" id="Clos_network:0">
 <semantics>
  <mrow>
   <msub>
    <mi>β</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mi>B</mi>
    <mi>A</mi>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mo>(</mo>
     <mtable>
      <mtr>
       <mtd columnalign="center">
        <mi>i</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mrow>
         <mi>m</mi>
         <mo>-</mo>
         <mi>j</mi>
        </mrow>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
    <mrow>
     <mo>(</mo>
     <mtable>
      <mtr>
       <mtd columnalign="center">
        <mi>m</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi>j</mi>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mrow>
      <mi>i</mi>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
     <mrow>
      <mi>j</mi>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
    </mrow>
    <mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>i</mi>
         <mo>+</mo>
         <mi>j</mi>
        </mrow>
        <mo>-</mo>
        <mi>m</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
     <mrow>
      <mi>m</mi>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>β</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <ci>B</ci>
      <ci>A</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <matrix>
       <matrixrow>
        <ci>i</ci>
       </matrixrow>
       <matrixrow>
        <apply>
         <minus></minus>
         <ci>m</ci>
         <ci>j</ci>
        </apply>
       </matrixrow>
      </matrix>
      <matrix>
       <matrixrow>
        <ci>m</ci>
       </matrixrow>
       <matrixrow>
        <ci>j</ci>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <factorial></factorial>
        <ci>i</ci>
       </apply>
       <apply>
        <factorial></factorial>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <factorial></factorial>
        <apply>
         <minus></minus>
         <apply>
          <plus></plus>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
         <ci>m</ci>
        </apply>
       </apply>
       <apply>
        <factorial></factorial>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \beta_{ij}=\frac{B}{A}=\frac{\left(\begin{array}[]{c}i\\
m-j\end{array}\right)}{\left(\begin{array}[]{c}m\\
j\end{array}\right)}=\frac{i!j!}{(i+j-m)!m!}
  </annotation>
 </semantics>
</math>

</p>

<p>If <em>f</em><sub><em>i</em></sub> is the probability that <em>i</em> other calls are already active on the ingress switch, and <em>g</em><sub><em>j</em></sub> is the probability that <em>j</em> other calls are already active on the egress switch, the overall blocking probability is:</p>

<p>

<math display="block" id="Clos_network:1">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>B</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi>u</mi>
    </munderover>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>j</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi>u</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>f</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>g</mi>
       <mi>j</mi>
      </msub>
      <msub>
       <mi>β</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>B</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>u</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>j</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <ci>u</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>g</ci>
        <ci>j</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>β</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{B}=\sum_{i=0}^{u}\sum_{j=0}^{u}f_{i}g_{j}\beta_{ij}
  </annotation>
 </semantics>
</math>

</p>

<p>This may be evaluated with <em>f</em><sub><em>i</em></sub> and <em>g</em><sub><em>j</em></sub> each being denoted by a <a href="binomial_distribution" title="wikilink">binomial distribution</a>. After considerable algebraic manipulation, this may be written as:</p>

<p>

<math display="block" id="Clos_network:2">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>B</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>u</mi>
        <mo lspace="0pt" rspace="3.5pt">!</mo>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>2</mn>
        <mo>-</mo>
        <mi>q</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mrow>
        <mn>2</mn>
        <mi>u</mi>
       </mrow>
       <mo>-</mo>
       <mi>m</mi>
      </mrow>
     </msup>
     <msup>
      <mi>q</mi>
      <mi>m</mi>
     </msup>
    </mrow>
    <mrow>
     <mrow>
      <mi>m</mi>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mn>2</mn>
         <mi>u</mi>
        </mrow>
        <mo>-</mo>
        <mi>m</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo lspace="0pt" rspace="3.5pt">!</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>B</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <factorial></factorial>
        <ci>u</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">2</cn>
        <ci>q</ci>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>u</ci>
        </apply>
        <ci>m</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>q</ci>
       <ci>m</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <factorial></factorial>
       <ci>m</ci>
      </apply>
      <apply>
       <factorial></factorial>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <cn type="integer">2</cn>
         <ci>u</ci>
        </apply>
        <ci>m</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{B}=\frac{(u!)^{2}(2-q)^{2u-m}q^{m}}{m!(2u-m)!}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="clos-networks-with-more-than-three-stages">Clos networks with more than three stages</h2>

<p>Clos networks may also be generalised to any odd number of stages. By replacing each centre stage crossbar switch with a 3-stage Clos network, Clos networks of five stages may be constructed. By applying the same process repeatedly, 7, 9, 11,... stages are possible.</p>

<p>===Beneš network (<em>m</em> = <em>n</em> = 2) === A rearrangeably nonblocking network of this type with <em>m</em> = <em>n</em> = 2 is generally called a <em>Beneš network</em>, even though it was discussed and analyzed by others before <a href="Václav_E._Beneš" title="wikilink">Václav E. Beneš</a>. The number of inputs and outputs is <em>N</em> = <em>r</em>×<em>n</em> = 2<em>r</em>. Such networks have 2 log<sub>2</sub><em>N</em> − 1 stages, each containing <em>N</em>/2 2×2 crossbar switches, and use a total of <em>N</em> log<sub>2</sub><em>N</em> − <em>N</em>/2 2×2 crossbar switches. For example, an 8×8 Benes network (i.e. with <em>N</em> = 8) is shown below; it has 2 log<sub>2</sub>8 − 1 = 5 stages, each containing <em>N</em>/2 = 4 2×2 crossbar switches, and it uses a total of <em>N</em> log<sub>2</sub><em>N</em> − <em>N</em>/2 = 20 2×2 crossbar switches. The central three stages consist of two smaller 4×4 Benes networks, while in the center stage, each 2×2 crossbar switch may itself be regarded as a 2×2 Benes network. This example therefore highlights the recursive construction of this type of network.</p>
<figure><b>(Figure)</b>
<figcaption>Benesnetwork.png</figcaption>
</figure>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Crossbar_switch" title="wikilink">Crossbar switch</a> Describes the switching element of a Clos network.</li>
<li><a href="Nonblocking_minimal_spanning_switch" title="wikilink">Nonblocking minimal spanning switch</a> Describes the switching algorithm of a Clos network.</li>
<li><a href="Banyan_switch" title="wikilink">Banyan switch</a> An alternative way to connect networks.</li>
<li><a href="Fat_tree" title="wikilink">Fat tree</a> An alternative way to connect networks.</li>
<li><a href="Omega_network" title="wikilink">Omega network</a> An alternative way to connect networks.</li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a class="uri" href="Category:Switches" title="wikilink">Category:Switches</a> <a href="Category:Telephone_exchange_equipment" title="wikilink">Category:Telephone exchange equipment</a> <a href="Category:Network_topology" title="wikilink">Category:Network topology</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a class="uri" href="http://www.networkworld.com/article/2226122/cisco-subnet/clos-networks--what-s-old-is-new-again.html">http://www.networkworld.com/article/2226122/cisco-subnet/clos-networks--what-s-old-is-new-again.html</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
</ol>
</section>
</hr></body>
</html>
