<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1770">Lattice reduction</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Lattice reduction</h1>
<hr/>

<p> In mathematics, the goal of <strong>lattice basis reduction</strong> is given an integer <a href="lattice_(group)" title="wikilink">lattice</a> basis as input, to find a <a href="basis_(linear_algebra)" title="wikilink">basis</a> with short, nearly <a class="uri" href="orthogonal" title="wikilink">orthogonal</a> vectors. This is realized using different algorithms, whose running time is usually at least exponential in the dimension of the lattice.</p>
<h2 id="nearly-orthogonal">Nearly Orthogonal</h2>

<p>One measure of <em>nearly orthogonal</em> is the <strong>orthogonality defect</strong>. This compares the product of the lengths of the basis vectors with the volume of the <a class="uri" href="parallelepiped" title="wikilink">parallelepiped</a> they define. For perfectly orthogonal basis vectors, these quantities would be the same.</p>

<p>Any particular basis of 

<math display="inline" id="Lattice_reduction:0">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 vectors may be represented by a <a href="Matrix_(mathematics)" title="wikilink">matrix</a> 

<math display="inline" id="Lattice_reduction:1">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

, whose columns are the basis vectors 

<math display="inline" id="Lattice_reduction:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>b</mi>
      <mi>i</mi>
     </msub>
     <mo>,</mo>
     <mi>i</mi>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>b</ci>
       <ci>i</ci>
      </apply>
      <ci>i</ci>
     </list>
     <cn type="integer">1</cn>
    </apply>
    <list>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b_{i},i=1,\ldots,n
  </annotation>
 </semantics>
</math>

. In the <strong>fully dimensional</strong> case where the number of basis vectors is equal to the dimension of the space they occupy, this matrix is square, and the volume of the fundamental parallelepiped is simply the absolute value of the <a class="uri" href="determinant" title="wikilink">determinant</a> of this matrix 

<math display="inline" id="Lattice_reduction:3">
 <semantics>
  <mrow>
   <mo>det</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <determinant></determinant>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \det(B)
  </annotation>
 </semantics>
</math>

. If the number of vectors is less than the dimension of the underlying space, then volume is 

<math display="inline" id="Lattice_reduction:4">
 <semantics>
  <msqrt>
   <mrow>
    <mo>det</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>B</mi>
       <mi>T</mi>
      </msup>
      <mi>B</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msqrt>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <root></root>
    <apply>
     <determinant></determinant>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <ci>T</ci>
      </apply>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqrt{\det(B^{T}B)}
  </annotation>
 </semantics>
</math>

. For a given lattice 

<math display="inline" id="Lattice_reduction:5">
 <semantics>
  <mi mathvariant="normal">Λ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Λ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Lambda
  </annotation>
 </semantics>
</math>

, this volume is the same (up to sign) for any basis, and hence is referred to as the determinant of the lattice 

<math display="inline" id="Lattice_reduction:6">
 <semantics>
  <mrow>
   <mo>det</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Λ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <determinant></determinant>
    <ci>normal-Λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \det(\Lambda)
  </annotation>
 </semantics>
</math>

 or <strong>lattice constant</strong> 

<math display="inline" id="Lattice_reduction:7">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Λ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>normal-Λ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(\Lambda)
  </annotation>
 </semantics>
</math>

.</p>

<p>The orthogonality defect is the product of the basis vector lengths divided by the parallelepiped volume;</p>

<p>

<math display="block" id="Lattice_reduction:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msubsup>
      <mi mathvariant="normal">Π</mi>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </msubsup>
     <mrow>
      <mo fence="true">||</mo>
      <msub>
       <mi>b</mi>
       <mi>i</mi>
      </msub>
      <mo fence="true">||</mo>
     </mrow>
    </mrow>
    <msqrt>
     <mrow>
      <mo>det</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msup>
         <mi>B</mi>
         <mi>T</mi>
        </msup>
        <mi>B</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msqrt>
   </mfrac>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msubsup>
      <mi mathvariant="normal">Π</mi>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>n</mi>
     </msubsup>
     <mrow>
      <mo fence="true">||</mo>
      <msub>
       <mi>b</mi>
       <mi>i</mi>
      </msub>
      <mo fence="true">||</mo>
     </mrow>
    </mrow>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi mathvariant="normal">Λ</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>δ</ci>
      <ci>B</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-Π</ci>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <root></root>
       <apply>
        <determinant></determinant>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>B</ci>
          <ci>T</ci>
         </apply>
         <ci>B</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>normal-Π</ci>
         <apply>
          <eq></eq>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>b</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>normal-Λ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(B)=\frac{\Pi_{i=1}^{n}||b_{i}||}{\sqrt{\det(B^{T}B)}}=\frac{\Pi_{i=1}^{%
n}||b_{i}||}{d(\Lambda)}
  </annotation>
 </semantics>
</math>

</p>

<p>From the geometric definition it may be appreciated that 

<math display="inline" id="Lattice_reduction:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>δ</ci>
     <ci>B</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(B)\geq 1
  </annotation>
 </semantics>
</math>

 with equality if and only if the basis is orthogonal.</p>

<p>If the lattice reduction problem is defined as finding the basis with the smallest possible defect, then the problem is <a href="NP_complete" title="wikilink">NP complete</a>. However, there exist <a href="polynomial_time" title="wikilink">polynomial time</a> algorithms to find a basis with defect 

<math display="inline" id="Lattice_reduction:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>δ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>δ</ci>
     <ci>B</ci>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta(B)\leq c
  </annotation>
 </semantics>
</math>

 where <em>c</em> is some constant depending only on the number of basis vectors and the dimension of the underlying space (if different). This is a good enough solution in many practical applications.</p>
<h2 id="in-two-dimensions">In two dimensions</h2>

<p>For a basis consisting of just two vectors, there is a simple and efficient method of reduction closely analogous to the <a href="Euclidean_algorithm" title="wikilink">Euclidean algorithm</a> for the <a href="greatest_common_divisor" title="wikilink">greatest common divisor</a> of two integers. As with the Euclidean algorithm, the method is iterative; at each step the larger of the two vectors is reduced by adding or subtracting an integer multiple of the smaller vector.</p>
<h2 id="applications">Applications</h2>

<p>Lattice reduction algorithms are used in a number of modern number theoretical applications, including in the discovery of a <a href="spigot_algorithm" title="wikilink">spigot algorithm</a> for 

<math display="inline" id="Lattice_reduction:11">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

. Although determining the shortest basis is possibly an NP-complete problem, algorithms such as the <a href="Lenstra–Lenstra–Lovász_lattice_basis_reduction_algorithm" title="wikilink">LLL algorithm</a> <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> can find a short (not necessarily shortest) basis in polynomial time with guaranteed worst-case performance. <a href="Lenstra–Lenstra–Lovász_lattice_basis_reduction_algorithm" title="wikilink">LLL</a> is widely used in the <a class="uri" href="cryptanalysis" title="wikilink">cryptanalysis</a> of <a href="Public-key_cryptography" title="wikilink">public key</a> cryptosystems.</p>

<p>When used to find integer relations, a typical input to the algorithm consists of an augmented nxn identity matrix with the entries in the last column consisting of the n elements (multiplied by a large positive constant w to penalize vectors that do not sum to zero) between which the relation is sought.</p>

<p>The <a href="LLL_algorithm" title="wikilink">LLL algorithm</a> for computing a nearly-orthogonal basis was used to show that <a href="integer_programming" title="wikilink">integer programming</a> in any fixed dimension can be done in <a href="P_(complexity)" title="wikilink">polynomial time</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="algorithms">Algorithms</h2>

<p>The following algorithms reduce lattice bases. They can be compared in terms of runtime and approximation to an optimal solution, always relative to the dimension of the given lattice. If there are public implementations of these algorithms this should also be noted here.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Year</p></th>
<th style="text-align: left;">
<p>Algorithm</p></th>
<th style="text-align: left;">
<p>Name</p></th>
<th style="text-align: left;">
<p>Implementation</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>1982</p></td>
<td style="text-align: left;">
<p><a href="Lenstra–Lenstra–Lovász_lattice_basis_reduction_algorithm" title="wikilink">LLL</a></p></td>
<td style="text-align: left;">
<p>Lenstra Lenstra Lovász</p></td>
<td style="text-align: left;">
<p><a href="Number_Theory_Library" title="wikilink">NTL</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1987</p></td>
<td style="text-align: left;">
<p>BKZ</p></td>
<td style="text-align: left;">
<p>Block Korkine Zolotarev<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p></td>
<td style="text-align: left;">
<p><a href="Number_Theory_Library" title="wikilink">NTL</a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>2002</p></td>
<td style="text-align: left;">
<p>RSR</p></td>
<td style="text-align: left;">
<p>Random Sampling Reduction</p></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>2002</p></td>
<td style="text-align: left;">
<p>PDR</p></td>
<td style="text-align: left;">
<p>Primal Dual Reduction</p></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Theory_of_cryptography" title="wikilink">Category:Theory of cryptography</a> <a href="Category:Computational_number_theory" title="wikilink">Category:Computational number theory</a> <a href="Category:Lattice_points" title="wikilink">Category:Lattice points</a> <a href="Category:Linear_algebra" title="wikilink">Category:Linear algebra</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
