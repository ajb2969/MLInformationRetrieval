<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1478">FO (complexity)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>FO (complexity)</h1>
<hr/>

<p>In <a href="descriptive_complexity" title="wikilink">descriptive complexity</a>, a branch of <a href="computational_complexity_theory" title="wikilink">computational complexity</a>, <em>FO</em> is a <a href="complexity_class" title="wikilink">complexity class</a> of structures which can be recognized by formulas of <a href="first-order_logic" title="wikilink">first-order logic</a>, and also equals the complexity class <a href="AC0" title="wikilink">AC<sup>0</sup></a>. Descriptive complexity uses the formalism of logic, but does not use several key notions associated with logic such as proof theory or axiomatization.</p>

<p>Restricting predicates to be from a set <em>X</em> yields a smaller class <em>FO[X]</em>. For instance, ''FO[ This allows the complexity of some problems to be established without reference to <a href="algorithm" title="wikilink">algorithms</a>.</p>
<h2 id="definition-and-examples">Definition and examples</h2>
<h3 id="the-idea">The idea</h3>

<p>When we use the logic formalism to describe a computational problem, the input is a finite structure, and the elements of that structure are the <a href="domain_of_discourse" title="wikilink">domain of discourse</a>. Usually the input is either a string (of bits or over an alphabet) and the elements of the logical structure represent positions of the string, or the input is a graph and the elements of the logical structure represent its vertices. The length of the input will be measured by the size of the respective structure. Whatever the structure is, we can assume that there are relations that can be tested, for example "

<math display="inline" id="FO_(complexity):0">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(x,y)
  </annotation>
 </semantics>
</math>

 is true <a class="uri" href="iff" title="wikilink">iff</a> there is an edge from 

<math display="inline" id="FO_(complexity):1">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="FO_(complexity):2">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

" (in case of the structure being a graph), or "

<math display="inline" id="FO_(complexity):3">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(n)
  </annotation>
 </semantics>
</math>

 is true <a class="uri" href="iff" title="wikilink">iff</a> the 

<math display="inline" id="FO_(complexity):4">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

th letter of the string is 1." These relations are the predicates for the first-order logic system. We also have constants, which are special elements of the respective structure, for example if we want to check reachability in a graph, we will have to choose two constants s (start) and t (terminal).</p>

<p>In descriptive complexity theory we almost always suppose that there is a total order over the elements and that we can check equality between elements. This lets us consider elements as numbers: the element 

<math display="inline" id="FO_(complexity):5">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 represents the number 

<math display="inline" id="FO_(complexity):6">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 iff there are 

<math display="inline" id="FO_(complexity):7">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n-1)
  </annotation>
 </semantics>
</math>

 elements 

<math display="inline" id="FO_(complexity):8">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="FO_(complexity):9">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is true if only the 

<math display="inline" id="FO_(complexity):10">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

th bit of 

<math display="inline" id="FO_(complexity):11">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mi>l</mi>
   <mi>u</mi>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>l</ci>
    <ci>u</ci>
    <ci>s</ci>
    <vector>
     <ci>x</ci>
     <ci>y</ci>
     <ci>z</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   plus(x,y,z)
  </annotation>
 </semantics>
</math>

 is 1. (We can replace addition and multiplication by ternary relations such that 

<math display="inline" id="FO_(complexity):12">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>+</mo>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mi>z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x+y=z
  </annotation>
 </semantics>
</math>

 is true iff 

<math display="inline" id="FO_(complexity):13">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mi>i</mi>
   <mi>m</mi>
   <mi>e</mi>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>i</ci>
    <ci>m</ci>
    <ci>e</ci>
    <ci>s</ci>
    <vector>
     <ci>x</ci>
     <ci>y</ci>
     <ci>z</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   times(x,y,z)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="FO_(complexity):14">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>*</mo>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mi>z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x*y=z
  </annotation>
 </semantics>
</math>

 is true iff 

<math display="inline" id="FO_(complexity):15">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge
  </annotation>
 </semantics>
</math>

).</p>
<h3 id="formally">Formally</h3>

<p>Let <em>X</em> be a set of predicate. The language <em>FO[X]</em> is defined as the closure by conjunction (

<math display="inline" id="FO_(complexity):16">
 <semantics>
  <mi mathvariant="normal">¬</mi>
  <annotation-xml encoding="MathML-Content">
   <not></not>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg
  </annotation>
 </semantics>
</math>

), negation (

<math display="inline" id="FO_(complexity):17">
 <semantics>
  <mo>∀</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">for-all</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall
  </annotation>
 </semantics>
</math>

) and universal quantification (

<math display="inline" id="FO_(complexity):18">
 <semantics>
  <mo>∃</mo>
  <annotation-xml encoding="MathML-Content">
   <exists></exists>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists
  </annotation>
 </semantics>
</math>

) over elements of the structures. Existential quantification (

<math display="inline" id="FO_(complexity):19">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vee
  </annotation>
 </semantics>
</math>

) and disjunction (

<math display="inline" id="FO_(complexity):20">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>a</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>a</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{a}(x)
  </annotation>
 </semantics>
</math>

) are also often used but those can be defined by means of the first three symbols. The base case is the predicates of <em>X</em> applied to some variables. One always implicitly has a predicate 

<math display="inline" id="FO_(complexity):21">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 for each letter 

<math display="inline" id="FO_(complexity):22">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 of an alphabet, stating that the letter at position 

<math display="inline" id="FO_(complexity):23">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is an 

<math display="inline" id="FO_(complexity):24">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg A
  </annotation>
 </semantics>
</math>

.</p>

<p>The semantics of the formulae in FO is straightforward, 

<math display="inline" id="FO_(complexity):25">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is true iff 

<math display="inline" id="FO_(complexity):26">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∧</mo>
   <mi>B</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>A</ci>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\wedge B
  </annotation>
 </semantics>
</math>

 is false, 

<math display="inline" id="FO_(complexity):27">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 is true iff 

<math display="inline" id="FO_(complexity):28">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 is true and 

<math display="inline" id="FO_(complexity):29">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mrow>
    <mi>x</mi>
    <mi>P</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <times></times>
     <ci>x</ci>
     <ci>P</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall xP(x)
  </annotation>
 </semantics>
</math>

 is true, and 

<math display="inline" id="FO_(complexity):30">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>v</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(v)
  </annotation>
 </semantics>
</math>

 is true iff 

<math display="inline" id="FO_(complexity):31">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 is true for all values 

<math display="inline" id="FO_(complexity):32">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 that 

<math display="inline" id="FO_(complexity):33">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>c</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>c</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(x_{1},\dots,x_{c})
  </annotation>
 </semantics>
</math>

 may take in the underlying universe. For <em>P</em> a <em>c</em>-ary predicate, 

<math display="inline" id="FO_(complexity):34">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}
  </annotation>
 </semantics>
</math>

 is true if and only if when 

<math display="inline" id="FO_(complexity):35">
 <semantics>
  <msub>
   <mi>n</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{i}
  </annotation>
 </semantics>
</math>

 is interpreted as 

<math display="inline" id="FO_(complexity):36">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>n</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>n</mi>
     <mi>c</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <ci>c</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(n_{1},\dots,n_{c})
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="FO_(complexity):37">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mo>,</mo>
   <mo>∃</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <csymbol cd="latexml">for-all</csymbol>
    <exists></exists>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall,\exists
  </annotation>
 </semantics>
</math>

 is true.</p>
<h2 id="property">Property</h2>
<h3 id="warning">Warning</h3>

<p>A query in FO will then be to check if a first-order formula is true over a given structure representing the input to the problem. One should not confuse this kind of problem with checking if a quantified boolean formula is true, which is the definition of <a href="Quantified_Boolean_formula_problem" title="wikilink">QBF</a>, which is <a class="uri" href="PSPACE-complete" title="wikilink">PSPACE-complete</a>. The difference between those two problems is that in QBF the size of the problem is the size of the formula and elements are just boolean values, whereas in FO the size of the problem is the size of the structure and the formula is fixed.</p>

<p>This is similar to <a href="Parameterized_complexity" title="wikilink">Parameterized complexity</a> but the size of the formula is not a fixed parameter.</p>
<h3 id="normal-form">Normal form</h3>

<p>Every formula is equivalent to a formula in <a href="prenex_normal_form" title="wikilink">prenex normal form</a> (where all quantifiers are written first, followed a quantifier-free formula).</p>
<h2 id="operators">Operators</h2>
<h3 id="fo-without-any-operators">FO without any operators</h3>

<p>In <a href="circuit_complexity" title="wikilink">circuit complexity</a>, <em>FO(ARB)</em> where <em>ARB</em> is the set of every predicates, the logic where we can use arbitrary predicates, can be shown to be equal to <a href="AC0" title="wikilink">AC<sup>0</sup></a>, the first class in the <a href="AC_(complexity)" title="wikilink">AC</a> hierarchy. Indeed, there is a natural translation from FO's symbols to nodes of circuits, with 

<math display="inline" id="FO_(complexity):38">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \land
  </annotation>
 </semantics>
</math>

 being 

<math display="inline" id="FO_(complexity):39">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lor
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="FO_(complexity):40">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 of size 

<math display="inline" id="FO_(complexity):41">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>x</ci>
    <ci>y</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x,y
  </annotation>
 </semantics>
</math>

.</p>

<p><em>FO(BIT)</em> is the restriction of AC<sup>0</sup> family of circuit constructible in <a href="LH_(complexity)" title="wikilink">alternative logarithmic time</a>. ''FO(k be an integer, 

<math display="inline" id="FO_(complexity):42">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 be vectors of 

<math display="inline" id="FO_(complexity):43">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 variables, 

<math display="inline" id="FO_(complexity):44">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 be a second-order variable of arity 

<math display="inline" id="FO_(complexity):45">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="FO_(complexity):46">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 be a FO(PFP,X) function using 

<math display="inline" id="FO_(complexity):47">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="FO_(complexity):48">
 <semantics>
  <msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>P</mi>
     <mi>i</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>i</mi>
    <mo>∈</mo>
    <mi>N</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <in></in>
     <ci>i</ci>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (P_{i})_{i\in N}
  </annotation>
 </semantics>
</math>

 as variables. We can iteratively define 

<math display="inline" id="FO_(complexity):49">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>P</mi>
     <mn>0</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mi>a</mi>
    <mi>l</mi>
    <mi>s</mi>
    <mi>e</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <cn type="integer">0</cn>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>a</ci>
     <ci>l</ci>
     <ci>s</ci>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{0}(x)=false
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="FO_(complexity):50">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>P</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>P</mi>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>,</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>P</ci>
      <ci>i</ci>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>ϕ</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>P</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>x</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}(x)=\phi(P_{i-1},x)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="FO_(complexity):51">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 (meaning 

<math display="inline" id="FO_(complexity):52">
 <semantics>
  <msub>
   <mi>P</mi>
   <mrow>
    <mi>i</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <apply>
     <minus></minus>
     <ci>i</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i-1}
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="FO_(complexity):53">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 substituted for the second-order variable 

<math display="inline" id="FO_(complexity):54">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>P</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (P_{i})
  </annotation>
 </semantics>
</math>

). Then, either there is a fixed point, or the list of 

<math display="inline" id="FO_(complexity):55">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ϕ</mi>
     <mrow>
      <mi>P</mi>
      <mo>,</mo>
      <mi>x</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <list>
      <ci>P</ci>
      <ci>x</ci>
     </list>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi_{P,x})(y)
  </annotation>
 </semantics>
</math>

s is cyclic.</p>

<p>PFP

<math display="inline" id="FO_(complexity):56">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>P</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (P_{i})
  </annotation>
 </semantics>
</math>

 is defined as the value of the fixed point of 

<math display="inline" id="FO_(complexity):57">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 on 

<math display="inline" id="FO_(complexity):58">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 if there is a fixed point, else as false. Since 

<math display="inline" id="FO_(complexity):59">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

s are properties of arity 

<math display="inline" id="FO_(complexity):60">
 <semantics>
  <msup>
   <mn>2</mn>
   <msup>
    <mi>n</mi>
    <mi>k</mi>
   </msup>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n^{k}}
  </annotation>
 </semantics>
</math>

, there are at most 

<math display="inline" id="FO_(complexity):61">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}
  </annotation>
 </semantics>
</math>

 values for the 

<math display="inline" id="FO_(complexity):62">
 <semantics>
  <msup>
   <mn>2</mn>
   <msup>
    <mi>n</mi>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n^{O(1)}}
  </annotation>
 </semantics>
</math>

s, so with a polynomial-space counter we can check if there is a loop or not.</p>

<p>It has been proven that FO(PFP,BIT) is equal to <a class="uri" href="PSPACE" title="wikilink">PSPACE</a>. This definition is equivalent to FO(

<math display="inline" id="FO_(complexity):63">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

).</p>
<h3 id="least-fixed-point-is-p">Least Fixed Point is P</h3>

<p>FO(LFP,X) is the set of boolean queries definable in FO(PFP,X) where the partial fixed point is limited to be monotone. That is, if the second order variable is 

<math display="inline" id="FO_(complexity):64">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>i</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>i</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}(x)
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="FO_(complexity):65">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i+1}(x)
  </annotation>
 </semantics>
</math>

 always implies 

<math display="inline" id="FO_(complexity):66">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

.</p>

<p>We can guarantee monotonicity by restricting the formula 

<math display="inline" id="FO_(complexity):67">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 to only contain positive occurrences of 

<math display="inline" id="FO_(complexity):68">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mrow>
    <mi>P</mi>
    <mo>,</mo>
    <mi>x</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <list>
     <ci>P</ci>
     <ci>x</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{P,x}
  </annotation>
 </semantics>
</math>

 (that is, occurrences preceded by an even number of negations). We can alternatively describe LFP(

<math display="inline" id="FO_(complexity):69">
 <semantics>
  <msub>
   <mi>ψ</mi>
   <mrow>
    <mi>P</mi>
    <mo>,</mo>
    <mi>x</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ψ</ci>
    <list>
     <ci>P</ci>
     <ci>x</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi_{P,x}
  </annotation>
 </semantics>
</math>

) as PFP(

<math display="inline" id="FO_(complexity):70">
 <semantics>
  <mrow>
   <mrow>
    <mi>ψ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>P</mi>
     <mo>,</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>P</mi>
      <mo>,</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∨</mo>
    <mrow>
     <mi>P</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>ψ</ci>
     <interval closure="open">
      <ci>P</ci>
      <ci>x</ci>
     </interval>
    </apply>
    <apply>
     <or></or>
     <apply>
      <times></times>
      <ci>ϕ</ci>
      <interval closure="open">
       <ci>P</ci>
       <ci>x</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi(P,x)=\phi(P,x)\vee P(x)
  </annotation>
 </semantics>
</math>

) where 

<math display="inline" id="FO_(complexity):71">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

.</p>

<p>Due to monotonicity, we only add vectors to the truth table of 

<math display="inline" id="FO_(complexity):72">
 <semantics>
  <msup>
   <mi>n</mi>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{k}
  </annotation>
 </semantics>
</math>

, and since there are only 

<math display="inline" id="FO_(complexity):73">
 <semantics>
  <msup>
   <mi>n</mi>
   <mi>k</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{k}
  </annotation>
 </semantics>
</math>

 possible vectors we will always find a fixed point before 

<math display="inline" id="FO_(complexity):74">
 <semantics>
  <msup>
   <mi>n</mi>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <apply>
     <times></times>
     <ci>O</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{O(1)}
  </annotation>
 </semantics>
</math>

 iterations. Hence it can be shown that FO(LFP,BIT)=<a href="P_(complexity)" title="wikilink">P</a>. This definition is equivalent to FO(

<math display="inline" id="FO_(complexity):75">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

).</p>
<h3 id="transitive-closure-is-nl">Transitive closure is NL</h3>

<p>FO(TC,X) is the set of boolean queries definable in FO(X) with a transitive closure (TC) operator.</p>

<p>TC is defined this way: let 

<math display="inline" id="FO_(complexity):76">
 <semantics>
  <mrow>
   <mi>u</mi>
   <mo>,</mo>
   <mi>v</mi>
   <mo>,</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>u</ci>
    <ci>v</ci>
    <ci>x</ci>
    <ci>y</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u,v,x,y
  </annotation>
 </semantics>
</math>

 be a positive integer and 

<math display="inline" id="FO_(complexity):77">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 be vector of 

<math display="inline" id="FO_(complexity):78">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ϕ</mi>
     <mrow>
      <mi>u</mi>
      <mo>,</mo>
      <mi>v</mi>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ϕ</ci>
     <list>
      <ci>u</ci>
      <ci>v</ci>
     </list>
    </apply>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\phi_{u,v})(x,y)
  </annotation>
 </semantics>
</math>

 variables. Then TC

<math display="inline" id="FO_(complexity):79">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 is true if there exist 

<math display="inline" id="FO_(complexity):80">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>z</mi>
    <mi>i</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>z</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (z_{i})
  </annotation>
 </semantics>
</math>

 vectors of variables 

<math display="inline" id="FO_(complexity):81">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>z</mi>
     <mn>1</mn>
    </msub>
    <mo>=</mo>
    <mi>x</mi>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msub>
     <mi>z</mi>
     <mi>n</mi>
    </msub>
    <mo>=</mo>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <ci>n</ci>
     </apply>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z_{1}=x,z_{n}=y
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="FO_(complexity):82">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

, and for all 

<math display="inline" id="FO_(complexity):83">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(x,y)
  </annotation>
 </semantics>
</math>

 is true. Here, 

<math display="inline" id="FO_(complexity):84">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

 is a formula written in FO(TC) and 

<math display="inline" id="FO_(complexity):85">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

 means that the variables 

<math display="inline" id="FO_(complexity):86">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="FO_(complexity):87">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 are replaced by 

<math display="inline" id="FO_(complexity):88">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mrow>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <list>
     <ci>u</ci>
     <ci>v</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{u,v}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="FO_(complexity):89">
 <semantics>
  <mi>u</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>u</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u
  </annotation>
 </semantics>
</math>

.</p>

<p>FO(TC,BIT) is equal to <a href="NL_(complexity)" title="wikilink">NL</a>.</p>
<h3 id="deterministic-transitive-closure-is-l">Deterministic transitive closure is L</h3>

<p>FO(DTC,X) is defined as FO(TC,X) where the transitive closure operator is deterministic. This means that when we apply DTC(

<math display="inline" id="FO_(complexity):90">
 <semantics>
  <mi>v</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>v</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v
  </annotation>
 </semantics>
</math>

), we know that for all 

<math display="inline" id="FO_(complexity):91">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <interval closure="open">
     <ci>u</ci>
     <ci>v</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(u,v)
  </annotation>
 </semantics>
</math>

, there exists at most one 

<math display="inline" id="FO_(complexity):92">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mrow>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <list>
     <ci>u</ci>
     <ci>v</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{u,v}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="FO_(complexity):93">
 <semantics>
  <msub>
   <mi>ψ</mi>
   <mrow>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ψ</ci>
    <list>
     <ci>u</ci>
     <ci>v</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi_{u,v}
  </annotation>
 </semantics>
</math>

.</p>

<p>We can suppose that DTC(

<math display="inline" id="FO_(complexity):94">
 <semantics>
  <mrow>
   <mi>ψ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>u</mi>
    <mo>,</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mo>∀</mo>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>=</mo>
    <mi>v</mi>
    <mo>∨</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>u</mi>
     <mo>,</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">ψ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">ϕ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <csymbol cd="unknown">v</csymbol>
     <or></or>
     <not></not>
     <csymbol cd="unknown">ϕ</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">u</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi(u,v)=\phi(u,v)\wedge\forall x(x=v\vee\neg\phi(u,x))
  </annotation>
 </semantics>
</math>

) is <a href="syntactic_sugar" title="wikilink">syntactic sugar</a> for TC(

<math display="inline" id="FO_(complexity):95">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>,</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <cn type="integer">0</cn>
    <apply>
     <minus></minus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0,(n-1)
  </annotation>
 </semantics>
</math>

) where 

<math display="inline" id="FO_(complexity):96">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(n)
  </annotation>
 </semantics>
</math>

.</p>

<p>It has been shown that FO(DTC,BIT) is equal to <a href="L_(complexity)" title="wikilink">L</a>.</p>
<h3 id="normal-form-1">Normal form</h3>

<p>Any formula with a fixed point (resp. transitive cosure) operator can without loss of generality be written with exactly one application of the operators applied to 0 (resp. 

<math display="inline" id="FO_(complexity):97">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(n)
  </annotation>
 </semantics>
</math>

)</p>
<h2 id="iterating">Iterating</h2>

<p>We will define first-order with iteration, <strong>'FO[

<math display="inline" id="FO_(complexity):98">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(n)
  </annotation>
 </semantics>
</math>

]</strong>'; here 

<math display="inline" id="FO_(complexity):99">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(n)
  </annotation>
 </semantics>
</math>

 is a (class of) functions from integers to integers, and for different classes of functions 

<math display="inline" id="FO_(complexity):100">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <mi>x</mi>
      <mi>P</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>P</ci>
     </apply>
    </apply>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall xP)Q
  </annotation>
 </semantics>
</math>

 we will obtain different complexity classes FO[

<math display="inline" id="FO_(complexity):101">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mo>∀</mo>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo>⇒</mo>
    <mi>Q</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-(</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-⇒</ci>
     <csymbol cd="unknown">Q</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-)</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall x(P\Rightarrow Q))
  </annotation>
 </semantics>
</math>

].</p>

<p>In this section we will write 

<math display="inline" id="FO_(complexity):102">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <mi>x</mi>
      <mi>P</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <ci>x</ci>
      <ci>P</ci>
     </apply>
    </apply>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\exists xP)Q
  </annotation>
 </semantics>
</math>

 to mean 

<math display="inline" id="FO_(complexity):103">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>P</mi>
       <mo>∨</mo>
       <mi>Q</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <apply>
     <times></times>
     <ci>x</ci>
     <apply>
      <or></or>
      <ci>P</ci>
      <ci>Q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\exists x(P\vee Q))
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="FO_(complexity):104">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>Q</mi>
      <mn>1</mn>
     </msub>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
    </mrow>
    <mo>,</mo>
    <msub>
     <mi>ϕ</mi>
     <mn>1</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="normal">…</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>Q</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mo>,</mo>
    <msub>
     <mi>ϕ</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <interval closure="open">
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <cn type="integer">1</cn>
     </apply>
    </interval>
    <ci>normal-…</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Q</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ϕ</ci>
      <ci>k</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Q_{1}x_{1},\phi_{1})...(Q_{k}x_{k},\phi_{k})
  </annotation>
 </semantics>
</math>

 to mean 

<math display="inline" id="FO_(complexity):105">
 <semantics>
  <msub>
   <mi>ϕ</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ϕ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi_{i}
  </annotation>
 </semantics>
</math>

. We first need to define quantifier blocks (QB), a quantifier block is a list 

<math display="inline" id="FO_(complexity):106">
 <semantics>
  <msub>
   <mi>Q</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Q</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{i}
  </annotation>
 </semantics>
</math>

 where the 

<math display="inline" id="FO_(complexity):107">
 <semantics>
  <mo>∀</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">for-all</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall
  </annotation>
 </semantics>
</math>

s are quantifier-free <a href="#Complexity_Zoo:F#FO" title="wikilink">FO</a>-formulae and 

<math display="inline" id="FO_(complexity):108">
 <semantics>
  <mo>∃</mo>
  <annotation-xml encoding="MathML-Content">
   <exists></exists>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists
  </annotation>
 </semantics>
</math>

s are either 

<math display="inline" id="FO_(complexity):109">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="FO_(complexity):110">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>Q</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mrow>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>Q</ci>
    </apply>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [Q]^{t(n)}
  </annotation>
 </semantics>
</math>

. If 

<math display="inline" id="FO_(complexity):111">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is a quantifiers block then we will call 

<math display="inline" id="FO_(complexity):112">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(n)
  </annotation>
 </semantics>
</math>

 the iteration operator, which is defined as 

<math display="inline" id="FO_(complexity):113">
 <semantics>
  <mrow>
   <mrow>
    <mi>k</mi>
    <mo>*</mo>
    <mi>t</mi>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <times></times>
     <ci>k</ci>
     <ci>t</ci>
    </apply>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k*t(n)
  </annotation>
 </semantics>
</math>

 written 

<math display="inline" id="FO_(complexity):114">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 time. One should pay attention that here there are 

<math display="inline" id="FO_(complexity):115">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(n)
  </annotation>
 </semantics>
</math>

 quantifiers in the list, but only 

<math display="inline" id="FO_(complexity):116">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(n)
  </annotation>
 </semantics>
</math>

 variables and each of those variable are used 

<math display="inline" id="FO_(complexity):117">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(n)
  </annotation>
 </semantics>
</math>

 times.</p>

<p>We can now define FO[

<math display="inline" id="FO_(complexity):118">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>i</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\log n)^{i}
  </annotation>
 </semantics>
</math>

] to be the FO-formulae with an iteration operator whose exponent is in the class 

<math display="inline" id="FO_(complexity):119">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(n)
  </annotation>
 </semantics>
</math>

, and we obtain those equalities:</p>
<ul>
<li>FO[

<math display="inline" id="FO_(complexity):120">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(n)
  </annotation>
 </semantics>
</math>

] is equal to FO-uniform <a href="AC_(complexity)" title="wikilink">AC<sup>i</sup></a>, and in fact FO[

<math display="inline" id="FO_(complexity):121">
 <semantics>
  <msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\log n)^{O(1)}
  </annotation>
 </semantics>
</math>

] is FO-uniform AC of depth 

<math display="inline" id="FO_(complexity):122">
 <semantics>
  <msup>
   <mi>n</mi>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <apply>
     <times></times>
     <ci>O</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{O(1)}
  </annotation>
 </semantics>
</math>

.</li>
<li>FO[

<math display="inline" id="FO_(complexity):123">
 <semantics>
  <msup>
   <mn>2</mn>
   <msup>
    <mi>n</mi>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n^{O(1)}}
  </annotation>
 </semantics>
</math>

] is equal to <a href="#NC_(complexity)" title="wikilink">NC</a>.</li>
<li>FO[

<math display="inline" id="FO_(complexity):124">
 <semantics>
  <mrow>
   <mi>succ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">x</mi>
    <mo>,</mo>
    <mi mathvariant="normal">y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>succ</ci>
    <interval closure="open">
     <ci>normal-x</ci>
     <ci>normal-y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rm{succ}(x,y)
  </annotation>
 </semantics>
</math>

] is equal to <a href="P_(complexity)" title="wikilink">PTIME</a>, it is also another way to write |FO(LFP).</li>
<li>FO[

<math display="inline" id="FO_(complexity):125">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x+1=y
  </annotation>
 </semantics>
</math>

] is equal to <a class="uri" href="PSPACE" title="wikilink">PSPACE</a>, it is also another way to write <a href="#Complexity_Zoo:F#fopfp" title="wikilink">FO(PFP)</a>.</li>
</ul>
<h2 id="logic-without-arithmetical-relations">Logic without arithmetical relations</h2>

<p>Let the successor relation, <em>succ</em>, be a binary relation such that 

<math display="inline" id="FO_(complexity):126">
 <semantics>
  <mrow>
   <mrow>
    <mi>plus</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">a</mi>
     <mo>,</mo>
     <mi mathvariant="normal">b</mi>
     <mo>,</mo>
     <mi mathvariant="normal">c</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>DTC</mi>
        <mrow>
         <mi mathvariant="normal">v</mi>
         <mo>,</mo>
         <mi mathvariant="normal">x</mi>
         <mo>,</mo>
         <mi mathvariant="normal">y</mi>
         <mo>,</mo>
         <mi mathvariant="normal">z</mi>
        </mrow>
       </msub>
       <mi>succ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi mathvariant="normal">v</mi>
        <mo>,</mo>
        <mi mathvariant="normal">y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>∧</mo>
      <mrow>
       <mi>succ</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi mathvariant="normal">z</mi>
        <mo>,</mo>
        <mi mathvariant="normal">x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">a</mi>
     <mo>,</mo>
     <mi mathvariant="normal">b</mi>
     <mo>,</mo>
     <mi mathvariant="normal">c</mi>
     <mo>,</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>plus</ci>
     <vector>
      <ci>normal-a</ci>
      <ci>normal-b</ci>
      <ci>normal-c</ci>
     </vector>
    </apply>
    <apply>
     <times></times>
     <apply>
      <and></and>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>DTC</ci>
        <list>
         <ci>normal-v</ci>
         <ci>normal-x</ci>
         <ci>normal-y</ci>
         <ci>normal-z</ci>
        </list>
       </apply>
       <ci>succ</ci>
       <interval closure="open">
        <ci>normal-v</ci>
        <ci>normal-y</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>succ</ci>
       <interval closure="open">
        <ci>normal-z</ci>
        <ci>normal-x</ci>
       </interval>
      </apply>
     </apply>
     <vector>
      <ci>normal-a</ci>
      <ci>normal-b</ci>
      <ci>normal-c</ci>
      <cn type="integer">0</cn>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rm{plus}(a,b,c)=(\rm{DTC}_{v,x,y,z}\rm{succ}(v,y)\land\rm{succ}(z,x))(a,b,c,0)
  </annotation>
 </semantics>
</math>

 is true if and only if 

<math display="inline" id="FO_(complexity):127">
 <semantics>
  <mrow>
   <mrow>
    <mi>bit</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">a</mi>
     <mo>,</mo>
     <mi mathvariant="normal">b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>DTC</mi>
       <mrow>
        <mi mathvariant="normal">a</mi>
        <mo>,</mo>
        <mi mathvariant="normal">b</mi>
        <mo>,</mo>
        <msup>
         <mi mathvariant="normal">a</mi>
         <mo>′</mo>
        </msup>
        <mo>,</mo>
        <msup>
         <mi mathvariant="normal">b</mi>
         <mo>′</mo>
        </msup>
       </mrow>
      </msub>
      <mi>ψ</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">a</mi>
     <mo>,</mo>
     <mi mathvariant="normal">b</mi>
     <mo>,</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>bit</ci>
     <interval closure="open">
      <ci>normal-a</ci>
      <ci>normal-b</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>DTC</ci>
       <list>
        <ci>normal-a</ci>
        <ci>normal-b</ci>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-a</ci>
         <ci>normal-′</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>normal-b</ci>
         <ci>normal-′</ci>
        </apply>
       </list>
      </apply>
      <ci>ψ</ci>
     </apply>
     <vector>
      <ci>normal-a</ci>
      <ci>normal-b</ci>
      <cn type="integer">1</cn>
      <cn type="integer">0</cn>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rm{bit}(a,b)=(\rm{DTC}_{a,b,a^{\prime},b^{\prime}}\psi)(a,b,1,0)
  </annotation>
 </semantics>
</math>

.</p>

<p>Over first order logic, <em>succ</em> is strictly less expressive than \times are as expressive as <em>bit</em>.</p>
<h3 id="using-successor-to-define-bit">Using successor to define <em>bit</em></h3>

<p>It is possible to define the <em>plus</em> and then the <em>bit</em> relations with a deterministic transitive closure.</p>

<p>

<math display="inline" id="FO_(complexity):128">
 <semantics>
  <mrow>
   <mi>ψ</mi>
   <mo>=</mo>
   <mtext>if</mtext>
   <mi>b</mi>
   <mo>=</mo>
   <mn>0</mn>
   <mtext>then</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mtext>if</mtext>
    <mo>∃</mo>
    <mi>m</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>=</mo>
     <mi>m</mi>
     <mo>+</mo>
     <mi>m</mi>
     <mo>+</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mtext>then</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>a</mi>
      <mo>′</mo>
     </msup>
     <mo>=</mo>
     <mn>1</mn>
     <mo>∧</mo>
     <msup>
      <mi>b</mi>
      <mo>′</mo>
     </msup>
     <mo>=</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mtext>else</mtext>
    <mo>⊥</mo>
    <mo stretchy="false">)</mo>
   </mrow>
   <mtext>else</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>succ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi mathvariant="normal">b</mi>
      <mo>′</mo>
     </msup>
     <mo>,</mo>
     <mi mathvariant="normal">b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">a</mi>
     <mo>+</mo>
     <mi mathvariant="normal">a</mi>
     <mo>=</mo>
     <msup>
      <mi mathvariant="normal">a</mi>
      <mo>′</mo>
     </msup>
     <mo>∨</mo>
     <mi mathvariant="normal">a</mi>
     <mo>+</mo>
     <mi mathvariant="normal">a</mi>
     <mo>+</mo>
     <mn>1</mn>
     <mo>=</mo>
     <msup>
      <mi mathvariant="normal">a</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">ψ</csymbol>
    <eq></eq>
    <mtext>if</mtext>
    <csymbol cd="unknown">b</csymbol>
    <eq></eq>
    <cn type="integer">0</cn>
    <mtext>then</mtext>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <mtext>if</mtext>
     <exists></exists>
     <csymbol cd="unknown">m</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">a</csymbol>
      <eq></eq>
      <csymbol cd="unknown">m</csymbol>
      <plus></plus>
      <csymbol cd="unknown">m</csymbol>
      <plus></plus>
      <cn type="integer">1</cn>
      <ci>normal-)</ci>
     </cerror>
     <mtext>then</mtext>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>a</ci>
       <ci>normal-′</ci>
      </apply>
      <eq></eq>
      <cn type="integer">1</cn>
      <and></and>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>b</ci>
       <ci>normal-′</ci>
      </apply>
      <eq></eq>
      <cn type="integer">0</cn>
      <ci>normal-)</ci>
     </cerror>
     <mtext>else</mtext>
     <csymbol cd="latexml">bottom</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <mtext>else</mtext>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">succ</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-b</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>normal-,</ci>
      <csymbol cd="unknown">b</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">a</csymbol>
      <plus></plus>
      <csymbol cd="unknown">a</csymbol>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-a</ci>
       <ci>normal-′</ci>
      </apply>
      <or></or>
      <csymbol cd="unknown">a</csymbol>
      <plus></plus>
      <csymbol cd="unknown">a</csymbol>
      <plus></plus>
      <cn type="integer">1</cn>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>normal-a</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi=\text{if }b=0\text{ then }(\text{if }\exists m(a=m+m+1)\text{ then }(a^{%
\prime}=1\land b^{\prime}=0)\text{ else }\bot)\text{ else }(\rm{succ}(b^{%
\prime},b)\land(a+a=a^{\prime}\lor a+a+1=a^{\prime})
  </annotation>
 </semantics>
</math>

 and</p>

<p>

<math display="inline" id="FO_(complexity):129">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 with</p>

<p>

<math display="inline" id="FO_(complexity):130">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>b</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b>0
  </annotation>
 </semantics>
</math>

</p>

<p>This just means that when we query for bit 0 we check the parity, and go to (1,0) if 

<math display="inline" id="FO_(complexity):131">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is odd(which is an accepting state), else we reject. If we check a bit 

<math display="inline" id="FO_(complexity):132">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>b</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b-1
  </annotation>
 </semantics>
</math>

, we divide <span class="LaTeX">$a$</span> by 2 and check bit <span class="LaTeX">$b-1$</span>.</p>

<p>Hence it makes no sense to speak of operators with successor alone, without the other predicates.</p>
<h3 id="logics-without-successor">Logics without successor</h3>

<p><em>FO[LFP]</em> and <em>FO[PFP]</em> are two logics without any predicates, apart from the equality predicates between variables and the letters predicates. They are equal respectively to <em>relational-P</em> and FO(PFP) is <em>relational-PSPACE</em>, the classes P and PSPACE over <a href="relational_machines" title="wikilink">relational machines</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The <a href="Abiteboul-Vianu_Theorem" title="wikilink">Abiteboul-Vianu Theorem</a> states that FO(LFP)=FO(PFP) if and only if FO( This shows that the order problem in first order is more a technical problem than a fundamental one.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="Ronald_Fagin" title="wikilink">Ronald Fagin</a>, <a href="http://www.almaden.ibm.com/cs/people/fagin/genspec.pdf">Generalized First-Order Spectra and Polynomial-Time Recognizable Sets</a>. <em>Complexity of Computation</em>, ed. R. Karp, SIAM-AMS Proceedings 7, pp. 27–41. 1974.</li>
<li>Ronald Fagin, <a href="http://www.almaden.ibm.com/cs/people/fagin/tcs93.pdf">Finite model theory-a personal perspective</a>. Theoretical Computer Science 116, 1993, pp. 3–31.</li>
<li>Neil Immerman. <a href="http://www.cs.umass.edu/~immerman/pub/capture.pdf">Languages Which Capture Complexity Classes</a>. <em>15th ACM STOC Symposium</em>, pp. 347–354. 1983.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.cs.umass.edu/~immerman/descriptive_complexity.html">Neil Immerman's descriptive complexity page</a>, including a diagram</li>
<li><a href="https://complexityzoo.uwaterloo.ca/Complexity_Zoo:F#fo">Complexity zoo about FO</a>, see also the following classes</li>
</ul>

<p>"</p>

<p><a href="Category:Descriptive_complexity" title="wikilink"> </a> <a href="Category:Finite_model_theory" title="wikilink">Category:Finite model theory</a> <a href="Category:Complexity_classes" title="wikilink">Category:Complexity classes</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Serge Abiteboul, <a href="Moshe_Y._Vardi" title="wikilink">Moshe Y. Vardi</a>, <a href="Victor_Vianu" title="wikilink">Victor Vianu</a>: <a href="http://portal.acm.org/citation.cfm?id=256295">Fixpoint logics, relational machines, and computational complexity</a> Journal of the ACM (JACM) archive, Volume 44 , Issue 1 (January 1997), Pages: 30-56, ISSN:0004-5411<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
