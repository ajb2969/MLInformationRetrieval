<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="344">Mean value analysis</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Mean value analysis</h1>
<hr/>

<p>In <a href="queueing_theory" title="wikilink">queueing theory</a>, a discipline within the mathematical <a href="theory_of_probability" title="wikilink">theory of probability</a>, <strong>mean value analysis (MVA)</strong> is a recursive technique for computing <a href="expected_value" title="wikilink">expected</a> queue lengths, waiting time at queueing nodes and throughput in equilibrium for a closed separable system of queues. The first approximate techniques were published independently by Schweitzer<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and Bard,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> followed later by an exact version by Lavenberg and Reiser published in 1980.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>It is based on the <a href="arrival_theorem" title="wikilink">arrival theorem</a>, which states that when one customer in an <em>M</em>-customer closed system arrives at a service facility he/she observes the rest of the system to be in the equilibrium state for a system with <em>M</em> − 1 customers.</p>
<h2 id="problem-setup">Problem setup</h2>

<p>Consider a closed queueing network of <em>K</em> <a href="M/M/1_queue" title="wikilink">M/M/1 queues</a>, with <em>M</em> customers circulating in the system. To compute the mean queue length and waiting time at each of the nodes and throughput of the system we use an iterative algorithm starting with a network with 0 customers.</p>

<p>Write <em>μ</em><sub><em>i</em></sub> for the service rate at node <em>i</em> and <em>P</em> for the customer routing matrix where element <em>p</em><sub><em>ij</em></sub> denotes the probability that a customer finishing service at node <em>i</em> moves to node <em>j</em> for service. To use the algorithm we first compute the visit ratio row vector <strong>v</strong>, a vector such that <strong>v</strong> = <strong>v</strong> P.</p>

<p>Now write <em>L</em><sub><em>i</em></sub>(<em>n</em>) for the mean number of customer at queue <em>i</em> when there are a total of <em>n</em> customers in the system (this includes the job currently being served at queue <em>i</em>) and <em>W</em><sub><em>j</em></sub>(<em>n</em>) for the mean time spent by a customer in queue <em>i</em> when there are a total of <em>n</em> customers in the system. Denote the throughput of a system with <em>m</em> customers by <em>λ</em><sub><em>m</em></sub>.</p>
<h2 id="algorithm">Algorithm</h2>

<p>The algorithm<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> starts with an empty network (zero customers), then increases the number of customers by 1 at each iteration until there are the required number (<em>M</em>) of customers in the system.</p>

<p>To initialise, set <em>L</em><sub><em>k</em></sub>(0) = 0 for <em>k</em> = 1,...,<em>K</em>. (This sets the average queue length in a system with no customers to zero at all nodes.)</p>

<p>Repeat for <em>m</em> = 1,...,<em>M</em>:</p>
<dl>
<dd>1. For <em>k</em> = 1, ..., <em>K</em> compute the waiting time at each node using the arrival theorem
<dl>
<dd><dl>
<dd>

<math display="inline" id="Mean_value_analysis:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>W</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>m</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mrow>
       <msub>
        <mi>L</mi>
        <mi>k</mi>
       </msub>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mi>m</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <msub>
      <mi>μ</mi>
      <mi>k</mi>
     </msub>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <ci>k</ci>
     </apply>
     <ci>m</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <minus></minus>
        <ci>m</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>μ</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{k}(m)=\frac{L_{k}\left(m-1\right)+1}{\mu_{k}}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
</dd>
<dd>2. Then compute the system throughput using Little's law
<dl>
<dd><dl>
<dd>

<math display="inline" id="Mean_value_analysis:1">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>λ</mi>
     <mi>m</mi>
    </msub>
    <mo>=</mo>
    <mfrac>
     <mi>m</mi>
     <mrow>
      <mstyle displaystyle="false">
       <msubsup>
        <mo largeop="true" symmetric="true">∑</mo>
        <mrow>
         <mi>k</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>K</mi>
       </msubsup>
      </mstyle>
      <mrow>
       <msub>
        <mi>W</mi>
        <mi>k</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>m</mi>
        <mo stretchy="false">)</mo>
       </mrow>
       <msub>
        <mi>v</mi>
        <mi>k</mi>
       </msub>
      </mrow>
     </mrow>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>λ</ci>
     <ci>m</ci>
    </apply>
    <apply>
     <divide></divide>
     <ci>m</ci>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>K</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>W</ci>
        <ci>k</ci>
       </apply>
       <ci>m</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda_{m}=\frac{m}{\sum_{k=1}^{K}W_{k}(m)v_{k}}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
</dd>
<dd>3. Finally, use little's law applied to each queue to compute the mean queue lengths for <em>k</em> = 1, ..., <em>K</em>
<dl>
<dd><dl>
<dd>

<math display="inline" id="Mean_value_analysis:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>L</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>m</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>v</mi>
      <mi>k</mi>
     </msub>
     <msub>
      <mi>λ</mi>
      <mi>m</mi>
     </msub>
     <msub>
      <mi>W</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>m</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>k</ci>
     </apply>
     <ci>m</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>v</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>λ</ci>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>W</ci>
      <ci>k</ci>
     </apply>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{k}(m)=v_{k}\lambda_{m}W_{k}(m).
  </annotation>
 </semantics>
</math>


</dd>
</dl>
</dd>
</dl>
</dd>
</dl>

<p>End repeat.</p>
<h2 id="schweitzers-approximation">Schweitzer's approximation</h2>

<p>Schweitzer's approximation estimates the average number of jobs at node <em>k</em> to be<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>

<math display="block" id="Mean_value_analysis:3">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>L</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>m</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mi>m</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
     <mi>m</mi>
    </mfrac>
    <msub>
     <mi>L</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>m</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>m</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>k</ci>
     </apply>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{k}(m-1)\approx\frac{m-1}{m}L_{k}(m)
  </annotation>
 </semantics>
</math>

</p>

<p>which from the above formulas yields <a href="fixed-point_iteration" title="wikilink">fixed-point relationships</a> which can be solved numerically. This iterative approach is typically faster than the recursive approach of MVA.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h3 id="pseudo-code">Pseudo-code</h3>

<p><code>
set ''L''<sub>''k''</sub>(''m'') = ''M''/''K''

repeat until convergence:

::<math>\lambda_m = \frac{m}{\sum_{k=1}^K \frac{\frac{m-1}{m}L_k(m) + 1}{\mu_k} v_k}</math>
::<math>L_k(m) = v_k \lambda_m \frac{\frac{m-1}{m}L_k(m) + 1}{\mu_k}</math>
</code></p>
<h2 id="multiclass-networks">Multiclass networks</h2>

<p>For networks with a single customer class the MVA algorithm is very fast and time taken grows linearly with the number of customers and number of queues. However, the number of multiplications and additions required for MVA grows exponentially with the number of customer classes. Practically, the algorithm works for 3-4 customer classes.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> The <em>method of moments</em> is an exact method which required log-quadratic time and can solve in practice models with up to 10 classes of customers.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> Approximate algorithms have also been proposed with lower complexity.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<h2 id="extensions">Extensions</h2>

<p>The mean value analysis algorithm has been applied to a class of <a class="uri" href="PEPA" title="wikilink">PEPA</a> models describing <a href="queueing_network" title="wikilink">queueing networks</a> and the performance of a <a href="key_distribution_center" title="wikilink">key distribution center</a>.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>
<h2 id="software">Software</h2>
<ul>
<li><a href="http://jmt.sourceforge.net/JMVA.html">JMVA</a>, a tool written in <a href="Java_(programming_language)" title="wikilink">Java</a> which implements MVA.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></li>
<li><a href="http://www.moreno.marzolla.name/software/queueing/">queueing</a>, a library for <a href="GNU_Octave" title="wikilink">GNU Octave</a> which includes MVA.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.netlab.tkk.fi/opetus/s383143/kalvot/E_qnets.pdf">J. Virtamo: Queuing networks</a>. Handout from Helsinki Tech gives good overview of Jackson's Theorem and MVA.</li>
<li><a href="http://www.cs.utexas.edu/users/lam/Vita/Jpapers/Lam83.pdf">Simon Lam: A simple derivation of the MVA algorithm</a>. Shows relationship between <a href="Buzen's_algorithm" title="wikilink">Buzen's algorithm</a> and MVA.</li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Stochastic_processes" title="wikilink">Category:Stochastic processes</a> <a href="Category:Queueing_theory" title="wikilink">Category:Queueing theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
</ol>
</section>
</body>
</html>
