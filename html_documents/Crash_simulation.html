<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1148">Crash simulation</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Crash simulation</h1>
<hr/>

<p><embed src="Traffic-accidents-pmed.1000250.s002.ogv" title="fig:A crash simulation with a slender (left) and obese (right) female passenger."></embed> A <strong>crash simulation</strong> is a <a href="Virtuality" title="wikilink">virtual</a> recreation of a destructive <a href="crash_test" title="wikilink">crash test</a> of a <a class="uri" href="car" title="wikilink">car</a> or a highway <a href="Traffic_barrier" title="wikilink">guard rail system</a> using a <a href="computer_simulation" title="wikilink">computer simulation</a> in order to examine the level of safety of the car and its occupants. Crash <a href="simulation" title="wikilink">simulations</a> are used by <a href="automaker" title="wikilink">automakers</a> during <a href="computer-aided_engineering" title="wikilink">computer-aided engineering</a> (CAE) analysis for <a class="uri" href="crashworthiness" title="wikilink">crashworthiness</a> in the <a href="computer-aided_design" title="wikilink">computer-aided design</a> (CAD) process of modelling new cars. During a crash simulation, the <a href="kinetic_energy" title="wikilink">kinetic energy</a>, or energy of motion, that a <a class="uri" href="vehicle" title="wikilink">vehicle</a> has before the impact is transformed into <a href="Deformation_(engineering)" title="wikilink">deformation</a> <a class="uri" href="energy" title="wikilink">energy</a>, mostly by <a href="plastic_deformation" title="wikilink">plastic deformation</a> (<a href="Plasticity_(physics)" title="wikilink">plasticity</a>) of the car body material (<a href="Body_in_White" title="wikilink">Body in White</a>), at the end of the impact.</p>

<p>Data obtained from a crash simulation indicate the capability of the car body or guard rail structure to protect the vehicle occupants during a <a class="uri" href="collision" title="wikilink">collision</a> (and also <a href="pedestrian" title="wikilink">pedestrians</a> hit by a car) against <a class="uri" href="injury" title="wikilink">injury</a>. Important results are the deformations (for example, <a href="steering_wheel" title="wikilink">steering wheel</a> intrusions) of the occupant space (driver, <a href="passenger" title="wikilink">passengers</a>) and the <a href="deceleration" title="wikilink">decelerations</a> (for example, head acceleration) felt by them, which must fall below threshold values fixed in legal <a href="car_safety" title="wikilink">car safety</a> <a class="uri" href="regulations" title="wikilink">regulations</a>. To model real crash tests, today's crash simulations include virtual models of <a href="crash_test_dummy" title="wikilink">crash test dummies</a> and of passive safety devices (<a href="seat_belts" title="wikilink">seat belts</a>, <a class="uri" href="airbags" title="wikilink">airbags</a>, shock absorbing <a href="dash_boards" title="wikilink">dash boards</a>, etc.). Guide rail tests evaluate vehicle deceleration and rollover potential, as well as penetration of the barrier by vehicles.</p>
<h2 id="origin">Origin</h2>

<p>In the years 1970 attempts were made to simulate car crash events with <a class="uri" href="non-linear" title="wikilink">non-linear</a> spring-mass systems after <a class="uri" href="calibration" title="wikilink">calibration</a>, which require as an input the results of physical destructive laboratory tests, needed to determine the mechanical crushing behavior of each spring component of the modeled system. "<a href="First_principle" title="wikilink">First principle</a>" simulations like more elaborate finite element models, however, need only the definition of the structural geometry and the basic material properties (<a class="uri" href="rheology" title="wikilink">rheology</a> of car body steel, glass, plastic parts, etc.) as an input to generate the numerical model.</p>

<p>The origins of industrial first principle computerized car crash simulation lie in <a href="military_defense" title="wikilink">military defense</a>, <a href="outer_space" title="wikilink">outer space</a> and civil <a href="nuclear_power_plant" title="wikilink">nuclear power plant</a> applications. Upon presentation of a simulation of the accidental crash of a military <a href="fighter_aircraft" title="wikilink">fighter</a> plane into a nuclear power plant on May 30, 1978 by <a href="http://www.esi-group.com">ESI Group</a> in a meeting organized by the <a href="Verein_Deutscher_Ingenieure" title="wikilink">Verein Deutscher Ingenieure</a> (VDI) in Stuttgart, car makers became alerted to the possibility of using this technology for the simulation of destructive car crash tests (Haug 1981).</p>

<p> In the following years, German car makers produced more complex crash simulation studies, simulating the crash behavior of individual car body components, component assemblies, and quarter and half car bodies in white (<a href="Body_in_White" title="wikilink">BIW</a>). These experiments culminated in a joint project by the Forschungsgemeinschaft Automobil-Technik (FAT), a conglomeration of all seven German car makers (<a class="uri" href="Audi" title="wikilink">Audi</a>, <a class="uri" href="BMW" title="wikilink">BMW</a>, <a href="Ford_Motor_Company" title="wikilink">Ford</a>, <a class="uri" href="Mercedes-Benz" title="wikilink">Mercedes-Benz</a>, <a class="uri" href="Opel" title="wikilink">Opel</a>, <a class="uri" href="Porsche" title="wikilink">Porsche</a>, and <a class="uri" href="Volkswagen" title="wikilink">Volkswagen</a>), which tested the applicability of two emerging commercial crash simulation codes. These simulation codes recreated a frontal impact of a full passenger car structure (Haug 1986) and they ran to completion on a computer overnight. Now that turn-around time between two consecutive job-submissions (computer runs) did not exceed one day, engineers were able to make efficient and progressive improvements of the crash behavior of the analyzed car body structure.</p>
<h2 id="application">Application</h2>

<p>Crash simulations are used to investigate the <a class="uri" href="safety" title="wikilink">safety</a> of the car occupants during impacts on the front end structure of the car in a "<a href="head-on_collision" title="wikilink">head-on collision</a>" or "frontal impact", the lateral structure of the car in a “<a href="side_collision" title="wikilink">side collision</a>” or “side impact”, the rear end structure of a car in a "<a href="rear-end_collision" title="wikilink">rear-end collision</a>" or “rear impact”, and the roof structure of the car when it overturns during a "<a class="uri" href="rollover" title="wikilink">rollover</a>". Crash simulations can also be used to assess injury to <a class="uri" href="pedestrians" title="wikilink">pedestrians</a> hit by a car.</p>
<h2 id="benefits">Benefits</h2>

<p>A crash simulation produces results without actual <a href="destructive_testing" title="wikilink">destructive testing</a> of a new car model. This way, tests can be performed quickly and inexpensively in a computer, which permits optimization of the design before a real prototype of the car has been manufactured. Using a simulation, problems can be solved before spending time and money on an actual crash test. The great flexibility of <a href="Printing" title="wikilink">printed</a> output and <a href="graphical_display" title="wikilink">graphical display</a> enables designers to solve some problems that would have been nearly impossible without the help of a computer.</p>
<h2 id="analysis">Analysis</h2>

<p> Large number of crash simulations use a method of analysis called the <a href="Finite_Element_Method" title="wikilink">Finite Element Method</a>. The complex problems are solved by dividing a surface into a large but still finite number of elements and determining the motion of these elements over very small periods of time. Another approach to crash simulations is performed by application of <a href="Macro_Element_Method" title="wikilink">Macro Element Method</a>. The difference between two mentioned above methodologies is that the structure in case of Macro Element Method consists of smaller number of elements. The calculation algorithm of structure deformation is based on experimental data rather than calculated from partial differential equations.</p>

<p>Pam-Crash started crash simulation and together with <a class="uri" href="LS-DYNA" title="wikilink">LS-DYNA</a> is a software package which is widely used for application of Finite Element Method. This method allows detailed modeling of a structure, but the disadvantage lies in high processing unit requirements and calculation time. The Visual Crash Studio uses Macro Element Methodology. In comparison with FEM it has some modeling and boundary condition limitations but its application does not require advanced computers and the calculation time is incomparably smaller. Two presented methods complement each other. Macro Element Method is useful at early stage of the structure design process while Finite Element Method performs well at its final stages.</p>
<h3 id="structural-analysis">Structural analysis</h3>

<p>In a typical crash simulation, the car body structure is analyzed using spatial <a class="uri" href="discretization" title="wikilink">discretization</a>, that is, breaking up the continuous movement of the body in real time into smaller changes in position over small, discrete time steps. The discretization involves subdividing the surface of the constituent, thin, <a href="sheet_metal" title="wikilink">sheet metal</a> parts into a large number (approaching one million in 2006) of <a class="uri" href="quadrilateral" title="wikilink">quadrilateral</a> or triangular regions, each of which spans the area between "nodes" to which its corners are fixed. Each element has mass, which is distributed as concentrated masses and as <a href="moment_of_inertia" title="wikilink">mass moments of inertia</a> to its connecting nodes. Each node has 6 kinematic <a href="degrees_of_freedom_(engineering)" title="wikilink">degrees of freedom</a>, that is, one node can move in three linear directions under <a href="translation_(physics)" title="wikilink">translation</a> and can <a href="rotation" title="wikilink">rotate</a> about three independent axes. The spatial <a class="uri" href="coordinates" title="wikilink">coordinates</a> (<em>x</em>), <a href="displacement_(distance)" title="wikilink">displacement</a> (<em>u</em>), <a class="uri" href="velocity" title="wikilink">velocity</a> (<em>v</em>), and <a class="uri" href="acceleration" title="wikilink">acceleration</a> (<em>a</em>) of each node is mostly expressed in a three-dimensional rectangular <a href="Cartesian_coordinate_system" title="wikilink">Cartesian coordinate system</a> with axes <em>X</em>,<em>Y</em>, and <em>Z</em>.</p>

<p>If the nodes move during a crash simulation, the connected elements move, stretch, and bend with their nodes, which causes them to impart forces and <a href="moment_(mathematics)" title="wikilink">moments</a> to their nodal connections. The forces and moments at the nodes correspond to the inertia forces and moments, caused by their translational (linear) and <a href="angular_acceleration" title="wikilink">angular accelerations</a> and to the forces and moments transmitted by the <a href="strength_of_materials" title="wikilink">resistance</a> of the structural material of the connected elements as they deform. Sometimes, additional external <a href="structural_loads" title="wikilink">structural loads</a> are applied, like gravity loads from the self weight of the parts, or added loads from external masses.</p>

<p>The forces and moments of all nodes are collected into a <a href="column_vector" title="wikilink">column vector</a> (or column matrix), and the time dependent <a href="equation_of_motion" title="wikilink">equations of motion</a> (in dynamic equilibrium) can be written as follows.</p>

<p>

<math display="block" id="Crash_simulation:0">
 <semantics>
  <mrow>
   <mi>𝐌𝐚</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐅</mi>
     <mrow>
      <mi>e</mi>
      <mi>x</mi>
      <mi>t</mi>
     </mrow>
    </msub>
    <mo>-</mo>
    <msub>
     <mi>𝐅</mi>
     <mrow>
      <mi>i</mi>
      <mi>n</mi>
      <mi>t</mi>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐌𝐚</ci>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐅</ci>
      <apply>
       <times></times>
       <ci>e</ci>
       <ci>x</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐅</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>n</ci>
       <ci>t</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Ma}=\mathbf{F}_{ext}-\mathbf{F}_{int}
  </annotation>
 </semantics>
</math>

 where vector 

<math display="inline" id="Crash_simulation:1">
 <semantics>
  <mi>𝐌𝐚</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐌𝐚</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{Ma}
  </annotation>
 </semantics>
</math>

 (mass times acceleration vector) collects the inertia forces at the nodes, 

<math display="inline" id="Crash_simulation:2">
 <semantics>
  <msub>
   <mi>𝐅</mi>
   <mrow>
    <mi>e</mi>
    <mi>x</mi>
    <mi>t</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐅</ci>
    <apply>
     <times></times>
     <ci>e</ci>
     <ci>x</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{F}_{ext}
  </annotation>
 </semantics>
</math>

 collects the external nodal loads, and 

<math display="inline" id="Crash_simulation:3">
 <semantics>
  <msub>
   <mi>𝐅</mi>
   <mrow>
    <mi>i</mi>
    <mi>n</mi>
    <mi>t</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐅</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>n</ci>
     <ci>t</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{F}_{int}
  </annotation>
 </semantics>
</math>


 collects the internal resisting forces from the deformation of the material. <em>M</em> is a <a href="diagonal_matrix" title="wikilink">diagonal matrix</a> of the nodal masses. Each vector (<em>u</em>, <em>v</em>, <em>a</em>, <em>F</em>, etc.) has <a class="uri" href="dimension" title="wikilink">dimension</a> 6 times the total number of nodes in the crash model (about 6 million “<a href="degrees_of_freedom_(engineering)" title="wikilink">degrees of freedom</a>” for every 1 million "nodes" in 3-D thin shell finite element models).</p>
<h3 id="time-analysis">Time analysis</h3>

<p>A crash simulation uses time discretization as well to separate the continuous changes in time into very small, usable segments. The dynamic <a href="equations_of_motion" title="wikilink">equations of motion</a> hold at all times during a crash simulation and must be integrated in time, <em>t</em>, starting from an <a href="initial_condition" title="wikilink">initial condition</a> at time zero, which is just prior to the crash. According to the explicit <a href="finite_difference" title="wikilink">finite difference</a> <a href="time_integration_method" title="wikilink">time integration method</a> used by most crash codes, the accelerations, velocities, and displacements of the body are related by the following equations.</p>

<p>

<math display="block" id="Crash_simulation:4">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐚</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>𝐌</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>𝐅</mi>
        <mrow>
         <mi>e</mi>
         <mi>x</mi>
         <mi>t</mi>
        </mrow>
       </msub>
       <mo>-</mo>
       <msub>
        <mi>𝐅</mi>
        <mrow>
         <mi>i</mi>
         <mi>n</mi>
         <mi>t</mi>
        </mrow>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐚</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐌</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐅</ci>
        <apply>
         <times></times>
         <ci>e</ci>
         <ci>x</ci>
         <ci>t</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐅</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>n</ci>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{a}_{n}=\mathbf{M}^{-1}(\mathbf{F}_{ext}-\mathbf{F}_{int})_{n}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Crash_simulation:5">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐯</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐯</mi>
     <mrow>
      <mi>n</mi>
      <mo>-</mo>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
     </mrow>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>𝐚</mi>
      <mi>n</mi>
     </msub>
     <mi mathvariant="normal">Δ</mi>
     <msub>
      <mi>t</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐯</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐯</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐚</ci>
       <ci>n</ci>
      </apply>
      <ci>normal-Δ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{v}_{n+1/2}=\mathbf{v}_{n-1/2}+\mathbf{a}_{n}\Delta t_{n}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Crash_simulation:6">
 <semantics>
  <mrow>
   <msub>
    <mi>𝐮</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐮</mi>
     <mi>n</mi>
    </msub>
    <mo>+</mo>
    <mrow>
     <msub>
      <mi>𝐯</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
     </msub>
     <mi mathvariant="normal">Δ</mi>
     <msub>
      <mi>t</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mrow>
        <mn>1</mn>
        <mo>/</mo>
        <mn>2</mn>
       </mrow>
      </mrow>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>𝐮</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐮</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐯</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <ci>normal-Δ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <apply>
         <divide></divide>
         <cn type="integer">1</cn>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}_{n+1}=\mathbf{u}_{n}+\mathbf{v}_{n+1/2}\Delta t_{n+1/2}
  </annotation>
 </semantics>
</math>

 In these equations the subscripts <em>n</em>±1/2, <em>n</em>, <em>n</em>+1 denote past, present, and future times, <em>t</em>, at half and full-time intervals with time steps 

<math display="inline" id="Crash_simulation:7">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <msub>
    <mi>t</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta t_{n}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Crash_simulation:8">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <msub>
    <mi>t</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>t</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta t_{n+1/2}
  </annotation>
 </semantics>
</math>


, respectively.</p>
<h3 id="solution">Solution</h3>

<p>The above <a href="system_of_linear_equations" title="wikilink">system of linear equations</a> is solved for the accelerations, 

<math display="inline" id="Crash_simulation:9">
 <semantics>
  <msub>
   <mi>𝐚</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐚</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{a}_{n}
  </annotation>
 </semantics>
</math>

, the velocities, 

<math display="inline" id="Crash_simulation:10">
 <semantics>
  <msub>
   <mi>𝐯</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐯</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{v}_{n+1/2}
  </annotation>
 </semantics>
</math>

, and the displacements, 

<math display="inline" id="Crash_simulation:11">
 <semantics>
  <msub>
   <mi>𝐮</mi>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐮</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{u}_{n+1}
  </annotation>
 </semantics>
</math>

, at each discrete point in time, <em>t</em>, during the crash <a href="interval_(time)" title="wikilink">duration</a>. This solution is trivial, since the mass matrix is diagonal. The computer time is proportional to the number of finite elements and the number of solution time steps. The stable solution time step, 

<math display="inline" id="Crash_simulation:12">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta t
  </annotation>
 </semantics>
</math>

, is limited for <a href="numerical_stability" title="wikilink">numerical stability</a>, as expressed by the <a href="Courant–Friedrichs–Lewy_condition" title="wikilink">Courant–Friedrichs–Lewy condition</a> (CFL), which states that “in any time-marching computer simulation, the time step must be less than the time for some significant action to occur, and preferably considerably less." In a crash simulation, the fastest significant actions are the acoustic signals that travel inside the structural material.</p>

<p>The solid elastic stress wave speed amounts to</p>

<p>

<math display="block" id="Crash_simulation:13">
 <semantics>
  <mrow>
   <mi>c</mi>
   <mo>=</mo>
   <msqrt>
    <mrow>
     <msub>
      <mi>E</mi>
      <mn>0</mn>
     </msub>
     <mo>/</mo>
     <mi>ρ</mi>
    </mrow>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>c</ci>
    <apply>
     <root></root>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>ρ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   c=\sqrt{E_{0}/\rho}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Crash_simulation:14">
 <semantics>
  <msub>
   <mi>E</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{0}
  </annotation>
 </semantics>
</math>

 is the initial elastic modulus (before <a href="plastic_deformation" title="wikilink">plastic deformation</a>) of the material and 

<math display="inline" id="Crash_simulation:15">
 <semantics>
  <mi>ρ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ρ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

 is the mass density. The largest stable time step for a given material is therefore</p>

<p>

<math display="block" id="Crash_simulation:16">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Δ</mi>
    <mi>t</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>d</mi>
     <mrow>
      <mi>m</mi>
      <mi>i</mi>
      <mi>n</mi>
     </mrow>
    </msub>
    <msqrt>
     <mrow>
      <mi>ρ</mi>
      <mo>/</mo>
      <msub>
       <mi>E</mi>
       <mn>0</mn>
      </msub>
     </mrow>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Δ</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>d</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>i</ci>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <root></root>
      <apply>
       <divide></divide>
       <ci>ρ</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta t=d_{min}\sqrt{\rho/E_{0}}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Crash_simulation:17">
 <semantics>
  <msub>
   <mi>d</mi>
   <mrow>
    <mi>m</mi>
    <mi>i</mi>
    <mi>n</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>d</ci>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>i</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{min}
  </annotation>
 </semantics>
</math>

 is the smallest distance between any two nodes of the numerical crash simulation model.</p>

<p>Since this distance can change during a simulation, the stable time step changes and must be updated continually as the solution proceeds in time. When using <a class="uri" href="steel" title="wikilink">steel</a>, the typical value of the stable time step is about one <a class="uri" href="microsecond" title="wikilink">microsecond</a> when the smallest discrete node distance in the mesh of the finite element model is about 5 millimeters. It needs then more than 100,000 time intervals to solve a crash event that lasts for one tenth of a second. This figure is exceeded in many industrial crash models demanding optimized crash solvers with High-Performance Computing (<a class="uri" href="HPC" title="wikilink">HPC</a>) features, such as <a href="Array_programming" title="wikilink">vectorization</a> and <a href="parallel_computing" title="wikilink">parallel computing</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Finite_element_method_in_structural_mechanics" title="wikilink">Finite element method in structural mechanics</a></li>
<li><a href="Finite_element_analysis" title="wikilink">Finite element analysis</a></li>
<li><a href="Crash_test" title="wikilink">Crash test</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Haug, E. (1981) "Engineering safety analysis via destructive numerical experiments", EUROMECH 121, Polish Academy of Sciences, Engineering Transactions 29(1), 39–49.</li>
<li>Haug, E., T. Scharnhorst, P. Du Bois (1986) "FEM-Crash, Berechnung eines Fahrzeugfrontalaufpralls", VDI Berichte 613, 479–505.</li>
</ul>

<p>"</p>

<p><a href="Category:Car_safety" title="wikilink">Category:Car safety</a> <a href="Category:Articles_containing_video_clips" title="wikilink">Category:Articles containing video clips</a></p>
</body>
</html>
