<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1048">Precoding</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Precoding</h1>
<hr/>

<p><strong>Precoding</strong> is a generalization of <a class="uri" href="beamforming" title="wikilink">beamforming</a> to support multi-stream (or multi-layer) transmission in <a href="MIMO" title="wikilink">multi-antenna</a> wireless communications. In conventional single-stream beamforming, the same signal is emitted from each of the transmit antennas with appropriate weighting (phase and gain) such that the signal power is maximized at the receiver output. When the receiver has multiple antennas, single-stream beamforming cannot simultaneously maximize the signal level at all of the receive antennas.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> In order to maximize the throughput in multiple receive antenna systems, multi-stream transmission is generally required.</p>

<p>In point-to-point systems, precoding means that multiple data streams are emitted from the transmit antennas with independent and appropriate weightings such that the link throughput is maximized at the receiver output. In <a href="multi-user_MIMO" title="wikilink">multi-user MIMO</a>, the data streams are intended for different users (known as <a href="space-division_multiple_access" title="wikilink">SDMA</a>) and some measure of the total throughput (e.g., the sum performance or max-min fairness) is maximized. In point-to-point systems, some of the benefits of precoding can be realized without requiring <a href="channel_state_information" title="wikilink">channel state information</a> at the transmitter, while such information is essential to handle the inter-user interference in multi-user systems.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Precoding in the downlink of cellular networks, known as network MIMO or coordinated multipoint (CoMP), is a generalized form of multi-user MIMO that can be analyzed by the same mathematical techniques.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="precoding-in-simple-words">Precoding in Simple Words</h2>

<p>Precoding is a technique which exploits transmit diversity by weighting information stream, i.e. the transmitter send the coded information to the receiver in order to the pre-knowledge of the channel. The receiver is a simple detector, such as a matched filter, and does not have to know the channel side information. This technique will reduce the corrupted effect of the communication channel.</p>

<p>For example you are sending the information 

<math display="inline" id="Precoding:0">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 and it will pass through the channel, 

<math display="inline" id="Precoding:1">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

, and add Gaussian noise, 

<math display="inline" id="Precoding:2">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

. The received signal at the receiver front-end will be 

<math display="inline" id="Precoding:3">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>s</mi>
     <mi>h</mi>
    </mrow>
    <mo>+</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>r</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>h</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=sh+n
  </annotation>
 </semantics>
</math>

;</p>

<p>The receiver will have to know the information about 

<math display="inline" id="Precoding:4">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Precoding:5">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

. It will suppress the effect of 

<math display="inline" id="Precoding:6">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 by increasing SNR, but what about 

<math display="inline" id="Precoding:7">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

? It needs information about the channel, 

<math display="inline" id="Precoding:8">
 <semantics>
  <mi>h</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>h</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h
  </annotation>
 </semantics>
</math>

, and this will increase the complexity. The receiver (mobile units) has to be simple for many reasons like cost or size of mobile unit. So, the transmitter (the base station) will do the hard work and predict the channel.</p>

<p>Let us call the predicted channel 

<math display="inline" id="Precoding:9">
 <semantics>
  <msub>
   <mi>h</mi>
   <mtext>est</mtext>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>h</ci>
    <mtext>est</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{\text{est}}
  </annotation>
 </semantics>
</math>

 and for a system with precoder the information will be coded

<math display="block" id="Precoding:10">
 <semantics>
  <mfrac>
   <mi>s</mi>
   <msub>
    <mi>h</mi>
    <mtext>est</mtext>
   </msub>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>s</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <mtext>est</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {s\over h_{\text{est}}}
  </annotation>
 </semantics>
</math>

. The received signal will be 

<math display="inline" id="Precoding:11">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mi>h</mi>
       <msub>
        <mi>h</mi>
        <mtext>est</mtext>
       </msub>
      </mfrac>
      <mo>)</mo>
     </mrow>
     <mi>s</mi>
    </mrow>
    <mo>+</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>r</ci>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <ci>h</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <mtext>est</mtext>
       </apply>
      </apply>
      <ci>s</ci>
     </apply>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=\left(\frac{h}{h_{\text{est}}}\right)s+n
  </annotation>
 </semantics>
</math>

.</p>

<p>If your prediction is perfect, 

<math display="inline" id="Precoding:12">
 <semantics>
  <mrow>
   <msub>
    <mi>h</mi>
    <mtext>est</mtext>
   </msub>
   <mo>=</mo>
   <mi>h</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>h</ci>
     <mtext>est</mtext>
    </apply>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h_{\text{est}}=h
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Precoding:13">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>=</mo>
   <mrow>
    <mi>s</mi>
    <mo>+</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>r</ci>
    <apply>
     <plus></plus>
     <ci>s</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=s+n
  </annotation>
 </semantics>
</math>

 and it turns out to be the detection problem in Gaussian channels which is simple.</p>

<p>Why do they call it "coding"? It is a preprocessing technique that performs transmit diversity and it is similar to equalization, but the main difference is that you have to optimize the precoder with a decoder. Channel equalization aims to minimize channel errors, but the precoder aims to minimize the error in the receiver output.</p>
<h2 id="precoding-for-point-to-point-mimo-systems">Precoding for Point-to-Point MIMO Systems</h2>

<p>In point-to-point multiple-input multiple-output (<a class="uri" href="MIMO" title="wikilink">MIMO</a>) systems, a transmitter equipped with multiple antennas communicates with a receiver that has multiple antennas. Most classic precoding results assume <a class="uri" href="narrowband" title="wikilink">narrowband</a>, <a href="fading" title="wikilink">slowly fading</a> channels, meaning that the channel for a certain period of time can be described by a single channel matrix which does not change faster. In practice, such channels can be achieved, for example, through <a class="uri" href="OFDM" title="wikilink">OFDM</a>. The precoding strategy that maximizes the throughput, called <a href="channel_capacity" title="wikilink">channel capacity</a>, depends on the <a href="channel_state_information" title="wikilink">channel state information</a> available in the system.</p>
<h3 id="statistical-channel-state-information">Statistical channel state information</h3>

<p>If the receiver knows the channel matrix and the transmitter has statistical information, eigenbeamforming is known to achieve the MIMO channel capacity.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> In this approach, the transmitter emits multiple streams in eigendirections of the channel covariance matrix.</p>
<h3 id="full-channel-state-information">Full channel state information</h3>

<p>If the channel matrix is completely known, <a href="singular_value_decomposition" title="wikilink">singular value decomposition</a> (SVD) precoding is known to achieve the MIMO channel capacity.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> In this approach, the channel matrix is diagonalized by taking an SVD and removing the two unitary matrices through pre- and post-multiplication at the transmitter and receiver, respectively. Then, one data stream per singular value can be transmitted (with appropriate power loading) without creating any interference whatsoever.</p>
<h2 id="precoding-for-multi-user-mimo-systems">Precoding for Multi-user MIMO Systems</h2>

<p>In <a href="multi-user_MIMO" title="wikilink">multi-user MIMO</a>, a multi-antenna transmitter communicates simultaneously with multiple receivers (each having one or multiple antennas). This is known as <a href="space-division_multiple_access" title="wikilink">space-division multiple access</a> (SDMA). From an implementation perspective, precoding algorithms for SDMA systems can be sub-divided into linear and nonlinear precoding types. The capacity achieving algorithms are nonlinear,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> but linear precoding approaches usually achieve reasonable performance with much lower complexity. Linear precoding strategies include maximum ratio transmission (MRT),<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> <a href="Zero-forcing_precoding" title="wikilink">zero-forcing</a> (ZF) precoding,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> and transmit Wiener precoding<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> There are also precoding strategies tailored for low-rate <a class="uri" href="feedback" title="wikilink">feedback</a> of <a href="channel_state_information" title="wikilink">channel state information</a>, for example random beamforming.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> Nonlinear precoding is designed based on the concept of <a href="dirty_paper_coding" title="wikilink">dirty paper coding</a> (DPC), which shows that any known interference at the transmitter can be subtracted without the penalty of radio resources if the optimal precoding scheme can be applied on the transmit signal.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>While performance maximization has a clear interpretation in point-to-point MIMO, a multi-user system cannot simultaneously maximize the performance for all users. This can be viewed as a <a href="multi-objective_optimization" title="wikilink">multi-objective optimization</a> problem where each objective corresponds to maximization of the capacity of one of the users.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> The usual way to simplify this problem is to select a system utility function; for example, the weighted sum capacity where the weights correspond to the system's subjective user priorities. Furthermore, there might be more users than data streams, requiring a <a href="scheduling_algorithm" title="wikilink">scheduling algorithm</a> to decide which users to serve at a given time instant.</p>
<h3 id="linear-precoding-with-full-channel-state-information">Linear precoding with full channel state information</h3>

<p>This suboptimal approach cannot achieve the weighted sum rate, but it can still maximize the weighted sum performance (or some other metric of achievable rates under linear precoding). The optimal linear precoding does not have any closed-form expression, but it takes the form of a weighted MMSE precoding for single-antenna receivers.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> The precoding weights for a given user are selected to maximize a ratio between the signal gain at this user and the interference generated at other users (with some weights) plus noise. Thus, precoding can be interpreted as finding the optimal balance between achieving strong signal gain and limiting inter-user interference.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>

<p>Finding the optimal weighted MMSE precoding is difficult, leading to approximate approaches where the weights are selected heuristically. A common approach is to concentrate on either the numerator or the denominator of the mentioned ratio; that is, maximum ratio transmission (MRT)<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> and <a href="zero-forcing_precoding" title="wikilink">zero-forcing</a> (ZF)<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> precoding. MRT only maximizes the signal gain at the intended user. MRT is close-to-optimal in noise-limited systems, where the inter-user interference is negligible compared to the noise. ZF precoding aims at nulling the inter-user interference, at the expense of losing some signal gain. ZF precoding can achieve performance close to the sum capacity when the number of users is large or the system is interference-limited (i.e., the noise is weak compared to the interference). A balance between MRT and ZF is obtained by the so-called regularized zero-forcing<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> (also known as signal-to-leakage-and-interference ratio (SLNR) beamforming<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> and transmit Wiener filtering<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a>) All of these heuristic approaches can also be applied to receivers that have multiple antennas.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a><a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a><a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>

<p>Also for multiuser MIMO system setup, another approach has been used to reformulate the weighted sum rate optimization problem to a weighted sum MSE problem with additional optimization MSE weights for each symbol in.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> However, still this work is not able to solve this problem optimally (i.e., its solution is suboptimal). On the other hand, duality approach also considered in <a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a> and <a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> to get sub-optimal solution for weighted sum rate optimization.</p>

<p>Note that the optimal linear precoding can be computed using monotonic optimization algorithms,<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a><a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> but the computational complexity scales exponentially fast with the number of users. These algorithms are therefore only useful for benchmarking in small systems.</p>
<h3 id="linear-precoding-with-limited-channel-state-information">Linear precoding with limited channel state information</h3>

<p>In practice, the <a href="channel_state_information" title="wikilink">channel state information</a> is limited at the transmitter due to estimation errors and quantization. Inaccurate channel knowledge may result in significant loss of system throughput, as the interference between the multiplexed streams cannot be completely controlled. In closed-loop systems, the feedback capabilities decide which precoding strategies that are feasible. Each receiver can either feedback a quantized version of its complete channel knowledge or focus on certain critical performance indicators (e.g., the channel gain).</p>

<p>If the complete channel knowledge is fed back with good accuracy, then one can use strategies designed for having full channel knowledge with minor performance degradation. Zero-forcing precoding may even achieve the full multiplexing gain, but only provided that the accuracy of the channel feedback increases linearly with <a href="signal-to-noise_ratio" title="wikilink">signal-to-noise ratio</a> (in dB).<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> Quantization and feedback of channel state information is based on <a href="vector_quantization" title="wikilink">vector quantization</a>, and codebooks based on Grassmannian line packing have shown good performance.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a></p>

<p>Other precoding strategies have been developed for the case with very low channel feedback rates. Random beamforming<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> (or opportunistic beamforming<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a>) was proposed as a simple way of achieving good performance that scales like the sum capacity when the number of receivers is large. In this suboptimal strategy, a set of beamforming directions are selected randomly and users feed back a few bits to tell the transmitter which beam gives the best performance and what rate they can support using it. When the number of users is large, it is likely that each random beamforming weight will provide good performance for some user.</p>

<p>In <a href="spatial_correlation" title="wikilink">spatially correlated</a> environments, the long-term channel statistics can be combined with low-rate feedback to perform multi-user precoding.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> As spatially correlated statistics contain much directional information, it is only necessary for users to feed back their current channel gain to achieve reasonable channel knowledge. As the beamforming weights are selected from the statistics, and not randomly, this approach outperforms random beamforming under strong spatial correlation.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></p>
<h3 id="dpc-or-dpc-like-nonlinear-precoding">DPC or DPC-like nonlinear precoding</h3>

<p><a href="Dirty_paper_coding_(DPC)" title="wikilink">Dirty paper coding</a> is a coding technique that pre-cancels known interference without power penalty. Only the transmitter needs to know this interference, but full <a href="channel_state_information" title="wikilink">channel state information</a> is required everywhere to achieve the weighted sum capacity.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> This category includes Costa precoding,<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> Tomlinson-Harashima precoding<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a><a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> and the vector perturbation technique.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a></p>
<h2 id="mathematical-description">Mathematical Description</h2>
<h3 id="description-of-point-to-point-mimo">Description of Point-to-Point MIMO</h3>

<p>The standard <a class="uri" href="narrowband" title="wikilink">narrowband</a>, <a href="fading" title="wikilink">slowly fading</a> channel model for point-to-point (single-user) MIMO communication is described in the page on <a href="Mimo#Mathematical_description" title="wikilink">MIMO</a> communication.</p>
<h3 id="description-of-multi-user-mimo">Description of Multi-user MIMO</h3>

<p>Consider a downlink multi-user MIMO system where a base station with 

<math display="inline" id="Precoding:14">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 transmit antennas and 

<math display="inline" id="Precoding:15">
 <semantics>
  <mi>K</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>K</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K
  </annotation>
 </semantics>
</math>

 single-antenna users. The channel to user 

<math display="inline" id="Precoding:16">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 is described by the 

<math display="inline" id="Precoding:17">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>×</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\times 1
  </annotation>
 </semantics>
</math>

 vector 

<math display="inline" id="Precoding:18">
 <semantics>
  <msub>
   <mi>𝐡</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐡</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{h}_{k}
  </annotation>
 </semantics>
</math>

 of channel coefficients and its 

<math display="inline" id="Precoding:19">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

th element describes the channel response between the 

<math display="inline" id="Precoding:20">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

th transmit antenna and the receive antenna. The input-output relationship can be described as</p>

<p>

<math display="block" id="Precoding:21">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>k</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msubsup>
       <mi>𝐡</mi>
       <mi>k</mi>
       <mi>H</mi>
      </msubsup>
      <mi>𝐱</mi>
     </mrow>
     <mo>+</mo>
     <msub>
      <mi>n</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>K</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐡</ci>
         <ci>k</ci>
        </apply>
        <ci>H</ci>
       </apply>
       <ci>𝐱</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>k</ci>
     <list>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
      <ci>normal-…</ci>
      <ci>K</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}=\mathbf{h}_{k}^{H}\mathbf{x}+n_{k},\quad k=1,2,\ldots,K
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Precoding:22">
 <semantics>
  <mi>𝐱</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐱</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 is the 

<math display="inline" id="Precoding:23">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>×</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\times 1
  </annotation>
 </semantics>
</math>

 transmitted vector signal, 

<math display="inline" id="Precoding:24">
 <semantics>
  <msub>
   <mi>y</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>y</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}
  </annotation>
 </semantics>
</math>

 is the received signal, and 

<math display="inline" id="Precoding:25">
 <semantics>
  <msub>
   <mi>n</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>n</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n_{k}
  </annotation>
 </semantics>
</math>

 is the zero-mean unit-variance noise.</p>

<p>Under linear precoding, the transmitted vector signal is</p>

<p>

<math display="block" id="Precoding:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐱</mi>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>K</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>𝐰</mi>
       <mi>i</mi>
      </msub>
      <msub>
       <mi>s</mi>
       <mi>i</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐱</ci>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>K</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐰</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}=\sum_{i=1}^{K}\mathbf{w}_{i}s_{i},
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Precoding:27">
 <semantics>
  <msub>
   <mi>s</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{i}
  </annotation>
 </semantics>
</math>

 is the (normalized) data symbol and 

<math display="inline" id="Precoding:28">
 <semantics>
  <msub>
   <mi>𝐰</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐰</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{w}_{i}
  </annotation>
 </semantics>
</math>

 is the 

<math display="inline" id="Precoding:29">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>×</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\times 1
  </annotation>
 </semantics>
</math>

 linear precoding vector. The <a href="Signal-to-noise_plus_interference" title="wikilink">signal-to-interference-and-noise</a> ratio (SINR) at user 

<math display="inline" id="Precoding:30">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 becomes</p>

<p>

<math display="block" id="Precoding:31">
 <semantics>
  <mrow>
   <msub>
    <mtext>SINR</mtext>
    <mi>k</mi>
   </msub>
   <mo>=</mo>
   <mfrac>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <msubsup>
        <mi>𝐡</mi>
        <mi>k</mi>
        <mi>H</mi>
       </msubsup>
       <msub>
        <mi>𝐰</mi>
        <mi>k</mi>
       </msub>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>≠</mo>
        <mi>k</mi>
       </mrow>
      </msub>
      <msup>
       <mrow>
        <mo stretchy="false">|</mo>
        <mrow>
         <msubsup>
          <mi>𝐡</mi>
          <mi>k</mi>
          <mi>H</mi>
         </msubsup>
         <msub>
          <mi>𝐰</mi>
          <mi>i</mi>
         </msub>
        </mrow>
        <mo stretchy="false">|</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <mtext>SINR</mtext>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐡</ci>
          <ci>k</ci>
         </apply>
         <ci>H</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐰</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <neq></neq>
         <ci>i</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <abs></abs>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>𝐡</ci>
            <ci>k</ci>
           </apply>
           <ci>H</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐰</ci>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textrm{SINR}_{k}=\frac{|\mathbf{h}_{k}^{H}\mathbf{w}_{k}|^{2}}{1+\sum_{i\neq k%
}|\mathbf{h}_{k}^{H}\mathbf{w}_{i}|^{2}}
  </annotation>
 </semantics>
</math>

 and the corresponding achievable information rate is 

<math display="inline" id="Precoding:32">
 <semantics>
  <mrow>
   <msub>
    <mi>log</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <msub>
      <mtext>SINR</mtext>
      <mi>k</mi>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <log></log>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <mtext>SINR</mtext>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log_{2}(1+\textrm{SINR}_{k})
  </annotation>
 </semantics>
</math>

 bits per channel use. The transmission is limited by power constraints. This can, for example, be a total power constraint 

<math display="inline" id="Precoding:33">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>K</mi>
    </msubsup>
    <msup>
     <mrow>
      <mo>∥</mo>
      <msub>
       <mi>𝐰</mi>
       <mi>i</mi>
      </msub>
      <mo>∥</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>≤</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>K</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐰</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{K}\|\mathbf{w}_{i}\|^{2}\leq P
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Precoding:34">
 <semantics>
  <mi>P</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>P</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P
  </annotation>
 </semantics>
</math>

 is the power limit.</p>

<p>A common performance metric in multi-user systems is the weighted sum rate</p>

<p>

<math display="block" id="Precoding:35">
 <semantics>
  <mrow>
   <munder accentunder="true">
    <mi>maximize</mi>
    <mrow>
     <mrow>
      <mo stretchy="false">{</mo>
      <msub>
       <mi>𝐰</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">}</mo>
     </mrow>
     <mo>:</mo>
     <mrow>
      <mrow>
       <mstyle displaystyle="true">
        <munder>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mi>i</mi>
        </munder>
       </mstyle>
       <msup>
        <mrow>
         <mo>∥</mo>
         <msub>
          <mi>𝐰</mi>
          <mi>i</mi>
         </msub>
         <mo>∥</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
      <mo>≤</mo>
      <mi>P</mi>
     </mrow>
    </mrow>
   </munder>
   <mrow>
    <munderover>
     <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
     <mrow>
      <mi>k</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>K</mi>
    </munderover>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>k</mi>
     </msub>
     <mrow>
      <msub>
       <mi>log</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mn>1</mn>
        <mo>+</mo>
        <msub>
         <mtext>SINR</mtext>
         <mi>k</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <apply>
      <ci>normal-:</ci>
      <set>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐰</ci>
        <ci>k</ci>
       </apply>
      </set>
      <apply>
       <leq></leq>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="latexml">norm</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐰</ci>
           <ci>i</ci>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <ci>P</ci>
      </apply>
     </apply>
     <ci>maximize</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>K</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <log></log>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <mtext>SINR</mtext>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \underset{\{\mathbf{w}_{k}\}:\sum_{i}\|\mathbf{w}_{i}\|^{2}\leq P}{\mathrm{%
maximize}}\sum_{k=1}^{K}a_{k}\log_{2}(1+\textrm{SINR}_{k})
  </annotation>
 </semantics>
</math>

 for some positive weights 

<math display="inline" id="Precoding:36">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{k}
  </annotation>
 </semantics>
</math>

 that represent the user priority. The weighted sum rate is maximized by weighted MMSE precoding that selects</p>

<p>

<math display="block" id="Precoding:37">
 <semantics>
  <mrow>
   <msubsup>
    <mi>𝐰</mi>
    <mi>k</mi>
    <mtext>W-MMSE</mtext>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msqrt>
     <msub>
      <mi>p</mi>
      <mi>k</mi>
     </msub>
    </msqrt>
    <mfrac>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>𝐈</mi>
         <mo>+</mo>
         <mrow>
          <msub>
           <mo largeop="true" symmetric="true">∑</mo>
           <mrow>
            <mi>i</mi>
            <mo>≠</mo>
            <mi>k</mi>
           </mrow>
          </msub>
          <mrow>
           <msub>
            <mi>q</mi>
            <mi>i</mi>
           </msub>
           <msub>
            <mi>𝐡</mi>
            <mi>i</mi>
           </msub>
           <msubsup>
            <mi>𝐡</mi>
            <mi>i</mi>
            <mi>H</mi>
           </msubsup>
          </mrow>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <msub>
       <mi>𝐡</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>𝐈</mi>
          <mo>+</mo>
          <mrow>
           <msub>
            <mo largeop="true" symmetric="true">∑</mo>
            <mrow>
             <mi>i</mi>
             <mo>≠</mo>
             <mi>k</mi>
            </mrow>
           </msub>
           <mrow>
            <msub>
             <mi>q</mi>
             <mi>i</mi>
            </msub>
            <msub>
             <mi>𝐡</mi>
             <mi>i</mi>
            </msub>
            <msubsup>
             <mi>𝐡</mi>
             <mi>i</mi>
             <mi>H</mi>
            </msubsup>
           </mrow>
          </mrow>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <msub>
        <mi>𝐡</mi>
        <mi>k</mi>
       </msub>
      </mrow>
      <mo>∥</mo>
     </mrow>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐰</ci>
      <mtext>W-MMSE</mtext>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <root></root>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <plus></plus>
         <ci>𝐈</ci>
         <apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <neq></neq>
            <ci>i</ci>
            <ci>k</ci>
           </apply>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>q</ci>
            <ci>i</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>𝐡</ci>
            <ci>i</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>𝐡</ci>
             <ci>i</ci>
            </apply>
            <ci>H</ci>
           </apply>
          </apply>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐡</ci>
        <ci>k</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <plus></plus>
          <ci>𝐈</ci>
          <apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <sum></sum>
            <apply>
             <neq></neq>
             <ci>i</ci>
             <ci>k</ci>
            </apply>
           </apply>
           <apply>
            <times></times>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>q</ci>
             <ci>i</ci>
            </apply>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>𝐡</ci>
             <ci>i</ci>
            </apply>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>𝐡</ci>
              <ci>i</ci>
             </apply>
             <ci>H</ci>
            </apply>
           </apply>
          </apply>
         </apply>
         <apply>
          <minus></minus>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐡</ci>
         <ci>k</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{w}^{\textrm{W-MMSE}}_{k}=\sqrt{p_{k}}\frac{(\mathbf{I}+\sum_{i\neq k}q%
_{i}\mathbf{h}_{i}\mathbf{h}_{i}^{H})^{-1}\mathbf{h}_{k}}{\|(\mathbf{I}+\sum_{%
i\neq k}q_{i}\mathbf{h}_{i}\mathbf{h}_{i}^{H})^{-1}\mathbf{h}_{k}\|}
  </annotation>
 </semantics>
</math>

 for some positive coefficients 

<math display="inline" id="Precoding:38">
 <semantics>
  <mrow>
   <msub>
    <mi>q</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>q</mi>
    <mi>K</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <ci>K</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{1},\ldots,q_{K}
  </annotation>
 </semantics>
</math>

 (related to the user weights) that satisfy 

<math display="inline" id="Precoding:39">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
     </mrow>
     <mi>K</mi>
    </msubsup>
    <msub>
     <mi>q</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mi>P</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>K</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sum_{i=1}^{K}q_{i}=P
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Precoding:40">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i}
  </annotation>
 </semantics>
</math>

 is the optimal power allocation.<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a></p>

<p>The suboptimal MRT approach removes the channel inversion and only selects</p>

<p>

<math display="block" id="Precoding:41">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>𝐰</mi>
     <mi>k</mi>
     <mi>MRT</mi>
    </msubsup>
    <mo>=</mo>
    <mrow>
     <msqrt>
      <msub>
       <mi>p</mi>
       <mi>k</mi>
      </msub>
     </msqrt>
     <mfrac>
      <msub>
       <mi>𝐡</mi>
       <mi>k</mi>
      </msub>
      <mrow>
       <mo>∥</mo>
       <msub>
        <mi>𝐡</mi>
        <mi>k</mi>
       </msub>
       <mo>∥</mo>
      </mrow>
     </mfrac>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐰</ci>
      <ci>MRT</ci>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <root></root>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐡</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐡</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{w}^{\mathrm{MRT}}_{k}=\sqrt{p_{k}}\frac{\mathbf{h}_{k}}{\|\mathbf{h}_{%
k}\|},
  </annotation>
 </semantics>
</math>

 while the suboptimal <a href="zero-forcing_precoding" title="wikilink">ZF precoding</a> makes sure that 

<math display="inline" id="Precoding:42">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>𝐡</mi>
     <mi>i</mi>
     <mi>H</mi>
    </msubsup>
    <msubsup>
     <mi>𝐰</mi>
     <mi>k</mi>
     <mi>ZF</mi>
    </msubsup>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐡</ci>
       <ci>i</ci>
      </apply>
      <ci>H</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐰</ci>
       <ci>ZF</ci>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{h}_{i}^{H}\mathbf{w}^{\mathrm{ZF}}_{k}=0
  </annotation>
 </semantics>
</math>

 for all i ≠ k and thus the interference can be removed in the SINR expression:</p>

<p>

<math display="block" id="Precoding:43">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mtext>SINR</mtext>
     <mi>k</mi>
     <mi>ZF</mi>
    </msubsup>
    <mo>=</mo>
    <msup>
     <mrow>
      <mo stretchy="false">|</mo>
      <mrow>
       <msubsup>
        <mi>𝐡</mi>
        <mi>k</mi>
        <mi>H</mi>
       </msubsup>
       <msubsup>
        <mi>𝐰</mi>
        <mi>k</mi>
        <mi>ZF</mi>
       </msubsup>
      </mrow>
      <mo stretchy="false">|</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <mtext>SINR</mtext>
      <ci>ZF</ci>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐡</ci>
         <ci>k</ci>
        </apply>
        <ci>H</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>𝐰</ci>
         <ci>ZF</ci>
        </apply>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textrm{SINR}^{\mathrm{ZF}}_{k}=|\mathbf{h}_{k}^{H}\mathbf{w}^{\mathrm{ZF}}_{k%
}|^{2}.
  </annotation>
 </semantics>
</math>

</p>
<h4 id="uplink-downlink-duality">Uplink-downlink duality</h4>

<p>For comparison purposes, it is instructive to compare the downlink results with the corresponding uplink MIMO channel where the same single-antenna users transmit to the same base station, having 

<math display="inline" id="Precoding:44">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 receive antennas. The input-output relationship can be described as</p>

<p>

<math display="block" id="Precoding:45">
 <semantics>
  <mrow>
   <mi>𝐲</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>k</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>K</mi>
     </munderover>
     <mrow>
      <msub>
       <mi>𝐡</mi>
       <mi>k</mi>
      </msub>
      <msqrt>
       <msub>
        <mi>q</mi>
        <mi>k</mi>
       </msub>
      </msqrt>
      <msub>
       <mi>s</mi>
       <mi>k</mi>
      </msub>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mi>𝐧</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>𝐲</ci>
    <apply>
     <plus></plus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>K</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐡</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <root></root>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>q</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>s</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <ci>𝐧</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}=\sum_{k=1}^{K}\mathbf{h}_{k}\sqrt{q_{k}}s_{k}+\mathbf{n}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Precoding:46">
 <semantics>
  <msub>
   <mi>s</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>s</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s_{k}
  </annotation>
 </semantics>
</math>

 is the transmitted symbol for user 

<math display="inline" id="Precoding:47">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Precoding:48">
 <semantics>
  <msub>
   <mi>q</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>q</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{k}
  </annotation>
 </semantics>
</math>

 is the transmit power for this symbol, 

<math display="inline" id="Precoding:49">
 <semantics>
  <mi>𝐲</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐲</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Precoding:50">
 <semantics>
  <mi>𝐧</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>𝐧</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{n}
  </annotation>
 </semantics>
</math>

 are the 

<math display="inline" id="Precoding:51">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>×</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\times 1
  </annotation>
 </semantics>
</math>

 vector of received signals and noise respectively, 

<math display="inline" id="Precoding:52">
 <semantics>
  <msub>
   <mi>𝐡</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐡</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{h}_{k}
  </annotation>
 </semantics>
</math>

 is the 

<math display="inline" id="Precoding:53">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>×</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>N</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N\times 1
  </annotation>
 </semantics>
</math>

 vector of channel coefficients. If the base station uses linear receive filters to combine the received signals on the 

<math display="inline" id="Precoding:54">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>

 antennas, the SINR for the data stream from user 

<math display="inline" id="Precoding:55">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 becomes</p>

<p>

<math display="block" id="Precoding:56">
 <semantics>
  <mrow>
   <msubsup>
    <mtext>SINR</mtext>
    <mi>k</mi>
    <mi>uplink</mi>
   </msubsup>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msub>
      <mi>q</mi>
      <mi>k</mi>
     </msub>
     <msup>
      <mrow>
       <mo stretchy="false">|</mo>
       <mrow>
        <msubsup>
         <mi>𝐡</mi>
         <mi>k</mi>
         <mi>H</mi>
        </msubsup>
        <msub>
         <mi>𝐯</mi>
         <mi>k</mi>
        </msub>
       </mrow>
       <mo stretchy="false">|</mo>
      </mrow>
      <mn>2</mn>
     </msup>
    </mrow>
    <mrow>
     <mn>1</mn>
     <mo>+</mo>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <mi>i</mi>
        <mo>≠</mo>
        <mi>k</mi>
       </mrow>
      </msub>
      <mrow>
       <msub>
        <mi>q</mi>
        <mi>i</mi>
       </msub>
       <msup>
        <mrow>
         <mo stretchy="false">|</mo>
         <mrow>
          <msubsup>
           <mi>𝐡</mi>
           <mi>i</mi>
           <mi>H</mi>
          </msubsup>
          <msub>
           <mi>𝐯</mi>
           <mi>k</mi>
          </msub>
         </mrow>
         <mo stretchy="false">|</mo>
        </mrow>
        <mn>2</mn>
       </msup>
      </mrow>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <mtext>SINR</mtext>
      <ci>uplink</ci>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <abs></abs>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐡</ci>
           <ci>k</ci>
          </apply>
          <ci>H</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐯</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">1</cn>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <neq></neq>
         <ci>i</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>q</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <abs></abs>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>𝐡</ci>
             <ci>i</ci>
            </apply>
            <ci>H</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>𝐯</ci>
            <ci>k</ci>
           </apply>
          </apply>
         </apply>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \textrm{SINR}^{\mathrm{uplink}}_{k}=\frac{q_{k}|\mathbf{h}_{k}^{H}\mathbf{v}_{%
k}|^{2}}{1+\sum_{i\neq k}q_{i}|\mathbf{h}_{i}^{H}\mathbf{v}_{k}|^{2}}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Precoding:57">
 <semantics>
  <msub>
   <mi>𝐯</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐯</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{v}_{k}
  </annotation>
 </semantics>
</math>

 is the unit-norm receive filter for this user. Compared with the downlink case, the only difference in the SINR expressions is that the indices are switched in the interference term. Remarkably, the optimal receive filters are the same as the weighted MMSE precoding vectors, up to a scaling factor:</p>

<p>

<math display="block" id="Precoding:58">
 <semantics>
  <mrow>
   <msubsup>
    <mi>𝐯</mi>
    <mi>k</mi>
    <mtext>MMSE</mtext>
   </msubsup>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>𝐈</mi>
        <mo>+</mo>
        <mrow>
         <msub>
          <mo largeop="true" symmetric="true">∑</mo>
          <mrow>
           <mi>i</mi>
           <mo>≠</mo>
           <mi>k</mi>
          </mrow>
         </msub>
         <mrow>
          <msub>
           <mi>q</mi>
           <mi>i</mi>
          </msub>
          <msub>
           <mi>𝐡</mi>
           <mi>i</mi>
          </msub>
          <msubsup>
           <mi>𝐡</mi>
           <mi>i</mi>
           <mi>H</mi>
          </msubsup>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <msub>
      <mi>𝐡</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>𝐈</mi>
         <mo>+</mo>
         <mrow>
          <msub>
           <mo largeop="true" symmetric="true">∑</mo>
           <mrow>
            <mi>i</mi>
            <mo>≠</mo>
            <mi>k</mi>
           </mrow>
          </msub>
          <mrow>
           <msub>
            <mi>q</mi>
            <mi>i</mi>
           </msub>
           <msub>
            <mi>𝐡</mi>
            <mi>i</mi>
           </msub>
           <msubsup>
            <mi>𝐡</mi>
            <mi>i</mi>
            <mi>H</mi>
           </msubsup>
          </mrow>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msup>
      <msub>
       <mi>𝐡</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mo>∥</mo>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>𝐯</ci>
      <mtext>MMSE</mtext>
     </apply>
     <ci>k</ci>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <plus></plus>
        <ci>𝐈</ci>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <neq></neq>
           <ci>i</ci>
           <ci>k</ci>
          </apply>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>q</ci>
           <ci>i</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>𝐡</ci>
           <ci>i</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>𝐡</ci>
            <ci>i</ci>
           </apply>
           <ci>H</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐡</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <plus></plus>
         <ci>𝐈</ci>
         <apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <sum></sum>
           <apply>
            <neq></neq>
            <ci>i</ci>
            <ci>k</ci>
           </apply>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>q</ci>
            <ci>i</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>𝐡</ci>
            <ci>i</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>𝐡</ci>
             <ci>i</ci>
            </apply>
            <ci>H</ci>
           </apply>
          </apply>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>𝐡</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{v}^{\textrm{MMSE}}_{k}=\frac{(\mathbf{I}+\sum_{i\neq k}q_{i}\mathbf{h}%
_{i}\mathbf{h}_{i}^{H})^{-1}\mathbf{h}_{k}}{\|(\mathbf{I}+\sum_{i\neq k}q_{i}%
\mathbf{h}_{i}\mathbf{h}_{i}^{H})^{-1}\mathbf{h}_{k}\|}
  </annotation>
 </semantics>
</math>

</p>

<p>Observe that the coefficients 

<math display="inline" id="Precoding:59">
 <semantics>
  <mrow>
   <msub>
    <mi>q</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>q</mi>
    <mi>K</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>q</ci>
     <ci>K</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q_{1},\ldots,q_{K}
  </annotation>
 </semantics>
</math>

 that was used in the weighted MMSE precoding are exactly the optimal power coefficients in the uplink (that maximize the weighted sum rate). This important relationship between downlink precoding and uplink receive filtering is known as the uplink-downlink duality.<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a><a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> As the downlink precoding problem usually is more difficult to solve, it often useful to first solve the corresponding uplink problem.</p>
<h4 id="limited-feedback-precoding">Limited feedback precoding</h4>

<p>The precoding strategies described above was based on having perfect <a href="channel_state_information" title="wikilink">channel state information</a> at the transmitter. However, in real systems, receivers can only feed back quantized information that is described by a limited number of bits. If the same precoding strategies are applied, but now based on inaccurate channel information, additional interference appears. This is an example on limited feedback precoding.</p>

<p>The received signal in multi-user MIMO with limited feedback precoding is mathematically described as</p>

<p>

<math display="block" id="Precoding:60">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>y</mi>
      <mi>k</mi>
     </msub>
     <mo>=</mo>
     <mrow>
      <mrow>
       <msubsup>
        <mi>𝐡</mi>
        <mi>k</mi>
        <mi>H</mi>
       </msubsup>
       <mrow>
        <munderover>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>i</mi>
          <mo>=</mo>
          <mn>1</mn>
         </mrow>
         <mi>K</mi>
        </munderover>
        <mrow>
         <msub>
          <mover accent="true">
           <mi>𝐰</mi>
           <mo stretchy="false">^</mo>
          </mover>
          <mi>i</mi>
         </msub>
         <msub>
          <mi>s</mi>
          <mi>i</mi>
         </msub>
        </mrow>
       </mrow>
      </mrow>
      <mo>+</mo>
      <msub>
       <mi>n</mi>
       <mi>k</mi>
      </msub>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mi>k</mi>
     <mo>=</mo>
     <mrow>
      <mn>1</mn>
      <mo>,</mo>
      <mn>2</mn>
      <mo>,</mo>
      <mi mathvariant="normal">…</mi>
      <mo>,</mo>
      <mi>K</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐡</ci>
         <ci>k</ci>
        </apply>
        <ci>H</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>K</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <ci>normal-^</ci>
           <ci>𝐰</ci>
          </apply>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>s</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>k</ci>
     <list>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
      <ci>normal-…</ci>
      <ci>K</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}=\mathbf{h}_{k}^{H}\sum_{i=1}^{K}\hat{\mathbf{w}}_{i}s_{i}+n_{k},\quad k=%
1,2,\ldots,K.
  </annotation>
 </semantics>
</math>

 In this case, the beamforming vectors are distorted as 

<math display="inline" id="Precoding:61">
 <semantics>
  <mrow>
   <msub>
    <mover accent="true">
     <mi>𝐰</mi>
     <mo stretchy="false">^</mo>
    </mover>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>𝐰</mi>
     <mi>i</mi>
    </msub>
    <mo>+</mo>
    <msub>
     <mi>𝐞</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <ci>normal-^</ci>
      <ci>𝐰</ci>
     </apply>
     <ci>i</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐰</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐞</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hat{\mathbf{w}}_{i}=\mathbf{w}_{i}+\mathbf{e}_{i}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Precoding:62">
 <semantics>
  <msub>
   <mi>𝐰</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐰</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{w}_{i}
  </annotation>
 </semantics>
</math>

 is the optimal vector and 

<math display="inline" id="Precoding:63">
 <semantics>
  <msub>
   <mi>𝐞</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>𝐞</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{e}_{i}
  </annotation>
 </semantics>
</math>

 is the error vector caused by inaccurate channel state information. The received signal can be rewritten as</p>

<p>

<math display="block" id="Precoding:64">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>y</mi>
     <mi>k</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mrow>
      <msubsup>
       <mi>𝐡</mi>
       <mi>k</mi>
       <mi>H</mi>
      </msubsup>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>K</mi>
       </munderover>
       <mrow>
        <msub>
         <mi>𝐰</mi>
         <mi>i</mi>
        </msub>
        <msub>
         <mi>s</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <msubsup>
       <mi>𝐡</mi>
       <mi>k</mi>
       <mi>H</mi>
      </msubsup>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>i</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>K</mi>
       </munderover>
       <mrow>
        <msub>
         <mi>𝐞</mi>
         <mi>i</mi>
        </msub>
        <msub>
         <mi>s</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </mrow>
     </mrow>
     <mo>+</mo>
     <msub>
      <mi>n</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>K</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐡</ci>
         <ci>k</ci>
        </apply>
        <ci>H</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>K</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐰</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>s</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐡</ci>
         <ci>k</ci>
        </apply>
        <ci>H</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>i</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>K</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐞</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>s</ci>
          <ci>i</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>k</ci>
     <list>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
      <ci>normal-…</ci>
      <ci>K</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y_{k}=\mathbf{h}_{k}^{H}\sum_{i=1}^{K}\mathbf{w}_{i}s_{i}+\mathbf{h}_{k}^{H}%
\sum_{i=1}^{K}\mathbf{e}_{i}s_{i}+n_{k},\quad k=1,2,\ldots,K
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Precoding:65">
 <semantics>
  <mrow>
   <msubsup>
    <mi>𝐡</mi>
    <mi>k</mi>
    <mi>H</mi>
   </msubsup>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <mi>i</mi>
      <mo>≠</mo>
      <mi>k</mi>
     </mrow>
    </msub>
    <mrow>
     <msub>
      <mi>𝐞</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>s</mi>
      <mi>i</mi>
     </msub>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>𝐡</ci>
      <ci>k</ci>
     </apply>
     <ci>H</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <neq></neq>
       <ci>i</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>𝐞</ci>
       <ci>i</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>s</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{h}_{k}^{H}\sum_{i\neq k}\mathbf{e}_{i}s_{i}
  </annotation>
 </semantics>
</math>

 is the additional interference at user 

<math display="inline" id="Precoding:66">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 according to the limited feedback precoding. To reduce this interference, higher accuracy in the <a href="channel_state_information" title="wikilink">channel information</a> feedback is required, which in turn reduces the throughput in the uplink.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="802.11n" title="wikilink">802.11n</a></li>
<li><a href="Channel_state_information" title="wikilink">Channel state information</a></li>
<li><a href="Cooperative_diversity" title="wikilink">Cooperative diversity</a></li>
<li><a href="Space–time_code" title="wikilink">Space–time code</a></li>
<li><a href="Space–time_trellis_code" title="wikilink">Space–time trellis code</a></li>
<li><a href="Spatial_multiplexing" title="wikilink">Spatial multiplexing</a></li>
<li><a href="Zero-forcing_precoding" title="wikilink">Zero-forcing precoding</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Radio_resource_management" title="wikilink">Category:Radio resource management</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">G.J. Foschini and M.J. Gans, <a href="http://dx.doi.org/10.1023/A:1008889222784">On limits of wireless communications in a fading environment when using multiple antennas</a>, Wireless Personal Communications, vol. 6, no. 3, pp. 311–335, 1998.<a href="#fnref1">↩</a></li>
<li id="fn2">D. Gesbert, M. Kountouris, R.W. Heath Jr., C.-B. Chae, and T. Sälzer, <a href="http://dx.doi.org/10.1109/MSP.2007.904815">Shifting the MIMO Paradigm</a>, IEEE Signal Processing Magazine, vol. 24, no. 5, pp. 36-46, 2007.<a href="#fnref2">↩</a></li>
<li id="fn3">E. Björnson and E. Jorswieck, <a href="http://kth.diva-portal.org/smash/get/diva2:608533/FULLTEXT01">Optimal Resource Allocation in Coordinated Multi-Cell Systems</a>, Foundations and Trends in Communications and Information Theory, vol. 9, no. 2-3, pp. 113-381, 2013.<a href="#fnref3">↩</a></li>
<li id="fn4">D. Love, R. Heath, V. Lau, D. Gesbert, B. Rao and M. Andrews, <a href="http://www.eurecom.fr/~gesbert/papers/JSAC_limitedfeedback_tutorial.pdf">An overview of limited feedback in wireless communication systems</a>, IEEE Journal on Selected Areas Communications, vol. 26, no. 8, pp. 1341–1365, 2008.<a href="#fnref4">↩</a></li>
<li id="fn5">E. Telatar, <a href="http://mars.bell-labs.com/papers/proof/proof.pdf">Capacity of multiantenna Gaussian channels</a>, European Transactions on Telecommunications, vol. 10, no. 6, pp. 585-595, 1999.<a href="#fnref5">↩</a></li>
<li id="fn6">H. Weingarten, Y. Steinberg, and S. Shamai, <a href="http://www.stanford.edu/class/ee360/suppRead/read1/WeingartenSteinbergShamai2006.pdf">The capacity region of the Gaussian multiple-input multiple-output broadcast channel</a>, IEEE Transactions on Information Theory, vol. 52, no. 9, pp. 3936–3964, 2006.<a href="#fnref6">↩</a></li>
<li id="fn7">T. Lo, <a href="http://dx.doi.org/10.1109/26.795811">Maximum ratio transmission</a>, IEEE Transactions on Communications, vol. 47, no. 10, pp. 1458–1461, 1999.<a href="#fnref7">↩</a></li>
<li id="fn8">M. Joham, W. Utschick, and J. Nossek, <a href="http://dx.doi.org/10.1109/TSP.2005.850331">Linear transmit processing in MIMO communications systems</a>, IEEE Transactions on Signal Processing, vol. 53, no. 8, pp. 2700–2712, 2005.<a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10">M. Sharif and B. Hassibi, <a href="http://iss.bu.edu/sharif/mimobc-final.pdf">On the Capacity of MIMO Broadcast Channels With Partial Side Information</a>, IEEE Transactions on Information Theory, vol. 51, no. 2, pp. 506-522, 2005.<a href="#fnref10">↩</a></li>
<li id="fn11"></li>
<li id="fn12"></li>
<li id="fn13"></li>
<li id="fn14">E. Björnson, R. Zakhour, D. Gesbert, B. Ottersten, <a href="http://kth.diva-portal.org/smash/get/diva2:373150/FULLTEXT01">Cooperative Multicell Precoding: Rate Region Characterization and Distributed Strategies with Instantaneous and Statistical CSI</a>, IEEE Transactions on Signal Processing, vol. 58, no. 8, pp. 4298-4310, 2010.<a href="#fnref14">↩</a></li>
<li id="fn15"></li>
<li id="fn16">N. Jindal, <a href="http://dx.doi.org/10.1109/TIT.2006.883550">MIMO Broadcast Channels with Finite Rate Feedback</a>, IEEE Transactions on Information Theory, vol. 52, no. 11, pp. 5045–5059, 2006.<a href="#fnref16">↩</a></li>
<li id="fn17">B. C. B. Peel, B. M. Hochwald, and A. L. Swindlehurst, <a href="http://dx.doi.org/10.1109/TCOMM.2004.840638">A vector-perturbation technique for near-capacity multiantenna multi-user communication - Part I: channel inversion and regularization</a>, IEEE Transactions on Communications, vol. 53, no. 1, pp. 195–202, 2005.<a href="#fnref17">↩</a></li>
<li id="fn18">M. Sadek, A. Tarighat, and A. Sayed, <a href="http://dx.doi.org/10.1109/TWC.2007.360373">A leakage-based precoding scheme for downlink multi-user MIMO channels</a>, IEEE Transactions on Wireless Communications, vol. 6, no. 5, pp. 1711–1721, 2007.<a href="#fnref18">↩</a></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23">T. E. Bogale and L. Vandendorpe, <a href="http://dx.doi.org/10.1109/TSP.2011.2179538">Weighted sum rate optimization for downlink multiuser MIMO coordinated base station systems: Centralized and distributed algorithms</a> IEEE Trans. Signal Process., vol. 60, no. 4, pp. 1876 – 1889, Dec. 2011.<a href="#fnref23">↩</a></li>
<li id="fn24">T. E. Bogale and L. Vandendorpe, <a href="http://dx.doi.org/10.1109/ICASSP.2012.6288607">Weighted sum rate optimization for downlink multiuser MIMO systems with per antenna power constraint:Downlink-uplink duality approach</a> IEEE International Conference On Acuostics, Speech and Signal Processing (ICASSP), Kyoto, Japan, 25 – 30 Mar. 2012, pp. 3245 – 3248.<a href="#fnref24">↩</a></li>
<li id="fn25">T. E. Bogale and L. Vandendorpe, <a href="http://dx.doi.org/10.1109/TSP.2013.2272554">Linear transceiver design for downlink multiuser MIMO systems: Downlink-interference duality approach</a>, IEEE Trans. Sig. Process., vol. 61, no. 19, pp. 4686 – 4700, Oct. 2013.<a href="#fnref25">↩</a></li>
<li id="fn26">W. Utschick and J. Brehmer, <a href="http://dx.doi.org/10.1109/TSP.2011.2182343">Monotonic optimization framework for coordinated beamforming in multicell networks</a>, IEEE Transactions on Signal Processing, vol. 60, no. 4, pp. 1899–1909, 2012.<a href="#fnref26">↩</a></li>
<li id="fn27">E. Björnson, G. Zheng, M. Bengtsson, and B. Ottersten, <a href="http://arxiv.org/pdf/1104.5240v4">Robust monotonic optimization framework for multicell MISO systems</a>, IEEE Transactions on Signal Processing, vol. 60, no. 5, pp. 2508–2523, 2012.<a href="#fnref27">↩</a></li>
<li id="fn28"></li>
<li id="fn29">D.J. Love, R.W. Heath, and T. Strohmer, <a href="http://dx.doi.org/10.1109/TIT.2003.817466">Grassmannian Beamforming for Multiple-Input Multiple-Output Wireless Systems</a>, IEEE Transactions on Information Theory, vol. 49, no. 10, pp. 2735–2747, 2003.<a href="#fnref29">↩</a></li>
<li id="fn30"></li>
<li id="fn31">P. Viswanath, D. N. C. Tse, Member, and R. Laroia, <a href="http://www.eecs.berkeley.edu/~dtse/oppbf_it.pdf">Opportunistic Beamforming Using Dumb Antennas</a>, IEEE Transactions on Information Theory, vol. 48, no. 6, pp. 1277–1294, 2002.<a href="#fnref31">↩</a></li>
<li id="fn32">D. Hammarwall, M. Bengtsson, and B. Ottersten, <a href="http://dx.doi.org/10.1109/TSP.2008.920484">Utilizing the spatial information provided by channel norm feedback in SDMA systems</a>, IEEE Transactions on Signal Processing, vol. 56, no. 7, pp. 3278–3293, 2008<a href="#fnref32">↩</a></li>
<li id="fn33">E. Björnson, D. Hammarwall, B. Ottersten, <a href="http://kth.diva-portal.org/smash/get/diva2:402940/FULLTEXT01">Exploiting Quantized Channel Norm Feedback through Conditional Statistics in Arbitrarily Correlated MIMO Systems</a>, IEEE Transactions on Signal Processing, vol. 57, no. 10, pp. 4027-4041, 2009<a href="#fnref33">↩</a></li>
<li id="fn34"></li>
<li id="fn35">M. Costa, <a href="http://dx.doi.org/10.1109/TIT.1983.1056659">Writing on dirty paper</a>, IEEE Transactions on Information Theory, vol. 29, no. 3, pp. 439–441, 1983<a href="#fnref35">↩</a></li>
<li id="fn36">M. Tomlinson, <a href="http://dx.doi.org/10.1049/el:19710089">New automatic equalizer employing modulo arithmetic</a>, Electronics Letters, vol. 7, no. 5, pp. 138–139, 1971<a href="#fnref36">↩</a></li>
<li id="fn37">H. Harashima and H. Miyakawa, <a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1091221">Matched-transmission technique for channels with intersymbol interference</a>, IEEE Transactions on Communications, vol. 20, no. 4, pp. 774–780, 1972<a href="#fnref37">↩</a></li>
<li id="fn38">B. M. Hochwald, C. B. Peel, and A. L. Swindlehurst, <a href="http://dx.doi.org/10.1109/TCOMM.2005.843995">A vector-perturbation technique for near-capacity multiantenna multi-user communication - Part II: Perturbation</a>, IEEE Transactions on Communications, vol. 53, no. 1, pp. 537–544, 2005<a href="#fnref38">↩</a></li>
<li id="fn39"></li>
<li id="fn40">M. Schubert and H. Boche, <a href="http://dx.doi.org/10.1109/TVT.2003.819629">Solution of the multiuser downlink beamforming problem with individual SINR constraints</a>, IEEE Transactions on Vehicular Technology, vol. 53, no. 1, pp. 18-28, 2004.<a href="#fnref40">↩</a></li>
<li id="fn41">A. Wiesel, Y.C. Eldar, S. Shamai, <a href="http://dx.doi.org/10.1109/TSP.2005.861073">Linear precoding via conic optimization for fixed MIMO receivers</a>, IEEE Transactions on Signal Processing, vol. 54, no. 1, pp. 161-176, 2006.<a href="#fnref41">↩</a></li>
</ol>
</section>
</body>
</html>
