<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="446">Root-finding algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Root-finding algorithm</h1>
<hr/>

<p>A <strong>root-finding algorithm</strong> is a numerical method, or <a class="uri" href="algorithm" title="wikilink">algorithm</a>, for finding a value <em>x</em> such that <em>f</em>(<em>x</em>) = 0, for a given <a href="function_(mathematics)" title="wikilink">function</a> <em>f</em>. Such an <em>x</em> is called a <a href="root_of_a_function" title="wikilink">root</a> of the function <em>f</em>.</p>

<p>This article is concerned with finding <a href="Scalar_(mathematics)" title="wikilink">scalar</a>, <a href="real_number" title="wikilink">real</a> or <a href="complex_number" title="wikilink">complex</a> roots, approximated as <a href="floating_point" title="wikilink">floating point</a> numbers. Finding integer roots or exact algebraic roots are separate problems, whose algorithms have little in common with those discussed here. (See: <a href="Diophantine_equation" title="wikilink">Diophantine equation</a> for integer roots)</p>

<p>Finding a root of <em>f</em>(<em>x</em>) − <em>g</em>(<em>x</em>) = 0 is the same as solving the <a class="uri" href="equation" title="wikilink">equation</a> <em>f</em>(<em>x</em>) = <em>g</em>(<em>x</em>). Here, <em>x</em> is called the <em>unknown</em> in the equation. Conversely, any equation can take the <a href="canonical_form" title="wikilink">canonical form</a> <em>f</em>(<em>x</em>) = 0, so <a href="equation_solving" title="wikilink">equation solving</a> is the same thing as computing (or <em>finding</em>) a root of a function.</p>

<p>Numerical root-finding methods use <a class="uri" href="iteration" title="wikilink">iteration</a>, producing a <a class="uri" href="sequence" title="wikilink">sequence</a> of numbers that hopefully converge towards a <a href="Limit_of_a_sequence" title="wikilink">limit</a>, which is a root. The first values of this series are <em>initial guesses</em>. Many methods computes subsequent values by evaluating an auxiliary function on the preceding values. The limit is thus a <a href="Fixed_point_(mathematics)" title="wikilink">fixed point</a> of the auxiliary function, which is chosen for having the roots of the original equation as fixed points.</p>

<p>The behaviour of root-finding algorithms is studied in <a href="numerical_analysis" title="wikilink">numerical analysis</a>. Algorithms perform best when they take advantage of known characteristics of the given function. Thus an algorithm to find isolated real roots of a low-degree polynomial in one variable may bear little resemblance to an algorithm for complex roots of a "black-box" function which is not even known to be differentiable. Questions include ability to separate close roots, robustness against failures of <a href="Continuous_function" title="wikilink">continuity</a> and <a class="uri" href="differentiability" title="wikilink">differentiability</a>, reliability despite inevitable numerical errors, and rate of convergence.</p>
<h2 id="bracketing-methods">Bracketing methods</h2>

<p>Bracketing methods track the end points of an interval containing a root. This allows them to provide absolute error bounds on a root's location when the function is known to be continuous. Bracketing methods require two initial conditions, one on either side of the root.</p>
<h3 id="bisection-method">Bisection method</h3>

<p>The simplest root-finding algorithm is the <a href="bisection_method" title="wikilink">bisection method</a>. It works when <em>f</em> is a <a href="continuous_function" title="wikilink">continuous function</a> and it requires previous knowledge of two initial guesses, <em>a</em> and <em>b</em>, such that <em>f</em>(<em>a</em>) and <em>f</em>(<em>b</em>) have opposite signs. Although it is reliable, it converges slowly, gaining one <a class="uri" href="bit" title="wikilink">bit</a> of accuracy with each iteration.</p>
<h3 id="false-position-regula-falsi">False position (regula falsi)</h3>

<p>The <a href="false_position_method" title="wikilink">false position method</a>, also called the <em>regula falsi</em> method, is like the secant method. However, instead of retaining the last two points, it makes sure to keep one point on either side of the root. The false position method can be faster than the bisection method and will never diverge like the secant method, but fails to converge under some naive implementations. <a href="Ridders'_method" title="wikilink">Ridders' method</a> is a variant on the false-position method that also evaluates the function at the midpoint of the interval, giving faster convergence with similar robustness.</p>
<h3 id="interpolation">Interpolation</h3>

<p>Regula falsi is an interpolation method because it approximates the function with a line between two points. Higher degree polynomials can also be used to approximate the function and its root, while bracketing the root. For example, <a href="Muller's_method" title="wikilink">Muller's method</a> can be easily modified so that rather than always keeping the last 3 points, it tracks the last two points to bracket the root and the best current approximation. Such methods combine good average performance with absolute bounds on the worst-case performance.</p>
<h2 id="open-methods">Open methods</h2>
<h3 id="newtons-method-and-similar-derivative-based-methods">Newton's method (and similar derivative-based methods)</h3>

<p><a href="Newton's_method" title="wikilink">Newton's method</a> assumes the function <em>f</em> to have a continuous <a class="uri" href="derivative" title="wikilink">derivative</a>. Newton's method may not converge if started too far away from a root. However, when it does converge, it is faster than the bisection method, and is usually quadratic. Newton's method is also important because it readily generalizes to higher-dimensional problems. Newton-like methods with higher orders of convergence are the <a href="Householder's_method" title="wikilink">Householder's methods</a>. The first one after Newton's method is <a href="Halley's_method" title="wikilink">Halley's method</a> with cubic order of convergence.</p>
<h3 id="secant-method">Secant method</h3>

<p>Replacing the derivative in Newton's method with a <a href="finite_difference" title="wikilink">finite difference</a>, we get the <a href="secant_method" title="wikilink">secant method</a>. This method does not require the computation (nor the existence) of a derivative, but the price is slower convergence (the order is approximately 1.6). A generalization of the secant method in higher dimensions is <a href="Broyden's_method" title="wikilink">Broyden's method</a>.</p>
<h3 id="interpolation-1">Interpolation</h3>

<p>The secant method also arises if one approximates the unknown function <em>f</em> by <a href="linear_interpolation" title="wikilink">linear interpolation</a>. When <a href="polynomial_interpolation" title="wikilink">quadratic interpolation</a> is used instead, one arrives at <a href="Muller's_method" title="wikilink">Muller's method</a>. It converges faster than the secant method. A particular feature of this method is that the iterates <em>x</em><sub><em>n</em></sub> may become <a href="complex_number" title="wikilink">complex</a>.</p>

<p><a href="Sidi's_method" title="wikilink">Sidi's method</a> allows for interpolation with an arbitrarily high <a href="Degree_of_a_polynomial" title="wikilink">degree</a> polynomial. The higher the degree of the interpolating polynomial, the faster the convergence. Sidi's method allows for convergence with an order arbitrarily close to 2.</p>
<h3 id="inverse-interpolation">Inverse interpolation</h3>

<p>The appearance of complex values in interpolation methods can be avoided by interpolating the <a href="inverse_function" title="wikilink">inverse</a> of <em>f</em>, resulting in the <a href="inverse_quadratic_interpolation" title="wikilink">inverse quadratic interpolation</a> method. Again, convergence is asymptotically faster than the secant method, but inverse quadratic interpolation often behaves poorly when the iterates are not close to the root.</p>
<h2 id="combinations-of-methods">Combinations of methods</h2>
<h3 id="brents-method">Brent's method</h3>

<p><a href="Brent's_method" title="wikilink">Brent's method</a> is a combination of the bisection method, the secant method and <a href="inverse_quadratic_interpolation" title="wikilink">inverse quadratic interpolation</a>. At every iteration, Brent's method decides which method out of these three is likely to do best, and proceeds by doing a step according to that method. This gives a robust and fast method, which therefore enjoys considerable popularity.</p>
<h2 id="finding-roots-of-polynomials">Finding roots of polynomials</h2>

<p>Much attention has been given to the special case that the function <em>f</em> is a <a class="uri" href="polynomial" title="wikilink">polynomial</a>, and there are several root-finding algorithms for polynomials. For univariate polynomials of degrees one (linear polynomial) through four (quartic polynomial), there are closed-form solutions which produce all roots. Linear polynomials are easy to solve, but using the <a href="quadratic_formula" title="wikilink">quadratic formula</a> to solve <a href="Quadratic_equation" title="wikilink">quadratic</a> (second degree) equations may require some care to ensure numerical stability. The closed-form solutions for degrees three (cubic polynomial) and four (quartic polynomial) are complicated and require much more care; consequently, numerical methods such as <a href="Bairstow's_method" title="wikilink">Bairstow's method</a> may be easier to use. Fifth-degree (quintic) and higher-degree polynomials do not have a general solution according to the <a href="Abel–Ruffini_theorem" title="wikilink">Abel–Ruffini theorem</a> (1824, 1799).</p>
<h3 id="finding-one-root-at-a-time">Finding one root at a time</h3>

<p>The general idea is to find a root of the polynomial and then apply <a href="Horner's_method" title="wikilink">Horner's method</a> to remove the corresponding factor according to the <a href="Ruffini_rule" title="wikilink">Ruffini rule</a>.</p>

<p>This iterative scheme is numerically unstable; the approximation errors accumulate during the successive factorizations, so that the last roots are determined with a polynomial that deviates widely from a factor of the original polynomial. To reduce this error, it is advisable to find the roots in increasing order of magnitude.</p>

<p><a href="Wilkinson's_polynomial" title="wikilink">Wilkinson's polynomial</a> illustrates that high <a href="precision_(arithmetic)" title="wikilink">precision</a> may be necessary when computing the roots of a polynomial given its coefficients: the problem of finding the roots from the coefficients is in general <a class="uri" href="ill-conditioned" title="wikilink">ill-conditioned</a>.</p>

<p>The most simple method to find a single root fast is Newton's method. One can use <a href="Horner's_method" title="wikilink">Horner's method</a> twice to efficiently evaluate the value of the polynomial function and its first derivative; this combination is called <a href="Birge–Vieta's_method" title="wikilink">Birge–Vieta's method</a>. This method provides quadratic convergence for simple roots at the cost of two polynomial evaluations per step.</p>

<p>Closely related to Newton's method are <a href="Halley's_method" title="wikilink">Halley's method</a> and <a href="Laguerre's_method" title="wikilink">Laguerre's method</a>. Using one additional Horner evaluation, the value of the second derivative is used to obtain methods of cubic convergence order for simple roots. If one starts from a point <em>x</em> close to a root and uses the same complexity of <em>6</em> function evaluations, these methods perform two steps with a residual of <em>O</em>(|<em>f</em>(<em>x</em>)|<sup>9</sup>), compared to three steps of Newton's method with an reduction <em>O</em>(|<em>f</em>(<em>x</em>)|<sup>8</sup>), giving a slight advantage to these methods.</p>

<p>When applying these methods to polynomials with real coefficients and real starting points, Newton's and Halley's method stay inside the real number line. One has to choose complex starting points to find complex roots. In contrast, the Laguerre method with a square root in its evaluation will on itself leave the real axis.</p>

<p>Another class of methods is based on translating the problem of finding polynomial roots to the problem of finding eigenvalues of the <a href="companion_matrix" title="wikilink">companion matrix</a> of the polynomial. In principle, one can use any <a href="eigenvalue_algorithm" title="wikilink">eigenvalue algorithm</a> to find the roots of the polynomial. However, for efficiency reasons one prefers methods that employ the structure of the matrix, that is, can be implemented in matrix-free form. Among these methods are the <a href="power_method" title="wikilink">power method</a>, whose application to the transpose of the companion matrix is the classical <a href="Bernoulli's_method" title="wikilink">Bernoulli's method</a> to find the root of greatest modulus. The <a href="inverse_power_method" title="wikilink">inverse power method</a> with shifts, which finds some smallest root first, is what drives the complex (<em>cpoly</em>) variant of the <a href="Jenkins–Traub_method" title="wikilink">Jenkins–Traub method</a> and gives it its numerical stability. Additionally, it is insensitive to multiple roots and has fast convergence with order 

<math display="inline" id="Root-finding_algorithm:0">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>+</mo>
    <mi mathvariant="normal">Φ</mi>
   </mrow>
   <mo>≈</mo>
   <mn>2.6</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>normal-Φ</ci>
    </apply>
    <cn type="float">2.6</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1+\Phi\approx 2.6
  </annotation>
 </semantics>
</math>

 even in the presence of clustered roots. This fast convergence comes with a cost of three Horner evaluations per step, resulting in a residual of <em>O</em>(|<em>f</em>(<em>x</em>)|<sup>2+3Φ</sup>), which is slower than three steps of Newton's method.</p>
<h3 id="finding-roots-in-pairs">Finding roots in pairs</h3>

<p>If the given polynomial only has real coefficients, one may wish to avoid computations with complex numbers. To that effect, one has to find quadratic factors for pairs of conjugate complex roots. The application of the multi-dimensional Newton's method to this task results in <a href="Bairstow's_method" title="wikilink">Bairstow's method</a>. In the framework of inverse power iterations of the companion matrix, the double shift method of Francis results in the real (<em>rpoly</em>) variant of the <a href="Jenkins–Traub_algorithm" title="wikilink">Jenkins–Traub method</a>.</p>
<h3 id="finding-all-roots-at-once">Finding all roots at once</h3>

<p>The simple <a href="Durand–Kerner_method" title="wikilink">Durand–Kerner</a> and the slightly more complicated <a href="Aberth_method" title="wikilink">Aberth methods</a> simultaneously find all of the roots using only simple <a href="complex_number" title="wikilink">complex number</a> arithmetic. Accelerated algorithms for multi-point evaluation and interpolation similar to the <a href="fast_Fourier_transform" title="wikilink">fast Fourier transform</a> can help speed them up for large degrees of the polynomial. It is advisable to choose an asymmetric, but evenly distributed set of initial points.</p>

<p>Another method with this style is the <a href="Graeffe's_method" title="wikilink">Dandelin–Gräffe method</a> (sometimes also falsely ascribed to <a href="Nikolai_Ivanovich_Lobachevsky" title="wikilink">Lobachevsky</a>), which uses <a href="polynomial_transformations" title="wikilink">polynomial transformations</a> to repeatedly and implicitly square the roots. This greatly magnifies variances in the roots. Applying Viete's formulas, one obtains easy approximations for the modulus of the roots, and with some more effort, for the roots themselves.</p>
<h3 id="exclusion-and-enclosure-methods">Exclusion and enclosure methods</h3>

<p>Several fast tests exist that tell if a segment of the real line or a region of the complex plane contains no roots. By bounding the modulus of the roots and recursively subdividing the initial region indicated by these bounds, one can isolate small regions that may contain roots and then apply other methods to locate them exactly.</p>

<p>All these methods require to find the coefficients of shifted and scaled versions of the polynomial. For large degrees, FFT-based accelerated methods become viable.</p>

<p>For real roots, <a href="Sturm's_theorem" title="wikilink">Sturm's theorem</a> and <a href="Descartes'_rule_of_signs" title="wikilink">Descartes' rule of signs</a> with its extension in the Budan–Fourier theorem provide guides to locating and separating roots. This plus <a href="interval_arithmetic" title="wikilink">interval arithmetic</a> combined with <a href="Newton's_method" title="wikilink">Newton's method</a> yields robust and fast algorithms.</p>

<p>The <a href="Lehmer–Schur_algorithm" title="wikilink">Lehmer–Schur algorithm</a> uses the Schur–Cohn test for circles, Wilf's global bisection algorithm uses a winding number computation for rectangular regions in the complex plane.</p>

<p>The <a href="splitting_circle_method" title="wikilink">splitting circle method</a> uses FFT-based polynomial transformations to find large-degree factors corresponding to clusters of roots. The precision of the factorization is maximized using a Newton-type iteration. This method is useful for finding the roots of polynomials of high degree to arbitrary precision; it has almost optimal complexity in this setting.</p>
<h3 id="method-based-on-the-budanfourier-theorem-or-sturm-chains">Method based on the Budan–Fourier theorem or Sturm chains</h3>

<p>The methods in this class give for polynomials with rational coefficients, and when carried out in rational arithmetic, provably complete enclosures of all real roots by rational intervals. The test of an interval for real roots using Budan's theorem is computationally simple but may yield false positive results. However, these will be reliably detected in the following transformation and refinement of the interval. The test based on Sturm chains is computationally more involved but gives always the exact number of real roots in the interval.</p>

<p>The algorithm for isolating the roots, using Descartes' rule of signs and <a href="Budan's_theorem#Vincent's_theorem_(1834_and_1836)" title="wikilink">Vincent's theorem</a>, had been originally called <em>modified Uspensky's algorithm</em> by its inventors Collins and Akritas.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> After going through names like "Collins–Akritas method" and "Descartes' method" (too confusing if ones considers Fourier's article<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a>), it was finally François Boulier, of Lille University, who gave it the name <em><a href="Vincent's_theorem#Vincent–Collins–Akritas_(VCA,_1976)" title="wikilink">Vincent–Collins–Akritas</a></em> (VCA) method,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> p. 24, based on "Uspensky's method" not existing<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> and neither does "Descartes' method".<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> This algorithm has been improved by Rouillier and Zimmerman,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> and the resulting implementation is, to date, the fastest bisection method. It has the same worst case <a href="Computational_complexity_theory" title="wikilink">complexity</a> as the Sturm algorithm, but is almost always much faster. It is the default algorithm of <a href="Maple_(software)" title="wikilink">Maple</a> root-finding function <em>fsolve</em>. Another method based on <a href="Budan's_theorem#Vincent's_theorem_(1834_and_1836)" title="wikilink">Vincent's theorem</a> is the <em><a href="Vincent's_theorem#Vincent–Akritas–Strzeboński_(VAS,_2005)" title="wikilink">Vincent–Akritas–Strzeboński</a></em> (VAS) method;<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> it has been shown<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> that the VAS (continued fractions) method is faster than the fastest implementation of the VCA (bisection) method,<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> which was independently confirmed elsewhere;<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> more precisely, for the Mignotte polynomials of high degree, VAS is about 50,000 times faster than the fastest implementation of VCA. VAS is the default algorithm for root isolation in <a class="uri" href="Mathematica" title="wikilink">Mathematica</a>, <a href="Sage_(mathematics_software)" title="wikilink">Sage</a>, <a class="uri" href="SymPy" title="wikilink">SymPy</a>, <a class="uri" href="Xcas" title="wikilink">Xcas</a>. See <a href="Budan's_theorem" title="wikilink">Budan's theorem</a> for a description of the historical background of these methods. For a comparison between Sturm's method and VAS, use the functions realroot(poly) and time(realroot(poly)) of <a class="uri" href="Xcas" title="wikilink">Xcas</a>. By default, to isolate the real roots of poly realroot uses the VAS method; to use Sturm's method, write realroot(sturm, poly). See also the <a href="Root-finding_algorithm#External_links" title="wikilink">External links</a> for a pointer to an iPhone/iPod/iPad application that does the same thing.</p>
<h3 id="finding-multiple-roots-of-polynomials">Finding multiple roots of polynomials</h3>

<p>Most root-finding algorithms behave badly when there are <a href="Multiplicity_(mathematics)" title="wikilink">multiple roots</a> or very close roots. However, for polynomials whose coefficients are exactly given as <a href="integer" title="wikilink">integers</a> or <a href="rational_number" title="wikilink">rational numbers</a>, there is an efficient method to factorize them into factors that have only simple roots and whose coefficients are also exactly given. This method, called <strong><a href="square-free_factorization" title="wikilink">square-free factorization</a></strong>, is based on the multiple roots of a polynomial being the roots of the <a href="polynomial_greatest_common_divisor" title="wikilink">greatest common divisor</a> of the polynomial and its derivative.</p>

<p>The square-free factorization of a polynomial <em>p</em> is a factorization 

<math display="inline" id="Root-finding_algorithm:1">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>p</mi>
     <mn>1</mn>
    </msub>
    <msubsup>
     <mi>p</mi>
     <mn>2</mn>
     <mn>2</mn>
    </msubsup>
    <mi mathvariant="normal">⋯</mi>
    <msubsup>
     <mi>p</mi>
     <mi>k</mi>
     <mi>k</mi>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>p</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>p</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>p</ci>
       <ci>k</ci>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p=p_{1}p_{2}^{2}\cdots p_{k}^{k}
  </annotation>
 </semantics>
</math>

 where each 

<math display="inline" id="Root-finding_algorithm:2">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i}
  </annotation>
 </semantics>
</math>

 is either 1 or a polynomial without multiple roots, and two different 

<math display="inline" id="Root-finding_algorithm:3">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{i}
  </annotation>
 </semantics>
</math>


 do not have any common root.</p>

<p>An efficient method to compute this factorization is <a href="Square-free_factorization#Yun's_algorithm" title="wikilink">Yun's algorithm</a>.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Nth_root_algorithm" title="wikilink"><em>n</em>th root algorithm</a></li>
<li><a href="Broyden's_method" title="wikilink">Broyden's method</a></li>
<li><a href="Multiplicity_(mathematics)" title="wikilink">Multiplicity (mathematics)</a></li>
<li><a href="Polynomial_greatest_common_divisor" title="wikilink">Polynomial greatest common divisor</a></li>
<li><a class="uri" href="Polynomial" title="wikilink">Polynomial</a></li>
<li><a href="Graeffe's_method" title="wikilink">Graeffe's method</a></li>
<li><a href="Cryptographically_secure_pseudorandom_number_generator" title="wikilink">Cryptographically secure pseudorandom number generator</a> — a class of functions designed specifically to be unsolvable by root-finding algorithms.</li>
<li><a href="System_of_polynomial_equations" title="wikilink">System of polynomial equations</a> — root-finding algorithms in the multivariate case</li>
<li><a class="uri" href="MPSolve" title="wikilink">MPSolve</a></li>
<li><a href="GNU_Scientific_Library" title="wikilink">GNU Scientific Library</a></li>
</ul>
<h2 id="references">References</h2>

<p><strong>Notes</strong> <strong>Sources</strong> </p>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://math.fullerton.edu/mathews/a2001/Animations/RootFinding/FixedPoint/FixedPoint.html">Animations for Fixed Point Iteration</a></li>
<li><a href="http://gams.nist.gov/serve.cgi/Class/F1a1/">GAMS: Roots of polynomials with real coefficients</a></li>
<li><a href="http://www.hvks.com/Numerical/websolver.php">Free online polynomial root finder for both real and complex coefficients</a></li>
<li>Kehagias, Spyros: RealRoots, a free App for iPhone, iPod Touch and iPad to compare Sturm's method and VAS <a class="uri" href="https://itunes.apple.com/gr/app/realroots/id483609988?mt=8">https://itunes.apple.com/gr/app/realroots/id483609988?mt=8</a></li>
</ul>

<p><a class="uri" href="zh:介值定理#零点定理" title="wikilink">zh:介值定理#零点定理</a>"</p>

<p><a href="Category:Root-finding_algorithms" title="wikilink">*</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6">F. Rouillier and P. Zimmerman, <em>Efficient isolation of polynomial's real roots</em>, Journal of Computational and Applied Mathematics <strong>162</strong> (2004)<a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
</ol>
</section>
</body>
</html>
