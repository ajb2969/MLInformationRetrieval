<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1214">Flip-flop (electronics)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Flip-flop (electronics)</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>An animated interactive SR latch (<em>R1, R2</em> = 1 kΩ <em>R3, R4</em> = 10 kΩ).</figcaption>
</figure>
<figure><b>(Figure)</b>
<figcaption>An SR latch, constructed from a pair of cross-coupled <a href="NOR_gate" title="wikilink">NOR</a> <a href="logic_gate" title="wikilink">gates</a>.</figcaption>
</figure>

<p>In <a class="uri" href="electronics" title="wikilink">electronics</a>, a <strong>flip-flop</strong> or <strong>latch</strong> is a <a href="electronic_circuit" title="wikilink">circuit</a> that has two stable states and can be used to store state information. A flip-flop is a <a href="bistable_multivibrator" title="wikilink">bistable multivibrator</a>. The circuit can be made to change state by signals applied to one or more control inputs and will have one or two outputs. It is the basic storage element in <a href="sequential_logic" title="wikilink">sequential logic</a>. Flip-flops and latches are a fundamental building block of <a href="digital_electronics" title="wikilink">digital electronics</a> systems used in computers, communications, and many other types of systems.</p>

<p>Flip-flops and latches are used as data storage elements. A flip-flop stores a single <em><a href="binary_digit" title="wikilink">bit</a></em> (binary digit) of data; one of its two states represents a "one" and the other represents a "zero". Such data storage can be used for storage of <em><a href="state_(computer_science)" title="wikilink">state</a></em>, and such a circuit is described as <a href="sequential_logic" title="wikilink">sequential logic</a>. When used in a <a href="finite-state_machine" title="wikilink">finite-state machine</a>, the output and next state depend not only on its current input, but also on its current state (and hence, previous inputs). It can also be used for counting of pulses, and for synchronizing variably-timed input signals to some reference timing signal.</p>

<p>Flip-flops can be either simple (transparent or opaque) or <a href="clock_signal" title="wikilink">clocked</a> (synchronous or edge-triggered). Although the term flip-flop has historically referred generically to both simple and clocked circuits, in modern usage it is common to reserve the term <em>flip-flop</em> exclusively for discussing clocked circuits; the simple ones are commonly called <em>latches</em>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Using this terminology, a latch is level-sensitive, whereas a flip-flop is edge-sensitive. That is, when a latch is enabled it becomes transparent, while a flip flop's output only changes on a single type (positive going or negative going) of clock edge.</p>
<h2 id="history">History</h2>

<p> The first electronic flip-flop was invented in 1918 by the British physicists <a href="William_Eccles" title="wikilink">William Eccles</a> and <a href="F._W._Jordan" title="wikilink">F. W. Jordan</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> It was initially called the <em>Eccles–Jordan trigger circuit</em> and consisted of two active elements (<a href="vacuum_tube" title="wikilink">vacuum tubes</a>).<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> The design was used in the 1943 British <a href="Colossus_computer" title="wikilink">Colossus codebreaking computer</a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> and such circuits and their transistorized versions were common in computers even after the introduction of <a href="integrated_circuit" title="wikilink">integrated circuits</a>, though flip-flops made from <a href="logic_gate" title="wikilink">logic gates</a> are also common now.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Early flip-flops were known variously as trigger circuits or <a href="multivibrator" title="wikilink">multivibrators</a>.</p>

<p>According to P. L. Lindley, an engineer at the US <a href="Jet_Propulsion_Laboratory" title="wikilink">Jet Propulsion Laboratory</a>, the flip-flop types detailed below (RS, D, T, JK) were first discussed in a 1954 <a class="uri" href="UCLA" title="wikilink">UCLA</a> course on computer design by Montgomery Phister, and then appeared in his book <em>Logical Design of Digital Computers.</em><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> Lindley was at the time working at Hughes Aircraft under Eldred Nelson, who had coined the term JK for a flip-flop which changed states when both inputs were on (a logical "one"). The other names were coined by Phister. They differ slightly from some of the definitions given below. Lindley explains that he heard the story of the JK flip-flop from Eldred Nelson, who is responsible for coining the term while working at <a href="Hughes_Aircraft" title="wikilink">Hughes Aircraft</a>. Flip-flops in use at Hughes at the time were all of the type that came to be known as J-K. In designing a logical system, Nelson assigned letters to flip-flop inputs as follows: #1: A &amp; B, #2: C &amp; D, #3: E &amp; F, #4: G &amp; H, #5: J &amp; K. Nelson used the notations "<em>j</em>-input" and "<em>k</em>-input" in a patent application filed in 1953.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>
<h2 id="implementation">Implementation</h2>
<figure><b>(Figure)</b>
<figcaption>A traditional flip-flop circuit based on <a href="bipolar_junction_transistor" title="wikilink">bipolar junction transistors</a></figcaption>
</figure>

<p>Flip-flops can be either simple (transparent or asynchronous) or clocked (synchronous); the transparent ones are commonly called latches.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> The word <em>latch</em> is mainly used for storage elements, while clocked devices are described as <em>flip-flops</em>.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>Simple flip-flops can be built around a pair of cross-coupled inverting elements: <a href="vacuum_tube" title="wikilink">vacuum tubes</a>, <a href="bipolar_transistor" title="wikilink">bipolar transistors</a>, <a href="field_effect_transistor" title="wikilink">field effect transistors</a>, <a href="inverter_(logic_gate)" title="wikilink">inverters</a>, and inverting <a href="logic_gate" title="wikilink">logic gates</a> have all been used in practical circuits. Clocked devices are specially designed for synchronous systems; such devices ignore their inputs except at the transition of a dedicated clock signal (known as clocking, pulsing, or strobing). Clocking causes the flip-flop to either change or retain its output signal based upon the values of the input signals at the transition. Some flip-flops change output on the rising <a href="signal_edge" title="wikilink">edge</a> of the clock, others on the falling edge.</p>

<p>Since the elementary amplifying stages are inverting, two stages can be connected in succession (as a cascade) to form the needed non-inverting amplifier. In this configuration, each amplifier may be considered as an active inverting feedback network for the other inverting amplifier. Thus the two stages are connected in a non-inverting loop although the circuit diagram is usually drawn as a symmetric cross-coupled pair (both the <a href=":File:Eccles-Jordan_trigger_circuit_flip-flip_drawings.png" title="wikilink">drawings</a> are initially introduced in the Eccles–Jordan patent).</p>
<h2 id="flip-flop-types">Flip-flop types</h2>

<p>Flip-flops can be divided into common types: the <strong>SR</strong> ("set-reset"), <strong>D</strong> ("data" or "delay"<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a>), <strong>T</strong> ("toggle"), and <strong>JK</strong> types are the common ones. The behavior of a particular type can be described by what is termed the characteristic equation, which derives the "next" (i.e., after the next clock pulse) output, <mtpl></mtpl> in terms of the input signal(s) and/or the current output, 

<math display="inline" id="Flip-flop_(electronics):0">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="simple-set-reset-latches">Simple set-reset latches</h3>
<h4 id="sr-nor-latch">SR NOR latch</h4>

<p> When using static gates as building blocks, the most fundamental latch is the simple <em>SR latch</em>, where S and R stand for <em>set</em> and <em>reset</em>. It can be constructed from a pair of cross-coupled <a href="NOR_gate" title="wikilink">NOR</a> <a href="logic_gate" title="wikilink">logic gates</a>. The stored bit is present on the output marked Q.</p>

<p>While the S and R inputs are both low, <a class="uri" href="feedback" title="wikilink">feedback</a> maintains the Q and 

<math display="inline" id="Flip-flop_(electronics):1">
 <semantics>
  <mover accent="true">
   <mi>Q</mi>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{Q}
  </annotation>
 </semantics>
</math>

 outputs in a constant state, with 

<math display="inline" id="Flip-flop_(electronics):2">
 <semantics>
  <mover accent="true">
   <mi>Q</mi>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{Q}
  </annotation>
 </semantics>
</math>

 the complement of Q. If S (<em>Set</em>) is pulsed high while R (<em>Reset</em>) is held low, then the Q output is forced high, and stays high when S returns to low; similarly, if R is pulsed high while S is held low, then the Q output is forced low, and stays low when R returns to low.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>SR latch operation<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="State_transition_table" title="wikilink">Characteristic table</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>S</strong></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
</tr>
</tbody>
</table>

<p>''Note: X means <em>don't care</em>, that is, either 0 or 1 is a valid value.''</p>

<p>The R = S = 1 combination is called a <strong>restricted combination</strong> or a <strong>forbidden state</strong> because, as both NOR gates then output zeros, it breaks the logical equation Q = <strong>not</strong> 

<math display="inline" id="Flip-flop_(electronics):3">
 <semantics>
  <mover accent="true">
   <mi>Q</mi>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{Q}
  </annotation>
 </semantics>
</math>

. The combination is also inappropriate in circuits where <em>both</em> inputs may go low <em>simultaneously</em> (i.e. a transition from <em>restricted</em> to <em>keep</em>). The output would lock at either 1 or 0 depending on the propagation time relations between the gates (a <a href="race_condition" title="wikilink">race condition</a>).</p>

<p>To overcome the restricted combination, one can add gates to the inputs that would convert <code>(S,R) = (1,1)</code> to one of the non-restricted combinations. That can be:</p>
<ul>
<li>Q = 1 (1,0) – referred to as an <em>S (dominated)-latch</em></li>
<li>Q = 0 (0,1) – referred to as an <em>R (dominated)-latch</em></li>
</ul>

<p>This is done in nearly every <a href="programmable_logic_controller" title="wikilink">programmable logic controller</a>.</p>
<ul>
<li>Keep state (0,0) – referred to as an <em>E-latch</em></li>
</ul>

<p>Alternatively, the restricted combination can be made to <em>toggle</em> the output. The result is the <a href="#JK_latch" title="wikilink">JK latch</a>.</p>

<p>Characteristic: Q+ = R'Q + R'S or Q+ = R'Q + S.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<h4 id="overlinesr-nand-latch">

<math display="inline" id="Flip-flop_(electronics):4">
 <semantics>
  <mover accent="true">
   <mrow>
    <mi>S</mi>
    <mi>R</mi>
   </mrow>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{SR}
  </annotation>
 </semantics>
</math>

 NAND latch</h4>
<figure><b>(Figure)</b>
<figcaption>An 

<math display="inline" id="Flip-flop_(electronics):5">
 <semantics>
  <mover accent="true">
   <mrow>
    <mi>S</mi>
    <mi>R</mi>
   </mrow>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{SR}
  </annotation>
 </semantics>
</math>

 latch</figcaption>
</figure>

<p>This is an alternate model of the simple SR latch which is built with <a href="NAND_gate" title="wikilink">NAND</a> <a href="logic_gate" title="wikilink">logic gates</a>. <em>Set</em> and <em>reset</em> now become active low signals, denoted 

<math display="inline" id="Flip-flop_(electronics):6">
 <semantics>
  <mover accent="true">
   <mi>S</mi>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{S}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Flip-flop_(electronics):7">
 <semantics>
  <mover accent="true">
   <mi>R</mi>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{R}
  </annotation>
 </semantics>
</math>

 respectively. Otherwise, operation is identical to that of the SR latch. Historically, 

<math display="inline" id="Flip-flop_(electronics):8">
 <semantics>
  <mover accent="true">
   <mrow>
    <mi>S</mi>
    <mi>R</mi>
   </mrow>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{SR}
  </annotation>
 </semantics>
</math>

-latches have been predominant despite the notational inconvenience of <a href="logic_level" title="wikilink">active-low</a> inputs.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>

<math display="inline" id="Flip-flop_(electronics):9">
 <semantics>
  <mover accent="true">
   <mrow>
    <mi>S</mi>
    <mi>R</mi>
   </mrow>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{SR}
  </annotation>
 </semantics>
</math>

 latch operation</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>

<math display="inline" id="Flip-flop_(electronics):10">
 <semantics>
  <mover accent="true">
   <mi>S</mi>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{S}
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
</tr>
</tbody>
</table></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Symbol for an 

<math display="inline" id="Flip-flop_(electronics):11">
 <semantics>
  <mover accent="true">
   <mrow>
    <mi>S</mi>
    <mi>R</mi>
   </mrow>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{SR}
  </annotation>
 </semantics>
</math>

 NAND latch</figcaption>
</figure></td>
</tr>
</tbody>
</table>
<h4 id="jk-latch">JK latch</h4>

<p>The JK latch is much less frequently used than the JK flip-flop. The JK latch follows the following state table:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><strong>JK latch truth table</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>J</strong></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
</tr>
</tbody>
</table>

<p>Hence, the JK latch is an SR latch that is made to <em>toggle</em> its output (oscillate between 0 and 1) when passed the input combination of 11.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> Unlike the JK flip-flop, the 11 input combination for the JK latch is not very useful because there is no clock that directs toggling.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>
<h3 id="gated-latches-and-conditional-transparency">Gated latches and conditional transparency</h3>

<p>Latches are designed to be <em>transparent.</em> That is, input signal changes cause immediate changes in output; when several <em>transparent</em> latches follow each other, using the same enable signal, signals can propagate through all of them at once. Alternatively, additional logic can be added to a simple transparent latch to make it <em>non-transparent</em> or <em>opaque</em> when another input (an "enable" input) is not asserted. By following a <em>transparent-high</em> latch with a <em>transparent-low</em> (or <em>opaque-high</em>) latch, a master–slave flip-flop is implemented.</p>
<h4 id="gated-sr-latch">Gated SR latch</h4>
<figure><b>(Figure)</b>
<figcaption>A gated SR latch circuit diagram constructed from NOR gates.</figcaption>
</figure>

<p>A <em>synchronous SR latch</em> (sometimes <em>clocked SR flip-flop</em>) can be made by adding a second level of NAND gates to the inverted SR latch (or a second level of AND gates to the direct SR latch). The extra NAND gates further invert the inputs so the simple 

<math display="inline" id="Flip-flop_(electronics):12">
 <semantics>
  <mover accent="true">
   <mrow>
    <mi>S</mi>
    <mi>R</mi>
   </mrow>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{SR}
  </annotation>
 </semantics>
</math>

 latch becomes a gated SR latch (and a simple SR latch would transform into a gated 

<math display="inline" id="Flip-flop_(electronics):13">
 <semantics>
  <mover accent="true">
   <mrow>
    <mi>S</mi>
    <mi>R</mi>
   </mrow>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{SR}
  </annotation>
 </semantics>
</math>

 latch with inverted enable).</p>

<p>With E high (<em>enable</em> true), the signals can pass through the input gates to the encapsulated latch; all signal combinations except for (0,0) = <em>hold</em> then immediately reproduce on the (Q,

<math display="inline" id="Flip-flop_(electronics):14">
 <semantics>
  <mover accent="true">
   <mi>Q</mi>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{Q}
  </annotation>
 </semantics>
</math>

) output, i.e. the latch is <em>transparent</em>.</p>

<p>With E low (<em>enable</em> false) the latch is <em>closed (opaque)</em> and remains in the state it was left the last time E was high.</p>

<p>The <em>enable</em> input is sometimes a <a href="clock_signal" title="wikilink">clock signal</a>, but more often a read or write strobe.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
</tr>
<tr class="even">
</tr>
<tr class="odd">
</tr>
<tr class="even">
</tr>
<tr class="odd">
</tr>
</tbody>
</table></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Symbol for a gated SR latch</figcaption>
</figure></td>
</tr>
</tbody>
</table>
<h4 id="gated-d-latch">Gated D latch</h4>
<figure><b>(Figure)</b>
<figcaption>A D-type transparent latch based on an 

<math display="inline" id="Flip-flop_(electronics):15">
 <semantics>
  <mover accent="true">
   <mrow>
    <mi>S</mi>
    <mi>R</mi>
   </mrow>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{SR}
  </annotation>
 </semantics>
</math>

 NAND latch</figcaption>
</figure>
<figure><b>(Figure)</b>
<figcaption>A gated D latch based on an SR NOR latch</figcaption>
</figure>
<figure><b>(Figure)</b>
<figcaption>A gated D latch in <a href="pass_transistor_logic" title="wikilink">pass transistor logic</a>, similar to the ones in the CD4042 or the CD74HC75 integrated circuits. </figcaption>
</figure>

<p>This latch exploits the fact that, in the two active input combinations (01 and 10) of a gated SR latch, R is the complement of S. The input NAND stage converts the two D input states (0 and 1) to these two input combinations for the next 

<math display="inline" id="Flip-flop_(electronics):16">
 <semantics>
  <mover accent="true">
   <mrow>
    <mi>S</mi>
    <mi>R</mi>
   </mrow>
   <mo>¯</mo>
  </mover>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-¯</ci>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>R</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \overline{SR}
  </annotation>
 </semantics>
</math>

 latch by inverting the data input signal. The low state of the <em>enable</em> signal produces the inactive "11" combination. Thus a gated D-latch may be considered as a <em>one-input synchronous SR latch</em>. This configuration prevents application of the restricted input combination. It is also known as <em>transparent latch</em>, <em>data latch</em>, or simply <em>gated latch</em>. It has a <em>data</em> input and an <em>enable</em> signal (sometimes named <em>clock</em>, or <em>control</em>). The word <em>transparent</em> comes from the fact that, when the enable input is on, the signal propagates directly through the circuit, from the input D to the output Q.</p>

<p>Transparent latches are typically used as I/O ports or in asynchronous systems, or in synchronous two-phase systems (<a href="synchronous_system" title="wikilink">synchronous systems</a> that use a <a href="two-phase_clock" title="wikilink">two-phase clock</a>), where two latches operating on different clock phases prevent data transparency as in a master–slave flip-flop.</p>

<p>Latches are available as <a href="integrated_circuit" title="wikilink">integrated circuits</a>, usually with multiple latches per chip. For example, 74HC75 is a quadruple transparent latch in the <a href="7400_series" title="wikilink">7400 series</a>.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><table>
<tbody>
<tr class="odd">
</tr>
<tr class="even">
</tr>
<tr class="odd">
</tr>
<tr class="even">
</tr>
<tr class="odd">
</tr>
<tr class="even">
</tr>
</tbody>
</table></td>
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption>Symbol for a gated D latch</figcaption>
</figure></td>
</tr>
</tbody>
</table>

<p>The truth table shows that when the <em>e</em>nable/<em>c</em>lock input is 0, the D input has no effect on the output. When E/C is high, the output equals D.</p>
<h4 id="earle-latch">Earle latch</h4>

<p> The classic gated latch designs have some undesirable characteristics.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> They require double-rail logic or an inverter. The input-to-output propagation may take up to three gate delays. The input-to-output propagation is not constant – some outputs take two gate delays while others take three.</p>

<p>Designers looked for alternatives.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> A successful alternative is the Earle latch. It requires only a single data input, and its output takes a constant two gate delays. In addition, the two gate levels of the Earle latch can, in some cases, be merged with the last two gate levels of the circuits driving the latch because many common computational circuits have an OR layer followed by an AND layer as their last two levels. Merging the latch function can implement the latch with no additional gate delays.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> The merge is commonly exploited in the design of pipelined computers, and, in fact, was originally developed by J. G. Earle to be used in the IBM System/360 Model 91 for that purpose.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>

<p>The Earle latch is hazard free.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> If the middle NAND gate is omitted, then one gets the <strong>polarity hold latch</strong>, which is commonly used because it demands less logic.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a><a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> However, it is susceptible to <a href="#Metastability" title="wikilink">logic hazard</a>. Intentionally skewing the clock signal can avoid the hazard.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a> </p>
<h3 id="d-flip-flop">D flip-flop</h3>
<figure><b>(Figure)</b>
<figcaption>D flip-flop symbol</figcaption>
</figure>

<p>The D ﬂip-ﬂop is widely used. It is also known as a "data" or "delay" flip-flop.</p>

<p>The D flip-flop captures the value of the D-input at a definite portion of the clock cycle (such as the rising edge of the clock). That captured value becomes the Q output. At other times, the output Q does not change.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a><a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a> The D flip-flop can be viewed as a memory cell, a <a href="zero-order_hold" title="wikilink">zero-order hold</a>, or a <a href="Analog_delay_line" title="wikilink">delay line</a>.</p>

<p>Truth table:</p>

<p>::{|class="wikitable" style="text-align:center" ||<strong>Clock</strong>||<strong>D</strong>||<strong>Q<sub>next</sub></strong> |- ||Rising edge||0||0 |- ||Rising edge||1||1 |- ||Non-Rising||X||Q |} ('X' denotes a <em><a href="Don't_care" title="wikilink">Don't care</a></em> condition, meaning the signal is irrelevant)</p>

<p>Most D-type flip-flops in ICs have the capability to be forced to the set or reset state (which ignores the D and clock inputs), much like an SR flip-flop. Usually, the illegal S = R = 1 condition is resolved in D-type flip-flops. By setting S = R = 0, the flip-flop can be used as described above. Here is the truth table for the others S and R possible configurations:</p>

<p>::{|class="wikitable" style="text-align:center" width=150 !Inputs!!Outputs |- |<strong>S</strong>||<strong>R</strong>||<strong>D</strong>||<strong>&gt;</strong>||<strong>Q</strong>||<strong>Q</strong>' |- ||0||1||X||X||0||1 |- ||1||0||X||X||1||0 |- ||1||1||X||X||1||1 |}</p>
<figure><b>(Figure)</b>
<figcaption>4-bit <a href="Shift_register#Serial-in,_parallel-out_(SIPO)" title="wikilink">serial-in, parallel-out (SIPO) shift register</a></figcaption>
</figure>

<p>These flip-flops are very useful, as they form the basis for <a href="shift_registers" title="wikilink">shift registers</a>, which are an essential part of many electronic devices. The advantage of the D flip-flop over the D-type "transparent latch" is that the signal on the D input pin is captured the moment the flip-flop is clocked, and subsequent changes on the D input will be ignored until the next clock event. An exception is that some flip-flops have a "reset" signal input, which will reset Q (to zero), and may be either asynchronous or synchronous with the clock.</p>

<p>The above circuit shifts the contents of the register to the right, one bit position on each active transition of the clock. The input X is shifted into the leftmost bit position.</p>
<h4 id="classical-positive-edge-triggered-d-flip-flop">Classical positive-edge-triggered D flip-flop</h4>

<p> This circuit<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> consists of two stages implemented by <a href="#SR_NAND_latch" title="wikilink"><span style="text-decoration:overline">SR</span> NAND latches</a>. The input stage (the two latches on the left) processes the clock and data signals to ensure correct input signals for the output stage (the single latch on the right). If the clock is low, both the output signals of the input stage are high regardless of the data input; the output latch is unaffected and it stores the previous state. When the clock signal changes from low to high, only one of the output voltages (depending on the data signal) goes low and sets/resets the output latch: if D = 0, the lower output becomes low; if D = 1, the upper output becomes low. If the clock signal continues staying high, the outputs keep their states regardless of the data input and force the output latch to stay in the corresponding state as the input logical zero (of the output stage) remains active while the clock is high. Hence the role of the output latch is to store the data only while the clock is low.</p>

<p>The circuit is closely related to the <a href="#Gated_D_latch" title="wikilink">gated D latch</a> as both the circuits convert the two D input states (0 and 1) to two input combinations (01 and 10) for the output <span style="text-decoration:overline">SR</span> latch by inverting the data input signal (both the circuits split the single D signal in two complementary <span style="text-decoration:overline">S</span> and <span style="text-decoration:overline">R</span> signals). The difference is that in the gated D latch simple NAND logical gates are used while in the positive-edge-triggered D flip-flop <span style="text-decoration:overline">SR</span> NAND latches are used for this purpose. The role of these latches is to "lock" the active output producing low voltage (a logical zero); thus the positive-edge-triggered D flip-flop can also be thought of as a gated D latch with latched input gates.</p>
<h4 id="masterslave-edge-triggered-d-flip-flop">Master–slave edge-triggered D flip-flop</h4>

<p>A master–slave D flip-flop is created by connecting two <a href="gated_D_latch" title="wikilink">gated D latches</a> in series, and inverting the <em>enable</em> input to one of them. It is called master–slave because the second latch in the series only changes in response to a change in the first (master) latch.</p>
<figure><b>(Figure)</b>
<figcaption>A master–slave D flip-flop. It responds on the falling edge of the <em>enable</em> input (usually a clock)</figcaption>
</figure>
<figure><b>(Figure)</b>
<figcaption>An implementation of a master–slave D flip-flop that is triggered on the rising edge of the clock</figcaption>
</figure>

<p>For a positive-edge triggered master–slave D flip-flop, when the clock signal is low (logical 0) the "enable" seen by the first or "master" D latch (the inverted clock signal) is high (logical 1). This allows the "master" latch to store the input value when the clock signal transitions from low to high. As the clock signal goes high (0 to 1) the inverted "enable" of the first latch goes low (1 to 0) and the value seen at the input to the master latch is "locked". Nearly simultaneously, the twice inverted "enable" of the second or "slave" D latch transitions from low to high (0 to 1) with the clock signal. This allows the signal captured at the rising edge of the clock by the now "locked" master latch to pass through the "slave" latch. When the clock signal returns to low (1 to 0), the output of the "slave" latch is "locked", and the value seen at the last rising edge of the clock is held while the "master" latch begins to accept new values in preparation for the next rising clock edge.</p>

<p>By removing the leftmost inverter in the circuit at side, a D-type flip-flop that strobes on the <em>falling edge</em> of a clock signal can be obtained. This has a truth table like this:</p>

<p>::{|class="wikitable" style="text-align:center" ||<strong>D</strong>||<strong>Q</strong>||<strong>&gt;</strong>||<strong>Q<sub>next</sub></strong> |- ||0||X||Falling||0 |- ||1||X||Falling||1 |}</p>
<figure><b>(Figure)</b>
<figcaption>A CMOS IC implementation of a "true single-phase edge-triggered flip-flop with reset"</figcaption>
</figure>
<h4 id="edge-triggered-dynamic-d-storage-element">Edge-triggered dynamic D storage element</h4>

<p>An efficient functional alternative to a D flip-flop can be made with dynamic circuits (where information is stored in a capacitance) as long as it is clocked often enough; while not a true flip-flop, it is still called a flip-flop for its functional role. While the master–slave D element is triggered on the edge of a clock, its components are each triggered by clock levels. The "edge-triggered D flip-flop", as it is called even though it is not a true flip-flop, does not have the master–slave properties.</p>

<p>Edge-triggered D flip-flops are often implemented in integrated high-speed operations using <a href="dynamic_logic_(digital_electronics)" title="wikilink">dynamic logic</a>. This means that the digital output is stored on parasitic device capacitance while the device is not transitioning. This design of dynamic flip flops also enables simple resetting since the reset operation can be performed by simply discharging one or more internal nodes. A common dynamic flip-flop variety is the true single-phase clock (TSPC) type which performs the flip-flop operation with little power and at high speeds. However, dynamic flip-flops will typically not work at static or low clock speeds: given enough time, leakage paths may discharge the parasitic capacitance enough to cause the flip-flop to enter invalid states.</p>
<h3 id="t-flip-flop">T flip-flop</h3>

<p> If the T input is high, the T flip-flop changes state ("toggles") whenever the clock input is strobed. If the T input is low, the flip-flop holds the previous value. This behavior is described by the characteristic <a class="uri" href="equation" title="wikilink">equation</a>:</p>

<p>

<math display="block" id="Flip-flop_(electronics):17">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mrow>
     <mi>n</mi>
     <mi>e</mi>
     <mi>x</mi>
     <mi>t</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>T</mi>
    <mo>⊕</mo>
    <mi>Q</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>T</mi>
     <mover accent="true">
      <mi>Q</mi>
      <mo>¯</mo>
     </mover>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mover accent="true">
      <mi>T</mi>
      <mo>¯</mo>
     </mover>
     <mi>Q</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>Q</ci>
      <apply>
       <times></times>
       <ci>n</ci>
       <ci>e</ci>
       <ci>x</ci>
       <ci>t</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">direct-sum</csymbol>
      <ci>T</ci>
      <ci>Q</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>T</ci>
       <apply>
        <ci>normal-¯</ci>
        <ci>Q</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <ci>normal-¯</ci>
        <ci>T</ci>
       </apply>
       <ci>Q</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{next}=T\oplus Q=T\overline{Q}+\overline{T}Q
  </annotation>
 </semantics>
</math>

 (expanding the <a href="XOR_gate" title="wikilink">XOR</a> operator)</p>

<p>and can be described in a <a href="truth_table" title="wikilink">truth table</a>:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>T flip-flop operation<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="State_transition_table" title="wikilink">Characteristic table</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>

<math display="inline" id="Flip-flop_(electronics):18">
 <semantics>
  <mi>T</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>T</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>| 0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>| 0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>| 1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>| 1</p></td>
</tr>
</tbody>
</table>

<p>When T is held high, the toggle flip-flop divides the clock frequency by two; that is, if clock frequency is 4 MHz, the output frequency obtained from the flip-flop will be 2 MHz. This "divide by" feature has application in various types of digital <a href="Counter_(digital)" title="wikilink">counters</a>. A T flip-flop can also be built using a JK flip-flop (J &amp; K pins are connected together and act as T) or D flip-flop (T input and Q<sub>previous</sub> is connected to the D input through an XOR gate).</p>
<h3 id="jk-flip-flop">JK flip-flop</h3>

<p> <a href="File:JK_flip-flop_NAND.svg" title="wikilink">thumb|right|128px |A JK flip-flop made of NAND gates</a> The JK flip-flop augments the behavior of the SR flip-flop (J=Set, K=Reset) by interpreting the J = K = 1 condition as a "flip" or toggle command. Specifically, the combination J = 1, K = 0 is a command to set the flip-flop; the combination J = 0, K = 1 is a command to reset the flip-flop; and the combination J = K = 1 is a command to toggle the flip-flop, i.e., change its output to the logical complement of its current value. Setting J = K = 0 does NOT result in a D flip-flop, but rather, will hold the current state. To synthesize a D flip-flop, simply set K equal to the complement of J. Similarly, to synthesize a T flip-flop, set K equal to J. The JK flip-flop is therefore a universal flip-flop, because it can be configured to work as an SR flip-flop, a D flip-flop, or a T flip-flop.</p>

<p>The characteristic equation of the JK flip-flop is:</p>

<p>

<math display="inline" id="Flip-flop_(electronics):19">
 <semantics>
  <mrow>
   <msub>
    <mi>Q</mi>
    <mrow>
     <mi>n</mi>
     <mi>e</mi>
     <mi>x</mi>
     <mi>t</mi>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>J</mi>
     <mover accent="true">
      <mi>Q</mi>
      <mo>¯</mo>
     </mover>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mover accent="true">
      <mi>K</mi>
      <mo>¯</mo>
     </mover>
     <mi>Q</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Q</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <ci>e</ci>
      <ci>x</ci>
      <ci>t</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>J</ci>
      <apply>
       <ci>normal-¯</ci>
       <ci>Q</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <ci>normal-¯</ci>
       <ci>K</ci>
      </apply>
      <ci>Q</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q_{next}=J\overline{Q}+\overline{K}Q
  </annotation>
 </semantics>
</math>

</p>

<p>and the corresponding truth table is:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>JK flip-flop operation<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a></p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><a href="State_transition_table" title="wikilink">Characteristic table</a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>J</strong></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>0</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>1</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
</tr>
</tbody>
</table>
<h2 id="timing-considerations">Timing considerations</h2>
<h3 id="setup-hold-recovery-removal-times">Setup, hold, recovery, removal times</h3>

<p> <strong>Setup time</strong> is the minimum amount of time the data signal should be held steady <strong>before</strong> the clock event so that the data is reliably sampled by the clock. This applies to synchronous input signals to the flip-flop.</p>

<p><strong>Hold time</strong> is the minimum amount of time the data signal should be held steady <strong>after</strong> the clock event so that the data are reliably sampled. This applies to synchronous input signals to the flip-flop.</p>

<p>Synchronous signals (like Data) should be held steady from the set-up time to the hold time, where both times are relative to the clock signal.</p>

<p><strong>Recovery time</strong> is like setup time for asynchronous ports (set, reset). It is the time available between the asynchronous signals going inactive and the active clock edge.</p>

<p><strong>Removal time</strong> is like hold time for asynchronous ports (set, reset). It is the time between active clock edge and asynchronous signal going inactive.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a></p>

<p>Short impulses applied to asynchronous inputs (set, reset) should not be applied completely within the recovery-removal period, or else it becomes entirely indeterminable whether the flip-flop will transition to the appropriate state. In another case, where an asynchronous signal simply makes one transition that happens to fall between the recovery/removal time, eventually the flip-flop will transition to the appropriate state, but a very short glitch may or may not appear on the output, dependent on the synchronous input signal. This second situation may or may not have significance to a circuit design.</p>

<p>Set and Reset (and other) signals may be either synchronous or asynchronous and therefore may be characterized with either Setup/Hold or Recovery/Removal times, and synchronicity is very dependent on the <a href="Transistor–transistor_logic" title="wikilink">TTL</a> design of the flip-flop.</p>

<p>Differentiation between Setup/Hold and Recovery/Removal times is often necessary when verifying the timing of larger circuits because asynchronous signals may be found to be less critical than synchronous signals. The differentiation offers circuit designers the ability to define the verification conditions for these types of signals independently.</p>
<h3 id="metastability">Metastability</h3>

<p>Flip-flops are subject to a problem called <a href="Metastability_in_electronics" title="wikilink">metastability</a>, which can happen when two inputs, such as data and clock or clock and reset, are changing at about the same time. When the order is not clear, within appropriate timing constraints, the result is that the output may behave unpredictably, taking many times longer than normal to settle to one state or the other, or even oscillating several times before settling. Theoretically, the time to settle down is not bounded. In a <a class="uri" href="computer" title="wikilink">computer</a> system, this metastability can cause corruption of data or a program crash if the state is not stable before another circuit uses its value; in particular, if two different logical paths use the output of a flip-flop, one path can interpret it as a 0 and the other as a 1 when it has not resolved to stable state, putting the machine into an inconsistent state.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></p>

<p>The metastability in flip-flops can be avoided by ensuring that the data and control inputs are held valid and constant for specified periods before and after the clock pulse, called the <strong>setup time</strong> (t<sub>su</sub>) and the <strong>hold time</strong> (t<sub>h</sub>) respectively. These times are specified in the data sheet for the device, and are typically between a few nanoseconds and a few hundred picoseconds for modern devices. Depending upon the flip-flop's internal organization, it is possible to build a device with a zero (or even negative) setup or hold time requirement but not both simultaneously.</p>

<p>Unfortunately, it is not always possible to meet the setup and hold criteria, because the flip-flop may be connected to a real-time signal that could change at any time, outside the control of the designer. In this case, the best the designer can do is to reduce the probability of error to a certain level, depending on the required reliability of the circuit. One technique for suppressing metastability is to connect two or more flip-flops in a chain, so that the output of each one feeds the data input of the next, and all devices share a common clock. With this method, the probability of a metastable event can be reduced to a negligible value, but never to zero. The probability of metastability gets closer and closer to zero as the number of flip-flops connected in series is increased. The number of flip-flops being cascaded is referred to as the "ranking"; "dual-ranked" flip flops (two flip-flops in series) is a common situation.</p>

<p>So-called metastable-hardened flip-flops are available, which work by reducing the setup and hold times as much as possible, but even these cannot eliminate the problem entirely. This is because metastability is more than simply a matter of circuit design. When the transitions in the clock and the data are close together in time, the flip-flop is forced to decide which event happened first. However fast we make the device, there is always the possibility that the input events will be so close together that it cannot detect which one happened first. It is therefore logically impossible to build a perfectly metastable-proof flip-flop. Flip-flops are sometimes characterized for a maximum settling time (the maximum time they will remain metastable under specified conditions). In this case, dual-ranked flip-flops that are clocked slower than the maximum allowed metastability time will provide proper conditioning for asynchronous (e.g., external) signals.</p>
<h3 id="propagation-delay">Propagation delay</h3>

<p>Another important timing value for a flip-flop is the clock-to-output delay (common symbol in data sheets: t<sub>CO</sub>) or <a href="propagation_delay" title="wikilink">propagation delay</a> (t<sub>P</sub>), which is the time a flip-flop takes to change its output after the clock edge. The time for a high-to-low transition (t<sub>PHL</sub>) is sometimes different from the time for a low-to-high transition (t<sub>PLH</sub>).</p>

<p>When cascading flip-flops which share the same clock (as in a <a href="shift_register" title="wikilink">shift register</a>), it is important to ensure that the t<sub>CO</sub> of a preceding flip-flop is longer than the hold time (t<sub>h</sub>) of the following flip-flop, so data present at the input of the succeeding flip-flop is properly "shifted in" following the active edge of the clock. This relationship between t<sub>CO</sub> and t<sub>h</sub> is normally guaranteed if the flip-flops are physically identical. Furthermore, for correct operation, it is easy to verify that the clock period has to be greater than the sum t<sub>su</sub> + t<sub>h</sub>.</p>
<h2 id="generalizations">Generalizations</h2>

<p>Flip-flops can be generalized in at least two ways: by making them 1-of-N instead of 1-of-2, and by adapting them to logic with more than two states. In the special cases of 1-of-3 encoding, or multi-valued <a href="ternary_logic" title="wikilink">ternary logic</a>, these elements may be referred to as <em>flip-flap-flops</em>.<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a></p>

<p>In a conventional flip-flop, exactly one of the two complementary outputs is high. This can be generalized to a memory element with N outputs, exactly one of which is high (alternatively, where exactly one of N is low). The output is therefore always a <a class="uri" href="one-hot" title="wikilink">one-hot</a> (respectively <em>one-cold</em>) representation. The construction is similar to a conventional cross-coupled flip-flop; each output, when high, inhibits all the other outputs.<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> Alternatively, more or less conventional flip-flops can be used, one per output, with additional circuitry to make sure only one at a time can be true.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a></p>

<p>Another generalization of the conventional flip-flop is a memory element for <a href="multi-valued_logic" title="wikilink">multi-valued logic</a>. In this case the memory element retains exactly one of the logic states until the control inputs induce a change.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> In addition, a multiple-valued clock can also be used, leading to new possible clock transitions.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a class="uri" href="Multivibrator" title="wikilink">Multivibrator</a></li>
<li><a href="Positive_feedback" title="wikilink">Positive feedback</a></li>
<li><a class="uri" href="Deadlock" title="wikilink">Deadlock</a></li>
<li><a href="Pulse_transition_detector" title="wikilink">Pulse transition detector</a></li>
<li><a href="Latching_relay" title="wikilink">Latching relay</a></li>
<li><a href="Counter_(digital)" title="wikilink">Counter</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://teahlab.com/Multivibrators_FlipFlop/">FlipFlop Hierarchy</a>, shows interactive flipflop circuits.</li>
<li><a href="http://www.allaboutcircuits.com/vol_4/chpt_10/6.html">The J-K Flip-Flop</a></li>
</ul>

<p>"</p>

<p><a href="Category:Digital_electronics" title="wikilink">Category:Digital electronics</a> <a href="Category:Electronic_engineering" title="wikilink">Category:Electronic engineering</a> <a href="Category:Digital_systems" title="wikilink">Circuit</a> <a href="Category:Logic_gates" title="wikilink">Category:Logic gates</a> <a href="Category:Computer_memory" title="wikilink">Category:Computer memory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"></li>
<li id="fn2"></li>
<li id="fn3">William Henry Eccles and Frank Wilfred Jordan, "[<a class="uri" href="http://v3.espacenet.com/origdoc?DB=EPODOC&amp;IDX">http://v3.espacenet.com/origdoc?DB=EPODOC&amp;IDX;</a>;=GB148582&amp;F;=0&amp;QPN;=GB148582 Improvements in ionic relays]" British patent number: GB 148582 (filed: 21 June 1918; published: 5 August 1920).<a href="#fnref3">↩</a></li>
<li id="fn4">W. H. Eccles and F. W. Jordan (19 September 1919) "A trigger relay utilizing three-electrode thermionic vacuum tubes," <em>The Electrician</em>, vol. 83, page 298. Reprinted in: <em>Radio Review</em>, vol. 1, no. 3, pages 143–146 (December 1919).<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9">P. L. Lindley, Aug. 1968, <a href="EDN_(magazine)" title="wikilink">EDN (magazine)</a>, (letter dated June 13, 1968).<a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11">; [<a class="uri" href="http://www.google.com/patents?id=JNUAAAAAEBAJ&amp;pg">http://www.google.com/patents?id=JNUAAAAAEBAJ&amp;pg;</a>;=PA15 page 15]<a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="http://rfic.eecs.berkeley.edu/ee100/pdf/lect24.pdf">Latches and Flip Flops</a> (EE 42/100 Lecture 24 from Berkeley) <em>"...Sometimes the terms flip-flop and latch are used interchangeably..."</em><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15">Roth, Charles H. Jr. "Latches and Flip-Flops." Fundamentals of Logic Design. Boston: PWS, 1995. Print.<a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"></li>
<li id="fn27"><a href="http://www.play-hookey.com/digital/d_nand_flip-flop.html">The D Flip-Flop</a><a href="#fnref27">↩</a></li>
<li id="fn28"><a href="http://www.ee.usyd.edu.au/tutorials/digital_tutorial/part2/flip-flop02.html">Edge-Triggered Flip-flops</a><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="http://focus.ti.com/lit/ds/symlink/sn7474.pdf">SN7474 TI datasheet</a><a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
<li id="fn31"></li>
<li id="fn32"><a class="uri" href="https://solvnet.synopsys.com/retrieve/customer/application_notes/attached_files/026030/App_Note_generic_constraint.pdf">https://solvnet.synopsys.com/retrieve/customer/application_notes/attached_files/026030/App_Note_generic_constraint.pdf</a><a href="#fnref32">↩</a></li>
<li id="fn33"><a href="#fnref33">↩</a></li>
<li id="fn34">Often attributed to <a href="Don_Knuth" title="wikilink">Don Knuth</a> (1969) (see ), the term <em>flip-flap-flop</em> actually appeared much earlier in the computing literature, for example, , and in <a href="#fnref34">↩</a></li>
<li id="fn35"><a href="#fnref35">↩</a></li>
<li id="fn36"><a href="#fnref36">↩</a></li>
<li id="fn37"><a href="#fnref37">↩</a></li>
<li id="fn38"><a href="#fnref38">↩</a></li>
</ol>
</section>
</body>
</html>
