<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1142">Sample complexity</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Sample complexity</h1>
<hr/>

<p>In <a href="machine_learning" title="wikilink">machine learning</a>, <strong>sample complexity</strong> is the number of examples needed for the estimate of a target function to be within a given error rate.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> The <strong>sample complexity</strong> of a machine learning algorithm characterizes its rate of <a href="consistency_(statistics)" title="wikilink">consistency</a>.</p>
<h2 id="mathematical-setup">Mathematical Setup</h2>

<p>Given a set of samples 

<math display="inline" id="Sample_complexity:0">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mi>n</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">‚Ä¶</mi>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi>n</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mi>n</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>n</ci>
    </apply>
    <set>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
     </interval>
     <ci>normal-‚Ä¶</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>n</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>n</ci>
      </apply>
     </interval>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{n}=\{(x_{1},y_{1}),\ldots,(x_{n},y_{n})\}
  </annotation>
 </semantics>
</math>

 drawn i.i.d. according to a distribution 

<math display="inline" id="Sample_complexity:1">
 <semantics>
  <mi>œÅ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>œÅ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

 from some input space 

<math display="inline" id="Sample_complexity:2">
 <semantics>
  <mrow>
   <mi class="ltx_font_mathcaligraphic">ùí≥</mi>
   <mo>√ó</mo>
   <mi class="ltx_font_mathcaligraphic">ùí¥</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ùí≥</ci>
    <ci>ùí¥</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{X}\times\mathcal{Y}
  </annotation>
 </semantics>
</math>

, a supervised learning algorithm chooses a function 

<math display="inline" id="Sample_complexity:3">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ùí≥</mi>
    <mo>‚Üí</mo>
    <mi class="ltx_font_mathcaligraphic">ùí¥</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-‚Üí</ci>
     <ci>ùí≥</ci>
     <ci>ùí¥</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f:\mathcal{X}\to\mathcal{Y}
  </annotation>
 </semantics>
</math>


 from some hypothesis class 

<math display="inline" id="Sample_complexity:4">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">‚Ñã</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>‚Ñã</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}
  </annotation>
 </semantics>
</math>

. A desirable property of the algorithm is that it chooses functions with small expected prediction error with respect to 

<math display="inline" id="Sample_complexity:5">
 <semantics>
  <mi>œÅ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>œÅ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

 and some loss function 

<math display="inline" id="Sample_complexity:6">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi class="ltx_font_mathcaligraphic">ùí¥</mi>
     <mo>√ó</mo>
     <mi class="ltx_font_mathcaligraphic">ùí¥</mi>
    </mrow>
    <mo>‚Üí</mo>
    <msub>
     <mi>‚Ñù</mi>
     <mo>+</mo>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>V</ci>
    <apply>
     <ci>normal-‚Üí</ci>
     <apply>
      <times></times>
      <ci>ùí¥</ci>
      <ci>ùí¥</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>‚Ñù</ci>
      <plus></plus>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V:\mathcal{Y}\times\mathcal{Y}\to\mathbb{R}_{+}
  </annotation>
 </semantics>
</math>

. Specifically, it is desirable to have a consistent algorithm, or an algorithm that generates functions whose expected risks converge to the best possible expected risk. Formally, let</p>

<p>

<math display="inline" id="Sample_complexity:7">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi class="ltx_font_mathcaligraphic">‚Ñõ</mi>
     <mi class="ltx_font_mathcaligraphic">‚Ñã</mi>
     <mo>*</mo>
    </msubsup>
    <mo>=</mo>
    <mrow>
     <munder accentunder="true">
      <mo>inf</mo>
      <mrow>
       <mi>f</mi>
       <mo>‚àà</mo>
       <mi class="ltx_font_mathcaligraphic">‚Ñã</mi>
      </mrow>
     </munder>
     <msub>
      <mi>ùîº</mi>
      <mi>œÅ</mi>
     </msub>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>V</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>,</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>‚Ñõ</ci>
      <times></times>
     </apply>
     <ci>‚Ñã</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <apply>
       <in></in>
       <ci>f</ci>
       <ci>‚Ñã</ci>
      </apply>
      <csymbol cd="latexml">infimum</csymbol>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùîº</ci>
      <ci>œÅ</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <times></times>
       <ci>V</ci>
       <interval closure="open">
        <apply>
         <times></times>
         <ci>f</ci>
         <ci>x</ci>
        </apply>
        <ci>y</ci>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{R}^{*}_{\mathcal{H}}=\underset{f\in\mathcal{H}}{\inf}\mathbb{E}_{\rho%
}[V(f(x),y)],
  </annotation>
 </semantics>
</math>

</p>

<p>and let 

<math display="inline" id="Sample_complexity:8">
 <semantics>
  <msub>
   <mi>f</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>f</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f_{n}
  </annotation>
 </semantics>
</math>


 be the functions generated by an algorithm as the number of data points 

<math display="inline" id="Sample_complexity:9">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 grows. The algorithm is consistent if</p>

<p>

<math display="inline" id="Sample_complexity:10">
 <semantics>
  <mrow>
   <munder accentunder="true">
    <mo>lim</mo>
    <mrow>
     <mi>n</mi>
     <mo>‚Üí</mo>
     <mi mathvariant="normal">‚àû</mi>
    </mrow>
   </munder>
   <msub>
    <mi>‚Ñô</mi>
    <msub>
     <mi>S</mi>
     <mi>n</mi>
    </msub>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ùîº</mi>
     <mi>œÅ</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>-</mo>
    <msubsup>
     <mi class="ltx_font_mathcaligraphic">‚Ñõ</mi>
     <mi class="ltx_font_mathcaligraphic">‚Ñã</mi>
     <mo>*</mo>
    </msubsup>
    <mo>></mo>
    <mi>œµ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <apply>
      <ci>normal-‚Üí</ci>
      <ci>n</ci>
      <infinity></infinity>
     </apply>
     <limit></limit>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>‚Ñô</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùîº</ci>
      <ci>œÅ</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">V</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">f</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-,</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-]</ci>
     </cerror>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>‚Ñõ</ci>
       <times></times>
      </apply>
      <ci>‚Ñã</ci>
     </apply>
     <gt></gt>
     <csymbol cd="unknown">œµ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \underset{n\to\infty}{\lim}\mathbb{P}_{S_{n}}(\mathbb{E}_{\rho}[V(f(x),y)]-%
\mathcal{R}^{*}_{\mathcal{H}}>\epsilon),
  </annotation>
 </semantics>
</math>

</p>

<p>for all 

<math display="inline" id="Sample_complexity:11">
 <semantics>
  <mrow>
   <mi>œµ</mi>
   <mo>></mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>œµ</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon>0
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Sample_complexity:12">
 <semantics>
  <msub>
   <mi>‚Ñô</mi>
   <msub>
    <mi>S</mi>
    <mi>n</mi>
   </msub>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>‚Ñô</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{P}_{S_{n}}
  </annotation>
 </semantics>
</math>

 denotes the probability measure 

<math display="inline" id="Sample_complexity:13">
 <semantics>
  <msup>
   <mi>œÅ</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>œÅ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho^{n}
  </annotation>
 </semantics>
</math>


.</p>

<p>The consistency property is nice, but it says nothing about how fast the expected risks converge. Since in practice one always deals with finite data, it is important to answer the question of how many samples are needed to achieve a risk that is close, in the 

<math display="inline" id="Sample_complexity:14">
 <semantics>
  <mi>œµ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>œµ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 sense, to the best possible for the function class. The notion of sample complexity answers this question. The sample complexity of a learning algorithm is a function 

<math display="inline" id="Sample_complexity:15">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>œÅ</mi>
    <mo>,</mo>
    <mi>œµ</mi>
    <mo>,</mo>
    <mi>Œ¥</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <vector>
     <ci>œÅ</ci>
     <ci>œµ</ci>
     <ci>Œ¥</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n(\rho,\epsilon,\delta)
  </annotation>
 </semantics>
</math>

 such that for all 

<math display="inline" id="Sample_complexity:16">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>‚â•</mo>
   <mrow>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>œÅ</mi>
     <mo>,</mo>
     <mi>œµ</mi>
     <mo>,</mo>
     <mi>Œ¥</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>n</ci>
    <apply>
     <times></times>
     <ci>n</ci>
     <vector>
      <ci>œÅ</ci>
      <ci>œµ</ci>
      <ci>Œ¥</ci>
     </vector>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\geq n(\rho,\epsilon,\delta)
  </annotation>
 </semantics>
</math>

,</p>

<p>

<math display="inline" id="Sample_complexity:17">
 <semantics>
  <mrow>
   <msub>
    <mi>‚Ñô</mi>
    <msub>
     <mi>S</mi>
     <mi>n</mi>
    </msub>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ùîº</mi>
     <mi>œÅ</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>-</mo>
    <msubsup>
     <mi class="ltx_font_mathcaligraphic">‚Ñõ</mi>
     <mi class="ltx_font_mathcaligraphic">‚Ñã</mi>
     <mo>*</mo>
    </msubsup>
    <mo>‚â§</mo>
    <mi>œµ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>‚â•</mo>
   <mn>1</mn>
   <mo>-</mo>
   <mi>Œ¥</mi>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>‚Ñô</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùîº</ci>
      <ci>œÅ</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">V</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">f</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-,</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-]</ci>
     </cerror>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>‚Ñõ</ci>
       <times></times>
      </apply>
      <ci>‚Ñã</ci>
     </apply>
     <leq></leq>
     <csymbol cd="unknown">œµ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <geq></geq>
    <cn type="integer">1</cn>
    <minus></minus>
    <csymbol cd="unknown">Œ¥</csymbol>
    <ci>normal-.</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbb{P}_{S_{n}}(\mathbb{E}_{\rho}[V(f(x),y)]-\mathcal{R}^{*}_{\mathcal{H}}%
\leq\epsilon)\geq 1-\delta.
  </annotation>
 </semantics>
</math>

</p>

<p>In words, the sample complexity 

<math display="inline" id="Sample_complexity:18">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>œÅ</mi>
    <mo>,</mo>
    <mi>œµ</mi>
    <mo>,</mo>
    <mi>Œ¥</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <vector>
     <ci>œÅ</ci>
     <ci>œµ</ci>
     <ci>Œ¥</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n(\rho,\epsilon,\delta)
  </annotation>
 </semantics>
</math>


 defines the rate of consistency of the algorithm. Given a desired accuracy 

<math display="inline" id="Sample_complexity:19">
 <semantics>
  <mi>œµ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>œµ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 and confidence 

<math display="inline" id="Sample_complexity:20">
 <semantics>
  <mi>Œ¥</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Œ¥</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

, one needs at most 

<math display="inline" id="Sample_complexity:21">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>œÅ</mi>
    <mo>,</mo>
    <mi>œµ</mi>
    <mo>,</mo>
    <mi>Œ¥</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <vector>
     <ci>œÅ</ci>
     <ci>œµ</ci>
     <ci>Œ¥</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n(\rho,\epsilon,\delta)
  </annotation>
 </semantics>
</math>

 samples to guarantee that the expected risk of the output function is within 

<math display="inline" id="Sample_complexity:22">
 <semantics>
  <mi>œµ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>œµ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \epsilon
  </annotation>
 </semantics>
</math>

 of the best possible expected risk with probability at least 

<math display="inline" id="Sample_complexity:23">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>-</mo>
   <mi>Œ¥</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <cn type="integer">1</cn>
    <ci>Œ¥</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1-\delta
  </annotation>
 </semantics>
</math>


.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="no-free-lunch-theorem-machine-learning">No Free Lunch Theorem (Machine Learning)</h2>

<p>Optimistically one could hope for a stronger notion of sample complexity that is independent of the distribution 

<math display="inline" id="Sample_complexity:24">
 <semantics>
  <mi>œÅ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>œÅ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

 on the input and output spaces. However, it has been shown that without restrictions on the hypothesis class 

<math display="inline" id="Sample_complexity:25">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">‚Ñã</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>‚Ñã</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}
  </annotation>
 </semantics>
</math>

, there always exists "bad" distributions for which the sample complexity is arbitrarily large.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Thus in order to make statements about the rate of convergence of the quantity</p>

<p>

<math display="inline" id="Sample_complexity:26">
 <semantics>
  <mrow>
   <mpadded width="+5pt">
    <munder accentunder="true">
     <mo>sup</mo>
     <mo>ùúå</mo>
    </munder>
   </mpadded>
   <msub>
    <mi>‚Ñô</mi>
    <msub>
     <mi>S</mi>
     <mi>n</mi>
    </msub>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ùîº</mi>
     <mi>œÅ</mi>
    </msub>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>V</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mo>-</mo>
    <msubsup>
     <mi class="ltx_font_mathcaligraphic">‚Ñõ</mi>
     <mi class="ltx_font_mathcaligraphic">‚Ñã</mi>
     <mo>*</mo>
    </msubsup>
    <mo>></mo>
    <mi>œµ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <ci>œÅ</ci>
     <csymbol cd="latexml">supremum</csymbol>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>‚Ñô</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <ci>n</ci>
     </apply>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ùîº</ci>
      <ci>œÅ</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">V</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">f</csymbol>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <ci>normal-(</ci>
        <csymbol cd="unknown">x</csymbol>
        <ci>normal-)</ci>
       </cerror>
       <ci>normal-,</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-]</ci>
     </cerror>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>‚Ñõ</ci>
       <times></times>
      </apply>
      <ci>‚Ñã</ci>
     </apply>
     <gt></gt>
     <csymbol cd="unknown">œµ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-,</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \underset{\rho}{\sup}\ \mathbb{P}_{S_{n}}(\mathbb{E}_{\rho}[V(f(x),y)]-%
\mathcal{R}^{*}_{\mathcal{H}}>\epsilon),
  </annotation>
 </semantics>
</math>

</p>

<p>one must either</p>
<ul>
<li>Constrain the set of probability distributions 

<math display="inline" id="Sample_complexity:27">
 <semantics>
  <mi>œÅ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>œÅ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rho
  </annotation>
 </semantics>
</math>

, e.g. via a parametric approach, or</li>
<li>Constrain the set 

<math display="inline" id="Sample_complexity:28">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">‚Ñã</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>‚Ñã</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}
  </annotation>
 </semantics>
</math>


 to be small, as in distribution free approaches.</li>
</ul>

<p>The latter approach leads to concepts such as <a href="VC_dimension" title="wikilink">VC dimension</a> and <a href="Rademacher_complexity" title="wikilink">Rademacher complexity</a> which control the complexity of the space 

<math display="inline" id="Sample_complexity:29">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">‚Ñã</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>‚Ñã</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{H}
  </annotation>
 </semantics>
</math>

. A smaller hypothesis space introduces more bias into the inference process, meaning that 

<math display="inline" id="Sample_complexity:30">
 <semantics>
  <msubsup>
   <mi class="ltx_font_mathcaligraphic">‚Ñõ</mi>
   <mi class="ltx_font_mathcaligraphic">‚Ñã</mi>
   <mo>*</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>‚Ñõ</ci>
     <times></times>
    </apply>
    <ci>‚Ñã</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{R}^{*}_{\mathcal{H}}
  </annotation>
 </semantics>
</math>

 may be larger than the best possible expected risk in a larger space. However, by restricting the complexity of the hypothesis space it becomes possible for an algorithm to produce functions converging in expected risk to 

<math display="inline" id="Sample_complexity:31">
 <semantics>
  <msubsup>
   <mi class="ltx_font_mathcaligraphic">‚Ñõ</mi>
   <mi class="ltx_font_mathcaligraphic">‚Ñã</mi>
   <mo>*</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>‚Ñõ</ci>
     <times></times>
    </apply>
    <ci>‚Ñã</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{R}^{*}_{\mathcal{H}}
  </annotation>
 </semantics>
</math>

. This trade-off leads to the concept of <a href="regularization_(mathematics)" title="wikilink">regularization</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="other-settings">Other Settings</h2>

<p>In addition to the supervised learning setting, sample complexity is relevant to <a href="semi-supervised_learning" title="wikilink">semi-supervised learning</a> problems including <a href="active_learning" title="wikilink">active learning</a>,<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> where the algorithm can ask for labels to specifically chosen inputs in order to reduce the cost of obtaining many labels. The concept of sample complexity also shows up in <a href="reinforcement_learning" title="wikilink">reinforcement learning</a>,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> <a href="online_machine_learning" title="wikilink">online learning</a>, and unsupervised algorithms, e.g. for <a href="dictionary_learning" title="wikilink">dictionary learning</a>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Machine_learning" title="wikilink">Category:Machine learning</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">‚Ü©</a></li>
<li id="fn2"><a href="#fnref2">‚Ü©</a></li>
<li id="fn3"><a href="#fnref3">‚Ü©</a></li>
<li id="fn4"></li>
<li id="fn5"></li>
<li id="fn6"><a href="#fnref6">‚Ü©</a></li>
<li id="fn7"><a href="#fnref7">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
