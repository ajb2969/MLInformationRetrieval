<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="156">Lambda-mu calculus</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Lambda-mu calculus</h1>
<hr/>

<p>In <a href="mathematical_logic" title="wikilink">mathematical logic</a> and <a href="computer_science" title="wikilink">computer science</a>, the <strong>lambda-mu calculus</strong> is an extension of the <a href="lambda_calculus" title="wikilink">lambda calculus</a>, and was introduced by M. Parigot.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> It introduces two new operators: the mu operator (which is completely different both from the <a href="mu_operator" title="wikilink">mu operator</a> found in <a href="computability_theory" title="wikilink">computability theory</a> and from the μ operator of <a href="modal_mu_calculus" title="wikilink">modal μ-calculus</a>) and the bracket operator. <a href="Proof_theory" title="wikilink">Proof-theoretically</a>, it provides a well-behaved formulation of <a href="Natural_deduction#Classical_and_modal_logics" title="wikilink">classical natural deduction</a>.</p>

<p>One of the main goals of this extended calculus is to be able to describe expressions corresponding to theorems in <a href="classical_logic" title="wikilink">classical logic</a>. According to the <a href="Curry–Howard_isomorphism" title="wikilink">Curry–Howard isomorphism</a>, lambda calculus on its own can express theorems in <a href="intuitionistic_logic" title="wikilink">intuitionistic logic</a> only, and several classical logical theorems can't be written at all. However with these new operators one is able to write terms that have the type of, for example, <a href="Peirce's_law" title="wikilink">Peirce's law</a>.</p>

<p>Semantically these operators correspond to <a class="uri" href="continuations" title="wikilink">continuations</a>, found in some <a href="functional_programming_languages" title="wikilink">functional programming languages</a>.</p>
<h2 id="formal-definition">Formal definition</h2>

<p>We can augment the definition of a lambda expression to gain one in the context of lambda-mu calculus. The three main expressions found in lambda calculus are as follows:</p>
<ol>
<li><code>V</code>, a <em>variable</em>, where <code>V</code> is any <a class="uri" href="identifier" title="wikilink">identifier</a>.</li>
<li><code>λV.E</code>, an <em>abstraction</em>, where <em>V</em> is any identifier and <em>E</em> is any lambda expression.</li>
<li><code>(E E′)</code>, an <em>application</em>, where <code>E</code> and <code>E′</code> are any lambda expressions.</li>
</ol>

<p>For details, see the <a href="lambda_calculus#Formal_definition" title="wikilink">corresponding article</a>.</p>

<p>In addition to the traditional λ-variables, the lambda-mu calculus includes a distinct set of μ-variables. These μ-variables can be used to <em>name</em> or <em>freeze</em> arbitrary subterms, allowing us to later abstract on those names. The set of terms contains <em>unnamed</em> (all traditional lambda expressions are of this kind) and <em>named</em> terms. The terms that are added by the lambda-mu calculus are of the form:</p>
<ol>
<li><code>[α]t</code> is a named term, where <code>α</code> is a μ-variable and <code>t</code> is an unnamed term.</li>
<li><code>(μ α. E)</code> is an unnamed term, where <code>α</code> is a μ-variable and <code>E</code> is a named term.</li>
</ol>
<h2 id="reduction">Reduction</h2>

<p>The basic reduction rules used in the lambda-mu calculus are the following:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>logical reduction</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda-mu_calculus:0">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>λ</mi>
    <mi>x</mi>
    <mo>.</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mpadded width="+2.8pt">
    <mi>v</mi>
   </mpadded>
   <mpadded width="+2.8pt">
    <msub>
     <mo>▷</mo>
     <mi>c</mi>
    </msub>
   </mpadded>
   <mi>u</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>v</mi>
    <mo>/</mo>
    <mi>x</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">λ</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">v</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-▷</ci>
     <ci>c</ci>
    </apply>
    <csymbol cd="unknown">u</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">v</csymbol>
     <divide></divide>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\lambda x.u)v\;\triangleright_{c}\;u[v/x]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>structural reduction</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda-mu_calculus:1">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>μ</mi>
    <mi>β</mi>
    <mo>.</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mpadded width="+2.8pt">
    <mi>v</mi>
   </mpadded>
   <mpadded width="+2.8pt">
    <msub>
     <mo>▷</mo>
     <mi>c</mi>
    </msub>
   </mpadded>
   <mi>μ</mi>
   <mi>β</mi>
   <mo>.</mo>
   <mi>u</mi>
   <mrow>
    <mo>[</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>β</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>w</mi>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>β</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>w</mi>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">μ</csymbol>
     <csymbol cd="unknown">β</csymbol>
     <ci>normal-.</ci>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">v</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-▷</ci>
     <ci>c</ci>
    </apply>
    <csymbol cd="unknown">μ</csymbol>
    <csymbol cd="unknown">β</csymbol>
    <ci>normal-.</ci>
    <csymbol cd="unknown">u</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">β</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">w</csymbol>
      <csymbol cd="unknown">v</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <divide></divide>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">β</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <csymbol cd="unknown">w</csymbol>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mu\beta.u)v\;\triangleright_{c}\;\mu\beta.u\left[[\beta](wv)/[\beta]w\right]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>renaming</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda-mu_calculus:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>α</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>μ</mi>
    <mi>β</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mpadded width="+2.8pt">
     <mi>u</mi>
    </mpadded>
    <mpadded width="+2.8pt">
     <msub>
      <mo>▷</mo>
      <mi>c</mi>
     </msub>
    </mpadded>
    <mrow>
     <mi>u</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>α</mi>
       <mo>/</mo>
       <mi>β</mi>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>α</ci>
     </apply>
     <ci>μ</ci>
     <ci>β</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-▷</ci>
      <ci>c</ci>
     </apply>
     <ci>u</ci>
     <apply>
      <times></times>
      <ci>u</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <divide></divide>
        <ci>α</ci>
        <ci>β</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [\alpha]\mu\beta.u\;\triangleright_{c}\;u[\alpha/\beta]
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>the equivalent of η-reduction</p></td>
<td style="text-align: left;">
<p>

<math display="inline" id="Lambda-mu_calculus:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>μ</mi>
    <mi>α</mi>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>α</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mpadded width="+2.8pt">
      <mi>u</mi>
     </mpadded>
    </mrow>
    <mpadded width="+2.8pt">
     <msub>
      <mo>▷</mo>
      <mi>c</mi>
     </msub>
    </mpadded>
    <mi>u</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>μ</ci>
     <ci>α</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-▷</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>α</ci>
      </apply>
      <ci>u</ci>
     </apply>
     <ci>u</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu\alpha.[\alpha]u\;\triangleright_{c}\;u
  </annotation>
 </semantics>
</math>

, for α not freely occurring in u</p></td>
</tr>
</tbody>
</table>

<p>These rules cause the calculus to be <a href="Confluence_(term_rewriting)" title="wikilink">confluent</a>. Further reduction rules could be added to provide us with a stronger notion of normal form, though this would be at the expense of confluence.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Lambda_Calculus" title="wikilink">Lambda Calculus</a></li>
<li>Classical <a href="pure_type_systems" title="wikilink">pure type systems</a> for typed generalizations of lambda calculi with control</li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://lambda-the-ultimate.org/node/811">Lambda-mu</a> relevant discussion on Lambda the Ultimate.</li>
</ul>

<p>"</p>

<p><a href="Category:Lambda_calculus" title="wikilink">Category:Lambda calculus</a> <a href="Category:Proof_theory" title="wikilink">Category:Proof theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Michel Parigot. <a href="http://www.springerlink.com/content/5x552812m8150709/"><em>λμ-Calculus: An algorithmic interpretation of classical natural deduction.</em></a> <em>Lecture Notes in Computer Science</em>, Volume <strong>624</strong>, pages 190-201, 1992.<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
