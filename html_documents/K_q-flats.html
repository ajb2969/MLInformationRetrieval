<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1690">K q-flats</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>K q-flats</h1>
<hr/>

<p>In <a href="data_mining" title="wikilink">data mining</a> and <a href="machine_learning" title="wikilink">machine learning</a>, 

<math display="inline" id="K_q-flats:0">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="K_q-flats:1">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

-flats algorithm <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> is an iterative method which aims to partition 

<math display="inline" id="K_q-flats:2">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 observations into 

<math display="inline" id="K_q-flats:3">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 clusters where each cluster is close to a <a href="flat_(geometry)" title="wikilink">

<math display="inline" id="K_q-flats:4">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

-flat</a>, where 

<math display="inline" id="K_q-flats:5">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

 is a given integer.</p>

<p>It is a generalization of the <a href="k-means_clustering" title="wikilink">

<math display="inline" id="K_q-flats:6">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-means algorithm</a>. In 

<math display="inline" id="K_q-flats:7">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-means algorithm, clusters are formed in the way that each cluster is close to one point, which is a 

<math display="inline" id="K_q-flats:8">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

-flat. 

<math display="inline" id="K_q-flats:9">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="K_q-flats:10">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

-flats algorithm gives better clustering result than 

<math display="inline" id="K_q-flats:11">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-means algorithm for some data set.</p>
<h2 id="description">Description</h2>
<h3 id="problem-formulation">Problem formulation</h3>

<p>Given a set 

<math display="inline" id="K_q-flats:12">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="K_q-flats:13">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 observations 

<math display="inline" id="K_q-flats:14">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>a</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>a</mi>
    <mi>m</mi>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <vector>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>m</ci>
    </apply>
   </vector>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a_{1},a_{2},\dots,a_{m})
  </annotation>
 </semantics>
</math>

 where each observation 

<math display="inline" id="K_q-flats:15">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}
  </annotation>
 </semantics>
</math>

 is an n-dimensional real vector, 

<math display="inline" id="K_q-flats:16">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="K_q-flats:17">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

-flats algorithm aims to partition 

<math display="inline" id="K_q-flats:18">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 observation points by generating 

<math display="inline" id="K_q-flats:19">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="K_q-flats:20">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

-flats that minimize the sum of the squares of distances of each observation to a nearest q-flat.</p>

<p>A 

<math display="inline" id="K_q-flats:21">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

-flat is a subset of 

<math display="inline" id="K_q-flats:22">
 <semantics>
  <msup>
   <mi>R</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>R</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{n}
  </annotation>
 </semantics>
</math>

 that is congruent to 

<math display="inline" id="K_q-flats:23">
 <semantics>
  <msup>
   <mi>R</mi>
   <mi>q</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>R</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R^{q}
  </annotation>
 </semantics>
</math>

. For example, a 

<math display="inline" id="K_q-flats:24">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
 </semantics>
</math>

-flat is a point; a 

<math display="inline" id="K_q-flats:25">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

-flat is a plane; a 

<math display="inline" id="K_q-flats:26">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-1
  </annotation>
 </semantics>
</math>

-flat is a <a class="uri" href="hyperplane" title="wikilink">hyperplane</a>. 

<math display="inline" id="K_q-flats:27">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

-flat can be characterized by the solution set of a linear system of equations

<math display="block" id="K_q-flats:28">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <mi>x</mi>
      <mo>∈</mo>
      <msup>
       <mi>R</mi>
       <mi>n</mi>
      </msup>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mrow>
       <msup>
        <mi>W</mi>
        <mo>′</mo>
       </msup>
       <mi>x</mi>
      </mrow>
      <mo>=</mo>
      <mi>γ</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>F</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <in></in>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>R</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>W</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>x</ci>
       </apply>
       <ci>γ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F=\{x|x\in R^{n},W^{\prime}x=\gamma\}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="K_q-flats:29">
 <semantics>
  <mrow>
   <mi>W</mi>
   <mo>∈</mo>
   <msup>
    <mi>R</mi>
    <mrow>
     <mi>n</mi>
     <mo>×</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mi>q</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>W</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <apply>
      <times></times>
      <ci>n</ci>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W\in R^{n\times(n-q)}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="K_q-flats:30">
 <semantics>
  <mrow>
   <mi>γ</mi>
   <mo>∈</mo>
   <msup>
    <mi>R</mi>
    <mrow>
     <mn>1</mn>
     <mo>×</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mi>q</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>γ</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <apply>
      <times></times>
      <cn type="integer">1</cn>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <ci>q</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma\in R^{1\times(n-q)}
  </annotation>
 </semantics>
</math>

.</p>

<p>Denote a <a href="partition_of_a_set" title="wikilink">partition</a> of 

<math display="inline" id="K_q-flats:31">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mi>n</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
    <ci>normal-…</ci>
    <ci>n</ci>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{1,2,\dots,n\}
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="K_q-flats:32">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>S</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>S</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <ci>k</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S=(S_{1},S_{2},\dots,S_{k})
  </annotation>
 </semantics>
</math>

. The problem can be formulated as</p>

<p>

<math display="inline" id="K_q-flats:33">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>P</mi>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <msub>
      <mi>min</mi>
      <mrow>
       <mrow>
        <mrow>
         <msub>
          <mi>F</mi>
          <mi>l</mi>
         </msub>
         <mo>,</mo>
         <mi>l</mi>
        </mrow>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mi mathvariant="normal">…</mi>
        <mo>,</mo>
        <mrow>
         <mi>k</mi>
         <mtext>are q-flats</mtext>
        </mrow>
       </mrow>
      </mrow>
     </msub>
     <msub>
      <mi>min</mi>
      <mi>S</mi>
     </msub>
    </mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>l</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>k</mi>
     </msubsup>
     <mrow>
      <msub>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <msub>
         <mi>a</mi>
         <mi>j</mi>
        </msub>
        <mo>∈</mo>
        <msub>
         <mi>S</mi>
         <mi>i</mi>
        </msub>
       </mrow>
      </msub>
      <msup>
       <mrow>
        <mo>∥</mo>
        <mrow>
         <msub>
          <mi>a</mi>
          <mi>j</mi>
         </msub>
         <mo>-</mo>
         <mrow>
          <msub>
           <mi>P</mi>
           <msub>
            <mi>F</mi>
            <mi>i</mi>
           </msub>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <msub>
            <mi>a</mi>
            <mi>j</mi>
           </msub>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>∥</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <times></times>
     <ci>P</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <eq></eq>
        <list>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>F</ci>
          <ci>l</ci>
         </apply>
         <ci>l</ci>
        </list>
        <cn type="integer">1</cn>
       </apply>
       <list>
        <ci>normal-…</ci>
        <apply>
         <times></times>
         <ci>k</ci>
         <mtext>are q-flats</mtext>
        </apply>
       </list>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <min></min>
      <ci>S</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <ci>l</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>k</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <in></in>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>a</ci>
         <ci>j</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>S</ci>
         <ci>i</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>a</ci>
          <ci>j</ci>
         </apply>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>P</ci>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>F</ci>
            <ci>i</ci>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>a</ci>
           <ci>j</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (P1)\min_{F_{l},l=1,\dots,k\text{ are q-flats}}\min_{S}\sum_{l=1}^{k}\sum_{a_{%
j}\in S_{i}}\|a_{j}-P_{F_{i}}(a_{j})\|^{2},
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="K_q-flats:34">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <msub>
     <mi>F</mi>
     <mi>i</mi>
    </msub>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>a</mi>
     <mi>j</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>F</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>j</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{F_{i}}(a_{j})
  </annotation>
 </semantics>
</math>

 is the projection of 

<math display="inline" id="K_q-flats:35">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{j}
  </annotation>
 </semantics>
</math>

 onto 

<math display="inline" id="K_q-flats:36">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{i}
  </annotation>
 </semantics>
</math>

. Note that 

<math display="inline" id="K_q-flats:37">
 <semantics>
  <mrow>
   <mrow>
    <mo>∥</mo>
    <mrow>
     <msub>
      <mi>a</mi>
      <mi>j</mi>
     </msub>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>P</mi>
       <msub>
        <mi>F</mi>
        <mi>i</mi>
       </msub>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>a</mi>
        <mi>j</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>∥</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>d</mi>
    <mi>i</mi>
    <mi>s</mi>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>a</mi>
      <mi>j</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>F</mi>
      <mi>l</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>F</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>a</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>d</ci>
     <ci>i</ci>
     <ci>s</ci>
     <ci>t</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>a</ci>
       <ci>j</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>l</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|a_{j}-P_{F_{i}}(a_{j})\|=dist(a_{j},F_{l})
  </annotation>
 </semantics>
</math>

 is the distance from 

<math display="inline" id="K_q-flats:38">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{j}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="K_q-flats:39">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>l</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{l}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="algorithm">Algorithm</h3>

<p>The algorithm is similar to the k-means algorithm (i.e. Lloyd's algorithm) in that it alternates between cluster assignment and cluster update. In specific, the algorithm starts with an initial set of 

<math display="inline" id="K_q-flats:40">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

-flats 

<math display="inline" id="K_q-flats:41">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>F</mi>
     <mi>l</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>0</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>x</mi>
      <mo>∈</mo>
      <msup>
       <mi>R</mi>
       <mi>n</mi>
      </msup>
     </mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mrow>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <msubsup>
          <mi>W</mi>
          <mi>l</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mn>0</mn>
           <mo stretchy="false">)</mo>
          </mrow>
         </msubsup>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo>′</mo>
       </msup>
       <mi>x</mi>
      </mrow>
      <mo>=</mo>
      <msubsup>
       <mi>γ</mi>
       <mi>l</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>0</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </msubsup>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mi>l</mi>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mi>k</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>F</ci>
       <ci>l</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <in></in>
       <ci>x</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>R</ci>
        <ci>n</ci>
       </apply>
      </apply>
      <apply>
       <eq></eq>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>W</ci>
           <ci>l</ci>
          </apply>
          <cn type="integer">0</cn>
         </apply>
         <ci>normal-′</ci>
        </apply>
        <ci>x</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>γ</ci>
         <ci>l</ci>
        </apply>
        <cn type="integer">0</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>l</ci>
     <list>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <ci>k</ci>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{l}^{(0)}=\{x\in R^{n}|(W_{l}^{(0)})^{\prime}x=\gamma_{l}^{(0)}\},l=1,\dots,k
  </annotation>
 </semantics>
</math>

, and proceeds by alternating between the following two steps:</p>
<dl>
<dd><strong>Cluster Assignment</strong> (given 

<math display="inline" id="K_q-flats:42">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

-flats, assign each point to closest 

<math display="inline" id="K_q-flats:43">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

-flat): the i'th cluster is updated as 

<math display="inline" id="K_q-flats:44">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>S</mi>
     <mi>i</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </msubsup>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <msub>
      <mi>a</mi>
      <mi>j</mi>
     </msub>
     <mo stretchy="false">|</mo>
     <mrow>
      <msub>
       <mrow>
        <mo>∥</mo>
        <mrow>
         <mrow>
          <msup>
           <mrow>
            <mo stretchy="false">(</mo>
            <msubsup>
             <mi>W</mi>
             <mi>i</mi>
             <mrow>
              <mo stretchy="false">(</mo>
              <mi>t</mi>
              <mo stretchy="false">)</mo>
             </mrow>
            </msubsup>
            <mo stretchy="false">)</mo>
           </mrow>
           <mo>′</mo>
          </msup>
          <msub>
           <mi>a</mi>
           <mi>j</mi>
          </msub>
         </mrow>
         <mo>-</mo>
         <msubsup>
          <mi>γ</mi>
          <mi>i</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>t</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </msubsup>
        </mrow>
        <mo>∥</mo>
       </mrow>
       <mi>F</mi>
      </msub>
      <mo>=</mo>
      <mrow>
       <msub>
        <mi>min</mi>
        <mrow>
         <mi>l</mi>
         <mo>=</mo>
         <mrow>
          <mn>1</mn>
          <mo>,</mo>
          <mi mathvariant="normal">…</mi>
          <mo>,</mo>
          <mi>k</mi>
         </mrow>
        </mrow>
       </msub>
       <msub>
        <mrow>
         <mo>∥</mo>
         <mrow>
          <mrow>
           <msup>
            <mrow>
             <mo stretchy="false">(</mo>
             <msubsup>
              <mi>W</mi>
              <mi>l</mi>
              <mrow>
               <mo stretchy="false">(</mo>
               <mi>t</mi>
               <mo stretchy="false">)</mo>
              </mrow>
             </msubsup>
             <mo stretchy="false">)</mo>
            </mrow>
            <mo>′</mo>
           </msup>
           <msub>
            <mi>a</mi>
            <mi>j</mi>
           </msub>
          </mrow>
          <mo>-</mo>
          <msubsup>
           <mi>γ</mi>
           <mi>l</mi>
           <mrow>
            <mo stretchy="false">(</mo>
            <mi>t</mi>
            <mo stretchy="false">)</mo>
           </mrow>
          </msubsup>
         </mrow>
         <mo>∥</mo>
        </mrow>
        <mi>F</mi>
       </msub>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <ci>i</ci>
     </apply>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>j</ci>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>W</ci>
             <ci>i</ci>
            </apply>
            <ci>t</ci>
           </apply>
           <ci>normal-′</ci>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>a</ci>
           <ci>j</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>γ</ci>
           <ci>i</ci>
          </apply>
          <ci>t</ci>
         </apply>
        </apply>
       </apply>
       <ci>F</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <min></min>
        <apply>
         <eq></eq>
         <ci>l</ci>
         <list>
          <cn type="integer">1</cn>
          <ci>normal-…</ci>
          <ci>k</ci>
         </list>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>W</ci>
              <ci>l</ci>
             </apply>
             <ci>t</ci>
            </apply>
            <ci>normal-′</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>a</ci>
            <ci>j</ci>
           </apply>
          </apply>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>γ</ci>
            <ci>l</ci>
           </apply>
           <ci>t</ci>
          </apply>
         </apply>
        </apply>
        <ci>F</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{i}^{(t)}=\{a_{j}|\|(W_{i}^{(t)})^{\prime}a_{j}-\gamma_{i}^{(t)}\|_{F}=\min_%
{l=1,\dots,k}\|(W_{l}^{(t)})^{\prime}a_{j}-\gamma_{l}^{(t)}\|_{F}\}.
  </annotation>
 </semantics>
</math>


</dd>
</dl>
<dl>
<dd><em>' Cluster Update</em>' (given cluster assignment, update the 

<math display="inline" id="K_q-flats:45">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

-flats): For 

<math display="inline" id="K_q-flats:46">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mo>=</mo>
   <mrow>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>k</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>l</ci>
    <list>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>k</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l=1,\dots,k
  </annotation>
 </semantics>
</math>

, let 

<math display="inline" id="K_q-flats:47">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∈</mo>
   <msup>
    <mi>R</mi>
    <mrow>
     <mrow>
      <mi>m</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>l</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>×</mo>
     <mi>n</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>l</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <apply>
      <times></times>
      <apply>
       <times></times>
       <ci>m</ci>
       <ci>l</ci>
      </apply>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(l)\in R^{m(l)\times n}
  </annotation>
 </semantics>
</math>

 with rows corresponding to all 

<math display="inline" id="K_q-flats:48">
 <semantics>
  <msub>
   <mi>a</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>a</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a_{i}
  </annotation>
 </semantics>
</math>

 assigned to cluster 

<math display="inline" id="K_q-flats:49">
 <semantics>
  <mi>l</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>l</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l
  </annotation>
 </semantics>
</math>

. Set 

<math display="inline" id="K_q-flats:50">
 <semantics>
  <msubsup>
   <mi>W</mi>
   <mi>l</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>t</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>W</ci>
     <ci>l</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>t</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W_{l}^{(t+1)}
  </annotation>
 </semantics>
</math>

 to be the matrix whose columns are the orthonormal eigenvectors corresponding to the 

<math display="inline" id="K_q-flats:51">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mi>n</mi>
    <mo>-</mo>
    <mi>q</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n-q)
  </annotation>
 </semantics>
</math>

 least eigenvalues of 

<math display="inline" id="K_q-flats:52">
 <semantics>
  <mrow>
   <mi>A</mi>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>′</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>I</mi>
     <mo>-</mo>
     <mfrac>
      <mrow>
       <mi>e</mi>
       <msup>
        <mi>e</mi>
        <mo>′</mo>
       </msup>
      </mrow>
      <mi>m</mi>
     </mfrac>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>A</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>l</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>l</ci>
     <ci>normal-′</ci>
    </apply>
    <apply>
     <minus></minus>
     <ci>I</ci>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>e</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>e</ci>
        <ci>normal-′</ci>
       </apply>
      </apply>
      <ci>m</ci>
     </apply>
    </apply>
    <ci>A</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(l)^{\prime}(I-\frac{ee^{\prime}}{m})A(l)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="K_q-flats:53">
 <semantics>
  <mrow>
   <msubsup>
    <mi>γ</mi>
    <mi>l</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>t</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </msubsup>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <msup>
      <mi>e</mi>
      <mo>′</mo>
     </msup>
     <mi>A</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <msubsup>
      <mi>W</mi>
      <mi>l</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>t</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </msubsup>
    </mrow>
    <mi>m</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>γ</ci>
      <ci>l</ci>
     </apply>
     <apply>
      <plus></plus>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>A</ci>
      <ci>l</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>W</ci>
        <ci>l</ci>
       </apply>
       <apply>
        <plus></plus>
        <ci>t</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma_{l}^{(t+1)}=\frac{e^{\prime}A(l)W_{l}^{(t+1)}}{m}
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>

<p>Stop whenever the assignments no longer change.</p>

<p>The cluster assignment step uses the following fact: given a q-flat 

<math display="inline" id="K_q-flats:54">
 <semantics>
  <mrow>
   <msub>
    <mi>F</mi>
    <mi>l</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>W</mi>
       <mo>′</mo>
      </msup>
      <mi>x</mi>
     </mrow>
     <mo>=</mo>
     <mi>γ</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>F</ci>
     <ci>l</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>x</ci>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>W</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>x</ci>
      </apply>
      <ci>γ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{l}=\{x|W^{\prime}x=\gamma\}
  </annotation>
 </semantics>
</math>

 and a vector 

<math display="inline" id="K_q-flats:55">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="K_q-flats:56">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>W</mi>
     <mo>′</mo>
    </msup>
    <mi>W</mi>
   </mrow>
   <mo>=</mo>
   <mi>I</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>W</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>W</ci>
    </apply>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{\prime}W=I
  </annotation>
 </semantics>
</math>

, the distance from 

<math display="inline" id="K_q-flats:57">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 to the q-flat 

<math display="inline" id="K_q-flats:58">
 <semantics>
  <msub>
   <mi>F</mi>
   <mi>l</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>F</ci>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F_{l}
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="K_q-flats:59">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mi>i</mi>
     <mi>s</mi>
     <mi>t</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <msub>
       <mi>F</mi>
       <mi>l</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>m</mi>
     <mi>i</mi>
     <msub>
      <mi>n</mi>
      <mrow>
       <mi>x</mi>
       <mo>:</mo>
       <mrow>
        <mrow>
         <msup>
          <mi>W</mi>
          <mo>′</mo>
         </msup>
         <mi>x</mi>
        </mrow>
        <mo>=</mo>
        <mi>γ</mi>
       </mrow>
      </mrow>
     </msub>
     <msubsup>
      <mrow>
       <mo>∥</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <mi>a</mi>
       </mrow>
       <mo>∥</mo>
      </mrow>
      <mi>F</mi>
      <mn>2</mn>
     </msubsup>
    </mrow>
    <mo>=</mo>
    <msubsup>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <mi>W</mi>
       <msup>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <msup>
           <mi>W</mi>
           <mo>′</mo>
          </msup>
          <mi>W</mi>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mrow>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mrow>
          <msup>
           <mi>W</mi>
           <mo>′</mo>
          </msup>
          <mi>x</mi>
         </mrow>
         <mo>-</mo>
         <mi>γ</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mi>F</mi>
     <mn>2</mn>
    </msubsup>
    <mo>=</mo>
    <msubsup>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <mrow>
        <msup>
         <mi>W</mi>
         <mo>′</mo>
        </msup>
        <mi>x</mi>
       </mrow>
       <mo>-</mo>
       <mi>γ</mi>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mi>F</mi>
     <mn>2</mn>
    </msubsup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>i</ci>
      <ci>s</ci>
      <ci>t</ci>
      <interval closure="open">
       <ci>a</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>F</ci>
        <ci>l</ci>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>i</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <apply>
        <ci>normal-:</ci>
        <ci>x</ci>
        <apply>
         <eq></eq>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>W</ci>
           <ci>normal-′</ci>
          </apply>
          <ci>x</ci>
         </apply>
         <ci>γ</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">norm</csymbol>
         <apply>
          <minus></minus>
          <ci>x</ci>
          <ci>a</ci>
         </apply>
        </apply>
        <ci>F</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <apply>
         <times></times>
         <ci>W</ci>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>W</ci>
            <ci>normal-′</ci>
           </apply>
           <ci>W</ci>
          </apply>
          <apply>
           <minus></minus>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>W</ci>
            <ci>normal-′</ci>
           </apply>
           <ci>x</ci>
          </apply>
          <ci>γ</ci>
         </apply>
        </apply>
       </apply>
       <ci>F</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="latexml">norm</csymbol>
        <apply>
         <minus></minus>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>W</ci>
           <ci>normal-′</ci>
          </apply>
          <ci>x</ci>
         </apply>
         <ci>γ</ci>
        </apply>
       </apply>
       <ci>F</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   dist(a,F_{l})=min_{x:W^{\prime}x=\gamma}\|x-a\|_{F}^{2}=\|W(W^{\prime}W)^{-1}(%
W^{\prime}x-\gamma)\|_{F}^{2}=\|W^{\prime}x-\gamma\|_{F}^{2}.
  </annotation>
 </semantics>
</math>

</p>

<p>The key part of this algorithm is how to update the cluster, i.e. given 

<math display="inline" id="K_q-flats:60">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 points, how to find a 

<math display="inline" id="K_q-flats:61">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

-flat that minimizes the sum of squares of distances of each point to the 

<math display="inline" id="K_q-flats:62">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

-flat. Mathematically, this problem is: given 

<math display="inline" id="K_q-flats:63">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>∈</mo>
    <msup>
     <mi>R</mi>
     <mrow>
      <mi>m</mi>
      <mo>×</mo>
      <mi>n</mi>
     </mrow>
    </msup>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>A</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\in R^{m\times n},
  </annotation>
 </semantics>
</math>

 solve the quadratic optimization problem</p>

<p>

<math display="inline" id="K_q-flats:64">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>P</mi>
      <mn>2</mn>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <msub>
     <mi>min</mi>
     <mrow>
      <mrow>
       <mi>W</mi>
       <mo>∈</mo>
       <msup>
        <mi>R</mi>
        <mrow>
         <mi>n</mi>
         <mo>×</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mi>q</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </msup>
      </mrow>
      <mo>,</mo>
      <mrow>
       <mi>γ</mi>
       <mo>∈</mo>
       <msup>
        <mi>R</mi>
        <mrow>
         <mn>1</mn>
         <mo>×</mo>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mi>q</mi>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </msup>
      </mrow>
     </mrow>
    </msub>
    <msubsup>
     <mrow>
      <mo>∥</mo>
      <mrow>
       <mrow>
        <mi>A</mi>
        <mi>W</mi>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mi>e</mi>
        <mi>γ</mi>
       </mrow>
      </mrow>
      <mo>∥</mo>
     </mrow>
     <mi>F</mi>
     <mn>2</mn>
    </msubsup>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <times></times>
     <ci>P</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <min></min>
     <apply>
      <csymbol cd="ambiguous">formulae-sequence</csymbol>
      <apply>
       <in></in>
       <ci>W</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>R</ci>
        <apply>
         <times></times>
         <ci>n</ci>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <ci>q</ci>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <in></in>
       <ci>γ</ci>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>R</ci>
        <apply>
         <times></times>
         <cn type="integer">1</cn>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <ci>q</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <apply>
         <times></times>
         <ci>A</ci>
         <ci>W</ci>
        </apply>
        <apply>
         <times></times>
         <ci>e</ci>
         <ci>γ</ci>
        </apply>
       </apply>
      </apply>
      <ci>F</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (P2)\min_{W\in R^{n\times(n-q)},\gamma\in R^{1\times(n-q)}}\|AW-e\gamma\|_{F}^%
{2},
  </annotation>
 </semantics>
</math>

 subject to 

<math display="inline" id="K_q-flats:65">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>W</mi>
      <mo>′</mo>
     </msup>
     <mi>W</mi>
    </mrow>
    <mo>=</mo>
    <mi>I</mi>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>W</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>W</ci>
    </apply>
    <ci>I</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   W^{\prime}W=I,
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="K_q-flats:66">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>∈</mo>
   <msup>
    <mi>R</mi>
    <mrow>
     <mi>m</mi>
     <mo>×</mo>
     <mi>n</mi>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>A</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>R</ci>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\in R^{m\times n}
  </annotation>
 </semantics>
</math>

 is given, and 

<math display="inline" id="K_q-flats:67">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>′</mo>
   </msup>
   <mo>∈</mo>
   <msup>
    <mi>R</mi>
    <mrow>
     <mi>m</mi>
     <mo>×</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>e</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <vector>
       <cn type="integer">1</cn>
       <ci>normal-…</ci>
       <cn type="integer">1</cn>
      </vector>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <in></in>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>R</ci>
      <apply>
       <times></times>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e=(1,\dots,1)^{\prime}\in R^{m\times 1}
  </annotation>
 </semantics>
</math>

.</p>

<p>The problem can be solved using Lagrangian multiplier method and the solution is as given in the cluster update step.</p>

<p>It can be shown that the algorithm will terminate in a finite number of iterations (no more than the total number of possible assignments, which is bounded by 

<math display="inline" id="K_q-flats:68">
 <semantics>
  <msup>
   <mi>k</mi>
   <mi>m</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{m}
  </annotation>
 </semantics>
</math>

). In addition, the algorithm will terminate at a point that the overall objective cannot be decreased either by a different assignment or by defining new cluster planes for these clusters (such point is called "locally optimal" in the references).</p>

<p>This convergence result is a consequence of the fact that problem (P2) can be solved exactly. The same convergence result holds for 

<math display="inline" id="K_q-flats:69">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-means algorithm because the cluster update problem can be solved exactly.</p>
<h2 id="relation-to-other-machine-learning-methods">Relation to other machine learning methods</h2>
<h3 id="k-means-algorithm">

<math display="inline" id="K_q-flats:70">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-means algorithm</h3>

<p>

<math display="inline" id="K_q-flats:71">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="K_q-flats:72">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

-flats algorithm is a generalization of 

<math display="inline" id="K_q-flats:73">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-means algorithm. In fact, 

<math display="inline" id="K_q-flats:74">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-means algorithm is 

<math display="inline" id="K_q-flats:75">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 0-flats algorithm since a point is a 0-flat. Despite their connection, they should be used in different scenarios. 

<math display="inline" id="K_q-flats:76">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="K_q-flats:77">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

-flats algorithm for the case that data lie in a few low-dimensional spaces.

<math display="inline" id="K_q-flats:78">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-means algorithm is desirable for the case the clusters are of the ambient dimension, . For example, if all observations lie in two lines, 

<math display="inline" id="K_q-flats:79">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="K_q-flats:80">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

-flats algorithm with 

<math display="inline" id="K_q-flats:81">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>q</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q=1
  </annotation>
 </semantics>
</math>

 may be used; if the observations are two <a href="Gaussian_clouds" title="wikilink">Gaussian clouds</a>, 

<math display="inline" id="K_q-flats:82">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-means algorithm may be used.</p>
<h3 id="sparse-dictionary-learning">Sparse Dictionary Learning</h3>

<p>Natural signals lie in a high-dimensional space. For example, the dimension of a 1024 by 1024 image is about <em>10</em><sup><em>6</em></sup>, which is far too high for most signal processing algorithms. One way to get rid of the high dimensionality is to find a set of basis functions, such that the high-dimensional signal can be represented by only a few basis functions. In other words, the coefficients of the signal representation lies in a low-dimensional space, which is easier to apply signal processing algorithms. In the literature, wavelet transform is usually used in image processing, and fourier transform is usually used in audio processing. The set of basis functions is usually called a <em>dictionary</em>.</p>

<p>However, it is not clear what is the best dictionary to use once given a signal data set. One popular approach is to find a dictionary when given a data set using the idea of Sparse Dictionary Learning. It aims to find a dictionary, such that the signal can be sparsely represented by the dictionary. The optimization problem can be written as follows.</p>

<p>

<math display="inline" id="K_q-flats:83">
 <semantics>
  <mrow>
   <msub>
    <mi>min</mi>
    <mrow>
     <mi>B</mi>
     <mo>,</mo>
     <mi>R</mi>
    </mrow>
   </msub>
   <msubsup>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mi>X</mi>
      <mo>-</mo>
      <mrow>
       <mi>B</mi>
       <mi>R</mi>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mi>F</mi>
    <mn>2</mn>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <min></min>
     <list>
      <ci>B</ci>
      <ci>R</ci>
     </list>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <ci>X</ci>
        <apply>
         <times></times>
         <ci>B</ci>
         <ci>R</ci>
        </apply>
       </apply>
      </apply>
      <ci>F</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min_{B,R}\|X-BR\|_{F}^{2}
  </annotation>
 </semantics>
</math>

 subject to 

<math display="inline" id="K_q-flats:84">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo>∥</mo>
     <msub>
      <mi>R</mi>
      <mi>i</mi>
     </msub>
     <mo>∥</mo>
    </mrow>
    <mn>0</mn>
   </msub>
   <mo>≤</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|R_{i}\|_{0}\leq q
  </annotation>
 </semantics>
</math>

</p>

<p>where</p>
<ul>
<li>X is a <em>d</em> by <em>N</em> matrix. Each columns of X represent a signal, and there are total <em>N</em> signals.</li>
<li>B is a <em>d</em> by <em>l</em> matrix. Each columns of B represent a basis function, and there are total <em>l</em> basis functions in the dictionary.</li>
<li>R is a <em>l</em> by <em>N</em> matrix. 

<math display="inline" id="K_q-flats:85">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{i}
  </annotation>
 </semantics>
</math>

 (<em>i</em><sup><em>th</em></sup> columns of R) represent the coefficients when we use the dictionary B to represent the <em>i</em><sup><em>th</em></sup> columns of X.</li>
<li>

<math display="inline" id="K_q-flats:86">
 <semantics>
  <msub>
   <mrow>
    <mo>∥</mo>
    <mi>v</mi>
    <mo>∥</mo>
   </mrow>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <ci>v</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|v\|_{0}
  </annotation>
 </semantics>
</math>

 denotes the zero-norm of the vector <em>v</em>.</li>
<li>

<math display="inline" id="K_q-flats:87">
 <semantics>
  <msub>
   <mrow>
    <mo>∥</mo>
    <mi>V</mi>
    <mo>∥</mo>
   </mrow>
   <mi>F</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <ci>V</ci>
    </apply>
    <ci>F</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|V\|_{F}
  </annotation>
 </semantics>
</math>

 denotes the Frobenious norm of matrix <em>V</em>.</li>
</ul>

<p>The idea of 

<math display="inline" id="K_q-flats:88">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="K_q-flats:89">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>-</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">limit-from</csymbol>
    <ci>q</ci>
    <minus></minus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q-
  </annotation>
 </semantics>
</math>

flats algorithm is similar to sparse dictionary learning in nature. If we restrict the q-flat to q-dimensional subspace, then the 

<math display="inline" id="K_q-flats:90">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="K_q-flats:91">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>-</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">limit-from</csymbol>
    <ci>q</ci>
    <minus></minus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q-
  </annotation>
 </semantics>
</math>

flats algorithm is simply finding the closed q-dimensional subspace to a given signal. Sparse dictionary learning is also doing the same thing, except for an additional constraints on the sparsity of the representation. Mathematically, it is possible to show that 

<math display="inline" id="K_q-flats:92">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="K_q-flats:93">
 <semantics>
  <mrow>
   <mi>q</mi>
   <mo>-</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">limit-from</csymbol>
    <ci>q</ci>
    <minus></minus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q-
  </annotation>
 </semantics>
</math>

flats algorithm is of the form of sparse dictionary learning with an additional block structure on <em>R</em>.</p>

<p>Let 

<math display="inline" id="K_q-flats:94">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{k}
  </annotation>
 </semantics>
</math>

 be a 

<math display="inline" id="K_q-flats:95">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>×</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\times q
  </annotation>
 </semantics>
</math>

 matrix, where columns of 

<math display="inline" id="K_q-flats:96">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{k}
  </annotation>
 </semantics>
</math>

 are basis of the 

<math display="inline" id="K_q-flats:97">
 <semantics>
  <msup>
   <mi>k</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{th}
  </annotation>
 </semantics>
</math>

 flat. Then the projection of the signal <em>x</em> to the 

<math display="inline" id="K_q-flats:98">
 <semantics>
  <msup>
   <mi>k</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>k</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k^{th}
  </annotation>
 </semantics>
</math>

 flat is 

<math display="inline" id="K_q-flats:99">
 <semantics>
  <mrow>
   <msub>
    <mi>B</mi>
    <mi>k</mi>
   </msub>
   <msub>
    <mi>r</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>B</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{k}r_{k}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="K_q-flats:100">
 <semantics>
  <msub>
   <mi>r</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>r</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r_{k}
  </annotation>
 </semantics>
</math>

 is a q-dimensional coefficient. Let 

<math display="inline" id="K_q-flats:101">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msub>
     <mi>B</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>,</mo>
    <msub>
     <mi>B</mi>
     <mi>K</mi>
    </msub>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>B</ci>
    <list>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <ci>K</ci>
     </apply>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B=[B_{1},\cdots,B_{K}]
  </annotation>
 </semantics>
</math>

 denote concatenation of basis of K flats, it is easy to show that the k -q-flat algorithm is the same as the following.</p>

<p>

<math display="inline" id="K_q-flats:102">
 <semantics>
  <mrow>
   <msub>
    <mi>min</mi>
    <mrow>
     <mi>B</mi>
     <mo>,</mo>
     <mi>R</mi>
    </mrow>
   </msub>
   <msubsup>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mi>X</mi>
      <mo>-</mo>
      <mrow>
       <mi>B</mi>
       <mi>R</mi>
      </mrow>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mi>F</mi>
    <mn>2</mn>
   </msubsup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <min></min>
     <list>
      <ci>B</ci>
      <ci>R</ci>
     </list>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <ci>X</ci>
        <apply>
         <times></times>
         <ci>B</ci>
         <ci>R</ci>
        </apply>
       </apply>
      </apply>
      <ci>F</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \min_{B,R}\|X-BR\|_{F}^{2}
  </annotation>
 </semantics>
</math>

 subject to 

<math display="inline" id="K_q-flats:103">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo>∥</mo>
     <msub>
      <mi>R</mi>
      <mi>i</mi>
     </msub>
     <mo>∥</mo>
    </mrow>
    <mn>0</mn>
   </msub>
   <mo>≤</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|R_{i}\|_{0}\leq q
  </annotation>
 </semantics>
</math>

 and <em>R</em> has a block structure.</p>

<p>The block structure of <em>R</em> refers the fact that each signal is labeled to only one flat. Comparing the two formulations, k q-flat is the same as sparse dictionary modeling when 

<math display="inline" id="K_q-flats:104">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mo>=</mo>
   <mrow>
    <mi>K</mi>
    <mo>×</mo>
    <mi>q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>l</ci>
    <apply>
     <times></times>
     <ci>K</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l=K\times q
  </annotation>
 </semantics>
</math>

 and with an additional block structure on <em>R</em>. Users may refer to Szlam's paper <a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> for more discussion about the relationship between the two concept.</p>
<h2 id="applications-and-variations">Applications and Variations</h2>
<h3 id="classification">Classification</h3>

<p><a href="Classification_in_machine_learning" title="wikilink">Classification</a> is a procedure that classifies an input signal into different classes. One example is to classify an email into <em>spam</em> or <em>non-spam</em> classes. Classification algorithms usually require a supervised learning stage. In the supervised learning stage, training data for each class is used for the algorithm to learn the characteristics of the class. In the classification stage, a new observation is classified into a class by using the characteristics that were already trained.</p>

<p>k q-flat algorithm can be used for classification. Suppose there are total of m classes. For each class, k flats are trained a priori via training data set. When a new data comes, find the flat that is closest to the new data. Then the new data is associate to class of the closest flat.</p>

<p>However, the classification performance can be further improved if we impose some structure on the flats. One possible choice is to require different flats from different class be sufficiently far apart. Some researchers <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> use this idea and develop a discriminative k q-flat algorithm.</p>
<h3 id="k-metrics">K-metrics <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></h3>

<p>In 

<math display="inline" id="K_q-flats:105">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="K_q-flats:106">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q
  </annotation>
 </semantics>
</math>

-flats algorithm, 

<math display="inline" id="K_q-flats:107">
 <semantics>
  <msup>
   <mrow>
    <mo>∥</mo>
    <mrow>
     <mi>x</mi>
     <mo>-</mo>
     <mrow>
      <msub>
       <mi>P</mi>
       <mi>F</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>∥</mo>
   </mrow>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <ci>F</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|x-P_{F}(x)\|^{2}
  </annotation>
 </semantics>
</math>

 is used to measure the representation error. 

<math display="inline" id="K_q-flats:108">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mi>F</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <ci>F</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{F}(x)
  </annotation>
 </semantics>
</math>

 denotes the projection of <em>x</em> to the flat <em>F</em>. If data lies in a q-dimension flat, then a single q-flat can represent the data very well. On the contrary, if data lies in a very high dimension space but near a common center, then k-means algorithm is a better way than k q-flat algorithm to represent the data. It is because 

<math display="inline" id="K_q-flats:109">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-means algorithm use 

<math display="inline" id="K_q-flats:110">
 <semantics>
  <msup>
   <mrow>
    <mo>∥</mo>
    <mrow>
     <mi>x</mi>
     <mo>-</mo>
     <msub>
      <mi>x</mi>
      <mi>c</mi>
     </msub>
    </mrow>
    <mo>∥</mo>
   </mrow>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="latexml">norm</csymbol>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>c</ci>
      </apply>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|x-x_{c}\|^{2}
  </annotation>
 </semantics>
</math>

 to measure the error, where 

<math display="inline" id="K_q-flats:111">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi>c</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{c}
  </annotation>
 </semantics>
</math>

 denotes the center. K-metrics is a generalization that use both the idea of flat and mean. In k-metrics, error is measured by the following Mahalanobis metric.</p>

<p>

<math display="inline" id="K_q-flats:112">
 <semantics>
  <mrow>
   <msubsup>
    <mrow>
     <mo>∥</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <mi>y</mi>
     </mrow>
     <mo>∥</mo>
    </mrow>
    <mi>A</mi>
    <mn>2</mn>
   </msubsup>
   <mo>=</mo>
   <mrow>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>x</mi>
       <mo>-</mo>
       <mi>y</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>T</mi>
    </msup>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>x</mi>
      <mo>-</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">norm</csymbol>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <ci>y</ci>
       </apply>
      </apply>
      <ci>A</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <ci>y</ci>
      </apply>
      <ci>T</ci>
     </apply>
     <ci>A</ci>
     <apply>
      <minus></minus>
      <ci>x</ci>
      <ci>y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|x-y\|_{A}^{2}=(x-y)^{T}A(x-y)
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>A</em> is a positive semi-definite matrix.</p>

<p>If <em>A</em> is the identity matrix, then the Mahalanobis metric is exactly the same as the error measure used in k-means. If <em>A</em> is not the identity matrix, then 

<math display="inline" id="K_q-flats:113">
 <semantics>
  <msubsup>
   <mrow>
    <mo>∥</mo>
    <mrow>
     <mi>x</mi>
     <mo>-</mo>
     <mi>y</mi>
    </mrow>
    <mo>∥</mo>
   </mrow>
   <mi>A</mi>
   <mn>2</mn>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">norm</csymbol>
      <apply>
       <minus></minus>
       <ci>x</ci>
       <ci>y</ci>
      </apply>
     </apply>
     <ci>A</ci>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \|x-y\|_{A}^{2}
  </annotation>
 </semantics>
</math>

 will favor certain directions as the k q-flat error measure.</p>
<h2 id="references">References</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Data_clustering_algorithms" title="wikilink">Category:Data clustering algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Bradley, P S, and O L Mangasarian. 2000. k-Plane Clustering. Journal of Global Optimization 16, no. 1: 23-32. <a class="uri" href="http://www.springerlink.com/index/H51L607707062TN7.pdf">http://www.springerlink.com/index/H51L607707062TN7.pdf</a>.<a href="#fnref1">↩</a></li>
<li id="fn2">Tseng, P. 2000. Nearest q-flat to m points. Journal of Optimization Theory and Applications 105, no. 1: 249–252.<a href="#fnref2">↩</a></li>
<li id="fn3">Szlam, A, and G Sapiro. 2009. “Discriminative k-metrics.” Ed. Léon Bottou and Michael Littman. Processing (1) 744615-744615-10<a href="#fnref3">↩</a></li>
<li id="fn4">Szlam, A, and G Sapiro. "Supervised Learning via Discriminative k q-Flats" <a href="ftp://128.97.4.251/pub/camreport/cam08-69.pdf">1</a><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
</ol>
</section>
</body>
</html>
