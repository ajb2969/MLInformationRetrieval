<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="785">Bach's algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Bach's algorithm</h1>
<hr/>

<p><strong>Bach's algorithm</strong><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> is a probabilistic <a href="polynomial_time" title="wikilink">polynomial time</a> <a class="uri" href="algorithm" title="wikilink">algorithm</a> for generating <a href="pseudorandom_number_generator" title="wikilink">random</a> numbers along with their <a class="uri" href="factorization" title="wikilink">factorization</a>, named after its discoverer, <a href="Eric_Bach" title="wikilink">Eric Bach</a>. It is of interest because no algorithm is known that efficiently factors numbers, so the straightforward method, namely generating a random number and then factoring it, is impractical.</p>

<p>The algorithm performs, in expectation, O(log n) <a href="primality_tests" title="wikilink">primality tests</a>.</p>

<p>A simpler, but less efficient algorithm (performing, in expectation, O(log<sup>2</sup> n) primality tests), is known and is due to <a href="Adam_Kalai" title="wikilink">Adam Kalai</a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="overview">Overview</h2>

<p>Bach's algorithm produces a number <em>x</em> uniformly at random between a given limit <em>N</em> and <em>N</em>/2, specifically 

<math display="inline" id="Bach's_algorithm:0">
 <semantics>
  <mrow>
   <mfrac>
    <mi>N</mi>
    <mn>2</mn>
   </mfrac>
   <mo><</mo>
   <mi>x</mi>
   <mo>≤</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <apply>
      <divide></divide>
      <ci>N</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>x</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{N}{2}<x\leq N
  </annotation>
 </semantics>
</math>

, along with its factorization. It does this by picking a <a href="prime_number" title="wikilink">prime number</a> <em>p</em> and an exponent <em>a</em> such that 

<math display="inline" id="Bach's_algorithm:1">
 <semantics>
  <mrow>
   <msup>
    <mi>p</mi>
    <mi>a</mi>
   </msup>
   <mo>≤</mo>
   <mi>N</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>p</ci>
     <ci>a</ci>
    </apply>
    <ci>N</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{a}\leq N
  </annotation>
 </semantics>
</math>

, according to a certain distribution. Bach's algorithm is then recursively applied to generate a number <em>y</em> uniformly at random between <em>M</em> and <em>M</em>/2, where 

<math display="inline" id="Bach's_algorithm:2">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mfrac>
    <mi>N</mi>
    <msup>
     <mi>p</mi>
     <mi>a</mi>
    </msup>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <apply>
     <divide></divide>
     <ci>N</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <ci>a</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=\frac{N}{p^{a}}
  </annotation>
 </semantics>
</math>

, along with the factorization of <em>y</em>. It then sets 

<math display="inline" id="Bach's_algorithm:3">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi>p</mi>
     <mi>a</mi>
    </msup>
    <mi>y</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>p</ci>
      <ci>a</ci>
     </apply>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=p^{a}y
  </annotation>
 </semantics>
</math>

, and appends 

<math display="inline" id="Bach's_algorithm:4">
 <semantics>
  <msup>
   <mi>p</mi>
   <mi>a</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>p</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p^{a}
  </annotation>
 </semantics>
</math>

 to the factorization of <em>y</em> to produce the factorization of <em>x</em>. This gives <em>x</em> which logarithmic distribution over the desired range; <a href="rejection_sampling" title="wikilink">rejection sampling</a> is then used to get a uniform distribution.</p>
<h2 id="references">References</h2>
<references>
</references>
<ul>
<li><a href="Eric_Bach" title="wikilink">Bach, Eric</a>. <em>Analytic methods in the Analysis and Design of Number-Theoretic Algorithms</em>, MIT Press, 1984. Chapter 2, "Generation of Random Factorizations", part of which is available online <a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15750-s02/www/dartboard.pdf">here</a>.</li>
</ul>

<p>"</p>

<p><a href="Category:Cryptographic_algorithms" title="wikilink">Category:Cryptographic algorithms</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="Eric_Bach" title="wikilink">Bach, Eric</a>. <em>How to Generate Factored Random Numbers</em>, SIAM Journal of Computing, 17 (1988), pp 179-193.<a href="#fnref1">↩</a></li>
<li id="fn2">Generating Random Factored Numbers, Easily: Adam Kalai, Journal of Cryptology, Vol 16, Number 4, 2003<a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
