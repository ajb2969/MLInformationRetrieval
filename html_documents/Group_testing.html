<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1182">Group testing</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Group testing</h1>
<hr/>

<p>In <a href="combinatorics" title="wikilink">combinatorial mathematics</a>, <strong>group testing</strong> refers to any procedure which breaks up the task of locating elements of a set which have certain properties into tests on subsets ("groups") rather than on individual elements. A familiar example of this type of technique is the false coin problem of <a href="recreational_mathematics" title="wikilink">recreational mathematics</a>. In this problem there are <em>n</em> coins and one of them is false, weighing less than a real coin. The objective is to find the false coin, using a <a href="balance_scale" title="wikilink">balance scale</a>, in the fewest number of weighings. By repeatedly dividing the coins in half and comparing the two halves, the false coin can be found quickly as it is always in the lighter half.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>Schemes for carrying out such group testing can be simple or complex and the tests involved at each stage may be different. Schemes in which the tests for the next stage depend on the results of the previous stages are called <em>adaptive procedures</em>, while schemes designed so that all the tests are known beforehand are called <em>non-adaptive procedures</em>. The structure of the scheme of the tests involved in a non-adaptive procedure is known as a <strong>pooling design</strong>.</p>
<h2 id="background">Background</h2>

<p>Robert Dorfman's paper in 1943 introduced the field of (Combinatorial) Group Testing. The motivation arose during the Second World War when the United States Public Health Service and the Selective service embarked upon a large scale project. The objective was to weed out all syphilitic men called up for induction. However, syphilis testing back then was expensive and testing every soldier individually would have been very cost heavy and inefficient. A basic breakdown of a <strong>test</strong> is:</p>
<ul>
<li>Draw sample from a given individual</li>
<li>Perform required tests</li>
<li>Determine presence or absence of syphilis</li>
</ul>

<p>Say we have 

<math display="inline" id="Group_testing:0">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 soldiers, then this method of testing leads to 

<math display="inline" id="Group_testing:1">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 tests. If we have 70-75% of the people infected then the method of individual testing would be reasonable. Our goal however, is to achieve effective testing in the more likely scenario where it does not make sense to test 100,000 people to get (say) 10 positives.</p>

<p>The feasibility of a more effective testing scheme hinges on the following property. We can combine blood samples and test a combined sample together to check if at least one soldier has syphilis.</p>

<p>Modern interest in these testing schemes has been rekindled by the Human Genome Project.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="formalization-of-the-problem">Formalization of the problem</h2>

<p>We now formalize the group testing problem abstractly.</p>

<p>

<math display="inline" id="Group_testing:2">
 <semantics>
  <mrow>
   <mrow>
    <mi>I</mi>
    <mi>n</mi>
    <mi>p</mi>
    <mi>u</mi>
    <mi>t</mi>
   </mrow>
   <mo>:</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <ci>I</ci>
     <ci>n</ci>
     <ci>p</ci>
     <ci>u</ci>
     <ci>t</ci>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Input:
  </annotation>
 </semantics>
</math>

 The total number of soldiers 

<math display="inline" id="Group_testing:3">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

, an <a href="upper_bound" title="wikilink">upper bound</a> on the number of infected soldiers 

<math display="inline" id="Group_testing:4">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

. The (unknown) information about which soldier is infected described as a <a href="Tuple" title="wikilink">vector</a> 

<math display="inline" id="Group_testing:5">
 <semantics>
  <mrow>
   <mi>ğ±</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">â€¦</mi>
    <mo>,</mo>
    <msub>
     <mi>x</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ğ±</ci>
    <vector>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-â€¦</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}=(x_{1},x_{2},...,x_{n})
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Group_testing:6">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}=1
  </annotation>
 </semantics>
</math>

 if the item 

<math display="inline" id="Group_testing:7">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 is infected else 

<math display="inline" id="Group_testing:8">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}=0
  </annotation>
 </semantics>
</math>

.</p>

<p>The <em>Hamming Weight</em> of 

<math display="inline" id="Group_testing:9">
 <semantics>
  <mi>ğ±</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ±</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 is defined as the number of 

<math display="inline" id="Group_testing:10">
 <semantics>
  <mrow>
   <msup>
    <mn>1</mn>
    <mo>â€²</mo>
   </msup>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">1</cn>
     <ci>normal-â€²</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1^{\prime}s
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Group_testing:11">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

. Hence, 

<math display="inline" id="Group_testing:12">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">|</mo>
    <mi>x</mi>
    <mo stretchy="false">|</mo>
   </mrow>
   <mo>â‰¤</mo>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <ci>x</ci>
    </apply>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |x|\leq d
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Group_testing:13">
 <semantics>
  <mrow>
   <mo stretchy="false">|</mo>
   <mi>x</mi>
   <mo stretchy="false">|</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <abs></abs>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |x|
  </annotation>
 </semantics>
</math>

 is the <a href="Hamming_weight" title="wikilink">Hamming weight</a>. The vector 

<math display="inline" id="Group_testing:14">
 <semantics>
  <mi>ğ±</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ±</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 is an implicit input since we do not know the positions of 

<math display="inline" id="Group_testing:15">
 <semantics>
  <mrow>
   <msup>
    <mn>1</mn>
    <mo>â€²</mo>
   </msup>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">1</cn>
     <ci>normal-â€²</ci>
    </apply>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1^{\prime}s
  </annotation>
 </semantics>
</math>

 in the input. The only way to find out is to run the tests.</p>
<h3 id="formal-notion-of-a-test">Formal notion of a Test</h3>

<p>A <strong>query/test</strong> 

<math display="inline" id="Group_testing:16">
 <semantics>
  <mi>S</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>S</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S
  </annotation>
 </semantics>
</math>

 is a subset of 

<math display="inline" id="Group_testing:17">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>n</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [n]
  </annotation>
 </semantics>
</math>

. The answer to the query 

<math display="inline" id="Group_testing:18">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>âŠ†</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subseteq[n]
  </annotation>
 </semantics>
</math>

 is defined as follows:</p>

<p>

<math display="inline" id="Group_testing:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>{</mo>
    <mtable>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mrow>
         <mn>1</mn>
         <mo>,</mo>
         <mrow>
          <mtext>if</mtext>
          <mrow>
           <mstyle displaystyle="true">
            <munder>
             <mo largeop="true" movablelimits="false" symmetric="true">âˆ‘</mo>
             <mrow>
              <mi>k</mi>
              <mo>âˆˆ</mo>
              <mi>S</mi>
             </mrow>
            </munder>
           </mstyle>
           <msub>
            <mi>x</mi>
            <mi>k</mi>
           </msub>
          </mrow>
         </mrow>
        </mrow>
        <mo>â‰¥</mo>
        <mn>1</mn>
       </mrow>
      </mtd>
      <mtd></mtd>
     </mtr>
     <mtr>
      <mtd columnalign="left">
       <mrow>
        <mn>0</mn>
        <mo>,</mo>
        <mtext>otherwise.</mtext>
       </mrow>
      </mtd>
      <mtd></mtd>
     </mtr>
    </mtable>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">cases</csymbol>
     <apply>
      <geq></geq>
      <list>
       <cn type="integer">1</cn>
       <apply>
        <times></times>
        <mtext>if</mtext>
        <apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <in></in>
           <ci>k</ci>
           <ci>S</ci>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
      </list>
      <cn type="integer">1</cn>
     </apply>
     <mtext>otherwise</mtext>
     <list>
      <cn type="integer">0</cn>
      <mtext>otherwise.</mtext>
     </list>
     <mtext>otherwise</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(S)=\begin{cases}1,\mbox{ if }\displaystyle\sum_{k\in S}x_{k}\geq 1\\
0,\mbox{ otherwise.}\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>Note that the addition operation used by the summation is the logical-

<math display="inline" id="Group_testing:20">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mi>R</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <ci>R</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   OR
  </annotation>
 </semantics>
</math>

, i.e.</p>

<p>

<math display="inline" id="Group_testing:21">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mstyle displaystyle="true">
     <munder>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">â‹</mo>
      <mrow>
       <mi>i</mi>
       <mo>âˆˆ</mo>
       <mi>S</mi>
      </mrow>
     </munder>
    </mstyle>
    <msub>
     <mi>x</mi>
     <mi>i</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>A</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <or></or>
      <apply>
       <in></in>
       <ci>i</ci>
       <ci>S</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A(S)=\displaystyle\bigvee_{i\in S}x_{i}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="goal">Goal</h3>

<p>Compute 

<math display="inline" id="Group_testing:22">
 <semantics>
  <mi>ğ±</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ±</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 and minimize the number of tests required to determine 

<math display="inline" id="Group_testing:23">
 <semantics>
  <mi>ğ±</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ±</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

</p>

<p>The question boils down to one of <strong><em>Combinatorial Searching</em></strong>. Combinatorial searching in general can be explained as follows: Say you have a set of 

<math display="inline" id="Group_testing:24">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 variables and each of these can take on 

<math display="inline" id="Group_testing:25">
 <semantics>
  <mi>m</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>m</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m
  </annotation>
 </semantics>
</math>

 possible values. So, finding possible solutions that match a certain constraint is a problem of combinatorial searching. The major problem with such questions is that the solution can grow <a href="Exponential_growth" title="wikilink">exponentially</a> in the size of the input. Here, we have no direct questions or answers. Any piece of information can only be obtained using an indirect query.</p>
<h3 id="definition">Definition</h3>

<p>

<math display="inline" id="Group_testing:26">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>d</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <interval closure="open">
      <ci>d</ci>
      <ci>n</ci>
     </interval>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(d,n):
  </annotation>
 </semantics>
</math>

 Given a set of 

<math display="inline" id="Group_testing:27">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 items with 

<math display="inline" id="Group_testing:28">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 defects, the minimum number of tests that one would have to make to detect all the defective items is defined as 

<math display="inline" id="Group_testing:29">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>d</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <interval closure="open">
     <ci>d</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(d,n)
  </annotation>
 </semantics>
</math>

.</p>

<p>Consider the case when only one person in the group will test positive. Then if we tested in the naive way, in the best case we would at least have to test the first person to find out if he/she is infected. However, in the worst case one might have to end up testing the entire group and only the last person we test will turn out to really be the one who was infected. Hence, 

<math display="inline" id="Group_testing:30">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>â‰¤</mo>
   <mrow>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>d</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â‰¤</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <ci>t</ci>
      <interval closure="open">
       <ci>d</ci>
       <ci>n</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq t(d,n)\leq n
  </annotation>
 </semantics>
</math>

</p>
<h3 id="testing-methods">Testing Methods</h3>

<p>There are two basic principles via which the testing may be carried out:</p>
<ol>
<li><em>Adaptive Group Testing</em> is where we test a given subset of items and, we get the answer from the test. We then base the next test on the outcome of the current test.</li>
<li><em>Non-adaptive Group Testing</em> on the other hand is when all the tests to be performed are decided <em>a priori</em>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></li>
</ol>
<h4 id="definition-1">Definition</h4>

<p>

<math display="inline" id="Group_testing:31">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>t</mi>
     <mi>a</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>d</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <ci>a</ci>
     </apply>
     <interval closure="open">
      <ci>d</ci>
      <ci>n</ci>
     </interval>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{a}(d,n):
  </annotation>
 </semantics>
</math>

 Given a set of 

<math display="inline" id="Group_testing:32">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 items with 

<math display="inline" id="Group_testing:33">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 defects, 

<math display="inline" id="Group_testing:34">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>t</mi>
     <mi>a</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>d</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <ci>a</ci>
     </apply>
     <interval closure="open">
      <ci>d</ci>
      <ci>n</ci>
     </interval>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{a}(d,n):
  </annotation>
 </semantics>
</math>

 is defined as the number of adaptive tests that one would have to make to detect all the defective items.</p>

<p>One should note that in the case of group testing for the Syphilis problem, non-adaptive group testing is crucial. This is because the soldiers might be spread out geographically and adaptive group testing will need a lot of co-ordination.</p>
<h3 id="mathematical-representation-of-the-set-of-non-adaptive-tests">Mathematical representation of the set of non-adaptive tests</h3>

<p>For, 

<math display="inline" id="Group_testing:35">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>âŠ†</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>S</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\subseteq[n]
  </annotation>
 </semantics>
</math>

, define 

<math display="inline" id="Group_testing:36">
 <semantics>
  <mrow>
   <msub>
    <mi>Ï‡</mi>
    <mi>i</mi>
   </msub>
   <mo>âˆˆ</mo>
   <msup>
    <mrow>
     <mo stretchy="false">{</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mn>1</mn>
     <mo stretchy="false">}</mo>
    </mrow>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>Ï‡</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <set>
      <cn type="integer">0</cn>
      <cn type="integer">1</cn>
     </set>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \chi_{i}\in\{0,1\}^{n}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Group_testing:37">
 <semantics>
  <mrow>
   <mrow>
    <mi>i</mi>
    <mo>âˆˆ</mo>
    <mi>S</mi>
   </mrow>
   <mo>â‡”</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>Ï‡</mi>
      <mi>s</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>i</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-â‡”</ci>
    <apply>
     <in></in>
     <ci>i</ci>
     <ci>S</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>Ï‡</ci>
       <ci>s</ci>
      </apply>
      <ci>i</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\in S\Leftrightarrow\chi_{s}(i)=1
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Group_testing:38">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 is a 

<math display="inline" id="Group_testing:39">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>Ã—</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\times n
  </annotation>
 </semantics>
</math>

 matrix of 

<math display="inline" id="Group_testing:40">
 <semantics>
  <msub>
   <mi>Ï‡</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Ï‡</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \chi_{i}
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Group_testing:41">
 <semantics>
  <mi>ğ±</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ±</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 is the input vector transposed and 

<math display="inline" id="Group_testing:42">
 <semantics>
  <mi>ğ«</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ«</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r}
  </annotation>
 </semantics>
</math>

 is the resultant. The construction is based on the grounds that for non-adaptive testing with 

<math display="inline" id="Group_testing:43">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 tests is represented by a 

<math display="inline" id="Group_testing:44">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>-</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">limit-from</csymbol>
    <ci>t</ci>
    <minus></minus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t-
  </annotation>
 </semantics>
</math>

subset 

<math display="inline" id="Group_testing:45">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mi>i</mi>
   </msub>
   <mo>âŠ†</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo>â‰¤</mo>
    <mi>i</mi>
    <mo>â‰¤</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <ci>i</ci>
    </apply>
    <subset></subset>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cn type="integer">1</cn>
     <leq></leq>
     <csymbol cd="unknown">i</csymbol>
     <leq></leq>
     <csymbol cd="unknown">t</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{i}\subseteq[n](1\leq i\leq t)
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="Group_testing:46">
 <semantics>
  <msub>
   <mi>Ï‡</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>Ï‡</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \chi_{i}
  </annotation>
 </semantics>
</math>

 for a given 

<math display="inline" id="Group_testing:47">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 is the 

<math display="inline" id="Group_testing:48">
 <semantics>
  <msup>
   <mi>i</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>i</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i^{th}
  </annotation>
 </semantics>
</math>

 test. 

<math display="inline" id="Group_testing:49">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 test matrix where 

<math display="inline" id="Group_testing:50">
 <semantics>
  <msub>
   <mi>m</mi>
   <mrow>
    <mi>i</mi>
    <mo>,</mo>
    <mi>j</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>m</ci>
    <list>
     <ci>i</ci>
     <ci>j</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m_{i,j}
  </annotation>
 </semantics>
</math>

 is one if for the 

<math display="inline" id="Group_testing:51">
 <semantics>
  <msup>
   <mi>i</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>i</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i^{th}
  </annotation>
 </semantics>
</math>

 test, 

<math display="inline" id="Group_testing:52">
 <semantics>
  <mrow>
   <mi>j</mi>
   <mo>âˆˆ</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>j</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j\in S
  </annotation>
 </semantics>
</math>

. Note that here multiplication is logical AND (

<math display="inline" id="Group_testing:53">
 <semantics>
  <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">â‹€</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigwedge
  </annotation>
 </semantics>
</math>

) and addition is logical OR (

<math display="inline" id="Group_testing:54">
 <semantics>
  <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">â‹</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigvee
  </annotation>
 </semantics>
</math>

). Then, 

<math display="inline" id="Group_testing:55">
 <semantics>
  <mrow>
   <mrow>
    <mi>M</mi>
    <mo>Ã—</mo>
    <mi>ğ±</mi>
   </mrow>
   <mo>=</mo>
   <mi>ğ«</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>M</ci>
     <ci>ğ±</ci>
    </apply>
    <ci>ğ«</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M\times\mathbf{x}=\mathbf{r}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Group_testing:56">
 <semantics>
  <mi>ğ«</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ«</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r}
  </annotation>
 </semantics>
</math>

 is the resultant of the matrix multiplication. To think of this in terms of testing, it is helpful to visualize matrix multiplication. Here, 

<math display="inline" id="Group_testing:57">
 <semantics>
  <mi>ğ«</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ«</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r}
  </annotation>
 </semantics>
</math>

 will have a 1 in position 

<math display="inline" id="Group_testing:58">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 if and only if there was a 

<math display="inline" id="Group_testing:59">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 in that position in both 

<math display="inline" id="Group_testing:60">
 <semantics>
  <mi>M</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>M</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Group_testing:61">
 <semantics>
  <mi>ğ±</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ±</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 i.e. if that person was tested with that particular group and if he tested out to be positive. 

<math display="inline" id="Group_testing:62">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msub>
         <mi>m</mi>
         <mrow>
          <mn>1</mn>
          <mo>,</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mi mathvariant="normal">â‹¯</mi>
        <msub>
         <mi>m</mi>
         <mrow>
          <mn>1</mn>
          <mo>,</mo>
          <mi>n</mi>
         </mrow>
        </msub>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <mi mathvariant="normal">â‹®</mi>
        <mi mathvariant="normal">â‹±</mi>
        <mi mathvariant="normal">â‹®</mi>
       </mrow>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mrow>
        <msub>
         <mi>m</mi>
         <mrow>
          <mi>t</mi>
          <mo>,</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mi mathvariant="normal">â‹¯</mi>
        <msub>
         <mi>m</mi>
         <mrow>
          <mi>t</mi>
          <mo>,</mo>
          <mi>n</mi>
         </mrow>
        </msub>
       </mrow>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <matrix>
     <matrixrow>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <list>
         <cn type="integer">1</cn>
         <cn type="integer">1</cn>
        </list>
       </apply>
       <ci>normal-â‹¯</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <list>
         <cn type="integer">1</cn>
         <ci>n</ci>
        </list>
       </apply>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <ci>normal-â‹®</ci>
       <ci>normal-â‹±</ci>
       <ci>normal-â‹®</ci>
      </apply>
     </matrixrow>
     <matrixrow>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <list>
         <ci>t</ci>
         <cn type="integer">1</cn>
        </list>
       </apply>
       <ci>normal-â‹¯</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <list>
         <ci>t</ci>
         <ci>n</ci>
        </list>
       </apply>
      </apply>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=\begin{pmatrix}m_{1,1}\cdots m_{1,n}\\
\vdots\ddots\vdots\\
m_{t,1}\cdots m_{t,n}\end{pmatrix}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Group_testing:63">
 <semantics>
  <mrow>
   <mi>ğ±</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mtable>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi mathvariant="normal">â‹®</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>x</mi>
         <mi>n</mi>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
    <mi>ğ«</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>r</mi>
        <mn>1</mn>
       </msub>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mi mathvariant="normal">â‹®</mi>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <msub>
        <mi>r</mi>
        <mi>t</mi>
       </msub>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>ğ±</ci>
     <apply>
      <times></times>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
       </matrixrow>
       <matrixrow>
        <ci>normal-â‹®</ci>
       </matrixrow>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </matrixrow>
      </matrix>
      <ci>ğ«</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <cn type="integer">1</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <ci>normal-â‹®</ci>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <ci>t</ci>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}=\begin{pmatrix}x_{1}\\
\vdots\\
x_{n}\end{pmatrix}\mathbf{r}=\begin{pmatrix}r_{1}\\
\vdots\\
r_{t}\end{pmatrix}
  </annotation>
 </semantics>
</math>

</p>
<h3 id="bounds-for-testing-on-tadn-and-tdn">Bounds for testing on 

<math display="inline" id="Group_testing:64">
 <semantics>
  <mrow>
   <msup>
    <mi>t</mi>
    <mi>a</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>d</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>t</ci>
     <ci>a</ci>
    </apply>
    <interval closure="open">
     <ci>d</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{a}(d,n)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Group_testing:65">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>d</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <interval closure="open">
     <ci>d</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(d,n)
  </annotation>
 </semantics>
</math>

</h3>

<p>

<math display="inline" id="Group_testing:66">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>â‰¤</mo>
   <mrow>
    <msup>
     <mi>t</mi>
     <mi>a</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>d</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â‰¤</mo>
   <mrow>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>d</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â‰¤</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <cn type="integer">1</cn>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>t</ci>
       <ci>a</ci>
      </apply>
      <interval closure="open">
       <ci>d</ci>
       <ci>n</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>t</ci>
      <interval closure="open">
       <ci>d</ci>
       <ci>n</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\leq t^{a}(d,n)\leq t(d,n)\leq n
  </annotation>
 </semantics>
</math>

</p>

<p>The reason for 

<math display="inline" id="Group_testing:67">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>t</mi>
     <mi>a</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>d</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â‰¤</mo>
   <mrow>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>d</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <ci>a</ci>
     </apply>
     <interval closure="open">
      <ci>d</ci>
      <ci>n</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>t</ci>
     <interval closure="open">
      <ci>d</ci>
      <ci>n</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{a}(d,n)\leq t(d,n)
  </annotation>
 </semantics>
</math>

 is due to the fact that any non-adaptive test can be performed by an adaptive test by running all of the tests in the first step of the adaptive test. Adaptive tests can be more efficient than non-adaptive tests since the test can be changed after certain things are discovered.</p>
<h4 id="lower-bound-on-tadn">Lower bound on 

<math display="inline" id="Group_testing:68">
 <semantics>
  <mrow>
   <msup>
    <mi>t</mi>
    <mi>a</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>d</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>t</ci>
     <ci>a</ci>
    </apply>
    <interval closure="open">
     <ci>d</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{a}(d,n)
  </annotation>
 </semantics>
</math>

</h4>

<p>Fix a valid group testing scheme with 

<math display="inline" id="Group_testing:69">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 tests. Now, for two distinct vectors 

<math display="inline" id="Group_testing:70">
 <semantics>
  <mi>ğ±</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ±</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Group_testing:71">
 <semantics>
  <mi>ğ²</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ²</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Group_testing:72">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>ğ±</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>ğ²</mi>
     <mo stretchy="false">|</mo>
    </mrow>
   </mrow>
   <mo>â‰¤</mo>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <list>
     <apply>
      <abs></abs>
      <ci>ğ±</ci>
     </apply>
     <apply>
      <abs></abs>
      <ci>ğ²</ci>
     </apply>
    </list>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\mathbf{x}|,|\mathbf{y}|\leq d
  </annotation>
 </semantics>
</math>

, the resulting vectors will not be the same i.e. 

<math display="inline" id="Group_testing:73">
 <semantics>
  <mrow>
   <mrow>
    <mi>ğ«</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ğ±</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â‰ </mo>
   <mrow>
    <mi>ğ«</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ğ²</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <apply>
     <times></times>
     <ci>ğ«</ci>
     <ci>ğ±</ci>
    </apply>
    <apply>
     <times></times>
     <ci>ğ«</ci>
     <ci>ğ²</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r(x)}\neq\mathbf{r(y)}
  </annotation>
 </semantics>
</math>

. Here 

<math display="inline" id="Group_testing:74">
 <semantics>
  <mrow>
   <mi>ğ«</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ğ±</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ğ«</ci>
    <ci>ğ±</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r(x)}
  </annotation>
 </semantics>
</math>

 is the resultant vector when 

<math display="inline" id="Group_testing:75">
 <semantics>
  <mi>ğ±</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ±</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

. This is because, two valid inputs will never give us the same result. If this ever happened, then we would always have an error in finding both 

<math display="inline" id="Group_testing:76">
 <semantics>
  <mi>ğ±</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ±</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{x}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Group_testing:77">
 <semantics>
  <mi>ğ²</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ²</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{y}
  </annotation>
 </semantics>
</math>

. This gives us that the total number of distinct results is the volume of a Hamming Ball of radius 

<math display="inline" id="Group_testing:78">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

, centered about 

<math display="inline" id="Group_testing:79">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n
  </annotation>
 </semantics>
</math>

 i.e. 

<math display="inline" id="Group_testing:80">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mi>o</mi>
   <msub>
    <mi>l</mi>
    <mn>2</mn>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>d</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>V</ci>
    <ci>o</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>l</ci>
     <cn type="integer">2</cn>
    </apply>
    <interval closure="open">
     <ci>d</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Vol_{2}(d,n)
  </annotation>
 </semantics>
</math>

. However, for 

<math display="inline" id="Group_testing:81">
 <semantics>
  <mi>t</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>t</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t
  </annotation>
 </semantics>
</math>

 bits, the total number of possible distinct vectors is 

<math display="inline" id="Group_testing:82">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>t</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{t}
  </annotation>
 </semantics>
</math>

. Hence, 

<math display="inline" id="Group_testing:83">
 <semantics>
  <mrow>
   <msup>
    <mn>2</mn>
    <mi>t</mi>
   </msup>
   <mo>â‰¥</mo>
   <mrow>
    <mi>V</mi>
    <mi>o</mi>
    <msub>
     <mi>l</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>d</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>t</ci>
    </apply>
    <apply>
     <times></times>
     <ci>V</ci>
     <ci>o</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>l</ci>
      <cn type="integer">2</cn>
     </apply>
     <interval closure="open">
      <ci>d</ci>
      <ci>n</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{t}\geq Vol_{2}(d,n)
  </annotation>
 </semantics>
</math>

. Taking the 

<math display="inline" id="Group_testing:84">
 <semantics>
  <mi>log</mi>
  <annotation-xml encoding="MathML-Content">
   <log></log>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \log
  </annotation>
 </semantics>
</math>

 on both sides gives us 

<math display="inline" id="Group_testing:85">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mo>â‰¥</mo>
   <mrow>
    <mi>log</mi>
    <mrow>
     <mo stretchy="false">{</mo>
     <mrow>
      <mi>V</mi>
      <mi>o</mi>
      <msub>
       <mi>l</mi>
       <mn>2</mn>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>d</mi>
       <mo>,</mo>
       <mi>n</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>t</ci>
    <apply>
     <log></log>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>o</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <cn type="integer">2</cn>
      </apply>
      <interval closure="open">
       <ci>d</ci>
       <ci>n</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t\geq\log\{Vol_{2}(d,n)\}
  </annotation>
 </semantics>
</math>

.</p>

<p>Now, 

<math display="inline" id="Group_testing:86">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mi>o</mi>
    <msub>
     <mi>l</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>d</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â‰¥</mo>
   <mrow>
    <mo>(</mo>
    <mstyle scriptlevel="+1">
     <mtable columnspacing="0.4em" rowspacing="0.2ex">
      <mtr>
       <mtd>
        <mi>n</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd>
        <mi>d</mi>
       </mtd>
      </mtr>
     </mtable>
    </mstyle>
    <mo>)</mo>
   </mrow>
   <mo>â‰¥</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mfrac>
      <mi>n</mi>
      <mi>d</mi>
     </mfrac>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>d</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <geq></geq>
     <apply>
      <times></times>
      <ci>V</ci>
      <ci>o</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <cn type="integer">2</cn>
      </apply>
      <interval closure="open">
       <ci>d</ci>
       <ci>n</ci>
      </interval>
     </apply>
     <apply>
      <csymbol cd="latexml">binomial</csymbol>
      <ci>n</ci>
      <ci>d</ci>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <ci>d</ci>
      </apply>
      <ci>d</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Vol_{2}(d,n)\geq{n\choose d}\geq(\frac{n}{d})^{d}
  </annotation>
 </semantics>
</math>

. Therefore, we will end up having to perform a minimum of 

<math display="inline" id="Group_testing:87">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mi>log</mi>
    <mfrac>
     <mi>n</mi>
     <mi>d</mi>
    </mfrac>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <apply>
     <log></log>
     <apply>
      <divide></divide>
      <ci>n</ci>
      <ci>d</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d\log{\frac{n}{d}}
  </annotation>
 </semantics>
</math>

 tests.</p>

<p>Thus we have proved, 

<math display="inline" id="Group_testing:88">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>t</mi>
     <mi>a</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>d</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â‰¥</mo>
   <mrow>
    <mi>d</mi>
    <mrow>
     <mi>log</mi>
     <mfrac>
      <mi>n</mi>
      <mi>d</mi>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <ci>a</ci>
     </apply>
     <interval closure="open">
      <ci>d</ci>
      <ci>n</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>d</ci>
     <apply>
      <log></log>
      <apply>
       <divide></divide>
       <ci>n</ci>
       <ci>d</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{a}(d,n)\geq d\log\frac{n}{d}
  </annotation>
 </semantics>
</math>

</p>
<h4 id="upper-bound-on-tadn">Upper bound on 

<math display="inline" id="Group_testing:89">
 <semantics>
  <mrow>
   <msup>
    <mi>t</mi>
    <mi>a</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>d</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>t</ci>
     <ci>a</ci>
    </apply>
    <interval closure="open">
     <ci>d</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{a}(d,n)
  </annotation>
 </semantics>
</math>

</h4>

<p>

<math display="inline" id="Group_testing:90">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>t</mi>
     <mi>a</mi>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>d</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â‰¤</mo>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>d</mi>
      <mrow>
       <mi>log</mi>
       <mi>n</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>t</ci>
      <ci>a</ci>
     </apply>
     <interval closure="open">
      <ci>d</ci>
      <ci>n</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>O</ci>
     <apply>
      <times></times>
      <ci>d</ci>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{a}(d,n)\leq O(d\log{n})
  </annotation>
 </semantics>
</math>

.</p>

<p>Since we know that the upper bound on the number of positives is 

<math display="inline" id="Group_testing:91">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

, we run a binary search at most 

<math display="inline" id="Group_testing:92">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 times or until there are no more values to be found. To simplify the problem we try to give a testing sccheme that uses 

<math display="inline" id="Group_testing:93">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(\log{n})
  </annotation>
 </semantics>
</math>

 adaptive tests to figure out a 

<math display="inline" id="Group_testing:94">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Group_testing:95">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>i</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{i}=1
  </annotation>
 </semantics>
</math>

. The related problem is solved by splitting 

<math display="inline" id="Group_testing:96">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>n</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [n]
  </annotation>
 </semantics>
</math>

 in two halves and querying to find a 

<math display="inline" id="Group_testing:97">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 in one of those and then proceeding recursively to find the exact position in the half where the query returned a 

<math display="inline" id="Group_testing:98">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

. This will take 

<math display="inline" id="Group_testing:99">
 <semantics>
  <mrow>
   <mn>2</mn>
   <mrow>
    <mo stretchy="false">âŒˆ</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">âŒ‰</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <cn type="integer">2</cn>
    <apply>
     <ceiling></ceiling>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2\lceil\log{n}\rceil
  </annotation>
 </semantics>
</math>

 time or if the first query is performed on the whole set, it will take 

<math display="inline" id="Group_testing:100">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">âŒˆ</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">âŒ‰</mo>
   </mrow>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <ceiling></ceiling>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lceil\log{n}\rceil+1
  </annotation>
 </semantics>
</math>

. Once a 

<math display="inline" id="Group_testing:101">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1
  </annotation>
 </semantics>
</math>

 is found, the search is then repeated after removing the 

<math display="inline" id="Group_testing:102">
 <semantics>
  <msup>
   <mi>i</mi>
   <mrow>
    <mi>t</mi>
    <mi>h</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>i</ci>
    <apply>
     <times></times>
     <ci>t</ci>
     <ci>h</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i^{th}
  </annotation>
 </semantics>
</math>

 co-ordinate. This can be done at most 

<math display="inline" id="Group_testing:103">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

 times. This justifies the running time of 

<math display="inline" id="Group_testing:104">
 <semantics>
  <mrow>
   <mi>O</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mi>log</mi>
      <mi>n</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>O</ci>
    <apply>
     <times></times>
     <ci>d</ci>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   O(d\log{n})
  </annotation>
 </semantics>
</math>

. For a full proof and an algorithm for the problem refer to: <a href="http://www.cse.buffalo.edu/~atri/courses/coding-theory/spr10/lectures/lect11.pdf">CSE545 at the University at Buffalo</a></p>
<h4 id="upper-bound-on-t1n">Upper bound on 

<math display="inline" id="Group_testing:105">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <interval closure="open">
     <cn type="integer">1</cn>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(1,n)
  </annotation>
 </semantics>
</math>

</h4>

<p>

<math display="inline" id="Group_testing:106">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â‰¤</mo>
   <mrow>
    <mo stretchy="false">âŒˆ</mo>
    <mrow>
     <mi>log</mi>
     <mi>n</mi>
    </mrow>
    <mo stretchy="false">âŒ‰</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>t</ci>
     <interval closure="open">
      <cn type="integer">1</cn>
      <ci>n</ci>
     </interval>
    </apply>
    <apply>
     <ceiling></ceiling>
     <apply>
      <log></log>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(1,n)\leq\lceil\log{n}\rceil
  </annotation>
 </semantics>
</math>

 This upper bound is for the special case where 

<math display="inline" id="Group_testing:107">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>d</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=1
  </annotation>
 </semantics>
</math>

 i.e. there is a maximum of 1 positive. In this case, the matrix multiplication gets simplified and the resultant 

<math display="inline" id="Group_testing:108">
 <semantics>
  <mi>ğ«</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ«</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{r}
  </annotation>
 </semantics>
</math>

 represents the binary representation of 

<math display="inline" id="Group_testing:109">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 for test 

<math display="inline" id="Group_testing:110">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

. This gives a lower bound of 

<math display="inline" id="Group_testing:111">
 <semantics>
  <mrow>
   <mo stretchy="false">âŒˆ</mo>
   <mrow>
    <mi>log</mi>
    <mi>n</mi>
   </mrow>
   <mo stretchy="false">âŒ‰</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ceiling></ceiling>
    <apply>
     <log></log>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lceil\log{n}\rceil
  </annotation>
 </semantics>
</math>

. Note that decoding becomes trivial because the binary representation of 

<math display="inline" id="Group_testing:112">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 gives us the location directly. The group test matrix here is just the parity check matrix 

<math display="inline" id="Group_testing:113">
 <semantics>
  <msub>
   <mi>H</mi>
   <mi>m</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>H</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H_{m}
  </annotation>
 </semantics>
</math>

 for the 

<math display="inline" id="Group_testing:114">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <mi>m</mi>
    </msup>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mrow>
    <msup>
     <mn>2</mn>
     <mi>m</mi>
    </msup>
    <mo>-</mo>
    <mi>m</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
   <mo>,</mo>
   <mn>3</mn>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>m</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cn type="integer">2</cn>
      <ci>m</ci>
     </apply>
     <ci>m</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">3</cn>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [2^{m}-1,2^{m}-m-1,3]
  </annotation>
 </semantics>
</math>

 <a href="Hamming_code" title="wikilink">Hamming code</a>.</p>

<p>Thus as the upper and lower bounds are the same, we have a tight bound for 

<math display="inline" id="Group_testing:115">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>d</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <interval closure="open">
     <ci>d</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(d,n)
  </annotation>
 </semantics>
</math>

 when 

<math display="inline" id="Group_testing:116">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>d</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d=1
  </annotation>
 </semantics>
</math>

. Such tight bounds are not known for general 

<math display="inline" id="Group_testing:117">
 <semantics>
  <mi>d</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>d</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d
  </annotation>
 </semantics>
</math>

.</p>
<h4 id="upper-bounds-for-non-adaptive-group-testing">Upper Bounds for Non-Adaptive Group Testing</h4>

<p>For non-adaptive group testing upper bounds we shift focus toward <a href="disjunct_matrix" title="wikilink">disjunct matrices</a>. Disjunct matrices have been used for many of the bounds because of their nice properties. Through use of different constructions of disjunct matrices it has been shown that 

<math display="inline" id="Group_testing:118">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Î©</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mfrac>
       <msup>
        <mi>d</mi>
        <mn>2</mn>
       </msup>
       <mrow>
        <mi>log</mi>
        <mi>d</mi>
       </mrow>
      </mfrac>
      <mrow>
       <mi>log</mi>
       <mi>n</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â‰¤</mo>
   <mrow>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>d</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>normal-Î©</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>d</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <log></log>
        <ci>d</ci>
       </apply>
      </apply>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>t</ci>
     <interval closure="open">
      <ci>d</ci>
      <ci>n</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Omega(\frac{d^{2}}{\log{d}}\log{n})\leq t(d,n)
  </annotation>
 </semantics>
</math>

. Also for upper bounds we currently have that (i) 

<math display="inline" id="Group_testing:119">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>d</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â‰¤</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ğ’ª</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>d</mi>
       <mn>2</mn>
      </msup>
      <mrow>
       <mi>log</mi>
       <mi>n</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>t</ci>
     <interval closure="open">
      <ci>d</ci>
      <ci>n</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>ğ’ª</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>d</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <log></log>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(d,n)\leq\mathcal{O}(d^{2}\log{n})
  </annotation>
 </semantics>
</math>

(explicit construction) and (ii) 

<math display="inline" id="Group_testing:120">
 <semantics>
  <mrow>
   <mrow>
    <mi>t</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>d</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>â‰¤</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ğ’ª</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>d</mi>
       <mn>2</mn>
      </msup>
      <mrow>
       <msup>
        <mi>log</mi>
        <mn>2</mn>
       </msup>
       <mi>n</mi>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>t</ci>
     <interval closure="open">
      <ci>d</ci>
      <ci>n</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>ğ’ª</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>d</ci>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <log></log>
        <cn type="integer">2</cn>
       </apply>
       <ci>n</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(d,n)\leq\mathcal{O}(d^{2}\log^{2}{n})
  </annotation>
 </semantics>
</math>

(strongly explicit construction). It is good to note that the current known lower bound for 

<math display="inline" id="Group_testing:121">
 <semantics>
  <mrow>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>d</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>t</ci>
    <interval closure="open">
     <ci>d</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t(d,n)
  </annotation>
 </semantics>
</math>

 is already a 

<math display="inline" id="Group_testing:122">
 <semantics>
  <mfrac>
   <mi>d</mi>
   <mrow>
    <mi>log</mi>
    <mi>d</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>d</ci>
    <apply>
     <log></log>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{d}{\log{d}}
  </annotation>
 </semantics>
</math>

 factor larger than the upper bound for 

<math display="inline" id="Group_testing:123">
 <semantics>
  <mrow>
   <msup>
    <mi>t</mi>
    <mi>a</mi>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>d</mi>
    <mo>,</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>t</ci>
     <ci>a</ci>
    </apply>
    <interval closure="open">
     <ci>d</ci>
     <ci>n</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t^{a}(d,n)
  </annotation>
 </semantics>
</math>

. Another thing to note is that give the smallest upper bound and biggest lower bound they are only off by a factor of 

<math display="inline" id="Group_testing:124">
 <semantics>
  <mfrac>
   <mn>1</mn>
   <mrow>
    <mi>log</mi>
    <mi>d</mi>
   </mrow>
  </mfrac>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <log></log>
     <ci>d</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{\log{d}}
  </annotation>
 </semantics>
</math>

 which is fairly small.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Disjunct_Matrix" title="wikilink">Disjunct Matrix</a></li>
<li><a href="Robert_Dorfman" title="wikilink">Robert Dorfman</a></li>
<li><a href="Concatenated_error_correction_codes" title="wikilink">Concatenated error correction codes</a></li>
<li><a href="Hamming_weight" title="wikilink">Hamming weight</a></li>
<li><a href="Hamming_code" title="wikilink">Hamming code</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>Atri Rudra's course on Error Correcting Codes: Combinatorics, Algorithms, and Applications (Spring 2007), Lectures <a href="http://www.cse.buffalo.edu/~atri/courses/coding-theory/lectures/lect7.pdf">7</a>.</li>
<li>Atri Rudra's course on Error Correcting Codes: Combinatorics, Algorithms, and Applications (Spring 2010), Lectures <a href="http://www.cse.buffalo.edu/~atri/courses/coding-theory/spr10/lectures/lect10.pdf">10</a>, <a href="http://www.cse.buffalo.edu/~atri/courses/coding-theory/spr10/lectures/lect11.pdf">11</a>, <a href="http://www.cse.buffalo.edu/~atri/courses/coding-theory/spr10/lectures/lect28.pdf">28</a>, <a href="http://www.cse.buffalo.edu/~atri/courses/coding-theory/spr10/lectures/lect29.pdf">29</a></li>
<li></li>
<li>Dorfman, R. The Detection of Defective Members of Large Populations. The Annals of Mathematical Statistics, 14(4), 436-440. Retrieved from <a href="http://www.jstor.org/pss/2235930">1</a></li>
<li>Du, D., &amp; Hwang, F. (2006). Pooling Designs and Nonadaptive Group Testing. Boston: Twayne Publishers.</li>
<li>Ely Porat, Amir Rothschild: Explicit Non-adaptive Combinatorial Group Testing Schemes. ICALP (1) 2008: 748-759</li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Combinatorics" title="wikilink">Category:Combinatorics</a> <a href="Category:Design_of_experiments" title="wikilink">Category:Design of experiments</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">A bit more precisely â€“ if there are an odd number of coins to be weighed, pick one to put aside and divide the rest into two equal piles. If the two piles have equal weight, the bad coin is the one put aside, otherwise the one put aside was good and no longer has to be tested.<a href="#fnref1">â†©</a></li>
<li id="fn2"><a href="#fnref2">â†©</a></li>
<li id="fn3"><a href="#fnref3">â†©</a></li>
</ol>
</section>
</body>
</html>
