<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1399">Quantum complex network</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Quantum complex network</h1>
<hr/>

<p>Being part of <a href="network_science" title="wikilink">network science</a> the study of quantum complex networks aims to explore the impact of complex network architectures in quantum communications.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> According to <a href="quantum_information_theory" title="wikilink">quantum information theory</a> it is possible to improve communication security and data transfer rates by taking advantage of <a href="quantum_mechanics" title="wikilink">quantum mechanics</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> In this context the study of quantum complex networks is motivated by the possibility of quantum communications being used on a massive scale in the future.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> In such case it is likely that quantum communication networks will acquire non trivial features as its common in the exiting communication networks today.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p>__TOC__</p>
<h2 id="motivation">Motivation</h2>

<p>It is theoretical possible to take an advantage of <a href="quantum_mechanics" title="wikilink">quantum mechanics</a> to create secure and faster communications, namely, <a href="quantum_key_distribution" title="wikilink">quantum key distribution</a> is an application of <a href="quantum_cryptography" title="wikilink">quantum cryptography</a> that allows for theoretical completely <a href="secure_communications" title="wikilink">secure communications</a>,<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> and quantum teleportation that can be used to transfer data at higher rate than using only classic channels.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>The successful <a href="quantum_teleportation" title="wikilink">quantum teleportation</a> experiments in 1998<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> followed by the development of first quantum communication networks in 2004,<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> opened the possibility of quantum communication being used in a large scale in the future. According to findings in <a href="network_science" title="wikilink">network science</a> the topology of the networks is, in most cases, extremely important, and the exiting large scale <a href="communication_networks" title="wikilink">communication networks</a> today tend to have non-trivial topologies and traits, like <a href="small_world_effect" title="wikilink">small world effect</a>, <a href="community_structure" title="wikilink">community structure</a> and <a href="Scale_free_network" title="wikilink">scale free</a> proprieties.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> The Study the of networks with quantum proprieties and complex network topologies, can help us not only to better understand such networks but also how to use the network topology to improve the efficience of communication networks in the future.</p>
<h2 id="important-concepts">Important concepts</h2>
<h3 id="qubits">Qubits</h3>

<p>In quantum information <a href="Qubit" title="wikilink">Qubits</a> are the equivalent to <a href="bit" title="wikilink">bits</a> in classical systems. A <a href="Qubit" title="wikilink">quibt</a> is quantum objects with only two states that is used to transmit information.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> The polarization of a photon or the nuclear spin are examples of two state systems that can be used as qubits.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h3 id="entanglement">Entanglement</h3>

<p><a href="Quantum_entanglement" title="wikilink">Quantum entanglement</a> is a physical phenomenon characterized by a correlation between the quantum states of two or more particles.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> While entangled particle do not interact in the classical sense, the quantum state of those particle can not be described independently. Particles can be entangle in different degrees, and the maximally entangled state are the ones the maximize the <a href="entropy_of_entanglement" title="wikilink">entropy of entanglement</a>.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> In the context of quantum communication, quantum entanglement qubits are used as a <a href="quantum_channel" title="wikilink">quantum channel</a> capable of transmitting information when combined with a <a href="Classical_information_channel" title="wikilink">classical chanel</a>.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>
<h3 id="bell-measurement">Bell measurement</h3>

<p><a href="Bell_measurement" title="wikilink">Bell measurement</a> is joint quantum-mechanical measurement of two qubits, so that after the measurement the two qubits will be maixmailly entangle.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a><a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>
<h3 id="entanglement-swapping">Entanglement swapping</h3>

<p> <a href="Entanglement_swapping" title="wikilink">Entanglement swapping</a> is a frequent strategy used in quantum networks that allows the connections in the network to change.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a><a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> Lets us suppose that we have 4 qubits, A B C and D, C and D belong to the same station, while A and C are belong to two different stations. Qubit A is entangled with qubit C and qubit B is entangled with qubit D. By performing a <a href="bell_measurement" title="wikilink">bell measurement</a> in qubits A and B, not only the qubits A and B will be entangled but it is also possible to create an entanglement state between qubit C and qubit D, despite the fact that there was never an interactions between them. Following this process the entanglement between qubits A and C, and qubits B and D will be lost. This strategy can be use to shape the connection on the network.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a><a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a><a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>
<h2 id="network-structure">Network structure</h2>

<p>While not all models for quantum complex network follow exactly the same structure, usually nodes represent a set of qubits in the same station were operation like <a href="bell_state" title="wikilink">bell measurements</a> and <a href="entanglement_swapping" title="wikilink">entanglement swapping</a> can be applied. In the other hand, a link between a node 

<math display="inline" id="Quantum_complex_network:0">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quantum_complex_network:1">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 means that a qubit in node 

<math display="inline" id="Quantum_complex_network:2">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 is entangled to a quibit in node 

<math display="inline" id="Quantum_complex_network:3">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>


, but those two qubits are in different places, thus physical interactions between them are not possible.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a><a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></p>
<h3 id="notation">Notation</h3>

<p>Each node in the network is composed by a set of qubits that can be in different states. The most convenient representation for the quantum state of the qubits is the <a href="dirac_notation" title="wikilink">dirac notation</a> and represent the two state of the qubits as 

<math display="inline" id="Quantum_complex_network:4">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mn>0</mn>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |0\rangle
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quantum_complex_network:5">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mn>1</mn>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |1\rangle
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a><a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> Two particle are entangled if the joint wave function, 

<math display="inline" id="Quantum_complex_network:6">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <msub>
    <mi>ψ</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ψ</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi_{ij}\rangle
  </annotation>
 </semantics>
</math>

, can not be decomposed as,<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a><a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a></p>

<p>

<math display="block" id="Quantum_complex_network:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <msub>
      <mi>ψ</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mi>ϕ</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mi>i</mi>
     </msub>
     <mo>⊗</mo>
     <msub>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mi>ϕ</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mi>j</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ψ</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <ci>ϕ</ci>
      </apply>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <ci>ϕ</ci>
      </apply>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi_{ij}\rangle=|\phi\rangle_{i}\otimes|\phi\rangle_{j},
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Quantum_complex_network:8">
 <semantics>
  <msub>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>ϕ</ci>
    </apply>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\phi\rangle_{i}
  </annotation>
 </semantics>
</math>


 represents the quantum state of the qubit at node i and 

<math display="inline" id="Quantum_complex_network:9">
 <semantics>
  <msub>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>ϕ</ci>
    </apply>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\phi\rangle_{j}
  </annotation>
 </semantics>
</math>

 represents the quantum state of the qubit at node j. Another important concept is maximally entangled states. For the four states that maximize the <a href="entropy_of_entanglement" title="wikilink">entropy of entanglement</a> can be written as<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a><a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a></p>

<p>

<math display="block" id="Quantum_complex_network:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <msubsup>
      <mi mathvariant="normal">Φ</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
      <mo>+</mo>
     </msubsup>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <msqrt>
       <mn>2</mn>
      </msqrt>
     </mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msub>
         <mrow>
          <mo fence="true" stretchy="false">|</mo>
          <mn>0</mn>
          <mo stretchy="false">⟩</mo>
         </mrow>
         <mi>i</mi>
        </msub>
        <mo>⊗</mo>
        <msub>
         <mrow>
          <mo fence="true" stretchy="false">|</mo>
          <mn>0</mn>
          <mo stretchy="false">⟩</mo>
         </mrow>
         <mi>j</mi>
        </msub>
       </mrow>
       <mo>+</mo>
       <mrow>
        <msub>
         <mrow>
          <mo fence="true" stretchy="false">|</mo>
          <mn>1</mn>
          <mo stretchy="false">⟩</mo>
         </mrow>
         <mi>i</mi>
        </msub>
        <mo>⊗</mo>
        <msub>
         <mrow>
          <mo fence="true" stretchy="false">|</mo>
          <mn>1</mn>
          <mo stretchy="false">⟩</mo>
         </mrow>
         <mi>j</mi>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Φ</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <plus></plus>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">0</cn>
        </apply>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">0</cn>
        </apply>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">1</cn>
        </apply>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">1</cn>
        </apply>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\Phi_{ij}^{+}\rangle=\frac{1}{\sqrt{2}}(|0\rangle_{i}\otimes|0\rangle_{j}+|1%
\rangle_{i}\otimes|1\rangle_{j}),
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Quantum_complex_network:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <msubsup>
      <mi mathvariant="normal">Φ</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
      <mo>-</mo>
     </msubsup>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <msqrt>
       <mn>2</mn>
      </msqrt>
     </mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msub>
         <mrow>
          <mo fence="true" stretchy="false">|</mo>
          <mn>0</mn>
          <mo stretchy="false">⟩</mo>
         </mrow>
         <mi>i</mi>
        </msub>
        <mo>⊗</mo>
        <msub>
         <mrow>
          <mo fence="true" stretchy="false">|</mo>
          <mn>0</mn>
          <mo stretchy="false">⟩</mo>
         </mrow>
         <mi>j</mi>
        </msub>
       </mrow>
       <mo>-</mo>
       <mrow>
        <msub>
         <mrow>
          <mo fence="true" stretchy="false">|</mo>
          <mn>1</mn>
          <mo stretchy="false">⟩</mo>
         </mrow>
         <mi>i</mi>
        </msub>
        <mo>⊗</mo>
        <msub>
         <mrow>
          <mo fence="true" stretchy="false">|</mo>
          <mn>1</mn>
          <mo stretchy="false">⟩</mo>
         </mrow>
         <mi>j</mi>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Φ</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <minus></minus>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">0</cn>
        </apply>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">0</cn>
        </apply>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">1</cn>
        </apply>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">1</cn>
        </apply>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\Phi_{ij}^{-}\rangle=\frac{1}{\sqrt{2}}(|0\rangle_{i}\otimes|0\rangle_{j}-|1%
\rangle_{i}\otimes|1\rangle_{j}),
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Quantum_complex_network:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <msubsup>
      <mi mathvariant="normal">Ψ</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
      <mo>+</mo>
     </msubsup>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <msqrt>
       <mn>2</mn>
      </msqrt>
     </mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msub>
         <mrow>
          <mo fence="true" stretchy="false">|</mo>
          <mn>0</mn>
          <mo stretchy="false">⟩</mo>
         </mrow>
         <mi>i</mi>
        </msub>
        <mo>⊗</mo>
        <msub>
         <mrow>
          <mo fence="true" stretchy="false">|</mo>
          <mn>1</mn>
          <mo stretchy="false">⟩</mo>
         </mrow>
         <mi>j</mi>
        </msub>
       </mrow>
       <mo>+</mo>
       <mrow>
        <msub>
         <mrow>
          <mo fence="true" stretchy="false">|</mo>
          <mn>1</mn>
          <mo stretchy="false">⟩</mo>
         </mrow>
         <mi>i</mi>
        </msub>
        <mo>⊗</mo>
        <msub>
         <mrow>
          <mo fence="true" stretchy="false">|</mo>
          <mn>0</mn>
          <mo stretchy="false">⟩</mo>
         </mrow>
         <mi>j</mi>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Ψ</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <plus></plus>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">0</cn>
        </apply>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">1</cn>
        </apply>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">1</cn>
        </apply>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">0</cn>
        </apply>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\Psi_{ij}^{+}\rangle=\frac{1}{\sqrt{2}}(|0\rangle_{i}\otimes|1\rangle_{j}+|1%
\rangle_{i}\otimes|0\rangle_{j}),
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Quantum_complex_network:13">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <msubsup>
      <mi mathvariant="normal">Ψ</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
      <mo>-</mo>
     </msubsup>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <msqrt>
       <mn>2</mn>
      </msqrt>
     </mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msub>
         <mrow>
          <mo fence="true" stretchy="false">|</mo>
          <mn>0</mn>
          <mo stretchy="false">⟩</mo>
         </mrow>
         <mi>i</mi>
        </msub>
        <mo>⊗</mo>
        <msub>
         <mrow>
          <mo fence="true" stretchy="false">|</mo>
          <mn>1</mn>
          <mo stretchy="false">⟩</mo>
         </mrow>
         <mi>j</mi>
        </msub>
       </mrow>
       <mo>-</mo>
       <mrow>
        <msub>
         <mrow>
          <mo fence="true" stretchy="false">|</mo>
          <mn>1</mn>
          <mo stretchy="false">⟩</mo>
         </mrow>
         <mi>i</mi>
        </msub>
        <mo>⊗</mo>
        <msub>
         <mrow>
          <mo fence="true" stretchy="false">|</mo>
          <mn>0</mn>
          <mo stretchy="false">⟩</mo>
         </mrow>
         <mi>j</mi>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>normal-Ψ</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <minus></minus>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <minus></minus>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">0</cn>
        </apply>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">1</cn>
        </apply>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">1</cn>
        </apply>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">0</cn>
        </apply>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\Psi_{ij}^{-}\rangle=\frac{1}{\sqrt{2}}(|0\rangle_{i}\otimes|1\rangle_{j}-|1%
\rangle_{i}\otimes|0\rangle_{j}).
  </annotation>
 </semantics>
</math>

</p>
<h2 id="models">Models</h2>
<h3 id="quantum-random-networks">Quantum random networks</h3>

<p> The quantum random network model proposed by Perseguers et al.<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a> can be thought as a quantum version of the <a href="Erdős–Rényi_model" title="wikilink">Erdős–Rényi model</a>. Instead of the typical links used in to represent other complex networks, in the quantum random network model each pair of nodes is connected trough an pair of <a href="Quantum_entanglement" title="wikilink">entangled</a> <a class="uri" href="qubits" title="wikilink">qubits</a>. In this case each node contains

<math display="inline" id="Quantum_complex_network:14">
 <semantics>
  <mrow>
   <mi>N</mi>
   <mo>-</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>N</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N-1
  </annotation>
 </semantics>
</math>

 quibits, one for each other node. In quantum random network the degree of entanglement between two pairs of nodes represented by 

<math display="inline" id="Quantum_complex_network:15">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, plays a similar role to the parameter 

<math display="inline" id="Quantum_complex_network:16">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 in the Erdős–Rényi model. While in the Erdős–Rényi model two nodes form a connection with probability 

<math display="inline" id="Quantum_complex_network:17">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, in the context of quantum random networks 

<math display="inline" id="Quantum_complex_network:18">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>


 means the probability of an entangled pair of qubits being successful converted to a maximally entangled state using only local operations and classical communications, called <a href="http://www.quantiki.org/wiki/LOCC_operations">LOCC operations</a>.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> We can think of maximally entangled qubits as the true links between nodes.</p>

<p>Using the notation introduced previously, we can represent a pair of entangle qubits connecting the nodes 

<math display="inline" id="Quantum_complex_network:19">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quantum_complex_network:20">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

, as</p>

<p>

<math display="block" id="Quantum_complex_network:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <msub>
      <mi>ψ</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mrow>
       <msqrt>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mrow>
          <mi>p</mi>
          <mo>/</mo>
          <mn>2</mn>
         </mrow>
        </mrow>
       </msqrt>
       <msub>
        <mrow>
         <mo fence="true" stretchy="false">|</mo>
         <mn>0</mn>
         <mo stretchy="false">⟩</mo>
        </mrow>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo>⊗</mo>
      <msub>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>0</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mi>j</mi>
      </msub>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mrow>
       <msqrt>
        <mrow>
         <mi>p</mi>
         <mo>/</mo>
         <mn>2</mn>
        </mrow>
       </msqrt>
       <msub>
        <mrow>
         <mo fence="true" stretchy="false">|</mo>
         <mn>1</mn>
         <mo stretchy="false">⟩</mo>
        </mrow>
        <mi>i</mi>
       </msub>
      </mrow>
      <mo>⊗</mo>
      <msub>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>1</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mi>j</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ψ</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <times></times>
       <apply>
        <root></root>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <apply>
          <divide></divide>
          <ci>p</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">0</cn>
        </apply>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <cn type="integer">0</cn>
       </apply>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">tensor-product</csymbol>
      <apply>
       <times></times>
       <apply>
        <root></root>
        <apply>
         <divide></divide>
         <ci>p</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">1</cn>
        </apply>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <cn type="integer">1</cn>
       </apply>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi_{ij}\rangle=\sqrt{1-p/2}|0\rangle_{i}\otimes|0\rangle_{j}+\sqrt{p/2}|1%
\rangle_{i}\otimes|1\rangle_{j},
  </annotation>
 </semantics>
</math>

 For 

<math display="inline" id="Quantum_complex_network:22">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>p</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p=0
  </annotation>
 </semantics>
</math>

 the two qubits are not entangled,</p>

<p>

<math display="block" id="Quantum_complex_network:23">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <msub>
      <mi>ψ</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msub>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>0</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mi>i</mi>
     </msub>
     <mo>⊗</mo>
     <msub>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>0</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mi>j</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ψ</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">tensor-product</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">0</cn>
      </apply>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">0</cn>
      </apply>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi_{ij}\rangle=|0\rangle_{i}\otimes|0\rangle_{j},
  </annotation>
 </semantics>
</math>

 and for 

<math display="inline" id="Quantum_complex_network:24">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>p</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p=1
  </annotation>
 </semantics>
</math>

 we obtain the maximally entangled state, given by</p>

<p>

<math display="block" id="Quantum_complex_network:25">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi>ψ</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msqrt>
     <mrow>
      <mn>1</mn>
      <mo>/</mo>
      <mn>2</mn>
     </mrow>
    </msqrt>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mrow>
         <mo fence="true" stretchy="false">|</mo>
         <mn>0</mn>
         <mo stretchy="false">⟩</mo>
        </mrow>
        <mi>i</mi>
       </msub>
       <mo>⊗</mo>
       <msub>
        <mrow>
         <mo fence="true" stretchy="false">|</mo>
         <mn>0</mn>
         <mo stretchy="false">⟩</mo>
        </mrow>
        <mi>j</mi>
       </msub>
      </mrow>
      <mo>+</mo>
      <mrow>
       <msub>
        <mrow>
         <mo fence="true" stretchy="false">|</mo>
         <mn>1</mn>
         <mo stretchy="false">⟩</mo>
        </mrow>
        <mi>i</mi>
       </msub>
       <mo>⊗</mo>
       <msub>
        <mrow>
         <mo fence="true" stretchy="false">|</mo>
         <mn>1</mn>
         <mo stretchy="false">⟩</mo>
        </mrow>
        <mi>j</mi>
       </msub>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ψ</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <root></root>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">0</cn>
        </apply>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">0</cn>
        </apply>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="latexml">tensor-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">1</cn>
        </apply>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <cn type="integer">1</cn>
        </apply>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi_{ij}\rangle=\sqrt{1/2}(|0\rangle_{i}\otimes|0\rangle_{j}+|1\rangle_{i}%
\otimes|1\rangle_{j})
  </annotation>
 </semantics>
</math>

.</p>

<p>For intermediate values of 

<math display="inline" id="Quantum_complex_network:26">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Quantum_complex_network:27">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

, successfully converted to the maximally entangled entangled state using <a href="http://www.quantiki.org/wiki/LOCC_operations">LOCC operations</a>.<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a></p>

<p>One of the main features that distinguish this model from its classic version is the fact the in quantum random networks links are only truly established after measurements in the networks being made, and It is possible to take advantage of this fact to shape final shape of the network. Considering an initial quantum complex network with an infinity number of nodes, Perseguers et al.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> showed that, by doing the right measurements and <a href="entanglement_swapping" title="wikilink">entanglement swapping</a>, it is possible to collapsed the initial network to a network containing any finite subgraph, provided that 

<math display="inline" id="Quantum_complex_network:28">
 <semantics>
  <mi>N</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>N</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   N
  </annotation>
 </semantics>
</math>


 scales with 

<math display="block" id="Quantum_complex_network:29">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mo>∼</mo>
    <msup>
     <mi>N</mi>
     <mi>Z</mi>
    </msup>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">similar-to</csymbol>
    <ci>p</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>N</ci>
     <ci>Z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\sim N^{Z},
  </annotation>
 </semantics>
</math>

 as,</p>

<p>

<math display="inline" id="Quantum_complex_network:30">
 <semantics>
  <mrow>
   <mi>Z</mi>
   <mo>≥</mo>
   <mrow>
    <mo>-</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>Z</ci>
    <apply>
     <minus></minus>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Z\geq-2
  </annotation>
 </semantics>
</math>

</p>

<p>were 

<math display="inline" id="Quantum_complex_network:31">
 <semantics>
  <mi>z</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>z</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   z
  </annotation>
 </semantics>
</math>

. This results is contrary to what we find in classic graph theory were the type of subgraphs contained in a network is bounded by the value of 

<math display="inline" id="Quantum_complex_network:32">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a></p>
<h3 id="entanglement-percolation">Entanglement Percolation</h3>

<p>The goal of entanglement percolation models is to determine if a quantum network is capable of establishing a connection between two arbitrary nodes trough entanglement, and to find best the strategies to create those same connections.<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a><a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> In a model proposed by Cirac et al.<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a> and applied to complex networks by Cuquet et al.,<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> nodes ares distributed in a lattice,<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a> or in a complex network,<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a> and each pair of neighbors share two pairs of entangled qubits that can be converted to a maximally entangle qubit pair with probability 

<math display="inline" id="Quantum_complex_network:33">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>


. We can think of maximally entangled qubits as the true links between nodes. According to classic <a href="percolation_theory" title="wikilink">percolation theory</a>, considering a probability 

<math display="inline" id="Quantum_complex_network:34">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p
  </annotation>
 </semantics>
</math>

 of two neighbors being connected, there is a critical 

<math display="inline" id="Quantum_complex_network:35">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>c</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{c}
  </annotation>
 </semantics>
</math>

 designed by 

<math display="inline" id="Quantum_complex_network:36">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>></mo>
   <msub>
    <mi>p</mi>
    <mi>c</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <ci>p</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>p</ci>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p>p_{c}
  </annotation>
 </semantics>
</math>

, so that if 

<math display="inline" id="Quantum_complex_network:37">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>c</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{c}
  </annotation>
 </semantics>
</math>

 there is a finite probability of existing a path between two random selected node, and for 

<math display="inline" id="Quantum_complex_network:38">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>c</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{c}
  </annotation>
 </semantics>
</math>


 depends only on the topology of the network.<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a> A similar phenomena was found in the model proposed by Cirac et al.,<a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a> where the probability of a forming a maximally entangled state between two random selected nodes is zero if 

<math display="inline" id="Quantum_complex_network:39">
 <semantics>
  <msub>
   <mi>p</mi>
   <mi>c</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>p</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p_{c}
  </annotation>
 </semantics>
</math>

. The main difference between classic and entangled percolation is that in quantum networks it is possible to change the links in the network, in a way changing the effective topology of the network, as a consequence <span class="LaTeX">$p_c$</span> will depend on the strategy used to convert partial entangle qubits to maximally connected qubits.<a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a><a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a> A naive approach yields that <span class="LaTeX">$p_c$</span> for a quantum network is equal to <span class="LaTeX">$p_c$</span> for a classic network with the same topology.<a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a> Nevertheless, it was showed that is possible to take advantage of quantum swamping to lower that value, both in <a href="Lattice_(group)" title="wikilink">regular lattices</a><a class="footnoteRef" href="#fn51" id="fnref51"><sup>51</sup></a> and <a href="complex_networks" title="wikilink">complex networks</a>.<a class="footnoteRef" href="#fn52" id="fnref52"><sup>52</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Quantum_key_distribution" title="wikilink">Quantum key distribution</a></li>
<li><a href="Quantum_teleportation" title="wikilink">Quantum teleportation</a></li>
<li><a href="Erdős–Rényi_model" title="wikilink">Erdős–Rényi model</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Network_theory" title="wikilink">Category:Network theory</a> <a href="Category:Quantum_information_theory" title="wikilink">Category:Quantum information theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"></li>
<li id="fn14"></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"></li>
<li id="fn20"></li>
<li id="fn21"></li>
<li id="fn22"></li>
<li id="fn23"></li>
<li id="fn24"></li>
<li id="fn25"></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29"></li>
<li id="fn30"></li>
<li id="fn31"></li>
<li id="fn32"></li>
<li id="fn33"></li>
<li id="fn34"></li>
<li id="fn35"></li>
<li id="fn36"><a href="#fnref36">↩</a></li>
<li id="fn37"></li>
<li id="fn38"></li>
<li id="fn39"><a href="#fnref39">↩</a></li>
<li id="fn40"></li>
<li id="fn41"><a href="#fnref41">↩</a></li>
<li id="fn42"></li>
<li id="fn43"></li>
<li id="fn44"></li>
<li id="fn45"></li>
<li id="fn46"></li>
<li id="fn47"></li>
<li id="fn48"></li>
<li id="fn49"></li>
<li id="fn50"></li>
<li id="fn51"></li>
<li id="fn52"></li>
</ol>
</section>
</body>
</html>
