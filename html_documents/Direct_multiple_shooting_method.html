<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="492">Direct multiple shooting method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Direct multiple shooting method</h1>
<hr/>

<p>In the area of <a class="uri" href="mathematics" title="wikilink">mathematics</a> known as <a href="numerical_ordinary_differential_equations" title="wikilink">numerical ordinary differential equations</a>, the <strong>direct multiple shooting method</strong> is a <a href="numerical_method" title="wikilink">numerical method</a> for the solution of <a href="boundary_value_problem" title="wikilink">boundary value problems</a>. The method divides the interval over which a solution is sought into several smaller intervals, solves an initial value problem in each of the smaller intervals, and imposes additional matching conditions to form a solution on the whole interval. The method constitutes a significant improvement in distribution of nonlinearity and <a href="numerical_stability" title="wikilink">numerical stability</a> over single <a href="shooting_method" title="wikilink">shooting methods</a>.</p>
<h2 id="single-shooting-methods">Single shooting methods</h2>

<p>Shooting methods can be used to solve boundary value problems (BVP) like</p>

<p>

<math display="block" id="Direct_multiple_shooting_method:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msup>
       <mi>y</mi>
       <mi>′′</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <mrow>
        <mi>y</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mrow>
      <mrow>
       <mi>y</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>t</mi>
         <mi>a</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <msub>
       <mi>y</mi>
       <mi>a</mi>
      </msub>
     </mrow>
     <mo rspace="12.5pt">,</mo>
     <mrow>
      <mrow>
       <mi>y</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>t</mi>
         <mi>b</mi>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>=</mo>
      <msub>
       <mi>y</mi>
       <mi>b</mi>
      </msub>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>′′</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>t</ci>
       <apply>
        <times></times>
        <ci>y</ci>
        <ci>t</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>y</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>a</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>a</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>y</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>b</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime\prime}(t)=f(t,y(t)),\quad y(t_{a})=y_{a},\quad y(t_{b})=y_{b},
  </annotation>
 </semantics>
</math>

 in which the time points <em>t</em><sub>a</sub> and <em>t</em><sub>b</sub> are known and we seek</p>

<p>

<math display="block" id="Direct_multiple_shooting_method:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo rspace="12.5pt">,</mo>
     <mi>t</mi>
    </mrow>
    <mo>∈</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>t</mi>
      <mi>a</mi>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>t</mi>
      <mi>b</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <list>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>t</ci>
     </apply>
     <ci>t</ci>
    </list>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>b</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(t),\quad t\in(t_{a},t_{b}).
  </annotation>
 </semantics>
</math>

</p>

<p>Single shooting methods proceed as follows. Let <em>y</em>(<em>t</em>; <em>t</em><sub>0</sub>, <em>y</em><sub>0</sub>) denote the solution of the initial value problem (IVP)</p>

<p>

<math display="block" id="Direct_multiple_shooting_method:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msup>
      <mi>y</mi>
      <mo>′</mo>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>t</mi>
      <mo>,</mo>
      <mrow>
       <mi>y</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>t</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>y</mi>
      <mn>0</mn>
     </msub>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mrow>
      <msup>
       <mi>y</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mn>0</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mi>p</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>t</ci>
       <apply>
        <times></times>
        <ci>y</ci>
        <ci>t</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <ci>y</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>y</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>t</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}(t)=f(t,y(t)),\quad y(t_{0})=y_{0},y^{\prime}(t_{0})=p
  </annotation>
 </semantics>
</math>

 Define the function <em>F</em>(<em>p</em>) as the difference between <em>y</em>(<em>t</em><sub><em>b</em></sub>; <em>p</em>) and the specified boundary value <em>y</em><sub><em>b</em></sub>: <em>F</em>(<em>p</em>) = <em>y</em>(<em>t</em><sub><em>b</em></sub>; <em>p</em>) − <em>y</em><sub><em>b</em></sub>. Then for every solution (<em>y</em><sub>a</sub>, <em>y</em><sub>b</sub>) of the boundary value problem we have <em>y</em><sub>a</sub>=<em>y</em><sub>0</sub> while <em>y</em><sub>b</sub> corresponds to a <a href="root_of_a_function" title="wikilink">root</a> of <em>F</em>. This root can be solved by any <a href="root-finding_method" title="wikilink">root-finding method</a> given that certain method-dependent prerequisites are satisfied. This often will require initial guesses to <em>y</em><sub>a</sub> and <em>y</em><sub>b</sub>. Typically, analytic root finding is impossible and iterative methods such as <a href="Newton's_method" title="wikilink">Newton's method</a> are used for this task.</p>

<p>The application of single shooting for the numerical solution of boundary value problems suffers from several drawbacks.</p>
<ul>
<li>For a given initial value <em>y</em><sub>0</sub> the solution of the IVP obviously must exist on the interval [<em>t</em><sub>a</sub>,<em>t</em><sub>b</sub>] so that we can evaluate the function <em>F</em> whose root is sought.</li>
</ul>

<p>For highly nonlinear or unstable ODEs, this requires the initial guess <em>y</em><sub>0</sub> to be extremely close to an actual but unknown solution <em>y</em><sub>a</sub>. Initial values that are chosen slightly off the true solution may lead to singularities or breakdown of the ODE solver method. Choosing such solutions is inevitable in an iterative root-finding method, however.</p>
<ul>
<li>Finite precision numerics may make it impossible at all to find initial values that allow for the solution of the ODE on the whole time interval.</li>
<li>The nonlinearity of the ODE effectively becomes a nonlinearity of <em>F</em>, and requires a root-finding technique capable of solving nonlinear systems. Such methods typically converge slower as nonlinearities become more severe. The boundary value problem solver's performance suffers from this.</li>
<li>Even stable and well-conditioned ODEs may make for unstable and ill-conditioned BVPs. A slight alteration of the initial value guess <em>y</em><sub>0</sub> may generate an extremely large step in the ODEs solution <em>y</em>(<em>t</em><sub>b</sub>; <em>t</em><sub>a</sub>, <em>y</em><sub>0</sub>) and thus in the values of the function <em>F</em> whose root is sought. Non-analytic root-finding methods can seldom cope with this behaviour.</li>
</ul>
<h2 id="multiple-shooting">Multiple shooting</h2>

<p>A direct multiple shooting method partitions the interval [<em>t<sub>a</sub></em>, <em>t<sub>b</sub></em>] by introducing additional grid points</p>

<p>

<math display="block" id="Direct_multiple_shooting_method:3">
 <semantics>
  <mrow>
   <msub>
    <mi>t</mi>
    <mi>a</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>t</mi>
    <mn>0</mn>
   </msub>
   <mo><</mo>
   <msub>
    <mi>t</mi>
    <mn>1</mn>
   </msub>
   <mo><</mo>
   <mi mathvariant="normal">⋯</mi>
   <mo><</mo>
   <msub>
    <mi>t</mi>
    <mi>N</mi>
   </msub>
   <mo>=</mo>
   <msub>
    <mi>t</mi>
    <mi>b</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>N</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>t</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   t_{a}=t_{0}<t_{1}<\cdots<t_{N}=t_{b}
  </annotation>
 </semantics>
</math>

. The method starts by guessing somehow the values of <em>y</em> at all grid points <em>t<sub>k</sub></em> with 0 ≤ <em>k</em> ≤ <em>N</em> − 1. Denote these guesses by <em>y<sub>k</sub></em>. Let <em>y</em>(<em>t</em>; <em>t<sub>k</sub></em>, <em>y<sub>k</sub></em>) denote the solution emanating from the <em>k</em>th grid point, that is, the solution of the initial value problem</p>

<p>

<math display="block" id="Direct_multiple_shooting_method:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msup>
       <mi>y</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>t</mi>
       <mo>,</mo>
       <mrow>
        <mi>y</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>t</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo rspace="12.5pt">,</mo>
    <mrow>
     <mrow>
      <mi>y</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>t</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <msub>
      <mi>y</mi>
      <mi>k</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>t</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>t</ci>
       <apply>
        <times></times>
        <ci>y</ci>
        <ci>t</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>y</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y^{\prime}(t)=f(t,y(t)),\quad y(t_{k})=y_{k}.
  </annotation>
 </semantics>
</math>

 All these solutions can be pieced together to form a continuous trajectory if the values <em>y</em> match at the grid points. Thus, solutions of the boundary value problem correspond to solutions of the following system of <em>N</em> equations:</p>

<p>

<math display="inline" id="Direct_multiple_shooting_method:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>t</mi>
      <mn>1</mn>
     </msub>
     <mo>;</mo>
     <msub>
      <mi>t</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>y</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msub>
    <mi>y</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>t</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">0</cn>
      </apply>
     </list>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle y(t_{1};t_{0},y_{0})=y_{1}
  </annotation>
 </semantics>
</math>


 The central <em>N</em>−2 equations are the matching conditions, and the first and last equations are the conditions <em>y</em>(<em>t</em><sub>a</sub>) = <em>y</em><sub>a</sub> and <em>y</em>(<em>t</em><sub>b</sub>) = <em>y</em><sub>b</sub> from the boundary value problem. The multiple shooting method solves the boundary value problem by solving this system of equations. Typically, a modification of the <a href="Newton's_method" title="wikilink">Newton's method</a> is used for the latter task.</p>
<h2 id="references">References</h2>
<ul>
<li>

<p>. See Sections 7.3.5 and further.</p></li>
<li></li>
</ul>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_differential_equations" title="wikilink">Category:Numerical differential equations</a></p>
</body>
</html>
