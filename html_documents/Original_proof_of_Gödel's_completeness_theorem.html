<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="457">Original proof of Gödel's completeness theorem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Original proof of Gödel's completeness theorem</h1>
<hr/>

<p>The proof of <a href="Gödel's_completeness_theorem" title="wikilink">Gödel's completeness theorem</a> given by <a href="Kurt_Gödel" title="wikilink">Kurt Gödel</a> in his doctoral dissertation of 1929 (and a rewritten version of the dissertation, published as an article in 1930) is not easy to read today; it uses concepts and formalism that are no longer used and terminology that is often obscure. The version given below attempts to represent all the steps in the proof and all the important ideas faithfully, while restating the proof in the modern language of <a href="mathematical_logic" title="wikilink">mathematical logic</a>. This outline should not be considered a rigorous proof of the theorem.</p>
<h2 id="definitions-and-assumptions">Definitions and assumptions</h2>

<p>We work with <a href="first-order_predicate_calculus" title="wikilink">first-order predicate calculus</a>. Our languages allow constant, function and relation symbols. Structures consist of (non-empty) domains and interpretations of the relevant symbols as constant members, functions or relations over that domain.</p>

<p>We fix some axiomatization of the predicate calculus: logical axioms and rules of inference. Any of the several well-known axiomatisations will do; we assume without proof all the basic well-known results about our formalism (such as the <a href="normal_form_theorem" title="wikilink">normal form theorem</a> or the <a href="soundness_theorem" title="wikilink">soundness theorem</a>) that we need.</p>

<p>We axiomatize predicate calculus <em>without equality</em>, i.e. there are no special axioms expressing the properties of equality as a special relation symbol. After the basic form of the theorem is proved, it will be easy to extend it to the case of predicate calculus <em>with equality</em>.</p>
<h2 id="statement-of-the-theorem-and-its-proof">Statement of the theorem and its proof</h2>

<p>In the following, we state two equivalent forms of the theorem, and show their equivalence.</p>

<p>Later, we prove the theorem. This is done in the following steps:</p>
<ol>
<li>Reducing the theorem to sentences (formulas with no free variables) in <a href="prenex_form" title="wikilink">prenex form</a>, i.e. with all <a href="Quantifier_(logic)" title="wikilink">quantifiers</a> (

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:0">
 <semantics>
  <mi mathvariant="normal">∀</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-∀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ∀
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:1">
 <semantics>
  <mi mathvariant="normal">∃</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-∃</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ∃
  </annotation>
 </semantics>
</math>

) at the beginning. Furthermore, we reduce it to formulas whose first quantifier is 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:2">
 <semantics>
  <mi mathvariant="normal">∀</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-∀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ∀
  </annotation>
 </semantics>
</math>

. This is possible because for every sentence, there is an equivalent one in prenex form whose first quantifier is 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:3">
 <semantics>
  <mi mathvariant="normal">∀</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-∀</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ∀
  </annotation>
 </semantics>
</math>

.</li>
<li>Reducing the theorem to sentences of the form <mtpl></mtpl>. While we cannot do this by simply rearranging the quantifiers, we show that it is yet enough to prove the theorem for sentences of that form.</li>
<li>Finally we prove the theorem for sentences of that form.
<ul>
<li>This is done by first noting that a sentence such as <mtpl> ∃<var>x<sub>1</sub></var>∃<var>x<sub>2</sub></var>...∃<var>x<sub>k</sub></var> ∃<var>y<sub>1</sub></var>∃<var>y<sub>2</sub></var>...∃<var>y<sub>m</sub></var> φ(<var>x<sub>1</sub></var>...<var>x<sub>k</sub></var>, <var>y<sub>1</sub></var>...<var>y<sub>m</sub></var>) }}</mtpl> is either refutable or has some model in which it holds; this model is simply assigning <a href="truth_value" title="wikilink">truth values</a> to the subpropositions from which B is built. The reason for that is the completeness of <a href="propositional_logic" title="wikilink">propositional logic</a>, with the existential quantifiers playing no role.</li>
<li>We extend this result to more and more complex and lengthy sentences, D<sub>n</sub> (n=1,2...), built out from B, so that either any of them is refutable and therefore so is φ, or all of them are not refutable and therefore each holds in some model.</li>
<li>We finally use the models in which the D<sub>n</sub> hold (in case all are not refutable) in order to build a model in which φ holds.</li>
</ul></li>
</ol>
<h3 id="theorem-1.-every-formula-valid-in-all-structures-is-provable.">Theorem 1. Every formula valid in all structures is provable.</h3>

<p>This is the most basic form of the completeness theorem. We immediately restate it in a form more convenient for our purposes:</p>
<h3 id="theorem-2.-every-formula-φ-is-either-refutable-or-satisfiable-in-some-structure.">Theorem 2. Every formula φ is either refutable or satisfiable in some structure.</h3>

<p>"φ is refutable" means <em>by definition</em> "¬φ is provable".</p>
<h3 id="equivalence-of-both-theorems">Equivalence of both theorems</h3>

<p>To see the equivalence, note first that if <strong>Theorem 1</strong> holds, and φ is not satisfiable in any structure, then ¬φ is valid in all structures and therefore provable, thus φ is refutable and <strong>Theorem 2</strong> holds. If on the other hand <strong>Theorem 2</strong> holds and φ is valid in all structures, then ¬φ is not satisfiable in any structure and therefore refutable; then ¬¬φ is provable and then so is φ, thus <strong>Theorem 1</strong> holds.</p>
<h3 id="proof-of-theorem-2-first-step">Proof of theorem 2: first step</h3>

<p>We approach the proof of <strong>Theorem 2</strong> by successively restricting the class of all formulas φ for which we need to prove "φ is either refutable or satisfiable". At the beginning we need to prove this for all possible formulas φ in our language. However, suppose that for every formula φ there is some formula ψ taken from a more restricted class of formulas <strong>C</strong>, such that "ψ is either refutable or satisfiable" → "φ is either refutable or satisfiable". Then, once this claim (expressed in the previous sentence) is proved, it will suffice to prove "φ is either refutable or satisfiable" only for φ's belonging to the class <strong>C</strong>. Note also that if φ is provably equivalent to ψ (<em>i.e.</em>, (φ≡ψ) is provable), then it is indeed the case that "ψ is either refutable or satisfiable" → "φ is either refutable or satisfiable" (the <a href="soundness_theorem" title="wikilink">soundness theorem</a> is needed to show this).</p>

<p>There are standard techniques for rewriting an arbitrary formula into one that does not use function or constant symbols, at the cost of introducing additional quantifiers; we will therefore assume that all formulas are free of such symbols. Gödel's paper uses a version of first-order predicate calculus that has no function or constant symbols to begin with.</p>

<p>Next we consider a generic formula φ (which no longer uses function or constant symbols) and apply the <a href="prenex_form" title="wikilink">prenex form</a> theorem to find a formula ψ in <em>normal form</em> such that φ≡ψ (ψ being in <em>normal form</em> means that all the quantifiers in ψ, if there are any, are found at the very beginning of ψ). It follows now that we need only prove <strong>Theorem 2</strong> for formulas φ in normal form.</p>

<p>Next, we eliminate all free variables from φ by quantifying them existentially: if, say, <strong>x<sub>1</sub>...x<sub>n</sub></strong> are free in φ, we form 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:4">
 <semantics>
  <mrow>
   <mi>ψ</mi>
   <mo>=</mo>
   <mrow>
    <mo>∃</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mi>ϕ</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ψ</ci>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <exists></exists>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
        <ci>ϕ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi=\exists x_{1}...\exists x_{n}\phi
  </annotation>
 </semantics>
</math>

. If ψ is satisfiable in a structure M, then certainly so is φ and if ψ is refutable, then 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:5">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>ψ</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <mrow>
      <mo>∀</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
       <mi mathvariant="normal">¬</mi>
       <mi>ϕ</mi>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <not></not>
     <ci>ψ</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
        <not></not>
        <ci>ϕ</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\psi=\forall x_{1}...\forall x_{n}\neg\phi
  </annotation>
 </semantics>
</math>

 is provable, and then so is ¬φ, thus φ is refutable. We see that we can restrict φ to be a <em>sentence</em>, that is, a formula with no free variables.</p>

<p>Finally, we would like, for reasons of technical convenience, that the <em>prefix</em> of φ (that is, the string of quantifiers at the beginning of φ, which is in normal form) begin with a universal quantifier and end with an existential quantifier. To achieve this for a generic φ (subject to restrictions we have already proved), we take some one-place relation symbol <strong>F</strong> unused in φ, and two new variables <strong>y</strong> and <strong>z</strong>.. If φ = <strong>(P)Φ</strong>, where (P) stands for the prefix of φ and Φ for the <em>matrix</em> (the remaining, quantifier-free part of φ) we form 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:6">
 <semantics>
  <mrow>
   <mi>ψ</mi>
   <mo>=</mo>
   <mrow>
    <mo>∀</mo>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>P</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <mi>z</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi mathvariant="normal">Φ</mi>
         <mo>∧</mo>
         <mrow>
          <mo stretchy="false">[</mo>
          <mrow>
           <mrow>
            <mi>F</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>y</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
           <mo>∨</mo>
           <mrow>
            <mi mathvariant="normal">¬</mi>
            <mi>F</mi>
            <mrow>
             <mo stretchy="false">(</mo>
             <mi>z</mi>
             <mo stretchy="false">)</mo>
            </mrow>
           </mrow>
          </mrow>
          <mo stretchy="false">]</mo>
         </mrow>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ψ</ci>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <ci>y</ci>
      <ci>P</ci>
      <apply>
       <exists></exists>
       <apply>
        <times></times>
        <ci>z</ci>
        <apply>
         <and></and>
         <ci>normal-Φ</ci>
         <apply>
          <csymbol cd="latexml">delimited-[]</csymbol>
          <apply>
           <or></or>
           <apply>
            <times></times>
            <ci>F</ci>
            <ci>y</ci>
           </apply>
           <apply>
            <times></times>
            <not></not>
            <ci>F</ci>
            <ci>z</ci>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi=\forall y(P)\exists z(\Phi\wedge[F(y)\vee\neg F(z)])
  </annotation>
 </semantics>
</math>

. Since 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:7">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <mi>z</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mrow>
         <mi>F</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>y</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>∨</mo>
        <mrow>
         <mi mathvariant="normal">¬</mi>
         <mi>F</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>z</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <times></times>
     <ci>y</ci>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <ci>z</ci>
       <apply>
        <or></or>
        <apply>
         <times></times>
         <ci>F</ci>
         <ci>y</ci>
        </apply>
        <apply>
         <times></times>
         <not></not>
         <ci>F</ci>
         <ci>z</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall y\exists z(F(y)\vee\neg F(z))
  </annotation>
 </semantics>
</math>

 is clearly provable, it is easy to see that 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:8">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>=</mo>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ϕ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi=\psi
  </annotation>
 </semantics>
</math>

 is provable.</p>
<h3 id="reducing-the-theorem-to-formulas-of-degree-1">Reducing the theorem to formulas of degree 1</h3>

<p>Our generic formula φ now is a sentence, in normal form, and its prefix starts with a universal quantifier and ends with an existential quantifier. Let us call the class of all such formulas <strong>R</strong>. We are faced with proving that every formula in <strong>R</strong> is either refutable or satisfiable. Given our formula φ, we group strings of quantifiers of one kind together in blocks:</p>

<p>

<math display="block" id="Original_proof_of_Gödel's_completeness_theorem:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>ϕ</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>∀</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <mi mathvariant="normal">…</mi>
        <mrow>
         <mo>∀</mo>
         <msub>
          <mi>x</mi>
          <msub>
           <mi>k</mi>
           <mn>1</mn>
          </msub>
         </msub>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>∃</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mrow>
          <msub>
           <mi>k</mi>
           <mn>1</mn>
          </msub>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
        <mi mathvariant="normal">…</mi>
        <mrow>
         <mo>∃</mo>
         <msub>
          <mi>x</mi>
          <msub>
           <mi>k</mi>
           <mn>2</mn>
          </msub>
         </msub>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi mathvariant="normal">…</mi>
     <mi mathvariant="normal">…</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>∀</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mrow>
         <msub>
          <mi>k</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>2</mn>
          </mrow>
         </msub>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mi mathvariant="normal">…</mi>
       <mrow>
        <mo>∀</mo>
        <msub>
         <mi>x</mi>
         <msub>
          <mi>k</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </msub>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mrow>
         <msub>
          <mi>k</mi>
          <mrow>
           <mi>n</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
       <mi mathvariant="normal">…</mi>
       <mrow>
        <mo>∃</mo>
        <msub>
         <mi>x</mi>
         <msub>
          <mi>k</mi>
          <mi>n</mi>
         </msub>
        </msub>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">Φ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <ci>ϕ</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">for-all</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="latexml">for-all</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>k</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <exists></exists>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <apply>
          <plus></plus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>k</ci>
           <cn type="integer">1</cn>
          </apply>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <exists></exists>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>x</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>k</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <ci>normal-…</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>k</ci>
          <apply>
           <minus></minus>
           <ci>n</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>k</ci>
          <apply>
           <minus></minus>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <exists></exists>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>k</ci>
          <apply>
           <minus></minus>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <exists></exists>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>k</ci>
          <ci>n</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <ci>normal-Φ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi=(\forall x_{1}...\forall x_{k_{1}})(\exists x_{k_{1}+1}...\exists x_{k_{2%
}}).......(\forall x_{k_{n-2}+1}...\forall x_{k_{n-1}})(\exists x_{k_{n-1}+1}.%
..\exists x_{k_{n}})(\Phi)
  </annotation>
 </semantics>
</math>

</p>

<p>We define the <strong>degree</strong> of 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:10">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 to be the number of universal quantifier blocks, separated by existential quantifier blocks as shown above, in the prefix of 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:11">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

. The following lemma, which Gödel adapted from Skolem's proof of the <a href="Löwenheim-Skolem_theorem" title="wikilink">Löwenheim-Skolem theorem</a>, lets us sharply reduce the complexity of the generic formula 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:12">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 we need to prove the theorem for:</p>

<p><strong>Lemma</strong>. Let <strong>k</strong>&gt;=1. If every formula in <strong>R</strong> of degree <strong>k</strong> is either refutable or satisfiable, then so is every formula in <strong>R</strong> of degree <strong>k+1</strong>.</p>
<dl>
<dd><strong>Comment</strong>: Take a formula φ of degree k+1 of the form 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:13">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>∀</mo>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>∃</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>∀</mo>
      <mi>u</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\exist</mtext>
      </merror>
      <mi>v</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>P</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ψ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ϕ</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>x</ci>
     </apply>
     <apply>
      <exists></exists>
      <ci>y</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>u</ci>
     </apply>
     <apply>
      <times></times>
      <mtext>\exist</mtext>
      <ci>v</ci>
     </apply>
     <ci>P</ci>
     <ci>ψ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi=(\forall x)(\exists y)(\forall u)(\exist v)(P)\psi
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:14">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (P)\psi
  </annotation>
 </semantics>
</math>

 is the remainder of 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:15">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 (it is thus of degree <strong>k-1</strong>). φ states that for every x there is a y such that... (something). It would have been nice to have a predicate ''Q' '' so that for every x, <em>Q'(x,y)</em> would be true if and only if y is the required one to make (something) true. Then we could have written a formula of degree k, which is equivalent to φ, namely 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:16">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\exist</mtext>
    </merror>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\exist</mtext>
    </merror>
    <msup>
     <mi>y</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <msup>
    <mi>Q</mi>
    <mo>′</mo>
   </msup>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>y</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>Q</mi>
     <mo>′</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <mtext>\exist</mtext>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <mtext>\exist</mtext>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>Q</ci>
     <ci>normal-′</ci>
    </apply>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Q</ci>
      <ci>normal-′</ci>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall x^{\prime})(\forall x)(\forall y)(\forall u)(\exist v)(\exist y^{%
\prime})(P)Q^{\prime}(x^{\prime},y^{\prime})\wedge(Q^{\prime}(x,y)\rightarrow\psi)
  </annotation>
 </semantics>
</math>

. This formula is indeed equivalent to φ because it states that for every x, if there is a y thatsatisfies Q'(x,y), then (something) holds, and furthermore, we know that there is such a y, because for every x', there is a y' that satisfies Q'(x',y'). Therefore φ follows from this formula. It is also easy to show that if the formula is false, then so is φ. <strong>Unfortunately</strong>, in general there is no such predicate Q'. However, this idea can be understood as a basis for the following proof of the Lemma.
</dd>
</dl>

<p><strong>Proof.</strong> Let φ be a formula of degree <strong>k+1</strong>; then we can write it as</p>

<p>

<math display="block" id="Original_proof_of_Gödel's_completeness_theorem:17">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>∀</mo>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>∃</mo>
      <mi>y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>∀</mo>
      <mi>u</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <merror class="ltx_ERROR undefined undefined">
       <mtext>\exist</mtext>
      </merror>
      <mi>v</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>P</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ψ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ϕ</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>x</ci>
     </apply>
     <apply>
      <exists></exists>
      <ci>y</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>u</ci>
     </apply>
     <apply>
      <times></times>
      <mtext>\exist</mtext>
      <ci>v</ci>
     </apply>
     <ci>P</ci>
     <ci>ψ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi=(\forall x)(\exists y)(\forall u)(\exist v)(P)\psi
  </annotation>
 </semantics>
</math>

</p>

<p>where <strong>(P)</strong> is the remainder of the prefix of 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:18">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 (it is thus of degree <strong>k-1</strong>) and 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:19">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

 is the quantifier-free matrix of 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:20">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

. <strong>x</strong>, <strong>y</strong>, <strong>u</strong> and <strong>v</strong> denote here <em>tuples</em> of variables rather than single variables; <em>e.g.</em> 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:21">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mo>∀</mo>
    <mi>x</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall x)
  </annotation>
 </semantics>
</math>

 really stands for 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:22">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mrow>
     <mo>∀</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>2</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <mrow>
       <mo>∀</mo>
       <msub>
        <mi>x</mi>
        <mi>n</mi>
       </msub>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>x</ci>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x_{1}\forall x_{2}...\forall x_{n}
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:23">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mi mathvariant="normal">…</mi>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{1}...x_{n}
  </annotation>
 </semantics>
</math>

 are some distinct variables.</p>

<p>Let now <strong>x</strong>' and <strong>y</strong>' be tuples of previously unused variables of the same length as <strong>x</strong> and <strong>y</strong> respectively, and let <strong>Q</strong> be a previously unused relation symbol that takes as many arguments as the sum of lengths of <strong>x</strong> and <strong>y</strong>; we consider the formula</p>

<p>

<math display="block" id="Original_proof_of_Gödel's_completeness_theorem:24">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∃</mo>
    <msup>
     <mi>y</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>y</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>∀</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\exist</mtext>
     </merror>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>P</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Φ</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <exists></exists>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">Q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Q</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">u</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <mtext>\exist</mtext>
      <csymbol cd="unknown">v</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">P</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi=(\forall x^{\prime})(\exists y^{\prime})Q(x^{\prime},y^{\prime})\wedge(%
\forall x)(\forall y)(Q(x,y)\rightarrow(\forall u)(\exist v)(P)\psi)
  </annotation>
 </semantics>
</math>

</p>

<p>Clearly, 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:25">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mo>→</mo>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>normal-Φ</ci>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi\rightarrow\phi
  </annotation>
 </semantics>
</math>

 is provable.</p>

<p>Now since the string of quantifiers 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:26">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>∀</mo>
     <mi>u</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>∃</mo>
     <mi>v</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>u</ci>
    </apply>
    <apply>
     <exists></exists>
     <ci>v</ci>
    </apply>
    <ci>P</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall u)(\exists v)(P)
  </annotation>
 </semantics>
</math>

 does not contain variables from <strong>x</strong> or <strong>y</strong>, the following equivalence is easily provable with the help of whatever formalism we're using:</p>

<p>

<math display="block" id="Original_proof_of_Gödel's_completeness_theorem:27">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>∀</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>∃</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>P</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∃</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Q</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">u</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <exists></exists>
      <csymbol cd="unknown">v</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">P</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <exists></exists>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Q</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (Q(x,y)\rightarrow(\forall u)(\exists v)(P)\psi)\equiv(\forall u)(\exists v)(P%
)(Q(x,y)\rightarrow\psi)
  </annotation>
 </semantics>
</math>

</p>

<p>And since these two formulas are equivalent, if we replace the first with the second inside Φ, we obtain the formula Φ' such that Φ≡Φ':</p>

<p>

<math display="block" id="Original_proof_of_Gödel's_completeness_theorem:28">
 <semantics>
  <mrow>
   <msup>
    <mi mathvariant="normal">Φ</mi>
    <mo>′</mo>
   </msup>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <merror class="ltx_ERROR undefined undefined">
     <mtext>\exist</mtext>
    </merror>
    <msup>
     <mi>y</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>y</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∃</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Φ</ci>
     <ci>normal-′</ci>
    </apply>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <mtext>\exist</mtext>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">Q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <exists></exists>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Q</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi^{\prime}=(\forall x^{\prime})(\exist y^{\prime})Q(x^{\prime},y^{\prime})%
\wedge(\forall x)(\forall y)(\forall u)(\exists v)(P)(Q(x,y)\rightarrow\psi)
  </annotation>
 </semantics>
</math>

</p>

<p>Now Φ' has the form 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:29">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>S</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ρ</mi>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <msup>
      <mi>S</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <msup>
     <mi>ρ</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>ρ</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>S</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ρ</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (S)\rho\wedge(S^{\prime})\rho^{\prime}
  </annotation>
 </semantics>
</math>

, where <strong>(S)</strong> and <strong>(S')</strong> are some quantifier strings, ρ and ρ' are quantifier-free, and, <strong>furthermore</strong>, no variable of <strong>(S)</strong> occurs in ρ' and no variable of <strong>(S')</strong> occurs in ρ. Under such conditions every formula of the form 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:30">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>T</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>ρ</mi>
     <mo>∧</mo>
     <msup>
      <mi>ρ</mi>
      <mo>′</mo>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <apply>
     <and></and>
     <ci>ρ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>ρ</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (T)(\rho\wedge\rho^{\prime})
  </annotation>
 </semantics>
</math>

, where <strong>(T)</strong> is a string of quantifiers containing all quantifiers in (S) and (S') interleaved among themselves in any fashion, but maintaining the relative order inside (S) and (S'), will be equivalent to the original formula Φ'(this is yet another basic result in first-order predicate calculus that we rely on). To wit, we form Ψ as follows:</p>

<p>

<math display="block" id="Original_proof_of_Gödel's_completeness_theorem:31">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ψ</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∃</mo>
    <msup>
     <mi>y</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∃</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>Q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>y</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>ψ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">Ψ</csymbol>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <exists></exists>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <exists></exists>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">Q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Q</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <csymbol cd="unknown">ψ</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi=(\forall x^{\prime})(\forall x)(\forall y)(\forall u)(\exists y^{\prime})%
(\exists v)(P)Q(x^{\prime},y^{\prime})\wedge(Q(x,y)\rightarrow\psi)
  </annotation>
 </semantics>
</math>

</p>

<p>and we have 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:32">
 <semantics>
  <mrow>
   <msup>
    <mi mathvariant="normal">Φ</mi>
    <mo>′</mo>
   </msup>
   <mo>≡</mo>
   <mi mathvariant="normal">Ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>normal-Φ</ci>
     <ci>normal-′</ci>
    </apply>
    <ci>normal-Ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi^{\prime}\equiv\Psi
  </annotation>
 </semantics>
</math>

.</p>

<p>Now 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:33">
 <semantics>
  <mi mathvariant="normal">Ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi
  </annotation>
 </semantics>
</math>

 is a formula of degree <strong>k</strong> and therefore by assumption either refutable or satisfiable. If 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:34">
 <semantics>
  <mi mathvariant="normal">Ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi
  </annotation>
 </semantics>
</math>

 is satisfiable in a structure <strong>M</strong>, then, considering 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:35">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ψ</mi>
   <mo>≡</mo>
   <msup>
    <mi mathvariant="normal">Φ</mi>
    <mo>′</mo>
   </msup>
   <mo>≡</mo>
   <mrow>
    <mi mathvariant="normal">Φ</mi>
    <mo>∧</mo>
    <mi mathvariant="normal">Φ</mi>
   </mrow>
   <mo>→</mo>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <ci>normal-Ψ</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-Φ</ci>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <and></and>
      <ci>normal-Φ</ci>
      <ci>normal-Φ</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>ϕ</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi\equiv\Phi^{\prime}\equiv\Phi\wedge\Phi\rightarrow\phi
  </annotation>
 </semantics>
</math>

, we see that 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:36">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 is satisfiable as well. If 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:37">
 <semantics>
  <mi mathvariant="normal">Ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi
  </annotation>
 </semantics>
</math>

 is refutable, then so is 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:38">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

, which is equivalent to it; thus 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:39">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi mathvariant="normal">Φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>normal-Φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\Phi
  </annotation>
 </semantics>
</math>

 is provable. Now we can replace all occurrences of Q inside the provable formula 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:40">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi mathvariant="normal">Φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>normal-Φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\Phi
  </annotation>
 </semantics>
</math>

 by some other formula dependent on the same variables, and we will still get a provable formula. (<em>This is yet another basic result of first-order predicate calculus. Depending on the particular formalism adopted for the calculus, it may be seen as a simple application of a "functional substitution" rule of inference, as in Gödel's paper, or it may be proved by considering the formal proof of 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:41">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi mathvariant="normal">Φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>normal-Φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\Phi
  </annotation>
 </semantics>
</math>

, replacing in it all occurrences of Q by some other formula with the same free variables, and noting that all logical axioms in the formal proof remain logical axioms after the substitution, and all rules of inference still apply in the same way.</em>)</p>

<p>In this particular case, we replace Q(x',y') in 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:42">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi mathvariant="normal">Φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>normal-Φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\Phi
  </annotation>
 </semantics>
</math>

 with the formula 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:43">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∃</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>ψ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>y</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <exists></exists>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">ψ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall u)(\exists v)(P)\psi(x,y|x^{\prime},y^{\prime})
  </annotation>
 </semantics>
</math>

. Here (x,y|x',y') means that instead of ψ we are writing a different formula, in which x and y are replaced with x' and y'. Note that Q(x,y) is simply replaced by 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:44">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>∀</mo>
     <mi>u</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>∃</mo>
     <mi>v</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>u</ci>
    </apply>
    <apply>
     <exists></exists>
     <ci>v</ci>
    </apply>
    <ci>P</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall u)(\exists v)(P)\psi
  </annotation>
 </semantics>
</math>

.</p>

<p>

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:45">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi mathvariant="normal">Φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>normal-Φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\Phi
  </annotation>
 </semantics>
</math>

 then becomes</p>

<p>

<math display="block" id="Original_proof_of_Gödel's_completeness_theorem:46">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>∀</mo>
     <msup>
      <mi>x</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>∃</mo>
     <msup>
      <mi>y</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>∀</mo>
     <mi>u</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>∃</mo>
     <mi>v</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>P</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ψ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">|</mo>
     <msup>
      <mi>x</mi>
      <mo>′</mo>
     </msup>
     <mo>,</mo>
     <msup>
      <mi>y</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>∀</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mo>∀</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>∀</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>∃</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>P</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>ψ</mi>
     <mo>→</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>∀</mo>
      <mi>u</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mo>∃</mo>
      <mi>v</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>P</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>ψ</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <not></not>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <exists></exists>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">u</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <exists></exists>
      <csymbol cd="unknown">v</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">P</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <csymbol cd="unknown">ψ</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-|</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>x</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>normal-,</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>y</ci>
       <ci>normal-′</ci>
      </apply>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="latexml">for-all</csymbol>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="latexml">for-all</csymbol>
       <csymbol cd="unknown">u</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <exists></exists>
       <csymbol cd="unknown">v</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">P</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">ψ</csymbol>
      <ci>normal-→</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="latexml">for-all</csymbol>
       <csymbol cd="unknown">u</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <exists></exists>
       <csymbol cd="unknown">v</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">P</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <csymbol cd="unknown">ψ</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg((\forall x^{\prime})(\exists y^{\prime})(\forall u)(\exists v)(P)\psi(x,y%
|x^{\prime},y^{\prime})\wedge(\forall x)(\forall y)((\forall u)(\exists v)(P)%
\psi\rightarrow(\forall u)(\exists v)(P)\psi))
  </annotation>
 </semantics>
</math>

</p>

<p>and this formula is provable; since the part under negation and after the 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:47">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge
  </annotation>
 </semantics>
</math>

 sign is obviously provable, and the part under negation and before the 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:48">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge
  </annotation>
 </semantics>
</math>

 sign is obviously φ, just with <strong>x</strong> and <strong>y</strong> replaced by <strong>x</strong>' and <strong>y</strong>', we see that 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:49">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>ϕ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\phi
  </annotation>
 </semantics>
</math>

 is provable, and φ is refutable. We have proved that φ is either satisfiable or refutable, and this concludes the proof of the <strong>Lemma</strong>.</p>

<p>Notice that we could not have used 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:50">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>u</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∃</mo>
    <mi>v</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>P</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>ψ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">|</mo>
    <msup>
     <mi>x</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>y</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">u</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <exists></exists>
     <csymbol cd="unknown">v</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">P</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">ψ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-|</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>x</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <ci>normal-′</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall u)(\exists v)(P)\psi(x,y|x^{\prime},y^{\prime})
  </annotation>
 </semantics>
</math>

 instead of Q(x',y') from the beginning, because 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:51">
 <semantics>
  <mi mathvariant="normal">Ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi
  </annotation>
 </semantics>
</math>

 would not have been a <a href="well-formed_formula" title="wikilink">well-formed formula</a> in that case. This is why we cannot naively use the argument appearing at the comment that precedes the proof.</p>
<h3 id="proving-the-theorem-for-formulas-of-degree-1">Proving the theorem for formulas of degree 1</h3>

<p>As shown by the <strong>Lemma</strong> above, we only need to prove our theorem for formulas φ in <strong>R</strong> of degree 1. φ cannot be of degree 0, since formulas in R have no free variables and don't use constant symbols. So the formula φ has the general form:</p>

<p>

<math display="block" id="Original_proof_of_Gödel's_completeness_theorem:52">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>∀</mo>
      <mrow>
       <msub>
        <mi>x</mi>
        <mn>1</mn>
       </msub>
       <mi mathvariant="normal">…</mi>
       <msub>
        <mi>x</mi>
        <mi>k</mi>
       </msub>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mn>1</mn>
       </msub>
       <mi mathvariant="normal">…</mi>
       <msub>
        <mi>y</mi>
        <mi>m</mi>
       </msub>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>x</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>y</mi>
       <mi>m</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
    <ci>ϕ</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall x_{1}...x_{k})(\exists y_{1}...y_{m})\phi(x_{1}...x_{k},y_{1}...y_{m}).
  </annotation>
 </semantics>
</math>

</p>

<p>Now we define an ordering of the k-<a href="tuple" title="wikilink">tuples</a> of <a href="natural_number" title="wikilink">natural numbers</a> as follows

<math display="block" id="Original_proof_of_Gödel's_completeness_theorem:53">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo><</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>y</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1}...x_{k})<(y_{1}...y_{k})
  </annotation>
 </semantics>
</math>

 should hold if either 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:54">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>x</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>y</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{k}(x_{1}...x_{k})<\Sigma_{k}(y_{1}...y_{k})
  </annotation>
 </semantics>
</math>

, or 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:55">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>x</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi mathvariant="normal">Σ</mi>
     <mi>k</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>y</mi>
       <mi>k</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>x</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>normal-Σ</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{k}(x_{1}...x_{k})=\Sigma_{k}(y_{1}...y_{k})
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:56">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>x</mi>
     <mi>k</mi>
    </msub>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x_{1}...x_{k})
  </annotation>
 </semantics>
</math>

 precedes 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:57">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>y</mi>
     <mi>k</mi>
    </msub>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>y</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (y_{1}...y_{k})
  </annotation>
 </semantics>
</math>

 in <a href="lexicographic_order" title="wikilink">lexicographic order</a>. [Here 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:58">
 <semantics>
  <mrow>
   <msub>
    <mi mathvariant="normal">Σ</mi>
    <mi>k</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>x</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>x</mi>
      <mi>k</mi>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>normal-Σ</ci>
     <ci>k</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma_{k}(x_{1}...x_{k})
  </annotation>
 </semantics>
</math>

 denotes the sum of the terms of the tuple.] Denote the nth tuple in this order by 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:59">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msubsup>
     <mi>a</mi>
     <mn>1</mn>
     <mi>n</mi>
    </msubsup>
    <mi mathvariant="normal">…</mi>
    <msubsup>
     <mi>a</mi>
     <mi>k</mi>
     <mi>n</mi>
    </msubsup>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (a^{n}_{1}...a^{n}_{k})
  </annotation>
 </semantics>
</math>

.</p>

<p>Set the formula 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:60">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{n}
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:61">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>z</mi>
      <msubsup>
       <mi>a</mi>
       <mn>1</mn>
       <mi>n</mi>
      </msubsup>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>z</mi>
      <msubsup>
       <mi>a</mi>
       <mi>k</mi>
       <mi>n</mi>
      </msubsup>
     </msub>
    </mrow>
    <mo>,</mo>
    <msub>
     <mi>z</mi>
     <mrow>
      <mrow>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>m</mi>
      </mrow>
      <mo>+</mo>
      <mn>2</mn>
     </mrow>
    </msub>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>z</mi>
      <mrow>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <mrow>
          <mi>n</mi>
          <mo>-</mo>
          <mn>1</mn>
         </mrow>
         <mo stretchy="false">)</mo>
        </mrow>
        <mi>m</mi>
       </mrow>
       <mo>+</mo>
       <mn>3</mn>
      </mrow>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>z</mi>
      <mrow>
       <mrow>
        <mi>n</mi>
        <mi>m</mi>
       </mrow>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>ϕ</ci>
    <vector>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>a</ci>
         <ci>n</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>a</ci>
         <ci>n</ci>
        </apply>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>m</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <minus></minus>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>m</ci>
        </apply>
        <cn type="integer">3</cn>
       </apply>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>n</ci>
         <ci>m</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi(z_{a^{n}_{1}}...z_{a^{n}_{k}},z_{(n-1)m+2},z_{(n-1)m+3}...z_{nm+1})
  </annotation>
 </semantics>
</math>

. Then put 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:62">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{n}
  </annotation>
 </semantics>
</math>

 as</p>

<p>

<math display="block" id="Original_proof_of_Gödel's_completeness_theorem:63">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <msub>
        <mi>z</mi>
        <mn>1</mn>
       </msub>
       <mi mathvariant="normal">…</mi>
       <msub>
        <mi>z</mi>
        <mrow>
         <mrow>
          <mi>n</mi>
          <mi>m</mi>
         </mrow>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>B</mi>
       <mn>1</mn>
      </msub>
      <mo>∧</mo>
      <mrow>
       <msub>
        <mi>B</mi>
        <mn>2</mn>
       </msub>
       <mi mathvariant="normal">…</mi>
      </mrow>
      <mo>∧</mo>
      <msub>
       <mi>B</mi>
       <mi>n</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>z</ci>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <ci>n</ci>
         <ci>m</ci>
        </apply>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>B</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>B</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\exists z_{1}...z_{nm+1})(B_{1}\wedge B_{2}...\wedge B_{n}).
  </annotation>
 </semantics>
</math>

</p>

<p><strong>Lemma</strong>: For every <em>n</em>, φ

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:64">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>→</mo>
   <msub>
    <mi>D</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \rightarrow D_{n}
  </annotation>
 </semantics>
</math>

.</p>

<p><strong>Proof</strong>: By induction on n; we have 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:65">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mi>k</mi>
   </msub>
   <mo>⇐</mo>
   <mrow>
    <msub>
     <mi>D</mi>
     <mrow>
      <mi>k</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>∧</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>∀</mo>
       <mrow>
        <msub>
         <mi>z</mi>
         <mn>1</mn>
        </msub>
        <mi mathvariant="normal">…</mi>
        <msub>
         <mi>z</mi>
         <mrow>
          <mrow>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>n</mi>
             <mo>-</mo>
             <mn>1</mn>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
           <mi>m</mi>
          </mrow>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>∃</mo>
       <mrow>
        <msub>
         <mi>z</mi>
         <mrow>
          <mrow>
           <mrow>
            <mo stretchy="false">(</mo>
            <mrow>
             <mi>n</mi>
             <mo>-</mo>
             <mn>1</mn>
            </mrow>
            <mo stretchy="false">)</mo>
           </mrow>
           <mi>m</mi>
          </mrow>
          <mo>+</mo>
          <mn>2</mn>
         </mrow>
        </msub>
        <mi mathvariant="normal">…</mi>
        <msub>
         <mi>z</mi>
         <mrow>
          <mrow>
           <mi>n</mi>
           <mi>m</mi>
          </mrow>
          <mo>+</mo>
          <mn>1</mn>
         </mrow>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <msub>
      <mi>B</mi>
      <mi>n</mi>
     </msub>
    </mrow>
   </mrow>
   <mo>⇐</mo>
   <mrow>
    <msub>
     <mi>D</mi>
     <mrow>
      <mi>k</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>∧</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>∀</mo>
       <mrow>
        <msub>
         <mi>z</mi>
         <msubsup>
          <mi>a</mi>
          <mn>1</mn>
          <mi>n</mi>
         </msubsup>
        </msub>
        <mi mathvariant="normal">…</mi>
        <msub>
         <mi>z</mi>
         <msubsup>
          <mi>a</mi>
          <mi>k</mi>
          <mi>n</mi>
         </msubsup>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo>∃</mo>
       <mrow>
        <msub>
         <mi>y</mi>
         <mn>1</mn>
        </msub>
        <mi mathvariant="normal">…</mi>
        <msub>
         <mi>y</mi>
         <mi>m</mi>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>ϕ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>z</mi>
        <msubsup>
         <mi>a</mi>
         <mn>1</mn>
         <mi>n</mi>
        </msubsup>
       </msub>
       <mi mathvariant="normal">…</mi>
       <msub>
        <mi>z</mi>
        <msubsup>
         <mi>a</mi>
         <mi>k</mi>
         <mi>n</mi>
        </msubsup>
       </msub>
      </mrow>
      <mo>,</mo>
      <mrow>
       <msub>
        <mi>y</mi>
        <mn>1</mn>
       </msub>
       <mi mathvariant="normal">…</mi>
       <msub>
        <mi>y</mi>
        <mi>m</mi>
       </msub>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-⇐</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <and></and>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>D</ci>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>normal-…</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <apply>
           <plus></plus>
           <apply>
            <times></times>
            <apply>
             <minus></minus>
             <ci>n</ci>
             <cn type="integer">1</cn>
            </apply>
            <ci>m</ci>
           </apply>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <exists></exists>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <apply>
           <plus></plus>
           <apply>
            <times></times>
            <apply>
             <minus></minus>
             <ci>n</ci>
             <cn type="integer">1</cn>
            </apply>
            <ci>m</ci>
           </apply>
           <cn type="integer">2</cn>
          </apply>
         </apply>
         <ci>normal-…</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <apply>
           <plus></plus>
           <apply>
            <times></times>
            <ci>n</ci>
            <ci>m</ci>
           </apply>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>B</ci>
        <ci>n</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-⇐</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <and></and>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>D</ci>
       <apply>
        <minus></minus>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">for-all</csymbol>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>a</ci>
            <ci>n</ci>
           </apply>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>normal-…</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>a</ci>
            <ci>n</ci>
           </apply>
           <ci>k</ci>
          </apply>
         </apply>
        </apply>
       </apply>
       <apply>
        <exists></exists>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>normal-…</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>m</ci>
         </apply>
        </apply>
       </apply>
       <ci>ϕ</ci>
       <interval closure="open">
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>a</ci>
            <ci>n</ci>
           </apply>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>normal-…</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>z</ci>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>a</ci>
            <ci>n</ci>
           </apply>
           <ci>k</ci>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <cn type="integer">1</cn>
         </apply>
         <ci>normal-…</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>y</ci>
          <ci>m</ci>
         </apply>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{k}\Leftarrow D_{k-1}\wedge(\forall z_{1}...z_{(n-1)m+1})(\exists z_{(n-1)m+%
2}...z_{nm+1})B_{n}\Leftarrow D_{k-1}\wedge(\forall z_{a^{n}_{1}}...z_{a^{n}_{%
k}})(\exists y_{1}...y_{m})\phi(z_{a^{n}_{1}}...z_{a^{n}_{k}},y_{1}...y_{m})
  </annotation>
 </semantics>
</math>

, where the latter implication holds by variable substitution, since the ordering of the tuples is such that 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:66">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>∀</mo>
      <mi>k</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msubsup>
       <mi>a</mi>
       <mn>1</mn>
       <mi>n</mi>
      </msubsup>
      <mi mathvariant="normal">…</mi>
      <msubsup>
       <mi>a</mi>
       <mi>k</mi>
       <mi>n</mi>
      </msubsup>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>n</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>m</mi>
    </mrow>
    <mo>+</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <lt></lt>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>k</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <ci>n</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <ci>n</ci>
       </apply>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <minus></minus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>m</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall k)({a^{n}_{1}}...{a^{n}_{k}})<(n-1)m+2
  </annotation>
 </semantics>
</math>

. But the last formula is equivalent to 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:67">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mrow>
     <mi>k</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>∧</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">limit-from</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>D</ci>
     <apply>
      <minus></minus>
      <ci>k</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <and></and>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{k-1}\wedge
  </annotation>
 </semantics>
</math>

φ.</p>

<p>For the base case, 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:68">
 <semantics>
  <mrow>
   <msub>
    <mi>D</mi>
    <mn>1</mn>
   </msub>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <msub>
        <mi>z</mi>
        <mn>1</mn>
       </msub>
       <mi mathvariant="normal">…</mi>
       <msub>
        <mi>z</mi>
        <mrow>
         <mi>m</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>z</mi>
       <msubsup>
        <mi>a</mi>
        <mn>1</mn>
        <mn>1</mn>
       </msubsup>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>z</mi>
       <msubsup>
        <mi>a</mi>
        <mi>k</mi>
        <mn>1</mn>
       </msubsup>
      </msub>
     </mrow>
     <mo>,</mo>
     <msub>
      <mi>z</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>z</mi>
       <mn>3</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>z</mi>
       <mrow>
        <mi>m</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>∃</mo>
      <mrow>
       <msub>
        <mi>z</mi>
        <mn>1</mn>
       </msub>
       <mi mathvariant="normal">…</mi>
       <msub>
        <mi>z</mi>
        <mrow>
         <mi>m</mi>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msub>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>ϕ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msub>
       <mi>z</mi>
       <mn>1</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>z</mi>
       <mn>1</mn>
      </msub>
     </mrow>
     <mo>,</mo>
     <msub>
      <mi>z</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mrow>
      <msub>
       <mi>z</mi>
       <mn>3</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>z</mi>
       <mrow>
        <mi>m</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>D</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <apply>
       <exists></exists>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <apply>
          <plus></plus>
          <ci>m</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>ϕ</ci>
      <vector>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>a</ci>
           <cn type="integer">1</cn>
          </apply>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">superscript</csymbol>
           <ci>a</ci>
           <cn type="integer">1</cn>
          </apply>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <cn type="integer">3</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <apply>
          <plus></plus>
          <ci>m</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </vector>
     </apply>
    </apply>
    <apply>
     <equivalent></equivalent>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <exists></exists>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <apply>
          <plus></plus>
          <ci>m</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
      <ci>ϕ</ci>
      <vector>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>z</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <cn type="integer">3</cn>
        </apply>
        <ci>normal-…</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>z</ci>
         <apply>
          <plus></plus>
          <ci>m</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </vector>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{1}\equiv(\exists z_{1}...z_{m+1})\phi(z_{a^{1}_{1}}...z_{a^{1}_{k}},z_{2},z%
_{3}...z_{m+1})\equiv(\exists z_{1}...z_{m+1})\phi(z_{1}...z_{1},z_{2},z_{3}..%
.z_{m+1})
  </annotation>
 </semantics>
</math>

 is obviously a corollary of φ as well. So the <strong>Lemma</strong> is proven.</p>

<p>Now if 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:69">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{n}
  </annotation>
 </semantics>
</math>

 is refutable for some <em>n</em>, it follows that φ is refutable. On the other hand, suppose that 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:70">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{n}
  </annotation>
 </semantics>
</math>

 is not refutable for any <em>n</em>. Then for each <em>n</em> there is some way of assigning truth values to the distinct subpropositions 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:71">
 <semantics>
  <msub>
   <mi>E</mi>
   <mi>h</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{h}
  </annotation>
 </semantics>
</math>

 (ordered by their first appearance in 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:72">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{n}
  </annotation>
 </semantics>
</math>

; "distinct" here means either distinct predicates, or distinct bound variables) in 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:73">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{k}
  </annotation>
 </semantics>
</math>

, such that 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:74">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{n}
  </annotation>
 </semantics>
</math>

 will be true when each proposition is evaluated in this fashion. This follows from the completeness of the underlying <a href="propositional_logic" title="wikilink">propositional logic</a>.</p>

<p>We will now show that there is such an assignment of truth values to 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:75">
 <semantics>
  <msub>
   <mi>E</mi>
   <mi>h</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{h}
  </annotation>
 </semantics>
</math>

, so that all 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:76">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{n}
  </annotation>
 </semantics>
</math>

 will be true: The 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:77">
 <semantics>
  <msub>
   <mi>E</mi>
   <mi>h</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{h}
  </annotation>
 </semantics>
</math>

 appear in the same order in every 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:78">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{n}
  </annotation>
 </semantics>
</math>

; we will inductively define a general assignment to them by a sort of "majority vote": Since there are infinitely many assignments (one for each 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:79">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{n}
  </annotation>
 </semantics>
</math>

) affecting 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:80">
 <semantics>
  <msub>
   <mi>E</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{1}
  </annotation>
 </semantics>
</math>

, either infinitely many make 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:81">
 <semantics>
  <msub>
   <mi>E</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{1}
  </annotation>
 </semantics>
</math>

 true, or infinitely many make it false and only finitely many make it true. In the former case, we choose 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:82">
 <semantics>
  <msub>
   <mi>E</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{1}
  </annotation>
 </semantics>
</math>

 to be true in general; in the latter we take it to be false in general. Then from the infinitely many <em>n</em> for which 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:83">
 <semantics>
  <msub>
   <mi>E</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{1}
  </annotation>
 </semantics>
</math>

 through 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:84">
 <semantics>
  <msub>
   <mi>E</mi>
   <mrow>
    <mi>h</mi>
    <mo>-</mo>
    <mn>1</mn>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <apply>
     <minus></minus>
     <ci>h</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{h-1}
  </annotation>
 </semantics>
</math>

 are assigned the same truth value as in the general assignment, we pick a general assignment to 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:85">
 <semantics>
  <msub>
   <mi>E</mi>
   <mi>h</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{h}
  </annotation>
 </semantics>
</math>

 in the same fashion.</p>

<p>This general assignment must lead to every one of the 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:86">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{k}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:87">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{k}
  </annotation>
 </semantics>
</math>

 being true, since if one of the 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:88">
 <semantics>
  <msub>
   <mi>B</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>B</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B_{k}
  </annotation>
 </semantics>
</math>

 were false under the general assignment, 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:89">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{n}
  </annotation>
 </semantics>
</math>

 would also be false for every <em>n &gt; k</em>. But this contradicts the fact that for the finite collection of general 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:90">
 <semantics>
  <msub>
   <mi>E</mi>
   <mi>h</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>E</ci>
    <ci>h</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{h}
  </annotation>
 </semantics>
</math>

 assignments appearing in 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:91">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{k}
  </annotation>
 </semantics>
</math>

, there are infinitely many <em>n</em> where the assignment making 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:92">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>n</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{n}
  </annotation>
 </semantics>
</math>

 true matches the general assignment.</p>

<p>From this general assignment, which makes all of the 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:93">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{k}
  </annotation>
 </semantics>
</math>

 true, we construct an interpretation of the language's predicates that makes φ true. The universe of the model will be the <a href="natural_numbers" title="wikilink">natural numbers</a>. Each i-ary predicate 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:94">
 <semantics>
  <mi mathvariant="normal">Ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi
  </annotation>
 </semantics>
</math>

 should be true of the naturals 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:95">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <msub>
     <mi>u</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>u</mi>
     <mi>i</mi>
    </msub>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>u</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (u_{1}...u_{i})
  </annotation>
 </semantics>
</math>

 precisely when the proposition 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:96">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Ψ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msub>
      <mi>z</mi>
      <msub>
       <mi>u</mi>
       <mn>1</mn>
      </msub>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>z</mi>
      <msub>
       <mi>u</mi>
       <mi>i</mi>
      </msub>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Ψ</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>u</ci>
       <ci>i</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Psi(z_{u_{1}}...z_{u_{i}})
  </annotation>
 </semantics>
</math>

 is either true in the general assignment, or not assigned by it (because it never appears in any of the 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:97">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{k}
  </annotation>
 </semantics>
</math>

).</p>

<p>In this model, each of the formulas 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:98">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo>∃</mo>
     <mrow>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>y</mi>
       <mi>m</mi>
      </msub>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>ϕ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msubsup>
      <mi>a</mi>
      <mn>1</mn>
      <mi>n</mi>
     </msubsup>
     <mi mathvariant="normal">…</mi>
     <msubsup>
      <mi>a</mi>
      <mi>k</mi>
      <mi>n</mi>
     </msubsup>
    </mrow>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>y</mi>
      <mn>1</mn>
     </msub>
     <mi mathvariant="normal">…</mi>
     <msub>
      <mi>y</mi>
      <mi>m</mi>
     </msub>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <exists></exists>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </apply>
    <ci>ϕ</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <ci>n</ci>
       </apply>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <ci>n</ci>
       </apply>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>y</ci>
       <ci>m</ci>
      </apply>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\exists y_{1}...y_{m})\phi(a^{n}_{1}...a^{n}_{k},y_{1}...y_{m})
  </annotation>
 </semantics>
</math>

 is true by construction. But this implies that φ itself is true in the model, since the 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:99">
 <semantics>
  <msup>
   <mi>a</mi>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>a</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{n}
  </annotation>
 </semantics>
</math>

 range over all possible k-tuples of natural numbers. So φ is satisfiable, and we are done.</p>
<h4 id="intuitive-explanation">Intuitive explanation</h4>

<p>We may write each B<sub>i</sub> as Φ(x<sub>1</sub>...x<sub>k</sub>,y<sub>1</sub>...y<sub>m</sub>) for some x-s, which we may call "first arguments" and y-s that we may call "last arguments".</p>

<p>Take B<sub>1</sub> for example. Its "last arguments" are z<sub>2</sub>,z<sub>3</sub>...z<sub>m+1</sub>, and for every possible combination of k of these variables there is some j so that they appear as "first arguments" in B<sub>j</sub>. Thus for large enough n<sub>1</sub>, D<sub>n<sub>1</sub></sub> has the property that the "last arguments" of B<sub>1</sub> appear, in every possible combinations of k of them, as "first arguments" in other B<sub>j</sub>-s within D<sub>n</sub>. For every B<sub>i</sub> there is a D<sub>n<sub>i</sub></sub> with the corresponding property.</p>

<p>Therefore in a model that satisfies all the D<sub>n</sub>-s, there are objects corresponding to z<sub>1</sub>, z<sub>2</sub>... and each combination of k of these appear as "first arguments" in some B<sub>j</sub>, meaning that for every k of these objects z<sub>p<sub>1</sub></sub>...z<sub>p<sub>k</sub></sub> there are z<sub>q<sub>1</sub></sub>...z<sub>q<sub>m</sub></sub>, which makes Φ(z<sub>p<sub>1</sub></sub>...z<sub>p<sub>k</sub></sub>,z<sub>q<sub>1</sub></sub>...z<sub>q<sub>m</sub></sub>) satisfied. By taking a submodel with only these z<sub>1</sub>, z<sub>2</sub>... objects, we have a model satisfying φ.</p>
<h2 id="extensions">Extensions</h2>
<h3 id="extension-to-first-order-predicate-calculus-with-equality">Extension to first-order predicate calculus with equality</h3>

<p>Gödel reduced a formula containing instances of the equality predicate to ones without it in an extended language. His method involves replacing a formula φ containing some instances of equality with the formula</p>

<p>

<math display="block" id="Original_proof_of_Gödel's_completeness_theorem:100">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi>E</mi>
   <mi>q</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>E</mi>
    <mi>q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>E</mi>
     <mi>q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>→</mo>
     <mi>E</mi>
     <mi>q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>y</mi>
      <mo>,</mo>
      <mi>z</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">E</csymbol>
    <csymbol cd="unknown">q</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">E</csymbol>
     <csymbol cd="unknown">q</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">E</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">z</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <csymbol cd="unknown">E</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">z</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\forall x)Eq(x,x)\wedge(\forall x,y,z)[Eq(x,y)\rightarrow(Eq(x,z)\rightarrow
Eq%
(y,z))]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:101">
 <semantics>
  <mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo>,</mo>
    <mi>z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>E</mi>
    <mi>q</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>E</mi>
     <mi>q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo>,</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>→</mo>
     <mi>E</mi>
     <mi>q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>z</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">y</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">z</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">E</csymbol>
     <csymbol cd="unknown">q</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">y</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">E</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">z</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">x</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <csymbol cd="unknown">E</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">z</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">y</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge(\forall x,y,z)[Eq(x,y)\rightarrow(Eq(z,x)\rightarrow Eq(z,y))]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:102">
 <semantics>
  <mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>x</mi>
     <mi>k</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>x</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>E</mi>
     <mi>q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∧</mo>
     <mi mathvariant="normal">…</mi>
     <mo>∧</mo>
     <mi>E</mi>
     <mi>q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>k</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>x</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>≡</mo>
     <mi>A</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>y</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>k</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">E</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-,</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <and></and>
      <ci>normal-…</ci>
      <and></and>
      <csymbol cd="unknown">E</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
       <ci>normal-,</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>k</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>k</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <equivalent></equivalent>
      <csymbol cd="unknown">A</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>k</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge(\forall x_{1}...x_{k},y_{1}...x_{k})[(Eq(x_{1},y_{1})\wedge...\wedge Eq%
(x_{k},y_{k}))\rightarrow(A(x_{1}...x_{k})\equiv A(y_{1}...y_{k}))]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:103">
 <semantics>
  <mrow>
   <mo>∧</mo>
   <mi mathvariant="normal">…</mi>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mo>∀</mo>
    <msub>
     <mi>x</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>x</mi>
     <mi>m</mi>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>y</mi>
     <mn>1</mn>
    </msub>
    <mi mathvariant="normal">…</mi>
    <msub>
     <mi>x</mi>
     <mi>m</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>E</mi>
     <mi>q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∧</mo>
     <mi mathvariant="normal">…</mi>
     <mo>∧</mo>
     <mi>E</mi>
     <mi>q</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mi>m</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>y</mi>
       <mi>m</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Z</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>x</mi>
       <mn>1</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>x</mi>
       <mi>m</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>≡</mo>
     <mi>Z</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>y</mi>
       <mn>1</mn>
      </msub>
      <mi mathvariant="normal">…</mi>
      <msub>
       <mi>y</mi>
       <mi>m</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <and></and>
    <ci>normal-…</ci>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="latexml">for-all</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>m</ci>
     </apply>
     <ci>normal-,</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>y</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>m</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">E</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-,</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <and></and>
      <ci>normal-…</ci>
      <and></and>
      <csymbol cd="unknown">E</csymbol>
      <csymbol cd="unknown">q</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>m</ci>
       </apply>
       <ci>normal-,</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>m</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">Z</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>m</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <equivalent></equivalent>
      <csymbol cd="unknown">Z</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <cn type="integer">1</cn>
       </apply>
       <ci>normal-…</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>y</ci>
        <ci>m</ci>
       </apply>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge...\wedge(\forall x_{1}...x_{m},y_{1}...x_{m})[(Eq(x_{1},y_{1})\wedge...%
\wedge Eq(x_{m},y_{m}))\rightarrow(Z(x_{1}...x_{m})\equiv Z(y_{1}...y_{m}))]
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:104">
 <semantics>
  <mrow>
   <mrow>
    <mo>∧</mo>
    <msup>
     <mi>φ</mi>
     <mo>′</mo>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>φ</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge\varphi^{\prime}.
  </annotation>
 </semantics>
</math>

</p>

<p>Here 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:105">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mi mathvariant="normal">…</mi>
   <mi>Z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>A</ci>
    <ci>normal-…</ci>
    <ci>Z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A...Z
  </annotation>
 </semantics>
</math>

 denote the predicates appearing in φ (with 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:106">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mi mathvariant="normal">…</mi>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>k</ci>
    <ci>normal-…</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k...m
  </annotation>
 </semantics>
</math>

 their respective arities), and φ' is the formula φ with all occurrences of equality replaced with the new predicate <em>Eq</em>. If this new formula is refutable, the original φ was as well; the same is true of satisfiability, since we may take a quotient of satisfying model of the new formula by the equivalence relation representing <em>Eq</em>. This quotient is well-defined with respect to the other predicates, and therefore will satisfy the original formula φ.</p>
<h3 id="extension-to-countable-sets-of-formulas">Extension to countable sets of formulas</h3>

<p>Gödel also considered the case where there are a countably infinite collection of formulas. Using the same reductions as above, he was able to consider only those cases where each formula is of degree 1 and contains no uses of equality. For a countable collection of formulas 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:107">
 <semantics>
  <msup>
   <mi>ϕ</mi>
   <mi>i</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>ϕ</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi^{i}
  </annotation>
 </semantics>
</math>

 of degree 1, we may define 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:108">
 <semantics>
  <msubsup>
   <mi>B</mi>
   <mi>k</mi>
   <mi>i</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>B</ci>
     <ci>i</ci>
    </apply>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{i}_{k}
  </annotation>
 </semantics>
</math>

 as above; then define 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:109">
 <semantics>
  <msub>
   <mi>D</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>D</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   D_{k}
  </annotation>
 </semantics>
</math>

 to be the closure of 

<math display="inline" id="Original_proof_of_Gödel's_completeness_theorem:110">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>B</mi>
     <mn>1</mn>
     <mn>1</mn>
    </msubsup>
    <mi mathvariant="normal">…</mi>
    <msubsup>
     <mi>B</mi>
     <mi>k</mi>
     <mn>1</mn>
    </msubsup>
   </mrow>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mrow>
    <msubsup>
     <mi>B</mi>
     <mn>1</mn>
     <mi>k</mi>
    </msubsup>
    <mi mathvariant="normal">…</mi>
    <msubsup>
     <mi>B</mi>
     <mi>k</mi>
     <mi>k</mi>
    </msubsup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <cn type="integer">1</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <cn type="integer">1</cn>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <ci>k</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>B</ci>
       <ci>k</ci>
      </apply>
      <ci>k</ci>
     </apply>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B^{1}_{1}...B^{1}_{k},...,B^{k}_{1}...B^{k}_{k}
  </annotation>
 </semantics>
</math>

. The remainder of the proof then went through as before.</p>
<h3 id="extension-to-arbitrary-sets-of-formulas">Extension to arbitrary sets of formulas</h3>

<p>When there is an uncountably infinite collection of formulas, the <a href="Axiom_of_Choice" title="wikilink">Axiom of Choice</a> (or at least some weak form of it) is needed. Using the full AC, one can <a class="uri" href="well-order" title="wikilink">well-order</a> the formulas, and prove the uncountable case with the same argument as the countable one, except with <a href="transfinite_induction" title="wikilink">transfinite induction</a>. Other approaches can be used to prove that the completeness theorem in this case is equivalent to the <a href="Boolean_prime_ideal_theorem" title="wikilink">Boolean prime ideal theorem</a>, a weak form of AC.</p>
<h2 id="references">References</h2>
<ul>
<li>

<p>The first proof of the completeness theorem.</p></li>
<li>

<p>The same material as the dissertation, except with briefer proofs, more succinct explanations, and omitting the lengthy introduction.</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="Stanford_Encyclopedia_of_Philosophy" title="wikilink">Stanford Encyclopedia of Philosophy</a>: "<a href="http://plato.stanford.edu/entries/goedel/">Kurt Gödel</a>"—by Juliette Kennedy.</li>
<li>MacTutor biography: <a href="http://www-groups.dcs.st-and.ac.uk/~history/Mathematicians/Godel.html">Kurt Gödel.</a></li>
</ul>

<p>"</p>

<p><a class="uri" href="Category:Logic" title="wikilink">Category:Logic</a> <a href="Category:Model_theory" title="wikilink">Godel's completeness theorem</a> <a href="Category:Mathematical_proofs" title="wikilink">Category:Mathematical proofs</a> <a href="Category:Mathematical_logic" title="wikilink">Godel's completeness theorem</a> <a href="Category:Proof_theory" title="wikilink">Godel's completeness theorem</a> <a href="Category:Works_by_Kurt_Gödel" title="wikilink">Category:Works by Kurt Gödel</a></p>
</body>
</html>
