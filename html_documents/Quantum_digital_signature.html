<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="6">Quantum digital signature</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Quantum digital signature</h1>
<hr/>

<p>A <strong>Quantum Digital Signature (QDS)</strong> refers to the quantum mechanical equivalent of either a classical <a href="digital_signature" title="wikilink">digital signature</a> or, more generally, a handwritten signature on a paper document. Like a handwritten signature, a digital signature is used to protect a document, such as a digital contract, against forgery by another party or by one of the participating parties.</p>

<p>As e-commerce has become more important in society, the need to certify the origin of exchanged information has arisen. Modern digital signatures enhance security based on the difficulty of solving a mathematical problem, such as finding the factors of large numbers (as used in the <a href="RSA_(algorithm)" title="wikilink">RSA algorithm</a>). Unfortunately, the task of solving these problems becomes feasible when a quantum computer is available (see <a href="Shor's_algorithm" title="wikilink">Shor's algorithm</a>). To face this new problem, new quantum digital signature schemes are in development to provide protection against tampering, even from parties in possession of quantum computers and using powerful quantum cheating strategies.</p>
<h2 id="classical-public-key-method">Classical public-key method</h2>

<p>The <a href="Public-key_cryptography" title="wikilink">public-key method</a> of cryptography allows a sender to sign a message (often only the <a href="Cryptographic_hash_function" title="wikilink">cryptographic hash</a> of the message) with a sign key in such a way that any recipient can, using the corresponding public key, check the authenticity of the message. To allow this, the public key is made broadly available to all potential recipients. To make sure only the legal author of the message can validly sign the message, the public key is created from a random, private sign key, using a <a href="one-way_function" title="wikilink">one-way function</a>. This is a function that is designed such that computing the result given the input is very easy, but computing the input given the result is very difficult. A classic example is the multiplication of two very large primes: The multiplication is easy, but factoring the product without knowing the primes is normally considered infeasible.</p>

<p>

<math display="block" id="Quantum_digital_signature:0">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>↦</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>x</ci>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\mapsto f(x)
  </annotation>
 </semantics>
</math>

 <em>easy</em></p>

<p>

<math display="block" id="Quantum_digital_signature:1">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>↦</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)\mapsto x
  </annotation>
 </semantics>
</math>

 <em>very difficult</em></p>
<h2 id="quantum-digital-signature">Quantum Digital Signature</h2>

<p>Like classical digital signatures, quantum digital signatures make use of asymmetric keys. Thus, a person who wants to sign a message creates one or more pairs of sign and corresponding public keys. In general we can divide quantum digital signature schemes into two groups:</p>
<ol>
<li>A scheme that creates a public quantum-bit key out of a private <strong>classical</strong> bit string

<math display="block" id="Quantum_digital_signature:2">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>↦</mo>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi>f</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>k</ci>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\mapsto|f_{k}\rangle
  </annotation>
 </semantics>
</math>

</li>
<li>A scheme that creates a public quantum-bit key out of a private <strong>quantum</strong> bit string

<math display="block" id="Quantum_digital_signature:3">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>k</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>↦</mo>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi>f</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>k</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |k\rangle\mapsto|f_{k}\rangle
  </annotation>
 </semantics>
</math>

</li>
</ol>

<p>In both cases f is a one-way quantum function that has the same properties as a classical one-way function. That is, the result is easy to compute, but, in contrast to the classical scheme, the function is <em>impossible</em> to invert, even if one uses powerful quantum cheating strategies.</p>

<p>The most famous scheme for the first method above is provided by Gottesman and Chuang <a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h3 id="requirements-for-a-good-and-usable-signature-scheme">Requirements for a good and usable signature scheme</h3>

<p>Most of the requirements for a classical digital signature scheme also apply to the quantum digital signature scheme.</p>

<p>In detail</p>
<ol>
<li>The scheme has to provide security against tampering by
<ol>
<li>The sender after the message was signed (see <a href="Commitment_scheme" title="wikilink">bit commitment</a>)</li>
<li>The receiver</li>
<li>A third party</li>
</ol></li>
<li>Creating a signed message has to be easy</li>
<li>Every recipient has to get the same answer, when testing the message for validity (Valid, Non-Valid)</li>
</ol>

<p><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h3 id="differences-between-classical-and-quantum-one-way-functions">Differences between classical and quantum one-way functions</h3>
<h4 id="nature-of-the-one-way-function">Nature of the one-way function</h4>

<p>A classical one-way function as said above is based on a classical infeasible mathematical task, whereas a quantum one-way function exploits the uncertainty principle which makes it impossible even for a quantum computer to compute the inverse. This is done by providing a quantum output state, with whom one cannot learn enough about the input string to reproduce it. In case of the first group of schemes this is shown by Holevo's theorem, which says, that from a given n-qubit quantum state one cannot extract more than n classical bits of information.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> One possibility to ensure that the scheme uses less qubits for a bit string of a certain length is by using nearly orthogonal states</p>

<p>

<math display="block" id="Quantum_digital_signature:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">|</mo>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <msub>
       <mi>f</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">|</mo>
      <msubsup>
       <mi>f</mi>
       <mi>k</mi>
       <mo>′</mo>
      </msubsup>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo><</mo>
    <mi>δ</mi>
   </mrow>
   <mrow>
    <mrow>
     <mtext>for</mtext>
     <mi>k</mi>
    </mrow>
    <mo>≠</mo>
    <mrow>
     <msup>
      <mi>k</mi>
      <mo>′</mo>
     </msup>
     <mi mathvariant="italic">and</mi>
     <mn>0</mn>
    </mrow>
    <mo>≤</mo>
    <mi>δ</mi>
    <mo>≤</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <lt></lt>
     <apply>
      <abs></abs>
      <apply>
       <csymbol cd="latexml">inner-product</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>k</ci>
        </apply>
        <ci>normal-′</ci>
       </apply>
      </apply>
     </apply>
     <ci>δ</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <neq></neq>
      <apply>
       <times></times>
       <mtext>for</mtext>
       <ci>k</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>k</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>italic- and</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
     <apply>
      <leq></leq>
      <share href="#.cmml">
      </share>
      <ci>δ</ci>
     </apply>
     <apply>
      <leq></leq>
      <share href="#.cmml">
      </share>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\langle f_{k}|f_{k}^{\prime}\rangle|<\delta\qquad\text{ for }k\neq k^{\prime}%
\and 0\leq\delta\leq 1
  </annotation>
 </semantics>
</math>

 That gives us the possibility to induce a basis with more than two states.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> So to describe an information of 

<math display="inline" id="Quantum_digital_signature:5">
 <semantics>
  <msup>
   <mn>2</mn>
   <mi>n</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n}
  </annotation>
 </semantics>
</math>

 bits, we can use less than n qubits. An example with a 3 qubit basis</p>

<p>:* 

<math display="inline" id="Quantum_digital_signature:6">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mn>0</mn>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |0\rangle
  </annotation>
 </semantics>
</math>

</p>

<p>:* 

<math display="inline" id="Quantum_digital_signature:7">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mn>1</mn>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |1\rangle
  </annotation>
 </semantics>
</math>

</p>

<p>:* 

<math display="inline" id="Quantum_digital_signature:8">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1</mn>
    <msqrt>
     <mn>2</mn>
    </msqrt>
   </mfrac>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mn>0</mn>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mn>1</mn>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <cn type="integer">1</cn>
     <apply>
      <root></root>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)
  </annotation>
 </semantics>
</math>

 Only m qubits are needed to describe n classical bits when 

<math display="inline" id="Quantum_digital_signature:9">
 <semantics>
  <mrow>
   <msup>
    <mn>3</mn>
    <mi>m</mi>
   </msup>
   <mo>=</mo>
   <msup>
    <mn>2</mn>
    <mi>n</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">3</cn>
     <ci>m</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3^{m}=2^{n}
  </annotation>
 </semantics>
</math>

 holds.</p>

<p>Because of Holevo's theorem and the fact, that m can be much smaller than n, we can only get m bits out of the n bits message. More general, if one gets T copies of the public key he can extract at most Tm bits of the private key. If 

<math display="inline" id="Quantum_digital_signature:10">
 <semantics>
  <mi>δ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>δ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta
  </annotation>
 </semantics>
</math>

 is big 

<math display="inline" id="Quantum_digital_signature:11">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mrow>
    <mi>T</mi>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-Tm
  </annotation>
 </semantics>
</math>

 becomes very large, which makes it impossible for a dishonest person to guess the sign key.</p>

<p>''Note: You cannot distinguish between non-orthogonal states, if you only have a small amount of identical states. That's how the quantum one-way functions works. <em><br/>
</em>Nevertheless 

<math display="inline" id="Quantum_digital_signature:12">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <msub>
    <mi>f</mi>
    <mi>k</mi>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |f_{k}\rangle
  </annotation>
 </semantics>
</math>

 leaks information about the private key, in contrast to the classical public key, which forces one to get nothing or all about the private key. ''</p>
<h4 id="copying-the-public-key">Copying the public key</h4>

<p>In the classical case we create a classical public key out of a classical sign key, thus it is easy to provide every potential recipient with a copy of the public key. The public key can be freely distributed. This becomes more difficult in the quantum case, because copying a quantum state is forbidden by the no cloning theorem, as long as the state itself is unknown.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> So public keys can only be created and distributed by a person who knows the exact quantum state he wants to create, thus who knows the sign key (This can be the sender or in more general a trustful institution). Nevertheless in contrast to the classical public key there is an upper bound for the number of public quantum keys <strong>T</strong> which can be created, without enabling one to guess the sign key and thus endangering the security of the scheme (

<math display="inline" id="Quantum_digital_signature:13">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>-</mo>
   <mrow>
    <mi>T</mi>
    <mi>m</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <ci>n</ci>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n-Tm
  </annotation>
 </semantics>
</math>

 has to be big)</p>
<h4 id="public-key-should-be-the-same-for-every-recipient-swap-test">Public Key should be the same for every recipient (Swap Test)</h4>

<p>To make sure that every recipient gets identical results when testing the authenticity of a message, public keys distributed have to be the same. This is straightforward in the classical case, because one can easily compare two classical bit strings and see if those match. Nevertheless in the quantum state it is more complicated. To test, if two public quantum states are the same one has to compare the following</p>

<p>

<math display="block" id="Quantum_digital_signature:14">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msubsup>
     <mi>f</mi>
     <mi>k</mi>
     <mo>′</mo>
    </msubsup>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi>f</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>k</ci>
      </apply>
      <ci>normal-′</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |f_{k}^{\prime}\rangle=|f_{k}\rangle
  </annotation>
 </semantics>
</math>

</p>

<p> This is done with the following quantum circuit which uses one <a href="Fredkin_gate" title="wikilink">Fredkin gate</a> <em>F</em>, one <a href="Hadamard_transform" title="wikilink">Hadamard gate</a> <em>H</em> and an ancilla qubit <em>a</em>. First of all the ancilla qubit is set to a symmetric state 

<math display="inline" id="Quantum_digital_signature:15">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>a</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msqrt>
      <mn>2</mn>
     </msqrt>
    </mfrac>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>0</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>1</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |a\rangle=\frac{1}{\sqrt{2}}(|0\rangle+|1\rangle)
  </annotation>
 </semantics>
</math>

.</p>

<p>Right after the ancilla qubit is used as a control on the targets 

<math display="inline" id="Quantum_digital_signature:16">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <msub>
    <mi>f</mi>
    <mi>k</mi>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |f_{k}\rangle
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Quantum_digital_signature:17">
 <semantics>
  <mrow>
   <mo fence="true" lspace="7.5pt" stretchy="false">|</mo>
   <msubsup>
    <mi>f</mi>
    <mi>k</mi>
    <mo>′</mo>
   </msubsup>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>k</ci>
     </apply>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ |f_{k}^{\prime}\rangle
  </annotation>
 </semantics>
</math>

 in a Fredkin Gate.</p>

<p>Furthermore a Hadamard gate is applied on the ancilla qubit and finally the first qubit gets measured. If both states are the same, the result 

<math display="inline" id="Quantum_digital_signature:18">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mn>0</mn>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |0\rangle
  </annotation>
 </semantics>
</math>

 is measured. If both states are nearly orthogonal, the result can be either 

<math display="inline" id="Quantum_digital_signature:19">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mn>0</mn>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |0\rangle
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Quantum_digital_signature:20">
 <semantics>
  <mrow>
   <mo fence="true" lspace="7.5pt" stretchy="false">|</mo>
   <mn>1</mn>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ |1\rangle
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>The calculation of the swap test in more detail:</p>

<p>The overall state</p>

<p>

<math display="block" id="Quantum_digital_signature:21">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi>ψ</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mi>a</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <msub>
      <mi>f</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <msubsup>
      <mi>f</mi>
      <mi>k</mi>
      <mo>′</mo>
     </msubsup>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ψ</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>k</ci>
       </apply>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi_{0}\rangle=|a\rangle|f_{k}\rangle|f_{k}^{\prime}\rangle
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Quantum_digital_signature:22">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi>ψ</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msqrt>
      <mn>2</mn>
     </msqrt>
    </mfrac>
    <mrow>
     <mo maxsize="210%" minsize="210%">(</mo>
     <mrow>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>0</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mn>1</mn>
       <mo stretchy="false">⟩</mo>
      </mrow>
     </mrow>
     <mo maxsize="210%" minsize="210%">)</mo>
    </mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <msub>
      <mi>f</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <msubsup>
      <mi>f</mi>
      <mi>k</mi>
      <mo>′</mo>
     </msubsup>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ψ</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>f</ci>
        <ci>k</ci>
       </apply>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi_{0}\rangle=\frac{1}{\sqrt{2}}\bigg(|0\rangle+|1\rangle\bigg)|f_{k}%
\rangle|f_{k}^{\prime}\rangle
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Quantum_digital_signature:23">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi>ψ</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msqrt>
      <mn>2</mn>
     </msqrt>
    </mfrac>
    <mrow>
     <mo maxsize="210%" minsize="210%">(</mo>
     <mrow>
      <mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>0</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <msub>
         <mi>f</mi>
         <mi>k</mi>
        </msub>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <msubsup>
         <mi>f</mi>
         <mi>k</mi>
         <mo>′</mo>
        </msubsup>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>1</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <msub>
         <mi>f</mi>
         <mi>k</mi>
        </msub>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <msubsup>
         <mi>f</mi>
         <mi>k</mi>
         <mo>′</mo>
        </msubsup>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo maxsize="210%" minsize="210%">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ψ</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <ci>k</ci>
         </apply>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <ci>k</ci>
         </apply>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi_{0}\rangle=\frac{1}{\sqrt{2}}\bigg(|0\rangle|f_{k}\rangle|f_{k}^{\prime}%
\rangle+|1\rangle|f_{k}\rangle|f_{k}^{\prime}\rangle\bigg)
  </annotation>
 </semantics>
</math>

</p>

<p>After the <strong>Fredkin</strong> gate is applied</p>

<p>

<math display="inline" id="Quantum_digital_signature:24">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⇒</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <msqrt>
      <mn>2</mn>
     </msqrt>
    </mfrac>
    <mrow>
     <mo maxsize="210%" minsize="210%">(</mo>
     <mrow>
      <mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>0</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <msub>
         <mi>f</mi>
         <mi>k</mi>
        </msub>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <msubsup>
         <mi>f</mi>
         <mi>k</mi>
         <mo>′</mo>
        </msubsup>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>1</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <msubsup>
         <mi>𝐟</mi>
         <mi>𝐤</mi>
         <mo>′</mo>
        </msubsup>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <msub>
         <mi>𝐟</mi>
         <mi>𝐤</mi>
        </msub>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo maxsize="210%" minsize="210%">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇒</ci>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <apply>
       <root></root>
       <cn type="integer">2</cn>
      </apply>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>f</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <ci>k</ci>
         </apply>
         <ci>normal-′</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>𝐟</ci>
          <ci>𝐤</ci>
         </apply>
         <ci>normal-′</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>𝐟</ci>
         <ci>𝐤</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Rightarrow\frac{1}{\sqrt{2}}\bigg(|0\rangle|f_{k}\rangle|f_{k}^{\prime}%
\rangle+|1\rangle\mathbf{|f_{k}^{\prime}\rangle|f_{k}\rangle}\bigg)
  </annotation>
 </semantics>
</math>

</p>

<p>After the <strong>Hadamard</strong> gate is applied on the first qubit</p>

<p>

<math display="inline" id="Quantum_digital_signature:25">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⇒</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mo maxsize="210%" minsize="210%">[</mo>
     <mrow>
      <mrow>
       <mrow>
        <mo maxsize="210%" minsize="210%">(</mo>
        <mrow>
         <mrow>
          <mo fence="true" stretchy="false">|</mo>
          <mn>0</mn>
          <mo stretchy="false">⟩</mo>
         </mrow>
         <mo>+</mo>
         <mrow>
          <mo fence="true" stretchy="false">|</mo>
          <mn>1</mn>
          <mo stretchy="false">⟩</mo>
         </mrow>
        </mrow>
        <mo maxsize="210%" minsize="210%">)</mo>
       </mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <msub>
         <mi>f</mi>
         <mi>k</mi>
        </msub>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <msubsup>
         <mi>f</mi>
         <mi>k</mi>
         <mo>′</mo>
        </msubsup>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mrow>
        <mo maxsize="210%" minsize="210%">(</mo>
        <mrow>
         <mrow>
          <mo fence="true" stretchy="false">|</mo>
          <mn>0</mn>
          <mo stretchy="false">⟩</mo>
         </mrow>
         <mo>-</mo>
         <mrow>
          <mo fence="true" stretchy="false">|</mo>
          <mn>1</mn>
          <mo stretchy="false">⟩</mo>
         </mrow>
        </mrow>
        <mo maxsize="210%" minsize="210%">)</mo>
       </mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <msubsup>
         <mi>f</mi>
         <mi>k</mi>
         <mo>′</mo>
        </msubsup>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <msub>
         <mi>f</mi>
         <mi>k</mi>
        </msub>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo maxsize="210%" minsize="210%">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇒</ci>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="latexml">ket</csymbol>
          <cn type="integer">0</cn>
         </apply>
         <apply>
          <csymbol cd="latexml">ket</csymbol>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <ci>k</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>f</ci>
           <ci>k</ci>
          </apply>
          <ci>normal-′</ci>
         </apply>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="latexml">ket</csymbol>
          <cn type="integer">0</cn>
         </apply>
         <apply>
          <csymbol cd="latexml">ket</csymbol>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>f</ci>
           <ci>k</ci>
          </apply>
          <ci>normal-′</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="latexml">ket</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>f</ci>
          <ci>k</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Rightarrow\frac{1}{2}\bigg[\bigg(|0\rangle+|1\rangle\bigg)|f_{k}\rangle|f_{k}%
^{\prime}\rangle+\bigg(|0\rangle-|1\rangle\bigg)|f_{k}^{\prime}\rangle|f_{k}%
\rangle\bigg]
  </annotation>
 </semantics>
</math>

</p>

<p>After <strong>sorting</strong> for 

<math display="inline" id="Quantum_digital_signature:26">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mn>0</mn>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mtext>and</mtext>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mn>1</mn>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <cn type="integer">0</cn>
    </apply>
    <mtext>and</mtext>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |0\rangle\text{ and }|1\rangle
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Quantum_digital_signature:27">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⇒</mo>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>ψ</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <mo maxsize="210%" minsize="210%">[</mo>
     <mrow>
      <mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>0</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mrow>
        <mo maxsize="210%" minsize="210%">(</mo>
        <mrow>
         <mrow>
          <mrow>
           <mo fence="true" stretchy="false">|</mo>
           <msub>
            <mi>f</mi>
            <mi>k</mi>
           </msub>
           <mo stretchy="false">⟩</mo>
          </mrow>
          <mrow>
           <mo fence="true" stretchy="false">|</mo>
           <msubsup>
            <mi>f</mi>
            <mi>k</mi>
            <mo>′</mo>
           </msubsup>
           <mo stretchy="false">⟩</mo>
          </mrow>
         </mrow>
         <mo>+</mo>
         <mrow>
          <mrow>
           <mo fence="true" stretchy="false">|</mo>
           <msubsup>
            <mi>f</mi>
            <mi>k</mi>
            <mo>′</mo>
           </msubsup>
           <mo stretchy="false">⟩</mo>
          </mrow>
          <mrow>
           <mo fence="true" stretchy="false">|</mo>
           <msub>
            <mi>f</mi>
            <mi>k</mi>
           </msub>
           <mo stretchy="false">⟩</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo maxsize="210%" minsize="210%">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>1</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mrow>
        <mo maxsize="210%" minsize="210%">(</mo>
        <mrow>
         <mrow>
          <mrow>
           <mo fence="true" stretchy="false">|</mo>
           <msub>
            <mi>f</mi>
            <mi>k</mi>
           </msub>
           <mo stretchy="false">⟩</mo>
          </mrow>
          <mrow>
           <mo fence="true" stretchy="false">|</mo>
           <msubsup>
            <mi>f</mi>
            <mi>k</mi>
            <mo>′</mo>
           </msubsup>
           <mo stretchy="false">⟩</mo>
          </mrow>
         </mrow>
         <mo>-</mo>
         <mrow>
          <mrow>
           <mo fence="true" stretchy="false">|</mo>
           <msubsup>
            <mi>f</mi>
            <mi>k</mi>
            <mo>′</mo>
           </msubsup>
           <mo stretchy="false">⟩</mo>
          </mrow>
          <mrow>
           <mo fence="true" stretchy="false">|</mo>
           <msub>
            <mi>f</mi>
            <mi>k</mi>
           </msub>
           <mo stretchy="false">⟩</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo maxsize="210%" minsize="210%">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo maxsize="210%" minsize="210%">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-⇒</ci>
     <csymbol cd="latexml">absent</csymbol>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>ψ</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <plus></plus>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="latexml">ket</csymbol>
          <cn type="integer">0</cn>
         </apply>
         <apply>
          <plus></plus>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="latexml">ket</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>f</ci>
             <ci>k</ci>
            </apply>
           </apply>
           <apply>
            <csymbol cd="latexml">ket</csymbol>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>f</ci>
              <ci>k</ci>
             </apply>
             <ci>normal-′</ci>
            </apply>
           </apply>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="latexml">ket</csymbol>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>f</ci>
              <ci>k</ci>
             </apply>
             <ci>normal-′</ci>
            </apply>
           </apply>
           <apply>
            <csymbol cd="latexml">ket</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>f</ci>
             <ci>k</ci>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="latexml">ket</csymbol>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="latexml">ket</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>f</ci>
             <ci>k</ci>
            </apply>
           </apply>
           <apply>
            <csymbol cd="latexml">ket</csymbol>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>f</ci>
              <ci>k</ci>
             </apply>
             <ci>normal-′</ci>
            </apply>
           </apply>
          </apply>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="latexml">ket</csymbol>
            <apply>
             <csymbol cd="ambiguous">superscript</csymbol>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>f</ci>
              <ci>k</ci>
             </apply>
             <ci>normal-′</ci>
            </apply>
           </apply>
           <apply>
            <csymbol cd="latexml">ket</csymbol>
            <apply>
             <csymbol cd="ambiguous">subscript</csymbol>
             <ci>f</ci>
             <ci>k</ci>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Rightarrow|\psi\rangle=\frac{1}{2}\bigg[|0\rangle\bigg(|f_{k}\rangle|f_{k}^{%
\prime}\rangle+|f_{k}^{\prime}\rangle|f_{k}\rangle\bigg)+|1\rangle\bigg(|f_{k}%
\rangle|f_{k}^{\prime}\rangle-|f_{k}^{\prime}\rangle|f_{k}\rangle\bigg)\bigg]
  </annotation>
 </semantics>
</math>

</p>

<p>Now it is easy to see, if the states 

<math display="inline" id="Quantum_digital_signature:28">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi>f</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msubsup>
     <mi>f</mi>
     <mi>k</mi>
     <mo>′</mo>
    </msubsup>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>k</ci>
      </apply>
      <ci>normal-′</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |f_{k}\rangle=|f_{k}^{\prime}\rangle
  </annotation>
 </semantics>
</math>

 then 

<math display="inline" id="Quantum_digital_signature:29">
 <semantics>
  <mrow>
   <mrow>
    <mo fence="true" lspace="7.5pt" stretchy="false">|</mo>
    <mi>ψ</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mn>0</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <msub>
      <mi>f</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <msub>
      <mi>f</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>ψ</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>k</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \ |\psi\rangle=|0\rangle|f_{k}\rangle|f_{k}\rangle
  </annotation>
 </semantics>
</math>

, which gives us a 0 whenever it is measured.</p>
<h2 id="an-example-of-a-signing-validation-process-using-a-simplified-gottesman-chuang-scheme">An example of a signing-validation process using a simplified Gottesman-Chuang scheme</h2>
<h3 id="signing-process">Signing Process</h3>

<p> Let Person A (Alice) want to send a message to Person B (Bob). Hash algorithms won't be considered, so Alice has to sign every single bit of her message. Message-Bit <strong>b</strong> 

<math display="inline" id="Quantum_digital_signature:30">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>∈</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <csymbol cd="latexml">absent</csymbol>
    <set>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \in\{0,1\}
  </annotation>
 </semantics>
</math>

.</p>

<p>Alice chooses <strong>M</strong> pairs of private keys 

<math display="inline" id="Quantum_digital_signature:31">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">{</mo>
     <msubsup>
      <mi>k</mi>
      <mn>0</mn>
      <mi>i</mi>
     </msubsup>
     <mo>,</mo>
     <msubsup>
      <mi>k</mi>
      <mn>1</mn>
      <mi>i</mi>
     </msubsup>
     <mo stretchy="false">}</mo>
    </mrow>
    <mn>1</mn>
   </mrow>
   <mo>≤</mo>
   <mi>i</mi>
   <mo>≤</mo>
   <mi>M</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <list>
      <set>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>k</ci>
         <cn type="integer">0</cn>
        </apply>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
        <ci>i</ci>
       </apply>
      </set>
      <cn type="integer">1</cn>
     </list>
     <ci>i</ci>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{k_{0}^{i},k_{1}^{i}\}\quad 1\leq i\leq M
  </annotation>
 </semantics>
</math>

</p>
<ul>
<li>All the 

<math display="inline" id="Quantum_digital_signature:32">
 <semantics>
  <msub>
   <mi>k</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{0}
  </annotation>
 </semantics>
</math>

 keys will be used to sign the message-bit if b = 0.</li>
<li>All the 

<math display="inline" id="Quantum_digital_signature:33">
 <semantics>
  <msub>
   <mi>k</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{1}
  </annotation>
 </semantics>
</math>

 keys will be used to sign the message-bit if b = 1.</li>
</ul>

<p>The function which maps 

<math display="inline" id="Quantum_digital_signature:34">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>↦</mo>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi>f</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>k</ci>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\mapsto|f_{k}\rangle
  </annotation>
 </semantics>
</math>

 is known to all parties. Alice now computes the corresponding public keys 

<math display="inline" id="Quantum_digital_signature:35">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msubsup>
     <mi>f</mi>
     <msub>
      <mi>k</mi>
      <mn>0</mn>
     </msub>
     <mi>i</mi>
    </msubsup>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msubsup>
     <mi>f</mi>
     <msub>
      <mi>k</mi>
      <mn>1</mn>
     </msub>
     <mi>i</mi>
    </msubsup>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>k</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>f</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>k</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>i</ci>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{|f_{k_{0}}^{i}\rangle,|f_{k_{1}}^{i}\rangle\}
  </annotation>
 </semantics>
</math>

 and gives all of them to the recipients. She can make as many copies as she needs, but has to take care, not to endanger the security 

<math display="inline" id="Quantum_digital_signature:36">
 <semantics>
  <mrow>
   <mo>(</mo>
   <mrow>
    <mi>n</mi>
    <mo>≫</mo>
    <mrow>
     <mi>T</mi>
     <mi>m</mi>
     <mtext>has to hold</mtext>
    </mrow>
   </mrow>
   <mo>)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">much-greater-than</csymbol>
    <ci>n</ci>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>m</ci>
     <mtext>has to hold</mtext>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left(n\gg Tm\text{ has to hold }\right)
  </annotation>
 </semantics>
</math>

.</p>

<p><em>Her level of security limits the number of identical public keys she can create</em></p>

<p>If</p>
<ul>
<li>message-bit <strong>b = 0</strong>, she sends all her private keys <strong>

<math display="inline" id="Quantum_digital_signature:37">
 <semantics>
  <msub>
   <mi>k</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{0}
  </annotation>
 </semantics>
</math>

</strong> along with the message-bit <strong>b</strong> to Bob</li>
<li>message-bit <strong>b = 1</strong>, she sends all her private keys <strong>

<math display="inline" id="Quantum_digital_signature:38">
 <semantics>
  <msub>
   <mi>k</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>k</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{1}
  </annotation>
 </semantics>
</math>

</strong> along with the message-bit <strong>b</strong> to Bob</li>
</ul>

<p>''Remember: In this example Alice picks only one bit <strong>b</strong> and signs it. She has to do that for every single bit in her message ''</p>
<h3 id="validation-process">Validation Process</h3>

<p> Bob now possesses</p>
<ul>
<li>The message-bit <strong>b</strong></li>
<li>The corresponding private keys 

<math display="inline" id="Quantum_digital_signature:39">
 <semantics>
  <mrow>
   <msub>
    <mi>k</mi>
    <mn>0</mn>
   </msub>
   <mtext>or</mtext>
   <msub>
    <mi>k</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <cn type="integer">0</cn>
    </apply>
    <mtext>or</mtext>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{0}\text{ or }k_{1}
  </annotation>
 </semantics>
</math>

</li>
<li>All public keys 

<math display="inline" id="Quantum_digital_signature:40">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi>f</mi>
     <msub>
      <mi>k</mi>
      <mn>0</mn>
     </msub>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>,</mo>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <msub>
     <mi>f</mi>
     <msub>
      <mi>k</mi>
      <mn>1</mn>
     </msub>
    </msub>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <cn type="integer">0</cn>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>f</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>k</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{|f_{k_{0}}\rangle,|f_{k_{1}}\rangle\}
  </annotation>
 </semantics>
</math>

</li>
</ul>

<p>Now Bob calculates 

<math display="inline" id="Quantum_digital_signature:41">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <msub>
    <mi>f</mi>
    <msub>
     <mi>k</mi>
     <mi>b</mi>
    </msub>
   </msub>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>k</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |f_{k_{b}}\rangle
  </annotation>
 </semantics>
</math>

 for all received private keys (either 

<math display="inline" id="Quantum_digital_signature:42">
 <semantics>
  <mrow>
   <msub>
    <mi>k</mi>
    <mn>0</mn>
   </msub>
   <mtext>or</mtext>
   <msub>
    <mi>k</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <cn type="integer">0</cn>
    </apply>
    <mtext>or</mtext>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>k</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k_{0}\text{ or }k_{1}
  </annotation>
 </semantics>
</math>

).</p>

<p>After he has done so he makes use of the swap test to compare the calculated states with the received public keys. Since the swap test has some probability to give the wrong answer he has to do it for all the <strong>M</strong> keys and counts how many incorrect keys he gets <strong>r</strong>. It is obvious, that <strong>M</strong> is some kind of a security parameter. It is more unlikely to validate a bit wrong for bigger <strong>M</strong>.</p>
<ul>
<li>If he only gets a few incorrect keys, then the bit is most probably valid, because his calculated keys and the public keys seem to be the same.</li>
<li>If he gets many incorrect keys, then somebody faked the message with high probability.</li>
</ul>
<h2 id="avoid-a-message-to-be-validated-differently">Avoid a message to be validated differently</h2>

<p>One problem which arises especially for small <strong>M</strong> is, that the number of incorrect keys different recipients measure differ with probability. So to define only one threshold is not enough, because it would cause a message to be validated differently, when the number of incorrect keys <strong>r</strong> is very close to the defined threshold.</p>

<p>This can be prevented by defining more than one threshold. Because the number of errors increase proportional with M, the thresholds are defined like</p>
<dl>
<dd><strong>Acceptance</strong> 

<math display="inline" id="Quantum_digital_signature:43">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mi>a</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>c</mi>
     <mn>1</mn>
    </msub>
    <mi>M</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{a}=c_{1}M
  </annotation>
 </semantics>
</math>


</dd>
</dl>
<dl>
<dd><strong>Rejection</strong> 

<math display="inline" id="Quantum_digital_signature:44">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mi>r</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>c</mi>
     <mn>2</mn>
    </msub>
    <mi>M</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <ci>r</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>c</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{r}=c_{2}M
  </annotation>
 </semantics>
</math>


</dd>
</dl>
<ul>
<li>If the number of incorrect keys <strong>r</strong> is below 

<math display="inline" id="Quantum_digital_signature:45">
 <semantics>
  <msub>
   <mi>T</mi>
   <mi>a</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{a}
  </annotation>
 </semantics>
</math>

, then the bit is valid with high probability</li>
<li>If the number of incorrect keys <strong>r</strong> is above 

<math display="inline" id="Quantum_digital_signature:46">
 <semantics>
  <msub>
   <mi>T</mi>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{r}
  </annotation>
 </semantics>
</math>

, then the bit is faked with high probability</li>
<li>If the number of incorrect keys <strong>r</strong> is in-between both thresholds, then the recipient cannot be sure, if another recipient gets the same outcome, when validating the bit. Furthermore he can't be even sure, if he validated the message right.</li>
</ul>

<p><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>

<p><em>If we assume perfect channels without noise, so the bit can't be changed due to the transfer, then the threshold 

<math display="inline" id="Quantum_digital_signature:47">
 <semantics>
  <msub>
   <mi>T</mi>
   <mi>a</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>T</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{a}
  </annotation>
 </semantics>
</math>

 can be set to zero, because the swap test passes always, when the compared states are the same</em></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Lamport_signature" title="wikilink">Lamport signature</a> - A practical digital signature method invented in the 1970s and believed to be secure even against quantum computing attacks.</li>
<li><a href="Quantum_cryptography" title="wikilink">Quantum cryptography</a></li>
<li><a href="Quantum_fingerprinting" title="wikilink">Quantum fingerprinting</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Digital_signature_schemes" title="wikilink">Category:Digital signature schemes</a> <a href="Category:Key_management" title="wikilink">Category:Key management</a> <a href="Category:Quantum_information_science" title="wikilink">Category:Quantum information science</a> <a href="Category:Theoretical_computer_science" title="wikilink">Category:Theoretical computer science</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Daniel Gottesman, Isaac L. Chuang. <em>Quantum Digital Signatures</em>, <a href="http://arxiv.org/abs/quant-ph/0105032v2"><em>arXiv:quant-ph/0105032</em> <strong>v2</strong></a>, (November 15, 2001)<a href="#fnref1">↩</a></li>
<li id="fn2"></li>
<li id="fn3">Xin Lü, Deng-Guo Feng. <em>Quantum Digital Signature Based on Quantum One-way Functions</em>, <a href="http://arxiv.org/abs/quant-ph/0403046"><em>arxiv:quant-ph/04030462</em> <strong>v2</strong></a>, (June 24, 2004)<a href="#fnref3">↩</a></li>
<li id="fn4">Michael A. Nielsen, Isaac L. Chuang. <em>Quantum Computation and Quantum Information 1st Ed.</em>, Cambridge University Press, <strong>p.531-536</strong><a href="#fnref4">↩</a></li>
<li id="fn5"></li>
<li id="fn6">Michael A. Nielsen, Isaac L. Chuang. <em>Quantum Computation and Quantum Information 1st Ed.</em>, Cambridge University Press, <strong>p.532</strong><a href="#fnref6">↩</a></li>
<li id="fn7"></li>
<li id="fn8"></li>
</ol>
</section>
</body>
</html>
