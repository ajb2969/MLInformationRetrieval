<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="173">Job shop scheduling</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Job shop scheduling</h1>
<hr/>

<p><strong>Job shop scheduling</strong> (or job-shop problem) is an optimization problem in <a href="computer_science" title="wikilink">computer science</a> and <a href="Operations_Research" title="wikilink">operations research</a> in which ideal jobs are assigned to resources at particular times. The most basic version is as follows:</p>

<p>We are given <em>n</em> jobs <em>J</em><sub>1</sub>,Â <em>J</em><sub>2</sub>,Â ...,Â <em>J<sub>n</sub></em> of varying sizes, which need to be scheduled on <em>m</em> identical machines, while trying to minimize the makespan. The makespan is the total length of the schedule (that is, when all the jobs have finished processing). Nowadays, the problem is presented as an <a href="online_problem" title="wikilink">online problem</a> (dynamic scheduling), that is, each job is presented, and the <a href="online_algorithm" title="wikilink">online algorithm</a> needs to make a decision about that job before the next job is presented.</p>

<p>This problem is one of the best known online problems, and was the first problem for which <a href="Competitive_analysis_(online_algorithm)" title="wikilink">competitive analysis</a> was presented, by Graham in 1966.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Best problem instances for basic model with makespan objective are due to Taillard.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="problem-variations">Problem variations</h2>

<p>Many variations of the problem exist, including the following:</p>
<ul>
<li>Machines can be related, independent, equal</li>
<li>Machines can require a certain gap between jobs or no idle-time</li>
<li>Machines can have <a href="sequence-dependent_setup" title="wikilink">sequence-dependent setups</a></li>
<li>Objective function can be to minimize the makespan, the <a href="Lp_space" title="wikilink"><em>L<sub>p</sub></em></a> norm, tardiness, maximum lateness etc. It can also be multi-objective optimization problem</li>
<li>Jobs may have constraints, for example a job <em>i</em> needs to finish before job <em>j</em> can be started (see <a class="uri" href="workflow" title="wikilink">workflow</a>). Also, the objective function can be multi-criteria.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></li>
<li>Jobs and machines have mutual constraints, for example, certain jobs can be scheduled on some machines only</li>
<li>Set of jobs can relate to different set of machines</li>
<li>Deterministic (fixed) processing times or probabilistic processing times</li>
<li>There may also be some other side constraints</li>
</ul>
<h2 id="np-hardness">NP-hardness</h2>

<p>If one already knows that the <a href="travelling_salesman_problem" title="wikilink">travelling salesman problem</a> is NP-hard (as it is), then the job-shop problem with <a href="sequence-dependent_setup" title="wikilink">sequence-dependent setup</a> is clearly also <a class="uri" href="NP-hard" title="wikilink">NP-hard</a>, since the TSP is special case of the JSP with 

<math display="inline" id="Job_shop_scheduling:0">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>m</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   m=1
  </annotation>
 </semantics>
</math>

 (the salesman is the machine and the cities are the jobs).</p>
<h2 id="problem-representation">Problem representation</h2>

<p>The <a href="disjunctive_graph" title="wikilink">disjunctive graph</a> <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> is one of the popular models used for describing the job shop scheduling problem instances.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>A mathematical statement of the problem can be made as follows:</p>

<p>Let 

<math display="inline" id="Job_shop_scheduling:1">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>M</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>M</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">â€¦</mi>
    <mo>,</mo>
    <msub>
     <mi>M</mi>
     <mi>m</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-â€¦</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>m</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=\{M_{1},M_{2},\dots,M_{m}\}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Job_shop_scheduling:2">
 <semantics>
  <mrow>
   <mi>J</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>J</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>J</mi>
     <mn>2</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">â€¦</mi>
    <mo>,</mo>
    <msub>
     <mi>J</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>J</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>J</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>J</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-â€¦</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>J</ci>
      <ci>n</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   J=\{J_{1},J_{2},\dots,J_{n}\}
  </annotation>
 </semantics>
</math>

 be two <a href="Finite_set" title="wikilink">finite</a> <a href="set_(mathematics)" title="wikilink">sets</a>. On account of the industrial origins of the problem, the 

<math display="inline" id="Job_shop_scheduling:3">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle M_{i}
  </annotation>
 </semantics>
</math>


 are called <strong>machines</strong> and the 

<math display="inline" id="Job_shop_scheduling:4">
 <semantics>
  <msub>
   <mi>J</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>J</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle J_{j}
  </annotation>
 </semantics>
</math>

 are called <strong>jobs</strong>.</p>

<p>Let 

<math display="inline" id="Job_shop_scheduling:5">
 <semantics>
  <mpadded lspace="5pt" width="+5pt">
   <mi class="ltx_font_mathcaligraphic">ğ’³</mi>
  </mpadded>
  <annotation-xml encoding="MathML-Content">
   <ci>ğ’³</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\ \mathcal{X}
  </annotation>
 </semantics>
</math>

 denote the set of all sequential assignments of jobs to machines, such that every job is done by every machine exactly once; elements 

<math display="inline" id="Job_shop_scheduling:6">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>âˆˆ</mo>
   <mi class="ltx_font_mathcaligraphic">ğ’³</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>ğ’³</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\mathcal{X}
  </annotation>
 </semantics>
</math>

 may be written as 

<math display="inline" id="Job_shop_scheduling:7">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>Ã—</mo>
   <mi>m</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>n</ci>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\times m
  </annotation>
 </semantics>
</math>

 matrices, in which column 

<math display="inline" id="Job_shop_scheduling:8">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle i
  </annotation>
 </semantics>
</math>


 lists the jobs that machine 

<math display="inline" id="Job_shop_scheduling:9">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle M_{i}
  </annotation>
 </semantics>
</math>

 will do, in order. For example, the matrix</p>

<p>

<math display="block" id="Job_shop_scheduling:10">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mrow>
    <mo>(</mo>
    <mtable displaystyle="true">
     <mtr>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>2</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>2</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>3</mn>
      </mtd>
     </mtr>
     <mtr>
      <mtd columnalign="center">
       <mn>3</mn>
      </mtd>
      <mtd columnalign="center">
       <mn>1</mn>
      </mtd>
     </mtr>
    </mtable>
    <mo>)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <matrix>
     <matrixrow>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
     </matrixrow>
     <matrixrow>
      <cn type="integer">3</cn>
      <cn type="integer">1</cn>
     </matrixrow>
    </matrix>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=\begin{pmatrix}1&2\\
2&3\\
3&1\end{pmatrix}
  </annotation>
 </semantics>
</math>

</p>

<p>means that machine 

<math display="inline" id="Job_shop_scheduling:11">
 <semantics>
  <msub>
   <mi>M</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle M_{1}
  </annotation>
 </semantics>
</math>

 will do the three jobs 

<math display="inline" id="Job_shop_scheduling:12">
 <semantics>
  <mrow>
   <msub>
    <mi>J</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>J</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>J</mi>
    <mn>3</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>J</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>J</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>J</ci>
     <cn type="integer">3</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle J_{1},J_{2},J_{3}
  </annotation>
 </semantics>
</math>

 in the order 

<math display="inline" id="Job_shop_scheduling:13">
 <semantics>
  <mrow>
   <msub>
    <mi>J</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>J</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>J</mi>
    <mn>3</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>J</ci>
     <cn type="integer">1</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>J</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>J</ci>
     <cn type="integer">3</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle J_{1},J_{2},J_{3}
  </annotation>
 </semantics>
</math>


, while machine 

<math display="inline" id="Job_shop_scheduling:14">
 <semantics>
  <msub>
   <mi>M</mi>
   <mn>2</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle M_{2}
  </annotation>
 </semantics>
</math>

 will do the jobs in the order 

<math display="inline" id="Job_shop_scheduling:15">
 <semantics>
  <mrow>
   <msub>
    <mi>J</mi>
    <mn>2</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>J</mi>
    <mn>3</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>J</mi>
    <mn>1</mn>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>J</ci>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>J</ci>
     <cn type="integer">3</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>J</ci>
     <cn type="integer">1</cn>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle J_{2},J_{3},J_{1}
  </annotation>
 </semantics>
</math>

.</p>

<p>Suppose also that there is some <strong>cost function</strong> 

<math display="inline" id="Job_shop_scheduling:16">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>:</mo>
   <mrow>
    <mi class="ltx_font_mathcaligraphic">ğ’³</mi>
    <mo>â†’</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mrow>
      <mo>+</mo>
      <mi mathvariant="normal">âˆ</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>C</ci>
    <apply>
     <ci>normal-â†’</ci>
     <ci>ğ’³</ci>
     <interval closure="closed">
      <cn type="integer">0</cn>
      <apply>
       <plus></plus>
       <infinity></infinity>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C:\mathcal{X}\to[0,+\infty]
  </annotation>
 </semantics>
</math>

. The cost function may be interpreted as a "total processing time", and may have some expression in terms of times 

<math display="inline" id="Job_shop_scheduling:17">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mi>M</mi>
     <mo>Ã—</mo>
     <mi>J</mi>
    </mrow>
    <mo>â†’</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>0</mn>
     <mo>,</mo>
     <mrow>
      <mo>+</mo>
      <mi mathvariant="normal">âˆ</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-â†’</ci>
     <apply>
      <times></times>
      <ci>M</ci>
      <ci>J</ci>
     </apply>
     <interval closure="closed">
      <cn type="integer">0</cn>
      <apply>
       <plus></plus>
       <infinity></infinity>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{ij}:M\times J\to[0,+\infty]
  </annotation>
 </semantics>
</math>

, the cost/time for machine 

<math display="inline" id="Job_shop_scheduling:18">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle M_{i}
  </annotation>
 </semantics>
</math>


 to do job 

<math display="inline" id="Job_shop_scheduling:19">
 <semantics>
  <msub>
   <mi>J</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>J</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle J_{j}
  </annotation>
 </semantics>
</math>

.</p>

<p>The <strong>job-shop problem</strong> is to find an assignment of jobs 

<math display="inline" id="Job_shop_scheduling:20">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>âˆˆ</mo>
   <mi class="ltx_font_mathcaligraphic">ğ’³</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>x</ci>
    <ci>ğ’³</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in\mathcal{X}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Job_shop_scheduling:21">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>C</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle C(x)
  </annotation>
 </semantics>
</math>

 is a minimum, that is, there is no 

<math display="inline" id="Job_shop_scheduling:22">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>âˆˆ</mo>
   <mi class="ltx_font_mathcaligraphic">ğ’³</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>y</ci>
    <ci>ğ’³</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y\in\mathcal{X}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Job_shop_scheduling:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gt></gt>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>y</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle C(x)>C(y)
  </annotation>
 </semantics>
</math>


.</p>
<h2 id="the-problem-of-infinite-cost">The problem of infinite cost</h2>

<p>One of the first problems that must be dealt with in the JSP is that many proposed solutions have infinite cost: i.e., there exists 

<math display="inline" id="Job_shop_scheduling:24">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mi mathvariant="normal">âˆ</mi>
   </msub>
   <mo>âˆˆ</mo>
   <mi class="ltx_font_mathcaligraphic">ğ’³</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <infinity></infinity>
    </apply>
    <ci>ğ’³</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{\infty}\in\mathcal{X}
  </annotation>
 </semantics>
</math>

 such that 

<math display="inline" id="Job_shop_scheduling:25">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>x</mi>
      <mi mathvariant="normal">âˆ</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>+</mo>
    <mi mathvariant="normal">âˆ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <infinity></infinity>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <infinity></infinity>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(x_{\infty})=+\infty
  </annotation>
 </semantics>
</math>

. In fact, it is quite simple to concoct examples of such 

<math display="inline" id="Job_shop_scheduling:26">
 <semantics>
  <msub>
   <mi>x</mi>
   <mi mathvariant="normal">âˆ</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{\infty}
  </annotation>
 </semantics>
</math>

 by ensuring that two machines will <a class="uri" href="deadlock" title="wikilink">deadlock</a>, so that each waits for the output of the other's next step.</p>
<h2 id="major-results">Major results</h2>

<p>Graham had already provided the List scheduling algorithm in 1966, which is 

<math display="inline" id="Job_shop_scheduling:27">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi mathvariant="normal">âˆ’</mi>
     <mn>1</mn>
    </mrow>
    <mo>/</mo>
    <mi>m</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>normal-âˆ’</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (2âˆ’1/m)
  </annotation>
 </semantics>
</math>

-competitive, where m is the number of machines.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Also, it was proved that List scheduling is optimum online algorithm for 2 and 3 machines. The <a href="Coffmanâ€“Graham_algorithm" title="wikilink">Coffmanâ€“Graham algorithm</a> (1972) for uniform-length jobs is also optimum for two machines, and is 

<math display="inline" id="Job_shop_scheduling:28">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi mathvariant="normal">âˆ’</mi>
     <mn>2</mn>
    </mrow>
    <mo>/</mo>
    <mi>m</mi>
   </mrow>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <cn type="integer">2</cn>
     <ci>normal-âˆ’</ci>
     <cn type="integer">2</cn>
    </apply>
    <ci>m</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (2âˆ’2/m)
  </annotation>
 </semantics>
</math>


-competitive.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> In 1992, Bartal, Fiat, Karloff and Vohra presented an algorithm that is 1.986 competitive.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> A 1.945-competitive algorithm was presented by Karger, Philips and Torng in 1994.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> In 1992, Albers provided a different algorithm that is 1.923-competitive.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> Currently, the best known result is an algorithm given by Fleischer and Wahl, which achieves a competitive ratio of 1.9201.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>A lower bound of 1.852 was presented by Albers.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> Taillard instances has an important role in developing job shop scheduling with makespan objective.</p>

<p>In 1976 Garey provided a proof<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> that this problem is <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> for m&gt;2, that is, no optimal solution can be computed in polynomial time for three or more machines (unless <a class="uri" href="P=NP" title="wikilink">P=NP</a>).</p>
<h2 id="offline-makespan-minimization">Offline makespan minimization</h2>
<h3 id="atomic-jobs">Atomic jobs</h3>

<p>The simplest form of the offline makespan minimisation problem deals with atomic jobs, that is, jobs that are not subdivided into multiple operations. It is equivalent to packing a number of items of various different sizes into a fixed number of bins, such that the maximum bin size needed is as small as possible. (If instead the number of bins is to be minimised, and the bin size is fixed, the problem becomes a different problem, known as the <a href="bin_packing_problem" title="wikilink">bin packing problem</a>.)</p>

<p><a href="Dorit_S._Hochbaum" title="wikilink">Dorit S. Hochbaum</a> and <a href="David_Shmoys" title="wikilink">David Shmoys</a> presented a <a href="polynomial-time_approximation_scheme" title="wikilink">polynomial-time approximation scheme</a> in 1987 that finds an approximate solution to the offline makespan minimisation problem with atomic jobs to any desired degree of accuracy.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a></p>
<h3 id="jobs-consisting-of-multiple-operations">Jobs consisting of multiple operations</h3>

<p>The basic form of the problem of scheduling jobs with multiple (M) operations, over M machines, such that all of the first operations must be done on the first machine, all of the second operations on the second, etc., and a single job cannot be performed in parallel, is known as the <strong><a href="open_shop_scheduling" title="wikilink">open shop scheduling</a></strong> problem. Various algorithms exist, including <a href="genetic_algorithm" title="wikilink">genetic algorithms</a>.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<h4 id="johnsons-algorithm">Johnson's algorithm</h4>

<p>A heuristic algorithm by S. M. Johnson can be used to solve the case of a 2 machine N job problem when all jobs are to be processed in the same order.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> The steps of algorithm are as follows:</p>

<p>Job P<sub>i</sub> has two operations, of duration P<sub>i1</sub>, P<sub>i2</sub>, to be done on Machine M1, M2 in that sequence.</p>
<ul>
<li><em>Step 1.</em> List A = { 1, 2, â€¦, N }, List L1 = {}, List L2 = {}.</li>
</ul>
<ul>
<li><em>Step 2.</em> From all available operation durations, pick the minimum.</li>
</ul>

<p>If the minimum belongs to P<sub>k1</sub>,</p>

<p>Remove K from list A; Add K to beginning of List L1.</p>

<p>If minimum belongs to P<sub>k2</sub>,</p>

<p>Remove K from list A; Add K to end of List L2.</p>
<ul>
<li><em>Step 3.</em> Repeat Step 2 until List A is empty.</li>
</ul>
<ul>
<li><em>Step 4.</em> Join List L1, List L2. This is the optimum sequence.</li>
</ul>

<p>Johnson's method only works optimally for two machines. However, since it is optimal, and easy to compute, some researchers have tried to adopt it for M machines, (<em>M</em>Â &gt;Â 2.)</p>

<p>The idea is as follows: Imagine that each job requires m operations in sequence, on M1, M2 â€¦ Mm. We combine the first <em>m</em>/2 machines into an (imaginary) Machining center, MC1, and the remaining Machines into a Machining Center MC2. Then the total processing time for a Job P on MC1 = sum( operation times on first <em>m</em>/2 machines), and processing time for Job P on MC2 = sum(operation times on last <em>m</em>/2 machines).</p>

<p>By doing so, we have reduced the m-Machine problem into a Two Machining center scheduling problem. We can solve this using Johnson's method.</p>
<h2 id="example">Example</h2>

<p>Here is an example of a job shop scheduling problem formulated in <a class="uri" href="AMPL" title="wikilink">AMPL</a> as a <a href="Linear_programming#Integer_unknowns" title="wikilink">mixed-integer programming</a> problem with indicator constraints:</p>

<p><code>paramÂ N_JOBS;</code><br/>
<code>paramÂ N_MACHINES;</code><br/>
<br/>
<code>setÂ JOBSÂ orderedÂ =Â 1..N_JOBS;</code><br/>
<code>setÂ MACHINESÂ orderedÂ =Â 1..N_MACHINES;</code><br/>
<br/>
<code>paramÂ ProcessingTime{JOBS,Â MACHINES}Â &gt;Â 0;</code><br/>
<br/>
<code>paramÂ CumulativeTime{iÂ inÂ JOBS,Â jÂ inÂ MACHINES}Â =</code><br/>
<code>Â Â Â sumÂ {jjÂ inÂ MACHINES:Â ord(jj)Â </code><code>Â i2}Â =</code><br/>
<code>Â Â Â maxÂ {jÂ inÂ MACHINES}</code><br/>
<code>Â Â Â Â Â (CumulativeTime[i1,j]Â -Â CumulativeTime[i2,j]Â +Â ProcessingTime[i2,j]);</code><br/>
<br/>
<code>varÂ endÂ &gt;=Â 0;</code><br/>
<code>varÂ start{JOBS}Â &gt;=Â 0;</code><br/>
<code>varÂ precedes{i1Â inÂ JOBS,Â i2Â inÂ JOBS:Â ord(i1)Â </code><code>=Â start[i]Â +Â sum{jÂ inÂ MACHINES}Â ProcessingTime[i,j];</code><br/>
<br/>
<code>subjÂ toÂ no12_conflict{i1Â inÂ JOBS,Â i2Â inÂ JOBS:Â ord(i1)Â </code><code>Â start[i2]Â &gt;=Â start[i1]Â +Â TimeOffset[i1,i2];</code><br/>
<br/>
<code>subjÂ toÂ no21_conflict{i1Â inÂ JOBS,Â i2Â inÂ JOBS:Â ord(i1)Â </code><code>Â start[i1]Â &gt;=Â start[i2]Â +Â TimeOffset[i2,i1];</code><br/>
<br/>
<code>data;</code><br/>
<br/>
<code>paramÂ N_JOBSÂ :=Â 4;</code><br/>
<code>paramÂ N_MACHINESÂ :=Â 3;</code><br/>
<br/>
<code>paramÂ ProcessingTime:</code><br/>
<code>Â Â 1Â 2Â 3Â :=</code><br/>
<code>1Â 4Â 2Â 1</code><br/>
<code>2Â 3Â 6Â 2</code><br/>
<code>3Â 7Â 2Â 3</code><br/>
<code>4Â 1Â 5Â 8;</code></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Disjunctive_graph" title="wikilink">Disjunctive graph</a></li>
<li><a href="Dynamic_programming" title="wikilink">Dynamic programming</a></li>
<li><a href="Flow_shop_scheduling" title="wikilink">Flow shop scheduling</a></li>
<li><a href="Genetic_algorithm_scheduling" title="wikilink">Genetic algorithm scheduling</a></li>
<li><a href="List_of_NP-complete_problems" title="wikilink">List of NP-complete problems</a></li>
<li><a href="Open_shop_scheduling" title="wikilink">Open shop scheduling</a></li>
<li><a href="Optimal_control" title="wikilink">Optimal control</a></li>
<li><a href="Scheduling_(production_processes)" title="wikilink">Scheduling (production processes)</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.mat.univie.ac.at/~neum/glopt/software_g.html">University of Vienna</a> Directory of methodologies, systems and software for dynamic optimization.</li>
<li><a href="http://mistic.heig-vd.ch/taillard/problemes.dir/ordonnancement.dir/jobshop.dir/best_lb_up.txt">Taillard instances</a></li>
</ul>

<p><a href="pt:Escalonamento_de_Job_Shop" title="wikilink">pt:Escalonamento de Job Shop</a>"</p>

<p><a href="Category:Operations_research" title="wikilink">Category:Operations research</a> <a href="Category:Mathematical_optimization" title="wikilink">Category:Mathematical optimization</a> <a href="Category:Optimization_algorithms_and_methods" title="wikilink">Category:Optimization algorithms and methods</a> <a href="Category:Combinatorial_optimization" title="wikilink">Category:Combinatorial optimization</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">â†©</a></li>
<li id="fn2"><a href="#fnref2">â†©</a></li>
<li id="fn3"><a href="#fnref3">â†©</a></li>
<li id="fn4">B. Roy, B. Sussmann, Les problÃ¨mes dâ€™ordonnancement avec constraintes disjonctives, SEMA, Note D.S., No. 9, Paris, 1964.<a href="#fnref4">â†©</a></li>
<li id="fn5">Jacek BÅ‚aÅ¼ewicz, Erwin Pesch, MaÅ‚gorzata Sterna, The disjunctive graph machine representation of the job shop scheduling problem, European Journal of Operational Research, Volume 127, Issue 2, 1 December 2000, Pages 317-331, ISSN 0377-2217, 10.1016/S0377-2217(99)00486-5.<a href="#fnref5">â†©</a></li>
<li id="fn6"></li>
<li id="fn7">.<a href="#fnref7">â†©</a></li>
<li id="fn8">.<a href="#fnref8">â†©</a></li>
<li id="fn9"><a href="#fnref9">â†©</a></li>
<li id="fn10"><a href="#fnref10">â†©</a></li>
<li id="fn11"><a href="#fnref11">â†©</a></li>
<li id="fn12"><a href="#fnref12">â†©</a></li>
<li id="fn13"><a href="#fnref13">â†©</a></li>
<li id="fn14"><a href="#fnref14">â†©</a></li>
<li id="fn15"><a href="#fnref15">â†©</a></li>
<li id="fn16"><a href="#fnref16">â†©</a></li>
<li id="fn17">S.M. Johnson, Optimal two- and three-stage production schedules with setup times included, Naval Res. Log. Quart. I(1954)61-68.<a href="#fnref17">â†©</a></li>
</ol>
</section>
</body>
</html>
