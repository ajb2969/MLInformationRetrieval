<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1024">Dynamic logic (modal logic)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Dynamic logic (modal logic)</h1>
<hr/>

<p><strong>Dynamic logic</strong> is an extension of <a href="modal_logic" title="wikilink">modal logic</a> originally intended for reasoning about computer programs and later applied to more general complex behaviors arising in <a class="uri" href="linguistics" title="wikilink">linguistics</a>, <a class="uri" href="philosophy" title="wikilink">philosophy</a>, <a href="Artificial_intelligence" title="wikilink">AI</a>, and other fields.</p>
<h2 id="language">Language</h2>

<p><a href="Modal_logic" title="wikilink">Modal logic</a> is characterized by the <a href="modal_operator" title="wikilink">modal operators</a> 

<math display="inline" id="Dynamic_logic_(modal_logic):0">
 <semantics>
  <mrow>
   <mi mathvariant="normal">□</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-□</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Box p
  </annotation>
 </semantics>
</math>

 (box p) asserting that 

<math display="inline" id="Dynamic_logic_(modal_logic):1">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 is necessarily the case, and 

<math display="inline" id="Dynamic_logic_(modal_logic):2">
 <semantics>
  <mrow>
   <mi mathvariant="normal">◇</mi>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-◇</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Diamond p
  </annotation>
 </semantics>
</math>

 (diamond p) asserting that 

<math display="inline" id="Dynamic_logic_(modal_logic):3">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 is possibly the case. Dynamic logic extends this by associating to every action 

<math display="inline" id="Dynamic_logic_(modal_logic):4">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 the modal operators 

<math display="inline" id="Dynamic_logic_(modal_logic):5">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>a</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [a]\,\!
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dynamic_logic_(modal_logic):6">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>a</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-⟨⟩</csymbol>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle a\rangle\,\!
  </annotation>
 </semantics>
</math>

, thereby making it a <a href="multimodal_logic" title="wikilink">multimodal logic</a>. The meaning of 

<math display="inline" id="Dynamic_logic_(modal_logic):7">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>a</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>a</ci>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [a]p\,\!
  </annotation>
 </semantics>
</math>

 is that after performing action 

<math display="inline" id="Dynamic_logic_(modal_logic):8">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 it is necessarily the case that 

<math display="inline" id="Dynamic_logic_(modal_logic):9">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 holds, that is, 

<math display="inline" id="Dynamic_logic_(modal_logic):10">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 must bring about 

<math display="inline" id="Dynamic_logic_(modal_logic):11">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

. The meaning of 

<math display="inline" id="Dynamic_logic_(modal_logic):12">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>a</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">delimited-⟨⟩</csymbol>
     <ci>a</ci>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle a\rangle p\,\!
  </annotation>
 </semantics>
</math>

 is that after performing 

<math display="inline" id="Dynamic_logic_(modal_logic):13">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 it is possible that 

<math display="inline" id="Dynamic_logic_(modal_logic):14">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 holds, that is, 

<math display="inline" id="Dynamic_logic_(modal_logic):15">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 might bring about 

<math display="inline" id="Dynamic_logic_(modal_logic):16">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

. These operators are related by 

<math display="inline" id="Dynamic_logic_(modal_logic):17">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>a</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>p</mi>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>a</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>a</ci>
     </apply>
     <ci>p</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <not></not>
      <ci>a</ci>
     </apply>
     <not></not>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [a]p\equiv\neg\langle a\rangle\neg p\,\!
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dynamic_logic_(modal_logic):18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>a</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>p</mi>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>a</mi>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <ci>a</ci>
     </apply>
     <ci>p</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <not></not>
      <ci>a</ci>
     </apply>
     <not></not>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle a\rangle p\equiv\neg[a]\neg p\,\!
  </annotation>
 </semantics>
</math>

, analogously to the relationship between the universal (

<math display="inline" id="Dynamic_logic_(modal_logic):19">
 <semantics>
  <mo>∀</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">for-all</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall\,\!
  </annotation>
 </semantics>
</math>

) and existential (

<math display="inline" id="Dynamic_logic_(modal_logic):20">
 <semantics>
  <mo>∃</mo>
  <annotation-xml encoding="MathML-Content">
   <exists></exists>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists\,\!
  </annotation>
 </semantics>
</math>

) quantifiers.</p>

<p>Dynamic logic permits compound actions built up from smaller actions. While the basic control operators of any programming language could be used for this purpose, Kleene's <a href="regular_expression" title="wikilink">regular expression</a> operators are a good match to modal logic. Given actions 

<math display="inline" id="Dynamic_logic_(modal_logic):21">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dynamic_logic_(modal_logic):22">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\,\!
  </annotation>
 </semantics>
</math>

, the compound action 

<math display="inline" id="Dynamic_logic_(modal_logic):23">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∪</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\cup b\,\!
  </annotation>
 </semantics>
</math>

, <em>choice</em>, also written 

<math display="inline" id="Dynamic_logic_(modal_logic):24">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>+</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a+b\,\!
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Dynamic_logic_(modal_logic):25">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo stretchy="false">|</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <ci>normal-|</ci>
    <csymbol cd="unknown">b</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a|b\,\!
  </annotation>
 </semantics>
</math>

, is performed by performing one of 

<math display="inline" id="Dynamic_logic_(modal_logic):26">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Dynamic_logic_(modal_logic):27">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\,\!
  </annotation>
 </semantics>
</math>

. The compound action 

<math display="inline" id="Dynamic_logic_(modal_logic):28">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>;</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <ci>a</ci>
    <ci>b</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a;b\,\!
  </annotation>
 </semantics>
</math>

, <em>sequence</em>, is performed by performing first 

<math display="inline" id="Dynamic_logic_(modal_logic):29">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 and then 

<math display="inline" id="Dynamic_logic_(modal_logic):30">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\,\!
  </annotation>
 </semantics>
</math>

. The compound action 

<math display="inline" id="Dynamic_logic_(modal_logic):31">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>*</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <times></times>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a*\,\!
  </annotation>
 </semantics>
</math>

, <em>iteration</em>, is performed by performing 

<math display="inline" id="Dynamic_logic_(modal_logic):32">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 zero or more times, sequentially. The constant action 

<math display="inline" id="Dynamic_logic_(modal_logic):33">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\,\!
  </annotation>
 </semantics>
</math>

 or <strong>BLOCK</strong> does nothing and does not terminate, whereas the constant action 

<math display="inline" id="Dynamic_logic_(modal_logic):34">
 <semantics>
  <mn>1</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">1</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1\,\!
  </annotation>
 </semantics>
</math>

 or <strong>SKIP</strong> or <strong>NOP</strong>, definable as 

<math display="inline" id="Dynamic_logic_(modal_logic):35">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>*</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cn type="integer">0</cn>
    <times></times>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0*\,\!
  </annotation>
 </semantics>
</math>

, does nothing but does terminate.</p>
<h2 id="axioms">Axioms</h2>

<p>These operators can be axiomatized in dynamic logic as follows, taking as already given a suitable axiomatization of <a href="modal_logic" title="wikilink">modal logic</a> including such axioms for modal operators as the above-mentioned axiom 

<math display="inline" id="Dynamic_logic_(modal_logic):36">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>a</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>p</mi>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>a</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>a</ci>
     </apply>
     <ci>p</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <not></not>
      <ci>a</ci>
     </apply>
     <not></not>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [a]p\equiv\neg\langle a\rangle\neg p\,\!
  </annotation>
 </semantics>
</math>

 and the two inference rules <em>modus ponens</em> (

<math display="inline" id="Dynamic_logic_(modal_logic):37">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⊢</mo>
   <mpadded width="-1.7pt">
    <mi>p</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash p\!
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dynamic_logic_(modal_logic):38">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⊢</mo>
   <mrow>
    <mi>p</mi>
    <mo>→</mo>
    <mpadded width="-1.7pt">
     <mi>q</mi>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <ci>normal-→</ci>
     <ci>p</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash p\to q\!
  </annotation>
 </semantics>
</math>

 implies 

<math display="inline" id="Dynamic_logic_(modal_logic):39">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⊢</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash q\,\!
  </annotation>
 </semantics>
</math>

) and <em>necessitation</em> (

<math display="inline" id="Dynamic_logic_(modal_logic):40">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⊢</mo>
   <mpadded width="-1.7pt">
    <mi>p</mi>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash p\!
  </annotation>
 </semantics>
</math>

 implies 

<math display="inline" id="Dynamic_logic_(modal_logic):41">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>⊢</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>a</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="latexml">absent</csymbol>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>a</ci>
     </apply>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vdash[a]p\,\!
  </annotation>
 </semantics>
</math>

).</p>

<p>A1. 

<math display="inline" id="Dynamic_logic_(modal_logic):42">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>0</mn>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <cn type="integer">0</cn>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [0]p\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>A2. 

<math display="inline" id="Dynamic_logic_(modal_logic):43">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mn>1</mn>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>p</mi>
   </mrow>
   <mo>≡</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <cn type="integer">1</cn>
     </apply>
     <ci>p</ci>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [1]p\equiv p\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>A3. 

<math display="inline" id="Dynamic_logic_(modal_logic):44">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>a</mi>
      <mo>∪</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>p</mi>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>a</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mi>p</mi>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>b</mi>
      <mo stretchy="false">]</mo>
     </mrow>
     <mi>p</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <apply>
       <union></union>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>p</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>a</ci>
      </apply>
      <ci>p</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <ci>b</ci>
      </apply>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [a\cup b]p\equiv[a]p\land[b]p\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>A4. 

<math display="inline" id="Dynamic_logic_(modal_logic):45">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>a</mi>
     <mo>;</mo>
     <mi>b</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>p</mi>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>a</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>b</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <list>
      <ci>a</ci>
      <ci>b</ci>
     </list>
     <ci>p</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>b</ci>
     </apply>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [a;b]p\equiv[a][b]p\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>A5. 

<math display="inline" id="Dynamic_logic_(modal_logic):46">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>a</mi>
    <mo>*</mo>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>p</mi>
   <mo>≡</mo>
   <mi>p</mi>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>a</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>a</mi>
    <mo>*</mo>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">a</csymbol>
     <times></times>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">p</csymbol>
    <equivalent></equivalent>
    <csymbol cd="unknown">p</csymbol>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">a</csymbol>
     <times></times>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">p</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [a*]p\equiv p\land[a][a*]p\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>A6. 

<math display="inline" id="Dynamic_logic_(modal_logic):47">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>a</mi>
    <mo>*</mo>
    <mo stretchy="false">]</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>a</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>a</mi>
    <mo>*</mo>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">a</csymbol>
     <times></times>
     <ci>normal-]</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">a</csymbol>
     <times></times>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">p</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\land[a*](p\to[a]p)\to[a*]p\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>Axiom A1 makes the empty promise that when <strong>BLOCK</strong> terminates, 

<math display="inline" id="Dynamic_logic_(modal_logic):48">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 will hold, even if 

<math display="inline" id="Dynamic_logic_(modal_logic):49">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 is the proposition <strong>false</strong>. (Thus <strong>BLOCK</strong> abstracts the essence of the action of hell freezing over.)<br/>
A2 says that <strong>[NOP]</strong> acts as the identity function on propositions, that is, it transforms 

<math display="inline" id="Dynamic_logic_(modal_logic):50">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 into itself.<br/>
A3 says that if doing one of 

<math display="inline" id="Dynamic_logic_(modal_logic):51">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Dynamic_logic_(modal_logic):52">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\,\!
  </annotation>
 </semantics>
</math>

 must bring about 

<math display="inline" id="Dynamic_logic_(modal_logic):53">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Dynamic_logic_(modal_logic):54">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 must bring about 

<math display="inline" id="Dynamic_logic_(modal_logic):55">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 and likewise for 

<math display="inline" id="Dynamic_logic_(modal_logic):56">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\,\!
  </annotation>
 </semantics>
</math>

, and conversely.<br/>
A4 says that if doing 

<math display="inline" id="Dynamic_logic_(modal_logic):57">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 and then 

<math display="inline" id="Dynamic_logic_(modal_logic):58">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\,\!
  </annotation>
 </semantics>
</math>

 must bring about 

<math display="inline" id="Dynamic_logic_(modal_logic):59">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Dynamic_logic_(modal_logic):60">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 must bring about a situation in which 

<math display="inline" id="Dynamic_logic_(modal_logic):61">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\,\!
  </annotation>
 </semantics>
</math>

 must bring about 

<math display="inline" id="Dynamic_logic_(modal_logic):62">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

.<br/>
A5 is the evident result of applying A2, A3 and A4 to the equation 

<math display="inline" id="Dynamic_logic_(modal_logic):63">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>*</mo>
   <mo>=</mo>
   <mn>1</mn>
   <mo>∪</mo>
   <mi>a</mi>
   <mo>;</mo>
   <mi>a</mi>
   <mo>*</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <times></times>
    <eq></eq>
    <cn type="integer">1</cn>
    <union></union>
    <csymbol cd="unknown">a</csymbol>
    <ci>normal-;</ci>
    <csymbol cd="unknown">a</csymbol>
    <times></times>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a*=1\cup a;a*\,\!
  </annotation>
 </semantics>
</math>

 of <a href="Kleene_algebra" title="wikilink">Kleene algebra</a>.<br/>
A6 asserts that if 

<math display="inline" id="Dynamic_logic_(modal_logic):64">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 holds now, and no matter how often we perform 

<math display="inline" id="Dynamic_logic_(modal_logic):65">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 it remains the case that the truth of 

<math display="inline" id="Dynamic_logic_(modal_logic):66">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 after that performance entails its truth after one more performance of 

<math display="inline" id="Dynamic_logic_(modal_logic):67">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Dynamic_logic_(modal_logic):68">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 must remain true no matter how often we perform 

<math display="inline" id="Dynamic_logic_(modal_logic):69">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

. A6 is recognizable as <a href="mathematical_induction" title="wikilink">mathematical induction</a> with the action <strong>n := n+1</strong> of incrementing <strong>n</strong> generalized to arbitrary actions 

<math display="inline" id="Dynamic_logic_(modal_logic):70">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="derivations">Derivations</h2>

<p>The modal logic axiom 

<math display="inline" id="Dynamic_logic_(modal_logic):71">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>a</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>p</mi>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>a</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
    </mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>a</ci>
     </apply>
     <ci>p</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <not></not>
      <ci>a</ci>
     </apply>
     <not></not>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [a]p\equiv\neg\langle a\rangle\neg p\,\!
  </annotation>
 </semantics>
</math>

 permits the derivation of the following six theorems corresponding to the above:</p>

<p>T1. 

<math display="inline" id="Dynamic_logic_(modal_logic):72">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mn>0</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
   </mrow>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <not></not>
     <cn type="integer">0</cn>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg\langle 0\rangle p\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>T2. 

<math display="inline" id="Dynamic_logic_(modal_logic):73">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mn>1</mn>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>p</mi>
   </mrow>
   <mo>≡</mo>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <cn type="integer">1</cn>
     </apply>
     <ci>p</ci>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle 1\rangle p\equiv p\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>T3. 

<math display="inline" id="Dynamic_logic_(modal_logic):74">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>a</mi>
      <mo>∪</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>p</mi>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>a</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mi>p</mi>
    </mrow>
    <mo>∨</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>b</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mi>p</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <apply>
       <union></union>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
     </apply>
     <ci>p</ci>
    </apply>
    <apply>
     <or></or>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">delimited-⟨⟩</csymbol>
       <ci>a</ci>
      </apply>
      <ci>p</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">delimited-⟨⟩</csymbol>
       <ci>b</ci>
      </apply>
      <ci>p</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle a\cup b\rangle p\equiv\langle a\rangle p\lor\langle b\rangle p\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>T4. 

<math display="inline" id="Dynamic_logic_(modal_logic):75">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>a</mi>
     <mo>;</mo>
     <mi>b</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>p</mi>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>a</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>b</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <list>
      <ci>a</ci>
      <ci>b</ci>
     </list>
     <ci>p</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <ci>a</ci>
     </apply>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <ci>b</ci>
     </apply>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle a;b\rangle p\equiv\langle a\rangle\langle b\rangle p\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>T5. 

<math display="inline" id="Dynamic_logic_(modal_logic):76">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>a</mi>
    <mo>*</mo>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>p</mi>
   <mo>≡</mo>
   <mi>p</mi>
   <mo>∨</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>a</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>a</mi>
    <mo>*</mo>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">a</csymbol>
     <times></times>
     <ci>normal-⟩</ci>
    </cerror>
    <csymbol cd="unknown">p</csymbol>
    <equivalent></equivalent>
    <csymbol cd="unknown">p</csymbol>
    <or></or>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-⟩</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">a</csymbol>
     <times></times>
     <ci>normal-⟩</ci>
    </cerror>
    <csymbol cd="unknown">p</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle a*\rangle p\equiv p\lor\langle a\rangle\langle a*\rangle p\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>T6. 

<math display="inline" id="Dynamic_logic_(modal_logic):77">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>a</mi>
    <mo>*</mo>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>p</mi>
   <mo>→</mo>
   <mi>p</mi>
   <mo>∨</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>a</mi>
    <mo>*</mo>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">¬</mi>
    <mi>p</mi>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>a</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">a</csymbol>
     <times></times>
     <ci>normal-⟩</ci>
    </cerror>
    <csymbol cd="unknown">p</csymbol>
    <ci>normal-→</ci>
    <csymbol cd="unknown">p</csymbol>
    <or></or>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">a</csymbol>
     <times></times>
     <ci>normal-⟩</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <not></not>
     <csymbol cd="unknown">p</csymbol>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-⟨</ci>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-⟩</ci>
     </cerror>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle a*\rangle p\to p\lor\langle a*\rangle(\neg p\land\langle a\rangle p)\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>T1 asserts the impossibility of bringing anything about by performing <strong>BLOCK</strong>.<br/>
T2 notes again that <strong>NOP</strong> changes nothing, bearing in mind that <strong>NOP</strong> is both deterministic and terminating whence 

<math display="inline" id="Dynamic_logic_(modal_logic):78">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mn>1</mn>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [1]\,\!
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dynamic_logic_(modal_logic):79">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mn>1</mn>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-⟨⟩</csymbol>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle 1\rangle\,\!
  </annotation>
 </semantics>
</math>

 have the same force.<br/>
T3 says that if the choice of 

<math display="inline" id="Dynamic_logic_(modal_logic):80">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Dynamic_logic_(modal_logic):81">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\,\!
  </annotation>
 </semantics>
</math>

 could bring about 

<math display="inline" id="Dynamic_logic_(modal_logic):82">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

, then either 

<math display="inline" id="Dynamic_logic_(modal_logic):83">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Dynamic_logic_(modal_logic):84">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\,\!
  </annotation>
 </semantics>
</math>

 alone could bring about 

<math display="inline" id="Dynamic_logic_(modal_logic):85">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

.<br/>
T4 is just like A4.<br/>
T5 is explained as for A5.<br/>
T6 asserts that if it is possible to bring about 

<math display="inline" id="Dynamic_logic_(modal_logic):86">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 by performing 

<math display="inline" id="Dynamic_logic_(modal_logic):87">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 sufficiently often, then either 

<math display="inline" id="Dynamic_logic_(modal_logic):88">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 is true now or it is possible to perform 

<math display="inline" id="Dynamic_logic_(modal_logic):89">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 repeatedly to bring about a situation where 

<math display="inline" id="Dynamic_logic_(modal_logic):90">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 is (still) false but one more performance of 

<math display="inline" id="Dynamic_logic_(modal_logic):91">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 could bring about 

<math display="inline" id="Dynamic_logic_(modal_logic):92">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

.</p>

<p>Box and diamond are entirely symmetric with regard to which one takes as primitive. An alternative axiomatization would have been to take the theorems T1-T6 as axioms, from which we could then have derived A1-A6 as theorems.</p>

<p>The difference between implication and inference is the same in dynamic logic as in any other logic: whereas the implication 

<math display="inline" id="Dynamic_logic_(modal_logic):93">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>→</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>p</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\to q\,\!
  </annotation>
 </semantics>
</math>

 asserts that if 

<math display="inline" id="Dynamic_logic_(modal_logic):94">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 is true then so is 

<math display="inline" id="Dynamic_logic_(modal_logic):95">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\,\!
  </annotation>
 </semantics>
</math>

, the inference 

<math display="inline" id="Dynamic_logic_(modal_logic):96">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>⊢</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>p</ci>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\vdash q\,\!
  </annotation>
 </semantics>
</math>

 asserts that if 

<math display="inline" id="Dynamic_logic_(modal_logic):97">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 is valid then so is 

<math display="inline" id="Dynamic_logic_(modal_logic):98">
 <semantics>
  <mi>q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   q\,\!
  </annotation>
 </semantics>
</math>

. However the dynamic nature of dynamic logic moves this distinction out of the realm of abstract axiomatics into the common-sense experience of situations in flux. The inference rule 

<math display="inline" id="Dynamic_logic_(modal_logic):99">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>⊢</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>a</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proves</csymbol>
    <ci>p</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>a</ci>
     </apply>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\vdash[a]p\,\!
  </annotation>
 </semantics>
</math>

, for example, is sound because its premise asserts that 

<math display="inline" id="Dynamic_logic_(modal_logic):100">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 holds at all times, whence no matter where 

<math display="inline" id="Dynamic_logic_(modal_logic):101">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 might take us, 

<math display="inline" id="Dynamic_logic_(modal_logic):102">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 will be true there. The implication 

<math display="inline" id="Dynamic_logic_(modal_logic):103">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>→</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>a</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>p</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>a</ci>
     </apply>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\to[a]p\,\!
  </annotation>
 </semantics>
</math>

 is not valid, however, because the truth of 

<math display="inline" id="Dynamic_logic_(modal_logic):104">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 at the present moment is no guarantee of its truth after performing 

<math display="inline" id="Dynamic_logic_(modal_logic):105">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

. For example, 

<math display="inline" id="Dynamic_logic_(modal_logic):106">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>→</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>a</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>p</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>p</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>a</ci>
     </apply>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\to[a]p\,\!
  </annotation>
 </semantics>
</math>

 will be true in any situation where 

<math display="inline" id="Dynamic_logic_(modal_logic):107">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 is false, or in any situation where 

<math display="inline" id="Dynamic_logic_(modal_logic):108">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>a</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>a</ci>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [a]p\,\!
  </annotation>
 </semantics>
</math>

 is true, but the assertion 

<math display="inline" id="Dynamic_logic_(modal_logic):109">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>x</mi>
    <mo>+</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>normal-]</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x=1)\to[x:=x+1](x=1)\,\!
  </annotation>
 </semantics>
</math>

 is false in any situation where 

<math display="inline" id="Dynamic_logic_(modal_logic):110">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\,\!
  </annotation>
 </semantics>
</math>

 has value 1, and therefore is not valid.</p>
<h2 id="derived-rules-of-inference">Derived rules of inference</h2>

<p>As for modal logic, the inference rules <em>modus ponens</em> and <em>necessitation</em> suffice also for dynamic logic as the only primitive rules it needs, as noted above. However, as usual in logic, many more rules can be derived from these with the help of the axioms. An example instance of such a derived rule in dynamic logic is that if kicking a broken TV once can't possibly fix it, then repeatedly kicking it can't possibly fix it either. Writing 

<math display="inline" id="Dynamic_logic_(modal_logic):111">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k\,\!
  </annotation>
 </semantics>
</math>

 for the action of kicking the TV, and 

<math display="inline" id="Dynamic_logic_(modal_logic):112">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\,\!
  </annotation>
 </semantics>
</math>

 for the proposition that the TV is broken, dynamic logic expresses this inference as 

<math display="inline" id="Dynamic_logic_(modal_logic):113">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>k</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>b</mi>
   <mo>⊢</mo>
   <mi>b</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>k</mi>
    <mo>*</mo>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">b</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">k</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">b</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="unknown">b</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">k</csymbol>
     <times></times>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">b</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\to[k]b\vdash b\to[k*]b\,\!
  </annotation>
 </semantics>
</math>

, having as premise 

<math display="inline" id="Dynamic_logic_(modal_logic):114">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>→</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>k</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>b</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>k</ci>
     </apply>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\to[k]b\,\!
  </annotation>
 </semantics>
</math>

 and as conclusion 

<math display="inline" id="Dynamic_logic_(modal_logic):115">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>k</mi>
    <mo>*</mo>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">b</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">k</csymbol>
     <times></times>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">b</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\to[k*]b\,\!
  </annotation>
 </semantics>
</math>

. The meaning of 

<math display="inline" id="Dynamic_logic_(modal_logic):116">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>k</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>k</ci>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [k]b\,\!
  </annotation>
 </semantics>
</math>

 is that it is guaranteed that after kicking the TV, it is broken. Hence the premise 

<math display="inline" id="Dynamic_logic_(modal_logic):117">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>→</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>k</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>b</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>k</ci>
     </apply>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\to[k]b\,\!
  </annotation>
 </semantics>
</math>

 means that if the TV is broken, then after kicking it once it will still be broken. 

<math display="inline" id="Dynamic_logic_(modal_logic):118">
 <semantics>
  <mrow>
   <mi>k</mi>
   <mo>*</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">k</csymbol>
    <times></times>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k*\,\!
  </annotation>
 </semantics>
</math>

 denotes the action of kicking the TV zero or more times. Hence the conclusion 

<math display="inline" id="Dynamic_logic_(modal_logic):119">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>k</mi>
    <mo>*</mo>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">b</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">k</csymbol>
     <times></times>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">b</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\to[k*]b\,\!
  </annotation>
 </semantics>
</math>

 means that if the TV is broken, then after kicking it zero or more times it will still be broken. For if not, then after the second-to-last kick the TV would be in a state where kicking it once more would fix it, which the premise claims can never happen under any circumstances.</p>

<p>The inference 

<math display="inline" id="Dynamic_logic_(modal_logic):120">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>k</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>b</mi>
   <mo>⊢</mo>
   <mi>b</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>k</mi>
    <mo>*</mo>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">b</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">k</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">b</csymbol>
    <csymbol cd="latexml">proves</csymbol>
    <csymbol cd="unknown">b</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">k</csymbol>
     <times></times>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">b</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\to[k]b\vdash b\to[k*]b\,\!
  </annotation>
 </semantics>
</math>

 is sound. However the implication 

<math display="inline" id="Dynamic_logic_(modal_logic):121">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>k</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>k</mi>
     <mo>*</mo>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">k</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">k</csymbol>
      <times></times>
      <ci>normal-]</ci>
     </cerror>
     <csymbol cd="unknown">b</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (b\to[k]b)\to(b\to[k*]b)\,\!
  </annotation>
 </semantics>
</math>

 is not valid because we can easily find situations in which 

<math display="inline" id="Dynamic_logic_(modal_logic):122">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>→</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>k</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>b</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>k</ci>
     </apply>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\to[k]b\,\!
  </annotation>
 </semantics>
</math>

 holds but 

<math display="inline" id="Dynamic_logic_(modal_logic):123">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>k</mi>
    <mo>*</mo>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">b</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">k</csymbol>
     <times></times>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">b</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\to[k*]b\,\!
  </annotation>
 </semantics>
</math>

 does not. In any such counterexample situation, 

<math display="inline" id="Dynamic_logic_(modal_logic):124">
 <semantics>
  <mi>b</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>b</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\,\!
  </annotation>
 </semantics>
</math>

 must hold but 

<math display="inline" id="Dynamic_logic_(modal_logic):125">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>k</mi>
    <mo>*</mo>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">k</csymbol>
     <times></times>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">b</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [k*]b\,\!
  </annotation>
 </semantics>
</math>

 must be false, while 

<math display="inline" id="Dynamic_logic_(modal_logic):126">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>k</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>k</ci>
    </apply>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [k]b\,\!
  </annotation>
 </semantics>
</math>

 however must be true. But this could happen in any situation where the TV is broken but can be revived with two kicks. The implication fails (is not valid) because it only requires that 

<math display="inline" id="Dynamic_logic_(modal_logic):127">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>→</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>k</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>b</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>k</ci>
     </apply>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\to[k]b\,\!
  </annotation>
 </semantics>
</math>

 hold now, whereas the inference succeeds (is sound) because it requires that 

<math display="inline" id="Dynamic_logic_(modal_logic):128">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mo>→</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>k</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>b</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>b</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>k</ci>
     </apply>
     <ci>b</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b\to[k]b\,\!
  </annotation>
 </semantics>
</math>

 hold in all situations, not just the present one.</p>

<p>An example of a valid implication is the proposition 

<math display="inline" id="Dynamic_logic_(modal_logic):129">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>≥</mo>
    <mn>3</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>x</mi>
    <mo>+</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>≥</mo>
    <mn>4</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <geq></geq>
     <cn type="integer">3</cn>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>normal-]</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <geq></geq>
     <cn type="integer">4</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x\geq 3)\to[x:=x+1](x\geq 4)\,\!
  </annotation>
 </semantics>
</math>

. This says that if 

<math display="inline" id="Dynamic_logic_(modal_logic):130">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\,\!
  </annotation>
 </semantics>
</math>

 is greater or equal to 3, then after incrementing 

<math display="inline" id="Dynamic_logic_(modal_logic):131">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\,\!
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Dynamic_logic_(modal_logic):132">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\,\!
  </annotation>
 </semantics>
</math>

 must be greater or equal to 4. In the case of deterministic actions 

<math display="inline" id="Dynamic_logic_(modal_logic):133">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 that are guaranteed to terminate, such as 

<math display="inline" id="Dynamic_logic_(modal_logic):134">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>:=</mo>
   <mrow>
    <mi>x</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x:=x+1\,\!
  </annotation>
 </semantics>
</math>

, <em>must</em> and <em>might</em> have the same force, that is, 

<math display="inline" id="Dynamic_logic_(modal_logic):135">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mi>a</mi>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [a]\,\!
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dynamic_logic_(modal_logic):136">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>a</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-⟨⟩</csymbol>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle a\rangle\,\!
  </annotation>
 </semantics>
</math>

 have the same meaning. Hence the above proposition is equivalent to 

<math display="inline" id="Dynamic_logic_(modal_logic):137">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>≥</mo>
    <mn>3</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>x</mi>
    <mo>+</mo>
    <mn>1</mn>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>≥</mo>
    <mn>4</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <geq></geq>
     <cn type="integer">3</cn>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>normal-⟩</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <geq></geq>
     <cn type="integer">4</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x\geq 3)\to\langle x:=x+1\rangle(x\geq 4)\,\!
  </annotation>
 </semantics>
</math>

 asserting that if 

<math display="inline" id="Dynamic_logic_(modal_logic):138">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\,\!
  </annotation>
 </semantics>
</math>

 is greater or equal to 3 then after performing 

<math display="inline" id="Dynamic_logic_(modal_logic):139">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>:=</mo>
   <mrow>
    <mi>x</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x:=x+1\,\!
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Dynamic_logic_(modal_logic):140">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\,\!
  </annotation>
 </semantics>
</math>

 might be greater or equal to 4.</p>
<h2 id="assignment">Assignment</h2>

<p>The general form of an assignment statement is 

<math display="inline" id="Dynamic_logic_(modal_logic):141">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>:=</mo>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>x</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x:=e\,\!
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Dynamic_logic_(modal_logic):142">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\,\!
  </annotation>
 </semantics>
</math>

 is a variable and 

<math display="inline" id="Dynamic_logic_(modal_logic):143">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e\,\!
  </annotation>
 </semantics>
</math>

 is an expression built from constants and variables with whatever operations are provided by the language, such as addition and multiplication. The Hoare axiom for assignment is not given as a single axiom but rather as an axiom schema.</p>

<p><strong>A7.</strong> 

<math display="inline" id="Dynamic_logic_(modal_logic):144">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>e</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≡</mo>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">Φ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <equivalent></equivalent>
    <csymbol cd="unknown">Φ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">e</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [x:=e]\Phi(x)\equiv\Phi(e)\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>This is a schema in the sense that 

<math display="inline" id="Dynamic_logic_(modal_logic):145">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Φ</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(x)\,\!
  </annotation>
 </semantics>
</math>

 can be instantiated with any formula 

<math display="inline" id="Dynamic_logic_(modal_logic):146">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi\,\!
  </annotation>
 </semantics>
</math>

 containing zero or more instances of a variable 

<math display="inline" id="Dynamic_logic_(modal_logic):147">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\,\!
  </annotation>
 </semantics>
</math>

. The meaning of 

<math display="inline" id="Dynamic_logic_(modal_logic):148">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>e</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Φ</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(e)\,\!
  </annotation>
 </semantics>
</math>

 is 

<math display="inline" id="Dynamic_logic_(modal_logic):149">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi\,\!
  </annotation>
 </semantics>
</math>

 with those occurrences of 

<math display="inline" id="Dynamic_logic_(modal_logic):150">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\,\!
  </annotation>
 </semantics>
</math>

 that occur free in 

<math display="inline" id="Dynamic_logic_(modal_logic):151">
 <semantics>
  <mi mathvariant="normal">Φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi\,\!
  </annotation>
 </semantics>
</math>

, i.e. not bound by some quantifier as in 

<math display="inline" id="Dynamic_logic_(modal_logic):152">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\,\!
  </annotation>
 </semantics>
</math>

, replaced by 

<math display="inline" id="Dynamic_logic_(modal_logic):153">
 <semantics>
  <mi>e</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>e</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e\,\!
  </annotation>
 </semantics>
</math>

. For example we may instantiate A7 with 

<math display="inline" id="Dynamic_logic_(modal_logic):154">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>e</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>=</mo>
    <msup>
     <mi>y</mi>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≡</mo>
   <mi>e</mi>
   <mo>=</mo>
   <msup>
    <mi>y</mi>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <equivalent></equivalent>
    <csymbol cd="unknown">e</csymbol>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>y</ci>
     <cn type="integer">2</cn>
    </apply>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [x:=e](x=y^{2})\equiv e=y^{2}\,\!
  </annotation>
 </semantics>
</math>

, or with 

<math display="inline" id="Dynamic_logic_(modal_logic):155">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>e</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>b</mi>
    <mo>=</mo>
    <mi>c</mi>
    <mo>+</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≡</mo>
   <mi>b</mi>
   <mo>=</mo>
   <mi>c</mi>
   <mo>+</mo>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">b</csymbol>
     <eq></eq>
     <csymbol cd="unknown">c</csymbol>
     <plus></plus>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <equivalent></equivalent>
    <csymbol cd="unknown">b</csymbol>
    <eq></eq>
    <csymbol cd="unknown">c</csymbol>
    <plus></plus>
    <csymbol cd="unknown">e</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [x:=e](b=c+x)\equiv b=c+e\,\!
  </annotation>
 </semantics>
</math>

. Such an axiom schema allows infinitely many axioms having a common form to be written as a finite expression connoting that form.</p>

<p>The instance 

<math display="inline" id="Dynamic_logic_(modal_logic):156">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>x</mi>
    <mo>+</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>≥</mo>
    <mn>4</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>+</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≥</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>normal-]</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <geq></geq>
     <cn type="integer">4</cn>
     <ci>normal-)</ci>
    </cerror>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <geq></geq>
    <cn type="integer">4</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [x:=x+1](x\geq 4)\equiv(x+1)\geq 4\,\!
  </annotation>
 </semantics>
</math>

 of A7 allows us to calculate mechanically that the example 

<math display="inline" id="Dynamic_logic_(modal_logic):157">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>x</mi>
    <mo>+</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>x</mi>
   <mo>≥</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">x</csymbol>
    <geq></geq>
    <cn type="integer">4</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [x:=x+1]x\geq 4\,\!
  </annotation>
 </semantics>
</math>

 encountered a few paragraphs ago is equivalent to 

<math display="inline" id="Dynamic_logic_(modal_logic):158">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>x</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≥</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <plus></plus>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x+1)\geq 4\,\!
  </annotation>
 </semantics>
</math>

, which in turn is equivalent to 

<math display="inline" id="Dynamic_logic_(modal_logic):159">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≥</mo>
   <mn>3</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>x</ci>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\geq 3\,\!
  </annotation>
 </semantics>
</math>

 by <a href="elementary_algebra" title="wikilink">elementary algebra</a>.</p>

<p>An example illustrating assignment in combination with 

<math display="inline" id="Dynamic_logic_(modal_logic):160">
 <semantics>
  <mo>*</mo>
  <annotation-xml encoding="MathML-Content">
   <times></times>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   *\,\!
  </annotation>
 </semantics>
</math>

 is the proposition 

<math display="inline" id="Dynamic_logic_(modal_logic):161">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>:=</mo>
     <mi>x</mi>
     <mo>+</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>*</mo>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>x</mi>
   <mo>=</mo>
   <mn>7</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">x</csymbol>
      <csymbol cd="latexml">assign</csymbol>
      <csymbol cd="unknown">x</csymbol>
      <plus></plus>
      <cn type="integer">1</cn>
      <ci>normal-)</ci>
     </cerror>
     <times></times>
     <ci>normal-⟩</ci>
    </cerror>
    <csymbol cd="unknown">x</csymbol>
    <eq></eq>
    <cn type="integer">7</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle(x:=x+1)*\rangle x=7\,\!
  </annotation>
 </semantics>
</math>

. This asserts that it is possible, by incrementing 

<math display="inline" id="Dynamic_logic_(modal_logic):162">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\,\!
  </annotation>
 </semantics>
</math>

 sufficiently often, to make 

<math display="inline" id="Dynamic_logic_(modal_logic):163">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\,\!
  </annotation>
 </semantics>
</math>

 equal to 7. This of course is not always true, e.g. if 

<math display="inline" id="Dynamic_logic_(modal_logic):164">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\,\!
  </annotation>
 </semantics>
</math>

 is 8 to begin with, or 6.5, whence this proposition is not a theorem of dynamic logic. If 

<math display="inline" id="Dynamic_logic_(modal_logic):165">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\,\!
  </annotation>
 </semantics>
</math>

 is of type integer however, then this proposition is true if and only if 

<math display="inline" id="Dynamic_logic_(modal_logic):166">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\,\!
  </annotation>
 </semantics>
</math>

 is at most 7 to begin with, that is, it is just a roundabout way of saying 

<math display="inline" id="Dynamic_logic_(modal_logic):167">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≤</mo>
   <mn>7</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>x</ci>
    <cn type="integer">7</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\leq 7\,\!
  </annotation>
 </semantics>
</math>

.</p>

<p><a href="Mathematical_induction" title="wikilink">Mathematical induction</a> can be obtained as the instance of A6 in which the proposition 

<math display="inline" id="Dynamic_logic_(modal_logic):168">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 is instantiated as 

<math display="inline" id="Dynamic_logic_(modal_logic):169">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Φ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(n)\,\!
  </annotation>
 </semantics>
</math>

, the action 

<math display="inline" id="Dynamic_logic_(modal_logic):170">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Dynamic_logic_(modal_logic):171">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>:=</mo>
   <mrow>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>n</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n:=n+1\,\!
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Dynamic_logic_(modal_logic):172">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\,\!
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Dynamic_logic_(modal_logic):173">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\,\!
  </annotation>
 </semantics>
</math>

. The first two of these three instantiations are straightforward, converting A6 to 

<math display="inline" id="Dynamic_logic_(modal_logic):174">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo>:=</mo>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>*</mo>
     <mo stretchy="false">]</mo>
    </mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>→</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>n</mi>
      <mo>:=</mo>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
      <mo stretchy="false">]</mo>
     </mrow>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo>:=</mo>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>*</mo>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Φ</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <csymbol cd="latexml">assign</csymbol>
       <csymbol cd="unknown">n</csymbol>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>normal-)</ci>
      </cerror>
      <times></times>
      <ci>normal-]</ci>
     </cerror>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">Φ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">n</csymbol>
       <csymbol cd="latexml">assign</csymbol>
       <csymbol cd="unknown">n</csymbol>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>normal-]</ci>
      </cerror>
      <csymbol cd="unknown">Φ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <csymbol cd="latexml">assign</csymbol>
      <csymbol cd="unknown">n</csymbol>
      <plus></plus>
      <cn type="integer">1</cn>
      <ci>normal-)</ci>
     </cerror>
     <times></times>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">Φ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Phi(n)\land[(n:=n+1)*](\Phi(n)\to[n:=n+1]\Phi(n)))\to[(n:=n+1)*]\Phi(n)\,\!
  </annotation>
 </semantics>
</math>

. However, the ostensibly simple substitution of 

<math display="inline" id="Dynamic_logic_(modal_logic):175">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\,\!
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Dynamic_logic_(modal_logic):176">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\,\!
  </annotation>
 </semantics>
</math>

 is not so simple as it brings out the so-called <em>referential opacity</em> of modal logic in the case when a modality can interfere with a substitution.</p>

<p>When we substituted 

<math display="inline" id="Dynamic_logic_(modal_logic):177">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Φ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(n)\,\!
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Dynamic_logic_(modal_logic):178">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

, we were thinking of the proposition symbol 

<math display="inline" id="Dynamic_logic_(modal_logic):179">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 as a <a href="rigid_designator" title="wikilink">rigid designator</a> with respect to the modality 

<math display="inline" id="Dynamic_logic_(modal_logic):180">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <mi>n</mi>
    <mo>:=</mo>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <ci>n</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [n:=n+1]\,\!
  </annotation>
 </semantics>
</math>

, meaning that it is the same proposition after incrementing 

<math display="inline" id="Dynamic_logic_(modal_logic):181">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\,\!
  </annotation>
 </semantics>
</math>

 as before, even though incrementing 

<math display="inline" id="Dynamic_logic_(modal_logic):182">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\,\!
  </annotation>
 </semantics>
</math>

 may impact its truth. Likewise, the action 

<math display="inline" id="Dynamic_logic_(modal_logic):183">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

 is still the same action after incrementing 

<math display="inline" id="Dynamic_logic_(modal_logic):184">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\,\!
  </annotation>
 </semantics>
</math>

, even though incrementing 

<math display="inline" id="Dynamic_logic_(modal_logic):185">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\,\!
  </annotation>
 </semantics>
</math>

 will result in its executing in a different environment. However, 

<math display="inline" id="Dynamic_logic_(modal_logic):186">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\,\!
  </annotation>
 </semantics>
</math>

 itself is not a rigid designator with respect to the modality 

<math display="inline" id="Dynamic_logic_(modal_logic):187">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <mi>n</mi>
    <mo>:=</mo>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </mrow>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <ci>n</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [n:=n+1]\,\!
  </annotation>
 </semantics>
</math>

; if it denotes 3 before incrementing 

<math display="inline" id="Dynamic_logic_(modal_logic):188">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\,\!
  </annotation>
 </semantics>
</math>

, it denotes 4 after. So we can't just substitute 

<math display="inline" id="Dynamic_logic_(modal_logic):189">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\,\!
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Dynamic_logic_(modal_logic):190">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\,\!
  </annotation>
 </semantics>
</math>

 everywhere in A6.</p>

<p>One way of dealing with the opacity of modalities is to eliminate them. To this end, expand 

<math display="inline" id="Dynamic_logic_(modal_logic):191">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo>:=</mo>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>*</mo>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <csymbol cd="latexml">assign</csymbol>
      <csymbol cd="unknown">n</csymbol>
      <plus></plus>
      <cn type="integer">1</cn>
      <ci>normal-)</ci>
     </cerror>
     <times></times>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">Φ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [(n:=n+1)*]\Phi(n)\,\!
  </annotation>
 </semantics>
</math>

 as the infinite conjunction 

<math display="inline" id="Dynamic_logic_(modal_logic):192">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo>:=</mo>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>0</mn>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo>:=</mo>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>1</mn>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo>:=</mo>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mn>2</mn>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∧</mo>
   <mi mathvariant="normal">…</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <csymbol cd="latexml">assign</csymbol>
       <csymbol cd="unknown">n</csymbol>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>normal-)</ci>
      </cerror>
      <cn type="integer">0</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">Φ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <csymbol cd="latexml">assign</csymbol>
       <csymbol cd="unknown">n</csymbol>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>normal-)</ci>
      </cerror>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">Φ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <csymbol cd="latexml">assign</csymbol>
       <csymbol cd="unknown">n</csymbol>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>normal-)</ci>
      </cerror>
      <cn type="integer">2</cn>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">Φ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <and></and>
    <ci>normal-…</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [(n:=n+1)^{0}]\Phi(n)\land[(n:=n+1)^{1}]\Phi(n)\land[(n:=n+1)^{2}]\Phi(n)\land%
\ldots\,\!
  </annotation>
 </semantics>
</math>

, that is, the conjunction over all 

<math display="inline" id="Dynamic_logic_(modal_logic):193">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\,\!
  </annotation>
 </semantics>
</math>

 of 

<math display="inline" id="Dynamic_logic_(modal_logic):194">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo>:=</mo>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>i</mi>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <csymbol cd="latexml">assign</csymbol>
       <csymbol cd="unknown">n</csymbol>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>normal-)</ci>
      </cerror>
      <ci>i</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">Φ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [(n:=n+1)^{i}]\Phi(n)\,\!
  </annotation>
 </semantics>
</math>

. Now apply A4 to turn 

<math display="inline" id="Dynamic_logic_(modal_logic):195">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo>:=</mo>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>i</mi>
    </msup>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <csymbol cd="latexml">assign</csymbol>
       <csymbol cd="unknown">n</csymbol>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>normal-)</ci>
      </cerror>
      <ci>i</ci>
     </apply>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">Φ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [(n:=n+1)^{i}]\Phi(n)\,\!
  </annotation>
 </semantics>
</math>

 into 

<math display="inline" id="Dynamic_logic_(modal_logic):196">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo>:=</mo>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>n</mi>
    <mo>:=</mo>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi mathvariant="normal">…</mi>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">n</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>normal-]</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">n</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>normal-]</ci>
    </cerror>
    <ci>normal-…</ci>
    <csymbol cd="unknown">Φ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [n:=n+1][n:=n+1]\ldots\Phi(n)\,\!
  </annotation>
 </semantics>
</math>

, having 

<math display="inline" id="Dynamic_logic_(modal_logic):197">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\,\!
  </annotation>
 </semantics>
</math>

 modalities. Then apply Hoare's axiom 

<math display="inline" id="Dynamic_logic_(modal_logic):198">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\,\!
  </annotation>
 </semantics>
</math>

 times to this to produce 

<math display="inline" id="Dynamic_logic_(modal_logic):199">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mi>i</mi>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Φ</ci>
    <apply>
     <plus></plus>
     <ci>n</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(n+i)\,\!
  </annotation>
 </semantics>
</math>

, then simplify this infinite conjunction to 

<math display="inline" id="Dynamic_logic_(modal_logic):200">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mrow>
    <mi>i</mi>
    <mi mathvariant="normal">Φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mi>i</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>normal-Φ</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall i\Phi(n+i)\,\!
  </annotation>
 </semantics>
</math>

. This whole reduction should be applied to both instances of 

<math display="inline" id="Dynamic_logic_(modal_logic):201">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>:=</mo>
    <mi>n</mi>
    <mo>+</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>*</mo>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <ci>normal-[</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>normal-)</ci>
    </cerror>
    <times></times>
    <ci>normal-]</ci>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [(n:=n+1)*]\,\!
  </annotation>
 </semantics>
</math>

 in A6, yielding 

<math display="inline" id="Dynamic_logic_(modal_logic):202">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mo>∀</mo>
    <mi>i</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo>+</mo>
      <mi>i</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>→</mo>
     <mrow>
      <mo stretchy="false">[</mo>
      <mi>n</mi>
      <mo>:=</mo>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
      <mo stretchy="false">]</mo>
     </mrow>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo>+</mo>
      <mi>i</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mo>∀</mo>
   <mi>i</mi>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>+</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Φ</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">i</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">Φ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <plus></plus>
       <csymbol cd="unknown">i</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-[</ci>
       <csymbol cd="unknown">n</csymbol>
       <csymbol cd="latexml">assign</csymbol>
       <csymbol cd="unknown">n</csymbol>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>normal-]</ci>
      </cerror>
      <csymbol cd="unknown">Φ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <plus></plus>
       <csymbol cd="unknown">i</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <csymbol cd="unknown">Φ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <plus></plus>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Phi(n)\land\forall i(\Phi(n+i)\to[n:=n+1]\Phi(n+i)))\to\forall i\Phi(n+i)\,\!
  </annotation>
 </semantics>
</math>

. The remaining modality can now be eliminated with one more use of Hoare's axiom to give 

<math display="inline" id="Dynamic_logic_(modal_logic):203">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mo>∀</mo>
    <mi>i</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo>+</mo>
      <mi>i</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>→</mo>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo>+</mo>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mo>∀</mo>
   <mi>i</mi>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>+</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Φ</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">i</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">Φ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <plus></plus>
       <csymbol cd="unknown">i</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <csymbol cd="unknown">Φ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <plus></plus>
       <csymbol cd="unknown">i</csymbol>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <csymbol cd="unknown">Φ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <plus></plus>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Phi(n)\land\forall i(\Phi(n+i)\to\Phi(n+i+1)))\to\forall i\Phi(n+i)\,\!
  </annotation>
 </semantics>
</math>

.</p>

<p>With the opaque modalities now out of the way, we can safely substitute 

<math display="inline" id="Dynamic_logic_(modal_logic):204">
 <semantics>
  <mn>0</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">0</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0\,\!
  </annotation>
 </semantics>
</math>

 for 

<math display="inline" id="Dynamic_logic_(modal_logic):205">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\,\!
  </annotation>
 </semantics>
</math>

 in the usual manner of <a href="first-order_logic" title="wikilink">first-order logic</a> to obtain <a class="uri" href="Peano" title="wikilink">Peano</a>'s celebrated axiom 

<math display="inline" id="Dynamic_logic_(modal_logic):206">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>0</mn>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mo>∀</mo>
    <mi>i</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>i</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>→</mo>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mo>∀</mo>
   <mi>i</mi>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Φ</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <cn type="integer">0</cn>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">i</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">Φ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">i</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <csymbol cd="unknown">Φ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">i</csymbol>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <csymbol cd="unknown">Φ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Phi(0)\land\forall i(\Phi(i)\to\Phi(i+1)))\to\forall i\Phi(i)\,\!
  </annotation>
 </semantics>
</math>

, namely mathematical induction.</p>

<p>One subtlety we glossed over here is that 

<math display="inline" id="Dynamic_logic_(modal_logic):207">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>i</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall i\,\!
  </annotation>
 </semantics>
</math>

 should be understood as ranging over the natural numbers, where 

<math display="inline" id="Dynamic_logic_(modal_logic):208">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\,\!
  </annotation>
 </semantics>
</math>

 is the superscript in the expansion of 

<math display="inline" id="Dynamic_logic_(modal_logic):209">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>*</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">a</csymbol>
    <times></times>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a*\,\!
  </annotation>
 </semantics>
</math>

 as the union of 

<math display="inline" id="Dynamic_logic_(modal_logic):210">
 <semantics>
  <msup>
   <mi>a</mi>
   <mi>i</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>a</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a^{i}\,\!
  </annotation>
 </semantics>
</math>

 over all natural numbers 

<math display="inline" id="Dynamic_logic_(modal_logic):211">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\,\!
  </annotation>
 </semantics>
</math>

. The importance of keeping this typing information straight becomes apparent if 

<math display="inline" id="Dynamic_logic_(modal_logic):212">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\,\!
  </annotation>
 </semantics>
</math>

 had been of type <em>integer</em>, or even <em>real</em>, for any of which A6 is perfectly valid as an axiom. As a case in point, if 

<math display="inline" id="Dynamic_logic_(modal_logic):213">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\,\!
  </annotation>
 </semantics>
</math>

 is a real variable and 

<math display="inline" id="Dynamic_logic_(modal_logic):214">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Φ</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(n)\,\!
  </annotation>
 </semantics>
</math>

 is the predicate 

<math display="inline" id="Dynamic_logic_(modal_logic):215">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\,\!
  </annotation>
 </semantics>
</math>

 <em>is a natural number</em>, then axiom A6 after the first two substitutions, that is, 

<math display="inline" id="Dynamic_logic_(modal_logic):216">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi mathvariant="normal">Φ</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mo>∀</mo>
    <mi>i</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo>+</mo>
      <mi>i</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>→</mo>
     <mi mathvariant="normal">Φ</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo>+</mo>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mo>∀</mo>
   <mi>i</mi>
   <mi mathvariant="normal">Φ</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>n</mi>
    <mo>+</mo>
    <mi>i</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Φ</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <csymbol cd="latexml">for-all</csymbol>
     <csymbol cd="unknown">i</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">Φ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <plus></plus>
       <csymbol cd="unknown">i</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-→</ci>
      <csymbol cd="unknown">Φ</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">n</csymbol>
       <plus></plus>
       <csymbol cd="unknown">i</csymbol>
       <plus></plus>
       <cn type="integer">1</cn>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">i</csymbol>
    <csymbol cd="unknown">Φ</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">n</csymbol>
     <plus></plus>
     <csymbol cd="unknown">i</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\Phi(n)\land\forall i(\Phi(n+i)\to\Phi(n+i+1)))\to\forall i\Phi(n+i)\,\!
  </annotation>
 </semantics>
</math>

, is just as valid, that is, true in every state regardless of the value of 

<math display="inline" id="Dynamic_logic_(modal_logic):217">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\,\!
  </annotation>
 </semantics>
</math>

 in that state, as when 

<math display="inline" id="Dynamic_logic_(modal_logic):218">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\,\!
  </annotation>
 </semantics>
</math>

 is of type <em>natural number</em>. If in a given state 

<math display="inline" id="Dynamic_logic_(modal_logic):219">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\,\!
  </annotation>
 </semantics>
</math>

 is a natural number, then the antecedent of the main implication of A6 holds, but then 

<math display="inline" id="Dynamic_logic_(modal_logic):220">
 <semantics>
  <mrow>
   <mi>n</mi>
   <mo>+</mo>
   <mi>i</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>n</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n+i\,\!
  </annotation>
 </semantics>
</math>

 is also a natural number so the consequent also holds. If 

<math display="inline" id="Dynamic_logic_(modal_logic):221">
 <semantics>
  <mi>n</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>n</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n\,\!
  </annotation>
 </semantics>
</math>

 is not a natural number, then the antecedent is false and so A6 remains true regardless of the truth of the consequent. We could strengthen A6 to an equivalence 

<math display="inline" id="Dynamic_logic_(modal_logic):222">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>∧</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>a</mi>
    <mo>*</mo>
    <mo stretchy="false">]</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>a</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>a</mi>
    <mo>*</mo>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">p</csymbol>
    <and></and>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">a</csymbol>
     <times></times>
     <ci>normal-]</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-[</ci>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-]</ci>
     </cerror>
     <csymbol cd="unknown">p</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <equivalent></equivalent>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">a</csymbol>
     <times></times>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">p</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\land[a*](p\to[a]p)\equiv[a*]p\,\!
  </annotation>
 </semantics>
</math>

 without impacting any of this, the other direction being provable from A5, from which we see that if the antecedent of A6 does happen to be false somewhere, then the consequent <em>must</em> be false.</p>
<h2 id="test">Test</h2>

<p>Dynamic logic associates to every proposition 

<math display="inline" id="Dynamic_logic_(modal_logic):223">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 an action 

<math display="inline" id="Dynamic_logic_(modal_logic):224">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mi mathvariant="normal">?</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>normal-?</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p?\,\!
  </annotation>
 </semantics>
</math>

 called a test. When 

<math display="inline" id="Dynamic_logic_(modal_logic):225">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 holds, the test 

<math display="inline" id="Dynamic_logic_(modal_logic):226">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mi mathvariant="normal">?</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>normal-?</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p?\,\!
  </annotation>
 </semantics>
</math>

 acts as a <strong>NOP</strong>, changing nothing while allowing the action to move on. When 

<math display="inline" id="Dynamic_logic_(modal_logic):227">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 is false, 

<math display="inline" id="Dynamic_logic_(modal_logic):228">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mi mathvariant="normal">?</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>normal-?</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p?\,\!
  </annotation>
 </semantics>
</math>

 acts as <strong>BLOCK</strong>. Tests can be axiomatized as follows.</p>

<p><strong>A8.</strong> 

<math display="inline" id="Dynamic_logic_(modal_logic):229">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mi>p</mi>
      <mi mathvariant="normal">?</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>q</mi>
   </mrow>
   <mo>≡</mo>
   <mi>p</mi>
   <mo>→</mo>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <equivalent></equivalent>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>p</ci>
        <ci>normal-?</ci>
       </apply>
      </apply>
      <ci>q</ci>
     </apply>
     <ci>p</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [p?]q\equiv p\to q\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>The corresponding theorem for 

<math display="inline" id="Dynamic_logic_(modal_logic):230">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mrow>
    <mi>p</mi>
    <mi mathvariant="normal">?</mi>
   </mrow>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-⟨⟩</csymbol>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>normal-?</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle p?\rangle\,\!
  </annotation>
 </semantics>
</math>

 is:</p>

<p><strong>T8.</strong> 

<math display="inline" id="Dynamic_logic_(modal_logic):231">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mrow>
      <mi>p</mi>
      <mi mathvariant="normal">?</mi>
     </mrow>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>q</mi>
   </mrow>
   <mo>≡</mo>
   <mrow>
    <mi>p</mi>
    <mo>∧</mo>
    <mi>q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-⟨⟩</csymbol>
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>normal-?</ci>
      </apply>
     </apply>
     <ci>q</ci>
    </apply>
    <apply>
     <and></and>
     <ci>p</ci>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle p?\rangle q\equiv p\land q\,\!
  </annotation>
 </semantics>
</math>

</p>

<p>The construct <strong>if p then a else b</strong> is realized in dynamic logic as 

<math display="inline" id="Dynamic_logic_(modal_logic):232">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>p</mi>
     <mi mathvariant="normal">?</mi>
    </mrow>
    <mo>;</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∪</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>p</mi>
     <mi mathvariant="normal">?</mi>
    </mrow>
    <mo>;</mo>
    <mi>b</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <list>
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>normal-?</ci>
     </apply>
     <ci>a</ci>
    </list>
    <list>
     <apply>
      <times></times>
      <not></not>
      <ci>p</ci>
      <ci>normal-?</ci>
     </apply>
     <ci>b</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p?;a)\cup(\neg p?;b)\,\!
  </annotation>
 </semantics>
</math>

. This action expresses a guarded choice: if 

<math display="inline" id="Dynamic_logic_(modal_logic):233">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 holds then 

<math display="inline" id="Dynamic_logic_(modal_logic):234">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mi mathvariant="normal">?</mi>
   </mrow>
   <mo>;</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>normal-?</ci>
    </apply>
    <ci>a</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p?;a\,\!
  </annotation>
 </semantics>
</math>

 is equivalent to 

<math display="inline" id="Dynamic_logic_(modal_logic):235">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

, whereas 

<math display="inline" id="Dynamic_logic_(modal_logic):236">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>p</mi>
    <mi mathvariant="normal">?</mi>
   </mrow>
   <mo>;</mo>
   <mi>b</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <not></not>
     <ci>p</ci>
     <ci>normal-?</ci>
    </apply>
    <ci>b</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg p?;b\,\!
  </annotation>
 </semantics>
</math>

 is equivalent to BLOCK, and 

<math display="inline" id="Dynamic_logic_(modal_logic):237">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>∪</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <union></union>
    <ci>a</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\cup 0\,\!
  </annotation>
 </semantics>
</math>

 is equivalent to 

<math display="inline" id="Dynamic_logic_(modal_logic):238">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\,\!
  </annotation>
 </semantics>
</math>

. Hence when 

<math display="inline" id="Dynamic_logic_(modal_logic):239">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 is true the performer of the action can only take the left branch, and when 

<math display="inline" id="Dynamic_logic_(modal_logic):240">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 is false the right.</p>

<p>The construct <strong>while p do a</strong> is realized as 

<math display="inline" id="Dynamic_logic_(modal_logic):241">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>p</mi>
    <mi mathvariant="normal">?</mi>
    <mo>;</mo>
    <mi>a</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>*</mo>
   <mo>;</mo>
   <mi mathvariant="normal">¬</mi>
   <mi>p</mi>
   <mi mathvariant="normal">?</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">?</csymbol>
     <ci>normal-;</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <times></times>
    <ci>normal-;</ci>
    <not></not>
    <csymbol cd="unknown">p</csymbol>
    <csymbol cd="unknown">?</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (p?;a)*;\neg p?\,\!
  </annotation>
 </semantics>
</math>

. This performs 

<math display="inline" id="Dynamic_logic_(modal_logic):242">
 <semantics>
  <mrow>
   <mrow>
    <mi>p</mi>
    <mi mathvariant="normal">?</mi>
   </mrow>
   <mo>;</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <times></times>
     <ci>p</ci>
     <ci>normal-?</ci>
    </apply>
    <ci>a</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p?;a\,\!
  </annotation>
 </semantics>
</math>

 zero or more times and then performs 

<math display="inline" id="Dynamic_logic_(modal_logic):243">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>p</mi>
   <mi mathvariant="normal">?</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>p</ci>
    <ci>normal-?</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg p?\,\!
  </annotation>
 </semantics>
</math>

. As long as 

<math display="inline" id="Dynamic_logic_(modal_logic):244">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 remains true, the 

<math display="inline" id="Dynamic_logic_(modal_logic):245">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>p</mi>
   <mi mathvariant="normal">?</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>p</ci>
    <ci>normal-?</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg p?\,\!
  </annotation>
 </semantics>
</math>

 at the end blocks the performer from terminating the iteration prematurely, but as soon as it becomes false, further iterations of the body 

<math display="inline" id="Dynamic_logic_(modal_logic):246">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 are blocked and the performer then has no choice but to exit via the test 

<math display="inline" id="Dynamic_logic_(modal_logic):247">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>p</mi>
   <mi mathvariant="normal">?</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>p</ci>
    <ci>normal-?</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg p?\,\!
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="quantification-as-random-assignment">Quantification as random assignment</h2>

<p>The random-assignment statement 

<math display="inline" id="Dynamic_logic_(modal_logic):248">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>:=</mo>
   <mi mathvariant="normal">?</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>x</ci>
    <ci>normal-?</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x:=?\,\!
  </annotation>
 </semantics>
</math>

 denotes the nondeterministic action of setting 

<math display="inline" id="Dynamic_logic_(modal_logic):249">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\,\!
  </annotation>
 </semantics>
</math>

 to an arbitrary value. 

<math display="inline" id="Dynamic_logic_(modal_logic):250">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi mathvariant="normal">?</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">?</csymbol>
     <ci>normal-]</ci>
    </cerror>
    <csymbol cd="unknown">p</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [x:=?]p\,\!
  </annotation>
 </semantics>
</math>

 then says that 

<math display="inline" id="Dynamic_logic_(modal_logic):251">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 holds no matter what you set 

<math display="inline" id="Dynamic_logic_(modal_logic):252">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\,\!
  </annotation>
 </semantics>
</math>

 to, while 

<math display="inline" id="Dynamic_logic_(modal_logic):253">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi mathvariant="normal">?</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">?</csymbol>
     <ci>normal-⟩</ci>
    </cerror>
    <csymbol cd="unknown">p</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x:=?\rangle p\,\!
  </annotation>
 </semantics>
</math>

 says that it is possible to set 

<math display="inline" id="Dynamic_logic_(modal_logic):254">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\,\!
  </annotation>
 </semantics>
</math>

 to a value that makes 

<math display="inline" id="Dynamic_logic_(modal_logic):255">
 <semantics>
  <mi>p</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>p</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\,\!
  </annotation>
 </semantics>
</math>

 true. 

<math display="inline" id="Dynamic_logic_(modal_logic):256">
 <semantics>
  <mrow>
   <mo stretchy="false">[</mo>
   <mrow>
    <mi>x</mi>
    <mo>:=</mo>
    <mi mathvariant="normal">?</mi>
   </mrow>
   <mo stretchy="false">]</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-[]</csymbol>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <ci>x</ci>
     <ci>normal-?</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [x:=?]\,\!
  </annotation>
 </semantics>
</math>

 thus has the same meaning as the universal quantifier 

<math display="inline" id="Dynamic_logic_(modal_logic):257">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x\,\!
  </annotation>
 </semantics>
</math>

, while 

<math display="inline" id="Dynamic_logic_(modal_logic):258">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mrow>
    <mi>x</mi>
    <mo>:=</mo>
    <mi mathvariant="normal">?</mi>
   </mrow>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-⟨⟩</csymbol>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <ci>x</ci>
     <ci>normal-?</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle x:=?\rangle\,\!
  </annotation>
 </semantics>
</math>

 similarly corresponds to the existential quantifier 

<math display="inline" id="Dynamic_logic_(modal_logic):259">
 <semantics>
  <mrow>
   <mo>∃</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <exists></exists>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \exists x\,\!
  </annotation>
 </semantics>
</math>

. That is, first-order logic can be understood as the dynamic logic of programs of the form 

<math display="inline" id="Dynamic_logic_(modal_logic):260">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>:=</mo>
   <mi mathvariant="normal">?</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>x</ci>
    <ci>normal-?</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x:=?\,\!
  </annotation>
 </semantics>
</math>

.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<h2 id="possible-world-semantics">Possible-world semantics</h2>

<p>Modal logic is most commonly interpreted in terms of <a href="possible_world" title="wikilink">possible world</a> semantics or Kripke structures. This semantics carries over naturally to dynamic logic by interpreting worlds as states of a computer in the application to program verification, or states of our environment in applications to linguistics, AI, etc. One role for possible world semantics is to formalize the intuitive notions of truth and validity, which in turn permit the notions of soundness and completeness to be defined for axiom systems. An inference rule is sound when validity of its premises implies validity of its conclusion. An axiom system is sound when all its axioms are valid and its inference rules are sound. An axiom system is complete when every valid formula is derivable as a theorem of that system. These concepts apply to all <a href="systems_of_logic" title="wikilink">systems of logic</a> including dynamic logic.</p>
<h2 id="propositional-dynamic-logic-pdl">Propositional dynamic logic (PDL)</h2>

<p>Ordinary or <a href="first-order_logic" title="wikilink">first-order logic</a> has two types of terms, respectively assertions and data. As can be seen from the examples above, dynamic logic adds a third type of term denoting actions. The dynamic logic assertion 

<math display="inline" id="Dynamic_logic_(modal_logic):261">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>x</mi>
    <mo>+</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>≥</mo>
    <mn>4</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>normal-]</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <geq></geq>
     <cn type="integer">4</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [x:=x+1](x\geq 4)\,\!
  </annotation>
 </semantics>
</math>

 contains all three types

<math display="block" id="Dynamic_logic_(modal_logic):262">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\,\!
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Dynamic_logic_(modal_logic):263">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x+1\,\!
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Dynamic_logic_(modal_logic):264">
 <semantics>
  <mn>4</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">4</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   4\,\!
  </annotation>
 </semantics>
</math>

 are data, 

<math display="inline" id="Dynamic_logic_(modal_logic):265">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>:=</mo>
   <mrow>
    <mi>x</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x:=x+1\,\!
  </annotation>
 </semantics>
</math>

 is an action, and 

<math display="inline" id="Dynamic_logic_(modal_logic):266">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≥</mo>
   <mn>4</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <ci>x</ci>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\geq 4\,\!
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Dynamic_logic_(modal_logic):267">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>x</mi>
    <mo>:=</mo>
    <mi>x</mi>
    <mo>+</mo>
    <mn>1</mn>
    <mo stretchy="false">]</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>≥</mo>
    <mn>4</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">x</csymbol>
     <csymbol cd="latexml">assign</csymbol>
     <csymbol cd="unknown">x</csymbol>
     <plus></plus>
     <cn type="integer">1</cn>
     <ci>normal-]</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <geq></geq>
     <cn type="integer">4</cn>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [x:=x+1](x\geq 4)\,\!
  </annotation>
 </semantics>
</math>

 are assertions. <a href="Propositional_logic" title="wikilink">Propositional logic</a> is derived from first-order logic by omitting data terms and reasons only about abstract propositions, which may be simple <a href="propositional_variable" title="wikilink">propositional variables</a> or atoms or compound propositions built with such logical connectives as <em>and</em>, <em>or</em>, and <em>not</em>.</p>

<p>Propositional dynamic logic, or PDL, was derived from dynamic logic in 1977 by <a href="Michael_J._Fischer" title="wikilink">Michael J. Fischer</a> and Richard Ladner. PDL blends the ideas behind propositional logic and dynamic logic by adding actions while omitting data; hence the terms of PDL are actions and propositions. The TV example above is expressed in PDL whereas the next example involving 

<math display="inline" id="Dynamic_logic_(modal_logic):268">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>:=</mo>
   <mrow>
    <mi>x</mi>
    <mo>+</mo>
    <mn>1</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">assign</csymbol>
    <ci>x</ci>
    <apply>
     <plus></plus>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x:=x+1\,\!
  </annotation>
 </semantics>
</math>

 is in first-order DL. PDL is to (first-order) dynamic logic as propositional logic is to first-order logic.</p>

<p>Fischer and Ladner showed in their 1977 paper that PDL satisfiability was of computational complexity at most nondeterministic exponential time, and at least deterministic exponential time in the worst case. This gap was closed in 1978 by Vaughan Pratt who showed that PDL was decidable in deterministic exponential time. In 1977, Krister Segerberg proposed a complete axiomatization of PDL, namely any complete axiomatization of modal logic K together with axioms A1-A6 as given above. Completeness proofs for Segerberg's axioms were found by Gabbay (unpublished note), Parikh (1978), Pratt (1979), and Kozen and Parikh (1981).</p>
<h2 id="history">History</h2>

<p>Dynamic logic was developed by <a href="Vaughan_Pratt" title="wikilink">Vaughan Pratt</a> in 1974 in notes for a class on program verification as an approach to assigning meaning to <a href="Hoare_logic" title="wikilink">Hoare logic</a> by expressing the Hoare formula 

<math display="inline" id="Dynamic_logic_(modal_logic):269">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>a</mi>
    <mo stretchy="false">}</mo>
   </mrow>
   <mi>q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <set>
     <ci>a</ci>
    </set>
    <ci>q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\{a\}q\,\!
  </annotation>
 </semantics>
</math>

 as 

<math display="inline" id="Dynamic_logic_(modal_logic):270">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mo>→</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">[</mo>
     <mi>a</mi>
     <mo stretchy="false">]</mo>
    </mrow>
    <mi>q</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>p</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="latexml">delimited-[]</csymbol>
      <ci>a</ci>
     </apply>
     <ci>q</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   p\to[a]q\,\!
  </annotation>
 </semantics>
</math>

. The approach was later published in 1976 as a <a href="logical_system" title="wikilink">logical system</a> in its own right. The system parallels A. Salwicki's system of Algorithmic Logic<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> and <a href="Edsger_Dijkstra" title="wikilink">Edsger Dijkstra</a>'s notion of weakest-precondition predicate transformer 

<math display="inline" id="Dynamic_logic_(modal_logic):271">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>w</ci>
    <ci>p</ci>
    <interval closure="open">
     <ci>a</ci>
     <ci>p</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   wp(a,p)\,\!
  </annotation>
 </semantics>
</math>

, with 

<math display="inline" id="Dynamic_logic_(modal_logic):272">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>a</mi>
    <mo stretchy="false">]</mo>
   </mrow>
   <mi>p</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <ci>a</ci>
    </apply>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   [a]p\,\!
  </annotation>
 </semantics>
</math>

 corresponding to Dijkstra's 

<math display="inline" id="Dynamic_logic_(modal_logic):273">
 <semantics>
  <mrow>
   <mi>w</mi>
   <mi>l</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>p</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>w</ci>
    <ci>l</ci>
    <ci>p</ci>
    <interval closure="open">
     <ci>a</ci>
     <ci>p</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   wlp(a,p)\,\!
  </annotation>
 </semantics>
</math>

, weakest liberal precondition. Those logics however made no connection with either modal logic, Kripke semantics, regular expressions, or the calculus of binary relations; dynamic logic therefore can be viewed as a refinement of algorithmic logic and <a href="Predicate_transformer_semantics" title="wikilink">Predicate Transformers</a> that connects them up to the axiomatics and Kripke semantics of modal logic as well as to the calculi of binary relations and regular expressions.</p>
<h2 id="the-concurrency-challenge">The Concurrency Challenge</h2>

<p>Hoare logic, algorithmic logic, weakest preconditions, and dynamic logic are all well suited to discourse and reasoning about sequential behavior. Extending these logics to concurrent behavior however has proved problematic. There are various approaches but all of them lack the elegance of the sequential case. In contrast <a href="Amir_Pnueli" title="wikilink">Amir Pnueli</a>'s 1977 system of <a href="temporal_logic" title="wikilink">temporal logic</a>, another variant of modal logic sharing many common features with dynamic logic, differs from all of the above-mentioned logics by being what Pnueli has characterized as an "endogenous" logic, the others being "exogenous" logics. By this Pnueli meant that temporal logic assertions are interpreted within a universal behavioral framework in which a single global situation changes with the passage of time, whereas the assertions of the other logics are made externally to the multiple actions about which they speak. The advantage of the endogenous approach is that it makes no fundamental assumptions about what causes what as the environment changes with time. Instead a temporal logic formula can talk about two unrelated parts of a system, which because they are unrelated tacitly evolve in parallel. In effect ordinary logical conjunction of temporal assertions is the concurrent composition operator of temporal logic. The simplicity of this approach to concurrency has resulted in temporal logic being the modal logic of choice for reasoning about concurrent systems with its aspects of synchronization, interference, independence, deadlock, livelock, fairness, etc.</p>

<p>These concerns of concurrency would appear to be less central to linguistics, philosophy, and artificial intelligence, the areas in which dynamic logic is most often encountered nowadays.</p>

<p>For a comprehensive treatment of dynamic logic see the book by <a href="David_Harel" title="wikilink">David Harel</a> et al. cited below.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Temporal_logic" title="wikilink">Temporal logic</a></li>
<li><a href="Temporal_logic_in_finite-state_verification" title="wikilink">Temporal logic in finite-state verification</a></li>
<li><a href="Temporal_logic_of_actions" title="wikilink">Temporal logic of actions</a></li>
<li><a href="Modal_μ-calculus" title="wikilink">Modal μ-calculus</a></li>
</ul>
<h2 id="footnotes">Footnotes</h2>
<h2 id="references">References</h2>
<ul>
<li><a href="Vaughan_Pratt" title="wikilink">Vaughan Pratt</a>, "Semantical Considerations on Floyd-Hoare Logic", Proc. 17th Annual IEEE Symposium on Foundations of Computer Science, 1976, 109-121.</li>
<li><a href="David_Harel" title="wikilink">David Harel</a>, <a href="Dexter_Kozen" title="wikilink">Dexter Kozen</a>, and <a href="Jerzy_Tiuryn" title="wikilink">Jerzy Tiuryn</a>, "Dynamic Logic". MIT Press, 2000 (450 pp).</li>
<li><a href="David_Harel" title="wikilink">David Harel</a>, "Dynamic Logic", In D. Gabbay and F. Guenthner, editors, Handbook of Philosophical Logic, volume II: Extensions of Classical Logic, chapter 10, pages 497-604. Reidel, Dordrecht, 1984.</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://boole.stanford.edu/pub/semcon.pdf">Semantical Considerations on Floyd-Hoare Logic</a> (original paper on dynamic logic)</li>
</ul>

<p>"</p>

<p><a href="Category:Modal_logic" title="wikilink">Category:Modal logic</a> <a href="Category:Logic_in_computer_science" title="wikilink">Category:Logic in computer science</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
