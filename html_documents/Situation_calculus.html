<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="436">Situation calculus</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Situation calculus</h1>
<hr/>

<p>The <strong>situation calculus</strong> is a <a class="uri" href="logic" title="wikilink">logic</a> formalism designed for representing and reasoning about dynamical domains. It was first introduced by <a href="John_McCarthy_(computer_scientist)" title="wikilink">John McCarthy</a> in 1963. The main version of the situational calculus that is presented in this article is based on that introduced by <a href="Ray_Reiter" title="wikilink">Ray Reiter</a> in 1991. It is followed by sections about McCarthy's 1986 version and a <a href="logic_programming" title="wikilink">logic programming</a> formulation.</p>
<h2 id="overview">Overview</h2>

<p>The situation calculus represents changing scenarios as a set of <a href="first-order_logic" title="wikilink">first-order logic</a> formulae. The basic elements of the calculus are:</p>
<ul>
<li>The actions that can be performed in the world</li>
<li>The <a href="Fluent_(artificial_intelligence)" title="wikilink">fluents</a> that describe the state of the world</li>
<li>The situations</li>
</ul>

<p>A domain is formalized by a number of formulae, namely:</p>
<ul>
<li>Action precondition axioms, one for each action</li>
<li>Successor state axioms, one for each fluent</li>
<li>Axioms describing the world in various situations</li>
<li>The foundational axioms of the situation calculus</li>
</ul>

<p>A simple robot world will be modeled as a running example. In this world there is a single robot and several inanimate objects. The world is laid out according to a grid so that locations can be specified in terms of 

<math display="inline" id="Situation_calculus:0">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)
  </annotation>
 </semantics>
</math>

 coordinate points. It is possible for the robot to move around the world, and to pick up and drop items. Some items may be too heavy for the robot to pick up, or fragile so that they break when they are dropped. The robot also has the ability to repair any broken items that it is holding.</p>
<h2 id="elements">Elements</h2>

<p>The main elements of the situation calculus are the actions, fluents and the situations. A number of objects are also typically involved in the description of the world. The situation calculus is based on a sorted domain with three sorts: actions, situations, and objects, where the objects include everything that is not an action or a situation. Variables of each sort can be used. While actions, situations, and objects are elements of the domain, the fluents are modeled as either predicates or functions.</p>
<h3 id="actions">Actions</h3>

<p>The actions form a sort of the domain. Variables of sort action can be used. Actions can be quantified. A special predicate 

<math display="inline" id="Situation_calculus:1">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>o</mi>
   <mi>s</mi>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>o</ci>
    <ci>s</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Poss
  </annotation>
 </semantics>
</math>

 is used to indicate when an action is executable.</p>

<p>In the example robot world, possible action terms would be 

<math display="inline" id="Situation_calculus:2">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi>o</mi>
   <mi>v</mi>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>o</ci>
    <ci>v</ci>
    <ci>e</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   move(x,y)
  </annotation>
 </semantics>
</math>

 to model the robot moving to a new location 

<math display="inline" id="Situation_calculus:3">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)
  </annotation>
 </semantics>
</math>


, and 

<math display="inline" id="Situation_calculus:4">
 <semantics>
  <mrow>
   <mi>p</mi>
   <mi>i</mi>
   <mi>c</mi>
   <mi>k</mi>
   <mi>u</mi>
   <mi>p</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>o</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>p</ci>
    <ci>i</ci>
    <ci>c</ci>
    <ci>k</ci>
    <ci>u</ci>
    <ci>p</ci>
    <ci>o</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   pickup(o)
  </annotation>
 </semantics>
</math>

 to model the robot picking up an object 

<math display="inline" id="Situation_calculus:5">
 <semantics>
  <mi>o</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>o</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   o
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="situations">Situations</h3>

<p>In the situation calculus, a dynamic world is modeled as progressing through a series of situations as a result of various actions being performed within the world. A situation represents a history of action occurrences. In the Reiter version of the situation calculus described here, a situation does not represent a state, contrarily to the literal meaning of the term and contrarily to the original definition by McCarthy and Hayes. This point has been summarized by Reiter as follows:</p>
<dl>
<dd>A situation is a finite sequence of actions. Period. It's not a state, it's not a snapshot, it's a <em>history</em> <a href="http://www.ida.liu.se/ext/etai/rac/notes/1997/09/note.html">1</a>.
</dd>
</dl>

<p>The situation before any actions have been performed is typically denoted 

<math display="inline" id="Situation_calculus:6">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{0}
  </annotation>
 </semantics>
</math>

 and called the initial situation. The new situation resulting from the performance of an action is denoted using the function symbol 

<math display="inline" id="Situation_calculus:7">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>o</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>o</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   do
  </annotation>
 </semantics>
</math>

 (Some other references also use 

<math display="inline" id="Situation_calculus:8">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mi>e</mi>
   <mi>s</mi>
   <mi>u</mi>
   <mi>l</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <ci>e</ci>
    <ci>s</ci>
    <ci>u</ci>
    <ci>l</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   result
  </annotation>
 </semantics>
</math>


). This function symbol has a situation and an action as arguments, and a situation as a result, the latter being the situation that results from performing the given action in the given situation.</p>

<p>The fact that situations are sequences of actions and not states is enforced by an axiom stating that 

<math display="inline" id="Situation_calculus:9">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>o</ci>
    <interval closure="open">
     <ci>a</ci>
     <ci>s</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   do(a,s)
  </annotation>
 </semantics>
</math>

 is equal to 

<math display="inline" id="Situation_calculus:10">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mi>a</mi>
     <mo>′</mo>
    </msup>
    <mo>,</mo>
    <msup>
     <mi>s</mi>
     <mo>′</mo>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>o</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>a</ci>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>s</ci>
      <ci>normal-′</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   do(a^{\prime},s^{\prime})
  </annotation>
 </semantics>
</math>

 if and only if 

<math display="inline" id="Situation_calculus:11">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mo>=</mo>
   <msup>
    <mi>a</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>a</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>a</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a=a^{\prime}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Situation_calculus:12">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>=</mo>
   <msup>
    <mi>s</mi>
    <mo>′</mo>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>s</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>s</ci>
     <ci>normal-′</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s=s^{\prime}
  </annotation>
 </semantics>
</math>

. This condition makes no sense if situations were states, as two different actions executed in two different states can result in the same state.</p>

<p>In the example robot world, if the robot's first action is to move to location 

<math display="inline" id="Situation_calculus:13">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>2</mn>
   <mo>,</mo>
   <mn>3</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">2</cn>
    <cn type="integer">3</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (2,3)
  </annotation>
 </semantics>
</math>


, the first action is 

<math display="inline" id="Situation_calculus:14">
 <semantics>
  <mrow>
   <mi>m</mi>
   <mi>o</mi>
   <mi>v</mi>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mn>3</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>m</ci>
    <ci>o</ci>
    <ci>v</ci>
    <ci>e</ci>
    <interval closure="open">
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   move(2,3)
  </annotation>
 </semantics>
</math>

 and the resulting situation is 

<math display="inline" id="Situation_calculus:15">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>m</mi>
     <mi>o</mi>
     <mi>v</mi>
     <mi>e</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>2</mn>
      <mo>,</mo>
      <mn>3</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>o</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>o</ci>
      <ci>v</ci>
      <ci>e</ci>
      <interval closure="open">
       <cn type="integer">2</cn>
       <cn type="integer">3</cn>
      </interval>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">0</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   do(move(2,3),S_{0})
  </annotation>
 </semantics>
</math>

. If its next action is to pick up the ball, the resulting situation is 

<math display="inline" id="Situation_calculus:16">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>p</mi>
     <mi>i</mi>
     <mi>c</mi>
     <mi>k</mi>
     <mi>u</mi>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>B</mi>
       <mi>a</mi>
       <mi>l</mi>
       <mi>l</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>d</mi>
     <mi>o</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>m</mi>
       <mi>o</mi>
       <mi>v</mi>
       <mi>e</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>2</mn>
        <mo>,</mo>
        <mn>3</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <msub>
       <mi>S</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>o</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>i</ci>
      <ci>c</ci>
      <ci>k</ci>
      <ci>u</ci>
      <ci>p</ci>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>a</ci>
       <ci>l</ci>
       <ci>l</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>o</ci>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>o</ci>
        <ci>v</ci>
        <ci>e</ci>
        <interval closure="open">
         <cn type="integer">2</cn>
         <cn type="integer">3</cn>
        </interval>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <cn type="integer">0</cn>
       </apply>
      </interval>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   do(pickup(Ball),do(move(2,3),S_{0}))
  </annotation>
 </semantics>
</math>

. Situations terms like 

<math display="inline" id="Situation_calculus:17">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>m</mi>
     <mi>o</mi>
     <mi>v</mi>
     <mi>e</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>2</mn>
      <mo>,</mo>
      <mn>3</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>o</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>o</ci>
      <ci>v</ci>
      <ci>e</ci>
      <interval closure="open">
       <cn type="integer">2</cn>
       <cn type="integer">3</cn>
      </interval>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">0</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   do(move(2,3),S_{0})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Situation_calculus:18">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>p</mi>
     <mi>i</mi>
     <mi>c</mi>
     <mi>k</mi>
     <mi>u</mi>
     <mi>p</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>B</mi>
       <mi>a</mi>
       <mi>l</mi>
       <mi>l</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>d</mi>
     <mi>o</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>m</mi>
       <mi>o</mi>
       <mi>v</mi>
       <mi>e</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mn>2</mn>
        <mo>,</mo>
        <mn>3</mn>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <msub>
       <mi>S</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>o</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>p</ci>
      <ci>i</ci>
      <ci>c</ci>
      <ci>k</ci>
      <ci>u</ci>
      <ci>p</ci>
      <apply>
       <times></times>
       <ci>B</ci>
       <ci>a</ci>
       <ci>l</ci>
       <ci>l</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>o</ci>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>o</ci>
        <ci>v</ci>
        <ci>e</ci>
        <interval closure="open">
         <cn type="integer">2</cn>
         <cn type="integer">3</cn>
        </interval>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <cn type="integer">0</cn>
       </apply>
      </interval>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   do(pickup(Ball),do(move(2,3),S_{0}))
  </annotation>
 </semantics>
</math>


 denote the sequences of executed actions, and not the description of the state that result from execution.</p>
<h3 id="fluents">Fluents</h3>

<p>Statements whose <a href="truth_value" title="wikilink">truth value</a> may change are modeled by <em>relational fluents</em>, predicates which take a situation as their final argument. Also possible are <em>functional fluents</em>, functions which take a situation as their final argument and return a situation-dependent value. Fluents may be thought of as "properties of the world"'.</p>

<p>In the example, the fluent 

<math display="inline" id="Situation_calculus:19">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mi>s</mi>
   <mi mathvariant="normal">_</mi>
   <mi>c</mi>
   <mi>a</mi>
   <mi>r</mi>
   <mi>r</mi>
   <mi>y</mi>
   <mi>i</mi>
   <mi>n</mi>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>o</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>i</ci>
    <ci>s</ci>
    <ci>normal-_</ci>
    <ci>c</ci>
    <ci>a</ci>
    <ci>r</ci>
    <ci>r</ci>
    <ci>y</ci>
    <ci>i</ci>
    <ci>n</ci>
    <ci>g</ci>
    <interval closure="open">
     <ci>o</ci>
     <ci>s</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   is\_carrying(o,s)
  </annotation>
 </semantics>
</math>

 can be used to indicate that the robot is carrying a particular object in a particular situation. If the robot initially carries nothing, 

<math display="inline" id="Situation_calculus:20">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mi>s</mi>
   <mi mathvariant="normal">_</mi>
   <mi>c</mi>
   <mi>a</mi>
   <mi>r</mi>
   <mi>r</mi>
   <mi>y</mi>
   <mi>i</mi>
   <mi>n</mi>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>B</mi>
     <mi>a</mi>
     <mi>l</mi>
     <mi>l</mi>
    </mrow>
    <mo>,</mo>
    <msub>
     <mi>S</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>i</ci>
    <ci>s</ci>
    <ci>normal-_</ci>
    <ci>c</ci>
    <ci>a</ci>
    <ci>r</ci>
    <ci>r</ci>
    <ci>y</ci>
    <ci>i</ci>
    <ci>n</ci>
    <ci>g</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>a</ci>
      <ci>l</ci>
      <ci>l</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">0</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   is\_carrying(Ball,S_{0})
  </annotation>
 </semantics>
</math>

 is false while 

<math display="inline" id="Situation_calculus:21">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mi>s</mi>
   <mi mathvariant="normal">_</mi>
   <mi>c</mi>
   <mi>a</mi>
   <mi>r</mi>
   <mi>r</mi>
   <mi>y</mi>
   <mi>i</mi>
   <mi>n</mi>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>B</mi>
     <mi>a</mi>
     <mi>l</mi>
     <mi>l</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>d</mi>
     <mi>o</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>p</mi>
       <mi>i</mi>
       <mi>c</mi>
       <mi>k</mi>
       <mi>u</mi>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mi>B</mi>
         <mi>a</mi>
         <mi>l</mi>
         <mi>l</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <msub>
       <mi>S</mi>
       <mn>0</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>i</ci>
    <ci>s</ci>
    <ci>normal-_</ci>
    <ci>c</ci>
    <ci>a</ci>
    <ci>r</ci>
    <ci>r</ci>
    <ci>y</ci>
    <ci>i</ci>
    <ci>n</ci>
    <ci>g</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>B</ci>
      <ci>a</ci>
      <ci>l</ci>
      <ci>l</ci>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>o</ci>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>p</ci>
        <ci>i</ci>
        <ci>c</ci>
        <ci>k</ci>
        <ci>u</ci>
        <ci>p</ci>
        <apply>
         <times></times>
         <ci>B</ci>
         <ci>a</ci>
         <ci>l</ci>
         <ci>l</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <cn type="integer">0</cn>
       </apply>
      </interval>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   is\_carrying(Ball,do(pickup(Ball),S_{0}))
  </annotation>
 </semantics>
</math>

 is true. The location of the robot can be modeled using a functional fluent 

<math display="inline" id="Situation_calculus:22">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mi>o</mi>
   <mi>c</mi>
   <mi>a</mi>
   <mi>t</mi>
   <mi>i</mi>
   <mi>o</mi>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <ci>o</ci>
    <ci>c</ci>
    <ci>a</ci>
    <ci>t</ci>
    <ci>i</ci>
    <ci>o</ci>
    <ci>n</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   location(s)
  </annotation>
 </semantics>
</math>

 which returns the location 

<math display="inline" id="Situation_calculus:23">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mi>x</mi>
   <mo>,</mo>
   <mi>y</mi>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <ci>x</ci>
    <ci>y</ci>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (x,y)
  </annotation>
 </semantics>
</math>


 of the robot in a particular situation.</p>
<h2 id="formulae">Formulae</h2>

<p>The description of a dynamic world is encoded in <a href="Second-order_logic" title="wikilink">second order logics</a> using three kinds of formulae: formulae about actions (preconditions and effects), formulae about the state of the world, and foundational axioms.</p>
<h3 id="action-preconditions">Action preconditions</h3>

<p>Some actions may not be executable in a given situation. For example, it is impossible to put down an object unless one is in fact carrying it. The restrictions on the performance of actions are modeled by literals of the form 

<math display="inline" id="Situation_calculus:24">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>o</mi>
   <mi>s</mi>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>o</ci>
    <ci>s</ci>
    <ci>s</ci>
    <interval closure="open">
     <ci>a</ci>
     <ci>s</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Poss(a,s)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Situation_calculus:25">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is an action, 

<math display="inline" id="Situation_calculus:26">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 a situation, and 

<math display="inline" id="Situation_calculus:27">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>o</mi>
   <mi>s</mi>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>o</ci>
    <ci>s</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Poss
  </annotation>
 </semantics>
</math>

 is a special binary predicate denoting executability of actions. In the example, the condition that dropping an object is only possible when one is carrying it is modeled by:</p>

<p>

<math display="inline" id="Situation_calculus:28">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mi>o</mi>
    <mi>s</mi>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>d</mi>
      <mi>r</mi>
      <mi>o</mi>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>o</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>↔</mo>
   <mrow>
    <mi>i</mi>
    <mi>s</mi>
    <mi mathvariant="normal">_</mi>
    <mi>c</mi>
    <mi>a</mi>
    <mi>r</mi>
    <mi>r</mi>
    <mi>y</mi>
    <mi>i</mi>
    <mi>n</mi>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>o</mi>
     <mo>,</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>o</ci>
     <ci>s</ci>
     <ci>s</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>r</ci>
       <ci>o</ci>
       <ci>p</ci>
       <ci>o</ci>
      </apply>
      <ci>s</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>s</ci>
     <ci>normal-_</ci>
     <ci>c</ci>
     <ci>a</ci>
     <ci>r</ci>
     <ci>r</ci>
     <ci>y</ci>
     <ci>i</ci>
     <ci>n</ci>
     <ci>g</ci>
     <interval closure="open">
      <ci>o</ci>
      <ci>s</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Poss(drop(o),s)\leftrightarrow is\_carrying(o,s)
  </annotation>
 </semantics>
</math>


</p>

<p>As a more complex example, the following models that the robot can carry only one object at a time, and that some objects are too heavy for the robot to lift (indicated by the predicate 

<math display="inline" id="Situation_calculus:29">
 <semantics>
  <mrow>
   <mi>h</mi>
   <mi>e</mi>
   <mi>a</mi>
   <mi>v</mi>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>h</ci>
    <ci>e</ci>
    <ci>a</ci>
    <ci>v</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   heavy
  </annotation>
 </semantics>
</math>

):</p>

<p>

<math display="inline" id="Situation_calculus:30">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mi>o</mi>
    <mi>s</mi>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>p</mi>
      <mi>i</mi>
      <mi>c</mi>
      <mi>k</mi>
      <mi>u</mi>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>o</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>↔</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo>∀</mo>
      <mrow>
       <mi>z</mi>
       <mi mathvariant="normal">¬</mi>
       <mi>i</mi>
       <mi>s</mi>
       <mi mathvariant="normal">_</mi>
       <mi>c</mi>
       <mi>a</mi>
       <mi>r</mi>
       <mi>r</mi>
       <mi>y</mi>
       <mi>i</mi>
       <mi>n</mi>
       <mi>g</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>z</mi>
        <mo>,</mo>
        <mi>s</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>h</mi>
     <mi>e</mi>
     <mi>a</mi>
     <mi>v</mi>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>o</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-↔</ci>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>o</ci>
     <ci>s</ci>
     <ci>s</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>i</ci>
       <ci>c</ci>
       <ci>k</ci>
       <ci>u</ci>
       <ci>p</ci>
       <ci>o</ci>
      </apply>
      <ci>s</ci>
     </interval>
    </apply>
    <apply>
     <and></and>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <apply>
       <times></times>
       <ci>z</ci>
       <not></not>
       <ci>i</ci>
       <ci>s</ci>
       <ci>normal-_</ci>
       <ci>c</ci>
       <ci>a</ci>
       <ci>r</ci>
       <ci>r</ci>
       <ci>y</ci>
       <ci>i</ci>
       <ci>n</ci>
       <ci>g</ci>
       <interval closure="open">
        <ci>z</ci>
        <ci>s</ci>
       </interval>
      </apply>
     </apply>
     <apply>
      <times></times>
      <not></not>
      <ci>h</ci>
      <ci>e</ci>
      <ci>a</ci>
      <ci>v</ci>
      <ci>y</ci>
      <ci>o</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Poss(pickup(o),s)\leftrightarrow(\forall z\neg is\_carrying(z,s))\wedge\neg
heavy%
(o)
  </annotation>
 </semantics>
</math>

</p>
<h3 id="action-effects">Action effects</h3>

<p>Given that an action is possible in a situation, one must specify the effects of that action on the fluents. This is done by the effect axioms. For example, the fact that picking up an object causes the robot to be carrying it can be modeled as:</p>

<p>

<math display="inline" id="Situation_calculus:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mi>o</mi>
    <mi>s</mi>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>p</mi>
      <mi>i</mi>
      <mi>c</mi>
      <mi>k</mi>
      <mi>u</mi>
      <mi>p</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>o</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>,</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>i</mi>
    <mi>s</mi>
    <mi mathvariant="normal">_</mi>
    <mi>c</mi>
    <mi>a</mi>
    <mi>r</mi>
    <mi>r</mi>
    <mi>y</mi>
    <mi>i</mi>
    <mi>n</mi>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>o</mi>
     <mo>,</mo>
     <mrow>
      <mi>d</mi>
      <mi>o</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>p</mi>
        <mi>i</mi>
        <mi>c</mi>
        <mi>k</mi>
        <mi>u</mi>
        <mi>p</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>o</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>o</ci>
     <ci>s</ci>
     <ci>s</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>p</ci>
       <ci>i</ci>
       <ci>c</ci>
       <ci>k</ci>
       <ci>u</ci>
       <ci>p</ci>
       <ci>o</ci>
      </apply>
      <ci>s</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>s</ci>
     <ci>normal-_</ci>
     <ci>c</ci>
     <ci>a</ci>
     <ci>r</ci>
     <ci>r</ci>
     <ci>y</ci>
     <ci>i</ci>
     <ci>n</ci>
     <ci>g</ci>
     <interval closure="open">
      <ci>o</ci>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>o</ci>
       <interval closure="open">
        <apply>
         <times></times>
         <ci>p</ci>
         <ci>i</ci>
         <ci>c</ci>
         <ci>k</ci>
         <ci>u</ci>
         <ci>p</ci>
         <ci>o</ci>
        </apply>
        <ci>s</ci>
       </interval>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Poss(pickup(o),s)\rightarrow is\_carrying(o,do(pickup(o),s))
  </annotation>
 </semantics>
</math>

</p>

<p>It is also possible to specify conditional effects, which are effects that depend on the current state. The following models that some objects are fragile (indicated by the predicate 

<math display="inline" id="Situation_calculus:32">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mi>r</mi>
   <mi>a</mi>
   <mi>g</mi>
   <mi>i</mi>
   <mi>l</mi>
   <mi>e</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>r</ci>
    <ci>a</ci>
    <ci>g</ci>
    <ci>i</ci>
    <ci>l</ci>
    <ci>e</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   fragile
  </annotation>
 </semantics>
</math>

) and dropping them causes them to be broken (indicated by the fluent 

<math display="inline" id="Situation_calculus:33">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mi>r</mi>
   <mi>o</mi>
   <mi>k</mi>
   <mi>e</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>b</ci>
    <ci>r</ci>
    <ci>o</ci>
    <ci>k</ci>
    <ci>e</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   broken
  </annotation>
 </semantics>
</math>


):</p>

<p>

<math display="inline" id="Situation_calculus:34">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mi>o</mi>
     <mi>s</mi>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>d</mi>
       <mi>r</mi>
       <mi>o</mi>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>o</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mi>f</mi>
     <mi>r</mi>
     <mi>a</mi>
     <mi>g</mi>
     <mi>i</mi>
     <mi>l</mi>
     <mi>e</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>o</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>b</mi>
    <mi>r</mi>
    <mi>o</mi>
    <mi>k</mi>
    <mi>e</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>o</mi>
     <mo>,</mo>
     <mrow>
      <mi>d</mi>
      <mi>o</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>d</mi>
        <mi>r</mi>
        <mi>o</mi>
        <mi>p</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>o</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <and></and>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>o</ci>
      <ci>s</ci>
      <ci>s</ci>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>r</ci>
        <ci>o</ci>
        <ci>p</ci>
        <ci>o</ci>
       </apply>
       <ci>s</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>r</ci>
      <ci>a</ci>
      <ci>g</ci>
      <ci>i</ci>
      <ci>l</ci>
      <ci>e</ci>
      <ci>o</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>b</ci>
     <ci>r</ci>
     <ci>o</ci>
     <ci>k</ci>
     <ci>e</ci>
     <ci>n</ci>
     <interval closure="open">
      <ci>o</ci>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>o</ci>
       <interval closure="open">
        <apply>
         <times></times>
         <ci>d</ci>
         <ci>r</ci>
         <ci>o</ci>
         <ci>p</ci>
         <ci>o</ci>
        </apply>
        <ci>s</ci>
       </interval>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Poss(drop(o),s)\wedge fragile(o)\rightarrow broken(o,do(drop(o),s))
  </annotation>
 </semantics>
</math>

</p>

<p>While this formula correctly describes the effect of the actions, it is not sufficient to correctly describe the action in logic, because of the <a href="frame_problem" title="wikilink">frame problem</a>.</p>
<h3 id="the-frame-problem">The frame problem</h3>

<p>While the above formulae seem suitable for reasoning about the effects of actions, they have a critical weakness - they cannot be used to derive the <em>non-effects</em> of actions. For example, it is not possible to deduce that after picking up an object, the robot's location remains unchanged. This requires a so-called frame axiom, a formula like:</p>

<p>

<math display="inline" id="Situation_calculus:35">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mi>o</mi>
     <mi>s</mi>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>p</mi>
       <mi>i</mi>
       <mi>c</mi>
       <mi>k</mi>
       <mi>u</mi>
       <mi>p</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>o</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mi>l</mi>
     <mi>o</mi>
     <mi>c</mi>
     <mi>a</mi>
     <mi>t</mi>
     <mi>i</mi>
     <mi>o</mi>
     <mi>n</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>l</mi>
    <mi>o</mi>
    <mi>c</mi>
    <mi>a</mi>
    <mi>t</mi>
    <mi>i</mi>
    <mi>o</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>d</mi>
      <mi>o</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>p</mi>
        <mi>i</mi>
        <mi>c</mi>
        <mi>k</mi>
        <mi>u</mi>
        <mi>p</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>o</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>,</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <and></and>
      <apply>
       <times></times>
       <ci>P</ci>
       <ci>o</ci>
       <ci>s</ci>
       <ci>s</ci>
       <interval closure="open">
        <apply>
         <times></times>
         <ci>p</ci>
         <ci>i</ci>
         <ci>c</ci>
         <ci>k</ci>
         <ci>u</ci>
         <ci>p</ci>
         <ci>o</ci>
        </apply>
        <ci>s</ci>
       </interval>
      </apply>
      <apply>
       <times></times>
       <ci>l</ci>
       <ci>o</ci>
       <ci>c</ci>
       <ci>a</ci>
       <ci>t</ci>
       <ci>i</ci>
       <ci>o</ci>
       <ci>n</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>l</ci>
      <ci>o</ci>
      <ci>c</ci>
      <ci>a</ci>
      <ci>t</ci>
      <ci>i</ci>
      <ci>o</ci>
      <ci>n</ci>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>o</ci>
       <interval closure="open">
        <apply>
         <times></times>
         <ci>p</ci>
         <ci>i</ci>
         <ci>c</ci>
         <ci>k</ci>
         <ci>u</ci>
         <ci>p</ci>
         <ci>o</ci>
        </apply>
        <ci>s</ci>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Poss(pickup(o),s)\wedge location(s)=(x,y)\rightarrow location(do(pickup(o),s))%
=(x,y)
  </annotation>
 </semantics>
</math>

</p>

<p>The need to specify frame axioms has long been recognised as a problem in axiomatizing dynamic worlds, and is known as the <a href="frame_problem" title="wikilink">frame problem</a>. As there are generally a very large number of such axioms, it is very easy for the designer to leave out a necessary frame axiom, or to forget to modify all appropriate axioms when a change to the world description is made.</p>
<h3 id="the-successor-state-axioms">The successor state axioms</h3>

<p>The successor state axioms "solve" the frame problem in the situation calculus. According to this solution, the designer must enumerate as effect axioms all the ways in which the value of a particular fluent can be changed. The effect axioms affecting the value of fluent 

<math display="inline" id="Situation_calculus:36">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo>→</mo>
    </mover>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <interval closure="open">
     <apply>
      <ci>normal-→</ci>
      <ci>x</ci>
     </apply>
     <ci>s</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(\overrightarrow{x},s)
  </annotation>
 </semantics>
</math>

 can be written in generalised form as a positive and a negative effect axiom:</p>

<p>

<math display="inline" id="Situation_calculus:37">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mi>o</mi>
     <mi>s</mi>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <msubsup>
      <mi>γ</mi>
      <mi>F</mi>
      <mo>+</mo>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mover accent="true">
       <mi>x</mi>
       <mo>→</mo>
      </mover>
      <mo>,</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo>→</mo>
     </mover>
     <mo>,</mo>
     <mrow>
      <mi>d</mi>
      <mi>o</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo>,</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <and></and>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>o</ci>
      <ci>s</ci>
      <ci>s</ci>
      <interval closure="open">
       <ci>a</ci>
       <ci>s</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <ci>F</ci>
       </apply>
       <plus></plus>
      </apply>
      <vector>
       <apply>
        <ci>normal-→</ci>
        <ci>x</ci>
       </apply>
       <ci>a</ci>
       <ci>s</ci>
      </vector>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>F</ci>
     <interval closure="open">
      <apply>
       <ci>normal-→</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>o</ci>
       <interval closure="open">
        <ci>a</ci>
        <ci>s</ci>
       </interval>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Poss(a,s)\wedge\gamma_{F}^{+}(\overrightarrow{x},a,s)\rightarrow F(%
\overrightarrow{x},do(a,s))
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Situation_calculus:38">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mi>o</mi>
     <mi>s</mi>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <msubsup>
      <mi>γ</mi>
      <mi>F</mi>
      <mo>-</mo>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mover accent="true">
       <mi>x</mi>
       <mo>→</mo>
      </mover>
      <mo>,</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo>→</mo>
     </mover>
     <mo>,</mo>
     <mrow>
      <mi>d</mi>
      <mi>o</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo>,</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <and></and>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>o</ci>
      <ci>s</ci>
      <ci>s</ci>
      <interval closure="open">
       <ci>a</ci>
       <ci>s</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <ci>F</ci>
       </apply>
       <minus></minus>
      </apply>
      <vector>
       <apply>
        <ci>normal-→</ci>
        <ci>x</ci>
       </apply>
       <ci>a</ci>
       <ci>s</ci>
      </vector>
     </apply>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>F</ci>
     <interval closure="open">
      <apply>
       <ci>normal-→</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>o</ci>
       <interval closure="open">
        <ci>a</ci>
        <ci>s</ci>
       </interval>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Poss(a,s)\wedge\gamma_{F}^{-}(\overrightarrow{x},a,s)\rightarrow\neg F(%
\overrightarrow{x},do(a,s))
  </annotation>
 </semantics>
</math>


</p>

<p>The formula 

<math display="inline" id="Situation_calculus:39">
 <semantics>
  <msubsup>
   <mi>γ</mi>
   <mi>F</mi>
   <mo>+</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>γ</ci>
     <ci>F</ci>
    </apply>
    <plus></plus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma_{F}^{+}
  </annotation>
 </semantics>
</math>

 describes the conditions under which action 

<math display="inline" id="Situation_calculus:40">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 in situation 

<math display="inline" id="Situation_calculus:41">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 makes the fluent 

<math display="inline" id="Situation_calculus:42">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 become true in the successor situation 

<math display="inline" id="Situation_calculus:43">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>o</ci>
    <interval closure="open">
     <ci>a</ci>
     <ci>s</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   do(a,s)
  </annotation>
 </semantics>
</math>


. Likewise, 

<math display="inline" id="Situation_calculus:44">
 <semantics>
  <msubsup>
   <mi>γ</mi>
   <mi>F</mi>
   <mo>-</mo>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>γ</ci>
     <ci>F</ci>
    </apply>
    <minus></minus>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma_{F}^{-}
  </annotation>
 </semantics>
</math>

 describes the conditions under which performing action 

<math display="inline" id="Situation_calculus:45">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 in situation 

<math display="inline" id="Situation_calculus:46">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 makes fluent 

<math display="inline" id="Situation_calculus:47">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 false in the successor situation.</p>

<p>If this pair of axioms describe all the ways in which fluent 

<math display="inline" id="Situation_calculus:48">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>


 can change value, they can be rewritten as a single axiom:</p>

<p>

<math display="inline" id="Situation_calculus:49">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>o</mi>
   <mi>s</mi>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo>[</mo>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo>→</mo>
     </mover>
     <mo>,</mo>
     <mi>d</mi>
     <mi>o</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>↔</mo>
    <msubsup>
     <mi>γ</mi>
     <mi>F</mi>
     <mo>+</mo>
    </msubsup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mover accent="true">
      <mi>x</mi>
      <mo>→</mo>
     </mover>
     <mo>,</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∨</mo>
    <mrow>
     <mo>(</mo>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mover accent="true">
       <mi>x</mi>
       <mo>→</mo>
      </mover>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>∧</mo>
     <mi mathvariant="normal">¬</mi>
     <msubsup>
      <mi>γ</mi>
      <mi>F</mi>
      <mo>-</mo>
     </msubsup>
     <mrow>
      <mo stretchy="false">(</mo>
      <mover accent="true">
       <mi>x</mi>
       <mo>→</mo>
      </mover>
      <mo>,</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">o</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">F</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>x</ci>
      </apply>
      <ci>normal-,</ci>
      <csymbol cd="unknown">d</csymbol>
      <csymbol cd="unknown">o</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">a</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">s</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-↔</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>γ</ci>
       <ci>F</ci>
      </apply>
      <plus></plus>
     </apply>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <apply>
       <ci>normal-→</ci>
       <ci>x</ci>
      </apply>
      <ci>normal-,</ci>
      <csymbol cd="unknown">a</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <or></or>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">F</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <ci>normal-→</ci>
        <ci>x</ci>
       </apply>
       <ci>normal-,</ci>
       <csymbol cd="unknown">s</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <and></and>
      <not></not>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>γ</ci>
        <ci>F</ci>
       </apply>
       <minus></minus>
      </apply>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <apply>
        <ci>normal-→</ci>
        <ci>x</ci>
       </apply>
       <ci>normal-,</ci>
       <csymbol cd="unknown">a</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">s</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Poss(a,s)\rightarrow\left[F(\overrightarrow{x},do(a,s))\leftrightarrow\gamma_{%
F}^{+}(\overrightarrow{x},a,s)\vee\left(F(\overrightarrow{x},s)\wedge\neg%
\gamma_{F}^{-}(\overrightarrow{x},a,s)\right)\right]
  </annotation>
 </semantics>
</math>

</p>

<p>In words, this formula states: "given that it is possible to perform action 

<math display="inline" id="Situation_calculus:50">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 in situation 

<math display="inline" id="Situation_calculus:51">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

, the fluent 

<math display="inline" id="Situation_calculus:52">
 <semantics>
  <mi>F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F
  </annotation>
 </semantics>
</math>

 would be true in the resulting situation 

<math display="inline" id="Situation_calculus:53">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>o</ci>
    <interval closure="open">
     <ci>a</ci>
     <ci>s</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   do(a,s)
  </annotation>
 </semantics>
</math>


 if and only if performing 

<math display="inline" id="Situation_calculus:54">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Situation_calculus:55">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 would make it true, or it is true in situation 

<math display="inline" id="Situation_calculus:56">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 and performing 

<math display="inline" id="Situation_calculus:57">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 in 

<math display="inline" id="Situation_calculus:58">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>


 would not make it false."</p>

<p>By way of example, the value of the fluent 

<math display="inline" id="Situation_calculus:59">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mi>r</mi>
   <mi>o</mi>
   <mi>k</mi>
   <mi>e</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>b</ci>
    <ci>r</ci>
    <ci>o</ci>
    <ci>k</ci>
    <ci>e</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   broken
  </annotation>
 </semantics>
</math>

 introduced above is given by the following successor state axiom:</p>

<p>

<math display="inline" id="Situation_calculus:60">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>o</mi>
   <mi>s</mi>
   <mi>s</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mo>[</mo>
    <mi>b</mi>
    <mi>r</mi>
    <mi>o</mi>
    <mi>k</mi>
    <mi>e</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>o</mi>
     <mo>,</mo>
     <mi>d</mi>
     <mi>o</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>↔</mo>
    <mi>a</mi>
    <mo>=</mo>
    <mi>d</mi>
    <mi>r</mi>
    <mi>o</mi>
    <mi>p</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>o</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mi>f</mi>
    <mi>r</mi>
    <mi>a</mi>
    <mi>g</mi>
    <mi>i</mi>
    <mi>l</mi>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>o</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∨</mo>
    <mi>b</mi>
    <mi>r</mi>
    <mi>o</mi>
    <mi>k</mi>
    <mi>e</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>o</mi>
     <mo>,</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mi>a</mi>
    <mo>≠</mo>
    <mi>r</mi>
    <mi>e</mi>
    <mi>p</mi>
    <mi>a</mi>
    <mi>i</mi>
    <mi>r</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>o</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">P</csymbol>
    <csymbol cd="unknown">o</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <csymbol cd="unknown">s</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">a</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">s</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">r</csymbol>
     <csymbol cd="unknown">o</csymbol>
     <csymbol cd="unknown">k</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">o</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">d</csymbol>
      <csymbol cd="unknown">o</csymbol>
      <cerror>
       <csymbol cd="ambiguous">fragments</csymbol>
       <ci>normal-(</ci>
       <csymbol cd="unknown">a</csymbol>
       <ci>normal-,</ci>
       <csymbol cd="unknown">s</csymbol>
       <ci>normal-)</ci>
      </cerror>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-↔</ci>
     <csymbol cd="unknown">a</csymbol>
     <eq></eq>
     <csymbol cd="unknown">d</csymbol>
     <csymbol cd="unknown">r</csymbol>
     <csymbol cd="unknown">o</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">o</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <csymbol cd="unknown">f</csymbol>
     <csymbol cd="unknown">r</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">g</csymbol>
     <csymbol cd="unknown">i</csymbol>
     <csymbol cd="unknown">l</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">o</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <or></or>
     <csymbol cd="unknown">b</csymbol>
     <csymbol cd="unknown">r</csymbol>
     <csymbol cd="unknown">o</csymbol>
     <csymbol cd="unknown">k</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <csymbol cd="unknown">n</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">o</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">s</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <and></and>
     <csymbol cd="unknown">a</csymbol>
     <neq></neq>
     <csymbol cd="unknown">r</csymbol>
     <csymbol cd="unknown">e</csymbol>
     <csymbol cd="unknown">p</csymbol>
     <csymbol cd="unknown">a</csymbol>
     <csymbol cd="unknown">i</csymbol>
     <csymbol cd="unknown">r</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">o</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Poss(a,s)\rightarrow\left[broken(o,do(a,s))\leftrightarrow a=drop(o)\wedge
fragile%
(o)\vee broken(o,s)\wedge a\neq repair(o)\right]
  </annotation>
 </semantics>
</math>

</p>
<h3 id="states">States</h3>

<p>The properties of the initial or any other situation can be specified by simply stating them as formulae. For example, a fact about the initial state is formalized by making assertions about 

<math display="inline" id="Situation_calculus:61">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{0}
  </annotation>
 </semantics>
</math>

 (which is not a state, but a <em>situation</em>). The following statements model that initially, the robot carries nothing, is at location 

<math display="inline" id="Situation_calculus:62">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <mn>0</mn>
   <mo>,</mo>
   <mn>0</mn>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <cn type="integer">0</cn>
    <cn type="integer">0</cn>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (0,0)
  </annotation>
 </semantics>
</math>

, and there are no broken objects:</p>

<p>

<math display="inline" id="Situation_calculus:63">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>z</mi>
    </mpadded>
    <mi mathvariant="normal">¬</mi>
    <mi>i</mi>
    <mi>s</mi>
    <mi mathvariant="normal">_</mi>
    <mi>c</mi>
    <mi>a</mi>
    <mi>r</mi>
    <mi>r</mi>
    <mi>y</mi>
    <mi>i</mi>
    <mi>n</mi>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>z</mi>
     <mo>,</mo>
     <msub>
      <mi>S</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <times></times>
     <ci>z</ci>
     <not></not>
     <ci>i</ci>
     <ci>s</ci>
     <ci>normal-_</ci>
     <ci>c</ci>
     <ci>a</ci>
     <ci>r</ci>
     <ci>r</ci>
     <ci>y</ci>
     <ci>i</ci>
     <ci>n</ci>
     <ci>g</ci>
     <interval closure="open">
      <ci>z</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">0</cn>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall z\,\neg is\_carrying(z,S_{0})
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Situation_calculus:64">
 <semantics>
  <mrow>
   <mrow>
    <mi>l</mi>
    <mi>o</mi>
    <mi>c</mi>
    <mi>a</mi>
    <mi>t</mi>
    <mi>i</mi>
    <mi>o</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>S</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>0</mn>
    <mo>,</mo>
    <mn>0</mn>
    <mo rspace="4.2pt" stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <ci>c</ci>
     <ci>a</ci>
     <ci>t</ci>
     <ci>i</ci>
     <ci>o</ci>
     <ci>n</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <interval closure="open">
     <cn type="integer">0</cn>
     <cn type="integer">0</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   location(S_{0})=(0,0)\,
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Situation_calculus:65">
 <semantics>
  <mrow>
   <mo>∀</mo>
   <mrow>
    <mpadded width="+1.7pt">
     <mi>o</mi>
    </mpadded>
    <mi mathvariant="normal">¬</mi>
    <mi>b</mi>
    <mi>r</mi>
    <mi>o</mi>
    <mi>k</mi>
    <mi>e</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>o</mi>
     <mo>,</mo>
     <msub>
      <mi>S</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">for-all</csymbol>
    <apply>
     <times></times>
     <ci>o</ci>
     <not></not>
     <ci>b</ci>
     <ci>r</ci>
     <ci>o</ci>
     <ci>k</ci>
     <ci>e</ci>
     <ci>n</ci>
     <interval closure="open">
      <ci>o</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>S</ci>
       <cn type="integer">0</cn>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall o\,\neg broken(o,S_{0})
  </annotation>
 </semantics>
</math>

</p>
<h3 id="foundational-axioms">Foundational axioms</h3>

<p>The foundational axioms of the situation calculus formalize the idea that situations are histories by having 

<math display="inline" id="Situation_calculus:66">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mi>o</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>d</mi>
     <mi>o</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msup>
       <mi>a</mi>
       <mo>′</mo>
      </msup>
      <mo>,</mo>
      <msup>
       <mi>s</mi>
       <mo>′</mo>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <mi>a</mi>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>a</mi>
      <mo>′</mo>
     </msup>
     <mi mathvariant="italic">and</mi>
     <mi>s</mi>
    </mrow>
    <mo>=</mo>
    <msup>
     <mi>s</mi>
     <mo>′</mo>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">iff</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>o</ci>
      <interval closure="open">
       <ci>a</ci>
       <ci>s</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>o</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>s</ci>
        <ci>normal-′</ci>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <eq></eq>
      <ci>a</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>a</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>italic- and</ci>
       <ci>s</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>normal-′</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   do(a,s)=do(a^{\prime},s^{\prime})\iff a=a^{\prime}\and s=s^{\prime}
  </annotation>
 </semantics>
</math>

. They also include other properties such as the second order induction on situations.</p>
<h2 id="regression">Regression</h2>

<p>Regression is a mechanism for proving consequences in the situation calculus. It is based on expressing a formula containing the situation 

<math display="inline" id="Situation_calculus:67">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>o</ci>
    <interval closure="open">
     <ci>a</ci>
     <ci>s</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   do(a,s)
  </annotation>
 </semantics>
</math>

 in terms of a formula containing the action 

<math display="inline" id="Situation_calculus:68">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 and the situation 

<math display="inline" id="Situation_calculus:69">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

, but not the situation 

<math display="inline" id="Situation_calculus:70">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mi>o</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <ci>o</ci>
    <interval closure="open">
     <ci>a</ci>
     <ci>s</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   do(a,s)
  </annotation>
 </semantics>
</math>

. By iterating this procedure, one can end up with an equivalent formula containing only the initial situation 

<math display="inline" id="Situation_calculus:71">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{0}
  </annotation>
 </semantics>
</math>

. Proving consequences is supposedly simpler from this formula than from the original one.</p>
<h2 id="golog">GOLOG</h2>

<p>GOLOG is a logic programming language based on the situation calculus.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="the-original-version-of-the-situation-calculus">The original version of the situation calculus</h2>

<p>The main difference between the original situation calculus by McCarthy and Hayes and the one in use today is the interpretation of situations. In the modern version of the situational calculus, a situation is a sequence of actions. Originally, situations were defined as “the complete state of the universe at an instant of time”. It was clear from the beginning that such situations could not be completely described; the idea was simply to give some statements about situations, and derive consequences from them. This is also different from the approach that is taken by the <a href="fluent_calculus" title="wikilink">fluent calculus</a>, where a state can be a collection of known facts, that is, a possibly <em>incomplete</em> description of the universe.</p>

<p>In the original version of the situation calculus, fluents are not reified. In other words, conditions that can change are represented by predicates and not by functions. Actually, McCarthy and Hayes defined a fluent as a function that depends on the situation, but they then proceeded always using predicates to represent fluents. For example, the fact that it is raining at place 

<math display="inline" id="Situation_calculus:72">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 in the situation 

<math display="inline" id="Situation_calculus:73">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 is represented by the literal 

<math display="inline" id="Situation_calculus:74">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mi>a</mi>
   <mi>i</mi>
   <mi>n</mi>
   <mi>i</mi>
   <mi>n</mi>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <ci>a</ci>
    <ci>i</ci>
    <ci>n</ci>
    <ci>i</ci>
    <ci>n</ci>
    <ci>g</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>s</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   raining(x,s)
  </annotation>
 </semantics>
</math>

. In the 1986 version of the situation calculus by McCarthy, functional fluents are used. For example, the position of an object 

<math display="inline" id="Situation_calculus:75">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 in the situation 

<math display="inline" id="Situation_calculus:76">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 is represented by the value of 

<math display="inline" id="Situation_calculus:77">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mi>o</mi>
   <mi>c</mi>
   <mi>a</mi>
   <mi>t</mi>
   <mi>i</mi>
   <mi>o</mi>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <ci>o</ci>
    <ci>c</ci>
    <ci>a</ci>
    <ci>t</ci>
    <ci>i</ci>
    <ci>o</ci>
    <ci>n</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>s</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   location(x,s)
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Situation_calculus:78">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mi>o</mi>
   <mi>c</mi>
   <mi>a</mi>
   <mi>t</mi>
   <mi>i</mi>
   <mi>o</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <ci>o</ci>
    <ci>c</ci>
    <ci>a</ci>
    <ci>t</ci>
    <ci>i</ci>
    <ci>o</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   location
  </annotation>
 </semantics>
</math>

 is a function. Statements about such functions can be given using equality

<math display="block" id="Situation_calculus:79">
 <semantics>
  <mrow>
   <mrow>
    <mi>l</mi>
    <mi>o</mi>
    <mi>c</mi>
    <mi>a</mi>
    <mi>t</mi>
    <mi>i</mi>
    <mi>o</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>l</mi>
    <mi>o</mi>
    <mi>c</mi>
    <mi>a</mi>
    <mi>t</mi>
    <mi>i</mi>
    <mi>o</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <msup>
      <mi>s</mi>
      <mo>′</mo>
     </msup>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <ci>c</ci>
     <ci>a</ci>
     <ci>t</ci>
     <ci>i</ci>
     <ci>o</ci>
     <ci>n</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>s</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>l</ci>
     <ci>o</ci>
     <ci>c</ci>
     <ci>a</ci>
     <ci>t</ci>
     <ci>i</ci>
     <ci>o</ci>
     <ci>n</ci>
     <interval closure="open">
      <ci>x</ci>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>s</ci>
       <ci>normal-′</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   location(x,s)=location(x,s^{\prime})
  </annotation>
 </semantics>
</math>

 means that the location of the object 

<math display="inline" id="Situation_calculus:80">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 is the same in the two situations 

<math display="inline" id="Situation_calculus:81">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Situation_calculus:82">
 <semantics>
  <msup>
   <mi>s</mi>
   <mo>′</mo>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>s</ci>
    <ci>normal-′</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s^{\prime}
  </annotation>
 </semantics>
</math>

.</p>

<p>The execution of actions is represented by the function 

<math display="inline" id="Situation_calculus:83">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mi>e</mi>
   <mi>s</mi>
   <mi>u</mi>
   <mi>l</mi>
   <mi>t</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <ci>e</ci>
    <ci>s</ci>
    <ci>u</ci>
    <ci>l</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   result
  </annotation>
 </semantics>
</math>

: the execution of the action 

<math display="inline" id="Situation_calculus:84">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 in the situation 

<math display="inline" id="Situation_calculus:85">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 is the situation 

<math display="inline" id="Situation_calculus:86">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mi>e</mi>
   <mi>s</mi>
   <mi>u</mi>
   <mi>l</mi>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <ci>e</ci>
    <ci>s</ci>
    <ci>u</ci>
    <ci>l</ci>
    <ci>t</ci>
    <interval closure="open">
     <ci>a</ci>
     <ci>s</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   result(a,s)
  </annotation>
 </semantics>
</math>

. The effects of actions are expressed by formulae relating fluents in situation 

<math display="inline" id="Situation_calculus:87">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 and fluents in situations 

<math display="inline" id="Situation_calculus:88">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mi>e</mi>
   <mi>s</mi>
   <mi>u</mi>
   <mi>l</mi>
   <mi>t</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>r</ci>
    <ci>e</ci>
    <ci>s</ci>
    <ci>u</ci>
    <ci>l</ci>
    <ci>t</ci>
    <interval closure="open">
     <ci>a</ci>
     <ci>s</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   result(a,s)
  </annotation>
 </semantics>
</math>

. For example, that the action of opening the door results in the door being open if not locked is represented by:</p>

<p>

<math display="block" id="Situation_calculus:89">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>l</mi>
    <mi>o</mi>
    <mi>c</mi>
    <mi>k</mi>
    <mi>e</mi>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>d</mi>
      <mi>o</mi>
      <mi>o</mi>
      <mi>r</mi>
     </mrow>
     <mo>,</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>o</mi>
    <mi>p</mi>
    <mi>e</mi>
    <mi>n</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>d</mi>
      <mi>o</mi>
      <mi>o</mi>
      <mi>r</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>r</mi>
      <mi>e</mi>
      <mi>s</mi>
      <mi>u</mi>
      <mi>l</mi>
      <mi>t</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>o</mi>
        <mi>p</mi>
        <mi>e</mi>
        <mi>n</mi>
        <mi>s</mi>
       </mrow>
       <mo>,</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <not></not>
     <ci>l</ci>
     <ci>o</ci>
     <ci>c</ci>
     <ci>k</ci>
     <ci>e</ci>
     <ci>d</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>o</ci>
       <ci>o</ci>
       <ci>r</ci>
      </apply>
      <ci>s</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>o</ci>
     <ci>p</ci>
     <ci>e</ci>
     <ci>n</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>o</ci>
       <ci>o</ci>
       <ci>r</ci>
      </apply>
      <apply>
       <times></times>
       <ci>r</ci>
       <ci>e</ci>
       <ci>s</ci>
       <ci>u</ci>
       <ci>l</ci>
       <ci>t</ci>
       <interval closure="open">
        <apply>
         <times></times>
         <ci>o</ci>
         <ci>p</ci>
         <ci>e</ci>
         <ci>n</ci>
         <ci>s</ci>
        </apply>
        <ci>s</ci>
       </interval>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg locked(door,s)\rightarrow open(door,result(opens,s))
  </annotation>
 </semantics>
</math>

</p>

<p>The predicates 

<math display="inline" id="Situation_calculus:90">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mi>o</mi>
   <mi>c</mi>
   <mi>k</mi>
   <mi>e</mi>
   <mi>d</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <ci>o</ci>
    <ci>c</ci>
    <ci>k</ci>
    <ci>e</ci>
    <ci>d</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   locked
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Situation_calculus:91">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mi>p</mi>
   <mi>e</mi>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <ci>p</ci>
    <ci>e</ci>
    <ci>n</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   open
  </annotation>
 </semantics>
</math>

 represent the conditions of a door being locked and open, respectively. Since these condition may vary, they are represented by predicates with a situation argument. The formula says that if the door is not locked in a situation, then the door is open after executing the action of opening, this action being represented by the constant 

<math display="inline" id="Situation_calculus:92">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mi>p</mi>
   <mi>e</mi>
   <mi>n</mi>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <ci>p</ci>
    <ci>e</ci>
    <ci>n</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   opens
  </annotation>
 </semantics>
</math>

.</p>

<p>These formulae are not sufficient to derive everything that is considered plausible. Indeed, fluents at different situations are only related if they are preconditions and effects of actions; if a fluent is not affected by an action, there is no way to deduce it did not change. For example, the formula above does not imply that 

<math display="inline" id="Situation_calculus:93">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>l</mi>
   <mi>o</mi>
   <mi>c</mi>
   <mi>k</mi>
   <mi>e</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>d</mi>
     <mi>o</mi>
     <mi>o</mi>
     <mi>r</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>r</mi>
     <mi>e</mi>
     <mi>s</mi>
     <mi>u</mi>
     <mi>l</mi>
     <mi>t</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>o</mi>
       <mi>p</mi>
       <mi>e</mi>
       <mi>n</mi>
       <mi>s</mi>
      </mrow>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>l</ci>
    <ci>o</ci>
    <ci>c</ci>
    <ci>k</ci>
    <ci>e</ci>
    <ci>d</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>o</ci>
      <ci>o</ci>
      <ci>r</ci>
     </apply>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>e</ci>
      <ci>s</ci>
      <ci>u</ci>
      <ci>l</ci>
      <ci>t</ci>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>o</ci>
        <ci>p</ci>
        <ci>e</ci>
        <ci>n</ci>
        <ci>s</ci>
       </apply>
       <ci>s</ci>
      </interval>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg locked(door,result(opens,s))
  </annotation>
 </semantics>
</math>

 follows from 

<math display="inline" id="Situation_calculus:94">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>l</mi>
   <mi>o</mi>
   <mi>c</mi>
   <mi>k</mi>
   <mi>e</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>d</mi>
     <mi>o</mi>
     <mi>o</mi>
     <mi>r</mi>
    </mrow>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>l</ci>
    <ci>o</ci>
    <ci>c</ci>
    <ci>k</ci>
    <ci>e</ci>
    <ci>d</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>o</ci>
      <ci>o</ci>
      <ci>r</ci>
     </apply>
     <ci>s</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg locked(door,s)
  </annotation>
 </semantics>
</math>

, which is what one would expect (the door is not made locked by opening it). In order for inertia to hold, formulae called <em>frame axioms</em> are needed. These formulae specify all non-effects of actions:</p>

<p>

<math display="block" id="Situation_calculus:95">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>l</mi>
    <mi>o</mi>
    <mi>c</mi>
    <mi>k</mi>
    <mi>e</mi>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>d</mi>
      <mi>o</mi>
      <mi>o</mi>
      <mi>r</mi>
     </mrow>
     <mo>,</mo>
     <mi>s</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi mathvariant="normal">¬</mi>
    <mi>l</mi>
    <mi>o</mi>
    <mi>c</mi>
    <mi>k</mi>
    <mi>e</mi>
    <mi>d</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>d</mi>
      <mi>o</mi>
      <mi>o</mi>
      <mi>r</mi>
     </mrow>
     <mo>,</mo>
     <mrow>
      <mi>r</mi>
      <mi>e</mi>
      <mi>s</mi>
      <mi>u</mi>
      <mi>l</mi>
      <mi>t</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>o</mi>
        <mi>p</mi>
        <mi>e</mi>
        <mi>n</mi>
        <mi>s</mi>
       </mrow>
       <mo>,</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <not></not>
     <ci>l</ci>
     <ci>o</ci>
     <ci>c</ci>
     <ci>k</ci>
     <ci>e</ci>
     <ci>d</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>o</ci>
       <ci>o</ci>
       <ci>r</ci>
      </apply>
      <ci>s</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <not></not>
     <ci>l</ci>
     <ci>o</ci>
     <ci>c</ci>
     <ci>k</ci>
     <ci>e</ci>
     <ci>d</ci>
     <interval closure="open">
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>o</ci>
       <ci>o</ci>
       <ci>r</ci>
      </apply>
      <apply>
       <times></times>
       <ci>r</ci>
       <ci>e</ci>
       <ci>s</ci>
       <ci>u</ci>
       <ci>l</ci>
       <ci>t</ci>
       <interval closure="open">
        <apply>
         <times></times>
         <ci>o</ci>
         <ci>p</ci>
         <ci>e</ci>
         <ci>n</ci>
         <ci>s</ci>
        </apply>
        <ci>s</ci>
       </interval>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg locked(door,s)\rightarrow\neg locked(door,result(opens,s))
  </annotation>
 </semantics>
</math>

</p>

<p>In the original formulation of the situation calculus, the initial situation, later denoted by 

<math display="inline" id="Situation_calculus:96">
 <semantics>
  <msub>
   <mi>S</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{0}
  </annotation>
 </semantics>
</math>

, is not explicitly identified. The initial situation is not needed if situations are taken to be descriptions of the world. For example, to represent the scenario in which the door was closed but not locked and the action of opening it is performed is formalized by taking a constant 

<math display="inline" id="Situation_calculus:97">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

 to mean the initial situation and making statements about it (e.g., 

<math display="inline" id="Situation_calculus:98">
 <semantics>
  <mrow>
   <mi mathvariant="normal">¬</mi>
   <mi>l</mi>
   <mi>o</mi>
   <mi>c</mi>
   <mi>k</mi>
   <mi>e</mi>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>d</mi>
     <mi>o</mi>
     <mi>o</mi>
     <mi>r</mi>
    </mrow>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <not></not>
    <ci>l</ci>
    <ci>o</ci>
    <ci>c</ci>
    <ci>k</ci>
    <ci>e</ci>
    <ci>d</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>o</ci>
      <ci>o</ci>
      <ci>r</ci>
     </apply>
     <ci>s</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \neg locked(door,s)
  </annotation>
 </semantics>
</math>

). That the door is open after the change is reflected by formula 

<math display="inline" id="Situation_calculus:99">
 <semantics>
  <mrow>
   <mi>o</mi>
   <mi>p</mi>
   <mi>e</mi>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>d</mi>
     <mi>o</mi>
     <mi>o</mi>
     <mi>r</mi>
    </mrow>
    <mo>,</mo>
    <mrow>
     <mi>r</mi>
     <mi>e</mi>
     <mi>s</mi>
     <mi>u</mi>
     <mi>l</mi>
     <mi>t</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>o</mi>
       <mi>p</mi>
       <mi>e</mi>
       <mi>n</mi>
       <mi>s</mi>
      </mrow>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>o</ci>
    <ci>p</ci>
    <ci>e</ci>
    <ci>n</ci>
    <interval closure="open">
     <apply>
      <times></times>
      <ci>d</ci>
      <ci>o</ci>
      <ci>o</ci>
      <ci>r</ci>
     </apply>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>e</ci>
      <ci>s</ci>
      <ci>u</ci>
      <ci>l</ci>
      <ci>t</ci>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>o</ci>
        <ci>p</ci>
        <ci>e</ci>
        <ci>n</ci>
        <ci>s</ci>
       </apply>
       <ci>s</ci>
      </interval>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   open(door,result(opens,s))
  </annotation>
 </semantics>
</math>

 being entailed. The initial situation is instead necessary if, like in the modern situation calculus, a situation is taken to be a history of actions, as the initial situation represents the empty sequence of actions.</p>

<p>The version of the situation calculus introduced by McCarthy in 1986 differs to the original one for the use of functional fluents (e.g., 

<math display="inline" id="Situation_calculus:100">
 <semantics>
  <mrow>
   <mi>l</mi>
   <mi>o</mi>
   <mi>c</mi>
   <mi>a</mi>
   <mi>t</mi>
   <mi>i</mi>
   <mi>o</mi>
   <mi>n</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <ci>o</ci>
    <ci>c</ci>
    <ci>a</ci>
    <ci>t</ci>
    <ci>i</ci>
    <ci>o</ci>
    <ci>n</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>s</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   location(x,s)
  </annotation>
 </semantics>
</math>

 is a term representing the position of 

<math display="inline" id="Situation_calculus:101">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 in the situation 

<math display="inline" id="Situation_calculus:102">
 <semantics>
  <mi>s</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>s</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s
  </annotation>
 </semantics>
</math>

) and for an attempt to use <a href="Circumscription_(logic)" title="wikilink">circumscription</a> to replace the frame axioms.</p>
<h2 id="the-situation-calculus-as-a-logic-program">The situation calculus as a logic program</h2>

<p>It is also possible (e.g. Kowalski 1979, Apt and Bezem 1990, Shanahan 1997) to write the situation calculus as a logic program:</p>

<p>

<math display="inline" id="Situation_calculus:103">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mi>o</mi>
    <mi>l</mi>
    <mi>d</mi>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo>,</mo>
     <mrow>
      <mi>d</mi>
      <mi>o</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo>,</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>←</mo>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mi>o</mi>
     <mi>s</mi>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mi>I</mi>
     <mi>n</mi>
     <mi>i</mi>
     <mi>t</mi>
     <mi>i</mi>
     <mi>a</mi>
     <mi>t</mi>
     <mi>e</mi>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>f</mi>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>o</ci>
     <ci>l</ci>
     <ci>d</ci>
     <ci>s</ci>
     <interval closure="open">
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>o</ci>
       <interval closure="open">
        <ci>a</ci>
        <ci>s</ci>
       </interval>
      </apply>
     </interval>
    </apply>
    <apply>
     <and></and>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>o</ci>
      <ci>s</ci>
      <ci>s</ci>
      <interval closure="open">
       <ci>a</ci>
       <ci>s</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>I</ci>
      <ci>n</ci>
      <ci>i</ci>
      <ci>t</ci>
      <ci>i</ci>
      <ci>a</ci>
      <ci>t</ci>
      <ci>e</ci>
      <ci>s</ci>
      <vector>
       <ci>a</ci>
       <ci>f</ci>
       <ci>s</ci>
      </vector>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Holds(f,do(a,s))\leftarrow Poss(a,s)\wedge Initiates(a,f,s)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Situation_calculus:104">
 <semantics>
  <mrow>
   <mrow>
    <mi>H</mi>
    <mi>o</mi>
    <mi>l</mi>
    <mi>d</mi>
    <mi>s</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo>,</mo>
     <mrow>
      <mi>d</mi>
      <mi>o</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo>,</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>←</mo>
   <mrow>
    <mrow>
     <mi>P</mi>
     <mi>o</mi>
     <mi>s</mi>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mi>H</mi>
     <mi>o</mi>
     <mi>l</mi>
     <mi>d</mi>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>f</mi>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mi mathvariant="normal">¬</mi>
     <mi>T</mi>
     <mi>e</mi>
     <mi>r</mi>
     <mi>m</mi>
     <mi>i</mi>
     <mi>n</mi>
     <mi>a</mi>
     <mi>t</mi>
     <mi>e</mi>
     <mi>s</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>f</mi>
      <mo>,</mo>
      <mi>s</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-←</ci>
    <apply>
     <times></times>
     <ci>H</ci>
     <ci>o</ci>
     <ci>l</ci>
     <ci>d</ci>
     <ci>s</ci>
     <interval closure="open">
      <ci>f</ci>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>o</ci>
       <interval closure="open">
        <ci>a</ci>
        <ci>s</ci>
       </interval>
      </apply>
     </interval>
    </apply>
    <apply>
     <and></and>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>o</ci>
      <ci>s</ci>
      <ci>s</ci>
      <interval closure="open">
       <ci>a</ci>
       <ci>s</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>H</ci>
      <ci>o</ci>
      <ci>l</ci>
      <ci>d</ci>
      <ci>s</ci>
      <interval closure="open">
       <ci>f</ci>
       <ci>s</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <not></not>
      <ci>T</ci>
      <ci>e</ci>
      <ci>r</ci>
      <ci>m</ci>
      <ci>i</ci>
      <ci>n</ci>
      <ci>a</ci>
      <ci>t</ci>
      <ci>e</ci>
      <ci>s</ci>
      <vector>
       <ci>a</ci>
       <ci>f</ci>
       <ci>s</ci>
      </vector>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Holds(f,do(a,s))\leftarrow Poss(a,s)\wedge Holds(f,s)\wedge\neg Terminates(a,f%
,s)
  </annotation>
 </semantics>
</math>

</p>

<p>Here 

<math display="inline" id="Situation_calculus:105">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mi>o</mi>
   <mi>l</mi>
   <mi>d</mi>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <ci>o</ci>
    <ci>l</ci>
    <ci>d</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Holds
  </annotation>
 </semantics>
</math>

 is a meta-predicate and the variable 

<math display="inline" id="Situation_calculus:106">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

 ranges over fluents. The predicates 

<math display="inline" id="Situation_calculus:107">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>o</mi>
   <mi>s</mi>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>o</ci>
    <ci>s</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Poss
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Situation_calculus:108">
 <semantics>
  <mrow>
   <mi>I</mi>
   <mi>n</mi>
   <mi>i</mi>
   <mi>t</mi>
   <mi>i</mi>
   <mi>a</mi>
   <mi>t</mi>
   <mi>e</mi>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>I</ci>
    <ci>n</ci>
    <ci>i</ci>
    <ci>t</ci>
    <ci>i</ci>
    <ci>a</ci>
    <ci>t</ci>
    <ci>e</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Initiates
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Situation_calculus:109">
 <semantics>
  <mrow>
   <mi>T</mi>
   <mi>e</mi>
   <mi>r</mi>
   <mi>m</mi>
   <mi>i</mi>
   <mi>n</mi>
   <mi>a</mi>
   <mi>t</mi>
   <mi>e</mi>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>T</ci>
    <ci>e</ci>
    <ci>r</ci>
    <ci>m</ci>
    <ci>i</ci>
    <ci>n</ci>
    <ci>a</ci>
    <ci>t</ci>
    <ci>e</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Terminates
  </annotation>
 </semantics>
</math>

 correspond to the predicates 

<math display="inline" id="Situation_calculus:110">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mi>o</mi>
   <mi>s</mi>
   <mi>s</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <ci>o</ci>
    <ci>s</ci>
    <ci>s</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Poss
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Situation_calculus:111">
 <semantics>
  <mrow>
   <msubsup>
    <mi>γ</mi>
    <mi>F</mi>
    <mo>+</mo>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo>→</mo>
    </mover>
    <mo>,</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>γ</ci>
      <ci>F</ci>
     </apply>
     <plus></plus>
    </apply>
    <vector>
     <apply>
      <ci>normal-→</ci>
      <ci>x</ci>
     </apply>
     <ci>a</ci>
     <ci>s</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma_{F}^{+}(\overrightarrow{x},a,s)
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Situation_calculus:112">
 <semantics>
  <mrow>
   <msubsup>
    <mi>γ</mi>
    <mi>F</mi>
    <mo>-</mo>
   </msubsup>
   <mrow>
    <mo stretchy="false">(</mo>
    <mover accent="true">
     <mi>x</mi>
     <mo>→</mo>
    </mover>
    <mo>,</mo>
    <mi>a</mi>
    <mo>,</mo>
    <mi>s</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>γ</ci>
      <ci>F</ci>
     </apply>
     <minus></minus>
    </apply>
    <vector>
     <apply>
      <ci>normal-→</ci>
      <ci>x</ci>
     </apply>
     <ci>a</ci>
     <ci>s</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \gamma_{F}^{-}(\overrightarrow{x},a,s)
  </annotation>
 </semantics>
</math>

 respectively. The left arrow 

<math display="inline" id="Situation_calculus:113">
 <semantics>
  <mo>←</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-←</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftarrow
  </annotation>
 </semantics>
</math>

 is half of the equivalence 

<math display="inline" id="Situation_calculus:114">
 <semantics>
  <mo>↔</mo>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-↔</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \leftrightarrow
  </annotation>
 </semantics>
</math>

. The other half is implicit in the completion of the program, in which negation is interpreted as <a href="negation_as_failure" title="wikilink">negation as failure</a>. Induction axioms are also implicit, and are needed only to prove program properties. Backward reasoning as in <a href="SLD_resolution" title="wikilink">SLD resolution</a>, which is the usual mechanism used to execute logic programs, implements regression implicitly.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Frame_problem" title="wikilink">Frame problem</a></li>
<li><a href="Event_calculus" title="wikilink">Event calculus</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>J. McCarthy and P. Hayes (1969). <a href="http://www-formal.stanford.edu/jmc/mcchay69.html">Some philosophical problems from the standpoint of artificial intelligence</a>. In B. Meltzer and D. Michie, editors, <em>Machine Intelligence</em>, 4:463–502. Edinburgh University Press, 1969.</li>
<li>R. Kowalski (1979). Logic for Problem Solving - Elsevier North Holland.</li>
<li>K.R. Apt and M. Bezem (1990). Acyclic Programs. In: 7th International Conference on Logic Programming. MIT Press. Jerusalem, Israel.</li>
<li>R. Reiter (1991). The frame problem in the situation calculus: a simple solution (sometimes) and a completeness result for goal regression. In Vladimir Lifshitz, editor, <em>Artificial intelligence and mathematical theory of computation: papers in honour of John McCarthy</em>, pages 359–380, San Diego, CA, USA. Academic Press Professional, Inc. 1991.</li>
<li>M. Shanahan (1997). Solving the Frame Problem: a Mathematical Investigation of the Common Sense Law of Inertia. MIT Press.</li>
<li>H. Levesque, F. Pirri, and R. Reiter (1998). <a href="http://www.ep.liu.se/ej/etai/1998/005">Foundations for the situation calculus</a>. <em><a href="Electronic_Transactions_on_Artificial_Intelligence" title="wikilink">Electronic Transactions on Artificial Intelligence</a></em>, 2(3–4):159-178.</li>
<li>F. Pirri and R. Reiter (1999). Some contributions to the metatheory of the Situation Calculus. <em><a href="Journal_of_the_ACM" title="wikilink">Journal of the ACM</a></em>, 46(3):325–361. </li>
<li>R. Reiter (2001). Knowledge in Action: Logical Foundations for Specifying and Implementing Dynamical Systems. The MIT Press.</li>
</ul>

<p>"</p>

<p><a href="Category:1963_introductions" title="wikilink">Category:1963 introductions</a> <a href="Category:Logic_programming" title="wikilink">Category:Logic programming</a> <a href="Category:Logical_calculi" title="wikilink">Category:Logical calculi</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
