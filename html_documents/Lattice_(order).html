<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1104">Lattice (order)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Lattice (order)</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, a <strong>lattice</strong> is a <a href="partially_ordered_set" title="wikilink">partially ordered set</a> in which every two elements have a unique <a class="uri" href="supremum" title="wikilink">supremum</a> (also called a least upper bound or <a href="Join_and_meet" title="wikilink">join</a>) and a unique <a class="uri" href="infimum" title="wikilink">infimum</a> (also called a greatest lower bound or <a href="Join_and_meet" title="wikilink">meet</a>). An example is given by the <a href="natural_number" title="wikilink">natural numbers</a>, partially ordered by <a class="uri" href="divisibility" title="wikilink">divisibility</a>, for which the unique supremum is the <a href="least_common_multiple" title="wikilink">least common multiple</a> and the unique infimum is the <a href="greatest_common_divisor" title="wikilink">greatest common divisor</a>.</p>

<p>Lattices can also be characterized as <a href="algebraic_structure" title="wikilink">algebraic structures</a> satisfying certain <a href="axiom" title="wikilink">axiomatic</a> <a href="Identity_(mathematics)" title="wikilink">identities</a>. Since the two definitions are equivalent, lattice theory draws on both <a href="order_theory" title="wikilink">order theory</a> and <a href="universal_algebra" title="wikilink">universal algebra</a>. <a href="Semilattice" title="wikilink">Semilattices</a> include lattices, which in turn include <a href="Heyting_algebra" title="wikilink">Heyting</a> and <a href="Boolean_algebra_(structure)" title="wikilink">Boolean algebras</a>. These "lattice-like" structures all admit <a href="order_theory" title="wikilink">order-theoretic</a> as well as algebraic descriptions. </p>
<h2 id="lattices-as-partially-ordered-sets">Lattices as partially ordered sets</h2>

<p>If (<em>L</em>, ≤) is a <a href="partially_ordered_set" title="wikilink">partially ordered set</a> (poset), and <em>S</em>⊆<em>L</em> is an arbitrary subset, then an element <em>u</em>∈<em>L</em> is said to be an <strong>upper bound</strong> of <em>S</em> if <em>s</em>≤<em>u</em> for each <em>s</em>∈<em>S</em>. A set may have many upper bounds, or none at all. An upper bound <em>u</em> of <em>S</em> is said to be its <strong>least upper bound</strong>, or <strong><a href="Join_(mathematics)" title="wikilink">join</a></strong>, or <strong>supremum</strong>, if <em>u</em>≤<em>x</em> for each upper bound <em>x</em> of <em>S</em>. A set need not have a least upper bound, but it cannot have more than one. <a href="duality_(order_theory)" title="wikilink">Dually</a>, <em>l</em>∈<em>L</em> is said to be a <strong>lower bound</strong> of <em>S</em> if <em>l</em>≤<em>s</em> for each <em>s</em>∈<em>S</em>. A lower bound <em>l</em> of <em>S</em> is said to be its <strong>greatest lower bound</strong>, or <strong><a href="meet_(mathematics)" title="wikilink">meet</a></strong>, or <strong>infimum</strong>, if <em>x</em>≤<em>l</em> for each lower bound <em>x</em> of <em>S</em>. A set may have many lower bounds, or none at all, but can have at most one greatest lower bound.</p>

<p>A partially ordered set (<em>L</em>, ≤) is called a <strong><a class="uri" href="join-semilattice" title="wikilink">join-semilattice</a></strong> and a <strong><a class="uri" href="meet-semilattice" title="wikilink">meet-semilattice</a></strong> if each two-element subset {<em>a</em>,<em>b</em>} ⊆ <em>L</em> has a join (i.e. least upper bound) and a meet (i.e. greatest lower bound), denoted by <em>a</em>∨<em>b</em> and <em>a</em>∧<em>b</em>, respectively. (<em>L</em>, ≤) is called a <strong>lattice</strong> if it is both a join- and a meet-semilattice. This definition makes ∨ and ∧ <a href="binary_operation" title="wikilink">binary operations</a>. Both operations are monotone with respect to the order: <em>a</em><sub>1</sub> ≤ <em>a</em><sub>2</sub> and <em>b</em><sub>1</sub> ≤ <em>b</em><sub>2</sub> implies that a<sub>1</sub>∨ b<sub>1</sub> ≤ a<sub>2</sub> ∨ b<sub>2</sub> and a<sub>1</sub>∧b<sub>1</sub> ≤ a<sub>2</sub>∧b<sub>2</sub>.</p>

<p>It follows by an <a href="mathematical_induction" title="wikilink">induction</a> argument that every non-empty finite subset of a lattice has a join and a meet. With additional assumptions, further conclusions may be possible; <em>see</em> <a href="Completeness_(order_theory)" title="wikilink">Completeness (order theory)</a> for more discussion of this subject. That article also discusses how one may rephrase the above definition in terms of the existence of suitable <a href="Galois_connection" title="wikilink">Galois connections</a> between related partially ordered sets — an approach of special interest for the <a href="category_theory" title="wikilink">category theoretic</a> approach to lattices.</p>

<p>A <strong>bounded lattice</strong> is a lattice that additionally has a <strong><a href="greatest_element" title="wikilink">greatest</a></strong> element 1 and a <strong><a href="least_element" title="wikilink">least</a></strong> element 0, which satisfy</p>
<dl>
<dd>0≤<em>x</em>≤1 for every <em>x</em> in <em>L</em>.
</dd>
</dl>

<p>The greatest and least element is also called the <strong>maximum</strong> and <strong>minimum</strong>, or the <strong>top</strong> and <strong>bottom</strong> element, and denoted by ⊤ and ⊥, respectively. Every lattice can be converted into a bounded lattice by adding an artificial greatest and least element, and every non-empty finite lattice is bounded, by taking the join (resp., meet) of all elements, denoted by 

<math display="inline" id="Lattice_(order):0">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋁</mo>
    <mi>L</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>∨</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>∨</mo>
    <msub>
     <mi>a</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <or></or>
     <ci>L</ci>
    </apply>
    <apply>
     <or></or>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigvee L=a_{1}\lor\cdots\lor a_{n}
  </annotation>
 </semantics>
</math>

 (resp.

<math display="inline" id="Lattice_(order):1">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋀</mo>
    <mi>L</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>∧</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>∧</mo>
    <msub>
     <mi>a</mi>
     <mi>n</mi>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <and></and>
     <ci>L</ci>
    </apply>
    <apply>
     <and></and>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-⋯</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigwedge L=a_{1}\land\cdots\land a_{n}
  </annotation>
 </semantics>
</math>

) where 

<math display="inline" id="Lattice_(order):2">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <msub>
     <mi>a</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <msub>
     <mi>a</mi>
     <mi>n</mi>
    </msub>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>L</ci>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>a</ci>
      <ci>n</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L=\{a_{1},\ldots,a_{n}\}
  </annotation>
 </semantics>
</math>

.</p>

<p>A partially ordered set is a bounded lattice if and only if every finite set of elements (including the empty set) has a join and a meet. For every element <em>x</em> of a poset it is trivially true (it is a <a href="vacuous_truth" title="wikilink">vacuous truth</a>) that 

<math display="inline" id="Lattice_(order):3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>a</mi>
    </mrow>
    <mo>∈</mo>
    <mi mathvariant="normal">∅</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>x</mi>
    <mo>≤</mo>
    <mi>a</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>a</ci>
     </apply>
     <emptyset></emptyset>
    </apply>
    <apply>
     <leq></leq>
     <ci>x</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall a\in\varnothing:x\leq a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lattice_(order):4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>a</mi>
    </mrow>
    <mo>∈</mo>
    <mi mathvariant="normal">∅</mi>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mi>a</mi>
    <mo>≤</mo>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <in></in>
     <apply>
      <csymbol cd="latexml">for-all</csymbol>
      <ci>a</ci>
     </apply>
     <emptyset></emptyset>
    </apply>
    <apply>
     <leq></leq>
     <ci>a</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall a\in\varnothing:a\leq x
  </annotation>
 </semantics>
</math>

, and therefore every element of a poset is both an upper bound and a lower bound of the empty set. This implies that the join of an empty set is the least element 

<math display="inline" id="Lattice_(order):5">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋁</mo>
    <mi mathvariant="normal">∅</mi>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <or></or>
     <emptyset></emptyset>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigvee\varnothing=0
  </annotation>
 </semantics>
</math>

, and the meet of the empty set is the greatest element 

<math display="inline" id="Lattice_(order):6">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋀</mo>
    <mi mathvariant="normal">∅</mi>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <and></and>
     <emptyset></emptyset>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigwedge\varnothing=1
  </annotation>
 </semantics>
</math>

. This is consistent with the associativity and commutativity of meet and join: the join of a union of finite sets is equal to the join of the joins of the sets, and dually, the meet of a union of finite sets is equal to the meet of the meets of the sets, i.e., for finite subsets <em>A</em> and <em>B</em> of a poset <em>L</em>,</p>

<p>

<math display="block" id="Lattice_(order):7">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋁</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∪</mo>
      <mi>B</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋁</mo>
      <mi>A</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>∨</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋁</mo>
      <mi>B</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <or></or>
     <apply>
      <union></union>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <or></or>
     <apply>
      <or></or>
      <ci>A</ci>
     </apply>
     <apply>
      <or></or>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigvee\left(A\cup B\right)=\left(\bigvee A\right)\vee\left(\bigvee B\right)
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Lattice_(order):8">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∪</mo>
      <mi>B</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
      <mi>A</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
      <mi>B</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <and></and>
     <apply>
      <union></union>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <and></and>
      <ci>A</ci>
     </apply>
     <apply>
      <and></and>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigwedge\left(A\cup B\right)=\left(\bigwedge A\right)\wedge\left(\bigwedge B\right)
  </annotation>
 </semantics>
</math>

</p>

<p>hold. Taking <em>B</em> to be the empty set,</p>

<p>

<math display="block" id="Lattice_(order):9">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋁</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∪</mo>
      <mi mathvariant="normal">∅</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋁</mo>
      <mi>A</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>∨</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋁</mo>
      <mi mathvariant="normal">∅</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋁</mo>
      <mi>A</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>∨</mo>
    <mn>0</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋁</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <or></or>
      <apply>
       <union></union>
       <ci>A</ci>
       <emptyset></emptyset>
      </apply>
     </apply>
     <apply>
      <or></or>
      <apply>
       <or></or>
       <ci>A</ci>
      </apply>
      <apply>
       <or></or>
       <emptyset></emptyset>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <or></or>
      <apply>
       <or></or>
       <ci>A</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <or></or>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigvee\left(A\cup\emptyset\right)=\left(\bigvee A\right)\vee\left(\bigvee%
\emptyset\right)=\left(\bigvee A\right)\vee 0=\bigvee A
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="block" id="Lattice_(order):10">
 <semantics>
  <mrow>
   <mrow>
    <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>A</mi>
      <mo>∪</mo>
      <mi mathvariant="normal">∅</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
      <mi>A</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>∧</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
      <mi mathvariant="normal">∅</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
      <mi>A</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>∧</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
    <mi>A</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <and></and>
      <apply>
       <union></union>
       <ci>A</ci>
       <emptyset></emptyset>
      </apply>
     </apply>
     <apply>
      <and></and>
      <apply>
       <and></and>
       <ci>A</ci>
      </apply>
      <apply>
       <and></and>
       <emptyset></emptyset>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <and></and>
      <apply>
       <and></and>
       <ci>A</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <and></and>
      <ci>A</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigwedge\left(A\cup\emptyset\right)=\left(\bigwedge A\right)\wedge\left(%
\bigwedge\emptyset\right)=\left(\bigwedge A\right)\wedge 1=\bigwedge A
  </annotation>
 </semantics>
</math>

</p>

<p>which is consistent with the fact that 

<math display="inline" id="Lattice_(order):11">
 <semantics>
  <mrow>
   <mrow>
    <mi>A</mi>
    <mo>∪</mo>
    <mi mathvariant="normal">∅</mi>
   </mrow>
   <mo>=</mo>
   <mi>A</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <union></union>
     <ci>A</ci>
     <emptyset></emptyset>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\cup\emptyset=A
  </annotation>
 </semantics>
</math>

.</p>

<p>A lattice element <em>y</em> is said to <strong><a href="covering_relation" title="wikilink">cover</a></strong> another element <em>x</em>, if <em>y</em>&gt;<em>x</em>, but there does not exist a <em>z</em> such that <em>y</em>&gt;<em>z</em>&gt;<em>x</em>. Here, <em>y</em>&gt;<em>x</em> means <em>x</em> ≤ <em>y</em> and <em>x</em> ≠ <em>y</em>.</p>

<p>A lattice (<em>L</em>,≤) is called <strong><a href="Graded_poset" title="wikilink">graded</a></strong>, sometimes <strong>ranked</strong> (but see <a href="ranked_poset" title="wikilink">this article</a> for an alternative meaning), if it can be equipped with a <strong>rank function</strong> <em>r</em> from <em>L</em> to ℕ, sometimes to ℤ, compatible with the ordering (so <em>r</em>(<em>x</em>)H \subset L, meet and join restrict to <a href="partial_function" title="wikilink">partial functions</a> – they are undefined if their value is not in the subset 

<math display="inline" id="Lattice_(order):12">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

. The resulting structure on 

<math display="inline" id="Lattice_(order):13">
 <semantics>
  <mi>H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H
  </annotation>
 </semantics>
</math>

 is called a <strong></strong>. In addition to this extrinsic definition as a subset of some other algebraic structure (a lattice), a partial lattice can also be intrinsically defined as a set with two partial binary operations satisfying certain axioms.</p>
<h2 id="lattices-as-algebraic-structures">Lattices as algebraic structures</h2>
<h3 id="general-lattice">General lattice</h3>

<p>An <a href="algebraic_structure" title="wikilink">algebraic structure</a> (<em>L</em>, 

<math display="inline" id="Lattice_(order):14">
 <semantics>
  <mrow>
   <mo>∨</mo>
   <mo>,</mo>
   <mo>∧</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <or></or>
    <and></and>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lor,\land
  </annotation>
 </semantics>
</math>


), consisting of a set <em>L</em> and two binary <a href="Operation_(mathematics)" title="wikilink">operations</a> 

<math display="inline" id="Lattice_(order):15">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lor
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="Lattice_(order):16">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \land
  </annotation>
 </semantics>
</math>

, on <em>L</em> is a <strong>lattice</strong> if the following axiomatic identities hold for all elements <em>a, b, c</em> of <em>L</em>.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><dl>
<dt><a href="commutative_property" title="wikilink">Commutative laws</a></dt>
<dd>

<math display="inline" id="Lattice_(order):17">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>∨</mo>
    <mi>b</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>b</mi>
    <mo>∨</mo>
    <mi>a</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <or></or>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <or></or>
     <ci>b</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\lor b=b\lor a
  </annotation>
 </semantics>
</math>

,
</dd>
<dd>

<math display="inline" id="Lattice_(order):18">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>∧</mo>
    <mi>b</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>b</mi>
    <mo>∧</mo>
    <mi>a</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <and></and>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <and></and>
     <ci>b</ci>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\land b=b\land a
  </annotation>
 </semantics>
</math>

.
</dd>
</dl></td>
<td style="text-align: left;">
<p>    </p></td>
<td style="text-align: left;"><dl>
<dt><a href="Associative_property" title="wikilink">Associative laws</a></dt>
<dd>

<math display="inline" id="Lattice_(order):19">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>∨</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>b</mi>
      <mo>∨</mo>
      <mi>c</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mo>∨</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∨</mo>
    <mi>c</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <or></or>
     <ci>a</ci>
     <apply>
      <or></or>
      <ci>b</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <or></or>
     <apply>
      <or></or>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\lor(b\lor c)=(a\lor b)\lor c
  </annotation>
 </semantics>
</math>


,
</dd>
<dd>

<math display="inline" id="Lattice_(order):20">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>b</mi>
      <mo>∧</mo>
      <mi>c</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mo>∧</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>∧</mo>
    <mi>c</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <and></and>
     <ci>a</ci>
     <apply>
      <and></and>
      <ci>b</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <and></and>
     <apply>
      <and></and>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <ci>c</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\land(b\land c)=(a\land b)\land c
  </annotation>
 </semantics>
</math>

.
</dd>
</dl></td>
<td style="text-align: left;">
<p>    </p></td>
<td style="text-align: left;"><dl>
<dt><a href="Absorption_law" title="wikilink">Absorption laws</a>:</dt>
<dd>

<math display="inline" id="Lattice_(order):21">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>∨</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mo>∧</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <or></or>
     <ci>a</ci>
     <apply>
      <and></and>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\lor(a\land b)=a
  </annotation>
 </semantics>
</math>

,
</dd>
<dd>

<math display="inline" id="Lattice_(order):22">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>∧</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mo>∨</mo>
      <mi>b</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <and></and>
     <ci>a</ci>
     <apply>
      <or></or>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\land(a\lor b)=a
  </annotation>
 </semantics>
</math>

.
</dd>
</dl></td>
</tr>
</tbody>
</table>

<p>The following two identities are also usually regarded as axioms, even though they follow from the two absorption laws taken together.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>
<dl>
<dt><a href="Idempotence" title="wikilink">Idempotent laws</a></dt>
<dd>

<math display="inline" id="Lattice_(order):23">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>∨</mo>
    <mi>a</mi>
   </mrow>
   <mo>=</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <or></or>
     <ci>a</ci>
     <ci>a</ci>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\lor a=a
  </annotation>
 </semantics>
</math>

,
</dd>
<dd>

<math display="inline" id="Lattice_(order):24">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>∧</mo>
    <mi>a</mi>
   </mrow>
   <mo>=</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <and></and>
     <ci>a</ci>
     <ci>a</ci>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\land a=a
  </annotation>
 </semantics>
</math>


.
</dd>
</dl>

<p>These axioms assert that both (<em>L</em>,

<math display="inline" id="Lattice_(order):25">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lor
  </annotation>
 </semantics>
</math>

) and (<em>L</em>,

<math display="inline" id="Lattice_(order):26">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \land
  </annotation>
 </semantics>
</math>

) are <a href="semilattice" title="wikilink">semilattices</a>. The absorption laws, the only axioms above in which both meet and join appear, distinguish a lattice from an arbitrary pair of semilattices and assure that the two semilattices interact appropriately. In particular, each semilattice is the <a href="Duality_(order_theory)" title="wikilink">dual</a> of the other.</p>
<h3 id="bounded-lattice">Bounded lattice</h3>

<p>A <strong>bounded lattice</strong> is an algebraic structure of the form (<em>L</em>, 

<math display="inline" id="Lattice_(order):27">
 <semantics>
  <mrow>
   <mo>∨</mo>
   <mo>,</mo>
   <mo>∧</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <or></or>
    <and></and>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lor,\land
  </annotation>
 </semantics>
</math>

, 0, 1) such that (<em>L</em>, 

<math display="inline" id="Lattice_(order):28">
 <semantics>
  <mrow>
   <mo>∨</mo>
   <mo>,</mo>
   <mo>∧</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <or></or>
    <and></and>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lor,\land
  </annotation>
 </semantics>
</math>

) is a lattice, 0 (the lattice's bottom) is the <a href="identity_element" title="wikilink">identity element</a> for the join operation 

<math display="inline" id="Lattice_(order):29">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lor
  </annotation>
 </semantics>
</math>


, and 1 (the lattice's top) is the identity element for the meet operation 

<math display="inline" id="Lattice_(order):30">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \land
  </annotation>
 </semantics>
</math>

.</p>
<dl>
<dt><a href="Identity_(mathematics)" title="wikilink">Identity laws</a></dt>
<dd>

<math display="inline" id="Lattice_(order):31">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>∨</mo>
    <mn>0</mn>
   </mrow>
   <mo>=</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <or></or>
     <ci>a</ci>
     <cn type="integer">0</cn>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\lor 0=a
  </annotation>
 </semantics>
</math>

,
</dd>
<dd>

<math display="inline" id="Lattice_(order):32">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>∧</mo>
    <mn>1</mn>
   </mrow>
   <mo>=</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <and></and>
     <ci>a</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\land 1=a
  </annotation>
 </semantics>
</math>

.
</dd>
</dl>

<p>See <a class="uri" href="semilattice" title="wikilink">semilattice</a> for further details.</p>
<h3 id="connection-to-other-algebraic-structures">Connection to other algebraic structures</h3>

<p>Lattices have some connections to the family of <a href="magma_(algebra)" title="wikilink">group-like algebraic structures</a>. Because meet and join both commute and associate, a lattice can be viewed as consisting of two commutative <a class="uri" href="semigroups" title="wikilink">semigroups</a> having the same domain. For a bounded lattice, these semigroups are in fact commutative <a href="monoid" title="wikilink">monoids</a>. The <a href="absorption_law" title="wikilink">absorption law</a> is the only defining identity that is peculiar to lattice theory.</p>

<p>By commutativity and associativity one can think of join and meet as binary operations that are defined on non-empty finite sets, rather than on elements. In a bounded lattice the empty join and the empty meet can also be defined (as 0 and 1, respectively). This makes bounded lattices somewhat more natural than general lattices, and many authors require all lattices to be bounded.</p>

<p>The algebraic interpretation of lattices plays an essential role in <a href="universal_algebra" title="wikilink">universal algebra</a>.</p>
<h2 id="connection-between-the-two-definitions">Connection between the two definitions</h2>

<p>An order-theoretic lattice gives rise to the two binary operations 

<math display="inline" id="Lattice_(order):33">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lor
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lattice_(order):34">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \land
  </annotation>
 </semantics>
</math>


. Since the commutative, associative and absorption laws can easily be verified for these operations, they make (<em>L</em>, 

<math display="inline" id="Lattice_(order):35">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lor
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Lattice_(order):36">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \land
  </annotation>
 </semantics>
</math>

) into a lattice in the algebraic sense.</p>

<p>The converse is also true. Given an algebraically defined lattice (<em>L</em>, 

<math display="inline" id="Lattice_(order):37">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lor
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Lattice_(order):38">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \land
  </annotation>
 </semantics>
</math>

), one can define a partial order ≤ on <em>L</em> by setting</p>
<dl>
<dd><em>a</em> ≤ <em>b</em> if <em>a</em> = <em>a</em>

<math display="inline" id="Lattice_(order):39">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \land
  </annotation>
 </semantics>
</math>


<em>b</em>, or
</dd>
<dd><em>a</em> ≤ <em>b</em> if <em>b</em> = <em>a</em>

<math display="inline" id="Lattice_(order):40">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lor
  </annotation>
 </semantics>
</math>

<em>b</em>,
</dd>
</dl>

<p>for all elements <em>a</em> and <em>b</em> from <em>L</em>. The laws of absorption ensure that both definitions are equivalent. One can now check that the relation ≤ introduced in this way defines a partial ordering within which binary meets and joins are given through the original operations 

<math display="inline" id="Lattice_(order):41">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lor
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lattice_(order):42">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \land
  </annotation>
 </semantics>
</math>

.</p>

<p>Since the two definitions of a lattice are equivalent, one may freely invoke aspects of either definition in any way that suits the purpose at hand.</p>
<h2 id="examples">Examples</h2>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption><strong>Pic.5:</strong> Lattice of nonnegative integer pairs, ordered componentwise.</figcaption>
</figure></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption><strong>Pic.4:</strong> Lattice of positive integers, ordered by &lt;.</figcaption>
</figure></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption><strong>Pic.3:</strong> Lattice of <a href="partition_(set_theory)" title="wikilink">partitions</a> of {1,2,3,4}, ordered by "<em>refines</em>".</figcaption>
</figure></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption><strong>Pic.2:</strong> Lattice of integer divisors of 60, ordered by "<em>divides</em>".</figcaption>
</figure></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption><strong>Pic.1:</strong> Lattice of subsets of {x,y,z}, ordered by "<em>is subset of</em>". The name "lattice" is suggested by the form of the <a href="Hasse_diagram" title="wikilink">Hasse diagram</a> depicting it.</figcaption>
</figure></td>
</tr>
</tbody>
</table>

<p>{{-}}</p>
<ul>
<li>For any set <em>A</em>, the collection of all subsets of <em>A</em> (called the <a href="power_set" title="wikilink">power set</a> of <em>A</em>) can be ordered via <a href="subset" title="wikilink">subset inclusion</a> to obtain a lattice bounded by <em>A</em> itself and the null set. Set <a href="intersection_(set_theory)" title="wikilink">intersection</a> and <a href="union_(set_theory)" title="wikilink">union</a> interpret meet and join, respectively (see pic.1).</li>
<li>For any set <em>A</em>, the collection of all finite subsets of <em>A</em>, ordered by inclusion, is also a lattice, and will be bounded if and only if <em>A</em> is finite.</li>
<li>For any set <em>A</em>, the collection of all <a href="partition_of_a_set" title="wikilink">partitions</a> of <em>A</em>, ordered by <a href="partition_of_a_set" title="wikilink">refinement</a>, is a lattice (see pic.3).</li>
<li>The <a href="natural_number" title="wikilink">positive integers</a> in their usual order form a lattice, under the operations of "min" and "max". 1 is bottom; there is no top (see pic.4).</li>
<li>The <a href="Cartesian_square" title="wikilink">Cartesian square</a> of the natural numbers, ordered so that (<em>a,b</em>) ≤ (<em>c,d</em>) if <em>a</em>≤<em>c</em> and <em>b</em>≤<em>d</em>. The pair (0,0) is the bottom element; there is no top (see pic.5).</li>
<li>The natural numbers also form a lattice under the operations of taking the <a href="greatest_common_divisor" title="wikilink">greatest common divisor</a> and <a href="least_common_multiple" title="wikilink">least common multiple</a>, with <a class="uri" href="divisibility" title="wikilink">divisibility</a> as the order relation: <em>a</em> ≤ <em>b</em> if <em>a</em> divides <em>b</em>. 1 is bottom; 0 is top. Pic.2 shows a finite sublattice.</li>
<li>Every <a href="complete_lattice" title="wikilink">complete lattice</a> (also see <a href="#Completeness" title="wikilink">below</a>) is a (rather specific) bounded lattice. This class gives rise to a broad range of practical <a href="Complete_lattice#Examples" title="wikilink">examples</a>.</li>
<li>The set of <a href="compact_element" title="wikilink">compact elements</a> of an <a href="arithmetic_lattice" title="wikilink">arithmetic</a> complete lattice is a lattice with a least element, where the lattice operations are given by restricting the respective operations of the arithmetic lattice. This is the specific property which distinguishes arithmetic lattices from <a href="algebraic_lattice" title="wikilink">algebraic lattices</a>, for which the compacts do only form a <a href="semilattice" title="wikilink">join-semilattice</a>. Both of these classes of complete lattices are studied in <a href="domain_theory" title="wikilink">domain theory</a>.</li>
</ul>

<p>Further examples of lattices are given for each of the additional properties discussed below. </p>
<h2 id="counter-examples">Counter-examples</h2>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption><strong>Pic.8:</strong> Non-lattice poset: <em>a</em> and <em>b</em> have common lower bounds 0, <em>d</em>, <em>g</em>, <em>h</em>, and <em>i</em>, but none of them are the <a href="greatest_lower_bound" title="wikilink">greatest lower bound</a>.</figcaption>
</figure></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption><strong>Pic.7:</strong> Non-lattice poset: <em>b</em> and <em>c</em> have common upper bounds <em>d</em>, <em>e</em>, and <em>f</em>, but none of them are the <a href="least_upper_bound" title="wikilink">least upper bound</a>.</figcaption>
</figure></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption><strong>Pic.6:</strong> Non-lattice poset: <em>c</em> and <em>d</em> have no common upper bound.</figcaption>
</figure></td>
</tr>
</tbody>
</table>

<p>Most partial ordered sets are not lattices, including the following.</p>
<ul>
<li>A discrete poset, meaning a poset such that <em>x</em> ≤ <em>y</em> implies <em>x</em> = <em>y</em>, is a lattice if and only if it has at most one element. In particular the two-element discrete poset is not a lattice.</li>
<li>Although the set {1,2,3,6} partially ordered by divisibility is a lattice, the set {1,2,3} so ordered is not a lattice because the pair 2,3 lacks a join, and it lacks a meet in {2,3,6}.</li>
<li>The set {1,2,3,12,18,36} partially ordered by divisibility is not a lattice. Every pair of elements has an upper bound and a lower bound, but the pair 2,3 has three upper bounds, namely 12, 18, and 36, none of which is the least of those three under divisibility (12 and 18 do not divide each other). Likewise the pair 12,18 has three lower bounds, namely 1, 2, and 3, none of which is the greatest of those three under divisibility (2 and 3 do not divide each other).</li>
</ul>
<h2 id="morphisms-of-lattices">Morphisms of lattices</h2>

<p> The appropriate notion of a <a class="uri" href="morphism" title="wikilink">morphism</a> between two lattices flows easily from the <a href="#Lattices_as_algebraic_structures" title="wikilink">above</a> algebraic definition. Given two lattices (<em>L</em>, ∨<sub><em>L</em></sub>, ∧<sub><em>L</em></sub>) and (<em>M</em>, ∨<sub><em>M</em></sub>, ∧<sub><em>M</em></sub>), a <strong>lattice homomorphism</strong> from <em>L</em> to <em>M</em> is a function <em>f</em> : <em>L</em> → <em>M</em> such that for all <em>a</em>, <em>b</em> ∈ <em>L</em>:</p>
<dl>
<dd><em>f</em>(<em>a</em>∨<sub><em>L</em></sub><em>b</em>) = <em>f</em>(<em>a</em>) ∨<sub><em>M</em></sub> <em>f</em>(<em>b</em>), and
</dd>
<dd><em>f</em>(<em>a</em>∧<sub><em>L</em></sub><em>b</em>) = <em>f</em>(<em>a</em>) ∧<sub><em>M</em></sub> <em>f</em>(<em>b</em>).
</dd>
</dl>

<p>Thus <em>f</em> is a <a class="uri" href="homomorphism" title="wikilink">homomorphism</a> of the two underlying <a href="semilattice" title="wikilink">semilattices</a>. When lattices with more structure are considered, the morphisms should "respect" the extra structure, too. In particular, a <strong>bounded-lattice homomorphism</strong> (usually called just "lattice homomorphism") <em>f</em> between two bounded lattices <em>L</em> and <em>M</em> should also have the following property:</p>
<dl>
<dd><em>f</em>(0<sub><em>L</em></sub>) = 0<sub><em>M</em></sub> , and
</dd>
<dd><em>f</em>(1<sub><em>L</em></sub>) = 1<sub><em>M</em></sub> .
</dd>
</dl>

<p>In the order-theoretic formulation, these conditions just state that a homomorphism of lattices is a function <a href="limit_preserving_function_(order_theory)" title="wikilink">preserving</a> binary meets and joins. For bounded lattices, preservation of least and greatest elements is just preservation of join and meet of the empty set.</p>

<p>Any homomorphism of lattices is necessarily <a href="monotone_function" title="wikilink">monotone</a> with respect to the associated ordering relation; see <a href="limit_preserving_function_(order_theory)" title="wikilink">preservation of limits</a>. The converse is not true: monotonicity by no means implies the required preservation of meets and joins (see pic.9), although an <a href="Monotonic_function" title="wikilink">order-preserving</a> <a class="uri" href="bijection" title="wikilink">bijection</a> is a homomorphism if its <a href="inverse_function" title="wikilink">inverse</a> is also order-preserving.</p>

<p>Given the standard definition of <a href="isomorphism" title="wikilink">isomorphisms</a> as invertible morphisms, a <em>lattice isomorphism</em> is just a <a class="uri" href="bijective" title="wikilink">bijective</a> lattice homomorphism. Similarly, a <em>lattice endomorphism</em> is a lattice homomorphism from a lattice to itself, and a <em>lattice automorphism</em> is a bijective lattice endomorphism. Lattices and their homomorphisms form a <a href="category_theory" title="wikilink">category</a>.</p>
<h2 id="sublattices">Sublattices</h2>

<p>A <em>sublattice</em> of a lattice <em>L</em> is a nonempty subset of <em>L</em> that is a lattice with the same meet and join operations as <em>L</em>. That is, if <em>L</em> is a lattice and <em>M</em>

<math display="inline" id="Lattice_(order):43">
 <semantics>
  <mrow>
   <mi></mi>
   <mo>≠</mo>
   <mi mathvariant="normal">∅</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <neq></neq>
    <csymbol cd="latexml">absent</csymbol>
    <emptyset></emptyset>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \not=\varnothing
  </annotation>
 </semantics>
</math>

 is a subset of <em>L</em> such that for every pair of elements <em>a</em>, <em>b</em> in <em>M</em> both <em>a</em>

<math display="inline" id="Lattice_(order):44">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge
  </annotation>
 </semantics>
</math>


<em>b</em> and <em>a</em>

<math display="inline" id="Lattice_(order):45">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vee
  </annotation>
 </semantics>
</math>

<em>b</em> are in <em>M</em>, then <em>M</em> is a sublattice of <em>L</em>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>A sublattice <em>M</em> of a lattice <em>L</em> is a <em>convex sublattice</em> of <em>L</em>, if <em>x ≤ z ≤ y</em> and <em>x</em>, <em>y</em> in <em>M</em> implies that <em>z</em> belongs to <em>M</em>, for all elements <em>x, y, z</em> in <em>L</em>.</p>
<h2 id="properties-of-lattices">Properties of lattices</h2>

<p>We now introduce a number of important properties that lead to interesting special classes of lattices. One, boundedness, has already been discussed.</p>
<h3 id="completeness">Completeness</h3>

<p>A poset is called a <strong>complete lattice</strong> if <em>all</em> its subsets have both a join and a meet. In particular, every complete lattice is a bounded lattice. While bounded lattice homomorphisms in general preserve only finite joins and meets, complete lattice homomorphisms are required to preserve arbitrary joins and meets.</p>

<p>Every poset that is a complete semilattice is also a complete lattice. Related to this result is the interesting phenomenon that there are various competing notions of homomorphism for this class of posets, depending on whether they are seen as complete lattices, complete join-semilattices, complete meet-semilattices, or as join-complete or meet-complete lattices.</p>

<p>Note that "partial lattice" is not the opposite of "complete lattice" – rather, "partial lattice", "lattice", and "complete lattice" are increasingly restrictive definitions.</p>
<h3 id="conditional-completeness">Conditional completeness</h3>

<p>A <strong>conditionally complete lattice</strong> is a lattice in which every <em>nonempty</em> subset <em>that has an upper bound</em> has a join (i.e., a least upper bound). Such lattices provide the most direct generalization of the <a href="completeness_axiom" title="wikilink">completeness axiom</a> of the <a href="real_number" title="wikilink">real numbers</a>. A conditionally complete lattice is either a complete lattice, or a complete lattice without its maximum element 1, its minimum element 0, or both.</p>
<h3 id="distributivity">Distributivity</h3>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption><strong>Pic.11:</strong> Smallest non-modular (and hence non-distributive) lattice N<sub>5</sub>.<br/>
The labelled elements violate the distributivity equation <em>c</em>∧(<em>a</em>∨<em>b</em>)=(<em>c</em>∧<em>a</em>)∨(<em>c</em>∧<em>b</em>), but satisfy its dual <em>c</em>∨(<em>a</em>∧<em>b</em>)=(<em>c</em>∨<em>a</em>)∧(<em>c</em>∨<em>b</em>).</figcaption>
</figure></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><figure><b>(Figure)</b>
<figcaption><strong>Pic.10:</strong> Smallest non-distributive (but modular) lattice M<sub>3</sub>.</figcaption>
</figure></td>
</tr>
</tbody>
</table>

<p>Since lattices come with two binary operations, it is natural to ask whether one of them <a href="distributivity" title="wikilink">distributes</a> over the other, i.e. whether one or the other of the following <a href="duality_(order_theory)" title="wikilink">dual</a> laws holds for every three elements <em>a, b, c</em> of <em>L</em>:</p>
<dl>
<dt>Distributivity of ∨ over ∧</dt>
<dd><em>a</em>∨(<em>b</em>∧<em>c</em>) = (<em>a</em>∨<em>b</em>) ∧ (<em>a</em>∨<em>c</em>).
</dd>
<dt>Distributivity of ∧ over ∨</dt>
<dd><em>a</em>∧(<em>b</em>∨<em>c</em>) = (<em>a</em>∧<em>b</em>) ∨ (<em>a</em>∧<em>c</em>).
</dd>
</dl>

<p>A lattice that satisfies the first or, equivalently (as it turns out), the second axiom, is called a <strong>distributive lattice</strong>. The only non-distributive lattices with fewer than 6 elements are called M<sub>3</sub> and N<sub>5</sub>;<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> they are shown in picture 10 and 11, respectively. A lattice is distributive if and only if it doesn't have a <a href="#Sublattices" title="wikilink">sublattice</a> isomorphic to M<sub>3</sub> or N<sub>5</sub>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> Each distributive lattice is isomorphic to a lattice of sets (with union and intersection as join and meet, respectively).<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p>For an overview of stronger notions of distributivity which are appropriate for complete lattices and which are used to define more special classes of lattices such as <a href="complete_Heyting_algebra" title="wikilink">frames</a> and <a href="completely_distributive_lattice" title="wikilink">completely distributive lattices</a>, see <a href="distributivity_(order_theory)" title="wikilink">distributivity in order theory</a>.</p>
<h3 id="modularity">Modularity</h3>

<p>For some applications the distributivity condition is too strong, and the following weaker property is often useful. A lattice (<em>L</em>, ∨, ∧) is <strong>modular</strong> if, for all elements <em>a, b, c</em> of <em>L</em>, the following identity holds.</p>
<dl>
<dt><strong>Modular identity</strong>: (<em>a</em> ∧ <em>c</em>) ∨ (<em>b</em> ∧ <em>c</em>) = [(<em>a</em> ∧ <em>c</em>) ∨ <em>b</em>] ∧ <em>c</em>.</dt>
</dl>

<p>This condition is equivalent to the following axiom.</p>
<dl>
<dt><strong>Modular law</strong>: <em>a</em> ≤ <em>c</em> implies <em>a</em> ∨ (<em>b</em> ∧ <em>c</em>) = (<em>a</em> ∨ <em>b</em>) ∧ <em>c</em>.</dt>
</dl>

<p>A lattice is modular if and only if it doesn't have a <a href="#Sublattices" title="wikilink">sublattice</a> isomorphic to N<sub>5</sub> (shown in pic.11).<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Besides distributive lattices, examples of modular lattices are the lattice of <a href="two-sided_ideal" title="wikilink">two-sided ideals</a> of a <a href="ring_(mathematics)" title="wikilink">ring</a>, the lattice of submodules of a <a href="module_(mathematics)" title="wikilink">module</a>, and the lattice of <a href="normal_subgroup" title="wikilink">normal subgroups</a> of a <a href="group_(mathematics)" title="wikilink">group</a>. The <a href="Subsumption_lattice" title="wikilink">set of first-order terms</a> with the ordering "<em>is more specific than</em>" is a non-modular lattice used in <a href="automated_reasoning" title="wikilink">automated reasoning</a>.</p>
<h3 id="semimodularity">Semimodularity</h3>

<p>A finite lattice is modular if and only if it is both upper and lower <a href="semimodular_lattice" title="wikilink">semimodular</a>. For a graded lattice, (upper) semimodularity is equivalent to the following condition on the rank function <em>r</em>:</p>

<p>

<math display="block" id="Lattice_(order):46">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <mi>r</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>r</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>y</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>≥</mo>
    <mrow>
     <mrow>
      <mi>r</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>∧</mo>
        <mi>y</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>r</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>∨</mo>
        <mi>y</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>r</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>r</ci>
      <apply>
       <and></and>
       <ci>x</ci>
       <ci>y</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>r</ci>
      <apply>
       <or></or>
       <ci>x</ci>
       <ci>y</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r(x)+r(y)\geq r(x\wedge y)+r(x\vee y).
  </annotation>
 </semantics>
</math>

 Another equivalent (for graded lattices) condition is Birkhoff's condition:</p>
<dl>
<dd>for each <em>x</em> and <em>y</em> in <em>L</em>, if <em>x</em> and <em>y</em> both cover 

<math display="inline" id="Lattice_(order):47">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∧</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\wedge y
  </annotation>
 </semantics>
</math>

, then 

<math display="inline" id="Lattice_(order):48">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∨</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <or></or>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\vee y
  </annotation>
 </semantics>
</math>

 covers both <em>x</em> and <em>y</em>.
</dd>
</dl>

<p>A lattice is called lower semimodular if its dual is semimodular. For finite lattices this means that the previous conditions hold with 

<math display="inline" id="Lattice_(order):49">
 <semantics>
  <mo>∨</mo>
  <annotation-xml encoding="MathML-Content">
   <or></or>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \vee
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Lattice_(order):50">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge
  </annotation>
 </semantics>
</math>

 exchanged, "covers" exchanged with "is covered by", and inequalities reversed.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>
<h3 id="continuity-and-algebraicity">Continuity and algebraicity</h3>

<p>In <a href="domain_theory" title="wikilink">domain theory</a>, it is natural to seek to approximate the elements in a partial order by "much simpler" elements. This leads to the class of <a href="continuous_poset" title="wikilink">continuous posets</a>, consisting of posets where every element can be obtained as the supremum of a <a href="directed_set" title="wikilink">directed set</a> of elements that are <a href="way-below_relation" title="wikilink">way-below</a> the element. If one can additionally restrict these to the <a href="compact_element" title="wikilink">compact elements</a> of a poset for obtaining these directed sets, then the poset is even <a href="algebraic_poset" title="wikilink">algebraic</a>. Both concepts can be applied to lattices as follows:</p>
<ul>
<li>A <strong>continuous lattice</strong> is a complete lattice that is continuous as a poset.</li>
<li>An <strong><a href="algebraic_lattice" title="wikilink">algebraic lattice</a></strong> is a complete lattice that is algebraic as a poset.</li>
</ul>

<p>Both of these classes have interesting properties. For example, continuous lattices can be characterized as algebraic structures (with infinitary operations) satisfying certain identities. While such a characterization is not known for algebraic lattices, they can be described "syntactically" via <a href="Scott_information_system" title="wikilink">Scott information systems</a>.</p>
<h3 id="complements-and-pseudo-complements">Complements and pseudo-complements</h3>

<p>Let <em>L</em> be a bounded lattice with greatest element 1 and least element 0. Two elements <em>x</em> and <em>y</em> of <em>L</em> are <strong>complements</strong> of each other if and only if:</p>

<p>

<math display="block" id="Lattice_(order):51">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>∨</mo>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <or></or>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\vee y=1
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lattice_(order):52">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>∧</mo>
    <mi>y</mi>
   </mrow>
   <mo>=</mo>
   <mn>0.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <and></and>
     <ci>x</ci>
     <ci>y</ci>
    </apply>
    <cn type="float">0.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\wedge y=0.
  </annotation>
 </semantics>
</math>

</p>

<p>In the case the complement is unique, we write ¬<em>x</em> = <em>y</em> and equivalently, ¬<em>y</em> = <em>x</em>. A bounded lattice for which every element has a complement is called a <a href="complemented_lattice" title="wikilink">complemented lattice</a>. The corresponding unary <a href="Operation_(mathematics)" title="wikilink">operation</a> over <em>L</em>, called complementation, introduces an analogue of logical <a class="uri" href="negation" title="wikilink">negation</a> into lattice theory. The complement is not necessarily unique, nor does it have a special status among all possible unary operations over <em>L</em>. A complemented lattice that is also distributive is a <a href="Boolean_algebra_(structure)" title="wikilink">Boolean algebra</a>. For a distributive lattice, the complement of <em>x</em>, when it exists, is unique.</p>

<p><a href="Heyting_algebra" title="wikilink">Heyting algebras</a> are an example of distributive lattices where some members might be lacking complements. Every element <em>x</em> of a Heyting algebra has, on the other hand, a <em>pseudo-complement</em>, also denoted ¬<em>x</em>. The pseudo-complement is the greatest element <em>y</em> such that <em>x</em>

<math display="inline" id="Lattice_(order):53">
 <semantics>
  <mo>∧</mo>
  <annotation-xml encoding="MathML-Content">
   <and></and>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \wedge
  </annotation>
 </semantics>
</math>

<em>y</em> = 0. If the pseudo-complement of every element of a Heyting algebra is in fact a complement, then the Heyting algebra is in fact a Boolean algebra.</p>
<h3 id="jordandedekind-chain-condition">Jordan–Dedekind chain condition</h3>

<p>A <strong>chain</strong> from <em>x</em><sub>0</sub> to <em>x</em><sub><em>n</em></sub> is a set 

<math display="inline" id="Lattice_(order):54">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <set>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>x</ci>
     <ci>n</ci>
    </apply>
   </set>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x_{0},x_{1},\ldots,x_{n}\}
  </annotation>
 </semantics>
</math>


, where 

<math display="inline" id="Lattice_(order):55">
 <semantics>
  <mrow>
   <msub>
    <mi>x</mi>
    <mn>0</mn>
   </msub>
   <mo><</mo>
   <msub>
    <mi>x</mi>
    <mn>1</mn>
   </msub>
   <mo><</mo>
   <msub>
    <mi>x</mi>
    <mn>2</mn>
   </msub>
   <mo><</mo>
   <mi mathvariant="normal">…</mi>
   <mo><</mo>
   <msub>
    <mi>x</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <ci>normal-…</ci>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>x</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x_{0}<x_{1}<x_{2}<\ldots<x_{n}
  </annotation>
 </semantics>
</math>

. The <strong>length</strong> of this chain is <em>n</em>, or one less than its number of elements. A chain is <strong>maximal</strong> if <em>x</em><sub><em>i</em></sub> covers <em>x</em><sub><em>i</em>-1</sub> for all 1 ≤ <em>i</em> ≤ <em>n</em>.</p>

<p>If for any pair, <em>x</em> and <em>y</em>, where <em>x</em> <a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a></p>
<h2 id="important-lattice-theoretic-notions">Important lattice-theoretic notions</h2>

<p>We now define some order-theoretic notions of importance to lattice theory. In the following, let <em>x</em> be an element of some lattice <em>L</em>. If <em>L</em> has a bottom element 0, <em>x</em>≠0 is sometimes required. <em>x</em> is called:</p>
<ul>
<li><strong>Join irreducible</strong> if <em>x</em> = <em>a</em>∨<em>b</em> implies <em>x</em> = <em>a</em> or <em>x</em> = <em>b</em> for all <em>a</em>, <em>b</em> in <em>L</em>. When the first condition is generalized to arbitrary joins 

<math display="inline" id="Lattice_(order):56">
 <semantics>
  <mrow>
   <msub>
    <mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋁</mo>
    <mrow>
     <mi>i</mi>
     <mo>∈</mo>
     <mi>I</mi>
    </mrow>
   </msub>
   <msub>
    <mi>a</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <or></or>
     <apply>
      <in></in>
      <ci>i</ci>
      <ci>I</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>a</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \bigvee_{i\in I}a_{i}
  </annotation>
 </semantics>
</math>

, <em>x</em> is called <strong>completely join irreducible</strong> (or ∨-irreducible). The dual notion is <strong>meet irreducibility</strong> (∧-irreducible). For example, in pic.2, the elements 2, 3, 4, and 5 are join irreducible, while 12, 15, 20, and 30 are meet irreducible. In the lattice of <a href="real_numbers" title="wikilink">real numbers</a> with the usual order, each element is join irreducible, but none is completely join irreducible.</li>
<li><strong>Join prime</strong> if <em>x</em> ≤ <em>a</em> ∨ <em>b</em> implies <em>x</em> ≤ <em>a</em> or <em>x</em> ≤ <em>b</em>. This too can be generalized to obtain the notion <strong>completely join prime</strong>. The dual notion is <strong>meet prime</strong>. Every join-prime element is also join irreducible, and every meet-prime element is also meet irreducible. The converse holds if <em>L</em> is distributive.</li>
</ul>

<p>Let <em>L</em> have a bottom element 0. An element <em>x</em> of <em>L</em> is an <a href="atom_(order_theory)" title="wikilink">atom</a> if 0 a\nleq b, there exists an atom <em>x</em> of <em>L</em> such that 

<math display="inline" id="Lattice_(order):57">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>≤</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <ci>x</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\leq a
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Lattice_(order):58">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>≰</mo>
    <mi>b</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">not-less-than-nor-greater-than</csymbol>
    <ci>x</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\nleq b.
  </annotation>
 </semantics>
</math>

</p>

<p>The notions of <a href="ideal_(order_theory)" title="wikilink">ideals</a> and the dual notion of <a href="filter_(mathematics)" title="wikilink">filters</a> refer to particular kinds of <a href="subset" title="wikilink">subsets</a> of a partially ordered set, and are therefore important for lattice theory. Details can be found in the respective entries.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Join_and_meet" title="wikilink">Join and meet</a></li>
<li><a href="Map_of_lattices" title="wikilink">Map of lattices</a></li>
<li><a href="Orthocomplemented_lattice" title="wikilink">Orthocomplemented lattice</a></li>
<li><a href="Total_order" title="wikilink">Total order</a></li>
<li><a href="Ideal_(order_theory)" title="wikilink">Ideal</a> and <a href="Filter_(mathematics)" title="wikilink">Filter</a> (dual notions)</li>
<li><a href="Skew_lattice" title="wikilink">Skew lattice</a> (generalization to non-commutative join and meet)</li>
<li><a href="Eulerian_lattice" title="wikilink">Eulerian lattice</a></li>
<li><a href="Post's_lattice" title="wikilink">Post's lattice</a></li>
<li><a href="Tamari_lattice" title="wikilink">Tamari lattice</a></li>
<li><a href="Young–Fibonacci_lattice" title="wikilink">Young–Fibonacci lattice</a></li>
<li><a href="0,1-simple_lattice" title="wikilink">0,1-simple lattice</a></li>
</ul>
<h3 id="applications-that-use-lattice-theory">Applications that use lattice theory</h3>

<p><em>Note that in many applications the sets are only partial lattices: not every pair of elements has a meet or join.</em></p>
<ul>
<li><a href="Pointless_topology" title="wikilink">Pointless topology</a></li>
<li><a href="Lattice_of_subgroups" title="wikilink">Lattice of subgroups</a></li>
<li><a href="Spectral_space" title="wikilink">Spectral space</a></li>
<li><a href="Invariant_subspace" title="wikilink">Invariant subspace</a></li>
<li><a href="Closure_operator" title="wikilink">Closure operator</a></li>
<li><a href="Abstract_interpretation" title="wikilink">Abstract interpretation</a></li>
<li><a href="Subsumption_lattice" title="wikilink">Subsumption lattice</a></li>
<li><a href="Fuzzy_set" title="wikilink">Fuzzy set</a> theory</li>
</ul>
<ul>
<li><a href="First-order_logic#Algebraizations" title="wikilink">Algebraizations of first-order logic</a></li>
<li><a href="Semantics_of_programming_languages" title="wikilink">Semantics of programming languages</a></li>
<li><a href="Domain_theory" title="wikilink">Domain theory</a></li>
<li><a href="Ontology_(computer_science)" title="wikilink">Ontology (computer science)</a></li>
<li><a href="Multiple_inheritance" title="wikilink">Multiple inheritance</a></li>
<li><a href="Formal_concept_analysis" title="wikilink">Formal concept analysis</a> and <a href="Lattice_Miner" title="wikilink">Lattice Miner</a> (theory and tool)</li>
<li><a href="Bloom_filter#Compact_approximators" title="wikilink">Bloom filter</a></li>
<li><a href="Information_flow" title="wikilink">Information flow</a></li>
<li><a href="Ordinal_optimization" title="wikilink">Ordinal optimization</a></li>
<li><a href="Quantum_logic" title="wikilink">Quantum logic</a></li>
<li><a href="Median_graph" title="wikilink">Median graph</a></li>
<li><a href="Knowledge_space" title="wikilink">Knowledge space</a></li>
<li><a href="Induction_of_regular_languages#Lattice_of_automata" title="wikilink">Regular language learning</a></li>
<li><a href="Analogical_Modeling" title="wikilink">Analogical Modeling</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>

<p>Monographs available free online:</p>
<ul>
<li>Burris, Stanley N., and H.P. Sankappanavar, H. P., 1981. <em><a href="http://www.thoralf.uwaterloo.ca/htdocs/ualg.html">A Course in Universal Algebra.</a></em> Springer-Verlag. ISBN 3-540-90578-2.</li>
<li>Jipsen, Peter, and Henry Rose, <em><a href="http://www1.chapman.edu/~jipsen/JipsenRoseVoL.html">Varieties of Lattices</a></em>, Lecture Notes in Mathematics 1533, Springer Verlag, 1992. ISBN 0-387-56314-8.</li>
<li>Nation, J. B., <em>Notes on Lattice Theory</em>. <a href="http://www.math.hawaii.edu/~jb/lat1-6.pdf">Chapters 1-6.</a> <a href="http://www.math.hawaii.edu/~jb/lat7-12.pdf">Chapters 7-12; Appendices 1-3.</a></li>
</ul>

<p>Elementary texts recommended for those with limited <a href="mathematical_maturity" title="wikilink">mathematical maturity</a>:</p>
<ul>
<li>Donnellan, Thomas, 1968. <em>Lattice Theory</em>. Pergamon.</li>
<li>Grätzer, G., 1971. <em>Lattice Theory: First concepts and distributive lattices</em>. W. H. Freeman.</li>
</ul>

<p>The standard contemporary introductory text, somewhat harder than the above:</p>
<ul>
<li></li>
</ul>

<p>Advanced monographs:</p>
<ul>
<li><a href="Garrett_Birkhoff" title="wikilink">Garrett Birkhoff</a>, 1967. <em>Lattice Theory</em>, 3rd ed. Vol. 25 of AMS Colloquium Publications. <a href="American_Mathematical_Society" title="wikilink">American Mathematical Society</a>.</li>
<li><a href="Robert_P._Dilworth" title="wikilink">Robert P. Dilworth</a> and Crawley, Peter, 1973. <em>Algebraic Theory of Lattices</em>. Prentice-Hall. ISBN 978-0-13-022269-5.</li>
<li></li>
</ul>

<p>On free lattices:</p>
<ul>
<li>R. Freese, J. Jezek, and J. B. Nation, 1985. "Free Lattices". Mathematical Surveys and Monographs Vol. 42. <a href="Mathematical_Association_of_America" title="wikilink">Mathematical Association of America</a>.</li>
<li>Johnstone, P.T., 1982. <em>Stone spaces</em>. Cambridge Studies in Advanced Mathematics 3. Cambridge University Press.</li>
</ul>

<p>On the history of lattice theory:</p>
<ul>
<li></li>
</ul>

<p>On applications of lattice theory:</p>
<ul>
<li>

<p><a href="http://www.ulb.tu-darmstadt.de/tocs/129983330.pdf">Table of contents</a></p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li></li>
<li>J.B. Nation, <a href="http://www.math.hawaii.edu/~jb/books.html"><em>Notes on Lattice Theory</em></a>, unpublished course notes available as two PDF files.</li>
<li>Ralph Freese, "<a href="http://www.math.hawaii.edu/LatThy/">Lattice Theory Homepage</a>".</li>
</ul>

<p>"</p>

<p><a href="Category:Lattice_theory" title="wikilink"> </a> <a href="Category:Algebraic_structures" title="wikilink">Category:Algebraic structures</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">

<math display="inline" id="Lattice_(order):59">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>∨</mo>
    <mi>a</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>a</mi>
    <mo>∨</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>a</mi>
      <mo>∧</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>a</mi>
        <mo>∨</mo>
        <mi>a</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <or></or>
      <ci>a</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <or></or>
      <ci>a</ci>
      <apply>
       <and></and>
       <ci>a</ci>
       <apply>
        <or></or>
        <ci>a</ci>
        <ci>a</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>a</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a\lor a=a\lor(a\land(a\lor a))=a
  </annotation>
 </semantics>
</math>


, and dually for the other idempotent law. .<a href="#fnref1">↩</a></li>
<li id="fn2">Burris, Stanley N., and H.P. Sankappanavar, H. P., 1981. <em><a href="http://www.thoralf.uwaterloo.ca/htdocs/ualg.html">A Course in Universal Algebra.</a></em> Springer-Verlag. ISBN 3-540-90578-2.<a href="#fnref2">↩</a></li>
<li id="fn3">, Exercise 4.1, [<a class="uri" href="http://books.google.com/books?id=vVVTxeuiyvQC&amp;pg">http://books.google.com/books?id=vVVTxeuiyvQC&amp;pg;</a>;=PA104 p. 104].<a href="#fnref3">↩</a></li>
<li id="fn4">, Theorem 4.10, [<a class="uri" href="http://books.google.com/books?id=vVVTxeuiyvQC&amp;pg">http://books.google.com/books?id=vVVTxeuiyvQC&amp;pg;</a>;=PA89 p. 89].<a href="#fnref4">↩</a></li>
<li id="fn5">, Theorem 10.21, [<a class="uri" href="http://books.google.com/books?id=vVVTxeuiyvQC&amp;pg">http://books.google.com/books?id=vVVTxeuiyvQC&amp;pg;</a>;=PA238 pp. 238–239].<a href="#fnref5">↩</a></li>
<li id="fn6"></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
</ol>
</section>
</body>
</html>
