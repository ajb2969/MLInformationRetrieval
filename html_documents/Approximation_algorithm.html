<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1652">Approximation algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Approximation algorithm</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a> and <a href="operations_research" title="wikilink">operations research</a>, <strong>approximation algorithms</strong> are <a href="algorithm" title="wikilink">algorithms</a> used to find approximate solutions to <a href="optimization_problem" title="wikilink">optimization problems</a>. Approximation algorithms are often associated with <a class="uri" href="NP-hard" title="wikilink">NP-hard</a> problems; since it is unlikely that there can ever be efficient <a href="polynomial_time" title="wikilink">polynomial-time</a> exact algorithms solving NP-hard problems, one settles for polynomial-time sub-optimal solutions. Unlike <a href="heuristic_(computer_science)" title="wikilink">heuristics</a>, which usually only find reasonably good solutions reasonably fast, one wants provable solution quality and provable run-time bounds. Ideally, the approximation is optimal up to a small constant factor (for instance within 5% of the optimal solution). Approximation algorithms are increasingly being used for problems where exact polynomial-time algorithms are known but are too expensive due to the input size. A typical example for an approximation algorithm is the one for <a href="Vertex_cover_problem" title="wikilink">vertex cover</a> in <a href="Graph_(mathematics)" title="wikilink">graphs</a>: find an uncovered edge and add <em>both</em> endpoints to the vertex cover, until none remain. It is clear that the resulting cover is at most twice as large as the optimal one. This is a <a href="constant_factor_approximation_algorithm" title="wikilink">constant factor approximation algorithm</a> with a factor of 2.</p>

<p>NP-hard problems vary greatly in their approximability; some, such as the <a href="bin_packing_problem" title="wikilink">bin packing problem</a>, can be approximated within any factor greater than 1 (such a family of approximation algorithms is often called a <a href="polynomial_time_approximation_scheme" title="wikilink">polynomial time approximation scheme</a> or <em>PTAS</em>). Others are impossible to approximate within any constant, or even polynomial factor unless <a href="P_=_NP" title="wikilink">P = NP</a>, such as the <a href="maximum_clique_problem" title="wikilink">maximum clique problem</a>.</p>

<p>NP-hard problems can often be expressed as <a href="integer_programs" title="wikilink">integer programs</a> (IP) and solved exactly in <a href="exponential_time" title="wikilink">exponential time</a>. Many approximation algorithms emerge from the <a href="linear_programming_relaxation" title="wikilink">linear programming relaxation</a> of the integer program.</p>

<p>Not all approximation algorithms are suitable for all practical applications. They often use IP/LP/<a href="semidefinite_programming" title="wikilink">Semidefinite</a> solvers, complex data structures or sophisticated algorithmic techniques which lead to difficult implementation problems. Also, some approximation algorithms have impractical running times even though they are polynomial time, for example O(<em>n</em><sup>2<sup>156</sup></sup>)<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> . Yet the study of even very expensive algorithms is not a completely theoretical pursuit as they can yield valuable insights. A classic example is the initial PTAS for <a href="Euclidean_traveling_salesman_problem" title="wikilink">Euclidean TSP</a> due to <a href="Sanjeev_Arora" title="wikilink">Sanjeev Arora</a> which had prohibitive running time, yet within a year, Arora refined the ideas into a linear time algorithm. Such algorithms are also worthwhile in some applications where the running times and cost can be justified e.g. <a href="computational_biology" title="wikilink">computational biology</a>, <a href="financial_engineering" title="wikilink">financial engineering</a>, <a href="transportation_planning" title="wikilink">transportation planning</a>, and <a href="inventory_management" title="wikilink">inventory management</a>. In such scenarios, they must compete with the corresponding direct IP formulations.</p>

<p>Another limitation of the approach is that it applies only to optimization problems and not to "pure" <a href="decision_problem" title="wikilink">decision problems</a> like <a href="boolean_satisfiability_problem" title="wikilink">satisfiability</a>, although it is often possible to conceive optimization versions of such problems, such as the <a href="maximum_satisfiability_problem" title="wikilink">maximum satisfiability problem</a> (Max SAT).</p>

<p>Inapproximability has been a fruitful area of research in computational complexity theory since the 1990 result of Feige, Goldwasser, Lovász, Safra and Szegedy on the inapproximability of <a href="Independent_set_(graph_theory)" title="wikilink">Independent Set</a>. After Arora et al. proved the <a href="PCP_theorem" title="wikilink">PCP theorem</a> a year later, it has now been shown that Johnson's 1974 approximation algorithms for Max SAT, Set Cover, Independent Set and Coloring all achieve the optimal approximation ratio, assuming P != NP.</p>
<h2 id="performance-guarantees">Performance guarantees</h2>

<p>For some approximation algorithms it is possible to prove certain properties about the approximation of the optimum result. For example, a <strong><em>ρ</em>-approximation algorithm</strong> <em>A</em> is defined to be an algorithm for which it has been proven that the value/cost, <em>f</em>(<em>x</em>), of the approximate solution <em>A</em>(<em>x</em>) to an instance <em>x</em> will not be more (or less, depending on the situation) than a factor <em>ρ</em> times the value, OPT, of an optimum solution.</p>

<p>

<math display="block" id="Approximation_algorithm:0">
 <semantics>
  <mrow>
   <mo>{</mo>
   <mtable displaystyle="true">
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mrow>
         <mi>OPT</mi>
         <mo>≤</mo>
         <mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>≤</mo>
         <mrow>
          <mi>ρ</mi>
          <mi>OPT</mi>
         </mrow>
        </mrow>
        <mo rspace="22.5pt">,</mo>
        <mrow>
         <mrow>
          <mtext>if</mtext>
          <mi>ρ</mi>
         </mrow>
         <mo>></mo>
         <mn>1</mn>
        </mrow>
       </mrow>
       <mo>;</mo>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
    <mtr>
     <mtd columnalign="left">
      <mrow>
       <mrow>
        <mrow>
         <mi>ρ</mi>
         <mi>OPT</mi>
        </mrow>
        <mo>≤</mo>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mi>x</mi>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
        <mo>≤</mo>
        <mi>OPT</mi>
       </mrow>
       <mo rspace="22.5pt">,</mo>
       <mrow>
        <mrow>
         <mtext>if</mtext>
         <mi>ρ</mi>
        </mrow>
        <mo><</mo>
        <mn>1.</mn>
       </mrow>
      </mrow>
     </mtd>
     <mtd></mtd>
    </mtr>
   </mtable>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">cases</csymbol>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <and></and>
      <apply>
       <leq></leq>
       <ci>OPT</ci>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <leq></leq>
       <share href="#.cmml">
       </share>
       <apply>
        <times></times>
        <ci>ρ</ci>
        <ci>OPT</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <gt></gt>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>ρ</ci>
      </apply>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <mtext>otherwise</mtext>
    <apply>
     <csymbol cd="ambiguous">formulae-sequence</csymbol>
     <apply>
      <and></and>
      <apply>
       <leq></leq>
       <apply>
        <times></times>
        <ci>ρ</ci>
        <ci>OPT</ci>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <leq></leq>
       <share href="#.cmml">
       </share>
       <ci>OPT</ci>
      </apply>
     </apply>
     <apply>
      <lt></lt>
      <apply>
       <times></times>
       <mtext>if</mtext>
       <ci>ρ</ci>
      </apply>
      <cn type="float">1.</cn>
     </apply>
    </apply>
    <mtext>otherwise</mtext>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{cases}\mathrm{OPT}\leq f(x)\leq\rho\mathrm{OPT},\qquad\mbox{if }\rho>1;%
\\
\rho\mathrm{OPT}\leq f(x)\leq\mathrm{OPT},\qquad\mbox{if }\rho<1.\end{cases}
  </annotation>
 </semantics>
</math>

</p>

<p>The factor <em>ρ</em> is called the <em>relative performance guarantee</em>. An approximation algorithm has an <em>absolute performance guarantee</em> or <em>bounded error</em> <em>c</em>, if it has been proven for every instance <em>x</em> that</p>

<p>

<math display="block" id="Approximation_algorithm:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>OPT</mi>
      <mo>-</mo>
      <mi>c</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≤</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>OPT</mi>
      <mo>+</mo>
      <mi>c</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <leq></leq>
     <apply>
      <minus></minus>
      <ci>OPT</ci>
      <ci>c</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <ci>OPT</ci>
      <ci>c</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (\mathrm{OPT}-c)\leq f(x)\leq(\mathrm{OPT}+c).
  </annotation>
 </semantics>
</math>

</p>

<p>Similarly, the <em>performance guarantee</em>, <em>R</em>(<em>x,y</em>), of a solution <em>y</em> to an instance <em>x</em> is defined as</p>

<p>

<math display="block" id="Approximation_algorithm:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>R</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo>,</mo>
      <mi>y</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>max</mi>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mrow>
        <mi>O</mi>
        <mi>P</mi>
        <mi>T</mi>
       </mrow>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>y</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mfrac>
      <mo>,</mo>
      <mfrac>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>y</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mrow>
        <mi>O</mi>
        <mi>P</mi>
        <mi>T</mi>
       </mrow>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>R</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <max></max>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>O</ci>
       <ci>P</ci>
       <ci>T</ci>
      </apply>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>y</ci>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>f</ci>
       <ci>y</ci>
      </apply>
      <apply>
       <times></times>
       <ci>O</ci>
       <ci>P</ci>
       <ci>T</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R(x,y)=\max\left(\frac{OPT}{f(y)},\frac{f(y)}{OPT}\right),
  </annotation>
 </semantics>
</math>

</p>

<p>where <em>f</em>(<em>y</em>) is the value/cost of the solution <em>y</em> for the instance <em>x</em>. Clearly, the performance guarantee is greater than or equal to 1 and equal to 1 if and only if <em>y</em> is an optimal solution. If an algorithm <em>A</em> guarantees to return solutions with a performance guarantee of at most <em>r</em>(<em>n</em>), then <em>A</em> is said to be an <em>r</em>(<em>n</em>)-approximation algorithm and has an <em>approximation ratio</em> of <em>r</em>(<em>n</em>). Likewise, a problem with an <em>r</em>(<em>n</em>)-approximation algorithm is said to be r<em>(</em>n<em>)</em>-<em>approximable</em> or have an approximation ratio of <em>r</em>(<em>n</em>).<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>

<p>One may note that for minimization problems, the two different guarantees provide the same result and that for maximization problems, a relative performance guarantee of ρ is equivalent to a performance guarantee of 

<math display="inline" id="Approximation_algorithm:3">
 <semantics>
  <mrow>
   <mi>r</mi>
   <mo>=</mo>
   <msup>
    <mi>ρ</mi>
    <mrow>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>r</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>ρ</ci>
     <apply>
      <minus></minus>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   r=\rho^{-1}
  </annotation>
 </semantics>
</math>


. In the literature, both definitions are common but it is clear which definition is used since, for maximization problems, as ρ ≤ 1 while r ≥ 1.</p>

<p>The <em>absolute performance guarantee</em> 

<math display="inline" id="Approximation_algorithm:4">
 <semantics>
  <msub>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\Rho</mtext>
   </merror>
   <mi>A</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>\Rho</mtext>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Rho_{A}
  </annotation>
 </semantics>
</math>

 of some approximation algorithm <em>A</em>, where <em>x</em> refers to an instance of a problem, and where 

<math display="inline" id="Approximation_algorithm:5">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>A</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>A</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{A}(x)
  </annotation>
 </semantics>
</math>

 is the performance guarantee of <em>A</em> on <em>x</em> (i.e. ρ for problem instance <em>x</em>) is:</p>

<p>

<math display="block" id="Approximation_algorithm:6">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <merror class="ltx_ERROR undefined undefined">
      <mtext>\Rho</mtext>
     </merror>
     <mi>A</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <mo movablelimits="false">inf</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mi>r</mi>
       <mo>≥</mo>
       <mn>1</mn>
      </mrow>
      <mo>∣</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>R</mi>
         <mi>A</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>x</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>≤</mo>
       <mrow>
        <mi>r</mi>
        <mo>,</mo>
        <mrow>
         <mo>∀</mo>
         <mi>x</mi>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <mtext>\Rho</mtext>
     <ci>A</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">infimum</csymbol>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <geq></geq>
       <ci>r</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <leq></leq>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <ci>A</ci>
        </apply>
        <ci>x</ci>
       </apply>
       <list>
        <ci>r</ci>
        <apply>
         <csymbol cd="latexml">for-all</csymbol>
         <ci>x</ci>
        </apply>
       </list>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Rho_{A}=\inf\{r\geq 1\mid R_{A}(x)\leq r,\forall x\}.
  </annotation>
 </semantics>
</math>

</p>

<p>That is to say that 

<math display="inline" id="Approximation_algorithm:7">
 <semantics>
  <msub>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\Rho</mtext>
   </merror>
   <mi>A</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <mtext>\Rho</mtext>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Rho_{A}
  </annotation>
 </semantics>
</math>

 is the largest bound on the approximation ratio, <em>r</em>, that one sees over all possible instances of the problem. Likewise, the <em>asymptotic performance ratio</em> 

<math display="inline" id="Approximation_algorithm:8">
 <semantics>
  <msubsup>
   <mi>R</mi>
   <mi>A</mi>
   <mi mathvariant="normal">∞</mi>
  </msubsup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>A</ci>
    </apply>
    <infinity></infinity>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{A}^{\infty}
  </annotation>
 </semantics>
</math>


 is:</p>

<p>

<math display="block" id="Approximation_algorithm:9">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>R</mi>
     <mi>A</mi>
     <mi mathvariant="normal">∞</mi>
    </msubsup>
    <mo>=</mo>
    <mrow>
     <mo movablelimits="false">inf</mo>
     <mrow>
      <mo stretchy="false">{</mo>
      <mrow>
       <mi>r</mi>
       <mo>≥</mo>
       <mn>1</mn>
      </mrow>
      <mo>∣</mo>
      <mrow>
       <mrow>
        <mrow>
         <mo>∃</mo>
         <mi>n</mi>
        </mrow>
        <mo>∈</mo>
        <msup>
         <mi>ℤ</mi>
         <mo>+</mo>
        </msup>
       </mrow>
       <mo>,</mo>
       <mrow>
        <mrow>
         <mrow>
          <msub>
           <mi>R</mi>
           <mi>A</mi>
          </msub>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>x</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>≤</mo>
         <mrow>
          <mi>r</mi>
          <mo>,</mo>
          <mrow>
           <mo>∀</mo>
           <mi>x</mi>
          </mrow>
         </mrow>
        </mrow>
        <mo>,</mo>
        <mrow>
         <mrow>
          <mo stretchy="false">|</mo>
          <mi>x</mi>
          <mo stretchy="false">|</mo>
         </mrow>
         <mo>≥</mo>
         <mi>n</mi>
        </mrow>
       </mrow>
      </mrow>
      <mo stretchy="false">}</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <ci>A</ci>
     </apply>
     <infinity></infinity>
    </apply>
    <apply>
     <csymbol cd="latexml">infimum</csymbol>
     <apply>
      <csymbol cd="latexml">conditional-set</csymbol>
      <apply>
       <geq></geq>
       <ci>r</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">formulae-sequence</csymbol>
       <apply>
        <in></in>
        <apply>
         <exists></exists>
         <ci>n</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>ℤ</ci>
         <plus></plus>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">formulae-sequence</csymbol>
        <apply>
         <leq></leq>
         <apply>
          <times></times>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>R</ci>
           <ci>A</ci>
          </apply>
          <ci>x</ci>
         </apply>
         <list>
          <ci>r</ci>
          <apply>
           <csymbol cd="latexml">for-all</csymbol>
           <ci>x</ci>
          </apply>
         </list>
        </apply>
        <apply>
         <geq></geq>
         <apply>
          <abs></abs>
          <ci>x</ci>
         </apply>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{A}^{\infty}=\inf\{r\geq 1\mid\exists n\in\mathbb{Z}^{+},R_{A}(x)\leq r,%
\forall x,|x|\geq n\}.
  </annotation>
 </semantics>
</math>

</p>

<p>That is to say that it is the same as the <em>absolute performance ratio</em>, with a lower bound <em>n</em> on the size of problem instances. These two types of ratios are used because there exist algorithms where the difference between these two is significant.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Performance guarantees</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>max

<math display="block" id="Approximation_algorithm:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <geq></geq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)\geq
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>min

<math display="block" id="Approximation_algorithm:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mi></mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <csymbol cd="latexml">absent</csymbol>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)\leq
  </annotation>
 </semantics>
</math>

</p></td>
</tr>
<tr class="odd">
</tr>
</tbody>
</table>
<h2 id="algorithm-design-techniques">Algorithm design techniques</h2>

<p>By now there are several standard techniques that one tries to design an approximation algorithm. These include the following ones.</p>
<ol>
<li><a href="Greedy_algorithm" title="wikilink">Greedy algorithm</a></li>
<li><a href="Local_search_(optimization)" title="wikilink">Local search</a></li>
<li>Enumeration and <a href="dynamic_programming" title="wikilink">dynamic programming</a></li>
<li>Solving a <a href="convex_programming" title="wikilink">convex programming</a> relaxation to get a fractional solution. Then converting this fractional solution into a feasible solution by some appropriate rounding. The popular relaxations include the following.
<ol>
<li><a href="Linear_programming" title="wikilink">Linear programming</a> relaxation</li>
<li><a href="Semidefinite_programming" title="wikilink">Semidefinite programming</a> relaxation</li>
</ol></li>
<li>Embedding the problem in some simple metric and then solving the problem on the metric. This is also known as metric embedding.</li>
</ol>
<h2 id="epsilon-terms">Epsilon terms</h2>

<p>In the literature, an approximation ratio for a maximization (minimization) problem of <em>c</em> - ϵ (min: <em>c</em> + ϵ) means that the algorithm has an approximation ratio of <em>c</em> ∓ ϵ for arbitrary ϵ &gt; 0 but that the ratio has not (or cannot) be shown for ϵ = 0. An example of this is the optimal inapproximability — inexistence of approximation — ratio of 7 / 8 + ϵ for satisfiable <a class="uri" href="MAX-3SAT" title="wikilink">MAX-3SAT</a> instances due to <a href="Johan_Håstad" title="wikilink">Johan Håstad</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> As mentioned previously, when <em>c</em> = 1, the problem is said to have a <a href="polynomial-time_approximation_scheme" title="wikilink">polynomial-time approximation scheme</a>.</p>

<p>An ϵ-term may appear when an approximation algorithm introduces a multiplicative error and a constant error while the minimum optimum of instances of size <em>n</em> goes to infinity as <em>n</em> does. In this case, the approximation ratio is <em>c</em> ∓ <em>k</em> / OPT = <em>c</em> ∓ o(1) for some constants <em>c</em> and <em>k</em>. Given arbitrary ϵ &gt; 0, one can choose a large enough <em>N</em> such that the term <em>k</em> / OPT  0.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Domination_analysis" title="wikilink">Domination analysis</a> considers guarantees in terms of the rank of the computed solution.</li>
<li><a href="Polynomial-time_approximation_scheme" title="wikilink">PTAS</a> - a type of approximation algorithm that takes the approximation ratio as a parameter</li>
<li><a class="uri" href="APX" title="wikilink">APX</a> is the class of problems with some constant-factor approximation algorithm</li>
<li><a href="Approximation-preserving_reduction" title="wikilink">Approximation-preserving reduction</a></li>
</ul>
<h2 id="citations">Citations</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li><a href="Thomas_H._Cormen" title="wikilink">Thomas H. Cormen</a>, <a href="Charles_E._Leiserson" title="wikilink">Charles E. Leiserson</a>, <a href="Ronald_L._Rivest" title="wikilink">Ronald L. Rivest</a>, and <a href="Clifford_Stein" title="wikilink">Clifford Stein</a>. <em><a href="Introduction_to_Algorithms" title="wikilink">Introduction to Algorithms</a></em>, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Chapter 35: Approximation Algorithms, pp. 1022–1056.</li>
<li><a href="Dorit_S._Hochbaum" title="wikilink">Dorit S. Hochbaum</a>, ed. <em><a href="Approximation_Algorithms_for_NP-Hard_problems" title="wikilink">Approximation Algorithms for NP-Hard problems</a></em>, PWS Publishing Company, 1997. ISBN 0-534-94968-1. Chapter 9: Various Notions of Approximations: Good, Better, Best, and More</li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li>Pierluigi Crescenzi, Viggo Kann, Magnús Halldórsson, <a href="Marek_Karpinski" title="wikilink">Marek Karpinski</a> and Gerhard Woeginger, <a href="http://www.nada.kth.se/~viggo/wwwcompendium/"><em>A compendium of NP optimization problems</em></a>.</li>
</ul>

<p>"</p>

<p><a href="Category:Computational_complexity_theory" title="wikilink">Category:Computational complexity theory</a> <a href="Category:Approximation_algorithms" title="wikilink"> </a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
</ol>
</section>
</body>
</html>
