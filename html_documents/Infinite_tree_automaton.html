<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1384">Infinite tree automaton</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Infinite tree automaton</h1>
<hr/>

<p>In <a href="computer_science" title="wikilink">computer science</a> and <a href="mathematical_logic" title="wikilink">mathematical logic</a>, an <strong>infinite tree automaton</strong> is a <a href="state_machine" title="wikilink">state machine</a> that deals with infinite <a href="Tree_(set_theory)#Tree_(automata_theory)" title="wikilink">tree structure</a>. It can be viewed as an extension from a <a href="tree_automaton" title="wikilink">finite tree automaton</a>, which accepts only finite tree structures. It can also be viewed as an extension of some infinite word automatons such as the <a href="Büchi_automaton" title="wikilink">Büchi automaton</a> and the <a href="Muller_automaton" title="wikilink">Muller automaton</a>.</p>

<p>A finite automaton which runs on an infinite tree was first used by Rabin<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> for proving decidability of monadic <a href="second_order_logic" title="wikilink">second order logic</a>. It has been further observed that tree automaton and logical theories are closely connected and it allows decision problems in logic to be reduced into decision problems for automaton.</p>
<h2 id="definition">Definition</h2>

<p>Infinite tree automaton runs of over a <a href="Tree_(set_theory)#Tree_(automata_theory)" title="wikilink">
<math display="inline" id="Infinite_tree_automaton:0">
<semantics>
<mi mathvariant="normal">Σ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Σ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Sigma
  </annotation>
</semantics>
</math>

-labeled tree</a>. There are many slightly different formulations of tree automaton. Here one of the formulation is described. An <strong>infinite tree automaton</strong> is a tuple 

<math display="inline" id="Infinite_tree_automaton:1">
<semantics>
<mrow>
<mi>A</mi>
<mo>=</mo>
<mrow>
<mo stretchy="false">(</mo>
<mi mathvariant="normal">Σ</mi>
<mo>,</mo>
<mi>D</mi>
<mo>,</mo>
<mi>Q</mi>
<mo>,</mo>
<mi>δ</mi>
<mo>,</mo>
<msub>
<mi>q</mi>
<mn>0</mn>
</msub>
<mo>,</mo>
<mi>F</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<ci>A</ci>
<vector>
<ci>normal-Σ</ci>
<ci>D</ci>
<ci>Q</ci>
<ci>δ</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>q</ci>
<cn type="integer">0</cn>
</apply>
<ci>F</ci>
</vector>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   A=(\Sigma,D,Q,\delta,q_{0},F)
  </annotation>
</semantics>
</math>

 where,</p>
<ul>
<li>
<math display="inline" id="Infinite_tree_automaton:2">
<semantics>
<mi mathvariant="normal">Σ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Σ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Sigma
  </annotation>
</semantics>
</math>

 is an alphabet.</li>
<li>
<math display="inline" id="Infinite_tree_automaton:3">
<semantics>
<mrow>
<mi>D</mi>
<mo>⊂</mo>
<mi>ℕ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<subset></subset>
<ci>D</ci>
<ci>ℕ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   D\subset\mathbb{N}
  </annotation>
</semantics>
</math>

 is a finite set. Each element of 

<math display="inline" id="Infinite_tree_automaton:4">
<semantics>
<mi>D</mi>
<annotation-xml encoding="MathML-Content">
<ci>D</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   D
  </annotation>
</semantics>
</math>

 is an allowed degree in input <a href="tree_structure#Formal_definition" title="wikilink">tree</a>.</li>
<li>
<math display="inline" id="Infinite_tree_automaton:5">
<semantics>
<mi>Q</mi>
<annotation-xml encoding="MathML-Content">
<ci>Q</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   Q
  </annotation>
</semantics>
</math>

 is a finite set of states.</li>
<li>
<math display="inline" id="Infinite_tree_automaton:6">
<semantics>
<mrow>
<mi>δ</mi>
<mo>:</mo>
<mrow>
<mrow>
<mi>Q</mi>
<mo>×</mo>
<mi mathvariant="normal">Σ</mi>
<mo>×</mo>
<mi>D</mi>
</mrow>
<mo>→</mo>
<msup>
<mn>2</mn>
<msup>
<mi>Q</mi>
<mo>*</mo>
</msup>
</msup>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<ci>normal-:</ci>
<ci>δ</ci>
<apply>
<ci>normal-→</ci>
<apply>
<times></times>
<ci>Q</ci>
<ci>normal-Σ</ci>
<ci>D</ci>
</apply>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<cn type="integer">2</cn>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>Q</ci>
<times></times>
</apply>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \delta:Q\times\Sigma\times D\rightarrow 2^{Q^{*}}
  </annotation>
</semantics>
</math>

 is a transition relation that maps an automaton state 

<math display="inline" id="Infinite_tree_automaton:7">
<semantics>
<mrow>
<mi>q</mi>
<mo>∈</mo>
<mi>Q</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>q</ci>
<ci>Q</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   q\in Q
  </annotation>
</semantics>
</math>

, an input letter 

<math display="inline" id="Infinite_tree_automaton:8">
<semantics>
<mrow>
<mi>σ</mi>
<mo>∈</mo>
<mi mathvariant="normal">Σ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>σ</ci>
<ci>normal-Σ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \sigma\in\Sigma
  </annotation>
</semantics>
</math>

, and a degree 

<math display="inline" id="Infinite_tree_automaton:9">
<semantics>
<mrow>
<mi>d</mi>
<mo>∈</mo>
<mi>D</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>d</ci>
<ci>D</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   d\in D
  </annotation>
</semantics>
</math>

 to a set of d-tuple of states.</li>
<li>
<math display="inline" id="Infinite_tree_automaton:10">
<semantics>
<mrow>
<msub>
<mi>q</mi>
<mn>0</mn>
</msub>
<mo>∈</mo>
<mi>Q</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>q</ci>
<cn type="integer">0</cn>
</apply>
<ci>Q</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   q_{0}\in Q
  </annotation>
</semantics>
</math>

 is an initial state of automaton.</li>
<li>
<math display="inline" id="Infinite_tree_automaton:11">
<semantics>
<mrow>
<mi>F</mi>
<mo>⊆</mo>
<msup>
<mi mathvariant="normal">Σ</mi>
<mi>ω</mi>
</msup>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<subset></subset>
<ci>F</ci>
<apply>
<csymbol cd="ambiguous">superscript</csymbol>
<ci>normal-Σ</ci>
<ci>ω</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   F\subseteq\Sigma^{\omega}
  </annotation>
</semantics>
</math>

 is an accepting condition.</li>
</ul>
<h2 id="run">Run</h2>

<p>A <em>run</em> of tree automaton 

<math display="inline" id="Infinite_tree_automaton:12">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

 over a 

<math display="inline" id="Infinite_tree_automaton:13">
<semantics>
<mi mathvariant="normal">Σ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Σ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Sigma
  </annotation>
</semantics>
</math>

-labeled tree 

<math display="inline" id="Infinite_tree_automaton:14">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<mi>T</mi>
<mo>,</mo>
<mi>V</mi>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<interval closure="open">
<ci>T</ci>
<ci>V</ci>
</interval>
</annotation-xml>
<annotation encoding="application/x-tex">
   (T,V)
  </annotation>
</semantics>
</math>

 is a 

<math display="inline" id="Infinite_tree_automaton:15">
<semantics>
<mi>Q</mi>
<annotation-xml encoding="MathML-Content">
<ci>Q</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   Q
  </annotation>
</semantics>
</math>

-labeled tree 

<math display="inline" id="Infinite_tree_automaton:16">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>T</mi>
<mi>r</mi>
</msub>
<mo>,</mo>
<mi>r</mi>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>T</ci>
<ci>r</ci>
</apply>
<ci>r</ci>
</interval>
</annotation-xml>
<annotation encoding="application/x-tex">
   (T_{r},r)
  </annotation>
</semantics>
</math>

. Lets suppose that the tree automaton is at state 

<math display="inline" id="Infinite_tree_automaton:17">
<semantics>
<mi>q</mi>
<annotation-xml encoding="MathML-Content">
<ci>q</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   q
  </annotation>
</semantics>
</math>

 and it has reached to a node t labeled with 

<math display="inline" id="Infinite_tree_automaton:18">
<semantics>
<mrow>
<mi>σ</mi>
<mo>∈</mo>
<mi mathvariant="normal">Σ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>σ</ci>
<ci>normal-Σ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \sigma\in\Sigma
  </annotation>
</semantics>
</math>

 of input tree. 

<math display="inline" id="Infinite_tree_automaton:19">
<semantics>
<mrow>
<mi>d</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>d</ci>
<ci>t</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   d(t)
  </annotation>
</semantics>
</math>

 is degree of node t. Then, the automaton proceeds by selecting a tuple 

<math display="inline" id="Infinite_tree_automaton:20">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>q</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>q</mi>
<mrow>
<mi>d</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</msub>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<vector>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>q</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>q</ci>
<apply>
<times></times>
<ci>d</ci>
<ci>t</ci>
</apply>
</apply>
</vector>
</annotation-xml>
<annotation encoding="application/x-tex">
   (q_{1},...,q_{d(t)})
  </annotation>
</semantics>
</math>

 from set 

<math display="inline" id="Infinite_tree_automaton:21">
<semantics>
<mrow>
<mi>δ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>q</mi>
<mo>,</mo>
<mi>σ</mi>
<mo>,</mo>
<mrow>
<mi>d</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>δ</ci>
<vector>
<ci>q</ci>
<ci>σ</ci>
<apply>
<times></times>
<ci>d</ci>
<ci>t</ci>
</apply>
</vector>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \delta(q,\sigma,d(t))
  </annotation>
</semantics>
</math>

 and splitting into 

<math display="inline" id="Infinite_tree_automaton:22">
<semantics>
<mrow>
<mi>d</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>d</ci>
<ci>t</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   d(t)
  </annotation>
</semantics>
</math>

 copies of itself. For each 

<math display="inline" id="Infinite_tree_automaton:23">
<semantics>
<mrow>
<mn>0</mn>
<mo>&lt;</mo>
<mi>i</mi>
<mo>≤</mo>
<mrow>
<mi>d</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<lt></lt>
<cn type="integer">0</cn>
<ci>i</ci>
</apply>
<apply>
<leq></leq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<ci>d</ci>
<ci>t</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   0<i\leq <="" annotation="" d(t)="">
</i\leq></annotation></semantics>
</math>

, one copy enters into 

<math display="inline" id="Infinite_tree_automaton:24">
<semantics>
<msub>
<mi>q</mi>
<mi>i</mi>
</msub>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>q</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   q_{i}
  </annotation>
</semantics>
</math>

 state and proceeds to the node 

<math display="inline" id="Infinite_tree_automaton:25">
<semantics>
<mrow>
<mi>t</mi>
<mo>.</mo>
<mi>i</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<ci>t</ci>
<ci>i</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   t.i
  </annotation>
</semantics>
</math>

. This process produces a run over a tree.</p>

<p>Formally, a run 

<math display="inline" id="Infinite_tree_automaton:26">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>T</mi>
<mi>r</mi>
</msub>
<mo>,</mo>
<mi>r</mi>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>T</ci>
<ci>r</ci>
</apply>
<ci>r</ci>
</interval>
</annotation-xml>
<annotation encoding="application/x-tex">
   (T_{r},r)
  </annotation>
</semantics>
</math>

 on the input tree satisfy following two conditions:</p>
<ol>
<li>
<math display="inline" id="Infinite_tree_automaton:27">
<semantics>
<mrow>
<mrow>
<mi>r</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>ϵ</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<msub>
<mi>q</mi>
<mn>0</mn>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>r</ci>
<ci>ϵ</ci>
</apply>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>q</ci>
<cn type="integer">0</cn>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   r(\epsilon)=q_{0}
  </annotation>
</semantics>
</math>
</li>
<li>For every 

<math display="inline" id="Infinite_tree_automaton:28">
<semantics>
<mrow>
<mi>t</mi>
<mo>∈</mo>
<msub>
<mi>T</mi>
<mi>r</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>t</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>T</ci>
<ci>r</ci>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   t\in T_{r}
  </annotation>
</semantics>
</math>

 with 

<math display="inline" id="Infinite_tree_automaton:29">
<semantics>
<mrow>
<mrow>
<mi>r</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>=</mo>
<mi>q</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<eq></eq>
<apply>
<times></times>
<ci>r</ci>
<ci>t</ci>
</apply>
<ci>q</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   r(t)=q
  </annotation>
</semantics>
</math>

, there exists a 

<math display="inline" id="Infinite_tree_automaton:30">
<semantics>
<mrow>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>q</mi>
<mn>1</mn>
</msub>
<mo>,</mo>
<mi mathvariant="normal">…</mi>
<mo>,</mo>
<msub>
<mi>q</mi>
<mrow>
<mi>d</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</msub>
<mo stretchy="false">)</mo>
</mrow>
<mo>∈</mo>
<mrow>
<mi>δ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>q</mi>
<mo>,</mo>
<mrow>
<mi>V</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo>,</mo>
<mrow>
<mi>d</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<vector>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>q</ci>
<cn type="integer">1</cn>
</apply>
<ci>normal-…</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>q</ci>
<apply>
<times></times>
<ci>d</ci>
<ci>t</ci>
</apply>
</apply>
</vector>
<apply>
<times></times>
<ci>δ</ci>
<vector>
<ci>q</ci>
<apply>
<times></times>
<ci>V</ci>
<ci>t</ci>
</apply>
<apply>
<times></times>
<ci>d</ci>
<ci>t</ci>
</apply>
</vector>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   (q_{1},...,q_{d(t)})\in\delta(q,V(t),d(t))
  </annotation>
</semantics>
</math>

 such that for every 

<math display="inline" id="Infinite_tree_automaton:31">
<semantics>
<mrow>
<mn>0</mn>
<mo>&lt;</mo>
<mi>i</mi>
<mo>≤</mo>
<mrow>
<mi>d</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<and></and>
<apply>
<lt></lt>
<cn type="integer">0</cn>
<ci>i</ci>
</apply>
<apply>
<leq></leq>
<share href="#.cmml">
</share>
<apply>
<times></times>
<ci>d</ci>
<ci>t</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   0<i\leq <="" annotation="" d(t)="">
</i\leq></annotation></semantics>
</math>

, we have 

<math display="inline" id="Infinite_tree_automaton:32">
<semantics>
<mrow>
<mi>t</mi>
<mo>.</mo>
<mrow>
<mi>i</mi>
<mo>∈</mo>
<msub>
<mi>T</mi>
<mi>r</mi>
</msub>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<csymbol cd="ambiguous">formulae-sequence</csymbol>
<ci>t</ci>
<apply>
<in></in>
<ci>i</ci>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>T</ci>
<ci>r</ci>
</apply>
</apply>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   t.i\in T_{r}
  </annotation>
</semantics>
</math>

 and 

<math display="inline" id="Infinite_tree_automaton:33">
<semantics>
<mrow>
<mi>r</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>t</mi>
<mo>.</mo>
<mi>i</mi>
<mo stretchy="false">)</mo>
</mrow>
<mo>=</mo>
<msub>
<mi>q</mi>
<mi>i</mi>
</msub>
</mrow>
<annotation-xml encoding="MathML-Content">
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<csymbol cd="unknown">r</csymbol>
<cerror>
<csymbol cd="ambiguous">fragments</csymbol>
<ci>normal-(</ci>
<csymbol cd="unknown">t</csymbol>
<ci>normal-.</ci>
<csymbol cd="unknown">i</csymbol>
<ci>normal-)</ci>
</cerror>
<eq></eq>
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>q</ci>
<ci>i</ci>
</apply>
</cerror>
</annotation-xml>
<annotation encoding="application/x-tex">
   r(t.i)=q_{i}
  </annotation>
</semantics>
</math>
</li>
</ol>
<h2 id="acceptance-condition">Acceptance condition</h2>

<p>In a run 

<math display="inline" id="Infinite_tree_automaton:34">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<msub>
<mi>T</mi>
<mi>r</mi>
</msub>
<mo>,</mo>
<mi>r</mi>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<interval closure="open">
<apply>
<csymbol cd="ambiguous">subscript</csymbol>
<ci>T</ci>
<ci>r</ci>
</apply>
<ci>r</ci>
</interval>
</annotation-xml>
<annotation encoding="application/x-tex">
   (T_{r},r)
  </annotation>
</semantics>
</math>

, an infinite path is labeled by a sequence of states. This sequence of states form an infinite word over states. If all these infinite words belong to accepting condition 

<math display="inline" id="Infinite_tree_automaton:35">
<semantics>
<mi>F</mi>
<annotation-xml encoding="MathML-Content">
<ci>F</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   F
  </annotation>
</semantics>
</math>

, then the run is <em>accepting</em>. The interesting accepting conditions are <a href="omega_automaton#Acceptance_conditions" title="wikilink">Büchi</a>, <a href="Rabin_automaton#Acceptance_conditions" title="wikilink">Rabin</a>, <a href="Streett_automaton#Acceptance_conditions" title="wikilink">Streett</a> and <a href="Muller_automaton#Acceptance_conditions" title="wikilink">Muller</a>. If for an input 

<math display="inline" id="Infinite_tree_automaton:36">
<semantics>
<mi mathvariant="normal">Σ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Σ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Sigma
  </annotation>
</semantics>
</math>

-labeled tree 

<math display="inline" id="Infinite_tree_automaton:37">
<semantics>
<mrow>
<mo stretchy="false">(</mo>
<mi>T</mi>
<mo>,</mo>
<mi>V</mi>
<mo stretchy="false">)</mo>
</mrow>
<annotation-xml encoding="MathML-Content">
<interval closure="open">
<ci>T</ci>
<ci>V</ci>
</interval>
</annotation-xml>
<annotation encoding="application/x-tex">
   (T,V)
  </annotation>
</semantics>
</math>

 there exist an accepting run then the input tree is <em>accepted</em> by the automaton. The set of all the accepted 

<math display="inline" id="Infinite_tree_automaton:38">
<semantics>
<mi mathvariant="normal">Σ</mi>
<annotation-xml encoding="MathML-Content">
<ci>normal-Σ</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   \Sigma
  </annotation>
</semantics>
</math>

-labeled trees is called tree language 

<math display="inline" id="Infinite_tree_automaton:39">
<semantics>
<mrow>
<mi class="ltx_font_mathcaligraphic">ℒ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>A</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>ℒ</ci>
<ci>A</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \mathcal{L}(A)
  </annotation>
</semantics>
</math>

 which is <em>recognized</em> by tree automaton 

<math display="inline" id="Infinite_tree_automaton:40">
<semantics>
<mi>A</mi>
<annotation-xml encoding="MathML-Content">
<ci>A</ci>
</annotation-xml>
<annotation encoding="application/x-tex">
   A
  </annotation>
</semantics>
</math>

.</p>
<h2 id="remarks">Remarks</h2>

<p>The set D may seem unusual to some people. Some times D is omitted from the definition when it is a singleton set that means input tree has fixed branching at each node. For example, if D = {2} then the input tree has to be a full binary tree.</p>

<p>Infinite tree automaton is <em>deterministic</em> if for some 

<math display="inline" id="Infinite_tree_automaton:41">
<semantics>
<mrow>
<mi>q</mi>
<mo>∈</mo>
<mi>Q</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>q</ci>
<ci>Q</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   q\in Q
  </annotation>
</semantics>
</math>

, 

<math display="inline" id="Infinite_tree_automaton:42">
<semantics>
<mrow>
<mi>σ</mi>
<mo>∈</mo>
<mi mathvariant="normal">Σ</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>σ</ci>
<ci>normal-Σ</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \sigma\in\Sigma
  </annotation>
</semantics>
</math>

, and 

<math display="inline" id="Infinite_tree_automaton:43">
<semantics>
<mrow>
<mi>d</mi>
<mo>∈</mo>
<mi>D</mi>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<in></in>
<ci>d</ci>
<ci>D</ci>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   d\in D
  </annotation>
</semantics>
</math>

 transition relation 

<math display="inline" id="Infinite_tree_automaton:44">
<semantics>
<mrow>
<mi>δ</mi>
<mrow>
<mo stretchy="false">(</mo>
<mi>q</mi>
<mo>,</mo>
<mi>σ</mi>
<mo>,</mo>
<mi>d</mi>
<mo stretchy="false">)</mo>
</mrow>
</mrow>
<annotation-xml encoding="MathML-Content">
<apply>
<times></times>
<ci>δ</ci>
<vector>
<ci>q</ci>
<ci>σ</ci>
<ci>d</ci>
</vector>
</apply>
</annotation-xml>
<annotation encoding="application/x-tex">
   \delta(q,\sigma,d)
  </annotation>
</semantics>
</math>

 has exactly one element. Otherwise the automaton is <em>non-deterministic</em>.</p>
<h2 id="accepting-tree-languages">Accepting tree languages</h2>

<p>Muller, parity, Rabin, and Streett accepting conditions in an infinite tree automaton recognize the same tree languages.</p>

<p>But, Büchi accepting condition is strictly weaker than other accepting conditions, i.e., there exists a tree language which can be recognized by Muller accepting condition in infinite tree automata but can't be recognized by any Büchi accepting condition in some infinite tree automaton.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>Tree languages which are recognized by Muller accepting conditions are closed under union, intersection, projection and complementation.</p>
<h2 id="reference-list">Reference list</h2>
<references>
</references>

<p>"</p>

<p><a href="Category:Trees_(data_structures)" title="wikilink">Category:Trees (data structures)</a> <a href="Category:Automata_theory" title="wikilink">Category:Automata theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Rabin, M. O.: <em>Decidability of second order theories and automata on infinite trees</em>,<em><a href="Transactions_of_the_American_Mathematical_Society" title="wikilink">Transactions of the American Mathematical Society</a></em>, vol. 141, pp. 1–35, 1969.<a href="#fnref1">↩</a></li>
<li id="fn2">Rabin, M. O.: <em>Weakly definable relations and special automata</em>,<em>Mathematical logic and foundation of set theory</em>, pp. 1–23, 1970.<a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
