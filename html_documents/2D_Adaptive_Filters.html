<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="1361">2D Adaptive Filters</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>2D Adaptive Filters</h1>
<hr/>

<p>A <strong>two-dimensional (2D) adaptive filter</strong> is very much like an 1-dimensional <a href="adaptive_filter" title="wikilink">adaptive filter</a> in the sense that it is a linear system whose parameters are adaptively updated throughout the process, according to some optimization approach. The main difference between 1D and 2D adaptive filters is that the former usually takes as inputs signals with respect to time, what implies in <a href="Causal_system" title="wikilink">causality</a> constraints, while the latter handles signals with 2 dimensions, like x-y coordinates in the space domain, which are usually non-causal. Moreover, just like 1D filters, most 2D adaptive filters are <a href="digital_filter" title="wikilink">digital filters</a>, because of the complex and iterative nature of the algorithms.</p>
<h2 id="motivation">Motivation</h2>

<p>The topic of 2D adaptive filters is very important in electrical engineering and <a href="signal_processing" title="wikilink">signal processing</a> since these filters have the ability to take into account the nonstationary statistical properties of 2D signals. Adaptive filters find applications in areas such as <a href="Active_noise_control" title="wikilink">Noise cancellation</a>, <a href="Linear_prediction" title="wikilink">Signal prediction</a>, <a href="Equalization_payments" title="wikilink">Equalization</a> and <a href="Echo_suppression_and_cancellation" title="wikilink">Echo cancellation</a>. Examples of applications of 2D adaptive filters include Image Denoising,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Motion Tracking,<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> OFDM channel estimation,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> magnetic recording equalization <a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>
<h2 id="example-application">Example Application</h2>

<p> 2D Adaptive Filters can be used to identify systems. The system function of the unknown system is given by 

<math display="inline" id="2D_Adaptive_Filters:0">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>z</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>z</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(z_{1},z_{2})
  </annotation>
 </semantics>
</math>

, and 

<math display="inline" id="2D_Adaptive_Filters:1">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>z</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>z</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(z_{1},z_{2})
  </annotation>
 </semantics>
</math>

 is the system function of the 2D adaptive filter when its output comes to steady. The error signal 

<math display="inline" id="2D_Adaptive_Filters:2">
 <semantics>
  <mrow>
   <mi>e</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>n</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>n</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>e</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e(n_{1},n_{2})
  </annotation>
 </semantics>
</math>

 between the unknown system output,

<math display="inline" id="2D_Adaptive_Filters:3">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>n</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>n</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(n_{1},n_{2})
  </annotation>
 </semantics>
</math>

, and the adaptive filter output,

<math display="inline" id="2D_Adaptive_Filters:4">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>n</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>n</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(n_{1},n_{2})
  </annotation>
 </semantics>
</math>

, is minimized if the unknown system and known 2D adaptive filter have the same input, and if the resulting outputs are similar. Then, it can be shown that 

<math display="inline" id="2D_Adaptive_Filters:5">
 <semantics>
  <mrow>
   <mi>P</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>z</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>z</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>P</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P(z_{1},z_{2})
  </annotation>
 </semantics>
</math>

 can be represented by 

<math display="inline" id="2D_Adaptive_Filters:6">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>z</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>z</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(z_{1},z_{2})
  </annotation>
 </semantics>
</math>

. 

<math display="inline" id="2D_Adaptive_Filters:7">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>z</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>z</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>z</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(z_{1},z_{2})
  </annotation>
 </semantics>
</math>

 is known as the system identification model of the unknown system.</p>
<h2 id="problem-statement">Problem Statement</h2>
<figure><b>(Figure)</b>
<figcaption>General Block Diagram for a 2D Adaptive Filter.</figcaption>
</figure>

<p>In digital signal processing, any <a href="LTI_system_theory" title="wikilink">linear shift invariant</a> system can be represented by the <a class="uri" href="convolution" title="wikilink">convolution</a> of the signal with the filter's <a href="impulse_response" title="wikilink">impulse response</a>, given by the expression:</p>

<p>

<math display="inline" id="2D_Adaptive_Filters:8">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>n</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>n</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mo largeop="true" symmetric="true">∑</mo>
     <msub>
      <mi>m</mi>
      <mn>1</mn>
     </msub>
    </msub>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <msub>
       <mi>m</mi>
       <mn>2</mn>
      </msub>
     </msub>
     <mrow>
      <mi>w</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>m</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>m</mi>
        <mn>2</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>n</mi>
         <mn>1</mn>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>m</mi>
         <mn>1</mn>
        </msub>
       </mrow>
       <mo>,</mo>
       <mrow>
        <msub>
         <mi>n</mi>
         <mn>2</mn>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>m</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <sum></sum>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>m</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <ci>w</ci>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <cn type="integer">2</cn>
        </apply>
       </interval>
       <ci>x</ci>
       <interval closure="open">
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(n_{1},n_{2})=\sum_{m_{1}}\sum_{m_{2}}w(m_{1},m_{2})x(n_{1}-m_{1},n_{2}-m_{2})
  </annotation>
 </semantics>
</math>

</p>

<p>If this system is to model a desired response 

<math display="inline" id="2D_Adaptive_Filters:9">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>n</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>n</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(n_{1},n_{2})
  </annotation>
 </semantics>
</math>

, the adaptive system can be obtained by continuously adjusting the weight values according to some cost function 

<math display="inline" id="2D_Adaptive_Filters:10">
 <semantics>
  <mrow>
   <mi>F</mi>
   <mrow>
    <mo stretchy="false">[</mo>
    <mrow>
     <mi>e</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>n</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>n</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>F</ci>
    <apply>
     <csymbol cd="latexml">delimited-[]</csymbol>
     <apply>
      <times></times>
      <ci>e</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F[e(n_{1},n_{2})]
  </annotation>
 </semantics>
</math>

 that evaluates the error between the two responses.</p>

<p>

<math display="inline" id="2D_Adaptive_Filters:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>n</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>n</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>n</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>n</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>n</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>n</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>e</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>d</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>y</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e(n_{1},n_{2})=d(n_{1},n_{2})-y(n_{1},n_{2})
  </annotation>
 </semantics>
</math>

<br/>


<math display="inline" id="2D_Adaptive_Filters:12">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>j</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>n</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>n</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>w</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>n</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>n</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">[</mo>
      <mrow>
       <mi>e</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>n</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>n</mi>
         <mn>2</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">]</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <apply>
       <plus></plus>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>j</ci>
      </apply>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>F</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>e</ci>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <cn type="integer">2</cn>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{j+1}(n_{1},n_{2})=w_{j}(n_{1},n_{2})+F[e(n_{1},n_{2})]
  </annotation>
 </semantics>
</math>

</p>
<h2 id="approaches">Approaches</h2>
<h3 id="d-least-mean-square-fir-adaptive-filters">2D Least Mean Square FIR Adaptive Filters</h3>

<p><strong>Least mean square (LMS) Adaptive Filters</strong> <a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> use the most common error measure method, the mean square error. The 2D LMS Adaptive filters are derived from the 1D <a href="Least_mean_squares_filter" title="wikilink">LMS adaptvie filters</a> main method which minimizes the output mean square value by adjusting coefficients of the filter. The filter has the primary 2D input signal d and the reference input signal x. The primary input signal d consists of the ideal signal and noise component. The filter is an N by N causal FIR filter with impulse response 

<math display="inline" id="2D_Adaptive_Filters:13">
 <semantics>
  <mi>w</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>w</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w
  </annotation>
 </semantics>
</math>

. Then we can get the filter output given by</p>

<p>

<math display="inline" id="2D_Adaptive_Filters:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>n</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>n</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∑</mo>
     <mrow>
      <msub>
       <mi>m</mi>
       <mn>1</mn>
      </msub>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mrow>
      <mi>N</mi>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msubsup>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <msub>
        <mi>m</mi>
        <mn>2</mn>
       </msub>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mrow>
      <msub>
       <mi>w</mi>
       <mi>j</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>m</mi>
        <mn>1</mn>
       </msub>
       <mo>,</mo>
       <msub>
        <mi>m</mi>
        <mn>2</mn>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>x</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>n</mi>
         <mn>1</mn>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>m</mi>
         <mn>1</mn>
        </msub>
       </mrow>
       <mo>,</mo>
       <mrow>
        <msub>
         <mi>n</mi>
         <mn>2</mn>
        </msub>
        <mo>-</mo>
        <msub>
         <mi>m</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <eq></eq>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <ci>N</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <cn type="integer">2</cn>
         </apply>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>N</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>w</ci>
        <ci>j</ci>
       </apply>
       <interval closure="open">
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <cn type="integer">2</cn>
        </apply>
       </interval>
       <ci>x</ci>
       <interval closure="open">
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>n</ci>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
       </interval>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(n_{1},n_{2})=\sum_{m_{1}=0}^{N-1}\sum_{m_{2}=0}^{N-1}w_{j}(m_{1},m_{2})x(n_{%
1}-m_{1},n_{2}-m_{2})
  </annotation>
 </semantics>
</math>

</p>

<p>where j is the iteration number for adaptive filters.</p>

<p>The error signal 

<math display="inline" id="2D_Adaptive_Filters:15">
 <semantics>
  <msub>
   <mi>e</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>e</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{j}
  </annotation>
 </semantics>
</math>

 at the j-th iteration is defined as</p>

<p>

<math display="inline" id="2D_Adaptive_Filters:16">
 <semantics>
  <mrow>
   <msub>
    <mi>e</mi>
    <mi>j</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>n</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>n</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <msub>
        <mi>m</mi>
        <mn>1</mn>
       </msub>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mrow>
       <mi>N</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <msub>
         <mi>m</mi>
         <mn>2</mn>
        </msub>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <mrow>
        <mi>N</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msubsup>
      <mrow>
       <msub>
        <mi>w</mi>
        <mi>j</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>m</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>m</mi>
         <mn>2</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>n</mi>
          <mn>1</mn>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>m</mi>
          <mn>1</mn>
         </msub>
        </mrow>
        <mo>,</mo>
        <mrow>
         <msub>
          <mi>n</mi>
          <mn>2</mn>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>m</mi>
          <mn>2</mn>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>e</ci>
     <ci>j</ci>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>d</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </interval>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <cn type="integer">1</cn>
         </apply>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <ci>N</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>m</ci>
           <cn type="integer">2</cn>
          </apply>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>N</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>w</ci>
         <ci>j</ci>
        </apply>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <cn type="integer">2</cn>
         </apply>
        </interval>
        <ci>x</ci>
        <interval closure="open">
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>m</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>n</ci>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>m</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e_{j}=d(n_{1},n_{2})-\sum_{m_{1}=0}^{N-1}\sum_{m_{2}=0}^{N-1}w_{j}(m_{1},m_{2}%
)x(n_{1}-m_{1},n_{2}-m_{2})
  </annotation>
 </semantics>
</math>

</p>

<p>The weight matrix at the next iteration is equal to the present weight matrix plus a change proportional to the negative gradient of the mean square error. For the two-dimensional LMS adaptive filter, the filter coefficients are updated as follows:</p>

<p>

<math display="inline" id="2D_Adaptive_Filters:17">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>w</mi>
     <mrow>
      <mi>j</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>n</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>n</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msub>
      <mi>w</mi>
      <mi>j</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>n</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>n</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>2</mn>
     <mi>μ</mi>
     <msub>
      <mi>e</mi>
      <mi>j</mi>
     </msub>
     <mi>x</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>n</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>n</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>w</ci>
      <apply>
       <plus></plus>
       <ci>j</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>w</ci>
       <ci>j</ci>
      </apply>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>μ</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>e</ci>
       <ci>j</ci>
      </apply>
      <ci>x</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   w_{j+1}(n_{1},n_{2})=w_{j}(n_{1},n_{2})+2\mu e_{j}x(n_{1},n_{2})
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="2D_Adaptive_Filters:18">
 <semantics>
  <mi>μ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>μ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mu
  </annotation>
 </semantics>
</math>

 is the scaler mutiplier controlling which can control the rate of convergence and filter stability.</p>

<p><strong>Advantages</strong>: The TDLMS adaptive filter can be implemented without any form of matrix operations or any averaging or differentiation. The algorithm convergence does not depend on the initial conditions and it will converge for any arbitrarily initial value, hence, it provides good performance in nonstationary images.</p>

<p><strong>Disadvantages</strong>: The exact values of the expectations of the TDLMS adaptive filter will not converges to a fixed value, if we need to maintain its tracking ability. Therefore, the design choice of μ depends on the particular application and it involves a tradeoff between the convergence speed, tracking ability, and steady-state MSE.</p>
<h3 id="d-least-mean-square-iir-adaptive-filters">2D Least Mean Square IIR Adaptive Filters</h3>

<p>For a two-dimensional LMS IIR Adaptive filter, its basic idea is the same as 2D LMS FIR Adaptive Filters, except we are using an <a href="Infinite_impulse_response" title="wikilink">IIR filter</a>, which can reduce the filter order requirements.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> The two-dimensional IIR filter`s difference equation can be written as</p>

<p>

<math display="inline" id="2D_Adaptive_Filters:19">
 <semantics>
  <mrow>
   <mrow>
    <mi>y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>n</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>n</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <msub>
        <mi>m</mi>
        <mn>1</mn>
       </msub>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <msub>
       <mi>M</mi>
       <mn>1</mn>
      </msub>
     </msubsup>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <msub>
         <mi>m</mi>
         <mn>2</mn>
        </msub>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <msub>
        <mi>M</mi>
        <mn>2</mn>
       </msub>
      </msubsup>
      <mrow>
       <mi>a</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>m</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>m</mi>
         <mn>2</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>x</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>n</mi>
          <mn>1</mn>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>m</mi>
          <mn>1</mn>
         </msub>
        </mrow>
        <mo>,</mo>
        <mrow>
         <msub>
          <mi>n</mi>
          <mn>2</mn>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>m</mi>
          <mn>2</mn>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <msub>
        <mi>m</mi>
        <mn>1</mn>
       </msub>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <msub>
       <mi>L</mi>
       <mn>1</mn>
      </msub>
     </msubsup>
     <mrow>
      <mmultiscripts>
       <mo largeop="true" symmetric="true">∑</mo>
       <mrow>
        <msub>
         <mi>m</mi>
         <mn>2</mn>
        </msub>
        <mo>=</mo>
        <mn>0</mn>
       </mrow>
       <msub>
        <mi>L</mi>
        <mn>2</mn>
       </msub>
       <mrow>
        <mrow>
         <mo stretchy="false">(</mo>
         <msub>
          <mi>m</mi>
          <mn>1</mn>
         </msub>
         <mo>,</mo>
         <msub>
          <mi>m</mi>
          <mn>2</mn>
         </msub>
         <mo stretchy="false">)</mo>
        </mrow>
        <mo>≠</mo>
        <mrow>
         <mo stretchy="false">(</mo>
         <mn>0</mn>
         <mo>,</mo>
         <mn>0</mn>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <none></none>
      </mmultiscripts>
      <mrow>
       <mi>b</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <msub>
         <mi>m</mi>
         <mn>1</mn>
        </msub>
        <mo>,</mo>
        <msub>
         <mi>m</mi>
         <mn>2</mn>
        </msub>
        <mo stretchy="false">)</mo>
       </mrow>
       <mi>y</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <msub>
          <mi>n</mi>
          <mn>1</mn>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>m</mi>
          <mn>1</mn>
         </msub>
        </mrow>
        <mo>,</mo>
        <mrow>
         <msub>
          <mi>n</mi>
          <mn>2</mn>
         </msub>
         <mo>-</mo>
         <msub>
          <mi>m</mi>
          <mn>2</mn>
         </msub>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>y</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <cn type="integer">1</cn>
         </apply>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>m</ci>
           <cn type="integer">2</cn>
          </apply>
          <cn type="integer">0</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>M</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>a</ci>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <cn type="integer">2</cn>
         </apply>
        </interval>
        <ci>x</ci>
        <interval closure="open">
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>m</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>n</ci>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>m</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <cn type="integer">1</cn>
         </apply>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <apply>
            <csymbol cd="ambiguous">subscript</csymbol>
            <ci>m</ci>
            <cn type="integer">2</cn>
           </apply>
           <cn type="integer">0</cn>
          </apply>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>L</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <neq></neq>
         <interval closure="open">
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>m</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>m</ci>
           <cn type="integer">2</cn>
          </apply>
         </interval>
         <interval closure="open">
          <cn type="integer">0</cn>
          <cn type="integer">0</cn>
         </interval>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>b</ci>
        <interval closure="open">
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <cn type="integer">1</cn>
         </apply>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <cn type="integer">2</cn>
         </apply>
        </interval>
        <ci>y</ci>
        <interval closure="open">
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>n</ci>
           <cn type="integer">1</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>m</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <apply>
          <minus></minus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>n</ci>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>m</ci>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </interval>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(n_{1},n_{2})=\sum_{m_{1}=0}^{M_{1}}\sum_{m_{2}=0}^{M_{2}}a(m_{1},m_{2})x(n_{%
1}-m_{1},n_{2}-m_{2})-{\sum_{m_{1}=0}^{L_{1}}\sum_{m_{2}=0}^{L_{2}}}_{(m_{1},m%
_{2})\neq(0,0)}b(m_{1},m_{2})y(n_{1}-m_{1},n_{2}-m_{2})
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="2D_Adaptive_Filters:20">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>n</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>n</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>y</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y(n_{1},n_{2})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="2D_Adaptive_Filters:21">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>n</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>n</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(n_{1},n_{2})
  </annotation>
 </semantics>
</math>

 are, respectively, the output and input of the adaptive filter. 

<math display="inline" id="2D_Adaptive_Filters:22">
 <semantics>
  <mrow>
   <mi>b</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>m</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>m</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>b</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   b(m_{1},m_{2})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="2D_Adaptive_Filters:23">
 <semantics>
  <mrow>
   <mi>a</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>m</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>m</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a(m_{1},m_{2})
  </annotation>
 </semantics>
</math>

 are the masks of the filter`s input and output. The error signal is given by</p>

<p>

<math display="inline" id="2D_Adaptive_Filters:24">
 <semantics>
  <mrow>
   <mrow>
    <mi>e</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>n</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>n</mi>
      <mn>2</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>n</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>n</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>-</mo>
    <mrow>
     <mi>y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>n</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>n</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>e</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>n</ci>
       <cn type="integer">2</cn>
      </apply>
     </interval>
    </apply>
    <apply>
     <minus></minus>
     <apply>
      <times></times>
      <ci>d</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </interval>
     </apply>
     <apply>
      <times></times>
      <ci>y</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   e(n_{1},n_{2})=d(n_{1},n_{2})-y(n_{1},n_{2})
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="2D_Adaptive_Filters:25">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>n</mi>
     <mn>1</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>n</mi>
     <mn>2</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(n_{1},n_{2})
  </annotation>
 </semantics>
</math>

is the primary output signal.</p>

<p>The mean square error 

<math display="inline" id="2D_Adaptive_Filters:26">
 <semantics>
  <mrow>
   <mi>E</mi>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <msup>
      <mi>e</mi>
      <mn>2</mn>
     </msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>n</mi>
       <mn>1</mn>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>n</mi>
       <mn>2</mn>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>E</ci>
    <set>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>e</ci>
       <cn type="integer">2</cn>
      </apply>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </interval>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E\{e^{2}(n_{1},n_{2})\}
  </annotation>
 </semantics>
</math>

 is minimized by updating the filter weights in a manner to converge to the optimum filter weight.</p>

<p><strong>Advantages</strong>: IIR filters can satisfy the prescribed frequency response because it can reduce the filter`s order requirements.</p>

<p><strong>Disadvantages</strong>: The performance surfaces of adaptive LMS IIR Adaptive filters are nonquadratic and may have local minima. Meanwhile, adaptive IIR filters may become unstable during the adaptation, thus some kind of stability monitoring is needed.</p>
<h3 id="recursive-least-square-adaptive-filters">Recursive Least Square Adaptive filters</h3>

<p><strong>2D Recursive Least Square Adaptive Filters</strong> <a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> can be developed by applying 1D <a href="Recursive_least_squares_filter" title="wikilink">Recursive Least Squares filters</a> along both horizontal and vertical directions. The RLS adaptive is an algorithm which finds the filter coefficients recursively to minimize the weighted least squares cost function. The RLS algorithm is different to the least mean suquares algorithm which aim to reduce the mean square error, its input signal is considered deterministic. For this reason, the RLS algorithm has fast convergence characteristic.</p>

<p><strong>Advantages</strong>:The RLS algorithm has fast convergence property. The accuracy of image denoising based on RLS algorithm is better than 2D LMS adaptive filters.</p>

<p><strong>Disadvantages</strong>:The RLS algorithm needs a large amount of computations, especially in Two-demensional and Multi-dimensional case.</p>
<h3 id="lexicographic-ordering">Lexicographic Ordering</h3>

<p>One convenient approach to implement 2D Adaptive Filters is to transform the 2D problem into a 1D problem by <a href="Lexicographical_order" title="wikilink">lexicographic ordering</a>.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> This simplifies the implementation and makes it possible to benefit from the extensive literature that is available for 1D adaptive filters and utilize all of the existing 1D algorithms.</p>
<h3 id="mcclellan-transformations">McClellan Transformations</h3>

<p><strong>McClellan transformations</strong> <a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> can be used to transform a 1D filter design into a 2D filter design by using a transformation function. This theory allows the design of 2D adaptive filters <a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> out of existing 1D prototype filters. Compared to the direct approach, this system has the advantages of a lower computational complexity and a faster convergence rate. However, in order to work properly, it needs some a priori information about the system to correctly select the transformation function parameters, making the system pre-constrained.</p>
<h3 id="block-diagonal-2d-adaptive-filters">Block Diagonal 2D Adaptive Filters</h3>

<p><strong>Block Diagonal 2D Adaptive Filters</strong> is an alternative approach <a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> that scans the signal through blocks and applies weight adjustments for each block, instead of for each sample as in the traditional adaptive filters. The advantage of this kind of system is that it takes into account signal correlations along both dimensions. On the other hand, it assumes a higher local stationarity of the signal.</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a href="Category:Digital_signal_processing" title="wikilink">Category:Digital signal processing</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Abadi, M. Shams Esfand, and S. Nikbakht. "Image denoising with two-dimensional adaptive filter algorithms." Iranian Journal of Electrical &amp; Electronic Engineering 7.2 (2011).<a href="#fnref1">↩</a></li>
<li id="fn2">Trimeche, Mejdi. "Hierarchical Motion Estimation Using Recursive LMS Filters." (2007).<a href="#fnref2">↩</a></li>
<li id="fn3">Hou, Xiaolin, et al. "On two-dimensional adaptive channel estimation in OFDM systems." Vehicular Technology Conference, 2004. VTC2004-Fall. 2004 IEEE 60th. Vol. 1. IEEE, 2004.<a href="#fnref3">↩</a></li>
<li id="fn4">Kumar, P. Sarath, and Sumit Roy. "Two-dimensional equalization: Theory and applications to high density magnetic recording." Communications, IEEE Transactions on 42.234 (1994): 386-395.<a href="#fnref4">↩</a></li>
<li id="fn5">Mohiy M.Hadhoud and David W.Thomas. "Two-Dimensional Adaptive LMS (TDLMS) Algorithm." IEEE Transactions on Circuits And Systems, Vol 35, No.5, May 1988.<a href="#fnref5">↩</a></li>
<li id="fn6">Alfredo C. Tan and Sheng-Tsal Chen, "Two-Dimensional Adaptive LMS IIR Filter." Circuits and Systems, 1993., ISCAS '93, 1993 IEEE International Symposium on Date 3–6 May 1993.<a href="#fnref6">↩</a></li>
<li id="fn7">Mitsuji Muneyasu, Eiji Uemoto and Takao Hinamoto. "A Novel 2-D Adaptive Filter Based On The 1-D RLS Algorithm." Circuits and Systems, 1997. ISCAS '97., Proceedings of 1997 IEEE International Symposium on Date 9-12 Jun 1997<a href="#fnref7">↩</a></li>
<li id="fn8"></li>
<li id="fn9">McClellan, James H. "The design of two-dimensional digital filters by transformations." Proc. 7th Annu. Princeton Conf. Information Sciences and Systems. 1973.<a href="#fnref9">↩</a></li>
<li id="fn10">Jenkins, W. K., and R. P. Faust. "A constrained two-dimensional adaptive digital filter with reduced computational complexity." Circuits and Systems, 1988., IEEE International Symposium on. IEEE, 1988.<a href="#fnref10">↩</a></li>
<li id="fn11">Azimi-Sadjadi, Mahmood R., and Hongye Pan. "Two-dimensional block diagonal LMS adaptive filtering." Signal Processing, IEEE Transactions on 42.9 (1994): 2420-2429.<a href="#fnref11">↩</a></li>
</ol>
</section>
</body>
</html>
