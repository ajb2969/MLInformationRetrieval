<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="509">Common knowledge (logic)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Common knowledge (logic)</h1>
<hr/>

<p><strong>Common knowledge</strong> is a special kind of <a class="uri" href="knowledge" title="wikilink">knowledge</a> for a group of <a href="wiktionary:agent" title="wikilink">agents</a>. There is <em>common knowledge</em> of <em>p</em> in a group of agents <em>G</em> when all the agents in <em>G</em> know <em>p</em>, they all know that they know <em>p</em>, they all know that they all know that they know <em>p</em>, and so on ad infinitum.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>The concept was first introduced in the philosophical literature by <a href="David_Kellogg_Lewis" title="wikilink">David Kellogg Lewis</a> in his study <em>Convention</em> (1969). It was first given a mathematical formulation in a <a href="set_theory" title="wikilink">set-theoretical</a> framework by <a href="Robert_Aumann" title="wikilink">Robert Aumann</a> (1976). <a href="computer_science" title="wikilink">Computer scientists</a> grew an interest in the subject of <a href="epistemic_logic" title="wikilink">epistemic logic</a> in general – and of common knowledge in particular – starting in the 1980s. There are numerous <a href="Logic_puzzle" title="wikilink">puzzles</a> based upon the concept which have been extensively investigated by mathematicians such as <a href="John_Horton_Conway" title="wikilink">John Conway</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>The philosopher <a href="Stephen_Schiffer" title="wikilink">Stephen Schiffer</a>, in his book <em>Meaning</em>, independently developed a notion he called "mutual knowledge" which functions quite similarly to Lewis's "common knowledge".<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a></p>
<h2 id="example">Example</h2>
<h3 id="question">Question</h3>

<p>The idea of common knowledge is often introduced by some variant of the following puzzle:</p>

<p>On an island, there are <em>k</em> people who have blue eyes, and the rest of the people have green eyes. At the start of the puzzle, no one on the island ever knows their own eye color. By rule, if a person on the island ever discovers they have blue eyes, that person must leave the island at dawn the next day. On the island, each person knows every other person's eye color, there are no reflective surfaces, and there is no discussion of eye color.</p>

<p>At some point, an outsider comes to the island, calls together all the people on the island, and makes the following public announcement: "At least one of you has blue eyes". The outsider, furthermore, is known by all to be truthful, and all know that all know this, and so on: it is common knowledge that he is truthful, and thus it becomes common knowledge that there is at least one islander who has blue eyes. The problem: assuming all persons on the island are completely logical and that this too is common knowledge, what is the eventual outcome?</p>
<h3 id="answer">Answer</h3>

<p>The answer is that, on the <em>k</em>th dawn after the announcement, all the blue-eyed people will leave the island.</p>

<p>The solution can be seen with an inductive argument. If <em>k</em> = 1 (that is, there is exactly one blue-eyed person), the person will recognize that they alone have blue eyes (by seeing only green eyes in the others) and leave at the first dawn. If <em>k</em> = 2, no one will leave at the first dawn. The two blue-eyed people, seeing only one person with blue eyes, <em>and</em> that no one left on the 1st dawn (and thus that <em>k</em> &gt; 1), will leave on the second dawn. Inductively, it can be reasoned that no one will leave at the first <em>k</em>-1 dawns if and only if there are at least <em>k</em> blue-eyed people. Those with blue eyes, seeing <em>k</em>-1 blue-eyed people among the others and knowing there must be at least <em>k</em>, will reason that they must have blue eyes and leave.</p>

<p>What's most interesting about this scenario is that, for <em>k</em> &gt; 1, the outsider is only telling the island citizens what they already know: that there are blue-eyed people among them. However, before this fact is announced, the fact is not <em>common knowledge</em>.</p>

<p>For <em>k</em> = 2, it is merely "first-order" knowledge. Each blue-eyed person knows that there is someone with blue eyes, but each blue eyed person does <em>not</em> know that the other blue-eyed person has this same knowledge.</p>

<p>For <em>k</em> = 3, it is "second order" knowledge. After 2 days, each blue-eyed person knows that a second blue-eyed person knows that a third person has blue eyes, but no one knows that there is a <em>third</em> blue-eyed person with that knowledge, until the third day arrives.</p>

<p>In general: For <em>k</em> &gt; 1, it is "(<em>k</em> − 1)th order" knowledge. After <em>k</em> − 1 days, each blue-eyed person knows that a second blue-eyed person knows that a third blue-eyed person knows that.... (repeat for a total of <em>k</em> − 1 levels) a <em>k</em>th person has blue eyes, but no one knows that there is a "<em>k</em>th" blue-eyed person with that knowledge, until the <em>k</em>th day arrives. The notion of <em>common knowledge</em> therefore has a palpable effect. Knowing that everyone knows does make a difference. When the outsider's public announcement (a fact already known to all) becomes common knowledge, the blue-eyed people on this island eventually deduce their status, and leave.</p>
<h2 id="formalization">Formalization</h2>
<h3 id="modal-logic-syntactic-characterization">Modal logic (syntactic characterization)</h3>

<p>Common knowledge can be given a logical definition in <a href="Modal_logic" title="wikilink">multi-modal logic</a> systems in which the modal operators are interpreted <a href="epistemic_logic" title="wikilink">epistemically</a>. At the propositional level, such systems are extensions of <a href="propositional_logic" title="wikilink">propositional logic</a>. The extension consists of the introduction of a group <em>G</em> of <em>agents</em>, and of <em>n</em> modal operators <em>K<sub>i</sub></em> (with <em>i</em> = 1, ..., <em>n</em>) with the intended meaning that "agent <em>i</em> knows." Thus <em>K<sub>i</sub> 

<math display="inline" id="Common_knowledge_(logic):0">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

</em> (where 

<math display="inline" id="Common_knowledge_(logic):1">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 is a formula of the calculus) is read "agent <em>i</em> knows 

<math display="inline" id="Common_knowledge_(logic):2">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

." We can define an operator <em>E<sub>G</sub></em> with the intended meaning of "everyone in group <em>G</em> knows" by defining it with the axiom</p>

<p>

<math display="block" id="Common_knowledge_(logic):3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>E</mi>
      <mi>G</mi>
     </msub>
     <mi>φ</mi>
    </mrow>
    <mo>⇔</mo>
    <mrow>
     <munder>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
      <mrow>
       <mi>i</mi>
       <mo>∈</mo>
       <mi>G</mi>
      </mrow>
     </munder>
     <mrow>
      <msub>
       <mi>K</mi>
       <mi>i</mi>
      </msub>
      <mi>φ</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>G</ci>
     </apply>
     <ci>φ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <and></and>
      <apply>
       <in></in>
       <ci>i</ci>
       <ci>G</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>i</ci>
      </apply>
      <ci>φ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{G}\varphi\Leftrightarrow\bigwedge_{i\in G}K_{i}\varphi,
  </annotation>
 </semantics>
</math>

</p>

<p>By abbreviating the expression 

<math display="inline" id="Common_knowledge_(logic):4">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mi>G</mi>
   </msub>
   <msubsup>
    <mi>E</mi>
    <mi>G</mi>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
   </msubsup>
   <mi>φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>G</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>G</ci>
     </apply>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <ci>φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{G}E_{G}^{n-1}\varphi
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Common_knowledge_(logic):5">
 <semantics>
  <mrow>
   <msubsup>
    <mi>E</mi>
    <mi>G</mi>
    <mi>n</mi>
   </msubsup>
   <mi>φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>E</ci>
      <ci>G</ci>
     </apply>
     <ci>n</ci>
    </apply>
    <ci>φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{G}^{n}\varphi
  </annotation>
 </semantics>
</math>

 and defining 

<math display="inline" id="Common_knowledge_(logic):6">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mi>E</mi>
     <mi>G</mi>
     <mn>0</mn>
    </msubsup>
    <mi>φ</mi>
   </mrow>
   <mo>=</mo>
   <mi>φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>G</ci>
      </apply>
      <cn type="integer">0</cn>
     </apply>
     <ci>φ</ci>
    </apply>
    <ci>φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{G}^{0}\varphi=\varphi
  </annotation>
 </semantics>
</math>

, we could then define common knowledge with the axiom</p>

<p>

<math display="block" id="Common_knowledge_(logic):7">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mi>φ</mi>
   </mrow>
   <mo>⇔</mo>
   <mrow>
    <munderover>
     <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋀</mo>
     <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>0</mn>
     </mrow>
     <mi mathvariant="normal">∞</mi>
    </munderover>
    <mrow>
     <msup>
      <mi>E</mi>
      <mi>i</mi>
     </msup>
     <mi>φ</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-⇔</ci>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>φ</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <and></and>
       <apply>
        <eq></eq>
        <ci>i</ci>
        <cn type="integer">0</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>E</ci>
       <ci>i</ci>
      </apply>
      <ci>φ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C\varphi\Leftrightarrow\bigwedge_{i=0}^{\infty}E^{i}\varphi
  </annotation>
 </semantics>
</math>

</p>

<p>There is however a complication. The languages of epistemic logic are usually <em>finitary</em>, whereas the <a class="uri" href="axiom" title="wikilink">axiom</a> above defines common knowledge as an infinite conjunction of formulas, hence not a <a href="well-formed_formula" title="wikilink">well-formed formula</a> of the language. To overcome this difficulty, a <em>fixed-point</em> definition of common knowledge can be given. Intuitively, common knowledge is thought of as the fixed point of the "equation" 

<math display="inline" id="Common_knowledge_(logic):8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>C</mi>
     <mi>G</mi>
    </msub>
    <mi>φ</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>ψ</mi>
    <mo>∧</mo>
    <mrow>
     <msub>
      <mi>E</mi>
      <mi>G</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <msub>
        <mi>C</mi>
        <mi>G</mi>
       </msub>
       <mi>φ</mi>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>G</ci>
     </apply>
     <ci>φ</ci>
    </apply>
    <apply>
     <and></and>
     <ci>ψ</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>G</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>C</ci>
        <ci>G</ci>
       </apply>
       <ci>φ</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{G}\varphi=\psi\wedge E_{G}(C_{G}\varphi)
  </annotation>
 </semantics>
</math>


. In this way, it is possible to find a formula 

<math display="inline" id="Common_knowledge_(logic):9">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

 implying 

<math display="inline" id="Common_knowledge_(logic):10">
 <semantics>
  <mrow>
   <msub>
    <mi>E</mi>
    <mi>G</mi>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mi>φ</mi>
     <mo>∧</mo>
     <mrow>
      <msub>
       <mi>C</mi>
       <mi>G</mi>
      </msub>
      <mi>φ</mi>
     </mrow>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>E</ci>
     <ci>G</ci>
    </apply>
    <apply>
     <and></and>
     <ci>φ</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>G</ci>
      </apply>
      <ci>φ</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{G}(\varphi\wedge C_{G}\varphi)
  </annotation>
 </semantics>
</math>

 from which, in the limit, we can infer common knowledge of 

<math display="inline" id="Common_knowledge_(logic):11">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

.</p>

<p>This <em>syntactic</em> characterization is given semantic content through so-called <em>Kripke structures</em>. A Kripke structure is given by (i) a set of states (or possible worlds) <em>S</em>, (ii) <em>n</em> <em>accessibility relations</em> 

<math display="inline" id="Common_knowledge_(logic):12">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>R</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{1},\dots,R_{n}
  </annotation>
 </semantics>
</math>

, defined on 

<math display="inline" id="Common_knowledge_(logic):13">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mo>×</mo>
   <mi>S</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <ci>S</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S\times S
  </annotation>
 </semantics>
</math>


, intuitively representing what states agent <em>i</em> considers possible from any given state, and (iii) a valuation function 

<math display="inline" id="Common_knowledge_(logic):14">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

 assigning a <a href="truth_value" title="wikilink">truth value</a>, in each state, to each primitive proposition in the language. The semantics for the knowledge operator is given by stipulating that 

<math display="inline" id="Common_knowledge_(logic):15">
 <semantics>
  <mrow>
   <msub>
    <mi>K</mi>
    <mi>i</mi>
   </msub>
   <mi>φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <ci>i</ci>
    </apply>
    <ci>φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{i}\varphi
  </annotation>
 </semantics>
</math>

 is true at state <em>s</em> iff 

<math display="inline" id="Common_knowledge_(logic):16">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 is true at <em>all</em> states <em>t</em> such that 

<math display="inline" id="Common_knowledge_(logic):17">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msub>
    <mi>R</mi>
    <mi>i</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>s</ci>
     <ci>t</ci>
    </interval>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s,t)\in R_{i}
  </annotation>
 </semantics>
</math>

. The semantics for the common knowledge operator, then, is given by taking, for each group of agents <em>G</em>, the reflexive and transitive closure of the 

<math display="inline" id="Common_knowledge_(logic):18">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{i}
  </annotation>
 </semantics>
</math>


, for all agents <em>i</em> in <em>G</em>, call such a relation 

<math display="inline" id="Common_knowledge_(logic):19">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>G</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{G}
  </annotation>
 </semantics>
</math>

, and stipulating that 

<math display="inline" id="Common_knowledge_(logic):20">
 <semantics>
  <mrow>
   <msub>
    <mi>C</mi>
    <mi>G</mi>
   </msub>
   <mi>φ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>C</ci>
     <ci>G</ci>
    </apply>
    <ci>φ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C_{G}\varphi
  </annotation>
 </semantics>
</math>

 is true at state <em>s</em> iff 

<math display="inline" id="Common_knowledge_(logic):21">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 is true at <em>all</em> states <em>t</em> such that 

<math display="inline" id="Common_knowledge_(logic):22">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>∈</mo>
   <msub>
    <mi>R</mi>
    <mi>G</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <interval closure="open">
     <ci>s</ci>
     <ci>t</ci>
    </interval>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>G</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (s,t)\in R_{G}
  </annotation>
 </semantics>
</math>

.</p>
<h3 id="set-theoretic-semantic-characterization">Set theoretic (semantic characterization)</h3>

<p>Alternatively (yet equivalently) common knowledge can be formalized using <a href="set_theory" title="wikilink">set theory</a> (this was the path taken by the Nobel laureate <a href="Robert_Aumann" title="wikilink">Robert Aumann</a> in his seminal 1976 paper). We will start with a set of states <em>S</em>. We can then define an event <em>E</em> as a subset of the set of states <em>S</em>. For each agent <em>i</em>, define a <a href="Partition_of_a_set" title="wikilink">partition</a> on <em>S</em>, <em>P<sub>i</sub></em>. This partition represents the state of knowledge of an agent in a state. In state <em>s</em>, agent <em>i</em> knows that one of the states in <em>P</em><sub><em>i</em></sub>(<em>s</em>) obtains, but not which one. (Here <em>P</em><sub><em>i</em></sub>(<em>s</em>) denotes the unique element of <em>P<sub>i</sub></em> containing <em>s</em>. Note that this model excludes cases in which agents know things that are not true.)</p>

<p>We can now define a knowledge function <em>K</em> in the following way:</p>

<p>

<math display="block" id="Common_knowledge_(logic):23">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>K</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>e</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mrow>
     <mi>s</mi>
     <mo>∈</mo>
     <mi>S</mi>
    </mrow>
    <mo stretchy="false">|</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>P</mi>
       <mi>i</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>s</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>⊂</mo>
     <mi>e</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <ci>i</ci>
     </apply>
     <ci>e</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <apply>
      <in></in>
      <ci>s</ci>
      <ci>S</ci>
     </apply>
     <apply>
      <subset></subset>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <ci>i</ci>
       </apply>
       <ci>s</ci>
      </apply>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{i}(e)=\{s\in S|P_{i}(s)\subset e\}
  </annotation>
 </semantics>
</math>

</p>

<p>That is, <em>K</em><sub><em>i</em></sub>(<em>e</em>) is the set of states where the agent will know that event <em>e</em> obtains. It is a subset of <em>e</em>.</p>

<p>Similar to the modal logic formulation above, we can define an operator for the idea that "everyone knows <em>e</em>".</p>

<p>

<math display="block" id="Common_knowledge_(logic):24">
 <semantics>
  <mrow>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>e</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <munder>
     <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋂</mo>
     <mi>i</mi>
    </munder>
    <mrow>
     <msub>
      <mi>K</mi>
      <mi>i</mi>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>e</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>e</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <intersect></intersect>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>i</ci>
      </apply>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E(e)=\bigcap_{i}K_{i}(e)
  </annotation>
 </semantics>
</math>

</p>

<p>As with the modal operator, we will iterate the <em>E</em> function, 

<math display="inline" id="Common_knowledge_(logic):25">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>E</mi>
     <mn>1</mn>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>e</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>e</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>E</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>e</ci>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <ci>e</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E^{1}(e)=E(e)
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Common_knowledge_(logic):26">
 <semantics>
  <mrow>
   <mrow>
    <msup>
     <mi>E</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>e</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>E</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msup>
       <mi>E</mi>
       <mi>n</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>e</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>E</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <ci>e</ci>
    </apply>
    <apply>
     <times></times>
     <ci>E</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>E</ci>
       <ci>n</ci>
      </apply>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E^{n+1}(e)=E(E^{n}(e))
  </annotation>
 </semantics>
</math>

. Using this we can then define a common knowledge function,</p>

<p>

<math display="block" id="Common_knowledge_(logic):27">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>C</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>e</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" mathsize="160%" movablelimits="false" stretchy="false" symmetric="true">⋂</mo>
      <mrow>
       <mi>n</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi mathvariant="normal">∞</mi>
     </munderover>
     <mrow>
      <msup>
       <mi>E</mi>
       <mi>n</mi>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>e</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>e</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <intersect></intersect>
       <apply>
        <eq></eq>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <infinity></infinity>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>E</ci>
       <ci>n</ci>
      </apply>
      <ci>e</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C(e)=\bigcap_{n=1}^{\infty}E^{n}(e).
  </annotation>
 </semantics>
</math>

</p>

<p>The equivalence with the syntactic approach sketched above can easily be seen: consider an Aumann structure as the one just defined. We can define a correspondent Kripke structure by taking (i) the same space <em>S</em>, (ii) accessibility relations 

<math display="inline" id="Common_knowledge_(logic):28">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{i}
  </annotation>
 </semantics>
</math>


 that define the equivalence classes corresponding to the partitions 

<math display="inline" id="Common_knowledge_(logic):29">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}
  </annotation>
 </semantics>
</math>

, and (iii) a valuation function such that it yields value <em>true</em> to the primitive proposition <em>p</em> in all and only the states <em>s</em> such that 

<math display="inline" id="Common_knowledge_(logic):30">
 <semantics>
  <mrow>
   <mi>s</mi>
   <mo>∈</mo>
   <msup>
    <mi>E</mi>
    <mi>p</mi>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>s</ci>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>E</ci>
     <ci>p</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   s\in E^{p}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Common_knowledge_(logic):31">
 <semantics>
  <msup>
   <mi>E</mi>
   <mi>p</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>E</ci>
    <ci>p</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E^{p}
  </annotation>
 </semantics>
</math>

 is the event of the Aumann structure corresponding to the primitive proposition <em>p</em>. It is not difficult to see that the common knowledge accessibility function 

<math display="inline" id="Common_knowledge_(logic):32">
 <semantics>
  <msub>
   <mi>R</mi>
   <mi>G</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{G}
  </annotation>
 </semantics>
</math>

 defined in the previous section corresponds to the finest common coarsening of the partitions 

<math display="inline" id="Common_knowledge_(logic):33">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}
  </annotation>
 </semantics>
</math>


 for all 

<math display="inline" id="Common_knowledge_(logic):34">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>∈</mo>
   <mi>G</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>i</ci>
    <ci>G</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i\in G
  </annotation>
 </semantics>
</math>

, which is the finitary characterization of common knowledge also given by Aumann in the 1976 article.</p>
<h2 id="applications">Applications</h2>

<p>Common knowledge was used by David Lewis in his pioneering game-theoretical account of convention. In this sense, common knowledge is a concept still central for linguists and philosophers of language (see Clark 1996) maintaining a Lewisian, conventionalist account of language.</p>

<p><a href="Robert_Aumann" title="wikilink">Robert Aumann</a> introduced a set theoretical formulation of common knowledge (theoretically equivalent to the one given above) and proved the so-called <a href="Aumann's_agreement_theorem" title="wikilink">agreement theorem</a> through which: if two agents have common <a href="prior_probability" title="wikilink">prior probability</a> over a certain event, and the <a href="posterior_probabilities" title="wikilink">posterior probabilities</a> are common knowledge, then such posterior probabilities are equal. A result based on the agreement theorem and proven by Milgrom shows that, given certain conditions on market efficiency and information, speculative trade is impossible.</p>

<p>The concept of common knowledge is central in <a href="game_theory" title="wikilink">game theory</a>. For several years it has been thought that the assumption of common knowledge of rationality for the players in the game was fundamental. It turns out (Aumann and Brandenburger 1995) that, in 2-player games, common knowledge of rationality is not needed as an epistemic condition for <a href="Nash_equilibrium" title="wikilink">Nash equilibrium</a> <a href="strategy_(game_theory)" title="wikilink">strategies</a>.</p>

<p>Computer scientists use languages incorporating epistemic logics (and common knowledge) to reason about distributed systems. Such systems can be based on logics more complicated than simple propositional epistemic logic, see Wooldridge <em>Reasoning about Artificial Agents</em>, 2000 (in which he uses a first-order logic incorporating epistemic and temporal operators) or van der Hoek et al. "Alternating Time Epistemic Logic".</p>

<p>In his 2007 book, <em><a href="The_Stuff_of_Thought" title="wikilink">The Stuff of Thought: Language as a Window into Human Nature</a>,</em> <a href="Steven_Pinker" title="wikilink">Steven Pinker</a> uses the notion of common knowledge to analyze the kind of indirect speech involved in innuendoes.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Global_game" title="wikilink">Global game</a></li>
<li><a href="Two_Generals'_Problem" title="wikilink">Two Generals' Problem</a> for the impossibility of establishing common knowledge over an unreliable channel</li>
<li><a href="Mutual_knowledge_(logic)" title="wikilink">Mutual knowledge (logic)</a></li>
<li><a href="Stephen_Schiffer" title="wikilink">Stephen Schiffer</a></li>
</ul>
<h2 id="notes">Notes</h2>
<ol>
<li>

<p>See the textbooks <em>Reasoning about knowledge</em> by Fagin, Halpern, Moses and Vardi (1995), and <em>Epistemic Logic for computer science</em> by Meyer and van der Hoek (1995).</p></li>
<li>

<p>A structurally identical problem is provided by <a href="Herbert_Gintis" title="wikilink">Herbert Gintis</a> (2000); he calls it "The Women of Sevitan".</p></li>
</ol>
<h2 id="references">References</h2>
<ul>
<li><a href="Robert_Aumann" title="wikilink">Aumann, Robert</a> (1976) "Agreeing to Disagree" <em>Annals of Statistics</em> 4(6): 1236–1239.</li>
<li>Aumann Robert and Adam Brandenburger (1995) "Epistemic Conditions for Nash Equilibrium" <a class="uri" href="Econometrica" title="wikilink">Econometrica</a> 63(5): 1161–1180.</li>
<li>Clark, Herbert (1996) <em>Using Language</em>, Cambridge University Press ISBN 0-521-56745-9</li>
<li>

<p>.</p></li>
<li><a href="David_Kellogg_Lewis" title="wikilink">Lewis, David</a> (1969) <em>Convention: A Philosophical Study</em> Oxford: Blackburn. ISBN 0-631-23257-5</li>
<li>J-J Ch. Meyer and W van der Hoek <em>Epistemic Logic for Computer Science and Artificial Intelligence</em>, volume 41, Cambridge Tracts in Theoretical Computer Science, Cambridge University Press, 1995. ISBN 0-521-46014-X</li>
<li>

<p>. See Chapter 3.</p></li>
<li>

<p>. See Section 13.4; <a href="http://www.masfoundations.org/download.html">downloadable free online</a>.</p></li>
<li>Gintis, Herbert (2000) <em>Game Theory Evolving</em> Princeton University Press. ISBN 0-691-14051-0</li>
<li>Gintis, Herbert (2009) <em>The Bounds of Reason</em> Princeton University Press. ISBN 0-691-14052-9</li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
<li><a href="http://terrytao.wordpress.com/2008/02/05/the-blue-eyed-islanders-puzzle/">Prof. Terence Tao's blog post (Feb 2008)</a></li>
<li>Carr, Kareem. <a href="http://twofoldgaze.wordpress.com/2009/11/07/in-the-long-run-we-are-all-dead/">"In the Long Run We Are All Dead"</a>, <a href="http://twofoldgaze.wordpress.com/2009/11/12/in-the-long-run-we-are-all-dead-ii/">"In the Long Run We Are All Dead II"</a> at The Twofold Gaze. Detailed description of the blue-eyed islander problem, with solution.</li>
<li>physics.harvard.edu <a href="https://www.physics.harvard.edu/uploads/files/undergrad/probweek/prob2.pdf">"Green-eyed Dragons Problem"</a>, <a href="https://www.physics.harvard.edu/uploads/files/undergrad/probweek/sol2.pdf">"Green-eyed Dragons Solution"</a> (Sept 2002)</li>
</ul>

<p>"</p>

<p><a href="Category:Game_theory" title="wikilink">Category:Game theory</a> <a href="Category:Concepts_in_logic" title="wikilink">Category:Concepts in logic</a> <a href="Category:Fixed_points_(mathematics)" title="wikilink">Category:Fixed points (mathematics)</a> <a class="uri" href="Category:Knowledge" title="wikilink">Category:Knowledge</a> <a href="Category:Social_epistemology" title="wikilink">Category:Social epistemology</a> <a href="Category:Formal_epistemology" title="wikilink">Category:Formal epistemology</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Osborne, Martin J., and <a href="Ariel_Rubinstein" title="wikilink">Ariel Rubinstein</a>. <em>A Course in Game Theory</em>. Cambridge, MA: MIT, 1994. Print.<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">Stephen Schiffer, <em>Meaning</em>, 2nd edition, Oxford University Press, 1988. The first edition was published by OUP in 1972. For a discussion of both Lewis's and Schiffer's notions, see Russell Dale, <em><a href="http://www.russelldale.com/dissertation/1996.RussellDale.TheTheoryOfMeaning.pdf">The Theory of Meaning</a></em> (1996).<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
