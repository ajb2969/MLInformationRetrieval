<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="616">Sandia method</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Sandia method</h1>
<hr/>

<p>The <strong>Sandia method</strong> (also known as Veers method) is a method for generating a turbulent wind profile that can be used in aero-elastic software to evaluate the fatigue imparted on a turbine in a turbulent environment. That is, it generates time series of wind speeds at a set of points on a surface, say the plane of the rotor of a wind turbine. Analysis is performed initially in the frequency domain, where turbulence can be described quantitatively with more ease than the time domain. Then, the time series are obtained by inverse fast Fourier transforms.</p>

<p>In its original form, the Sandia method only simulates the u-component of the wind; that is, the wind was modelled as propagating in a direction perpendicular to the plane of the rotor. Work carried out by NREL, specifically Kelley, suggested that a considerable amount of turbulent energy existed in the v-component (the v-component is parallel to both the plane of the rotor and the Earth). As such, the Sandia method was upgraded such that it included the v-component and w-component. Further upgrades have been performed such that the wind profile exhibits cross-axis correlation (turbulent fluctuations in one component being somehow connected to turbulent fluctuations in another). However, these are not considered in this article.</p>
<h2 id="point-wind-speed-spectra">Point-wind speed spectra</h2>

<p>Although turbulence leads to unpredictable results in the time domain, it can, to some extent, be characterized in the frequency domain. Turbulent fluctuations are dominated by low frequency components, with higher frequency components having less influence. For further information, see <a href="Turbulence#Kolmogorov's_theory_of_1941" title="wikilink">Kolmogorov's theory on turbulence</a>.</p>

<p>Several models of frequency domain representations of point wind speeds have been developed: the <a href="von_Kármán_wind_turbulence_model" title="wikilink">von Kármán wind turbulence model</a> and <a href="Dryden_Wind_Turbulence_Model" title="wikilink">Dryden Wind Turbulence Model</a> are examples of such.</p>
<h3 id="discretizing-a-spectrum">Discretizing a spectrum</h3>

<p>A spectrum in its original form is a continuous function. However, computer programmes operate on discrete functions. Thus a modification to whatever type of spectrum, be it Kaimal, von Karman, or some other spectrum, is needed. This is given below:</p>

<p>

<math display="block" id="Sandia_method:0">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ω</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ω</mi>
    <mo>=</mo>
    <msub>
     <mi>ω</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>ω</mi>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>k</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <csymbol cd="unknown">S</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ω</csymbol>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>k</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
    <csymbol cd="unknown">Δ</csymbol>
    <csymbol cd="unknown">ω</csymbol>
    <divide></divide>
    <cn type="integer">2</cn>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\omega_{k})=S(\omega=\omega_{k})\Delta\omega/2
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Sandia_method:1">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ω</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\omega_{k})
  </annotation>
 </semantics>
</math>

 is the discretized spectrum evaluated only at the discrete frequencies 

<math display="inline" id="Sandia_method:2">
 <semantics>
  <msub>
   <mi>ω</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ω</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{k}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Sandia_method:3">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ω</mi>
    <mo>=</mo>
    <msub>
     <mi>ω</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">S</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">ω</csymbol>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>k</ci>
     </apply>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\omega=\omega_{k})
  </annotation>
 </semantics>
</math>

 is the continuous spectrum evaluated at 

<math display="inline" id="Sandia_method:4">
 <semantics>
  <mrow>
   <mi>ω</mi>
   <mo>=</mo>
   <msub>
    <mi>ω</mi>
    <mi>k</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ω</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega=\omega_{k}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sandia_method:5">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <mi>ω</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta\omega
  </annotation>
 </semantics>
</math>

 is the size of the step between consecutive frequencies being considered.</p>
<h2 id="coherence">Coherence</h2>

<p>When generating a time series of wind speeds for a set of points across a surface, coherence needs to be taken into account. That is, the instantaneous wind speed at some point, A, will bare some resemblance to the wind speed at some other point, B. Clearly, the resemblance is influenced by the separation of points A and B. That is, two points separated by a large distance will show less similarity to each other than two neighbouring points on the surface. In addition, one would expect low frequency components of the wind speeds at points A and B to show more correlation than high frequency components. As such, many coherence functions have been proposed: Davenport, Solari, etc. The Solari coherence spectrum is provided as an example:</p>

<p>

<math display="block" id="Sandia_method:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mi>o</mi>
    <msub>
     <mi>h</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
      <mi>k</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>exp</mi>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <mn>2</mn>
       <mi>C</mi>
       <mi mathvariant="normal">Δ</mi>
       <msub>
        <mi>r</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
       </msub>
       <msub>
        <mi>ω</mi>
        <mi>k</mi>
       </msub>
      </mrow>
      <mo>/</mo>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>u</mi>
         <mi>i</mi>
        </msub>
        <mo>+</mo>
        <msub>
         <mi>u</mi>
         <mi>j</mi>
        </msub>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>o</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <exp></exp>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <ci>C</ci>
        <ci>normal-Δ</ci>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>ω</ci>
         <ci>k</ci>
        </apply>
       </apply>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>i</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>u</ci>
         <ci>j</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Coh_{ijk}=\exp^{-2C\Delta r_{ij}\omega_{k}/(u_{i}+u_{j})}
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Sandia_method:7">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 is a constant, 

<math display="inline" id="Sandia_method:8">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Δ</mi>
   <msub>
    <mi>r</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Δ</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>r</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Delta r_{ij}
  </annotation>
 </semantics>
</math>

 is the separation of points 

<math display="inline" id="Sandia_method:9">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sandia_method:10">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 on the surface, 

<math display="inline" id="Sandia_method:11">
 <semantics>
  <msub>
   <mi>ω</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ω</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{k}
  </annotation>
 </semantics>
</math>

 is the frequency, and 

<math display="inline" id="Sandia_method:12">
 <semantics>
  <msub>
   <mi>u</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>u</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sandia_method:13">
 <semantics>
  <msub>
   <mi>u</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>u</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   u_{j}
  </annotation>
 </semantics>
</math>

 are the mean wind speeds at points 

<math display="inline" id="Sandia_method:14">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sandia_method:15">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 respectively. The indices 

<math display="inline" id="Sandia_method:16">
 <semantics>
  <mi>i</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>i</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Sandia_method:17">
 <semantics>
  <mi>j</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>j</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   j
  </annotation>
 </semantics>
</math>

 run from 1 to n, and the index 

<math display="inline" id="Sandia_method:18">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 covers the frequency range. From the coherence function stems the coherence matrix. To cover all relationships between all points, the coherence function must be an 

<math display="inline" id="Sandia_method:19">
 <semantics>
  <msup>
   <mi>n</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{2}
  </annotation>
 </semantics>
</math>

-by-

<math display="inline" id="Sandia_method:20">
 <semantics>
  <msup>
   <mi>n</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{2}
  </annotation>
 </semantics>
</math>

-by-

<math display="inline" id="Sandia_method:21">
 <semantics>
  <mi>ω</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ω</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega
  </annotation>
 </semantics>
</math>

 matrix. Clearly, the coherence matrix is symmetric about the main diagonal if we are restricting ourselves to looking at the coherence function at a single frequency. This is because the spatial separation between points A and B is the same as the spatial separation between B and A. That is, for a n-by-n grid, only 

<math display="inline" id="Sandia_method:22">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>n</mi>
      <mn>4</mn>
     </msup>
     <mo>+</mo>
     <msup>
      <mi>n</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">4</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n^{4}+n^{2})/2
  </annotation>
 </semantics>
</math>

 elements need to be calculated for each frequency.</p>

<p>It is worth noting at this point that whilst the coherence matrix is strictly a 3-dimensional matrix (i, j, and k), computer programmes which implement the Sandia method typically reduce the coherence matrix to a 2-dimensional matrix where the frequency dimension has been 'removed'. This is to ease computational requirements. A 2-dimensional matrix is also required to perform some of the actions on the spectral matrix, such as a Cholesky decomposition, which is mentioned later. Of course, variation in frequency is still applied. However, the following process is carried out in full for one given frequency before proceeding to the next frequency. As such, in the following section, a power spectrum refers to the value of the power spectrum at a given frequency and not the full set of values across the frequency range being used. That is,</p>

<p>

<math display="block" id="Sandia_method:23">
 <semantics>
  <mrow>
   <mrow>
    <mi>C</mi>
    <mi>o</mi>
    <msub>
     <mi>h</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
      <mi>k</mi>
     </mrow>
    </msub>
   </mrow>
   <mo>→</mo>
   <mrow>
    <mi>C</mi>
    <mi>o</mi>
    <msub>
     <mi>h</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ω</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>o</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
       <ci>k</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>o</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Coh_{ijk}\rightarrow Coh_{ij}(\omega_{k})
  </annotation>
 </semantics>
</math>

</p>

<p>and</p>

<p>

<math display="inline" id="Sandia_method:24">
 <semantics>
  <mrow>
   <msub>
    <mi>S</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
     <mi>k</mi>
    </mrow>
   </msub>
   <mo>→</mo>
   <mrow>
    <msub>
     <mi>S</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ω</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>S</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{ijk}\rightarrow S_{ij}(\omega_{k})
  </annotation>
 </semantics>
</math>

</p>

<p>where an element of S, 

<math display="inline" id="Sandia_method:25">
 <semantics>
  <msub>
   <mi>S</mi>
   <mrow>
    <mi>i</mi>
    <mi>j</mi>
    <mi>k</mi>
   </mrow>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>S</ci>
    <apply>
     <times></times>
     <ci>i</ci>
     <ci>j</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{ijk}
  </annotation>
 </semantics>
</math>

 , would have given the strength of the spectrum at a particular frequency 

<math display="inline" id="Sandia_method:26">
 <semantics>
  <msub>
   <mi>ω</mi>
   <mi>k</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>ω</ci>
    <ci>k</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega_{k}
  </annotation>
 </semantics>
</math>

 at a particular point in space.</p>
<h2 id="generating-turbulence">Generating turbulence</h2>

<p>Power spectra are needed for each of the 

<math display="inline" id="Sandia_method:27">
 <semantics>
  <msup>
   <mi>n</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{2}
  </annotation>
 </semantics>
</math>

 points on the surface; this encapsulates information about the turbulence intensity for each point. It should be noted that under IEC standards, only one power spectrum is used; that is, all 

<math display="inline" id="Sandia_method:28">
 <semantics>
  <msup>
   <mi>n</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{2}
  </annotation>
 </semantics>
</math>

 points have the same turbulence intensity.</p>

<p>With the power spectra, the spectral matrix can be formed. This a 

<math display="inline" id="Sandia_method:29">
 <semantics>
  <msup>
   <mi>n</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{2}
  </annotation>
 </semantics>
</math>

-by-

<math display="inline" id="Sandia_method:30">
 <semantics>
  <msup>
   <mi>n</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{2}
  </annotation>
 </semantics>
</math>

 matrix. The main diagonal of the spectral matrix contains the previously defined spectra for all 

<math display="inline" id="Sandia_method:31">
 <semantics>
  <msup>
   <mi>n</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{2}
  </annotation>
 </semantics>
</math>

 points on the surface. The off-main diagonal elements contain all the cross spectra between the points. The cross spectra are determined by the following function:</p>

<p>

<math display="block" id="Sandia_method:32">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>S</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ω</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>C</mi>
    <mi>o</mi>
    <msub>
     <mi>h</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ω</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <msqrt>
     <mrow>
      <msub>
       <mi>S</mi>
       <mrow>
        <mi>i</mi>
        <mi>i</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>ω</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
      <msub>
       <mi>S</mi>
       <mrow>
        <mi>j</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>ω</mi>
        <mi>k</mi>
       </msub>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </msqrt>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>S</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>C</ci>
     <ci>o</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>k</ci>
     </apply>
     <apply>
      <root></root>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>i</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <ci>k</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>S</ci>
        <apply>
         <times></times>
         <ci>j</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>ω</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S_{ij}(\omega_{k})=Coh_{ij}(\omega_{k})\sqrt{S_{ii}(\omega_{k})S_{jj}(\omega_{%
k})}
  </annotation>
 </semantics>
</math>

</p>

<p>Due to the symmetry of the coherence matrix, only 

<math display="inline" id="Sandia_method:33">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <msup>
      <mi>n</mi>
      <mn>4</mn>
     </msup>
     <mo>+</mo>
     <msup>
      <mi>n</mi>
      <mn>2</mn>
     </msup>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>/</mo>
   <mn>2</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">4</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (n^{4}+n^{2})/2
  </annotation>
 </semantics>
</math>

 elements are independent. This property can be exploited to lighten memory requirements when writing a programme to simulate the Sandia method.</p>

<p>The spectral matrix, 

<math display="inline" id="Sandia_method:34">
 <semantics>
  <mrow>
   <mi>S</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ω</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>S</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\omega_{k})
  </annotation>
 </semantics>
</math>

, can be written as the matrix product of a matrix, 

<math display="inline" id="Sandia_method:35">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ω</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(\omega_{k})
  </annotation>
 </semantics>
</math>

, and its transpose. That is,</p>

<p>

<math display="block" id="Sandia_method:36">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ω</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ω</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>H</mi>
    <msup>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>ω</mi>
       <mi>k</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
     <mi>T</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>S</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>H</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>k</ci>
     </apply>
     <ci>H</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>ω</ci>
       <ci>k</ci>
      </apply>
      <ci>T</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\omega_{k})=H(\omega_{k})H(\omega_{k})^{T}
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Sandia_method:37">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ω</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(\omega_{k})
  </annotation>
 </semantics>
</math>

 is ultimately needed to obtain the complex Fourier co-efficients of the Fourier transforms of the time series of the wind speeds at all the points on the surface. Note - if the Fourier transform of a time domain function, 

<math display="inline" id="Sandia_method:38">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>t</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>x</ci>
    <ci>t</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x(t)
  </annotation>
 </semantics>
</math>

, is 

<math display="inline" id="Sandia_method:39">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>ω</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <ci>ω</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(\omega)
  </annotation>
 </semantics>
</math>

, then the resultant spectrum is 

<math display="inline" id="Sandia_method:40">
 <semantics>
  <mrow>
   <mrow>
    <mi>S</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>∝</mo>
   <mrow>
    <mi>X</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <msup>
     <mi>X</mi>
     <mo>*</mo>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>ω</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">proportional-to</csymbol>
    <apply>
     <times></times>
     <ci>S</ci>
     <ci>ω</ci>
    </apply>
    <apply>
     <times></times>
     <ci>X</ci>
     <ci>ω</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>X</ci>
      <times></times>
     </apply>
     <ci>ω</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   S(\omega)\propto X(\omega)X^{*}(\omega)
  </annotation>
 </semantics>
</math>

; for multiple time domain functions, the Fourier co-efficients can be stored in a matrix, which then means that the above equation is applicable.</p>

<p>Obviously, there are an infinite number of solutions to the above expression; consequently, the assumption that 

<math display="inline" id="Sandia_method:41">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ω</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(\omega_{k})
  </annotation>
 </semantics>
</math>

 is a lower triangular matrix is made such that only one solution exists. The solution can be found via a Cholesky decomposition. The resultant 

<math display="inline" id="Sandia_method:42">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ω</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(\omega_{k})
  </annotation>
 </semantics>
</math>

 matrix can be thought of as the weighting factors for the linear combination of N independent, unit-magnitude, white-noise inputs that will yield N correlated outputs with the correct spectral matrix.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a></p>

<p>To get the complex Fourier co-efficients associated with the Fourier transform of the time series of the wind speeds, a column vector, 

<math display="inline" id="Sandia_method:43">
 <semantics>
  <mi>V</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>V</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V
  </annotation>
 </semantics>
</math>

 is obtained by multiply the 

<math display="inline" id="Sandia_method:44">
 <semantics>
  <mrow>
   <mi>H</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ω</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>H</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   H(\omega_{k})
  </annotation>
 </semantics>
</math>

 matrix by a column vector containing 

<math display="inline" id="Sandia_method:45">
 <semantics>
  <msup>
   <mi>n</mi>
   <mn>2</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <cn type="integer">2</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{2}
  </annotation>
 </semantics>
</math>

 values of Gaussian white noise, 

<math display="inline" id="Sandia_method:46">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>ω</mi>
     <mi>k</mi>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>X</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>ω</ci>
     <ci>k</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   X(\omega_{k})
  </annotation>
 </semantics>
</math>

, as shown below:</p>

<p>

<math display="block" id="Sandia_method:47">
 <semantics>
  <mrow>
   <mrow>
    <mi>V</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ω</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ω</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
    <mi>X</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ω</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>V</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <ci>H</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>k</ci>
     </apply>
     <ci>X</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V(\omega_{k})=H(\omega_{k})X(\omega_{k})
  </annotation>
 </semantics>
</math>

</p>

<p>The column vector gives the Fourier co-efficients for all points on the grid at a given frequency. This is then built up into a two dimensional matrix which covers the complex Fourier co-efficients for all points across all frequencies. Then, an inverse fast Fourier transform is performed to get the time series. That is,</p>

<p>

<math display="block" id="Sandia_method:48">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>V</mi>
     <mi>i</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>ω</mi>
      <mi>k</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>→</mo>
   <msub>
    <mi>V</mi>
    <mrow>
     <mi>i</mi>
     <mi>k</mi>
    </mrow>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>V</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>ω</ci>
      <ci>k</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>V</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>k</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V_{i}(\omega_{k})\rightarrow V_{ik}
  </annotation>
 </semantics>
</math>

</p>
<h2 id="references">References</h2>

<p>"</p>

<p><a class="uri" href="Category:Wind" title="wikilink">Category:Wind</a> <a href="Category:Fluid_dynamics" title="wikilink">Category:Fluid dynamics</a> <a href="Category:Wind_turbines" title="wikilink">Category:Wind turbines</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">Veers - Three-dimensional wind simulation<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
