<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="52">SO (complexity)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>SO (complexity)</h1>
<hr/>

<p>Second-order logic is an extension of <a href="FO_(complexity)" title="wikilink">first-order</a> with <a href="second_order_logic" title="wikilink">second orders</a> quantifiers, hence the reader should first read <a href="FO_(complexity)" title="wikilink">FO (complexity)</a> to be able to understand this article. In <a href="descriptive_complexity" title="wikilink">descriptive complexity</a> we can see that the languages recognised by SO formulae is exactly equal to the language decided by a <a href="Turing_machine" title="wikilink">Turing machine</a> in the <a href="PH_(complexity)" title="wikilink">polynomial hierarchy</a>. Extensions of SO with some operators also give us the same expressivity than some well known <a href="complexity_class" title="wikilink">complexity class</a>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> so it is a way to do proofs about the complexity of some problems without having to go to the <a href="algorithm" title="wikilink">algorithmic</a> level.</p>
<h2 id="definition-and-examples">Definition and examples</h2>

<p>We define second-order variable, a SO variable has got an arity 

<math display="inline" id="SO_(complexity):0">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

 and represent any proposition of arity 

<math display="inline" id="SO_(complexity):1">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

, i.e. a subset of the 

<math display="inline" id="SO_(complexity):2">
 <semantics>
  <mi>k</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>k</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   k
  </annotation>
 </semantics>
</math>

-tuples of the universe. They are usually written in upper-case. Second order logic is the set of <a href="FO_(complexity)" title="wikilink">FO</a> formulae where we add quantification over second-order variables, hence we will use the terms defined in the <a href="FO_(complexity)" title="wikilink">FO</a> article without defining them again.</p>
<h2 id="property">Property</h2>
<h3 id="normal-form">Normal form</h3>

<p>Every formula is equivalent to a formula in prenex normal form, where we first write quantification on variable on second order and then a FO-formula in prenex normal form.</p>
<h3 id="relation-to-complexity-classes">Relation to complexity classes</h3>

<p>SO is equal to <a href="Polynomial_hierarchy" title="wikilink">Polynomial hierarchy</a>, more precisely we have that formula in prenex normal form where existential and universal of second order alternate <em>k</em> times are the <em>k</em>th level of the polynomial hierarchy.</p>

<p>This means that SO with only existential second-order quantification is equal to 

<math display="inline" id="SO_(complexity):3">
 <semantics>
  <msup>
   <mi mathvariant="normal">Σ</mi>
   <mn>1</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Σ</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma^{1}
  </annotation>
 </semantics>
</math>

 which is <a href="NP_(complexity)" title="wikilink">NP</a>, and with only universal quantification is equal to 

<math display="inline" id="SO_(complexity):4">
 <semantics>
  <msup>
   <mi mathvariant="normal">Π</mi>
   <mn>1</mn>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>normal-Π</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Pi^{1}
  </annotation>
 </semantics>
</math>

 which is <a class="uri" href="Co-NP" title="wikilink">Co-NP</a>.</p>
<h2 id="adding-restrictions">Adding restrictions</h2>
<h3 id="horn-formulae-are-equal-to-p">Horn formulae are equal to P</h3>

<p>SO(horn) is the set of boolean queries definable with SO formulae in <a href="disjunctive_normal_form" title="wikilink">disjunctive normal form</a> such that the first order quantifiers are all universal and the quantifier-free part of the formula is in <a href="Horn_clause" title="wikilink">Horn</a> form, which means that it is a big AND of OR, and in each "OR" every variable except possibly one are negated.</p>

<p>This class is equal to <a href="P_(complexity)" title="wikilink">P</a>.</p>

<p>Those formulaes can be made in prenex form where the second order is existential and the first order universal without loss of generalities.</p>
<h3 id="krom-formulae-are-equal-to-nl">Krom formulae are equal to NL</h3>

<p>SO(Krom) is the set of boolean queries definable with second-order formulae in conjunctive normal form such that the first order quantifiers are universal and the quantifier-free part of the formula is in <a href="Krom-clause" title="wikilink">Krom</a> form, which means that the first order formula is a big AND of OR, and in each "OR" there is at most two variables.</p>

<p>This class is equal to <a href="NL_(complexity)" title="wikilink">NL</a>.</p>

<p>Those formulaes can be made in prenex form where the second order is existential and the first order universal without loss of generalities.</p>
<h3 id="transitive-closure-is-pspace">Transitive closure is PSPACE</h3>

<p>SO(TC) is to SO what <a href="FO_(complexity)#Transitive_closure_is_NL" title="wikilink">FO(TC)</a> is to <a href="FO_(complexity)" title="wikilink">FO</a>. The TC operator can now also take second-order variable as argument. SO(TC) is equal to <a class="uri" href="PSPACE" title="wikilink">PSPACE</a>.</p>
<h3 id="least-fixed-point-is-exptime">Least fixed point is EXPTIME</h3>

<p>SO(LFP) is to SO what <a href="FO_(complexity)#Least_Fixed_Point_is_P" title="wikilink">FO(LFP)</a> is to <a href="FO_(complexity)" title="wikilink">FO</a>. The LFP operator can now also take second-order variable as argument. SO(LFP) is equal to <a class="uri" href="EXPTIME" title="wikilink">EXPTIME</a>.</p>
<h3 id="iterating">Iterating</h3>

<p>SO(<em>t</em>(<em>n</em>)) is to SO what <a href="FO_(complexity)#Iterating" title="wikilink">FO[<em>t</em>(<em>n</em>)</a>] is to <a href="FO_(complexity)" title="wikilink">FO</a>. But we now also have second-order quantifier in the quantifier block. It is known that:</p>
<ul>
<li>SO[

<math display="inline" id="SO_(complexity):5">
 <semantics>
  <msup>
   <mi>n</mi>
   <mrow>
    <mi>O</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>1</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>n</ci>
    <apply>
     <times></times>
     <ci>O</ci>
     <cn type="integer">1</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   n^{O(1)}
  </annotation>
 </semantics>
</math>

] is equal to <a class="uri" href="PSPACE" title="wikilink">PSPACE</a> it is also another way to write SO(TC).</li>
<li>SO[

<math display="inline" id="SO_(complexity):6">
 <semantics>
  <msup>
   <mn>2</mn>
   <msup>
    <mi>n</mi>
    <mrow>
     <mi>O</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mn>1</mn>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <cn type="integer">2</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>n</ci>
     <apply>
      <times></times>
      <ci>O</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2^{n^{O(1)}}
  </annotation>
 </semantics>
</math>

] is equal to <a class="uri" href="EXPTIME" title="wikilink">EXPTIME</a> it is also another way to write SO(LFP)</li>
</ul>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="FO_(complexity)" title="wikilink">First order</a></li>
<li><a href="HO_(complexity)" title="wikilink">High order</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://qwiki.stanford.edu/index.php/Complexity_Zoo:S#SO">Complexity zoo about SO</a>, see the class under it also.</li>
</ul>

<p>"</p>

<p><a href="Category:Descriptive_complexity" title="wikilink">Category:Descriptive complexity</a> <a href="Category:Computational_complexity_theory" title="wikilink">Category:Computational complexity theory</a> <a href="Category:Finite_model_theory" title="wikilink">Category:Finite model theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">*N. Immerman <em>Descriptive complexity</em> (1999 Springer), All information in this article can be checked in this book.<a href="#fnref1">↩</a></li>
</ol>
</section>
</body>
</html>
