<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="530">Alignment-free sequence analysis</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Alignment-free sequence analysis</h1><hr/>

<p>The emergence and need for the analysis of different types of data generated through biological research has given rise to the field of <a class="uri" href="bioinformatics" title="wikilink">bioinformatics</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Molecular sequence and structure data of <a class="uri" href="DNA" title="wikilink">DNA</a>, <a class="uri" href="RNA" title="wikilink">RNA</a> and <a class="uri" href="proteins" title="wikilink">proteins</a>, <a href="gene_expression" title="wikilink">gene expression</a> profiles or <a href="micro_array" title="wikilink">micro array</a> data, <a href="metabolic_pathway" title="wikilink">metabolic pathway</a> data are some of the major types of data being analysed in bioinformatics. Among them sequence data is increasing at the exponential rate due to advent of next-generation sequencing technologies. Since the origin of bioinformatics, <a href="sequence_analysis" title="wikilink">sequence analysis</a> has remained the major area of research with wide range of applications in database searching, <a href="genome_annotation" title="wikilink">genome annotation</a>, <a href="comparative_genomics" title="wikilink">comparative genomics</a>, <a href="molecular_phylogeny" title="wikilink">molecular phylogeny</a> and <a href="gene_prediction" title="wikilink">gene prediction</a>. The pioneering approaches for sequence analysis were based on <a href="sequence_alignment" title="wikilink">sequence alignment</a> either global or local, pairwise or <a href="multiple_sequence_alignment" title="wikilink">multiple sequence alignment</a>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Alignment-based approaches generally give excellent results when the sequences under study are closely related and can be reliably aligned, but when the sequences are divergent, a reliable alignment cannot be obtained and hence the applications of sequence alignment are limited. Another limitation of alignment-based approaches is their computational complexity and are time-consuming and thus, are limited when dealing with large-scale sequence data.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> The advent of <a href="next_generation_sequencing" title="wikilink">next generation sequencing</a> technologies has resulted in generation of voluminous sequencing data. The size of this sequence data poses challenges on alignment-based algorithms in their assembly, annotation and comparative studies. Thus, <strong>alignment-free sequence analysis</strong> approaches provide attractive alternatives over alignment-based approaches.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>
<h2 id="alignment-free-methods">Alignment-free methods</h2>

<p>Alignment-free methods can broadly be classified into four categories: a) methods based on k-mer/word frequency, b) methods based on substrings, c) methods based on information theory and d) methods based on graphical representation. Alignment-free approaches have been used in sequence similarity searches,<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> clustering and classification of sequences,<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> and more recently in phylogenetics<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a><a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a> (<strong>Figure 1</strong>).</p>

<p>Such molecular phylogeny analyses employing alignment-free approaches are said to be part of <em>next-generation phylogenomics</em>.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> A number of review articles provide in-depth review of alignment-free methods in sequence analysis.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a><a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a><a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a><a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a></p>
<h3 id="methods-based-on-k-merword-frequency">Methods based on k-mer/word frequency</h3>

<p>The popular methods based on k-mer/word frequencies include feature frequency profile (FFP),<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> Composition vector (CV),<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> Return time distribution (RTD),<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> frequency chaos game representation (FCGR).<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> and Spaced Words <a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>
<h4 id="feature-frequency-profile-ffp">Feature frequency profile (FFP)</h4>

<p>The methodology involved in FFP based method starts by calculating the count of each possible k-mer (possible number of k-mers for nucleotide sequence: 4<sup>k</sup>, while that for protein sequence: 20<sup>k</sup>) in sequences. Each k-mer count in each sequence is then normalized by dividing it by total of all k-mers' count in that sequence. This leads to conversion of each sequence into its feature frequency profile. The pair wise distance between two sequences is then calculated <a href="Jensen-Shannon_divergence" title="wikilink">Jensen-Shannon (JS) divergence</a> between their respective FFPs. The <a href="distance_matrix" title="wikilink">distance matrix</a> thus obtained can be used to construct <a href="phylogenetic_tree" title="wikilink">phylogenetic tree</a> using clustering algorithms like <a class="uri" href="Neighbor-joining" title="wikilink">Neighbor-joining</a>, <a class="uri" href="UPGMA" title="wikilink">UPGMA</a> etc.</p>
<h4 id="composition-vector-cv">Composition vector (CV)</h4>

<p>In this method frequency of appearance of each possible k-mer in a given sequence is calculated. The next characteristic step of this method is the subtraction of random background of these frequencies using <a href="Markov_model" title="wikilink">Markov model</a> to reduce the inﬂuence of random neutral <a class="uri" href="mutations" title="wikilink">mutations</a> to highlight the role of selective evolution. The normalized frequencies are put a ﬁxed order to form the composition vector (CV) of a given sequence. <a href="Cosine_distance" title="wikilink">Cosine distance</a> function is then used to compute pairwise distance between CVs of sequences. The distance matrix thus obtained can be used to construct phylogenetic tree using clustering algorithms like <a class="uri" href="Neighbor-joining" title="wikilink">Neighbor-joining</a>, <a class="uri" href="UPGMA" title="wikilink">UPGMA</a> etc. This method can be extended through resort to efficient pattern matching algorithms to include in the computation of the composition vectors: (i) all k-mers for any value of k, (ii) all substrings of any length up to an arbitrarily set maximum k value, (iii) all maximal substrings, where a substring is maximal if extending it by any character would cause a decrease in its occurrence count .<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a><a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>
<h4 id="return-time-distribution-rtd">Return time distribution (RTD)</h4>

<p>The RTD based method does not calculate the count of k-mers in sequences, instead it computes the time required for the reappearance of k-mers. The time refers to the number of residues in successive appearance of particular k-mer. Thus the occurrence of each k-mer in a sequence is calculated in the form of RTD, which is then summarised using two statistical parameters <a class="uri" href="mean" title="wikilink">mean</a> (μ) and <a href="standard_deviation" title="wikilink">standard deviation</a> (σ). Thus each sequence is represented in the form of numeric vector of size 2*4<sup>k</sup> containing μ and σ of 4<sup>k</sup> RTDs. The pair wise distance between sequences is calculated using <a href="Euclidean_distance" title="wikilink">Euclidean distance</a> measure. The distance matrix thus obtained can be used to construct phylogenetic tree using clustering algorithms like <a class="uri" href="Neighbor-joining" title="wikilink">Neighbor-joining</a>, <a class="uri" href="UPGMA" title="wikilink">UPGMA</a> etc.</p>
<h4 id="frequency-chaos-game-representation-fcgr">Frequency chaos game representation (FCGR)</h4>

<p>The FCGR methods have evolved from Chaos game representation (CGR) technique, which provides scale independent representation for genomic sequences.<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> The CGRs can be divided by grid lines where each grid square denotes the occurrence of oligonucleotides of a specific length in the sequence. Such representation of CGRs is termed as Frequency Chaos Game Representation (FCGR). This leads to representation of each sequence into FCGR. The pair wise distance between FCGRs of sequences can be calculated using either the Pearson distance or the Euclidean distance.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>
<h4 id="spaced-word-frequencies">Spaced-word frequencies</h4>

<p>While most alignment-free algorithms compare the word-composition of sequences, Spaced Words uses a pattern of care and don't care positions. The occurrence of a spaced word in a sequence is then defined by the characters at the match positions only, while the characters at the don't care positions are ignored. Instead of comparing the frequencies of contiguous words in the input sequences, this approach compares the frequencies of the spaced words according to the pre-defined pattern.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a></p>
<h3 id="methods-based-on-substrings">Methods based on substrings</h3>

<p>The methods in this category employ the similarity and differences of substrings in a pair of sequences. These algorithms were mostly used for string processing in <a href="computer_science" title="wikilink">computer science</a>.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></p>
<h4 id="average-common-substring-acs">Average common substring (ACS)</h4>

<p>In this approach, for a chosen pair of sequences (A and B of lengths l and m respectively), longest substring starting at some position is identified in one sequence (A) which exactly matches in the other sequence (B) at any position. In this way, lengths of longest substrings starting at different positions in sequence A and having exact matches at some positions in sequence B are calculated. All these lengths are averaged to derive a measure 

<math display="inline" id="Alignment-free_sequence_analysis:0">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <interval closure="open">
     <ci>A</ci>
     <ci>B</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(A,B)
  </annotation>
 </semantics>
</math>

. Intuitively, larger the 

<math display="inline" id="Alignment-free_sequence_analysis:1">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <interval closure="open">
     <ci>A</ci>
     <ci>B</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(A,B)
  </annotation>
 </semantics>
</math>

, the more similar the two sequences are. To account for the differences in the length of sequences, 

<math display="inline" id="Alignment-free_sequence_analysis:2">
 <semantics>
  <mrow>
   <mi>L</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>L</ci>
    <interval closure="open">
     <ci>A</ci>
     <ci>B</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(A,B)
  </annotation>
 </semantics>
</math>

 is normalized [i.e. 

<math display="inline" id="Alignment-free_sequence_analysis:3">
 <semantics>
  <mrow>
   <mrow>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>,</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>/</mo>
   <mrow>
    <mi>log</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <apply>
     <times></times>
     <ci>L</ci>
     <interval closure="open">
      <ci>A</ci>
      <ci>B</ci>
     </interval>
    </apply>
    <apply>
     <log></log>
     <ci>m</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L(A,B)/\log(m)
  </annotation>
 </semantics>
</math>

]. This gives the similarity measure between the sequences.</p>

<p>In order to derive a distance measure, the inverse of similarity measure is taken and a correction term is subtracted from it to assure that 

<math display="inline" id="Alignment-free_sequence_analysis:4">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>A</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <interval closure="open">
     <ci>A</ci>
     <ci>A</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(A,A)
  </annotation>
 </semantics>
</math>

 will be zero.</p>

<p>Thus, 

<math display="inline" id="Alignment-free_sequence_analysis:5">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>log</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>,</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">]</mo>
   </mrow>
   <mo>-</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mi>log</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mi>L</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>,</mo>
     <mi>A</mi>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">d</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-,</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <eq></eq>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <log></log>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">m</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <divide></divide>
     <csymbol cd="unknown">L</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">B</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-]</ci>
    </cerror>
    <minus></minus>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-[</ci>
     <log></log>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">n</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <divide></divide>
     <csymbol cd="unknown">L</csymbol>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-,</ci>
      <csymbol cd="unknown">A</csymbol>
      <ci>normal-]</ci>
     </cerror>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(A,B)=[\log(m)/L(A,B)]-[\log(n)/L(A,A]
  </annotation>
 </semantics>
</math>

.</p>

<p>This measure 

<math display="inline" id="Alignment-free_sequence_analysis:6">
 <semantics>
  <mrow>
   <mi>d</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>d</ci>
    <interval closure="open">
     <ci>A</ci>
     <ci>B</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d(A,B)
  </annotation>
 </semantics>
</math>

 is not symmetric, so one has to compute 

<math display="inline" id="Alignment-free_sequence_analysis:7">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>d</mi>
     <mi>s</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>A</mi>
     <mo>,</mo>
     <mi>B</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>d</mi>
     <mi>s</mi>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>B</mi>
     <mo>,</mo>
     <mi>A</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mi>d</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>A</mi>
        <mo>,</mo>
        <mi>B</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mi>d</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>B</mi>
        <mo>,</mo>
        <mi>A</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <ci>s</ci>
      </apply>
      <interval closure="open">
       <ci>A</ci>
       <ci>B</ci>
      </interval>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>d</ci>
       <ci>s</ci>
      </apply>
      <interval closure="open">
       <ci>B</ci>
       <ci>A</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>d</ci>
        <interval closure="open">
         <ci>A</ci>
         <ci>B</ci>
        </interval>
       </apply>
       <apply>
        <times></times>
        <ci>d</ci>
        <interval closure="open">
         <ci>B</ci>
         <ci>A</ci>
        </interval>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   d_{s}(A,B)=d_{s}(B,A)=(d(A,B)+d(B,A))/2
  </annotation>
 </semantics>
</math>

, which gives ﬁnal ACS measure between the two strings (A and B).<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> The subsequence/substring search can be efficiently performed by using <a href="Suffix_tree" title="wikilink">sufﬁx trees</a>.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a><a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a><a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a></p>
<h4 id="k-mismatch-average-common-substring-approach-kmacs">k-mismatch average common substring approach (kmacs)</h4>

<p>This approach is a generalization of the ACS approach. To define the distance between two DNA or protein sequences, kmacs estimates for each position i of the first sequence the longest substring starting at i and matching a substring of the second sequence with up to k mismatches. It defines the average of these values as a measure of similarity between the sequences and turns this into a symmetric distance measure. Kmacs does not compute exact k-mismatch substrings, since this would be computational too costly, but approximates such substrings.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></p>
<h4 id="mutation-distances-kr">Mutation distances (Kr)</h4>

<p>This approach is closely related to the ACS, which calculates the number of substitutions per site between two DNA sequences using the shortest absent substring (termed as shustring).<a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a></p>
<h3 id="methods-based-on-information-theory">Methods based on Information theory</h3>

<p>Information Theory has provided successful methods for alignment-free sequence analysis and comparison. The existing applications of information theory include global and local characterization of DNA, RNA and proteins, estimating genome entropy to motif and region classification. It also holds promise in gene mapping, next-generation sequencing analysis and metagenomics.<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a></p>
<h4 id="base-base-correlation-bbc">Base base correlation (BBC)</h4>

<p>Base base correlation (BBC)converts the genome sequence into a unique 16-dimensional numeric vector using the following equation,<br/>


<math display="inline" id="Alignment-free_sequence_analysis:8">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>T</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>K</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>l</mi>
       <mo>=</mo>
       <mn>1</mn>
      </mrow>
      <mi>K</mi>
     </msubsup>
     <mrow>
      <msub>
       <mi>P</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>l</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
   <mrow>
    <msub>
     <mi>log</mi>
     <mn>2</mn>
    </msub>
    <mrow>
     <mo>(</mo>
     <mfrac>
      <mrow>
       <msub>
        <mi>P</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>l</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mrow>
       <msub>
        <mi>P</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>P</mi>
        <mi>j</mi>
       </msub>
      </mrow>
     </mfrac>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>T</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <ci>K</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <sum></sum>
        <apply>
         <eq></eq>
         <ci>l</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>K</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>l</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <log></log>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>l</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <ci>j</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{ij}(K)=\sum_{l=1}^{K}P_{ij}(l).\log_{2}\left(\frac{P_{ij}(l)}{P_{i}P_{j}}\right)
  </annotation>
 </semantics>
</math>

<br/>
The 

<math display="inline" id="Alignment-free_sequence_analysis:9">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>i</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>i</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{i}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Alignment-free_sequence_analysis:10">
 <semantics>
  <msub>
   <mi>P</mi>
   <mi>j</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>P</ci>
    <ci>j</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{j}
  </annotation>
 </semantics>
</math>

 denotes the probabilities of bases i and j in the genome. The 

<math display="inline" id="Alignment-free_sequence_analysis:11">
 <semantics>
  <mrow>
   <msub>
    <mi>P</mi>
    <mrow>
     <mi>i</mi>
     <mi>j</mi>
    </mrow>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>l</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>P</ci>
     <apply>
      <times></times>
      <ci>i</ci>
      <ci>j</ci>
     </apply>
    </apply>
    <ci>l</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   P_{ij}(l)
  </annotation>
 </semantics>
</math>

 indicates the probability of bases i and j at distance l in the genome. The parameter K indicates the maximum distance between the bases i and j. The variation in the values of 16 parameters reflect variation in the genome content and length.<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a><a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a><a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a></p>
<h4 id="information-correlation-and-partial-information-correlation-ic-pic">Information correlation and partial information correlation (IC-PIC)</h4>

<p>IC-PIC (information correlation and partial information correlation) based method employs the base correlation property of DNA sequence. IC and PIC were calculated using following formulas,</p>

<p>

<math display="inline" id="Alignment-free_sequence_analysis:12">
 <semantics>
  <mrow>
   <mrow>
    <mi>I</mi>
    <msub>
     <mi>C</mi>
     <mi>l</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mn>2</mn>
      <mrow>
       <msub>
        <mo largeop="true" symmetric="true">∑</mo>
        <mi>i</mi>
       </msub>
       <mrow>
        <msub>
         <mi>P</mi>
         <mi>i</mi>
        </msub>
        <mrow>
         <msub>
          <mi>log</mi>
          <mn>2</mn>
         </msub>
         <msub>
          <mi>P</mi>
          <mi>i</mi>
         </msub>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mrow>
     <msub>
      <mo largeop="true" symmetric="true">∑</mo>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
     <mrow>
      <msub>
       <mi>P</mi>
       <mrow>
        <mi>i</mi>
        <mi>j</mi>
       </mrow>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>l</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <msub>
        <mi>log</mi>
        <mn>2</mn>
       </msub>
       <msub>
        <mi>P</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
       </msub>
      </mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>l</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>I</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <ci>l</ci>
     </apply>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <cn type="integer">2</cn>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <ci>i</ci>
        </apply>
        <apply>
         <times></times>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>P</ci>
          <ci>i</ci>
         </apply>
         <apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <log></log>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>P</ci>
           <ci>i</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>l</ci>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <log></log>
         <cn type="integer">2</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>P</ci>
         <apply>
          <times></times>
          <ci>i</ci>
          <ci>j</ci>
         </apply>
        </apply>
       </apply>
       <ci>l</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   IC_{l}=-2\sum_{i}P_{i}\log_{2}P_{i}+\sum_{ij}P_{ij}(l)\log_{2}P_{ij}(l)
  </annotation>
 </semantics>
</math>

 

<math display="inline" id="Alignment-free_sequence_analysis:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>P</mi>
    <mi>I</mi>
    <msub>
     <mi>C</mi>
     <mrow>
      <mi>i</mi>
      <mi>j</mi>
     </mrow>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>l</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <msub>
        <mi>P</mi>
        <mrow>
         <mi>i</mi>
         <mi>j</mi>
        </mrow>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>l</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>-</mo>
      <mrow>
       <msub>
        <mi>P</mi>
        <mi>i</mi>
       </msub>
       <msub>
        <mi>P</mi>
        <mi>j</mi>
       </msub>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>l</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>P</ci>
     <ci>I</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>C</ci>
      <apply>
       <times></times>
       <ci>i</ci>
       <ci>j</ci>
      </apply>
     </apply>
     <ci>l</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <minus></minus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <apply>
         <times></times>
         <ci>i</ci>
         <ci>j</ci>
        </apply>
       </apply>
       <ci>l</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>P</ci>
        <ci>j</ci>
       </apply>
       <ci>l</ci>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   PIC_{ij}(l)=(P_{ij}(l)-P_{i}P_{j}(l))^{2}
  </annotation>
 </semantics>
</math>

</p>

<p>The final vector is obtained as following,</p>

<p>

<math display="inline" id="Alignment-free_sequence_analysis:14">
 <semantics>
  <mrow>
   <mi>V</mi>
   <mo>=</mo>
   <mfrac>
    <mrow>
     <mi>I</mi>
     <msub>
      <mi>C</mi>
      <mi>l</mi>
     </msub>
    </mrow>
    <mrow>
     <mi>P</mi>
     <mi>I</mi>
     <msub>
      <mi>C</mi>
      <mrow>
       <mi>i</mi>
       <mi>j</mi>
      </mrow>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>l</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>V</ci>
    <apply>
     <divide></divide>
     <apply>
      <times></times>
      <ci>I</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <ci>l</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>P</ci>
      <ci>I</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>C</ci>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>j</ci>
       </apply>
      </apply>
      <ci>l</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   V={IC_{l}\over PIC_{ij}(l)}
  </annotation>
 </semantics>
</math>

 here 

<math display="inline" id="Alignment-free_sequence_analysis:15">
 <semantics>
  <mrow>
   <mi>l</mi>
   <merror class="ltx_ERROR undefined undefined">
    <mtext>\isin</mtext>
   </merror>
   <mrow>
    <mo>{</mo>
    <msub>
     <mi>l</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>l</mi>
      <mn>0</mn>
     </msub>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mrow>
     <msub>
      <mi>l</mi>
      <mn>0</mn>
     </msub>
     <mo>+</mo>
     <mi>n</mi>
    </mrow>
    <mo>}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>l</ci>
    <mtext>\isin</mtext>
    <set>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>l</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>l</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>n</ci>
     </apply>
    </set>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   l\isin\left\{l_{0},l_{0}+1,...,l_{0}+n\right\}
  </annotation>
 </semantics>
</math>

 which defines the range of distance between bases.<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a></p>

<p>The pair wise distance between sequences is calculated using Euclidean distance measure. The distance matrix thus obtained can be used to construct phylogenetic tree using clustering algorithms like Neighbor-joining, UPGMA etc.</p>
<h4 id="lempel-ziv-compress">Lempel-Ziv compress</h4>

<p>Lempel-Ziv complexity uses the relative information between the sequences. This complexity is measured by the number of steps required to generate a string given the prior knowledge of another string and a self-delimiting production process. This measure has a relation to measuring k-words in a sequence, as they can be easily used to generate the sequence. It is computational intensive method. Otu and Sayood (2003) used this method to construct five different distance measures for phylogenetic tree construction.<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a></p>
<h4 id="context-modeling-compress">Context modeling compress</h4>

<p>In the context modeling complexity the next-symbol predictions, of one or more statistical models, are combined or competing to yield a prediction that is based on events recorded in the past. The algorithmic information content derived from each symbol prediction can be used to compute algorithmic information profiles with a time proportional to the length of the sequence. The process has been applied to DNA sequence analysis.<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a></p>
<h3 id="methods-based-on-graphical-representation">Methods based on graphical representation</h3>
<h4 id="iterated-maps">Iterated Maps</h4>

<p>The use of iterated maps for sequence analysis was first introduced by HJ Jefferey in 1990<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a> when he proposed to apply the <a href="Chaos_game" title="wikilink">Chaos Game</a> to map genomic sequences into a unit square. That report coined the procedure as Chaos Game Representation (CGR). However, only 3 years later this approach was first dismissed as a projection of a Markov transition table by N Goldman.<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> This objection was overruled by the end of that decade when the opposite was found to be the case - that CGR bijectively maps Markov transition is into a fractal, order-free (degree-free) representation.<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a> The realization that iterated maps provide a bijective map between the symbolic space and numeric space led to the identification of a variety of alignment-free approaches to sequence comparison and characterization. These developments were reviewed in late 2013 by JS Almeida in.<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a> A number of web apps such as <a class="uri" href="http://usm.github.com">http://usm.github.com</a> are available to demonstrate how to encode and compare arbitrary symbolic sequences.</p>
<h2 id="comparison-of-alignment-based-and-alignment-free-methods">Comparison of alignment based and alignment-free methods <a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a></h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Alignment-based methods</p></th>
<th style="text-align: left;">
<p>Alignment-free methods</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>These methods assume that homologous regions are contiguous (with gaps)</p></td>
<td style="text-align: left;">
<p>Does not assume such contiguity of homologous regions</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Computes all possible pairwise comparisons of sequences; hence computationally expensive</p></td>
<td style="text-align: left;">
<p>Based on occurrences of sub-sequences; composition; computationally inexpensive, can be memory-intensive</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Well-established approach in phylogenomics</p></td>
<td style="text-align: left;">
<p>Relatively recent and application in phylogenomics is limited; needs further testing for robustness and scalability</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Requires substitution/evolutionary models</p></td>
<td style="text-align: left;">
<p>Less dependent on substitution/evolutionary models</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Sensitive to stochastic sequence variation, recombination, horizontal (or lateral) genetic transfer, rate heterogeneity and sequences of varied lengths, especially when similarity lies in the “twilight zone”</p></td>
<td style="text-align: left;">
<p>Less sensitive to stochastic sequence variation, recombination, horizontal (or lateral) genetic transfer, rate heterogeneity and sequences of varied lengths</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Best practice uses inference algorithms with complexity at least O(n<sup>2</sup>); less time-efficient</p></td>
<td style="text-align: left;">
<p>Inference algorithms typically O(n<sup>2</sup>) or less; more time-efficient</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Heuristic in nature; statistical significance of how alignment scores relate to homology is difficult to assess</p></td>
<td style="text-align: left;">
<p>Exact solutions; statistical significance of the sequence distances (and degree of similarity) can be readily assessed</p></td>
</tr>
</tbody>
</table>
<h2 id="applications-of-alignment-free-methods">Applications of alignment-free methods</h2>
<ul>
<li>Genomic rearrangements<a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a></li>
<li>Molecular phylogenetics<a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a></li>
<li>Metagenomics<a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a></li>
<li>Next generation sequence data analysis<a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a></li>
<li>Epigenomics<a class="footnoteRef" href="#fn51" id="fnref51"><sup>51</sup></a></li>
<li>Barcoding of species<a class="footnoteRef" href="#fn52" id="fnref52"><sup>52</sup></a></li>
<li>Population genetics<a class="footnoteRef" href="#fn53" id="fnref53"><sup>53</sup></a></li>
<li>Horizontal gene transfer<a class="footnoteRef" href="#fn54" id="fnref54"><sup>54</sup></a></li>
<li>Sero/genotyping of viruses<a class="footnoteRef" href="#fn55" id="fnref55"><sup>55</sup></a><a class="footnoteRef" href="#fn56" id="fnref56"><sup>56</sup></a><a class="footnoteRef" href="#fn57" id="fnref57"><sup>57</sup></a></li>
<li>Allergenicity prediction<a class="footnoteRef" href="#fn58" id="fnref58"><sup>58</sup></a></li>
<li>SNP discovery<a class="footnoteRef" href="#fn59" id="fnref59"><sup>59</sup></a></li>
<li>Recombination detection<a class="footnoteRef" href="#fn60" id="fnref60"><sup>60</sup></a></li>
</ul>
<h2 id="list-of-web-serverssoftware-for-alignment-free-methods">List of web servers/software for alignment-free methods</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Name</p></th>
<th style="text-align: left;">
<p>Description</p></th>
<th style="text-align: left;">
<p>Availability</p></th>
<th style="text-align: left;">
<p>Reference</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>kmacs</p></td>
<td style="text-align: left;">
<p>k-mismatch average common substring approach</p></td>
<td style="text-align: left;">
<p><a href="http://kmacs.gobics.de/">kmacs</a></p></td>
<td style="text-align: left;">
<p><a class="footnoteRef" href="#fn61" id="fnref61"><sup>61</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Spaced words</p></td>
<td style="text-align: left;">
<p>Spaced-word frequencies</p></td>
<td style="text-align: left;">
<p><a href="http://spaced.gobics.de/">spaced-words</a></p></td>
<td style="text-align: left;">
<p><a class="footnoteRef" href="#fn62" id="fnref62"><sup>62</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>FFP</p></td>
<td style="text-align: left;">
<p>Feature frequency profile based phylogeny</p></td>
<td style="text-align: left;">
<p><a href="http://sourceforge.net/projects/ffp-phylogeny/">FFP</a></p></td>
<td style="text-align: left;">
<p><a class="footnoteRef" href="#fn63" id="fnref63"><sup>63</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>CVTree</p></td>
<td style="text-align: left;">
<p>Composition vector based server for phylogeny</p></td>
<td style="text-align: left;">
<p><a href="http://tlife.fudan.edu.cn/cvtree/">CVTree</a></p></td>
<td style="text-align: left;">
<p><a class="footnoteRef" href="#fn64" id="fnref64"><sup>64</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>RTD Phylogeny</p></td>
<td style="text-align: left;">
<p>Return time distribution based server for phylogeny</p></td>
<td style="text-align: left;">
<p><a href="http://bioinfo.net.in/RTD/home.html">RTD Phylogeny</a></p></td>
<td style="text-align: left;">
<p><a class="footnoteRef" href="#fn65" id="fnref65"><sup>65</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>AGP</p></td>
<td style="text-align: left;">
<p>A multimethods web server for alignment-free genome phylogeny</p></td>
<td style="text-align: left;">
<p><a href="http://www.herbbol.org:8000/agp">AGP</a></p></td>
<td style="text-align: left;">
<p><a class="footnoteRef" href="#fn66" id="fnref66"><sup>66</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>Alfy</p></td>
<td style="text-align: left;">
<p>Alignment-free detection of local similarity among viral and bacterial genomes</p></td>
<td style="text-align: left;">
<p><a href="http://guanine.evolbio.mpg.de/alfy/">Alfy</a></p></td>
<td style="text-align: left;">
<p><a class="footnoteRef" href="#fn67" id="fnref67"><sup>67</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>decaf+py</p></td>
<td style="text-align: left;">
<p>DistancE Calculation using Alignment-Free methods in PYthon</p></td>
<td style="text-align: left;">
<p><a href="http://acb.qfab.org/acb/decaf+py/">decaf+py</a></p></td>
<td style="text-align: left;">
<p><a class="footnoteRef" href="#fn68" id="fnref68"><sup>68</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>MuV genotyping server</p></td>
<td style="text-align: left;">
<p>Genotyping of Mumps viruses based on RTD</p></td>
<td style="text-align: left;">
<p><a href="http://117.239.43.117:1800/muv/homepage.html">MuV Genotyping server</a></p></td>
<td style="text-align: left;">
<p><a class="footnoteRef" href="#fn69" id="fnref69"><sup>69</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>Dengue Subtyper</p></td>
<td style="text-align: left;">
<p>Genotyping of Dengue viruses based on RTD</p></td>
<td style="text-align: left;">
<p><a href="http://117.239.43.117:1800/Dengue/homepage.html">Dengue Subtyper</a></p></td>
<td style="text-align: left;">
<p><a class="footnoteRef" href="#fn70" id="fnref70"><sup>70</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>WNV Typer</p></td>
<td style="text-align: left;">
<p>Genotyping of West nile viruses based on RTD</p></td>
<td style="text-align: left;">
<p><a href="http://117.239.43.117:1800/WNV/homepage.html">WNV Typer</a></p></td>
<td style="text-align: left;">
<p><a class="footnoteRef" href="#fn71" id="fnref71"><sup>71</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>AllergenFP</p></td>
<td style="text-align: left;">
<p>Allergenicity prediction by descriptor fingerprints</p></td>
<td style="text-align: left;">
<p><a href="http://ddg-pharmfac.net/AllergenFP/">AllergenFP</a></p></td>
<td style="text-align: left;">
<p><a class="footnoteRef" href="#fn72" id="fnref72"><sup>72</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>kSNP v2</p></td>
<td style="text-align: left;">
<p>Alignment-Free SNP Discovery</p></td>
<td style="text-align: left;">
<p><a href="http://sourceforge.net/projects/ksnp/">kSNP v2</a></p></td>
<td style="text-align: left;">
<p><a class="footnoteRef" href="#fn73" id="fnref73"><sup>73</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>d2Tools</p></td>
<td style="text-align: left;">
<p>Comparison of Metatranscriptomic Samples Based on k-Tuple Frequencies</p></td>
<td style="text-align: left;">
<p><a href="https://code.google.com/p/d2-tools/">d2Tools</a></p></td>
<td style="text-align: left;">
<p><a class="footnoteRef" href="#fn74" id="fnref74"><sup>74</sup></a></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>rush</p></td>
<td style="text-align: left;">
<p>Recombination detection Using SHustrings</p></td>
<td style="text-align: left;">
<p><a href="http://guanine.evolbio.mpg.de/rush/">rush</a></p></td>
<td style="text-align: left;">
<p><a class="footnoteRef" href="#fn75" id="fnref75"><sup>75</sup></a></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>smash</p></td>
<td style="text-align: left;">
<p>Genomic rearrangements detection and visualisation</p></td>
<td style="text-align: left;">
<p><a href="http://bioinformatics.ua.pt/software/smash/">smash</a></p></td>
<td style="text-align: left;">
<p><a class="footnoteRef" href="#fn76" id="fnref76"><sup>76</sup></a></p></td>
</tr>
</tbody>
</table>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Sequence_analysis" title="wikilink">Sequence analysis</a></li>
<li><a href="Multiple_sequence_alignment" title="wikilink">Multiple sequence alignment</a></li>
<li><a class="uri" href="Phylogenomics" title="wikilink">Phylogenomics</a></li>
<li><a class="uri" href="Bioinformatics" title="wikilink">Bioinformatics</a></li>
<li><a class="uri" href="Metagenomics" title="wikilink">Metagenomics</a></li>
<li><a href="Next-generation_sequencing" title="wikilink">Next-generation sequencing</a></li>
<li><a href="Population_genetics" title="wikilink">Population genetics</a></li>
<li><a class="uri" href="SNPs" title="wikilink">SNPs</a></li>
<li><a href="Recombination_detection_program" title="wikilink">Recombination detection program</a></li>
</ul>
<h2 id="references">References</h2>

<p>"</p>

<p><a class="uri" href="Category:Bioinformatics" title="wikilink">Category:Bioinformatics</a> <a href="Category:Computational_biology" title="wikilink">Category:Computational biology</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
<li id="fn31"><a href="#fnref31">↩</a></li>
<li id="fn32"><a href="#fnref32">↩</a></li>
<li id="fn33"></li>
<li id="fn34"><a href="#fnref34">↩</a></li>
<li id="fn35"><a href="#fnref35">↩</a></li>
<li id="fn36"><a href="#fnref36">↩</a></li>
<li id="fn37"><a href="#fnref37">↩</a></li>
<li id="fn38"><a href="#fnref38">↩</a></li>
<li id="fn39"><a href="#fnref39">↩</a></li>
<li id="fn40"><a href="#fnref40">↩</a></li>
<li id="fn41"><a href="#fnref41">↩</a></li>
<li id="fn42"></li>
<li id="fn43"><a href="#fnref43">↩</a></li>
<li id="fn44"><a href="#fnref44">↩</a></li>
<li id="fn45"><a href="#fnref45">↩</a></li>
<li id="fn46"></li>
<li id="fn47"><a href="#fnref47">↩</a></li>
<li id="fn48"></li>
<li id="fn49"><a href="#fnref49">↩</a></li>
<li id="fn50"></li>
<li id="fn51"><a href="#fnref51">↩</a></li>
<li id="fn52"><a href="#fnref52">↩</a></li>
<li id="fn53"><a href="#fnref53">↩</a></li>
<li id="fn54"><a href="#fnref54">↩</a></li>
<li id="fn55"></li>
<li id="fn56"></li>
<li id="fn57"><a href="#fnref57">↩</a></li>
<li id="fn58"><a href="#fnref58">↩</a></li>
<li id="fn59"><a href="#fnref59">↩</a></li>
<li id="fn60"><a href="#fnref60">↩</a></li>
<li id="fn61"><a href="#fnref61">↩</a></li>
<li id="fn62"><a href="#fnref62">↩</a></li>
<li id="fn63"></li>
<li id="fn64"><a href="#fnref64">↩</a></li>
<li id="fn65"></li>
<li id="fn66"><a href="#fnref66">↩</a></li>
<li id="fn67"></li>
<li id="fn68"><a href="#fnref68">↩</a></li>
<li id="fn69"></li>
<li id="fn70"></li>
<li id="fn71"></li>
<li id="fn72"></li>
<li id="fn73"></li>
<li id="fn74"><a href="#fnref74">↩</a></li>
<li id="fn75"></li>
<li id="fn76"></li>
</ol>
</section>
</body>
</html>
