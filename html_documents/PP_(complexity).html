<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="137">PP (complexity)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>PP (complexity)</h1>
<hr/>

<p>In <a href="complexity_theory_in_computation" title="wikilink">complexity theory</a>, <strong>PP</strong> is the class of <a href="decision_problem" title="wikilink">decision problems</a> solvable by a <a href="probabilistic_Turing_machine" title="wikilink">probabilistic Turing machine</a> in <a href="polynomial_time" title="wikilink">polynomial time</a>, with an error probability of less than 1/2 for all instances. The abbreviation <strong>PP</strong> refers to probabilistic polynomial time. The complexity class was defined<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> by Gill in 1977.</p>

<p>If a decision problem is in <strong>PP</strong>, then there is an algorithm for it that is allowed to flip coins and make random decisions. It is guaranteed to run in polynomial time. If the answer is YES, the algorithm will answer YES with probability more than 1/2. If the answer is NO, the algorithm will answer YES with probability less than or equal to 1/2. In more practical terms, it is the class of problems that can be solved to any fixed degree of accuracy by running a randomized, polynomial-time algorithm a sufficient (but bounded) number of times.</p>

<p>An alternative characterization of <strong>PP</strong> is the set of problems that can be solved by a <a href="nondeterministic_Turing_machine" title="wikilink">nondeterministic Turing machine</a> in polynomial time where the acceptance condition is that a majority (more than half) of computation paths accept. Because of this some authors have suggested the alternative name <em>Majority-P</em>.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<h2 id="definition">Definition</h2>

<p>A language <em>L</em> is in <strong>PP</strong> if and only if there exists a probabilistic Turing machine <em>M</em>, such that</p>
<ul>
<li><em>M</em> runs for polynomial time on all inputs</li>
<li>For all <em>x</em> in <em>L</em>, <em>M</em> outputs 1 with probability strictly greater than 1/2</li>
<li>For all <em>x</em> not in <em>L</em>, <em>M</em> outputs 1 with probability less than or equal to 1/2.</li>
</ul>

<p>Alternatively, <strong>PP</strong> can be defined using only deterministic Turing machines. A language <em>L</em> is in <strong>PP</strong> if and only if there exists a polynomial <em>p</em> and deterministic Turing machine <em>M</em>, such that</p>
<ul>
<li><em>M</em> runs for polynomial time on all inputs</li>
<li>For all <em>x</em> in <em>L</em>, the fraction of strings <em>y</em> of length <em>p</em>(|<em>x</em>|) which satisfy <em>M(x,y)</em> = 1 is strictly greater than 1/2</li>
<li>For all <em>x</em> not in <em>L</em>, the fraction of strings <em>y</em> of length <em>p</em>(|<em>x</em>|) which satisfy <em>M(x,y)</em> = 1 is less than or equal to 1/2.</li>
</ul>

<p>In both definitions, "less than or equal" can be changed to "less than" (see below), and the threshold 1/2 can be replaced by any fixed rational number in (0,1), without changing the class.</p>
<h2 id="pp-vs-bpp">PP vs BPP</h2>

<p><strong><a href="Bounded-error_probabilistic_polynomial" title="wikilink">BPP</a></strong> is a subset of <strong>PP</strong>; it can be seen as the subset for which there are efficient probabilistic algorithms. The distinction is in the error probability that is allowed: in <strong>BPP</strong>, an algorithm must give correct answer (YES or NO) with probability exceeding some fixed constant <em>c</em> greater than 1/2, such as 2/3 or 501/1000. If this is the case, then we can run the algorithm a polynomial number of times and take a majority vote to achieve any desired probability of correctness less than 1, using the <a href="Chernoff_bound" title="wikilink">Chernoff bound</a>. This number of repeats increases if <em>c</em> becomes closer to 1/2, but it does not depend on the input size <em>n</em>.</p>

<p>The important thing is that this constant <em>c</em> is not allowed to depend on the input. On the other hand, a <strong>PP</strong> algorithm is permitted to do something like the following:</p>
<ul>
<li>On a YES instance, output YES with probability 1/2 + 1/2<sup><em>n</em></sup>, where <em>n</em> is the length of the input.</li>
<li>On a NO instance, output YES with probability 1/2 - 1/2<sup><em>n</em></sup>.</li>
</ul>

<p>Because these two probabilities are so close together, especially for large <em>n</em>, even if we run it a large number of times it is very difficult to tell whether we are operating on a YES instance or a NO instance. Attempting to achieve a fixed desired probability level using a majority vote and the Chernoff bound requires a number of repetitions that is exponential in <em>n</em>.</p>
<h2 id="pp-compared-to-other-complexity-classes">PP compared to other complexity classes</h2>

<p><strong>PP</strong> contains <strong>BPP</strong>, since probabilistic algorithms described in the definition of <strong>BPP</strong> form a subset of those in the definition of <strong>PP</strong>.</p>

<p><strong>PP</strong> also contains <strong><a href="NP_(complexity_class)" title="wikilink">NP</a></strong>. To prove this, we show that the <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> <a href="Boolean_satisfiability_problem" title="wikilink">satisfiability</a> problem belongs to <strong>PP</strong>. Consider a probabilistic algorithm that, given a formula <em>F</em>(<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ..., <em>x</em><sub><em>n</em></sub>) chooses an assignment <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ..., <em>x</em><sub><em>n</em></sub> uniformly at random. Then, the algorithm checks if the assignment makes the formula <em>F</em> true. If yes, it outputs YES. Otherwise, it outputs YES with probability 1/2 and NO with probability 1/2.</p>

<p>If the formula is unsatisfiable, the algorithm will always output YES with probability 1/2. If there exists a satisfying assignment, it will output YES with probability more than 1/2 (exactly 1/2 if it picked an unsatisfying assignment and 1 if it picked a satisfying assignment, averaging to some number greater than 1/2). Thus, this algorithm puts satisfiability in <strong>PP</strong>. As <strong>SAT</strong> is NP-complete, and we can prefix any deterministic <a href="polynomial-time_many-one_reduction" title="wikilink">polynomial-time many-one reduction</a> onto the <strong>PP</strong> algorithm, <strong>NP</strong> is contained in <strong>PP</strong>. Because <strong>PP</strong> is closed under complement, it also contains <strong>co-NP</strong>.</p>

<p>Furthermore, <strong>PP</strong> contains <strong><a href="Arthur-Merlin_protocol" title="wikilink">MA</a></strong>,<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> which subsumes the previous two inclusions.</p>

<p><strong>PP</strong> also contains <strong><a class="uri" href="BQP" title="wikilink">BQP</a></strong>, the class of decision problems solvable by efficient polynomial time <a href="quantum_computer" title="wikilink">quantum computers</a>. In fact, BQP is <a href="low_(complexity)" title="wikilink">low</a> for <strong>PP</strong>, meaning that a <strong>PP</strong> machine achieves no benefit from being able to solve <strong>BQP</strong> problems instantly. The class of polynomial time on quantum computers with <a class="uri" href="postselection" title="wikilink">postselection</a>, <strong><a class="uri" href="PostBQP" title="wikilink">PostBQP</a></strong>, is equal to <strong>PP</strong><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> (see <a class="uri" href="#PostBQP" title="wikilink">#PostBQP</a> below).</p>

<p>Furthermore, <strong>PP</strong> contains <strong><a class="uri" href="QMA" title="wikilink">QMA</a></strong>, which subsumes inclusions of <strong>MA</strong> and <strong>BQP</strong>.</p>

<p>A polynomial time Turing machine with a PP <a href="oracle_machine" title="wikilink">oracle</a> (<strong>P<sup>PP</sup></strong>) can solve all problems in <strong><a href="PH_(complexity)" title="wikilink">PH</a></strong>, the entire <a href="polynomial_hierarchy" title="wikilink">polynomial hierarchy</a>. This result was shown by <a href="Seinosuke_Toda" title="wikilink">Seinosuke Toda</a> in 1989 and is known as <a href="Toda's_theorem" title="wikilink">Toda's theorem</a>. This is evidence of how hard it is to solve problems in <strong>PP</strong>. The class <a href="Sharp-P" title="wikilink">#P</a> is in some sense about as hard, since <strong>P</strong><sup><strong>#P</strong></sup> = <strong>P<sup>PP</sup></strong>and therefore <strong>P</strong><sup><strong>#P</strong></sup> contains <strong>PH</strong> as well.</p>

<p><strong>PP</strong> strictly contains <strong><a href="TC0" title="wikilink">TC<sup>0</sup></a></strong>, the class of constant-depth, unbounded-fan-in uniform <a href="boolean_circuit" title="wikilink">boolean circuits</a> with <a href="majority_gate" title="wikilink">majority gates</a>. (Allender 1996, as cited in Burtschick 1999).</p>

<p><strong>PP</strong> is contained in <strong><a class="uri" href="PSPACE" title="wikilink">PSPACE</a></strong>. This can be easily shown by exhibiting a polynomial-space algorithm for <strong>MAJSAT</strong>, defined below; simply try all assignments and count the number of satisfying ones.</p>

<p><strong>PP</strong> is not contained in <strong>SIZE</strong>(n<sup>k</sup>) for any k (<a href="Karp-Lipton_theorem#Application_to_circuit_lower_bounds_–_Kannan's_theorem" title="wikilink">proof</a>).</p>
<h2 id="complete-problems-and-other-properties">Complete problems and other properties</h2>

<p>Unlike <strong>BPP</strong>, <strong>PP</strong> is a syntactic, rather than semantic class. Any polynomial-time probabilistic machine recognizes some language in <strong>PP</strong>. In contrast, given a description of a polynomial-time probabilistic machine, it is undecidable in general to determine if it recognizes a language in <strong>BPP</strong>.</p>

<p><strong>PP</strong> has natural complete problems, for example, <strong>MAJSAT</strong>. <strong>MAJSAT</strong> is a decision problem in which one is given a Boolean formula F. The answer must be YES if more than half of all assignments <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ..., <em>x</em><sub><em>n</em></sub> make F true and NO otherwise.</p>
<h3 id="proof-that-pp-is-closed-under-complement">Proof that PP is closed under complement</h3>

<p>Let <em>L</em> be a language in <strong>PP</strong>. Let 

<math display="inline" id="PP_(complexity):0">
 <semantics>
  <msup>
   <mi>L</mi>
   <mi>c</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>L</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{c}
  </annotation>
 </semantics>
</math>

 denote the complement of <em>L</em>. By the definition of <strong>PP</strong> there is a polynomial-time probabilistic algorithm <em>A</em> with the property that 

<math display="inline" id="PP_(complexity):1">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>L</mi>
   <mo>⇒</mo>
   <mrow>
    <mi>Pr</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mi>A</mi>
      </mpadded>
      <mpadded width="+1.7pt">
       <mi>accepts</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <ci>x</ci>
     <ci>L</ci>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>Pr</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>accepts</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <gt></gt>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in L\Rightarrow\mathrm{Pr}[A\,\mathrm{accepts}\,x]>1/2
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="PP_(complexity):2">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∉</mo>
   <mi>L</mi>
   <mo>⇒</mo>
   <mrow>
    <mi>Pr</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mi>A</mi>
      </mpadded>
      <mpadded width="+1.7pt">
       <mi>accepts</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <notin></notin>
     <ci>x</ci>
     <ci>L</ci>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>Pr</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>accepts</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\not\in L\Rightarrow\mathrm{Pr}[A\,\mathrm{accepts}\,x]\leq 1/2
  </annotation>
 </semantics>
</math>

. We claim that <a href="without_loss_of_generality" title="wikilink">without loss of generality</a>, the latter inequality is always strict; once we do this the theorem can be proved as follows. Let 

<math display="inline" id="PP_(complexity):3">
 <semantics>
  <msup>
   <mi>A</mi>
   <mi>c</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>A</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{c}
  </annotation>
 </semantics>
</math>


 denote the machine which is the same as <em>A</em> except that 

<math display="inline" id="PP_(complexity):4">
 <semantics>
  <msup>
   <mi>A</mi>
   <mi>c</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>A</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A^{c}
  </annotation>
 </semantics>
</math>

 accepts when <em>A</em> would reject, and vice versa. Then 

<math display="inline" id="PP_(complexity):5">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <msup>
    <mi>L</mi>
    <mi>c</mi>
   </msup>
   <mo>⇒</mo>
   <mrow>
    <mi>Pr</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <msup>
        <mi>A</mi>
        <mi>c</mi>
       </msup>
      </mpadded>
      <mpadded width="+1.7pt">
       <mi>accepts</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>Pr</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>A</ci>
         <ci>c</ci>
        </apply>
        <ci>accepts</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <gt></gt>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in L^{c}\Rightarrow\mathrm{Pr}[A^{c}\,\mathrm{accepts}\,x]>1/2
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="PP_(complexity):6">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∉</mo>
   <msup>
    <mi>L</mi>
    <mi>c</mi>
   </msup>
   <mo>⇒</mo>
   <mrow>
    <mi>Pr</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <msup>
        <mi>A</mi>
        <mi>c</mi>
       </msup>
      </mpadded>
      <mpadded width="+1.7pt">
       <mi>accepts</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <notin></notin>
     <ci>x</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>L</ci>
      <ci>c</ci>
     </apply>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>Pr</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>A</ci>
         <ci>c</ci>
        </apply>
        <ci>accepts</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\not\in L^{c}\Rightarrow\mathrm{Pr}[A^{c}\,\mathrm{accepts}\,x]<1/2
  </annotation>
 </semantics>
</math>

, which implies that 

<math display="inline" id="PP_(complexity):7">
 <semantics>
  <msup>
   <mi>L</mi>
   <mi>c</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>L</ci>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L^{c}
  </annotation>
 </semantics>
</math>

 is in <strong>PP</strong>.</p>

<p>Now we justify our without loss of generality assumption. Let 

<math display="inline" id="PP_(complexity):8">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>x</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <apply>
     <abs></abs>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(|x|)
  </annotation>
 </semantics>
</math>


 be the polynomial upper bound on the running time of <em>A</em> on input <em>x</em>. Thus <em>A</em> makes at most 

<math display="inline" id="PP_(complexity):9">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mrow>
     <mo stretchy="false">|</mo>
     <mi>x</mi>
     <mo stretchy="false">|</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <apply>
     <abs></abs>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(|x|)
  </annotation>
 </semantics>
</math>

 random coin flips during its execution. In particular, 

<math display="inline" id="PP_(complexity):10">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>L</mi>
   <mo>⇒</mo>
   <mrow>
    <mi>Pr</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <mi>A</mi>
      </mpadded>
      <mpadded width="+1.7pt">
       <mi>accepts</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <msup>
      <mn>2</mn>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mo stretchy="false">|</mo>
         <mi>x</mi>
         <mo stretchy="false">|</mo>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </msup>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <ci>x</ci>
     <ci>L</ci>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>Pr</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <ci>A</ci>
        <ci>accepts</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <cn type="integer">2</cn>
        <apply>
         <times></times>
         <ci>f</ci>
         <apply>
          <abs></abs>
          <ci>x</ci>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in L\Rightarrow\mathrm{Pr}[A\,\mathrm{accepts}\,x]\geq 1/2+1/2^{f(|x|)}
  </annotation>
 </semantics>
</math>

 since the probability of acceptance is an integer multiple of 

<math display="inline" id="PP_(complexity):11">
 <semantics>
  <mrow>
   <mn>1</mn>
   <mo>/</mo>
   <msup>
    <mn>2</mn>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mo stretchy="false">|</mo>
       <mi>x</mi>
       <mo stretchy="false">|</mo>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <cn type="integer">1</cn>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <abs></abs>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1/2^{f(|x|)}
  </annotation>
 </semantics>
</math>

. Define a machine ''A' '' as follows: on input <em>x</em>, ''A' '' runs <em>A</em> as a subroutine, and rejects if <em>A</em> would reject; otherwise, if <em>A</em> would accept, ''A' '' flips 

<math display="inline" id="PP_(complexity):12">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mo stretchy="false">|</mo>
      <mi>x</mi>
      <mo stretchy="false">|</mo>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>+</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <plus></plus>
    <apply>
     <times></times>
     <ci>f</ci>
     <apply>
      <abs></abs>
      <ci>x</ci>
     </apply>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(|x|)+1
  </annotation>
 </semantics>
</math>

 coins and rejects if they are all heads, and accepts otherwise. Then 

<math display="inline" id="PP_(complexity):13">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∉</mo>
   <mi>L</mi>
   <mo>⇒</mo>
   <mrow>
    <mi>Pr</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <msup>
        <mi>A</mi>
        <mo>′</mo>
       </msup>
      </mpadded>
      <mpadded width="+1.7pt">
       <mi>accepts</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mrow>
     <mn>1</mn>
     <mo>/</mo>
     <mn>2</mn>
    </mrow>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <msup>
        <mn>2</mn>
        <mrow>
         <mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mo stretchy="false">|</mo>
            <mi>x</mi>
            <mo stretchy="false">|</mo>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msup>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo><</mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <notin></notin>
     <ci>x</ci>
     <ci>L</ci>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>Pr</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>A</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>accepts</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <leq></leq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">2</cn>
         <apply>
          <plus></plus>
          <apply>
           <times></times>
           <ci>f</ci>
           <apply>
            <abs></abs>
            <ci>x</ci>
           </apply>
          </apply>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <lt></lt>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\not\in L\Rightarrow\mathrm{Pr}[A^{\prime}\,\mathrm{accepts}\,x]\leq 1/2\cdot%
(1-1/2^{f(|x|)+1})<1/2
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="PP_(complexity):14">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>∈</mo>
   <mi>L</mi>
   <mo>⇒</mo>
   <mrow>
    <mi>Pr</mi>
    <mrow>
     <mo stretchy="false">[</mo>
     <mrow>
      <mpadded width="+1.7pt">
       <msup>
        <mi>A</mi>
        <mo>′</mo>
       </msup>
      </mpadded>
      <mpadded width="+1.7pt">
       <mi>accepts</mi>
      </mpadded>
      <mi>x</mi>
     </mrow>
     <mo stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>≥</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <mn>2</mn>
      </mrow>
      <mo>+</mo>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <msup>
        <mn>2</mn>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mo stretchy="false">|</mo>
           <mi>x</mi>
           <mo stretchy="false">|</mo>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
        </mrow>
       </msup>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>⋅</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mn>1</mn>
      <mo>-</mo>
      <mrow>
       <mn>1</mn>
       <mo>/</mo>
       <msup>
        <mn>2</mn>
        <mrow>
         <mrow>
          <mi>f</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mrow>
            <mo stretchy="false">|</mo>
            <mi>x</mi>
            <mo stretchy="false">|</mo>
           </mrow>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mo>+</mo>
         <mn>1</mn>
        </mrow>
       </msup>
      </mrow>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>></mo>
   <mrow>
    <mn>1</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <in></in>
     <ci>x</ci>
     <ci>L</ci>
    </apply>
    <apply>
     <ci>normal-⇒</ci>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>Pr</ci>
      <apply>
       <csymbol cd="latexml">delimited-[]</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>A</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>accepts</ci>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <geq></geq>
     <share href="#.cmml">
     </share>
     <apply>
      <ci>normal-⋅</ci>
      <apply>
       <plus></plus>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">2</cn>
         <apply>
          <times></times>
          <ci>f</ci>
          <apply>
           <abs></abs>
           <ci>x</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <cn type="integer">2</cn>
         <apply>
          <plus></plus>
          <apply>
           <times></times>
           <ci>f</ci>
           <apply>
            <abs></abs>
            <ci>x</ci>
           </apply>
          </apply>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <gt></gt>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\in L\Rightarrow\mathrm{Pr}[A^{\prime}\,\mathrm{accepts}\,x]\geq(1/2+1/2^{f(|%
x|)})\cdot(1-1/2^{f(|x|)+1})>1/2
  </annotation>
 </semantics>
</math>

. This justifies the assumption (since ''A' '' is still a polynomial-time probabilistic algorithm) and completes the proof.</p>

<p>David Russo proved in his 1985 Ph.D. thesis<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> that <strong>PP</strong> is closed under <a href="symmetric_difference" title="wikilink">symmetric difference</a>. It was an <a href="open_problem" title="wikilink">open problem</a> for 14 years whether <strong>PP</strong> was closed under <a href="union_(set_theory)" title="wikilink">union</a> and <a href="Intersection_(set_theory)" title="wikilink">intersection</a>; this was settled in the affirmative by Beigel, Reingold, and Spielman.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> Alternate proofs were later given by Li<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> and Aaronson (see <a class="uri" href="#PostBQP" title="wikilink">#PostBQP</a> below).</p>
<h2 id="other-equivalent-complexity-classes">Other equivalent complexity classes</h2>
<h3 id="postbqp">PostBQP</h3>

<p>The quantum complexity class <strong><a class="uri" href="BQP" title="wikilink">BQP</a></strong> is the class of problems solvable in <a href="polynomial_time" title="wikilink">polynomial time</a> on a <a href="quantum_Turing_machine" title="wikilink">quantum Turing machine</a>. By adding <a class="uri" href="postselection" title="wikilink">postselection</a>, a larger class called <strong><a class="uri" href="PostBQP" title="wikilink">PostBQP</a></strong> is obtained. Informally, postselection gives the computer the following power: whenever some event (such as measuring a qubit in a certain state) has nonzero probability, you are allowed to assume that it takes place.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> <a href="Scott_Aaronson" title="wikilink">Scott Aaronson</a> showed in 2004 that <strong>PostBQP</strong> is equal to <strong>PP</strong>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> This reformulation of <strong>PP</strong> makes it easier to show certain results, such as that <strong>PP</strong> is closed under intersection (and hence, under union), that <strong>BQP</strong> is <a href="low_(complexity)" title="wikilink">low</a> for <strong>PP</strong>, and that <strong><a class="uri" href="QMA" title="wikilink">QMA</a></strong> is contained in <strong>PP</strong>.</p>
<h3 id="pqp">PQP</h3>

<p><strong>PP</strong> is also equal to another quantum complexity class known as <strong>PQP</strong>, which is the unbounded error analog of <strong>BQP</strong>. It denotes the class of decision problems solvable by a quantum computer in polynomial time, with an error probability of less than 1/2 for all instances.</p>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
<li>

<p>.</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Probabilistic_complexity_classes" title="wikilink">Category:Probabilistic complexity classes</a> <a href="Category:Quantum_complexity_theory" title="wikilink">Category:Quantum complexity theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1">J. Gill, "Computational complexity of probabilistic Turing machines." <em>SIAM Journal on Computing</em>, 6 (4), pp. 675–695, 1977.<a href="#fnref1">↩</a></li>
<li id="fn2">Lance Fortnow. Computational Complexity: Wednesday, September 4, 2002: Complexity Class of the Week: PP. <a class="uri" href="http://weblog.fortnow.com/2002/09/complexity-class-of-week-pp.html">http://weblog.fortnow.com/2002/09/complexity-class-of-week-pp.html</a><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="http://lpcs.math.msu.su/~ver/papers/am-pp.ps">N.K. Vereshchagin, "On the Power of PP"</a><a href="#fnref3">↩</a></li>
<li id="fn4">. Preprint available at <a href="http://arxiv.org/abs/quant-ph/0412187">1</a><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6">R. Beigel, N. Reingold, and D. A. Spielman, "<a href="http://citeseer.ist.psu.edu/152946.html">PP is closed under intersection</a>", <em>Proceedings of ACM Symposium on Theory of Computing 1991</em>, pp. 1–9, 1991.<a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
</ol>
</section>
</body>
</html>
