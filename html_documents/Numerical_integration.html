<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="621">Numerical integration</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Numerical integration</h1>
<style>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
<style>
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</body></html>
<body>
<hr/>

<p> In <a href="numerical_analysis" title="wikilink">numerical analysis</a>, <strong>numerical integration</strong> constitutes a broad family of <a href="algorithm" title="wikilink">algorithms</a> for calculating the numerical value of a definite <a class="uri" href="integral" title="wikilink">integral</a>, and by extension, the term is also sometimes used to describe the <a href="numerical_ordinary_differential_equations" title="wikilink">numerical solution of differential equations</a>. This article focuses on calculation of definite integrals. The term <strong>numerical quadrature</strong> (often abbreviated to <a href="Quadrature_(mathematics)" title="wikilink"><em>quadrature</em></a>) is more or less a synonym for <em>numerical integration</em>, especially as applied to one-dimensional integrals. Numerical integration over more than one dimension is sometimes incorrectly described as <strong>cubature</strong>,<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> since the meaning of <em>quadrature</em> is understood for higher-dimensional integration as well.</p>

<p>The basic problem in numerical integration is to compute an approximate solution to a definite integral</p>

<p>

<math display="block" id="Numerical_integration:0">
 <semantics>
  <mrow>
   <mpadded width="-1.7pt">
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mi>a</mi>
     <mi>b</mi>
    </msubsup>
   </mpadded>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo rspace="4.2pt" stretchy="false">)</mo>
    </mrow>
    <mi>d</mi>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <int></int>
      <ci>a</ci>
     </apply>
     <ci>b</ci>
    </apply>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
     <ci>d</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{a}^{b}\!f(x)\,dx
  </annotation>
 </semantics>
</math>

</p>

<p>to a given degree of accuracy. If 

<math display="inline" id="Numerical_integration:1">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)
  </annotation>
 </semantics>
</math>

 is a smooth function integrated over a small number of dimensions, and the domain of integration is bounded, there are many methods for approximating the integral to the desired precision.</p>
<h2 id="history">History</h2>

<p><strong>Quadrature</strong> is a historical mathematical term that means calculating area. Quadrature problems have served as one of the main sources of <a href="mathematical_analysis" title="wikilink">mathematical analysis</a>. <a href="Greek_mathematics" title="wikilink">Mathematicians of Ancient Greece</a>, according to the <a href="Pythagoreanism" title="wikilink">Pythagorean</a> doctrine, understood calculation of <a class="uri" href="area" title="wikilink">area</a> as the process of constructing geometrically a <a href="square_(geometry)" title="wikilink">square</a> having the same area (<em>squaring</em>). That is why the process was named <strong>quadrature</strong>. For example, a <a href="quadrature_of_the_circle" title="wikilink">quadrature of the circle</a>, <a href="Lune_of_Hippocrates" title="wikilink">Lune of Hippocrates</a>, <a href="The_Quadrature_of_the_Parabola" title="wikilink">The Quadrature of the Parabola</a>. This construction must be performed only by means of <a href="Compass_and_straightedge_constructions" title="wikilink">compass and straightedge</a>.</p>

<p> For a quadrature of a rectangle with the sides <em>a</em> and <em>b</em> it is necessary to construct a square with the side 

<math display="inline" id="Numerical_integration:2">
 <semantics>
  <mrow>
   <mi>x</mi>
   <mo>=</mo>
   <msqrt>
    <mrow>
     <mi>a</mi>
     <mi>b</mi>
    </mrow>
   </msqrt>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>x</ci>
    <apply>
     <root></root>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x=\sqrt{ab}
  </annotation>
 </semantics>
</math>

 (the <a href="Geometric_mean" title="wikilink">Geometric mean</a> of <em>a</em> and <em>b</em>). For this purpose it is possible to use the following fact: if we draw the circle with the sum of <em>a</em> and <em>b</em> as the diameter, then the height BH (from a point of their connection to crossing with a circle) equals their geometric mean. The similar geometrical construction solves a problem of a quadrature for a parallelogram and a triangle.</p>

<p>[[<a class="uri" href="File:Parabola">File:Parabola</a> and inscribed triangle.svg|thumb|200px|</p>
<center>

<p>The area of a segment of a parabola</p>
</center>

<p>]] Problems of quadrature for curvilinear figures are much more difficult. The <a href="quadrature_of_the_circle" title="wikilink">quadrature of the circle</a> with compass and straightedge had been proved in the 19th century to be impossible. Nevertheless, for some figures (for example <a href="Lune_of_Hippocrates" title="wikilink">Lune of Hippocrates</a>) a quadrature can be performed. The quadratures of a sphere surface and a <a href="The_Quadrature_of_the_Parabola" title="wikilink">parabola segment</a> done by <a class="uri" href="Archimedes" title="wikilink">Archimedes</a> became the highest achievement of the antique analysis.</p>
<ul>
<li>The area of the surface of a sphere is equal to quadruple the area of a <a href="great_circle" title="wikilink">great circle</a> of this sphere.</li>
<li>The area of a segment of the <a class="uri" href="parabola" title="wikilink">parabola</a> cut from it by a straight line is 4/3 the area of the triangle inscribed in this segment.</li>
</ul>

<p>For the proof of the results Archimedes used the <a href="Method_of_exhaustion" title="wikilink">Method of exhaustion</a> of <a href="Eudoxus_of_Cnidus" title="wikilink">Eudoxus</a>.</p>

<p>In medieval Europe the quadrature meant calculation of area by any method. More often the <a href="Method_of_indivisibles" title="wikilink">Method of indivisibles</a> was used; it was less rigorous, but more simple and powerful. With its help <a href="Galileo_Galilei" title="wikilink">Galileo Galilei</a> and <a href="Gilles_de_Roberval" title="wikilink">Gilles de Roberval</a> found the area of a <a class="uri" href="cycloid" title="wikilink">cycloid</a> arch, <a href="Grégoire_de_Saint-Vincent" title="wikilink">Grégoire de Saint-Vincent</a> investigated the area under a <a class="uri" href="hyperbola" title="wikilink">hyperbola</a> (<em>Opus Geometricum</em>, 1647), and <a href="Alphonse_Antonio_de_Sarasa" title="wikilink">Alphonse Antonio de Sarasa</a>, de Saint-Vincent's pupil and commentator noted the relation of this area to <a href="logarithm" title="wikilink">logarithms</a>.</p>

<p><a href="John_Wallis" title="wikilink">John Wallis</a> algebrised this method: he wrote in his <em>Arithmetica Infinitorum</em> (1656) series that we now call the <a href="definite_integral" title="wikilink">definite integral</a>, and he calculated their values. <a href="Isaac_Barrow" title="wikilink">Isaac Barrow</a> and <a href="James_Gregory_(mathematician)" title="wikilink">James Gregory</a> made further progress: quadratures for some <a href="algebraic_curves" title="wikilink">algebraic curves</a> and <a href="spiral" title="wikilink">spirals</a>. <a href="Christiaan_Huygens" title="wikilink">Christiaan Huygens</a> successfully performed a quadrature of some <a href="Solid_of_revolution" title="wikilink">Solids of revolution</a>.</p>

<p>The quadrature of the hyperbola by Saint-Vincent and de Sarasa provided a new <a href="function(mathematics)" title="wikilink">function</a>, the <a href="natural_logarithm" title="wikilink">natural logarithm</a>, of critical importance.</p>

<p>With the invention of <a href="integral_calculus" title="wikilink">integral calculus</a> came a universal method for area calculation. In response, the term <strong>quadrature</strong> has become traditional, and instead the modern phrase "<em>computation of a univariate definite integral</em>" is more common.</p>
<h2 id="reasons-for-numerical-integration">Reasons for numerical integration</h2>

<p>There are several reasons for carrying out numerical integration. The integrand <em>f</em>(<em>x</em>)'' may be known only at certain points, such as obtained by <a href="sampling_(statistics)" title="wikilink">sampling</a>. Some <a href="embedded_systems" title="wikilink">embedded systems</a> and other computer applications may need numerical integration for this reason.</p>

<p>A formula for the integrand may be known, but it may be difficult or impossible to find an <a class="uri" href="antiderivative" title="wikilink">antiderivative</a> that is an <a href="elementary_function" title="wikilink">elementary function</a>. An example of such an integrand is <em>f</em>(<em>x</em>) = exp(−<em>x</em><sup><em>2</em></sup>), the antiderivative of which (the <a href="error_function" title="wikilink">error function</a>, times a constant) cannot be written in <a href="elementary_form" title="wikilink">elementary form</a>.</p>

<p>It may be possible to find an antiderivative symbolically, but it may be easier to compute a numerical approximation than to compute the antiderivative. That may be the case if the antiderivative is given as an infinite series or product, or if its evaluation requires a <a href="special_function" title="wikilink">special function</a> that is not available.</p>
<h2 id="methods-for-one-dimensional-integrals">Methods for one-dimensional integrals</h2>

<p>Numerical integration methods can generally be described as combining evaluations of the integrand to get an approximation to the integral. The integrand is evaluated at a finite set of points called <strong>integration points</strong> and a weighted sum of these values is used to approximate the integral. The integration points and weights depend on the specific method used and the accuracy required from the approximation.</p>

<p>An important part of the analysis of any numerical integration method is to study the behavior of the approximation error as a function of the number of integrand evaluations. A method that yields a small error for a small number of evaluations is usually considered superior. Reducing the number of evaluations of the integrand reduces the number of arithmetic operations involved, and therefore reduces the total <a href="round-off_error" title="wikilink">round-off error</a>. Also, each evaluation takes time, and the integrand may be arbitrarily complicated.</p>

<p>A 'brute force' kind of numerical integration can be done, if the integrand is reasonably well-behaved (i.e. <a class="uri" href="piecewise" title="wikilink">piecewise</a> <a href="continuous_function" title="wikilink">continuous</a> and of <a href="bounded_variation" title="wikilink">bounded variation</a>), by evaluating the integrand with very small increments.</p>
<h3 id="quadrature-rules-based-on-interpolating-functions">Quadrature rules based on interpolating functions</h3>

<p>A large class of quadrature rules can be derived by constructing <a href="interpolation" title="wikilink">interpolating</a> functions that are easy to integrate. Typically these interpolating functions are <a href="polynomial" title="wikilink">polynomials</a>. In practice, since polynomials of very high degree tend to oscillate wildly, only polynomials of low degree are used, typically linear and quadratic.</p>

<p> The simplest method of this type is to let the interpolating function be a constant function (a polynomial of degree zero) that passes through the point ((<em>a</em>+<em>b</em>)/2, <em>f</em>((<em>a</em>+<em>b</em>)/2)). This is called the <em>midpoint rule</em> or <em><a href="rectangle_method" title="wikilink">rectangle rule</a></em>.</p>

<p>

<math display="block" id="Numerical_integration:3">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi>a</mi>
      <mi>b</mi>
     </msubsup>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>≈</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>b</mi>
       <mo>-</mo>
       <mi>a</mi>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>f</mi>
     <mrow>
      <mo>(</mo>
      <mfrac>
       <mrow>
        <mi>a</mi>
        <mo>+</mo>
        <mi>b</mi>
       </mrow>
       <mn>2</mn>
      </mfrac>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>a</ci>
      </apply>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>b</ci>
      <ci>a</ci>
     </apply>
     <ci>f</ci>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <ci>a</ci>
       <ci>b</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{a}^{b}f(x)\,dx\approx(b-a)\,f\left(\frac{a+b}{2}\right).
  </annotation>
 </semantics>
</math>

</p>

<p> The interpolating function may be a straight line (an <a href="affine_function" title="wikilink">affine function</a>, i.e. a polynomial of degree 1) passing through the points (<em>a</em>, <em>f</em>(<em>a</em>)) and (<em>b</em>, <em>f</em>(<em>b</em>)). This is called the <em><a href="trapezoidal_rule" title="wikilink">trapezoidal rule</a></em>.</p>

<p>

<math display="block" id="Numerical_integration:4">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi>a</mi>
      <mi>b</mi>
     </msubsup>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>≈</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>b</mi>
       <mo>-</mo>
       <mi>a</mi>
      </mrow>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mfrac>
      <mrow>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>a</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>b</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
      <mn>2</mn>
     </mfrac>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>a</ci>
      </apply>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <minus></minus>
      <ci>b</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <divide></divide>
      <apply>
       <plus></plus>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>a</ci>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>b</ci>
       </apply>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{a}^{b}f(x)\,dx\approx(b-a)\,\frac{f(a)+f(b)}{2}.
  </annotation>
 </semantics>
</math>

</p>

<p> For either one of these rules, we can make a more accurate approximation by breaking up the interval [<em>a</em>, <em>b</em>] into some number <em>n</em> of subintervals, computing an approximation for each subinterval, then adding up all the results. This is called a <em>composite rule</em>, <em>extended rule</em>, or <em>iterated rule</em>. For example, the composite trapezoidal rule can be stated as</p>

<p>

<math display="block" id="Numerical_integration:5">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mi>a</mi>
     <mi>b</mi>
    </msubsup>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mfrac>
     <mrow>
      <mi>b</mi>
      <mo>-</mo>
      <mi>a</mi>
     </mrow>
     <mi>n</mi>
    </mfrac>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mfrac>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>a</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mn>2</mn>
      </mfrac>
      <mo>+</mo>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>k</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mrow>
         <mi>n</mi>
         <mo>-</mo>
         <mn>1</mn>
        </mrow>
       </munderover>
       <mrow>
        <mo>(</mo>
        <mrow>
         <mi>f</mi>
         <mrow>
          <mo>(</mo>
          <mrow>
           <mi>a</mi>
           <mo>+</mo>
           <mrow>
            <mi>k</mi>
            <mfrac>
             <mrow>
              <mi>b</mi>
              <mo>-</mo>
              <mi>a</mi>
             </mrow>
             <mi>n</mi>
            </mfrac>
           </mrow>
          </mrow>
          <mo>)</mo>
         </mrow>
        </mrow>
        <mo>)</mo>
       </mrow>
      </mrow>
      <mo>+</mo>
      <mfrac>
       <mrow>
        <mi>f</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>b</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mn>2</mn>
      </mfrac>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>a</ci>
      </apply>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <minus></minus>
       <ci>b</ci>
       <ci>a</ci>
      </apply>
      <ci>n</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>a</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>k</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <apply>
         <minus></minus>
         <ci>n</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <apply>
         <plus></plus>
         <ci>a</ci>
         <apply>
          <times></times>
          <ci>k</ci>
          <apply>
           <divide></divide>
           <apply>
            <minus></minus>
            <ci>b</ci>
            <ci>a</ci>
           </apply>
           <ci>n</ci>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>b</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{a}^{b}f(x)\,dx\approx\frac{b-a}{n}\left({f(a)\over 2}+\sum_{k=1}^{n-1}%
\left(f\left(a+k\frac{b-a}{n}\right)\right)+{f(b)\over 2}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>where the subintervals have the form [<em>k</em> <em>h</em>, (<em>k</em>+1) <em>h</em>], with <em>h</em> = (<em>b</em>−<em>a</em>)/<em>n</em> and <em>k</em> = 0, 1, 2, ..., <em>n</em>−1.</p>

<p>Interpolation with polynomials evaluated at equally spaced points in [<em>a</em>, <em>b</em>] yields the <a href="Newton–Cotes_formulas" title="wikilink">Newton–Cotes formulas</a>, of which the rectangle rule and the trapezoidal rule are examples. <a href="Simpson's_rule" title="wikilink">Simpson's rule</a>, which is based on a polynomial of order 2, is also a Newton–Cotes formula.</p>

<p>Quadrature rules with equally spaced points have the very convenient property of <em>nesting</em>. The corresponding rule with each interval subdivided includes all the current points, so those integrand values can be re-used.</p>

<p>If we allow the intervals between interpolation points to vary, we find another group of quadrature formulas, such as the <a href="Gaussian_quadrature" title="wikilink">Gaussian quadrature</a> formulas. A Gaussian quadrature rule is typically more accurate than a Newton–Cotes rule, which requires the same number of function evaluations, if the integrand is <a href="Smooth_function" title="wikilink">smooth</a> (i.e., if it is sufficiently differentiable). Other quadrature methods with varying intervals include <a href="Clenshaw–Curtis_quadrature" title="wikilink">Clenshaw–Curtis quadrature</a> (also called Fejér quadrature) methods, which do nest.</p>

<p>Gaussian quadrature rules do not nest, but the related <a href="Gauss–Kronrod_quadrature_formula" title="wikilink">Gauss–Kronrod quadrature formulas</a> do.</p>
<h3 id="adaptive-algorithms">Adaptive algorithms</h3>

<p>If <em>f</em>(<em>x</em>) does not have many derivatives at all points, or if the derivatives become large, then Gaussian quadrature is often insufficient. In this case, an algorithm similar to the following will perform better:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> calculate_definite_integral_of_f(f, initial_step_size):
    <span class="co">'''</span>
<span class="co">    This algorithm calculates the definite integral of a function</span>
<span class="co">    from 0 to 1, adaptively, by choosing smaller steps near</span>
<span class="co">    problematic points.</span>
<span class="co">    '''</span>
    x <span class="op">=</span> <span class="fl">0.0</span>
    h <span class="op">=</span> initial_step_size
    accumulator <span class="op">=</span> <span class="fl">0.0</span>
    <span class="cf">while</span> x <span class="op">&lt;</span> <span class="fl">1.0</span>:
        <span class="cf">if</span> x <span class="op">+</span> h <span class="op">&gt;</span> <span class="fl">1.0</span>:
            h <span class="op">=</span> <span class="fl">1.0</span> <span class="op">-</span> x
        quad_this_step <span class="op">=</span>
        <span class="cf">if</span> error_too_big_in_quadrature_of_over_range(f, [x,x<span class="op">+</span>h]):
            h <span class="op">=</span> make_h_smaller(h)
        <span class="cf">else</span>:
            accumulator <span class="op">+=</span> quadrature_of_f_over_range(f, [x,x<span class="op">+</span>h])
            x <span class="op">+=</span> h
            <span class="cf">if</span> error_too_small_in_quadrature_of_over_range(f, [x,x<span class="op">+</span>h]):
                h <span class="op">=</span> make_h_larger(h) <span class="co"># Avoid wasting time on tiny steps.</span>
    <span class="cf">return</span> accumulator</code></pre></div>

<p>Some details of the algorithm require careful thought. For many cases, estimating the error from quadrature over an interval for a function <em>f</em>(<em>x</em>) isn't obvious. One popular solution is to use two different rules of quadrature, and use their difference as an estimate of the error from quadrature. The other problem is deciding what "too large" or "very small" signify. A <em>local</em> criterion for "too large" is that the quadrature error should not be larger than <em>t</em> · <em>h</em> where <em>t</em>, a real number, is the tolerance we wish to set for global error. Then again, if <em>h</em> is already tiny, it may not be worthwhile to make it even smaller even if the quadrature error is apparently large. A <em>global</em> criterion is that the sum of errors on all the intervals should be less than <em>t</em>. This type of error analysis is usually called "a posteriori" since we compute the error after having computed the approximation.</p>

<p>Heuristics for adaptive quadrature are discussed by Forsythe et al. (Section 5.4).</p>
<h3 id="extrapolation-methods">Extrapolation methods</h3>

<p>The accuracy of a quadrature rule of the Newton-Cotes type is generally a function of the number of evaluation points. The result is usually more accurate as the number of evaluation points increases, or, equivalently, as the width of the step size between the points decreases. It is natural to ask what the result would be if the step size were allowed to approach zero. This can be answered by extrapolating the result from two or more nonzero step sizes, using <a href="series_acceleration" title="wikilink">series acceleration</a> methods such as <a href="Richardson_extrapolation" title="wikilink">Richardson extrapolation</a>. The extrapolation function may be a <a class="uri" href="polynomial" title="wikilink">polynomial</a> or <a href="rational_function" title="wikilink">rational function</a>. Extrapolation methods are described in more detail by Stoer and Bulirsch (Section 3.4) and are implemented in many of the routines in the <a class="uri" href="QUADPACK" title="wikilink">QUADPACK</a> library.</p>
<h3 id="conservative-a-priori-error-estimation">Conservative (a priori) error estimation</h3>

<p>Let <em>f</em> have a bounded first derivative over [<em>a</em>,<em>b</em>]. The <a href="mean_value_theorem" title="wikilink">mean value theorem</a> for <em>f</em>, where <em>x</em> (x - a) f'(v_x) = f(x) - f(a)\,</p>

<p>for some <em>v<sub>x</sub></em> in [<em>a</em>,<em>x</em>] depending on <em>x</em>. If we integrate in <em>x</em> from <em>a</em> to <em>b</em> on both sides and take the absolute values, we obtain</p>

<p>

<math display="block" id="Numerical_integration:6">
 <semantics>
  <mrow>
   <mrow>
    <mo>|</mo>
    <mrow>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <mi>a</mi>
       <mi>b</mi>
      </msubsup>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
       <mi>d</mi>
       <mi>x</mi>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>b</mi>
        <mo>-</mo>
        <mi>a</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>|</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo>|</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mi>a</mi>
      <mi>b</mi>
     </msubsup>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>x</mi>
        <mo>-</mo>
        <mi>a</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <msup>
       <mi>f</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <msub>
        <mi>v</mi>
        <mi>x</mi>
       </msub>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>|</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <int></int>
         <ci>a</ci>
        </apply>
        <ci>b</ci>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>x</ci>
        <ci>d</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <ci>b</ci>
        <ci>a</ci>
       </apply>
       <ci>f</ci>
       <ci>a</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <abs></abs>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <int></int>
        <ci>a</ci>
       </apply>
       <ci>b</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <ci>x</ci>
        <ci>a</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>v</ci>
        <ci>x</ci>
       </apply>
       <ci>d</ci>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left|\int_{a}^{b}f(x)\,dx-(b-a)f(a)\right|=\left|\int_{a}^{b}(x-a)f^{\prime}(%
v_{x})\,dx\right|
  </annotation>
 </semantics>
</math>

</p>

<p>We can further approximate the integral on the right-hand side by bringing the absolute value into the integrand, and replacing the term in ''f' '' by an upper bound:</p>

<p>

<math display="block" id="Numerical_integration:7">
 <semantics>
  <mrow>
   <mrow>
    <mo>|</mo>
    <mrow>
     <mrow>
      <msubsup>
       <mo largeop="true" symmetric="true">∫</mo>
       <mi>a</mi>
       <mi>b</mi>
      </msubsup>
      <mrow>
       <mi>f</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo rspace="4.2pt" stretchy="false">)</mo>
       </mrow>
       <mi>d</mi>
       <mi>x</mi>
      </mrow>
     </mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>b</mi>
        <mo>-</mo>
        <mi>a</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>a</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>|</mo>
   </mrow>
   <mo>≤</mo>
   <mrow>
    <mfrac>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mi>b</mi>
        <mo>-</mo>
        <mi>a</mi>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mn>2</mn>
     </msup>
     <mn>2</mn>
    </mfrac>
    <mrow>
     <munder>
      <mo movablelimits="false">sup</mo>
      <mrow>
       <mi>a</mi>
       <mo>≤</mo>
       <mi>x</mi>
       <mo>≤</mo>
       <mi>b</mi>
      </mrow>
     </munder>
     <mrow>
      <mo>|</mo>
      <mrow>
       <msup>
        <mi>f</mi>
        <mo>′</mo>
       </msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>|</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <leq></leq>
    <apply>
     <abs></abs>
     <apply>
      <minus></minus>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <int></int>
         <ci>a</ci>
        </apply>
        <ci>b</ci>
       </apply>
       <apply>
        <times></times>
        <ci>f</ci>
        <ci>x</ci>
        <ci>d</ci>
        <ci>x</ci>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <minus></minus>
        <ci>b</ci>
        <ci>a</ci>
       </apply>
       <ci>f</ci>
       <ci>a</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <ci>b</ci>
        <ci>a</ci>
       </apply>
       <cn type="integer">2</cn>
      </apply>
      <cn type="integer">2</cn>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <csymbol cd="latexml">supremum</csymbol>
       <apply>
        <and></and>
        <apply>
         <leq></leq>
         <ci>a</ci>
         <ci>x</ci>
        </apply>
        <apply>
         <leq></leq>
         <share href="#.cmml">
         </share>
         <ci>b</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <abs></abs>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>f</ci>
         <ci>normal-′</ci>
        </apply>
        <ci>x</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left|\int_{a}^{b}f(x)\,dx-(b-a)f(a)\right|\leq{(b-a)^{2}\over 2}\sup_{a\leq x%
\leq b}\left|f^{\prime}(x)\right|
  </annotation>
 </semantics>
</math>

 (**)</p>

<p>(See <a class="uri" href="supremum" title="wikilink">supremum</a>.) Hence, if we approximate the integral ∫<sub><em>a</em></sub><sup><em>b</em></sup> <em>f</em>(<em>x</em>) d<em>x</em> by the quadrature rule (<em>b</em> − <em>a</em>)<em>f</em>(<em>a</em>) our error is no greater than the right hand side of (**). We can convert this into an error analysis for the Riemann sum (*), giving an upper bound of</p>

<p>

<math display="block" id="Numerical_integration:8">
 <semantics>
  <mrow>
   <mfrac>
    <msup>
     <mi>n</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mn>2</mn>
   </mfrac>
   <mrow>
    <munder>
     <mo movablelimits="false">sup</mo>
     <mrow>
      <mn>0</mn>
      <mo>≤</mo>
      <mi>x</mi>
      <mo>≤</mo>
      <mn>1</mn>
     </mrow>
    </munder>
    <mrow>
     <mo>|</mo>
     <mrow>
      <msup>
       <mi>f</mi>
       <mo>′</mo>
      </msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>|</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <divide></divide>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>n</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <cn type="integer">2</cn>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <csymbol cd="latexml">supremum</csymbol>
      <apply>
       <and></and>
       <apply>
        <leq></leq>
        <cn type="integer">0</cn>
        <ci>x</ci>
       </apply>
       <apply>
        <leq></leq>
        <share href="#.cmml">
        </share>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
     <apply>
      <abs></abs>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>f</ci>
        <ci>normal-′</ci>
       </apply>
       <ci>x</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {n^{-1}\over 2}\sup_{0\leq x\leq 1}\left|f^{\prime}(x)\right|
  </annotation>
 </semantics>
</math>

</p>

<p>for the error term of that particular approximation. (Note that this is precisely the error we calculated for the example 

<math display="inline" id="Numerical_integration:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>x</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <ci>x</ci>
    </apply>
    <ci>x</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x)=x
  </annotation>
 </semantics>
</math>

.) Using more derivatives, and by tweaking the quadrature, we can do a similar error analysis using a <a href="Taylor_series" title="wikilink">Taylor series</a> (using a partial sum with remainder term) for <em>f</em>. This error analysis gives a strict upper bound on the error, if the derivatives of <em>f</em> are available.</p>

<p>This integration method can be combined with <a href="interval_arithmetic" title="wikilink">interval arithmetic</a> to produce <a href="computer_proof" title="wikilink">computer proofs</a> and <em>verified</em> calculations.</p>
<h3 id="integrals-over-infinite-intervals">Integrals over infinite intervals</h3>

<p>Several methods exist for approximate integration over unbounded intervals. The standard technique involves specially derived quadrature rules, such as <a href="Gauss-Hermite_quadrature" title="wikilink">Gauss-Hermite quadrature</a> for integrals on the whole real line and <a href="Gauss-Laguerre_quadrature" title="wikilink">Gauss-Laguerre quadrature</a> for integrals on the positive reals.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Monte Carlo methods can also be used, or a change of variables to a finite interval; e.g., for the whole line one could use</p>

<p>

<math display="block" id="Numerical_integration:10">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mo>-</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
      <mrow>
       <mo>+</mo>
       <mi mathvariant="normal">∞</mi>
      </mrow>
     </msubsup>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo rspace="4.2pt" stretchy="false">)</mo>
      </mrow>
      <mi>d</mi>
      <mi>x</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msubsup>
      <mo largeop="true" symmetric="true">∫</mo>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
      <mrow>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msubsup>
     <mrow>
      <mi>f</mi>
      <mrow>
       <mo>(</mo>
       <mfrac>
        <mi>t</mi>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <msup>
          <mi>t</mi>
          <mn>2</mn>
         </msup>
        </mrow>
       </mfrac>
       <mo>)</mo>
      </mrow>
      <mpadded width="+1.7pt">
       <mfrac>
        <mrow>
         <mn>1</mn>
         <mo>+</mo>
         <msup>
          <mi>t</mi>
          <mn>2</mn>
         </msup>
        </mrow>
        <msup>
         <mrow>
          <mo stretchy="false">(</mo>
          <mrow>
           <mn>1</mn>
           <mo>-</mo>
           <msup>
            <mi>t</mi>
            <mn>2</mn>
           </msup>
          </mrow>
          <mo stretchy="false">)</mo>
         </mrow>
         <mn>2</mn>
        </msup>
       </mfrac>
      </mpadded>
      <mi>d</mi>
      <mi>t</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <minus></minus>
        <infinity></infinity>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <divide></divide>
       <ci>t</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>t</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <plus></plus>
        <cn type="integer">1</cn>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>t</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <apply>
          <csymbol cd="ambiguous">superscript</csymbol>
          <ci>t</ci>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>d</ci>
      <ci>t</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{-\infty}^{+\infty}f(x)\,dx=\int_{-1}^{+1}f\left(\frac{t}{1-t^{2}}\right)%
\frac{1+t^{2}}{(1-t^{2})^{2}}\,dt,
  </annotation>
 </semantics>
</math>

</p>

<p>and for semi-infinite intervals one could use</p>

<p>

<math display="block" id="Numerical_integration:11">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mi>a</mi>
     <mrow>
      <mo>+</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
    </msubsup>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mn>0</mn>
     <mn>1</mn>
    </msubsup>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mi>a</mi>
       <mo>+</mo>
       <mfrac>
        <mi>t</mi>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mi>t</mi>
        </mrow>
       </mfrac>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mfrac>
      <mrow>
       <mi>d</mi>
       <mi>t</mi>
      </mrow>
      <msup>
       <mrow>
        <mo stretchy="false">(</mo>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mi>t</mi>
        </mrow>
        <mo stretchy="false">)</mo>
       </mrow>
       <mn>2</mn>
      </msup>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>a</ci>
      </apply>
      <apply>
       <plus></plus>
       <infinity></infinity>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <plus></plus>
       <ci>a</ci>
       <apply>
        <divide></divide>
        <ci>t</ci>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <ci>t</ci>
        </apply>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <ci>t</ci>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{a}^{+\infty}f(x)\,dx=\int_{0}^{1}f\left(a+\frac{t}{1-t}\right)\frac{dt}{%
(1-t)^{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Numerical_integration:12">
 <semantics>
  <mrow>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mrow>
      <mo>-</mo>
      <mi mathvariant="normal">∞</mi>
     </mrow>
     <mi>a</mi>
    </msubsup>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>x</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mn>0</mn>
     <mn>1</mn>
    </msubsup>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mi>a</mi>
       <mo>-</mo>
       <mfrac>
        <mrow>
         <mn>1</mn>
         <mo>-</mo>
         <mi>t</mi>
        </mrow>
        <mi>t</mi>
       </mfrac>
      </mrow>
      <mo>)</mo>
     </mrow>
     <mfrac>
      <mrow>
       <mi>d</mi>
       <mi>t</mi>
      </mrow>
      <msup>
       <mi>t</mi>
       <mn>2</mn>
      </msup>
     </mfrac>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <apply>
        <minus></minus>
        <infinity></infinity>
       </apply>
      </apply>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
      <ci>d</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <cn type="integer">0</cn>
      </apply>
      <cn type="integer">1</cn>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <apply>
       <minus></minus>
       <ci>a</ci>
       <apply>
        <divide></divide>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
         <ci>t</ci>
        </apply>
        <ci>t</ci>
       </apply>
      </apply>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>d</ci>
        <ci>t</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>t</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \int_{-\infty}^{a}f(x)\,dx=\int_{0}^{1}f\left(a-\frac{1-t}{t}\right)\frac{dt}{%
t^{2}}
  </annotation>
 </semantics>
</math>

</p>

<p>as possible transformations.</p>
<h2 id="multidimensional-integrals">Multidimensional integrals</h2>

<p>The quadrature rules discussed so far are all designed to compute one-dimensional integrals. To compute integrals in multiple dimensions, one approach is to phrase the multiple integral as repeated one-dimensional integrals by appealing to <a href="Fubini's_theorem" title="wikilink">Fubini's theorem</a>. This approach requires the function evaluations to <a href="exponential_growth" title="wikilink">grow exponentially</a> as the number of dimensions increases. Two methods are known to overcome this so-called <em><a href="curse_of_dimensionality" title="wikilink">curse of dimensionality</a></em>.</p>
<h3 id="monte-carlo">Monte Carlo</h3>

<p><a href="Monte_Carlo_method" title="wikilink">Monte Carlo methods</a> and <a href="quasi-Monte_Carlo_method" title="wikilink">quasi-Monte Carlo methods</a> are easy to apply to multi-dimensional integrals, and may yield greater accuracy for the same number of function evaluations than repeated integrations using one-dimensional methods.</p>

<p>A large class of useful Monte Carlo methods are the so-called <a href="Markov_chain_Monte_Carlo" title="wikilink">Markov chain Monte Carlo</a> algorithms, which include the <a href="Metropolis-Hastings_algorithm" title="wikilink">Metropolis-Hastings algorithm</a> and <a href="Gibbs_sampling" title="wikilink">Gibbs sampling</a>.</p>
<h3 id="sparse-grids">Sparse grids</h3>

<p><a href="Sparse_grid" title="wikilink">Sparse grids</a> were originally developed by Smolyak for the quadrature of high-dimensional functions. The method is always based on a one-dimensional quadrature rule, but performs a more sophisticated combination of univariate results.</p>
<h2 id="connection-with-differential-equations">Connection with differential equations</h2>

<p>The problem of evaluating the integral</p>

<p>

<math display="block" id="Numerical_integration:13">
 <semantics>
  <mrow>
   <mrow>
    <mi>F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msubsup>
     <mo largeop="true" symmetric="true">∫</mo>
     <mi>a</mi>
     <mi>x</mi>
    </msubsup>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>u</mi>
      <mo rspace="4.2pt" stretchy="false">)</mo>
     </mrow>
     <mi>d</mi>
     <mi>u</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>F</ci>
     <ci>x</ci>
    </apply>
    <apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <int></int>
       <ci>a</ci>
      </apply>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>u</ci>
      <ci>d</ci>
      <ci>u</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   F(x)=\int_{a}^{x}f(u)\,du
  </annotation>
 </semantics>
</math>

 can be reduced to an <a href="initial_value_problem" title="wikilink">initial value problem</a> for an <a href="ordinary_differential_equation" title="wikilink">ordinary differential equation</a>. By differentiating both sides of the above with respect to the argument <em>x</em>, it is seen that the function <em>F</em> satisfies</p>

<p>

<math display="block" id="Numerical_integration:14">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mrow>
      <mi>d</mi>
      <mi>F</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>x</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mrow>
      <mi>d</mi>
      <mi>x</mi>
     </mrow>
    </mfrac>
    <mo>=</mo>
    <mrow>
     <mi>f</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>x</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="12.5pt">,</mo>
   <mrow>
    <mrow>
     <mi>F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mn>0.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>F</ci>
       <ci>x</ci>
      </apply>
      <apply>
       <times></times>
       <ci>d</ci>
       <ci>x</ci>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <ci>x</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>F</ci>
      <ci>a</ci>
     </apply>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{dF(x)}{dx}=f(x),\quad F(a)=0.
  </annotation>
 </semantics>
</math>

 Methods developed for ordinary differential equations, such as <a href="Runge–Kutta_methods" title="wikilink">Runge–Kutta methods</a>, can be applied to the restated problem and thus be used to evaluate the integral. For instance, the standard fourth-order Runge–Kutta method applied to the differential equation yields Simpson's rule from above.</p>

<p>The differential equation <em>F</em> ' (<em>x</em>) = ƒ(<em>x</em>) has a special form: the right-hand side contains only the dependent variable (here <em>x</em>) and not the independent variable (here <em>F</em>). This simplifies the theory and algorithms considerably. The problem of evaluating integrals is thus best studied in its own right.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Numerical_ordinary_differential_equations" title="wikilink">Numerical ordinary differential equations</a></li>
<li><a href="Truncation_error_(numerical_integration)" title="wikilink">Truncation error (numerical integration)</a></li>
<li><a href="Clenshaw–Curtis_quadrature" title="wikilink">Clenshaw–Curtis quadrature</a></li>
<li><a href="Gauss-Kronrod_quadrature" title="wikilink">Gauss-Kronrod quadrature</a></li>
<li><a href="Riemann_Sum" title="wikilink">Riemann Sum</a> or <a href="Riemann_Integral" title="wikilink">Riemann Integral</a></li>
<li><a href="Trapezoidal_Rule" title="wikilink">Trapezoidal Rule</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li><a href="Philip_J._Davis" title="wikilink">Philip J. Davis</a> and <a href="Philip_Rabinowitz_(mathematician)" title="wikilink">Philip Rabinowitz</a>, <em>Methods of Numerical Integration</em>.</li>
<li><a href="George_E._Forsythe" title="wikilink">George E. Forsythe</a>, Michael A. Malcolm, and <a href="Cleve_B._Moler" title="wikilink">Cleve B. Moler</a>, <em>Computer Methods for Mathematical Computations</em>. Englewood Cliffs, NJ: Prentice-Hall, 1977. <em>(See Chapter 5.)</em></li>
<li></li>
<li><a href="Josef_Stoer" title="wikilink">Josef Stoer</a> and <a href="Roland_Bulirsch" title="wikilink">Roland Bulirsch</a>, <em>Introduction to Numerical Analysis</em>. New York: Springer-Verlag, 1980. <em>(See Chapter 3.)</em></li>
<li><a href="Carl_Benjamin_Boyer" title="wikilink">Boyer, C. B.</a>, <em>A History of Mathematics</em>, 2nd ed. rev. by Uta C. Merzbach, New York: Wiley, 1989 ISBN 0-471-09763-2 (1991 pbk ed. ISBN 0-471-54397-7).</li>
<li><a href="Howard_Eves" title="wikilink">Eves, Howard</a>, <em>An Introduction to the History of Mathematics</em>, Saunders, 1990, ISBN 0-03-029558-0,</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://numericalmethods.eng.usf.edu/mws/gen/07int/index.html">Integration: Background, Simulations, etc.</a> at Holistic Numerical Methods Institute</li>
</ul>
<h3 id="free-software-for-numerical-integration">Free software for numerical integration</h3>

<p>Numerical integration is one of the most intensively studied problems in numerical analysis. Of the many software implementations, we list a few <a href="free_and_open_source_software" title="wikilink">free and open source software</a> packages here:</p>
<ul>
<li><a class="uri" href="QUADPACK" title="wikilink">QUADPACK</a> (part of SLATEC): description <a href="http://www.netlib.org/slatec/src/qpdoc.f">1</a>, source code <a href="http://www.netlib.org/slatec/src">2</a>. QUADPACK is a collection of algorithms, in Fortran, for numerical integration based on Gaussian quadrature.</li>
<li><a href="http://openopt.org/interalg">interalg</a>: a solver from <a class="uri" href="OpenOpt" title="wikilink">OpenOpt</a>/<a class="uri" href="FuncDesigner" title="wikilink">FuncDesigner</a> frameworks, based on interval analysis, guaranteed precision, license: BSD (free for any purposes)</li>
<li><a href="http://www.gnu.org/software/gsl/">GSL</a>: The GNU Scientific Library (GSL) is a numerical library written in C that provides a wide range of mathematical routines, like Monte Carlo integration.</li>
<li>Numerical integration algorithms are found in <a href="Guide_to_Available_Mathematical_Software" title="wikilink">GAMS</a> class <a href="http://gams.nist.gov/serve.cgi/Class/H2">H2</a>.</li>
<li><a href="http://www.alglib.net/integral/">ALGLIB</a> is a collection of algorithms, in C# / C++ / Delphi / Visual Basic / etc., for numerical integration (includes Bulirsch-Stoer and Runge-Kutta integrators).</li>
<li><a href="http://www.feynarts.de/cuba/">Cuba</a> is a free-software library of several multi-dimensional integration algorithms.</li>
<li><a href="http://ab-initio.mit.edu/wiki/index.php/Cubature">Cubature</a> code for adaptive multi-dimensional integration.</li>
<li><a href="http://www.scilab.org/">Scilab</a> is an open source software under CeCILL license (GPL compatible), providing powerful features including numerical integration.</li>
</ul>

<p>"</p>

<p><a href="Category:Numerical_analysis" title="wikilink">Category:Numerical analysis</a> <a href="Category:Numerical_integration_(quadrature)" title="wikilink">*</a> <a href="Category:Articles_with_example_Python_code" title="wikilink">Category:Articles with example Python code</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
</ol>
</section>
</body>

