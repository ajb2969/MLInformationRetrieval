<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="687">Class (set theory)</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Class (set theory)</h1>
<hr/>

<p>In <a href="set_theory" title="wikilink">set theory</a> and its applications throughout <a class="uri" href="mathematics" title="wikilink">mathematics</a>, a <strong>class</strong> is a collection of <a href="Set_(mathematics)" title="wikilink">sets</a> (or sometimes other mathematical objects) that can be unambiguously defined by a property that all its members share. The precise definition of "class" depends on foundational context. In work on <a href="Zermelo‚ÄìFraenkel_set_theory" title="wikilink">Zermelo‚ÄìFraenkel set theory</a>, the notion of class is informal, whereas other set theories, such as <a href="Von_Neumann‚ÄìBernays‚ÄìG√∂del_set_theory" title="wikilink">Von Neumann‚ÄìBernays‚ÄìG√∂del set theory</a>, axiomatize the notion of "proper class", e.g., as entities that are not members of another entity.</p>

<p>A class that is not a set (informally in Zermelo‚ÄìFraenkel) is called a <strong>proper class</strong>, and a class that is a set is sometimes called a <strong>small class</strong>. For instance, the class of all <a href="ordinal_number" title="wikilink">ordinal numbers</a>, and the class of all sets, are proper classes in many formal systems.</p>

<p>Outside set theory, the word "class" is sometimes used synonymously with "set". This usage dates from a historical period where classes and sets were not distinguished as they are in modern set-theoretic terminology. Many discussions of "classes" in the 19th century and earlier are really referring to sets, or perhaps to a more ambiguous concept.</p>
<h2 id="examples">Examples</h2>

<p>The collection of all algebraic objects of a given type will usually be a proper class. Examples include the class of all <a href="group_(mathematics)" title="wikilink">groups</a>, the class of all <a href="vector_space" title="wikilink">vector spaces</a>, and many others. In <a href="category_theory" title="wikilink">category theory</a>, a category whose collection of objects forms a proper class (or whose collection of <a href="morphism" title="wikilink">morphisms</a> forms a proper class) is called a <a href="large_category" title="wikilink">large category</a>.</p>

<p>The <a href="surreal_number" title="wikilink">surreal numbers</a> are a proper class of objects that have the properties of a <a href="field_(mathematics)" title="wikilink">field</a>.</p>

<p>Within set theory, many collections of sets turn out to be proper classes. Examples include the class of all sets, the class of all ordinal numbers, and the class of all cardinal numbers.</p>

<p>One way to prove that a class is proper is to place it in <a class="uri" href="bijection" title="wikilink">bijection</a> with the class of all ordinal numbers. This method is used, for example, in the proof that there is no <a href="free_lattice#The_complete_free_lattice" title="wikilink">free</a> <a href="complete_lattice#Free_complete_lattices" title="wikilink">complete lattice</a>.</p>
<h2 id="paradoxes">Paradoxes</h2>

<p>The <a href="naive_set_theory#Paradoxes" title="wikilink">paradoxes of naive set theory</a> can be explained in terms of the inconsistent assumption that "all classes are sets". With a rigorous foundation, these paradoxes instead suggest <a href="proof_(mathematics)" title="wikilink">proofs</a> that certain classes are proper. For example, <a href="Russell's_paradox" title="wikilink">Russell's paradox</a> suggests a proof that the class of all sets which do not contain themselves is proper, and the <a href="Burali-Forti_paradox" title="wikilink">Burali-Forti paradox</a> suggests that the class of all <a href="ordinal_numbers" title="wikilink">ordinal numbers</a> is proper.</p>
<h2 id="classes-in-formal-set-theories">Classes in formal set theories</h2>

<p><a href="ZF_set_theory" title="wikilink">ZF set theory</a> does not formalize the notion of classes, so each formula with classes must be reduced syntactically to a formula without classes.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> For example, one can reduce the formula 

<math display="inline" id="Class_(set_theory):0">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">{</mo>
    <mi>x</mi>
    <mo>‚à£</mo>
    <mrow>
     <mi>x</mi>
     <mo>=</mo>
     <mi>x</mi>
    </mrow>
    <mo stretchy="false">}</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>A</ci>
    <apply>
     <csymbol cd="latexml">conditional-set</csymbol>
     <ci>x</ci>
     <apply>
      <eq></eq>
      <ci>x</ci>
      <ci>x</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A=\{x\mid x=x\}
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Class_(set_theory):1">
 <semantics>
  <mrow>
   <mo>‚àÄ</mo>
   <mi>x</mi>
   <mo>.</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>‚àà</mo>
    <mi>A</mi>
    <mo>‚Üî</mo>
    <mi>x</mi>
    <mo>=</mo>
    <mi>x</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">for-all</csymbol>
    <csymbol cd="unknown">x</csymbol>
    <ci>normal-.</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">x</csymbol>
     <in></in>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-‚Üî</ci>
     <csymbol cd="unknown">x</csymbol>
     <eq></eq>
     <csymbol cd="unknown">x</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall x.(x\in A\leftrightarrow x=x)
  </annotation>
 </semantics>
</math>

. Semantically, in a <a class="uri" href="metalanguage" title="wikilink">metalanguage</a>, the classes can be described as equivalence classes of logical formulas: If 

<math display="inline" id="Class_(set_theory):2">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíú</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíú</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 is a <a href="structure_(mathematical_logic)" title="wikilink">structure</a> interpreting ZF, then the object language class builder expression 

<math display="inline" id="Class_(set_theory):3">
 <semantics>
  <mrow>
   <mo stretchy="false">{</mo>
   <mi>x</mi>
   <mo>‚à£</mo>
   <mi>œï</mi>
   <mo stretchy="false">}</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">conditional-set</csymbol>
    <ci>x</ci>
    <ci>œï</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \{x\mid\phi\}
  </annotation>
 </semantics>
</math>

 is interpreted in 

<math display="inline" id="Class_(set_theory):4">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíú</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíú</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 by the collection of all the elements from the domain of 

<math display="inline" id="Class_(set_theory):5">
 <semantics>
  <mi class="ltx_font_mathcaligraphic">ùíú</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ùíú</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathcal{A}
  </annotation>
 </semantics>
</math>

 on which 

<math display="inline" id="Class_(set_theory):6">
 <semantics>
  <mrow>
   <mrow>
    <mi>Œª</mi>
    <mi>x</mi>
   </mrow>
   <mo>.</mo>
   <mi>œï</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <times></times>
     <ci>Œª</ci>
     <ci>x</ci>
    </apply>
    <ci>œï</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \lambda x.\phi
  </annotation>
 </semantics>
</math>

 holds; thus, the class can be described as the set of all predicates equivalent to 

<math display="inline" id="Class_(set_theory):7">
 <semantics>
  <mi>œï</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>œï</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 (including 

<math display="inline" id="Class_(set_theory):8">
 <semantics>
  <mi>œï</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>œï</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 itself). In particular, one can identify the "class of all sets" with the set of all predicates equivalent to <em>x=x</em>.</p>

<p>Because classes do not have any formal status in the theory of ZF, the axioms of ZF do not immediately apply to classes. However, if an <a href="inaccessible_cardinal" title="wikilink">inaccessible cardinal</a> Œ∫ is assumed, then the sets of smaller rank form a model of ZF (a <a href="Grothendieck_universe" title="wikilink">Grothendieck universe</a>), and its subsets can be thought of as "classes".</p>

<p>In ZF, the concept of a <a class="uri" href="function" title="wikilink">function</a> can also be generalised to classes. A class function is not a function in the usual sense, since it is not a set; it is rather a formula 

<math display="inline" id="Class_(set_theory):9">
 <semantics>
  <mrow>
   <mi mathvariant="normal">Œ¶</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>normal-Œ¶</ci>
    <interval closure="open">
     <ci>x</ci>
     <ci>y</ci>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(x,y)
  </annotation>
 </semantics>
</math>

 with the property that for any set <em>x</em> there is no more than one set <em>y</em> such that the pair (<em>x</em>,<em>y</em>) satisfies 

<math display="inline" id="Class_(set_theory):10">
 <semantics>
  <mi mathvariant="normal">Œ¶</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Œ¶</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

. For example, the class function mapping each set to its successor may be expressed as the formula 

<math display="inline" id="Class_(set_theory):11">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>=</mo>
   <mrow>
    <mi>x</mi>
    <mo>‚à™</mo>
    <mrow>
     <mo stretchy="false">{</mo>
     <mi>x</mi>
     <mo stretchy="false">}</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>y</ci>
    <apply>
     <union></union>
     <ci>x</ci>
     <set>
      <ci>x</ci>
     </set>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y=x\cup\{x\}
  </annotation>
 </semantics>
</math>

. The fact that the ordered pair (<em>x</em>,<em>y</em>) satisfies 

<math display="inline" id="Class_(set_theory):12">
 <semantics>
  <mi mathvariant="normal">Œ¶</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Œ¶</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi
  </annotation>
 </semantics>
</math>

 may be expressed with the shorthand notation 

<math display="inline" id="Class_(set_theory):13">
 <semantics>
  <mrow>
   <mrow>
    <mi mathvariant="normal">Œ¶</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>normal-Œ¶</ci>
     <ci>x</ci>
    </apply>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Phi(x)=y
  </annotation>
 </semantics>
</math>

.</p>

<p>Another approach is taken by the <a href="von_Neumann‚ÄìBernays‚ÄìG√∂del_axioms" title="wikilink">von Neumann‚ÄìBernays‚ÄìG√∂del axioms</a> (NBG); classes are the basic objects in this theory, and a set is then defined to be a class that is an element of some other class. However, the class existence axioms of NBG are restricted so that they only quantify over sets, rather than over all classes. This causes NBG to be a <a href="conservative_extension" title="wikilink">conservative extension</a> of ZF.</p>

<p><a href="Morse‚ÄìKelley_set_theory" title="wikilink">Morse‚ÄìKelley set theory</a> admits proper classes as basic objects, like NBG, but also allows quantification over all proper classes in its class existence axioms. This causes MK to be strictly stronger than both NBG and ZF.</p>

<p>In other set theories, such as <a href="New_Foundations" title="wikilink">New Foundations</a> or the theory of <a href="semiset" title="wikilink">semisets</a>, the concept of "proper class" still makes sense (not all classes are sets) but the criterion of sethood is not closed under subsets. For example, any set theory with a universal set has proper classes which are subclasses of sets.</p>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li></li>
</ul>

<p>"</p>

<p><a href="Category:Set_theory" title="wikilink">Category:Set theory</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a class="uri" href="http://us.metamath.org/mpegif/abeq2.html">http://us.metamath.org/mpegif/abeq2.html</a><a href="#fnref1">‚Ü©</a></li>
</ol>
</section>
</body>
</html>
