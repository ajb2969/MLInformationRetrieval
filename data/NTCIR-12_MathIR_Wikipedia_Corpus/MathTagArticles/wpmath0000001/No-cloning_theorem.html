<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="730">No-cloning theorem</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>No-cloning theorem</h1>
<hr/>

<p>In <a class="uri" href="physics" title="wikilink">physics</a>, the <strong>no-cloning theorem</strong> states that it is impossible to create an identical copy of an arbitrary unknown <a href="quantum_state" title="wikilink">quantum state</a>. This <a href="no-go_theorem" title="wikilink">no-go theorem</a> of <a href="quantum_mechanics" title="wikilink">quantum mechanics</a> was articulated by <a href="William_Wootters" title="wikilink">Wootters</a> and <a href="Wojciech_Zurek" title="wikilink">Zurek</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> and <a href="Dennis_Dieks" title="wikilink">Dieks</a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> in 1982, and has profound implications in <a href="quantum_computer" title="wikilink">quantum computing</a> and related fields.</p>

<p>The state of one system can be <a href="quantum_entanglement" title="wikilink">entangled</a> with the state of another system. For instance, one can use the <a href="controlled_NOT_gate" title="wikilink">controlled NOT gate</a> and the <a href="Hadamard_transform#Quantum_computing_applications" title="wikilink">Walsh–Hadamard gate</a> to entangle two <a href="qubit" title="wikilink">qubits</a>. This is not cloning. No well-defined state can be attributed to a subsystem of an entangled state. Cloning is a process whose result is a <a href="separable_state" title="wikilink">separable state</a> with identical factors. According to <a href="Asher_Peres" title="wikilink">Asher Peres</a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and David Kaiser,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a> the publication of the no-cloning theorem was prompted by a proposal of <a href="Nick_Herbert_(physicist)" title="wikilink">Nick Herbert</a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> for a <a href="superluminal_communication" title="wikilink">superluminal communication</a> device using quantum entanglement.</p>

<p>The no-cloning theorem is normally stated and proven for <a href="pure_state" title="wikilink">pure states</a>; the <a href="no-broadcast_theorem" title="wikilink">no-broadcast theorem</a> generalizes this result to <a href="mixed_state_(physics)" title="wikilink">mixed states</a>.</p>

<p>The no-cloning theorem has a time-reversed dual, the <a href="no-deleting_theorem" title="wikilink">no-deleting theorem</a>. Together, these underpin the interpretation of quantum mechanics in terms of <a href="category_theory" title="wikilink">category theory</a>, and, in particular, as a <a href="dagger_compact_category" title="wikilink">dagger compact category</a>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a><a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> This formulation, known as <a href="categorical_quantum_mechanics" title="wikilink">categorical quantum mechanics</a>, allows, in turn, a connection to be made from quantum mechanics to <a href="linear_logic" title="wikilink">linear logic</a> as the logic of <a href="quantum_information_theory" title="wikilink">quantum information theory</a> (in the same sense that classical logic arises from <a href="Cartesian_closed_category" title="wikilink">Cartesian closed categories</a>).</p>
<h2 id="theorem-and-proof">Theorem and proof</h2>

<p>Suppose the state of a quantum system A, which we wish to copy, is 

<math display="inline" id="No-cloning_theorem:0">
 <semantics>
  <msub>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>A</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>ϕ</ci>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\phi\rangle_{A}
  </annotation>
 </semantics>
</math>

 (see <a href="bra–ket_notation" title="wikilink">bra–ket notation</a>). In order to make a copy, we take a system B with the same <a href="Hilbert_space" title="wikilink">state space</a> and initial state 

<math display="inline" id="No-cloning_theorem:1">
 <semantics>
  <msub>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>e</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>B</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>e</ci>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |e\rangle_{B}
  </annotation>
 </semantics>
</math>

. The initial, or blank, state must be independent of 

<math display="inline" id="No-cloning_theorem:2">
 <semantics>
  <msub>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>A</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>ϕ</ci>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\phi\rangle_{A}
  </annotation>
 </semantics>
</math>

, of which we have no prior knowledge. The state of the composite system is then described by the following <a href="tensor_product" title="wikilink">tensor product</a>:</p>

<p>

<math display="block" id="No-cloning_theorem:3">
 <semantics>
  <mrow>
   <msub>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mi>ϕ</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mi>A</mi>
   </msub>
   <mo>⊗</mo>
   <mpadded width="+1.7pt">
    <msub>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mi>e</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mi>B</mi>
    </msub>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">tensor-product</csymbol>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>ϕ</ci>
     </apply>
     <ci>A</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>e</ci>
     </apply>
     <ci>B</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\phi\rangle_{A}\otimes|e\rangle_{B}\,
  </annotation>
 </semantics>
</math>

.</p>

<p>(in the following we will omit the 

<math display="inline" id="No-cloning_theorem:4">
 <semantics>
  <mo>⊗</mo>
  <annotation-xml encoding="MathML-Content">
   <csymbol cd="latexml">tensor-product</csymbol>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \otimes
  </annotation>
 </semantics>
</math>

 symbol and keep it implicit) There are only two permissible <a href="quantum_operation" title="wikilink">quantum operations</a> with which we may manipulate the composite system.</p>

<p>We could perform an observation, which irreversibly <a href="Wavefunction_collapse" title="wikilink">collapses</a> the system into some <a class="uri" href="eigenstate" title="wikilink">eigenstate</a> of an <a class="uri" href="observable" title="wikilink">observable</a>, corrupting the information contained in the <a href="qubit" title="wikilink">qubit(s)</a>. This is obviously not what we want. Alternatively, we could control the <a href="Hamiltonian_(quantum_mechanics)" title="wikilink">Hamiltonian</a> of the system, and thus the <a href="mathematical_formulation_of_quantum_mechanics" title="wikilink">time-evolution operator</a> <em>U</em> (for a time independent Hamiltonian, 

<math display="inline" id="No-cloning_theorem:5">
 <semantics>
  <mrow>
   <mrow>
    <mi>U</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>t</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <msup>
    <mi>e</mi>
    <mrow>
     <mo>-</mo>
     <mrow>
      <mrow>
       <mi>i</mi>
       <mi>H</mi>
       <mi>t</mi>
      </mrow>
      <mo>/</mo>
      <mi mathvariant="normal">ℏ</mi>
     </mrow>
    </mrow>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>U</ci>
     <ci>t</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>e</ci>
     <apply>
      <minus></minus>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>i</ci>
        <ci>H</ci>
        <ci>t</ci>
       </apply>
       <csymbol cd="latexml">Planck-constant-over-2-pi</csymbol>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U(t)=e^{-iHt/\hbar}
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="No-cloning_theorem:6">
 <semantics>
  <mrow>
   <mo>-</mo>
   <mrow>
    <mi>H</mi>
    <mo>/</mo>
    <mi mathvariant="normal">ℏ</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <minus></minus>
    <apply>
     <divide></divide>
     <ci>H</ci>
     <csymbol cd="latexml">Planck-constant-over-2-pi</csymbol>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   -H/\hbar
  </annotation>
 </semantics>
</math>

 is called the generator of translations in time) up to some fixed time interval, which yields a <a href="unitary_operator" title="wikilink">unitary operator</a> <em>U</em>. Then <em>U</em> acts as a copier provided that</p>

<p>

<math display="block" id="No-cloning_theorem:7">
 <semantics>
  <mrow>
   <mrow>
    <mi>U</mi>
    <msub>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mi>ϕ</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mi>A</mi>
    </msub>
    <msub>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mi>e</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mi>B</mi>
    </msub>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msub>
     <mrow>
      <mo fence="true" stretchy="false">|</mo>
      <mi>ϕ</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mi>A</mi>
    </msub>
    <mpadded width="+1.7pt">
     <msub>
      <mrow>
       <mo fence="true" stretchy="false">|</mo>
       <mi>ϕ</mi>
       <mo stretchy="false">⟩</mo>
      </mrow>
      <mi>B</mi>
     </msub>
    </mpadded>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>U</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <ci>ϕ</ci>
      </apply>
      <ci>A</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <ci>e</ci>
      </apply>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <ci>ϕ</ci>
      </apply>
      <ci>A</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">ket</csymbol>
       <ci>ϕ</ci>
      </apply>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   U|\phi\rangle_{A}|e\rangle_{B}=|\phi\rangle_{A}|\phi\rangle_{B}\,
  </annotation>
 </semantics>
</math>

</p>

<p>for all possible states 

<math display="inline" id="No-cloning_theorem:8">
 <semantics>
  <mrow>
   <mo fence="true" stretchy="false">|</mo>
   <mi>ϕ</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">ket</csymbol>
    <ci>ϕ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\phi\rangle
  </annotation>
 </semantics>
</math>

 in the state space. We now select an arbitrary pair of states 

<math display="inline" id="No-cloning_theorem:9">
 <semantics>
  <msub>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>A</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>ϕ</ci>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\phi\rangle_{A}
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="No-cloning_theorem:10">
 <semantics>
  <msub>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mi>ψ</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>A</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <ci>ψ</ci>
    </apply>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\psi\rangle_{A}
  </annotation>
 </semantics>
</math>

 drawn from the Hilbert space. Because <em>U</em> is unitary, it preserves the inner product:</p>

<p>

<math display="block" id="No-cloning_theorem:11">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mrow>
       <msub>
        <mrow>
         <mi>e</mi>
         <mo fence="true">|</mo>
        </mrow>
        <mi>B</mi>
       </msub>
       <msub>
        <mrow>
         <mo stretchy="false">⟨</mo>
         <msub>
          <mrow>
           <mi>ϕ</mi>
           <mo fence="true">|</mo>
          </mrow>
          <mi>A</mi>
         </msub>
         <mo stretchy="false">|</mo>
         <mi>ψ</mi>
         <mo stretchy="false">⟩</mo>
        </mrow>
        <mi>A</mi>
       </msub>
      </mrow>
      <mo stretchy="false">|</mo>
      <mi>e</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mi>B</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mrow>
       <msub>
        <mrow>
         <mi>e</mi>
         <mo fence="true">|</mo>
        </mrow>
        <mi>B</mi>
       </msub>
       <msub>
        <mrow>
         <mo stretchy="false">⟨</mo>
         <mrow>
          <msub>
           <mrow>
            <mi>ϕ</mi>
            <mo fence="true">|</mo>
           </mrow>
           <mi>A</mi>
          </msub>
          <msup>
           <mi>U</mi>
           <mo>†</mo>
          </msup>
          <mi>U</mi>
         </mrow>
         <mo stretchy="false">|</mo>
         <mi>ψ</mi>
         <mo stretchy="false">⟩</mo>
        </mrow>
        <mi>A</mi>
       </msub>
      </mrow>
      <mo stretchy="false">|</mo>
      <mi>e</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mi>B</mi>
    </msub>
    <mo>=</mo>
    <msub>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mrow>
       <msub>
        <mrow>
         <mi>ϕ</mi>
         <mo fence="true">|</mo>
        </mrow>
        <mi>B</mi>
       </msub>
       <msub>
        <mrow>
         <mo stretchy="false">⟨</mo>
         <msub>
          <mrow>
           <mi>ϕ</mi>
           <mo fence="true">|</mo>
          </mrow>
          <mi>A</mi>
         </msub>
         <mo stretchy="false">|</mo>
         <mi>ψ</mi>
         <mo stretchy="false">⟩</mo>
        </mrow>
        <mi>A</mi>
       </msub>
      </mrow>
      <mo stretchy="false">|</mo>
      <mi>ψ</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mi>B</mi>
    </msub>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">inner-product</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="latexml">evaluated-at</csymbol>
         <ci>e</ci>
         <ci>B</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="latexml">inner-product</csymbol>
          <apply>
           <csymbol cd="latexml">evaluated-at</csymbol>
           <ci>ϕ</ci>
           <ci>A</ci>
          </apply>
          <ci>ψ</ci>
         </apply>
         <ci>A</ci>
        </apply>
       </apply>
       <ci>e</ci>
      </apply>
      <ci>B</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">inner-product</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="latexml">evaluated-at</csymbol>
         <ci>e</ci>
         <ci>B</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="latexml">inner-product</csymbol>
          <apply>
           <times></times>
           <apply>
            <csymbol cd="latexml">evaluated-at</csymbol>
            <ci>ϕ</ci>
            <ci>A</ci>
           </apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>U</ci>
            <ci>normal-†</ci>
           </apply>
           <ci>U</ci>
          </apply>
          <ci>ψ</ci>
         </apply>
         <ci>A</ci>
        </apply>
       </apply>
       <ci>e</ci>
      </apply>
      <ci>B</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <apply>
       <csymbol cd="latexml">inner-product</csymbol>
       <apply>
        <times></times>
        <apply>
         <csymbol cd="latexml">evaluated-at</csymbol>
         <ci>ϕ</ci>
         <ci>B</ci>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <apply>
          <csymbol cd="latexml">inner-product</csymbol>
          <apply>
           <csymbol cd="latexml">evaluated-at</csymbol>
           <ci>ϕ</ci>
           <ci>A</ci>
          </apply>
          <ci>ψ</ci>
         </apply>
         <ci>A</ci>
        </apply>
       </apply>
       <ci>ψ</ci>
      </apply>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle e|_{B}\langle\phi|_{A}|\psi\rangle_{A}|e\rangle_{B}=\langle e|_{B}%
\langle\phi|_{A}U^{\dagger}U|\psi\rangle_{A}|e\rangle_{B}=\langle\phi|_{B}%
\langle\phi|_{A}|\psi\rangle_{A}|\psi\rangle_{B},
  </annotation>
 </semantics>
</math>

</p>

<p>and because quantum mechanical states are assumed to be normalized, it follows that</p>

<p>

<math display="block" id="No-cloning_theorem:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>ϕ</mi>
     <mo stretchy="false">|</mo>
     <mi>ψ</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <msup>
     <mrow>
      <mo stretchy="false">⟨</mo>
      <mi>ϕ</mi>
      <mo stretchy="false">|</mo>
      <mi>ψ</mi>
      <mo stretchy="false">⟩</mo>
     </mrow>
     <mn>2</mn>
    </msup>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">inner-product</csymbol>
     <ci>ϕ</ci>
     <ci>ψ</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <apply>
      <csymbol cd="latexml">inner-product</csymbol>
      <ci>ϕ</ci>
      <ci>ψ</ci>
     </apply>
     <cn type="integer">2</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\phi|\psi\rangle=\langle\phi|\psi\rangle^{2}.\,
  </annotation>
 </semantics>
</math>

</p>

<p>This implies that either 

<math display="inline" id="No-cloning_theorem:13">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">|</mo>
    <mi>ψ</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mn>1</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">inner-product</csymbol>
     <ci>ϕ</ci>
     <ci>ψ</ci>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\phi|\psi\rangle=1
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="No-cloning_theorem:14">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">|</mo>
    <mi>ψ</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="latexml">inner-product</csymbol>
     <ci>ϕ</ci>
     <ci>ψ</ci>
    </apply>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\phi|\psi\rangle=0
  </annotation>
 </semantics>
</math>

, so we obtain either 

<math display="inline" id="No-cloning_theorem:15">
 <semantics>
  <mrow>
   <mi>ϕ</mi>
   <mo>=</mo>
   <mi>ψ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ϕ</ci>
    <ci>ψ</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi=\psi
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="No-cloning_theorem:16">
 <semantics>
  <mi>ϕ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ϕ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \phi
  </annotation>
 </semantics>
</math>

 is <a href="orthogonality" title="wikilink">orthogonal</a> to 

<math display="inline" id="No-cloning_theorem:17">
 <semantics>
  <mi>ψ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>ψ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \psi
  </annotation>
 </semantics>
</math>

. However, this cannot be the case for two <em>arbitrary</em> states. Therefore a single universal <em>U</em> cannot clone a <em>general</em> quantum state. This proves the no-cloning theorem.</p>

<p>Note that it is possible to find specific pairs that satisfy the algebraic requirement above. An example is given by the orthogonal states</p>

<p>

<math display="block" id="No-cloning_theorem:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mi>ϕ</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <msqrt>
       <mn>2</mn>
      </msqrt>
     </mfrac>
     <mrow>
      <mo maxsize="210%" minsize="210%">(</mo>
      <mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>0</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mo>+</mo>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>1</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mrow>
      <mo maxsize="210%" minsize="210%">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="22.5pt">,</mo>
   <mrow>
    <mrow>
     <mo fence="true" stretchy="false">|</mo>
     <mi>ψ</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <msqrt>
       <mn>2</mn>
      </msqrt>
     </mfrac>
     <mrow>
      <mo maxsize="210%" minsize="210%">(</mo>
      <mrow>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>0</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
       <mo>-</mo>
       <mrow>
        <mo fence="true" stretchy="false">|</mo>
        <mn>1</mn>
        <mo stretchy="false">⟩</mo>
       </mrow>
      </mrow>
      <mo maxsize="210%" minsize="210%">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>ϕ</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <root></root>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">ket</csymbol>
      <ci>ψ</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <root></root>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <cn type="integer">0</cn>
       </apply>
       <apply>
        <csymbol cd="latexml">ket</csymbol>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |\phi\rangle={1\over\sqrt{2}}\bigg(|0\rangle+|1\rangle\bigg),\qquad|\psi%
\rangle={1\over\sqrt{2}}\bigg(|0\rangle-|1\rangle\bigg)
  </annotation>
 </semantics>
</math>

</p>

<p>and one verifies that 

<math display="inline" id="No-cloning_theorem:19">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>ϕ</mi>
    <mo stretchy="false">|</mo>
    <mi>ψ</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>=</mo>
   <mn>0</mn>
   <mo>=</mo>
   <msup>
    <mrow>
     <mo stretchy="false">⟨</mo>
     <mi>ϕ</mi>
     <mo stretchy="false">|</mo>
     <mi>ψ</mi>
     <mo stretchy="false">⟩</mo>
    </mrow>
    <mn>2</mn>
   </msup>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="latexml">inner-product</csymbol>
      <ci>ϕ</ci>
      <ci>ψ</ci>
     </apply>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="latexml">inner-product</csymbol>
       <ci>ϕ</ci>
       <ci>ψ</ci>
      </apply>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle\phi|\psi\rangle=0=\langle\phi|\psi\rangle^{2}
  </annotation>
 </semantics>
</math>

 in this special case. But this relationship does not hold for more general quantum states.</p>
<h2 id="generalizations">Generalizations</h2>
<h3 id="mixed-states-and-nonunitary-operations">Mixed states and nonunitary operations</h3>

<p>In the statement of the theorem, two assumptions were made: the state to be copied is a <a href="pure_state" title="wikilink">pure state</a> and the proposed copier acts via unitary time evolution. These assumptions cause no loss of generality. If the state to be copied is a <a href="mixed_state_(physics)" title="wikilink">mixed state</a>, it can be <a href="purification_of_quantum_state" title="wikilink">purified</a>. Alternately, a different proof can be given that works directly with mixed states; in this case, the theorem is often known as the <a href="no-broadcast_theorem" title="wikilink">no-broadcast theorem</a>. Similarly, an arbitrary <a href="quantum_operation" title="wikilink">quantum operation</a> can be implemented via introducing an <a class="uri" href="ancilla" title="wikilink">ancilla</a> and performing a suitable unitary evolution. Thus the no-cloning theorem holds in full generality.</p>
<h3 id="arbitrary-sets-of-states">Arbitrary sets of states</h3>

<p>Non-clonability can be seen as a property of arbitrary sets of quantum states. If we know that a system's state is one of the states in some set S, but we do not know which one, can we prepare another system in the same state? If the elements of S are pairwise <a class="uri" href="orthogonal" title="wikilink">orthogonal</a>, the answer is always yes: for any such set there exists a measurement which will ascertain the exact state of the system without disturbing it, and once we know the state we can prepare another system in the same state.</p>

<p>On the other hand, if S contains a pair of elements that are not pairwise orthogonal, then an argument like that given above shows that the answer is no. So even if we can narrow down the state of a quantum system to just <em>two</em> possibilities, we still cannot clone it in general (unless the states happen to be orthogonal).</p>

<p>Another way of stating the no-cloning theorem is that <a href="amplifier" title="wikilink">amplification</a> of a quantum signal can only happen with respect to some orthogonal basis. This is related to the emergence of the rules of classical probability via <a href="quantum_decoherence" title="wikilink">quantum decoherence</a>.</p>
<h3 id="no-cloning-in-a-classical-context">No-cloning in a classical context</h3>

<p>There is a classical analogue to the quantum no-cloning theorem, which might be stated as follows: given only the result of one flip of a (possibly biased) coin, we cannot simulate a second, independent toss of the same coin. The proof of this statement uses the linearity of classical probability, and has exactly the same structure as the proof of the quantum no-cloning theorem. Thus, in order to claim that no-cloning is a uniquely quantum result, some care is necessary in stating the theorem. One way of restricting the result to quantum mechanics is to restrict the states to pure states, where a pure state is defined to be one that is not a <a href="convex_combination" title="wikilink">convex combination</a> of other states. The classical pure states are pairwise orthogonal, but quantum pure states are not.</p>
<h2 id="consequences">Consequences</h2>
<ul>
<li>The no-cloning theorem prevents the use of classical <a href="error_correction" title="wikilink">error correction</a> techniques on quantum states. For example, backup copies of a state in the middle of a <a href="quantum_computer" title="wikilink">quantum computation</a> cannot be created and used for correcting subsequent errors. Error correction is vital for practical quantum computing, and for some time this was thought to be a fatal limitation. In 1995, <a href="Peter_Shor" title="wikilink">Shor</a> and <a href="Andrew_Steane" title="wikilink">Steane</a> revived the prospects of quantum computing by independently devising the first <a href="quantum_error_correction" title="wikilink">quantum error correcting</a> codes, which circumvent the no-cloning theorem.</li>
</ul>
<ul>
<li>Similarly, cloning would violate the <a href="no-teleportation_theorem" title="wikilink">no-teleportation theorem</a>, which says classical teleportation (not to be confused with <a href="quantum_teleportation" title="wikilink">entanglement-assisted teleportation</a>) is impossible. In other words, quantum states cannot be measured reliably.</li>
</ul>
<ul>
<li>The no-cloning theorem is implied by the <a href="no-communication_theorem" title="wikilink">no-communication theorem</a>, which states that quantum entanglement cannot be used to transmit classical information (whether superluminally, or slower). That is, cloning, together with entanglement, would allow such communication to occur. To see this, consider the <a href="EPR_paradox" title="wikilink">EPR thought experiment</a>, and suppose quantum states could be cloned. Assume parts of a <a href="Maximally_entangled_state" title="wikilink">maximally entangled</a> <a href="Bell_state" title="wikilink">Bell state</a> are distributed to Alice and Bob. Alice could send bits to Bob in the following way: If Alice wishes to transmit a "0", she measures the spin of her electron in the <strong>z</strong> direction, collapsing Bob's state to either 

<math display="inline" id="No-cloning_theorem:20">
 <semantics>
  <msub>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mrow>
     <mi>z</mi>
     <mo>+</mo>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>B</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="latexml">limit-from</csymbol>
      <ci>z</ci>
      <plus></plus>
     </apply>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |z+\rangle_{B}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="No-cloning_theorem:21">
 <semantics>
  <msub>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mrow>
     <mi>z</mi>
     <mo>-</mo>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>B</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="latexml">limit-from</csymbol>
      <ci>z</ci>
      <minus></minus>
     </apply>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |z-\rangle_{B}
  </annotation>
 </semantics>
</math>

. To transmit "1", Alice does nothing to her qubit. Bob creates many copies of his electron's state, and measures the spin of each copy in the <strong>z</strong> direction. Bob will know that Alice has transmitted a "0" if all his measurements will produce the same result; otherwise, his measurements will have outcomes 

<math display="inline" id="No-cloning_theorem:22">
 <semantics>
  <msub>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mrow>
     <mi>z</mi>
     <mo>+</mo>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>B</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="latexml">limit-from</csymbol>
      <ci>z</ci>
      <plus></plus>
     </apply>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |z+\rangle_{B}
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="No-cloning_theorem:23">
 <semantics>
  <msub>
   <mrow>
    <mo fence="true" stretchy="false">|</mo>
    <mrow>
     <mi>z</mi>
     <mo>-</mo>
    </mrow>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mi>B</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <apply>
     <csymbol cd="latexml">ket</csymbol>
     <apply>
      <csymbol cd="latexml">limit-from</csymbol>
      <ci>z</ci>
      <minus></minus>
     </apply>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   |z-\rangle_{B}
  </annotation>
 </semantics>
</math>

 with equal probability. This would allow Alice and Bob to communicate classical bits between each other (possibly across <a class="uri" href="space-like" title="wikilink">space-like</a> separations, violating <a class="uri" href="causality" title="wikilink">causality</a>).</li>
</ul>
<ul>
<li>The no cloning theorem prevents an interpretation of the <a href="holographic_principle" title="wikilink">holographic principle</a> for <a href="black_hole" title="wikilink">black holes</a> as meaning that there are two copies of information, one lying at the <a href="event_horizon" title="wikilink">event horizon</a> and the other in the black hole interior. This leads to more radical interpretations, such as <a href="black_hole_complementarity" title="wikilink">black hole complementarity</a>.</li>
</ul>
<ul>
<li>The no-cloning theorem extends to all <a href="dagger_compact_category" title="wikilink">dagger compact categories</a>: there is no universal cloning morphism for any non-trivial category of this kind.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> The result is important, as this category includes things that are not finite-dimensional Hilbert spaces, including the <a href="category_of_sets_and_relations" title="wikilink">category of sets and relations</a> and the category of <a href="cobordism" title="wikilink">cobordisms</a>.</li>
</ul>
<h2 id="imperfect-cloning">Imperfect cloning</h2>

<p>Even though it is impossible to make perfect copies of an unknown quantum state, it is possible to produce imperfect copies. This can be done by coupling a larger auxiliary system to the system that is to be cloned, and applying a <a href="unitary_transformation" title="wikilink">unitary transformation</a> to the combined system. If the unitary transformation is chosen correctly, several components of the combined system will evolve into approximate copies of the original system. In 1996, V. Buzek and M. Hillery showed that a universal cloning machine can make a clone of an unknown state with the surprisingly high fidelity of 5/6.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p><a href="Quantum_cloning" title="wikilink">Imperfect cloning</a> can be used as an eavesdropping attack on quantum cryptography protocols, among other uses in quantum information science.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Fundamental_Fysiks_Group" title="wikilink">Fundamental Fysiks Group</a></li>
<li><a href="No-broadcast_theorem" title="wikilink">No-broadcast theorem</a></li>
<li><a href="No-communication_theorem" title="wikilink">No-communication theorem</a></li>
<li><a href="No-deleting_theorem" title="wikilink">No-deleting theorem</a></li>
<li><a href="Quantum_entanglement" title="wikilink">Quantum entanglement</a></li>
<li><a href="Quantum_cloning" title="wikilink">Quantum cloning</a></li>
<li><a href="Quantum_information" title="wikilink">Quantum information</a></li>
<li><a href="Quantum_teleportation" title="wikilink">Quantum teleportation</a></li>
<li><a href="Uncertainty_principle" title="wikilink">Uncertainty principle</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="other-sources">Other sources</h2>
<ul>
<li>V. Buzek and M. Hillery, <em>Quantum cloning</em>, Physics World 14 (11) (2001), pp. 25–29.</li>
</ul>

<p>"</p>

<p><a href="Category:Quantum_information_science" title="wikilink">Category:Quantum information science</a> <a href="Category:Physics_theorems" title="wikilink">Category:Physics theorems</a> <a href="Category:Articles_containing_proofs" title="wikilink">Category:Articles containing proofs</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6">John Baez, Mike Stay, <em><a href="http://math.ucr.edu/home/baez/rosetta.pdf">Physics, Topology, Logic and Computation: A Rosetta Stone</a></em> (2009)<a href="#fnref6">↩</a></li>
<li id="fn7">Bob Coecke, <em>Quantum Picturalism</em>, (2009) <a href="http://arxiv.org/abs/0908.1787">ArXiv 0908.1787</a><a href="#fnref7">↩</a></li>
<li id="fn8">S. Abramsky, "No-Cloning in categorical quantum mechanics", (2008) <em>Semantic Techniques for Quantum Computation</em>, I. Mackie and S. Gay (eds), Cambridge University Press<a href="#fnref8">↩</a></li>
<li id="fn9">Bužek V. and Hillery, M. Quantum Copying: Beyond the No-Cloning Theorem. Phys. Rev. A 54, 1844 (1996)<a href="#fnref9">↩</a></li>
</ol>
</section>
</body>
</html>
