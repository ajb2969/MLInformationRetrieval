<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="375">Euclidean algorithm</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Euclidean algorithm</h1>
<hr/>
<figure><b>(Figure)</b>
<figcaption>Euclid's method for finding the greatest common divisor (GCD) of two starting lengths BA and DC, both defined to be multiples of a common "unit" length. The length DC being shorter, it is used to "measure" BA, but only once because remainder EA is less than DC. EA now measures (twice) the shorter length DC, with remainder FC shorter than EA. Then FC measures (three times) length EA. Because there is no remainder, the process ends with FC being the GCD. On the right <a class="uri" href="Nicomachus" title="wikilink">Nicomachus</a>' example with numbers 49 and 21 resulting in their GCD of 7 (derived from Heath 1908:300).</figcaption>
</figure>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a>, the <strong>Euclidean algorithm</strong>, or <strong>Euclid's algorithm</strong>, is an efficient method for computing the <a href="greatest_common_divisor" title="wikilink">greatest common divisor</a> (GCD) of two numbers, the largest number that divides both of them without leaving a <a class="uri" href="remainder" title="wikilink">remainder</a>. It is named after the ancient Greek <a class="uri" href="mathematician" title="wikilink">mathematician</a> <a class="uri" href="Euclid" title="wikilink">Euclid</a>, who first described it in <a href="Euclid's_Elements" title="wikilink">Euclid's <em>Elements</em></a> (c. 300 BC). It is an example of an <em><a class="uri" href="algorithm" title="wikilink">algorithm</a></em>, a step-by-step procedure for performing a calculation according to well-defined rules, and is one of the oldest numerical algorithms in common use. It can be used to reduce <a href="Fraction_(mathematics)" title="wikilink">fractions</a> to their <a href="Irreducible_fraction" title="wikilink">simplest form</a>, and is a part of many other number-theoretic and cryptographic calculations.</p>

<p>The Euclidean algorithm is based on the principle that the greatest common divisor of two numbers does not change if the larger number is replaced by its difference with the smaller number. For example, 21 is the GCD of 252 and 105 (252 = 21 × 12 and 105 = 21 × 5), and the same number 21 is also the GCD of 105 and 147 = 252 − 105. Since this replacement reduces the larger of the two numbers, repeating this process gives successively smaller pairs of numbers until one of the two numbers reaches zero. When that occurs, the other number (the one that is not zero) is the GCD of the original two numbers. By <a href="extended_Euclidean_algorithm" title="wikilink">reversing the steps</a>, the GCD can be expressed as a <a href="linear_combination" title="wikilink">sum</a> of the two original numbers each multiplied by a positive or negative <a class="uri" href="integer" title="wikilink">integer</a>, e.g., 21 = 5 × 105 + (−2) × 252. The fact that the GCD can always be expressed in this way is known as <a href="Bézout's_identity" title="wikilink">Bézout's identity</a>.</p>

<p>The version of the Euclidean algorithm described above (and by Euclid) can take many subtraction steps to find the GCD when one of the given numbers is much bigger than the other. A more efficient version of the algorithm shortcuts these steps, instead replacing the larger of the two numbers by its remainder when divided by the smaller of the two. With this improvement, the algorithm never requires more steps than five times the number of digits (base 10) of the smaller integer. This was proven by <a href="Gabriel_Lamé" title="wikilink">Gabriel Lamé</a> in 1844, and marks the beginning of <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>. Additional methods for improving the algorithm's efficiency were developed in the 20th century.</p>

<p>The Euclidean algorithm has many theoretical and practical applications. It is used for reducing <a href="Fraction_(mathematics)" title="wikilink">fractions</a> to their <a href="Irreducible_fraction" title="wikilink">simplest form</a> and for performing <a href="Division_(mathematics)" title="wikilink">division</a> in <a href="modular_arithmetic" title="wikilink">modular arithmetic</a>. Computations using this algorithm form part of the <a href="cryptographic_protocol" title="wikilink">cryptographic protocols</a> that are used to secure <a class="uri" href="internet" title="wikilink">internet</a> communications, and in methods for breaking these cryptosystems by <a href="integer_factorization" title="wikilink">factoring large composite numbers</a>. The Euclidean algorithm may be used to solve <a href="Diophantine_equation" title="wikilink">Diophantine equations</a>, such as finding numbers that satisfy multiple congruences according to the <a href="Chinese_remainder_theorem" title="wikilink">Chinese remainder theorem</a>, to construct <a href="continued_fraction" title="wikilink">continued fractions</a>, and to find accurate <a href="Diophantine_approximation" title="wikilink">rational approximations</a> to real numbers. Finally, it is a basic tool for proving theorems in <a href="number_theory" title="wikilink">number theory</a> such as <a href="Lagrange's_four-square_theorem" title="wikilink">Lagrange's four-square theorem</a> and the <a href="fundamental_theorem_of_arithmetic" title="wikilink">uniqueness of prime factorizations</a>. The original algorithm was described only for natural numbers and geometric lengths (real numbers), but the algorithm was generalized in the 19th century to other types of numbers, such as <a href="Gaussian_integer" title="wikilink">Gaussian integers</a> and <a href="polynomial" title="wikilink">polynomials</a> of one variable. This led to modern <a href="abstract_algebra" title="wikilink">abstract algebraic</a> notions such as <a href="Euclidean_domain" title="wikilink">Euclidean domains</a>.</p>
<h2 id="background-greatest-common-divisor">Background: greatest common divisor</h2>

<p>The Euclidean algorithm calculates the greatest common divisor (GCD) of two <a href="natural_number" title="wikilink">natural numbers</a> <em>a</em> and <em>b</em>. The greatest common divisor <em>g</em> is the largest natural number that divides both <em>a</em> and <em>b</em> without leaving a remainder. Synonyms for the GCD include the <em>greatest common factor</em> (GCF), the <em>highest common factor</em> (HCF), and the <em>greatest common measure</em> (GCM). The greatest common divisor is often written as gcd(<em>a</em>, <em>b</em>) or, more simply, as (<em>a</em>, <em>b</em>),<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> although the latter notation is also used for other mathematical concepts, such as two-dimensional <a href="coordinate_vector" title="wikilink">vectors</a>.</p>

<p>If gcd(<em>a</em>, <em>b</em>) = 1, then <em>a</em> and <em>b</em> are said to be <a href="Coprime_integers" title="wikilink">coprime</a> (or relatively prime).<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> This property does not imply that <em>a</em> or <em>b</em> are themselves <a href="prime_number" title="wikilink">prime numbers</a>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> For example, neither 6 nor 35 is a prime number, since they both have two prime factors: 6 = 2 × 3 and 35 = 5 × 7. Nevertheless, 6 and 35 are coprime. No natural number other than 1 divides both 6 and 35, since they have no prime factors in common.</p>
<figure><b>(Figure)</b>
<figcaption>A 24-by-60 rectangle is covered with ten 12-by-12 square tiles, where 12 is the GCD of 24 and 60. More generally, an <em>a</em>-by-<em>b</em> rectangle can be covered with square tiles of side-length <em>c</em> only if <em>c</em> is a common divisor of <em>a</em> and <em>b</em>.</figcaption>
</figure>

<p>Let <em>g</em> = gcd(<em>a</em>, <em>b</em>). Since <em>a</em> and <em>b</em> are both multiples of <em>g</em>, they can be written <em>a</em> = <em>mg</em> and <em>b</em> = <em>ng</em>, and there is no larger number <em>G</em> &gt; <em>g</em> for which this is true. The natural numbers <em>m</em> and <em>n</em> must be coprime, since any common factor could be factored out of <em>m</em> and <em>n</em> to make <em>g</em> greater. Thus, any other number <em>c</em> that divides both <em>a</em> and <em>b</em> must also divide <em>g</em>. The greatest common divisor <em>g</em> of <em>a</em> and <em>b</em> is the unique (positive) common divisor of <em>a</em> and <em>b</em> that is divisible by any other common divisor <em>c</em>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a></p>

<p>The GCD can be visualized as follows.<a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> Consider a rectangular area <em>a</em> by <em>b</em>, and any common divisor <em>c</em> that divides both <em>a</em> and <em>b</em> exactly. The sides of the rectangle can be divided into segments of length <em>c</em>, which divides the rectangle into a grid of squares of side length <em>c</em>. The greatest common divisor <em>g</em> is the largest value of <em>c</em> for which this is possible. For illustration, a 24-by-60 rectangular area can be divided into a grid of: 1-by-1 squares, 2-by-2 squares, 3-by-3 squares, 4-by-4 squares, 6-by-6 squares or 12-by-12 squares. Therefore, 12 is the greatest common divisor of 24 and 60. A 24-by-60 rectangular area can be divided into a grid of 12-by-12 squares, with two squares along one edge (24/12 = 2) and five squares along the other (60/12 = 5).</p>

<p>The GCD of two numbers <em>a</em> and <em>b</em> is the product of the prime factors shared by the two numbers, where a same prime factor can be used multiple times, but only as long as the product of these factors divides both <em>a</em> and <em>b</em>.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> For example, since 1386 can be factored into 2 × 3 × 3 × 7 × 11, and 3213 can be factored into 3 × 3 × 3 × 7 × 17, the greatest common divisor of 1386 and 3213 equals 63 = 3 × 3 × 7, the product of their shared prime factors. If two numbers have no prime factors in common, their greatest common divisor is 1 (obtained here as an instance of the <a href="empty_product" title="wikilink">empty product</a>), in other words they are coprime. A key advantage of the Euclidean algorithm is that it can find the GCD efficiently without having to compute the prime factors.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> <a href="integer_factorization" title="wikilink">Factorization</a> of large integers is believed to be a computationally very difficult problem, and the security of many modern cryptography systems is based upon its infeasibility.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>Another definition of the GCD is helpful in advanced mathematics, particularly <a href="ring_theory" title="wikilink">ring theory</a>.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a> The greatest common divisor <em>g</em>  of two nonzero numbers <em>a</em> and <em>b</em> is also their smallest positive integral linear combination, that is, the smallest positive number of the form <em>ua</em> + <em>vb</em> where <em>u</em> and <em>v</em> are integers. The set of all integral linear combinations of <em>a</em> and <em>b</em> is actually the same as the set of all multiples of <em>g</em> (<em>mg</em>, where <em>m</em> is an integer). In modern mathematical language, the <a href="ideal_(ring_theory)" title="wikilink">ideal</a> generated by <em>a</em> and <em>b</em> is the ideal generated by <em>g</em> alone (an ideal generated by a single element is called a <a href="principal_ideal" title="wikilink">principal ideal</a>, and all ideals of the integers are principal ideals). Some properties of the GCD are in fact easier to see with this description, for instance the fact that any common divisor of <em>a</em> and <em>b</em> also divides the GCD (it divides both terms of <em>ua</em> + <em>vb</em>). The equivalence of this GCD definition with the other definitions is described below.</p>

<p>The GCD of three or more numbers equals the product of the prime factors common to all the numbers,<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> but it can also be calculated by repeatedly taking the GCDs of pairs of numbers.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> For example,</p>
<dl>
<dd>

<math display="inline" id="Euclidean_algorithm:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>g</mi>
     <mi>c</mi>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mi>b</mi>
      <mo>,</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>g</mi>
     <mi>c</mi>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo>,</mo>
      <mrow>
       <mi mathvariant="normal"></mi>
       <mi>g</mi>
       <mi>c</mi>
       <mi>d</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>b</mi>
        <mo>,</mo>
        <mi>c</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>g</mi>
     <mi>c</mi>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>g</mi>
       <mi>c</mi>
       <mi>d</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo>,</mo>
        <mi>b</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mi>c</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>g</mi>
     <mi>c</mi>
     <mi>d</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>g</mi>
       <mi>c</mi>
       <mi>d</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo>,</mo>
        <mi>c</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
      <mo>,</mo>
      <mi>b</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>c</ci>
      <ci>d</ci>
      <vector>
       <ci>a</ci>
       <ci>b</ci>
       <ci>c</ci>
      </vector>
     </apply>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>c</ci>
      <ci>d</ci>
      <interval closure="open">
       <ci>a</ci>
       <apply>
        <times></times>
        <ci>normal-</ci>
        <ci>g</ci>
        <ci>c</ci>
        <ci>d</ci>
        <interval closure="open">
         <ci>b</ci>
         <ci>c</ci>
        </interval>
       </apply>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>c</ci>
      <ci>d</ci>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>g</ci>
        <ci>c</ci>
        <ci>d</ci>
        <interval closure="open">
         <ci>a</ci>
         <ci>b</ci>
        </interval>
       </apply>
       <ci>c</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>c</ci>
      <ci>d</ci>
      <interval closure="open">
       <apply>
        <times></times>
        <ci>g</ci>
        <ci>c</ci>
        <ci>d</ci>
        <interval closure="open">
         <ci>a</ci>
         <ci>c</ci>
        </interval>
       </apply>
       <ci>b</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   gcd(a,b,c)=gcd(a, gcd(b,c))=gcd(gcd(a,b),c)=gcd(gcd(a,c),b).
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>Thus, Euclid's algorithm, which computes the GCD of two integers, suffices to calculate the GCD of arbitrarily many integers.</p>
<h2 id="description">Description</h2>
<h3 id="procedure">Procedure</h3>

<p>The Euclidean algorithm proceeds in a series of steps such that the output of each step is used as an input for the next one. Let <em>k</em> be an integer that counts the steps of the algorithm, starting with zero. Thus, the initial step corresponds to <em>k</em> = 0, the next step corresponds to <em>k</em> = 1, and so on.</p>

<p>Each step begins with two nonnegative remainders <em>r</em><sub><em>k</em>−1</sub> and <em>r</em><sub><em>k</em>−2</sub>. Since the algorithm ensures that the remainders decrease steadily with every step, <em>r</em><sub><em>k</em>−1</sub> is less than its predecessor <em>r</em><sub><em>k</em>−2</sub>. The goal of the <em>k</em>th step is to find a <a class="uri" href="quotient" title="wikilink">quotient</a> <em>q</em><sub><em>k</em></sub> and <a class="uri" href="remainder" title="wikilink">remainder</a> <em>r</em><sub><em>k</em></sub> that satisfy the equation</p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>and that have <em>r</em><sub><em>k</em></sub> <em>k</em>−1. In other words, multiples of the smaller number <em>r</em><sub><em>k</em>−1</sub> are subtracted from the larger number <em>r</em><sub><em>k</em>−2</sub> until the remainder <em>r</em><sub><em>k</em></sub> is smaller than <em>r</em><sub><em>k</em>−1</sub>.</p>

<p>In the initial step (<em>k</em> = 0), the remainders <em>r</em><sub>−2</sub> and <em>r</em><sub>−1</sub> equal <em>a</em> and <em>b</em>, the numbers for which the GCD is sought. In the next step (<em>k</em> = 1), the remainders equal <em>b</em> and the remainder <em>r</em><sub>0</sub> of the initial step, and so on. Thus, the algorithm can be written as a sequence of equations</p>
<dl>
<dd><mtpl></mtpl>
</dd>
<dd><mtpl></mtpl>
</dd>
<dd><mtpl></mtpl>
</dd>
<dd><mtpl></mtpl>
</dd>
<dd>

<math display="inline" id="Euclidean_algorithm:1">
 <semantics>
  <mi mathvariant="normal">…</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-…</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   …
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>If <em>a</em> is smaller than <em>b</em>, the first step of the algorithm swaps the numbers. For example, if <em>a</em> 0 equals zero, and the remainder <em>r</em><sub>0</sub> is <em>a</em>. Thus, <em>r</em><sub><em>k</em></sub> is smaller than its predecessor <em>r</em><sub><em>k</em>−1</sub> for all <em>k</em> ≥ 0.</p>

<p>Since the remainders decrease with every step but can never be negative, a remainder <em>r</em><sub><em>N</em></sub> must eventually equal zero, at which point the algorithm stops.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> The final nonzero remainder <em>r</em><sub><em>N</em>−1</sub> is the greatest common divisor of <em>a</em> and <em>b</em>. The number <em>N</em> cannot be infinite because there are only a finite number of nonnegative integers between the initial remainder <em>r</em><sub>0</sub> and zero.</p>
<h3 id="proof-of-validity">Proof of validity</h3>

<p>The validity of the Euclidean algorithm can be proven by a two-step argument.<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> In the first step, the final nonzero remainder <em>r</em><sub><em>N</em>−1</sub> is shown to divide both <em>a</em> and <em>b</em>. Since it is a common divisor, it must be less than or equal to the greatest common divisor <em>g</em>. In the second step, it is shown that any common divisor of <em>a</em> and <em>b</em>, including <em>g</em>, must divide <em>r</em><sub><em>N</em>−1</sub>; therefore, <em>g</em> must be less than or equal to <em>r</em><sub><em>N</em>−1</sub>. These two conclusions are inconsistent unless <em>r</em><sub><em>N</em>−1</sub> = <em>g</em>.</p>

<p>To demonstrate that <em>r</em><sub><em>N</em>−1</sub> divides both <em>a</em> and <em>b</em> (the first step), <em>r</em><sub><em>N</em>−1</sub> divides its predecessor <em>r</em><sub><em>N</em>−2</sub></p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>since the final remainder <em>r</em><sub><em>N</em></sub> is zero. <em>r</em><sub><em>N</em>−1</sub> also divides its next predecessor <em>r</em><sub><em>N</em>−3</sub></p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>because it divides both terms on the right-hand side of the equation. Iterating the same argument, <em>r</em><sub><em>N</em>−1</sub> divides all the preceding remainders, including <em>a</em> and <em>b</em>. None of the preceding remainders <em>r</em><sub><em>N</em>−2</sub>, <em>r</em><sub><em>N</em>−3</sub>, etc. divide <em>a</em> and <em>b</em>, since they leave a remainder. Since <em>r</em><sub><em>N</em>−1</sub> is a common divisor of <em>a</em> and <em>b</em>, <em>r</em><sub><em>N</em>−1</sub> ≤ <em>g</em>.</p>

<p>In the second step, any natural number <em>c</em> that divides both <em>a</em> and <em>b</em> (in other words, any common divisor of <em>a</em> and <em>b</em>) divides the remainders <em>r</em><sub><em>k</em></sub>. By definition, <em>a</em> and <em>b</em> can be written as multiples of <em>c</em>: <em>a</em> = <em>mc</em> and <em>b</em> = <em>nc</em>, where <em>m</em> and <em>n</em> are natural numbers. Therefore, <em>c</em> divides the initial remainder <em>r</em><sub>0</sub>, since <em>r</em><sub>0</sub> = <em>a</em> − <em>q</em><sub>0</sub><em>b</em> = <em>mc</em> − <em>q</em><sub>0</sub><em>nc</em> = (<em>m</em> − <em>q</em><sub>0</sub><em>n</em>)<em>c</em>. An analogous argument shows that <em>c</em> also divides the subsequent remainders <em>r</em><sub>1</sub>, <em>r</em><sub>2</sub>, etc. Therefore, the greatest common divisor <em>g</em> must divide <em>r</em><sub><em>N</em>−1</sub>, which implies that <em>g</em> ≤ <em>r</em><sub><em>N</em>−1</sub>. Since the first part of the argument showed the reverse (<em>r</em><sub><em>N</em>−1</sub> ≤ <em>g</em>), it follows that <em>g</em> = <em>r</em><sub><em>N</em>−1</sub>. Thus, <em>g</em> is the greatest common divisor of all the succeeding pairs:<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a><a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a></p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>
<h3 id="worked-example">Worked example</h3>
<figure><b>(Figure)</b>
<figcaption>Subtraction-based animation of the Euclidean algorithm. The initial rectangle has dimensions <em>a</em> = 1071 and <em>b</em> = 462. Squares of size 462×462 are placed within it leaving a 462×147 rectangle. This rectangle is tiled with 147×147 squares until a 21×147 rectangle is left, which in turn is tiled with 21×21 squares, leaving no uncovered area. The smallest square size, 21, is the GCD of 1071 and 462.</figcaption>
</figure>

<p>For illustration, the Euclidean algorithm can be used to find the greatest common divisor of <em>a</em> = 1071 and <em>b</em> = 462. To begin, multiples of 462 are subtracted from 1071 until the remainder is less than 462. Two such multiples can be subtracted (<em>q</em><sub>0</sub> = 2), leaving a remainder of 147:</p>
<dl>
<dd>

<math display="inline" id="Euclidean_algorithm:2">
 <semantics>
  <mrow>
   <mn>1071</mn>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>2</mn>
     <mi mathvariant="normal">×</mi>
     <mn>462</mn>
    </mrow>
    <mo>+</mo>
    <mn>147.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <cn type="integer">1071</cn>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">2</cn>
      <ci>normal-×</ci>
      <cn type="integer">462</cn>
     </apply>
     <cn type="float">147.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1071=2×462+147.
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>Then multiples of 147 are subtracted from 462 until the remainder is less than 147. Three multiples can be subtracted (<em>q</em><sub>1</sub> = 3), leaving a remainder of 21:</p>
<dl>
<dd>

<math display="inline" id="Euclidean_algorithm:3">
 <semantics>
  <mrow>
   <mn>462</mn>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>3</mn>
     <mi mathvariant="normal">×</mi>
     <mn>147</mn>
    </mrow>
    <mo>+</mo>
    <mn>21.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <cn type="integer">462</cn>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">3</cn>
      <ci>normal-×</ci>
      <cn type="integer">147</cn>
     </apply>
     <cn type="float">21.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   462=3×147+21.
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>Then multiples of 21 are subtracted from 147 until the remainder is less than 21. Seven multiples can be subtracted (<em>q</em><sub>2</sub> = 7), leaving no remainder:</p>
<dl>
<dd>

<math display="inline" id="Euclidean_algorithm:4">
 <semantics>
  <mrow>
   <mn>147</mn>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mn>7</mn>
     <mi mathvariant="normal">×</mi>
     <mn>21</mn>
    </mrow>
    <mo>+</mo>
    <mn>0.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <cn type="integer">147</cn>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <cn type="integer">7</cn>
      <ci>normal-×</ci>
      <cn type="integer">21</cn>
     </apply>
     <cn type="float">0.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   147=7×21+0.
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>Since the last remainder is zero, the algorithm ends with 21 as the greatest common divisor of 1071 and 462. This agrees with the gcd(1071, 462) found by prime factorization <a href="#Background" title="wikilink">above</a>. In tabular form, the steps are</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Step <em>k</em></p></th>
<th style="text-align: left;">
<p>Equation</p></th>
<th style="text-align: left;">
<p>Quotient and remainder</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>0</p></td>
<td style="text-align: left;">
<p><mtpl></mtpl></p></td>
<td style="text-align: left;">
<p><mtpl></mtpl></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p>1</p></td>
<td style="text-align: left;">
<p><mtpl></mtpl></p></td>
<td style="text-align: left;">
<p><mtpl></mtpl></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p>2</p></td>
<td style="text-align: left;">
<p><mtpl></mtpl></p></td>
<td style="text-align: left;">
<p><mtpl></mtpl>; algorithm ends</p></td>
</tr>
</tbody>
</table>
<h3 id="visualization">Visualization</h3>

<p>The Euclidean algorithm can be visualized in terms of the tiling analogy given above for the greatest common divisor.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a> Assume that we wish to cover an <em>a</em>-by-<em>b</em> rectangle with square tiles exactly, where <em>a</em> is the larger of the two numbers. We first attempt to tile the rectangle using <em>b</em>-by-<em>b</em> square tiles; however, this leaves an <em>r</em><sub>0</sub>-by-<em>b</em> residual rectangle untiled, where <em>r</em><sub>0</sub> 0-by-<em>r</em><sub>0</sub> square tiles. This leaves a second residual rectangle <em>r</em><sub>1</sub>-by-<em>r</em><sub>0</sub>, which we attempt to tile using <em>r</em><sub>1</sub>-by-<em>r</em><sub>1</sub> square tiles, and so on. The sequence ends when there is no residual rectangle, i.e., when the square tiles cover the previous residual rectangle exactly. The length of the sides of the smallest square tile is the GCD of the dimensions of the original rectangle. For example, the smallest square tile in the adjacent figure is 21-by-21 (shown in red), and 21 is the GCD of 1071 and 462, the dimensions of the original rectangle (shown in green).</p>
<h3 id="euclidean-division">Euclidean division</h3>

<p>At every step <em>k</em>, the Euclidean algorithm computes a quotient <em>q</em><sub><em>k</em></sub> and remainder <em>r</em><sub><em>k</em></sub> from two numbers <em>r</em><sub><em>k</em>−1</sub> and <em>r</em><sub><em>k</em>−2</sub></p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>where the <a href="absolute_value" title="wikilink">magnitude</a> of <em>r</em><sub><em>k</em></sub> is strictly less than that of <em>r</em><sub><em>k</em>−1</sub>. The theorem which underlies the definition of the <a href="Euclidean_division" title="wikilink">Euclidean division</a> ensures that such a quotient and remainder always exist and are unique.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a></p>

<p>In Euclid's original version of the algorithm, the quotient and remainder are found by repeated subtraction; that is, <em>r</em><sub><em>k</em>−1</sub> is subtracted from <em>r</em><sub><em>k</em>−2</sub> repeatedly until the remainder <em>r</em><sub><em>k</em></sub> is smaller than <em>r</em><sub><em>k</em>−1</sub>. After that <em>r</em><sub><em>k</em></sub> and <em>r</em><sub><em>k</em>−1</sub> are exchanged and the process is iterated. Euclidean division reduces all the steps between two exchanges into a single step, which is thus more efficient. Moreover, the quotients are not needed, thus one may replace Euclidean division by the <a href="modulo_operation" title="wikilink">modulo operation</a>, which gives only the remainder. Thus the iteration of the Euclidean algorithm becomes simply</p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>
<h3 id="implementations">Implementations</h3>

<p>Implementations of the algorithm may be expressed in <a class="uri" href="pseudocode" title="wikilink">pseudocode</a>. For example, the division-based version may be <a href="computer_programming" title="wikilink">programmed</a> as<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a></p>

<p><strong><code>function</code></strong><code> gcd(a, b)</code><br/>
<code>    </code><strong><code>while</code></strong><code> b ≠ 0</code><br/>
<code>       t := b</code><br/>
<code>       b := a </code><strong><code>mod</code></strong><code> b</code><br/>
<code>       a := t</code><br/>
<code>    </code><strong><code>return</code></strong><code> a</code></p>

<p>At the beginning of the <em>k</em>th iteration, the variable <em>b</em> holds the latest remainder <em>r</em><sub><em>k</em>−1</sub>, whereas the variable <em>a</em> holds its predecessor, <em>r</em><sub><em>k</em>−2</sub>. The step <em>b</em> := <em>a</em> mod <em>b</em> is equivalent to the above recursion formula <em>r</em><sub><em>k</em></sub> ≡ <em>r</em><sub><em>k</em>−2</sub> mod <em>r</em><sub><em>k</em>−1</sub>. The <a href="temporary_variable" title="wikilink">temporary variable</a> <em>t</em> holds the value of <em>r</em><sub><em>k</em>−1</sub> while the next remainder <em>r</em><sub><em>k</em></sub> is being calculated. At the end of the loop iteration, the variable <em>b</em> holds the remainder <em>r</em><sub><em>k</em></sub>, whereas the variable <em>a</em> holds its predecessor, <em>r</em><sub><em>k</em>−1</sub>.</p>

<p>In the subtraction-based version which was Euclid's original version, the remainder calculation (<em>b</em> = <em>a</em> mod <em>b</em>) is replaced by repeated subtraction.<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> Contrary to the division-based version, which works with arbitrary integers as input, the subtraction-based version supposes that the input consists of positive integers and stops when <em>a</em> = <em>b</em>:</p>

<p><strong><code>function</code></strong><code> gcd(a, b)</code><br/>
<code>    </code><strong><code>while</code></strong><code> a ≠ b</code><br/>
<code>        </code><strong><code>if</code></strong><code> a &gt; b</code><br/>
<code>           a := a − b</code><br/>
<code>        </code><strong><code>else</code></strong><br/>
<code>           b := b − a</code><br/>
<code>    </code><strong><code>return</code></strong><code> a</code></p>

<p>The variables <em>a</em> and <em>b</em> alternate holding the previous remainders <em>r</em><sub><em>k</em>−1</sub> and <em>r</em><sub><em>k</em>−2</sub>. Assume that <em>a</em> is larger than <em>b</em> at the beginning of an iteration; then <em>a</em> equals <em>r</em><sub><em>k</em>−2</sub>, since <em>r</em><sub><em>k</em>−2</sub> &gt; <em>r</em><sub><em>k</em>−1</sub>. During the loop iteration, <em>a</em> is reduced by multiples of the previous remainder <em>b</em> until <em>a</em> is smaller than <em>b</em>. Then <em>a</em> is the next remainder <em>r</em><sub><em>k</em></sub>. Then <em>b</em> is reduced by multiples of <em>a</em> until it is again smaller than <em>a</em>, giving the next remainder <em>r</em><sub><em>k</em>+1</sub>, and so on.</p>

<p>The recursive version<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> is based on the equality of the GCDs of successive remainders and the stopping condition gcd(<em>r</em><sub><em>N</em>−1</sub>, 0) = <em>r</em><sub><em>N</em>−1</sub>.</p>

<p><strong><code>function</code></strong><code> gcd(a, b)</code><br/>
<code>    </code><strong><code>if</code></strong><code> b = 0</code><br/>
<code>       </code><strong><code>return</code></strong><code> a</code><br/>
<code>    </code><strong><code>else</code></strong><br/>
<code>       </code><strong><code>return</code></strong><code> gcd(b, a </code><strong><code>mod</code></strong><code> b)</code></p>

<p>For illustration, the gcd(1071, 462) is calculated from the equivalent gcd(462, 1071 mod 462) = gcd(462, 147). The latter GCD is calculated from the gcd(147, 462 mod 147) = gcd(147, 21), which in turn is calculated from the gcd(21, 147 mod 21) = gcd(21, 0) = 21.</p>
<h3 id="method-of-least-absolute-remainders">Method of least absolute remainders</h3>

<p>In another version of Euclid's algorithm, the quotient at each step is increased by one if the resulting negative remainder is smaller in magnitude than the typical positive remainder.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a><a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> Previously, the equation</p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>assumed that <mtpl><em>r</em><sub><em>k</em>−1</sub>{{!}} &gt; <em>r</em><sub><em>k</em></sub> &gt; 0}}</mtpl>. However, an alternative negative remainder <mtpl></mtpl> can be computed:</p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>if <mtpl></mtpl> or</p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>if <mtpl></mtpl>.</p>

<p>If <mtpl></mtpl> is replaced by <mtpl></mtpl> when <mtpl><em>e</em><sub><em>k</em></sub>{{!}} <em>k</em>{{!}}}}</mtpl>, then one gets a variant of Euclidean algorithm such that</p>
<dl>
<dd><mtpl><em>r</em><sub><em>k</em></sub>{{!}} ≤ {{!}}<em>r</em><sub><em>k</em>−1</sub>{{!}} / 2 }}</mtpl>
</dd>
</dl>

<p>at each step.</p>

<p><a href="Leopold_Kronecker" title="wikilink">Leopold Kronecker</a> has shown that this version requires the least number of steps of any version of Euclid's algorithm.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a><a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a> More generally, it has been proven that, for every input numbers <em>a</em> and <em>b</em>, the number of steps is minimal if and only if <mtpl></mtpl> is chosen in order that 

<math display="inline" id="Euclidean_algorithm:5">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>|</mo>
     <mfrac>
      <msub>
       <mi>r</mi>
       <mrow>
        <mi>k</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <msub>
       <mi>r</mi>
       <mi>k</mi>
      </msub>
     </mfrac>
     <mo>|</mo>
    </mrow>
    <mo><</mo>
    <mfrac>
     <mn>1</mn>
     <mi>φ</mi>
    </mfrac>
    <mo>∼</mo>
    <mn>0.618</mn>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <lt></lt>
     <apply>
      <abs></abs>
      <apply>
       <divide></divide>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <apply>
         <plus></plus>
         <ci>k</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>r</ci>
        <ci>k</ci>
       </apply>
      </apply>
     </apply>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>φ</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">similar-to</csymbol>
     <share href="#.cmml">
     </share>
     <cn type="float">0.618</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \left|\frac{r_{k+1}}{r_{k}}\right|<\frac{1}{\varphi}\sim 0.618,
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Euclidean_algorithm:6">
 <semantics>
  <mi>φ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>φ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \varphi
  </annotation>
 </semantics>
</math>

 is the <a href="golden_ratio" title="wikilink">golden ratio</a>.<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>
<h2 id="historical-development">Historical development</h2>
<figure><b>(Figure)</b>
<figcaption>The Euclidean algorithm was probably invented centuries before <a class="uri" href="Euclid" title="wikilink">Euclid</a>, shown here holding a <a href="Compass_(drawing_tool)" title="wikilink">compass</a>.</figcaption>
</figure>

<p>The Euclidean algorithm is one of the oldest algorithms in common use.<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> It appears in <a href="Euclid's_Elements" title="wikilink">Euclid's <em>Elements</em></a> (c. 300 BC), specifically in Book 7 (Propositions 1–2) and Book 10 (Propositions 2–3). In Book 7, the algorithm is formulated for integers, whereas in Book 10, it is formulated for lengths of line segments. (In modern usage, one would say it was formulated there for <a href="real_number" title="wikilink">real numbers</a>. But lengths, areas, and volumes, represented as real numbers in modern usage, are not measured in the same units and there is no natural unit of length, area, or volume; the concept of real numbers was unknown at that time.) The latter algorithm is geometrical. The GCD of two lengths <em>a</em> and <em>b</em> corresponds to the greatest length <em>g</em> that measures <em>a</em> and <em>b</em> evenly; in other words, the lengths <em>a</em> and <em>b</em> are both integer multiples of the length <em>g</em>.</p>

<p>The algorithm was probably not discovered by <a class="uri" href="Euclid" title="wikilink">Euclid</a>, who compiled results from earlier mathematicians in his <em>Elements</em>.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a><a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> The mathematician and historian <a href="Bartel_Leendert_van_der_Waerden" title="wikilink">B. L. van der Waerden</a> suggests that Book VII derives from a textbook on <a href="number_theory" title="wikilink">number theory</a> written by mathematicians in the school of <a class="uri" href="Pythagoras" title="wikilink">Pythagoras</a>.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> The algorithm was probably known by <a href="Eudoxus_of_Cnidus" title="wikilink">Eudoxus of Cnidus</a> (about 375 BC).<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a><a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> The algorithm may even pre-date Eudoxus,<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a><a class="footnoteRef" href="#fn34" id="fnref34"><sup>34</sup></a> judging from the use of the technical term ἀνθυφαίρεσις (<em>anthyphairesis</em>, reciprocal subtraction) in works by Euclid and Aristotle.<a class="footnoteRef" href="#fn35" id="fnref35"><sup>35</sup></a></p>

<p>Centuries later, Euclid's algorithm was discovered independently both in India and in China,<a class="footnoteRef" href="#fn36" id="fnref36"><sup>36</sup></a> primarily to solve <a href="Diophantine_equation" title="wikilink">Diophantine equations</a> that arise in astronomy and making accurate calendars. In the late 5th century, the Indian mathematician and astronomer <a class="uri" href="Aryabhata" title="wikilink">Aryabhata</a> described the algorithm as the "pulverizer",<a class="footnoteRef" href="#fn37" id="fnref37"><sup>37</sup></a> perhaps because of its effectiveness in solving Diophantine equations.<a class="footnoteRef" href="#fn38" id="fnref38"><sup>38</sup></a> Although a special case of the <a href="Chinese_remainder_theorem" title="wikilink">Chinese remainder theorem</a> had already been described by Chinese mathematician and astronomer <a href="Sun_Tzu_(mathematician)" title="wikilink">Sun Tzu</a>,<a class="footnoteRef" href="#fn39" id="fnref39"><sup>39</sup></a> the general solution was published by <a href="Qin_Jiushao" title="wikilink">Qin Jiushao</a> in his 1247 book <em>Shushu Jiuzhang</em> (數書九章 <em><a href="Mathematical_Treatise_in_Nine_Sections" title="wikilink">Mathematical Treatise in Nine Sections</a></em>).<a class="footnoteRef" href="#fn40" id="fnref40"><sup>40</sup></a> The Euclidean algorithm was first described in Europe in the second edition of <a href="Claude_Gaspard_Bachet_de_Méziriac" title="wikilink">Bachet's</a> <em>Problèmes plaisants et délectables</em> (<em>Pleasant and enjoyable problems</em>, 1624).<a class="footnoteRef" href="#fn41" id="fnref41"><sup>41</sup></a> In Europe, it was likewise used to solve Diophantine equations and in developing <a href="continued_fraction" title="wikilink">continued fractions</a>. The <a href="extended_Euclidean_algorithm" title="wikilink">extended Euclidean algorithm</a> was published by the English mathematician <a href="Nicholas_Saunderson" title="wikilink">Nicholas Saunderson</a>, who attributed it to <a href="Roger_Cotes" title="wikilink">Roger Cotes</a> as a method for computing continued fractions efficiently.<a class="footnoteRef" href="#fn42" id="fnref42"><sup>42</sup></a></p>

<p>In the 19th century, the Euclidean algorithm led to the development of new number systems, such as <a href="Gaussian_integer" title="wikilink">Gaussian integers</a> and <a href="Eisenstein_integer" title="wikilink">Eisenstein integers</a>. In 1815, <a href="Carl_Friedrich_Gauss" title="wikilink">Carl Gauss</a> used the Euclidean algorithm to demonstrate unique factorization of <a href="Gaussian_integer" title="wikilink">Gaussian integers</a>, although his work was first published in 1832.<a class="footnoteRef" href="#fn43" id="fnref43"><sup>43</sup></a> Gauss mentioned the algorithm in his <em><a href="Disquisitiones_Arithmeticae" title="wikilink">Disquisitiones Arithmeticae</a></em> (published 1801), but only as a method for <a href="continued_fraction" title="wikilink">continued fractions</a>.<a class="footnoteRef" href="#fn44" id="fnref44"><sup>44</sup></a> <a href="Peter_Gustav_Lejeune_Dirichlet" title="wikilink">Peter Gustav Lejeune Dirichlet</a> seems to have been the first to describe the Euclidean algorithm as the basis for much of number theory.<a class="footnoteRef" href="#fn45" id="fnref45"><sup>45</sup></a> Lejeune Dirichlet noted that many results of number theory, such as unique factorization, would hold true for any other system of numbers to which the Euclidean algorithm could be applied.<a class="footnoteRef" href="#fn46" id="fnref46"><sup>46</sup></a> Lejeune Dirichlet's lectures on number theory were edited and extended by <a href="Richard_Dedekind" title="wikilink">Richard Dedekind</a>, who used Euclid's algorithm to study <a href="algebraic_integer" title="wikilink">algebraic integers</a>, a new general type of number. For example, Dedekind was the first to prove <a href="Fermat's_theorem_on_sums_of_two_squares" title="wikilink">Fermat's two-square theorem</a> using the unique factorization of Gaussian integers.<a class="footnoteRef" href="#fn47" id="fnref47"><sup>47</sup></a> Dedekind also defined the concept of a <a href="Euclidean_domain" title="wikilink">Euclidean domain</a>, a number system in which a generalized version of the Euclidean algorithm can be defined (as described <a href="#Euclidean_domains" title="wikilink">below</a>). In the closing decades of the 19th century, the Euclidean algorithm gradually became eclipsed by Dedekind's more general theory of <a href="ideal_(ring_theory)" title="wikilink">ideals</a>.<a class="footnoteRef" href="#fn48" id="fnref48"><sup>48</sup></a></p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>"[The Euclidean algorithm] is the granddaddy of all algorithms, because it is the oldest nontrivial algorithm that has survived to the present day."</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><a href="Donald_Knuth" title="wikilink">Donald Knuth</a>, <em>The Art of Computer Programming, Vol. 2: Seminumerical Algorithms</em>, 2nd edition (1981), p. 318.</p></td>
</tr>
</tbody>
</table>

<p>Other applications of Euclid's algorithm were developed in the 19th century. In 1829, <a href="Jacques_Charles_François_Sturm" title="wikilink">Charles Sturm</a> showed that the algorithm was useful in the <a href="Sturm's_theorem" title="wikilink">Sturm chain</a> method for counting the real roots of polynomials in any given interval.<a class="footnoteRef" href="#fn49" id="fnref49"><sup>49</sup></a></p>

<p>The Euclidean algorithm was the first <a href="integer_relation_algorithm" title="wikilink">integer relation algorithm</a>, which is a method for finding integer relations between commensurate real numbers. Several novel <a href="integer_relation_algorithm" title="wikilink">integer relation algorithms</a> have been developed, such as the algorithm of <a href="Helaman_Ferguson" title="wikilink">Helaman Ferguson</a> and R.W. Forcade (1979)<a class="footnoteRef" href="#fn50" id="fnref50"><sup>50</sup></a> and the <a href="Lenstra–Lenstra–Lovász_lattice_basis_reduction_algorithm" title="wikilink">LLL algorithm</a>.<a class="footnoteRef" href="#fn51" id="fnref51"><sup>51</sup></a><a class="footnoteRef" href="#fn52" id="fnref52"><sup>52</sup></a></p>

<p>In 1969, Cole and Davie developed a two-player game based on the Euclidean algorithm, called <em>The Game of Euclid</em>,<a class="footnoteRef" href="#fn53" id="fnref53"><sup>53</sup></a> which has an optimal strategy.<a class="footnoteRef" href="#fn54" id="fnref54"><sup>54</sup></a> The players begin with two piles of <em>a</em> and <em>b</em> stones. The players take turns removing <em>m</em> multiples of the smaller pile from the larger. Thus, if the two piles consist of <em>x</em> and <em>y</em> stones, where <em>x</em> is larger than <em>y</em>, the next player can reduce the larger pile from <em>x</em> stones to <em>x</em> − <em>my</em> stones, as long as the latter is a nonnegative integer. The winner is the first player to reduce one pile to zero stones.<a class="footnoteRef" href="#fn55" id="fnref55"><sup>55</sup></a><a class="footnoteRef" href="#fn56" id="fnref56"><sup>56</sup></a></p>
<h2 id="mathematical-applications">Mathematical applications</h2>
<h3 id="bézouts-identity">Bézout's identity</h3>

<p><a href="Bézout's_identity" title="wikilink">Bézout's identity</a> states that the greatest common divisor <em>g</em> of two integers <em>a</em> and <em>b</em> can be represented as a linear sum of the original two numbers <em>a</em> and <em>b</em>.<a class="footnoteRef" href="#fn57" id="fnref57"><sup>57</sup></a> In other words, it is always possible to find integers <em>s</em> and <em>t</em> such that <em>g</em> = <em>sa</em> + <em>tb</em>.<a class="footnoteRef" href="#fn58" id="fnref58"><sup>58</sup></a><a class="footnoteRef" href="#fn59" id="fnref59"><sup>59</sup></a></p>

<p>The integers <em>s</em> and <em>t</em> can be calculated from the quotients <em>q</em><sub>0</sub>, <em>q</em><sub>1</sub>, etc. by reversing the order of equations in Euclid's algorithm.<a class="footnoteRef" href="#fn60" id="fnref60"><sup>60</sup></a> Beginning with the next-to-last equation, <em>g</em> can be expressed in terms of the quotient <em>q</em><sub><em>N</em>−1</sub> and the two preceding remainders, <em>r</em><sub><em>N</em>−2</sub> and <em>r</em><sub><em>N</em>−3</sub>:</p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>Those two remainders can be likewise expressed in terms of their quotients and preceding remainders,</p>
<dl>
<dd><mtpl></mtpl> and
</dd>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>Substituting these formulae for <em>r</em><sub><em>N</em>−2</sub> and <em>r</em><sub><em>N</em>−3</sub> into the first equation yields <em>g</em> as a linear sum of the remainders <em>r</em><sub><em>N</em>−4</sub> and <em>r</em><sub><em>N</em>−5</sub>. The process of substituting remainders by formulae involving their predecessors can be continued until the original numbers <em>a</em> and <em>b</em> are reached:</p>
<dl>
<dd><mtpl></mtpl>
</dd>
<dd><mtpl></mtpl>
</dd>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>After all the remainders <em>r</em><sub>0</sub>, <em>r</em><sub>1</sub>, etc. have been substituted, the final equation expresses <em>g</em> as a linear sum of <em>a</em> and <em>b</em>: <em>g</em> = <em>sa</em> + <em>tb</em>. <a href="Bézout's_identity" title="wikilink">Bézout's identity</a>, and therefore the previous algorithm, can both be generalized to the context of <a href="Euclidean_domain" title="wikilink">Euclidean domains</a>.</p>
<h3 id="principal-ideals-and-related-problems">Principal ideals and related problems</h3>

<p>Bézout's identity provides yet another definition of the greatest common divisor <em>g</em> of two numbers <em>a</em> and <em>b</em>.<a class="footnoteRef" href="#fn61" id="fnref61"><sup>61</sup></a> Consider the set of all numbers <em>ua</em> + <em>vb</em>, where <em>u</em> and <em>v</em> are any two integers. Since <em>a</em> and <em>b</em> are both divisible by <em>g</em>, every number in the set is divisible by <em>g</em>. In other words, every number of the set is an integer multiple of <em>g</em>. This is true for every common divisor of <em>a</em> and <em>b</em>. However, unlike other common divisors, the greatest common divisor is a member of the set; by Bézout's identity, choosing <em>u</em> = <em>s</em> and <em>v</em> = <em>t</em> gives <em>g</em>. A smaller common divisor cannot be a member of the set, since every member of the set must be divisible by <em>g</em>. Conversely, any multiple <em>m</em> of <em>g</em> can be obtained by choosing <em>u</em> = <em>ms</em> and <em>v</em> = <em>mt</em>, where <em>s</em> and <em>t</em> are the integers of Bézout's identity. This may be seen by multiplying Bézout's identity by <em>m</em>,</p>
<dl>
<dd>

<math display="inline" id="Euclidean_algorithm:7">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>m</mi>
     <mi>g</mi>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>m</mi>
      <mi>s</mi>
      <mi>a</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>m</mi>
      <mi>t</mi>
      <mi>b</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>m</ci>
     <ci>g</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>s</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>t</ci>
      <ci>b</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   mg=msa+mtb.
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>Therefore, the set of all numbers <em>ua</em> + <em>vb</em> is equivalent to the set of multiples <em>m</em> of <em>g</em>. In other words, the set of all possible sums of integer multiples of two numbers (<em>a</em> and <em>b</em>) is equivalent to the set of multiples of gcd(<em>a</em>, <em>b</em>). The GCD is said to be the generator of the <a href="ideal_(ring_theory)" title="wikilink">ideal</a> of <em>a</em> and <em>b</em>. This GCD definition led to the modern <a href="abstract_algebra" title="wikilink">abstract algebraic</a> concepts of a <a href="principal_ideal" title="wikilink">principal ideal</a> (an ideal generated by a single element) and a <a href="principal_ideal_domain" title="wikilink">principal ideal domain</a> (a <a href="domain_(ring_theory)" title="wikilink">domain</a> in which every ideal is a principal ideal).</p>

<p>Certain problems can be solved using this result.<a class="footnoteRef" href="#fn62" id="fnref62"><sup>62</sup></a> For example, consider two measuring cups of volume <em>a</em> and <em>b</em>. By adding/subtracting <em>u</em> multiples of the first cup and <em>v</em> multiples of the second cup, any volume <em>ua</em> + <em>vb</em> can be measured out. These volumes are all multiples of <em>g</em> = gcd(<em>a</em>, <em>b</em>).</p>
<h3 id="extended-euclidean-algorithm">Extended Euclidean algorithm</h3>

<p>The integers <em>s</em> and <em>t</em> of Bézout's identity can be computed efficiently using the <a href="extended_Euclidean_algorithm" title="wikilink">extended Euclidean algorithm</a>. This extension adds two recursive equations to Euclid's algorithm<a class="footnoteRef" href="#fn63" id="fnref63"><sup>63</sup></a></p>
<dl>
<dd><mtpl></mtpl>
</dd>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>with the starting values</p>
<dl>
<dd><mtpl></mtpl>
</dd>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>Using this recursion, Bézout's integers <em>s</em> and <em>t</em> are given by <em>s</em> = <em>s</em><sub><em>N</em></sub> and <em>t</em> = <em>t</em><sub><em>N</em></sub>, where <em>N+1</em> is the step on which the algorithm terminates with <em>r</em><sub><em>N+1</em></sub> = 0.</p>

<p>The validity of this approach can be shown by induction. Assume that the recursion formula is correct up to step <em>k</em> − 1 of the algorithm; in other words, assume that</p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>for all <em>j</em> less than <em>k</em>. The <em>k</em>th step of the algorithm gives the equation</p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>Since the recursion formula has been assumed to be correct for <em>r</em><sub><em>k</em>−2</sub> and <em>r</em><sub><em>k</em>−1</sub>, they may be expressed in terms of the corresponding <em>s</em> and <em>t</em> variables</p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>Rearranging this equation yields the recursion formula for step <em>k</em>, as required</p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>
<h3 id="matrix-method">Matrix method</h3>

<p>The integers <em>s</em> and <em>t</em> can also be found using an equivalent <a href="matrix_(mathematics)" title="wikilink">matrix</a> method.<a class="footnoteRef" href="#fn64" id="fnref64"><sup>64</sup></a> The sequence of equations of Euclid's algorithm</p>
<dl>
<dd><mtpl></mtpl>
</dd>
<dd><mtpl></mtpl>
</dd>
<dd>

<math display="inline" id="Euclidean_algorithm:8">
 <semantics>
  <mi mathvariant="normal">…</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-…</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   …
  </annotation>
 </semantics>
</math>


</dd>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>can be written as a product of 2-by-2 quotient matrices multiplying a two-dimensional remainder vector</p>

<p>

<math display="block" id="Euclidean_algorithm:9">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mi>a</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi>b</mi>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>q</mi>
          <mn>0</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mi>b</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>r</mi>
          <mn>0</mn>
         </msub>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>q</mi>
          <mn>0</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>q</mi>
          <mn>1</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>r</mi>
          <mn>0</mn>
         </msub>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>r</mi>
          <mn>1</mn>
         </msub>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mi mathvariant="normal">⋯</mi>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi>N</mi>
     </munderover>
     <mrow>
      <mrow>
       <mo>(</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <msub>
           <mi>q</mi>
           <mi>i</mi>
          </msub>
         </mtd>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
        </mtr>
       </mtable>
       <mo>)</mo>
      </mrow>
      <mpadded width="+1.7pt">
       <mrow>
        <mo>(</mo>
        <mtable displaystyle="true">
         <mtr>
          <mtd columnalign="center">
           <msub>
            <mi>r</mi>
            <mrow>
             <mi>N</mi>
             <mo>-</mo>
             <mn>1</mn>
            </mrow>
           </msub>
          </mtd>
         </mtr>
         <mtr>
          <mtd columnalign="center">
           <mn>0</mn>
          </mtd>
         </mtr>
        </mtable>
        <mo>)</mo>
       </mrow>
      </mpadded>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <matrix>
      <matrixrow>
       <ci>a</ci>
      </matrixrow>
      <matrixrow>
       <ci>b</ci>
      </matrixrow>
     </matrix>
     <apply>
      <times></times>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>q</ci>
         <cn type="integer">0</cn>
        </apply>
        <cn type="integer">1</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
       </matrixrow>
      </matrix>
      <matrix>
       <matrixrow>
        <ci>b</ci>
       </matrixrow>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <cn type="integer">0</cn>
        </apply>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>q</ci>
         <cn type="integer">0</cn>
        </apply>
        <cn type="integer">1</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
       </matrixrow>
      </matrix>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>q</ci>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">1</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
       </matrixrow>
      </matrix>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <cn type="integer">0</cn>
        </apply>
       </matrixrow>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <cn type="integer">1</cn>
        </apply>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>normal-⋯</ci>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <apply>
       <times></times>
       <matrix>
        <matrixrow>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>q</ci>
          <ci>i</ci>
         </apply>
         <cn type="integer">1</cn>
        </matrixrow>
        <matrixrow>
         <cn type="integer">1</cn>
         <cn type="integer">0</cn>
        </matrixrow>
       </matrix>
       <matrix>
        <matrixrow>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>r</ci>
          <apply>
           <minus></minus>
           <ci>N</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </matrixrow>
        <matrixrow>
         <cn type="integer">0</cn>
        </matrixrow>
       </matrix>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{pmatrix}a\\
b\end{pmatrix}=\begin{pmatrix}q_{0}&1\\
1&0\end{pmatrix}\begin{pmatrix}b\\
r_{0}\end{pmatrix}=\begin{pmatrix}q_{0}&1\\
1&0\end{pmatrix}\begin{pmatrix}q_{1}&1\\
1&0\end{pmatrix}\begin{pmatrix}r_{0}\\
r_{1}\end{pmatrix}=\cdots=\prod_{i=0}^{N}\begin{pmatrix}q_{i}&1\\
1&0\end{pmatrix}\begin{pmatrix}r_{N-1}\\
0\end{pmatrix}\,.
  </annotation>
 </semantics>
</math>

</p>

<p>Let <strong>M</strong> represent the product of all the quotient matrices</p>

<p>

<math display="block" id="Euclidean_algorithm:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>𝐌</mi>
    <mo>=</mo>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>m</mi>
         <mn>11</mn>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>m</mi>
         <mn>12</mn>
        </msub>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <msub>
         <mi>m</mi>
         <mn>21</mn>
        </msub>
       </mtd>
       <mtd columnalign="center">
        <msub>
         <mi>m</mi>
         <mn>22</mn>
        </msub>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <munderover>
      <mo largeop="true" movablelimits="false" symmetric="true">∏</mo>
      <mrow>
       <mi>i</mi>
       <mo>=</mo>
       <mn>0</mn>
      </mrow>
      <mi>N</mi>
     </munderover>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>q</mi>
          <mi>i</mi>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>q</mi>
          <mn>0</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>q</mi>
          <mn>1</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>1</mn>
        </mtd>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
     <mi mathvariant="normal">⋯</mi>
     <mpadded width="+1.7pt">
      <mrow>
       <mo>(</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <msub>
           <mi>q</mi>
           <mi>N</mi>
          </msub>
         </mtd>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>1</mn>
         </mtd>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
        </mtr>
       </mtable>
       <mo>)</mo>
      </mrow>
     </mpadded>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>𝐌</ci>
     <matrix>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <cn type="integer">11</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <cn type="integer">12</cn>
       </apply>
      </matrixrow>
      <matrixrow>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <cn type="integer">21</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>m</ci>
        <cn type="integer">22</cn>
       </apply>
      </matrixrow>
     </matrix>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <csymbol cd="latexml">product</csymbol>
        <apply>
         <eq></eq>
         <ci>i</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
       <ci>N</ci>
      </apply>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>q</ci>
         <ci>i</ci>
        </apply>
        <cn type="integer">1</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>q</ci>
         <cn type="integer">0</cn>
        </apply>
        <cn type="integer">1</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
       </matrixrow>
      </matrix>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>q</ci>
         <cn type="integer">1</cn>
        </apply>
        <cn type="integer">1</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
       </matrixrow>
      </matrix>
      <ci>normal-⋯</ci>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>q</ci>
         <ci>N</ci>
        </apply>
        <cn type="integer">1</cn>
       </matrixrow>
       <matrixrow>
        <cn type="integer">1</cn>
        <cn type="integer">0</cn>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathbf{M}=\begin{pmatrix}m_{11}&m_{12}\\
m_{21}&m_{22}\end{pmatrix}=\prod_{i=0}^{N}\begin{pmatrix}q_{i}&1\\
1&0\end{pmatrix}=\begin{pmatrix}q_{0}&1\\
1&0\end{pmatrix}\begin{pmatrix}q_{1}&1\\
1&0\end{pmatrix}\cdots\begin{pmatrix}q_{N}&1\\
1&0\end{pmatrix}\,.
  </annotation>
 </semantics>
</math>

</p>

<p>This simplifies the Euclidean algorithm to the form</p>

<p>

<math display="block" id="Euclidean_algorithm:11">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mi>a</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mi>b</mi>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>𝐌</mi>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>r</mi>
          <mrow>
           <mi>N</mi>
           <mo>-</mo>
           <mn>1</mn>
          </mrow>
         </msub>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mn>0</mn>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mi>𝐌</mi>
     <mpadded width="+1.7pt">
      <mrow>
       <mo>(</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <mi>g</mi>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mn>0</mn>
         </mtd>
        </mtr>
       </mtable>
       <mo>)</mo>
      </mrow>
     </mpadded>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <matrix>
      <matrixrow>
       <ci>a</ci>
      </matrixrow>
      <matrixrow>
       <ci>b</ci>
      </matrixrow>
     </matrix>
     <apply>
      <times></times>
      <ci>𝐌</ci>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <apply>
          <minus></minus>
          <ci>N</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>𝐌</ci>
      <matrix>
       <matrixrow>
        <ci>g</ci>
       </matrixrow>
       <matrixrow>
        <cn type="integer">0</cn>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{pmatrix}a\\
b\end{pmatrix}=\mathbf{M}\begin{pmatrix}r_{N-1}\\
0\end{pmatrix}=\mathbf{M}\begin{pmatrix}g\\
0\end{pmatrix}\,.
  </annotation>
 </semantics>
</math>

</p>

<p>To express <em>g</em> as a linear sum of <em>a</em> and <em>b</em>, both sides of this equation can be multiplied by the <a href="invertible_matrix" title="wikilink">inverse</a> of the matrix <strong>M</strong>.<a class="footnoteRef" href="#fn65" id="fnref65"><sup>65</sup></a><a class="footnoteRef" href="#fn66" id="fnref66"><sup>66</sup></a> The <a class="uri" href="determinant" title="wikilink">determinant</a> of <strong>M</strong> equals (−1)<sup><em>N</em>+1</sup>, since it equals the product of the determinants of the quotient matrices, each of which is negative one. Since the determinant of <strong>M</strong> is never zero, the vector of the final remainders can be solved using the inverse of <strong>M</strong></p>

<p>

<math display="block" id="Euclidean_algorithm:12">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mtable displaystyle="true">
      <mtr>
       <mtd columnalign="center">
        <mi>g</mi>
       </mtd>
      </mtr>
      <mtr>
       <mtd columnalign="center">
        <mn>0</mn>
       </mtd>
      </mtr>
     </mtable>
     <mo>)</mo>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mi>𝐌</mi>
      <mrow>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <mi>a</mi>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mi>b</mi>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <msup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
      <mrow>
       <mi>N</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msup>
     <mrow>
      <mo>(</mo>
      <mtable displaystyle="true">
       <mtr>
        <mtd columnalign="center">
         <msub>
          <mi>m</mi>
          <mn>22</mn>
         </msub>
        </mtd>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <msub>
           <mi>m</mi>
           <mn>12</mn>
          </msub>
         </mrow>
        </mtd>
       </mtr>
       <mtr>
        <mtd columnalign="center">
         <mrow>
          <mo>-</mo>
          <msub>
           <mi>m</mi>
           <mn>21</mn>
          </msub>
         </mrow>
        </mtd>
        <mtd columnalign="center">
         <msub>
          <mi>m</mi>
          <mn>11</mn>
         </msub>
        </mtd>
       </mtr>
      </mtable>
      <mo>)</mo>
     </mrow>
     <mpadded width="+1.7pt">
      <mrow>
       <mo>(</mo>
       <mtable displaystyle="true">
        <mtr>
         <mtd columnalign="center">
          <mi>a</mi>
         </mtd>
        </mtr>
        <mtr>
         <mtd columnalign="center">
          <mi>b</mi>
         </mtd>
        </mtr>
       </mtable>
       <mo>)</mo>
      </mrow>
     </mpadded>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <matrix>
      <matrixrow>
       <ci>g</ci>
      </matrixrow>
      <matrixrow>
       <cn type="integer">0</cn>
      </matrixrow>
     </matrix>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <ci>𝐌</ci>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <matrix>
       <matrixrow>
        <ci>a</ci>
       </matrixrow>
       <matrixrow>
        <ci>b</ci>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <apply>
        <minus></minus>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <plus></plus>
        <ci>N</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <matrix>
       <matrixrow>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <cn type="integer">22</cn>
        </apply>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <cn type="integer">12</cn>
         </apply>
        </apply>
       </matrixrow>
       <matrixrow>
        <apply>
         <minus></minus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>m</ci>
          <cn type="integer">21</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>m</ci>
         <cn type="integer">11</cn>
        </apply>
       </matrixrow>
      </matrix>
      <matrix>
       <matrixrow>
        <ci>a</ci>
       </matrixrow>
       <matrixrow>
        <ci>b</ci>
       </matrixrow>
      </matrix>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \begin{pmatrix}g\\
0\end{pmatrix}=\mathbf{M}^{-1}\begin{pmatrix}a\\
b\end{pmatrix}=(-1)^{N+1}\begin{pmatrix}m_{22}&-m_{12}\\
-m_{21}&m_{11}\end{pmatrix}\begin{pmatrix}a\\
b\end{pmatrix}\,.
  </annotation>
 </semantics>
</math>

</p>

<p>Since the top equation gives</p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>the two integers of Bézout's identity are <em>s</em> = (−1)<sup><em>N</em>+1</sup><em>m</em><sub>22</sub> and <em>t</em> = (−1)<sup><em>N</em></sup><em>m</em><sub>12</sub>. The matrix method is as efficient as the equivalent recursion, with two multiplications and two additions per step of the Euclidean algorithm.</p>
<h3 id="euclids-lemma-and-unique-factorization">Euclid's lemma and unique factorization</h3>

<p>Bézout's identity is essential to many applications of Euclid's algorithm, such as demonstrating the <a href="Fundamental_theorem_of_arithmetic" title="wikilink">unique factorization</a> of numbers into prime factors.<a class="footnoteRef" href="#fn67" id="fnref67"><sup>67</sup></a> To illustrate this, suppose that a number <em>L</em> can be written as a product of two factors <em>u</em> and <em>v</em>, that is, <em>L</em> = <em>uv</em>. If another number <em>w</em> also divides <em>L</em> but is coprime with <em>u</em>, then <em>w</em> must divide <em>v</em>, by the following argument: If the greatest common divisor of <em>u</em> and <em>w</em> is 1, then integers <em>s</em> and <em>t</em> can be found such that</p>
<dl>
<dd>

<math display="inline" id="Euclidean_algorithm:13">
 <semantics>
  <mrow>
   <mrow>
    <mn>1</mn>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>s</mi>
      <mi>u</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>t</mi>
      <mi>w</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <cn type="integer">1</cn>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>u</ci>
     </apply>
     <apply>
      <times></times>
      <ci>t</ci>
      <ci>w</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   1=su+tw.
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>by Bézout's identity. Multiplying both sides by <em>v</em> gives the relation</p>
<dl>
<dd>

<math display="inline" id="Euclidean_algorithm:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>v</mi>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>s</mi>
      <mi>u</mi>
      <mi>v</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>t</mi>
      <mi>w</mi>
      <mi>v</mi>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mrow>
      <mi>s</mi>
      <mi>L</mi>
     </mrow>
     <mo>+</mo>
     <mrow>
      <mi>t</mi>
      <mi>w</mi>
      <mi>v</mi>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>v</ci>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>u</ci>
       <ci>v</ci>
      </apply>
      <apply>
       <times></times>
       <ci>t</ci>
       <ci>w</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <ci>s</ci>
       <ci>L</ci>
      </apply>
      <apply>
       <times></times>
       <ci>t</ci>
       <ci>w</ci>
       <ci>v</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   v=suv+twv=sL+twv.
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>Since <em>w</em> divides both terms on the right-hand side, it must also divide the left-hand side, <em>v</em>. This result is known as <a href="Euclid's_lemma" title="wikilink">Euclid's lemma</a>.<a class="footnoteRef" href="#fn68" id="fnref68"><sup>68</sup></a> Specifically, if a prime number divides <em>L</em>, then it must divide at least one factor of <em>L</em>. Conversely, if a number <em>w</em> is coprime to each of a series of numbers <em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, …, <em>a</em><sub><em>n</em></sub>, then <em>w</em> is also coprime to their product, <em>a</em><sub>1</sub> × <em>a</em><sub>2</sub> × … × <em>a</em><sub><em>n</em></sub>.<a class="footnoteRef" href="#fn69" id="fnref69"><sup>69</sup></a></p>

<p>Euclid's lemma suffices to prove that every number has a unique factorization into prime numbers.<a class="footnoteRef" href="#fn70" id="fnref70"><sup>70</sup></a> To see this, assume the contrary, that there are two independent factorizations of <em>L</em> into <em>m</em> and <em>n</em> prime factors, respectively</p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>Since each prime <em>p</em> divides <em>L</em> by assumption, it must also divide one of the <em>q</em> factors; since each <em>q</em> is prime as well, it must be that <em>p</em> = <em>q</em>. Iteratively dividing by the <em>p</em> factors shows that each <em>p</em> has an equal counterpart <em>q</em>; the two prime factorizations are identical except for their order. The unique factorization of numbers into primes has many applications in mathematical proofs, as shown below.</p>
<h3 id="linear-diophantine-equations">Linear Diophantine equations</h3>
<figure><b>(Figure)</b>
<figcaption>Plot of a linear <a href="Diophantine_equation" title="wikilink">Diophantine equation</a>, 9<em>x</em> + 12<em>y</em> = 483. The solutions are shown as blue circles.</figcaption>
</figure>

<p><a href="Diophantine_equation" title="wikilink">Diophantine equations</a> are equations in which the solutions are restricted to integers; they are named after the 3rd-century Alexandrian mathematician <a class="uri" href="Diophantus" title="wikilink">Diophantus</a>.<a class="footnoteRef" href="#fn71" id="fnref71"><sup>71</sup></a> A typical <em>linear</em> Diophantine equation seeks integers <em>x</em> and <em>y</em> such that<a class="footnoteRef" href="#fn72" id="fnref72"><sup>72</sup></a></p>
<dl>
<dd>

<math display="inline" id="Euclidean_algorithm:15">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>b</mi>
     <mi>y</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>c</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>b</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <ci>c</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ax+by=c
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>where <em>a</em>, <em>b</em> and <em>c</em> are given integers. This can be written as an equation for <em>x</em> in <a href="modular_arithmetic" title="wikilink">modular arithmetic</a>:</p>
<dl>
<dd>

<math display="inline" id="Euclidean_algorithm:16">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mi>x</mi>
    <mi mathvariant="normal">≡</mi>
    <mi>c</mi>
    <mi>m</mi>
    <mi>o</mi>
    <mi>d</mi>
    <mi>b</mi>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>a</ci>
    <ci>x</ci>
    <ci>normal-≡</ci>
    <ci>c</ci>
    <ci>m</ci>
    <ci>o</ci>
    <ci>d</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ax≡cmodb.
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>Let <em>g</em> be the greatest common divisor of <em>a</em> and <em>b</em>. Both terms in <em>ax</em> + <em>by</em> are divisible by <em>g</em>; therefore, <em>c</em> must also be divisible by <em>g</em>, or the equation has no solutions. By dividing both sides by <em>c</em>/<em>g</em>, the equation can be reduced to Bezout's identity</p>
<dl>
<dd>

<math display="inline" id="Euclidean_algorithm:17">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>s</mi>
     <mi>a</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>t</mi>
     <mi>b</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>g</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>s</ci>
      <ci>a</ci>
     </apply>
     <apply>
      <times></times>
      <ci>t</ci>
      <ci>b</ci>
     </apply>
    </apply>
    <ci>g</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   sa+tb=g
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>where <em>s</em> and <em>t</em> can be found by the <a href="extended_Euclidean_algorithm" title="wikilink">extended Euclidean algorithm</a>.<a class="footnoteRef" href="#fn73" id="fnref73"><sup>73</sup></a> This provides one solution to the Diophantine equation, <em>x</em><sub>1</sub> = <em>s</em> (<em>c</em>/<em>g</em>) and <em>y</em><sub>1</sub> = <em>t</em> (<em>c</em>/<em>g</em>).</p>

<p>In general, a linear Diophantine equation has no solutions, or an infinite number of solutions.<a class="footnoteRef" href="#fn74" id="fnref74"><sup>74</sup></a> To find the latter, consider two solutions, (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>) and (<em>x</em><sub>2</sub>, <em>y</em><sub>2</sub>), where</p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>or equivalently</p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>Therefore, the smallest difference between two <em>x</em> solutions is <em>b</em>/<em>g</em>, whereas the smallest difference between two <em>y</em> solutions is <em>a</em>/<em>g</em>. Thus, the solutions may be expressed as</p>
<dl>
<dd><mtpl></mtpl>
</dd>
<dd><mtpl></mtpl>.
</dd>
</dl>

<p>By allowing <em>u</em> to vary over all possible integers, an infinite family of solutions can be generated from a single solution (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>). If the solutions are required to be <em>positive</em> integers (<em>x</em> &gt; 0, <em>y</em> &gt; 0), only a finite number of solutions may be possible. This restriction on the acceptable solutions allows some systems of Diophantine equations with more unknowns than equations to have a finite number of solutions;<a class="footnoteRef" href="#fn75" id="fnref75"><sup>75</sup></a> this is impossible for a <a href="system_of_linear_equations" title="wikilink">system of linear equations</a> when the solutions can be any <a href="real_number" title="wikilink">real number</a> (see <a href="Underdetermined_system" title="wikilink">Underdetermined system</a>).</p>
<h3 id="multiplicative-inverses-and-the-rsa-algorithm">Multiplicative inverses and the RSA algorithm</h3>

<p>A <a href="finite_field" title="wikilink">finite field</a> is a set of numbers with four generalized operations. The operations are called addition, subtraction, multiplication and division and have their usual properties, such as <a class="uri" href="commutativity" title="wikilink">commutativity</a>, <a class="uri" href="associativity" title="wikilink">associativity</a> and <a class="uri" href="distributivity" title="wikilink">distributivity</a>. An example of a finite field is the set of 13 numbers {0, 1, 2, …, 12} using <a href="modular_arithmetic" title="wikilink">modular arithmetic</a>. In this field, the results of any mathematical operation (addition, subtraction, multiplication, or division) is reduced <a href="modulo_operation" title="wikilink">modulo</a> 13; that is, multiples of 13 are added or subtracted until the result is brought within the range 0–12. For example, the result of 5 × 7 = 35 mod 13 = 9. Such finite fields can be defined for any prime <em>p</em>; using more sophisticated definitions, they can also be defined for any power <em>m</em> of a prime <em>p</em><sup> <em>m</em></sup>. Finite fields are often called <a href="Évariste_Galois" title="wikilink">Galois</a> fields, and are abbreviated as GF(<em>p</em>) or GF(<em>p</em><sup> <em>m</em></sup>).</p>

<p>In such a field with <em>m</em> numbers, every nonzero element <em>a</em> has a unique <a href="modular_multiplicative_inverse" title="wikilink">modular multiplicative inverse</a>, <em>a</em><sup>−1</sup> such that <mtpl></mtpl> This inverse can be found by solving the congruence equation <em>ax</em> ≡ 1 mod <em>m</em>,<a class="footnoteRef" href="#fn76" id="fnref76"><sup>76</sup></a> or the equivalent linear Diophantine equation<a class="footnoteRef" href="#fn77" id="fnref77"><sup>77</sup></a></p>
<dl>
<dd>

<math display="inline" id="Euclidean_algorithm:18">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>a</mi>
     <mi>x</mi>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mi>m</mi>
     <mi>y</mi>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mn>1.</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <ci>a</ci>
      <ci>x</ci>
     </apply>
     <apply>
      <times></times>
      <ci>m</ci>
      <ci>y</ci>
     </apply>
    </apply>
    <cn type="float">1.</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   ax+my=1.
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>This equation can be solved by the Euclidean algorithm, as described <a href="#Linear_Diophantine_equations" title="wikilink">above</a>. Finding multiplicative inverses is an essential step in the <a href="RSA_algorithm" title="wikilink">RSA algorithm</a>, which is widely used in <a href="electronic_commerce" title="wikilink">electronic commerce</a>; specifically, the equation determines the integer used to decrypt the message.<a class="footnoteRef" href="#fn78" id="fnref78"><sup>78</sup></a> Note that although the RSA algorithm uses <a href="ring_(mathematics)" title="wikilink">rings</a> rather than fields, the Euclidean algorithm can still be used to find a multiplicative inverse where one exists. The Euclidean algorithm also has other applications in <a href="error-correcting_code" title="wikilink">error-correcting codes</a>; for example, it can be used as an alternative to the <a href="Berlekamp–Massey_algorithm" title="wikilink">Berlekamp–Massey algorithm</a> for decoding <a href="BCH_code" title="wikilink">BCH</a> and <a href="Reed–Solomon_code" title="wikilink">Reed–Solomon codes</a>, which are based on Galois fields.<a class="footnoteRef" href="#fn79" id="fnref79"><sup>79</sup></a></p>
<h3 id="chinese-remainder-theorem">Chinese remainder theorem</h3>

<p>Euclid's algorithm can also be used to solve multiple linear Diophantine equations.<a class="footnoteRef" href="#fn80" id="fnref80"><sup>80</sup></a> Such equations arise in the <a href="Chinese_remainder_theorem" title="wikilink">Chinese remainder theorem</a>, which describes a novel method to represent an integer <em>x</em>. Instead of representing an integer by its digits, it may be represented by its remainders <em>x</em><sub><em>i</em></sub> modulo a set of <em>N</em> coprime numbers <em>m</em><sub><em>i</em></sub>:<a class="footnoteRef" href="#fn81" id="fnref81"><sup>81</sup></a></p>

<p>

<math display="inline" id="Euclidean_algorithm:19">
 <semantics>
  <msub>
   <mi>x</mi>
   <mn>1</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>x</ci>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle x_{1}
  </annotation>
 </semantics>
</math>


</p>

<p>The goal is to determine <em>x</em> from its <em>N</em> remainders <em>x</em><sub><em>i</em></sub>. The solution is to combine the multiple equations into a single linear Diophantine equation with a much larger modulus <em>M</em> that is the product of all the individual moduli <em>m</em><sub><em>i</em></sub>, and define <em>M</em><sub><em>i</em></sub> as</p>

<p>

<math display="block" id="Euclidean_algorithm:20">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>M</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mfrac>
     <mi>M</mi>
     <msub>
      <mi>m</mi>
      <mi>i</mi>
     </msub>
    </mfrac>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <divide></divide>
     <ci>M</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{i}=\frac{M}{m_{i}}.
  </annotation>
 </semantics>
</math>

</p>

<p>Thus, each <em>M</em><sub><em>i</em></sub> is the product of all the moduli <em>except</em> <em>m</em><sub><em>i</em></sub>. The solution depends on finding <em>N</em> new numbers <em>h</em><sub><em>i</em></sub> such that</p>

<p>

<math display="block" id="Euclidean_algorithm:21">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <msub>
      <mi>M</mi>
      <mi>i</mi>
     </msub>
     <msub>
      <mi>h</mi>
      <mi>i</mi>
     </msub>
    </mrow>
    <mo>≡</mo>
    <mrow>
     <mn>1</mn>
     <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
     <mpadded width="+1.7pt">
      <msub>
       <mi>m</mi>
       <mi>i</mi>
      </msub>
     </mpadded>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>h</ci>
      <ci>i</ci>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <cn type="integer">1</cn>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>m</ci>
      <ci>i</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{i}h_{i}\equiv 1\bmod m_{i}\,.
  </annotation>
 </semantics>
</math>

</p>

<p>With these numbers <em>h</em><sub><em>i</em></sub>, any integer <em>x</em> can be reconstructed from its remainders <em>x</em><sub><em>i</em></sub> by the equation</p>

<p>

<math display="block" id="Euclidean_algorithm:22">
 <semantics>
  <mrow>
   <mrow>
    <mi>x</mi>
    <mo>≡</mo>
    <mrow>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <msub>
         <mi>x</mi>
         <mn>1</mn>
        </msub>
        <msub>
         <mi>M</mi>
         <mn>1</mn>
        </msub>
        <msub>
         <mi>h</mi>
         <mn>1</mn>
        </msub>
       </mrow>
       <mo>+</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mn>2</mn>
        </msub>
        <msub>
         <mi>M</mi>
         <mn>2</mn>
        </msub>
        <msub>
         <mi>h</mi>
         <mn>2</mn>
        </msub>
       </mrow>
       <mo>+</mo>
       <mi mathvariant="normal">⋯</mi>
       <mo>+</mo>
       <mrow>
        <msub>
         <mi>x</mi>
         <mi>N</mi>
        </msub>
        <msub>
         <mi>M</mi>
         <mi>N</mi>
        </msub>
        <msub>
         <mi>h</mi>
         <mi>N</mi>
        </msub>
       </mrow>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
     <mo lspace="2.5pt" rspace="2.5pt">mod</mo>
     <mpadded width="+1.7pt">
      <mi>M</mi>
     </mpadded>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <equivalent></equivalent>
    <ci>x</ci>
    <apply>
     <csymbol cd="latexml">modulo</csymbol>
     <apply>
      <plus></plus>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <cn type="integer">2</cn>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <ci>normal-⋯</ci>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>x</ci>
        <ci>N</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>M</ci>
        <ci>N</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>h</ci>
        <ci>N</ci>
       </apply>
      </apply>
     </apply>
     <ci>M</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x\equiv(x_{1}M_{1}h_{1}+x_{2}M_{2}h_{2}+\cdots+x_{N}M_{N}h_{N})\bmod M\,.
  </annotation>
 </semantics>
</math>

</p>

<p>Since these numbers <em>h</em><sub><em>i</em></sub> are the multiplicative inverses of the <em>M</em><sub><em>i</em></sub>, they may be found using Euclid's algorithm as described in the previous subsection.</p>
<h3 id="sternbrocot-tree">Stern–Brocot tree</h3>

<p>The Euclidean algorithm can be used to arrange the set of all positive <a href="rational_number" title="wikilink">rational numbers</a> into an infinite <a href="binary_search_tree" title="wikilink">binary search tree</a>, called the <a href="Stern–Brocot_tree" title="wikilink">Stern–Brocot tree</a>. The number 1 (expressed as a fraction 1/1) is placed at the root of the tree, and the location of any other number <em>a</em>/<em>b</em> can be found by computing gcd(<em>a</em>,<em>b</em>) using the original form of the Euclidean algorithm, in which each step replaces the larger of the two given numbers by its difference with the smaller number (not its remainder), stopping when two equal numbers are reached. A step of the Euclidean algorithm that replaces the first of the two numbers corresponds to a step in the tree from a node to its right child, and a step that replaces the second of the two numbers corresponds to a step in the tree from a node to its left child. The sequence of steps constructed in this way does not depend on whether <em>a</em>/<em>b</em> is given in lowest terms, and forms a path from the root to a node containing the number <em>a</em>/<em>b</em>.<a class="footnoteRef" href="#fn82" id="fnref82"><sup>82</sup></a> This fact can be used to prove that each positive rational number appears exactly once in this tree.</p>

<p>For example, 3/4 can be found by starting at the root, going to the left once, then to the right twice:</p>
<figure><b>(Figure)</b>
<figcaption>The Stern–Brocot tree, and the Stern–Brocot sequences of order <em>i</em> for <em>i</em> = 1, 2, 3, 4</figcaption>
</figure>

<p>

<math display="inline" id="Euclidean_algorithm:23">
 <semantics>
  <mrow>
   <mi>gcd</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>3</mn>
    <mo>,</mo>
    <mn>4</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <gcd></gcd>
    <cn type="integer">3</cn>
    <cn type="integer">4</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\gcd(3,4)
  </annotation>
 </semantics>
</math>


</p>

<p>The Euclidean algorithm has almost the same relationship to another binary tree on the rational numbers called the <a href="Calkin–Wilf_tree" title="wikilink">Calkin–Wilf tree</a>. The difference is that the path is reversed: instead of producing a path from the root of the tree to a target, it produces a path from the target to the root.</p>
<h3 id="continued-fractions">Continued fractions</h3>

<p>The Euclidean algorithm has a close relationship with <a href="continued_fraction" title="wikilink">continued fractions</a>.<a class="footnoteRef" href="#fn83" id="fnref83"><sup>83</sup></a> The sequence of equations can be written in the form</p>

<p>

<math display="inline" id="Euclidean_algorithm:24">
 <semantics>
  <mstyle displaystyle="true">
   <mfrac>
    <mi>a</mi>
    <mi>b</mi>
   </mfrac>
  </mstyle>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <divide></divide>
    <ci>a</ci>
    <ci>b</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \displaystyle\frac{a}{b}
  </annotation>
 </semantics>
</math>


</p>

<p>The last term on the right-hand side always equals the inverse of the left-hand side of the next equation. Thus, the first two equations may be combined to form</p>

<p>

<math display="block" id="Euclidean_algorithm:25">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mi>a</mi>
     <mi>b</mi>
    </mfrac>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>q</mi>
      <mn>0</mn>
     </msub>
     <mo>+</mo>
     <mpadded width="+1.7pt">
      <mfrac>
       <mn>1</mn>
       <mrow>
        <msub>
         <mi>q</mi>
         <mn>1</mn>
        </msub>
        <mo>+</mo>
        <mstyle displaystyle="true">
         <mfrac>
          <msub>
           <mi>r</mi>
           <mn>1</mn>
          </msub>
          <msub>
           <mi>r</mi>
           <mn>0</mn>
          </msub>
         </mfrac>
        </mstyle>
       </mrow>
      </mfrac>
     </mpadded>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">continued-fraction</csymbol>
      <cn type="integer">1</cn>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>q</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="latexml">continued-fraction</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>r</ci>
         <cn type="integer">0</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{a}{b}=q_{0}+\cfrac{1}{q_{1}+\cfrac{r_{1}}{r_{0}}}\,.
  </annotation>
 </semantics>
</math>

</p>

<p>The third equation may be used to substitute the denominator term <em>r</em><sub>1</sub>/<em>r</em><sub>0</sub>, yielding</p>

<p>

<math display="block" id="Euclidean_algorithm:26">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mi>a</mi>
     <mi>b</mi>
    </mfrac>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>q</mi>
      <mn>0</mn>
     </msub>
     <mo>+</mo>
     <mpadded width="+1.7pt">
      <mfrac>
       <mn>1</mn>
       <mrow>
        <msub>
         <mi>q</mi>
         <mn>1</mn>
        </msub>
        <mo>+</mo>
        <mstyle displaystyle="true">
         <mfrac>
          <mn>1</mn>
          <mrow>
           <msub>
            <mi>q</mi>
            <mn>2</mn>
           </msub>
           <mo>+</mo>
           <mstyle displaystyle="true">
            <mfrac>
             <msub>
              <mi>r</mi>
              <mn>2</mn>
             </msub>
             <msub>
              <mi>r</mi>
              <mn>1</mn>
             </msub>
            </mfrac>
           </mstyle>
          </mrow>
         </mfrac>
        </mstyle>
       </mrow>
      </mfrac>
     </mpadded>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <divide></divide>
     <ci>a</ci>
     <ci>b</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>q</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="latexml">continued-fraction</csymbol>
      <cn type="integer">1</cn>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>q</ci>
        <cn type="integer">1</cn>
       </apply>
       <apply>
        <csymbol cd="latexml">continued-fraction</csymbol>
        <cn type="integer">1</cn>
        <apply>
         <plus></plus>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <ci>q</ci>
          <cn type="integer">2</cn>
         </apply>
         <apply>
          <csymbol cd="latexml">continued-fraction</csymbol>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>r</ci>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>r</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{a}{b}=q_{0}+\cfrac{1}{q_{1}+\cfrac{1}{q_{2}+\cfrac{r_{2}}{r_{1}}}}\,.
  </annotation>
 </semantics>
</math>

</p>

<p>The final ratio of remainders <em>r</em><sub><em>k</em></sub>/<em>r</em><sub><em>k</em>−1</sub> can always be replaced using the next equation in the series, up to the final equation. The result is a continued fraction</p>

<p>

<math display="block" id="Euclidean_algorithm:27">
 <semantics>
  <mrow>
   <mrow>
    <mfrac>
     <mi>a</mi>
     <mi>b</mi>
    </mfrac>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>q</mi>
      <mn>0</mn>
     </msub>
     <mo>+</mo>
     <mfrac>
      <mn>1</mn>
      <mrow>
       <msub>
        <mi>q</mi>
        <mn>1</mn>
       </msub>
       <mo>+</mo>
       <mstyle displaystyle="true">
        <mfrac>
         <mn>1</mn>
         <mrow>
          <msub>
           <mi>q</mi>
           <mn>2</mn>
          </msub>
          <mo>+</mo>
          <mstyle displaystyle="true">
           <mfrac>
            <mn>1</mn>
            <mrow>
             <mi mathvariant="normal">⋱</mi>
             <mo>+</mo>
             <mstyle displaystyle="true">
              <mfrac>
               <mn>1</mn>
               <msub>
                <mi>q</mi>
                <mi>N</mi>
               </msub>
              </mfrac>
             </mstyle>
            </mrow>
           </mfrac>
          </mstyle>
         </mrow>
        </mfrac>
       </mstyle>
      </mrow>
     </mfrac>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mo stretchy="false">[</mo>
     <msub>
      <mi>q</mi>
      <mn>0</mn>
     </msub>
     <mo>;</mo>
     <msub>
      <mi>q</mi>
      <mn>1</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>q</mi>
      <mn>2</mn>
     </msub>
     <mo>,</mo>
     <mi mathvariant="normal">…</mi>
     <mo>,</mo>
     <msub>
      <mi>q</mi>
      <mi>N</mi>
     </msub>
     <mo rspace="4.2pt" stretchy="false">]</mo>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <plus></plus>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="latexml">continued-fraction</csymbol>
       <cn type="integer">1</cn>
       <apply>
        <plus></plus>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>q</ci>
         <cn type="integer">1</cn>
        </apply>
        <apply>
         <csymbol cd="latexml">continued-fraction</csymbol>
         <cn type="integer">1</cn>
         <apply>
          <plus></plus>
          <apply>
           <csymbol cd="ambiguous">subscript</csymbol>
           <ci>q</ci>
           <cn type="integer">2</cn>
          </apply>
          <apply>
           <csymbol cd="latexml">continued-fraction</csymbol>
           <cn type="integer">1</cn>
           <apply>
            <plus></plus>
            <ci>normal-⋱</ci>
            <apply>
             <csymbol cd="latexml">continued-fraction</csymbol>
             <cn type="integer">1</cn>
             <apply>
              <csymbol cd="ambiguous">subscript</csymbol>
              <ci>q</ci>
              <ci>N</ci>
             </apply>
            </apply>
           </apply>
          </apply>
         </apply>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <list>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <cn type="integer">1</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <cn type="integer">2</cn>
      </apply>
      <ci>normal-…</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>q</ci>
       <ci>N</ci>
      </apply>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{a}{b}=q_{0}+\cfrac{1}{q_{1}+\cfrac{1}{q_{2}+\cfrac{1}{\ddots+\cfrac{1}{q%
_{N}}}}}=[q_{0};q_{1},q_{2},\ldots,q_{N}]\,.
  </annotation>
 </semantics>
</math>

</p>

<p>In the worked example <a href="#Worked_example" title="wikilink">above</a>, the gcd(1071, 462) was calculated, and the quotients <em>q</em><sub><em>k</em></sub> were 2, 3 and 7, respectively. Therefore, the fraction 1071/462 may be written</p>

<p>

<math display="block" id="Euclidean_algorithm:28">
 <semantics>
  <mrow>
   <mfrac>
    <mn>1071</mn>
    <mn>462</mn>
   </mfrac>
   <mo>=</mo>
   <mrow>
    <mn>2</mn>
    <mo>+</mo>
    <mfrac>
     <mn>1</mn>
     <mrow>
      <mn>3</mn>
      <mo>+</mo>
      <mstyle displaystyle="true">
       <mfrac>
        <mn>1</mn>
        <mn>7</mn>
       </mfrac>
      </mstyle>
     </mrow>
    </mfrac>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">[</mo>
    <mn>2</mn>
    <mo>;</mo>
    <mn>3</mn>
    <mo>,</mo>
    <mn>7</mn>
    <mo stretchy="false">]</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <cn type="integer">1071</cn>
      <cn type="integer">462</cn>
     </apply>
     <apply>
      <plus></plus>
      <cn type="integer">2</cn>
      <apply>
       <csymbol cd="latexml">continued-fraction</csymbol>
       <cn type="integer">1</cn>
       <apply>
        <plus></plus>
        <cn type="integer">3</cn>
        <apply>
         <csymbol cd="latexml">continued-fraction</csymbol>
         <cn type="integer">1</cn>
         <cn type="integer">7</cn>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <list>
      <cn type="integer">2</cn>
      <cn type="integer">3</cn>
      <cn type="integer">7</cn>
     </list>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \frac{1071}{462}=2+\cfrac{1}{3+\cfrac{1}{7}}=[2;3,7]
  </annotation>
 </semantics>
</math>

</p>

<p>as can be confirmed by calculation.</p>
<h3 id="factorization-algorithms">Factorization algorithms</h3>

<p>Calculating a greatest common divisor is an essential step in several <a href="integer_factorization" title="wikilink">integer factorization</a> algorithms,<a class="footnoteRef" href="#fn84" id="fnref84"><sup>84</sup></a> such as <a href="Pollard's_rho_algorithm" title="wikilink">Pollard's rho algorithm</a>,<a class="footnoteRef" href="#fn85" id="fnref85"><sup>85</sup></a> <a href="Shor's_algorithm" title="wikilink">Shor's algorithm</a>,<a class="footnoteRef" href="#fn86" id="fnref86"><sup>86</sup></a> <a href="Dixon's_factorization_method" title="wikilink">Dixon's factorization method</a><a class="footnoteRef" href="#fn87" id="fnref87"><sup>87</sup></a> and the <a href="Lenstra_elliptic_curve_factorization" title="wikilink">Lenstra elliptic curve factorization</a>.<a class="footnoteRef" href="#fn88" id="fnref88"><sup>88</sup></a> The Euclidean algorithm may be used to find this GCD efficiently. <a href="Continued_fraction_factorization" title="wikilink">Continued fraction factorization</a> uses continued fractions, which are determined using Euclid's algorithm.<a class="footnoteRef" href="#fn89" id="fnref89"><sup>89</sup></a></p>
<h2 id="algorithmic-efficiency">Algorithmic efficiency</h2>
<figure><b>(Figure)</b>
<figcaption>Number of steps in the Euclidean algorithm for gcd(<em>x</em>,<em>y</em>). Lighter (red and yellow) points indicate relatively few steps, whereas darker (green and blue) points indicate more steps. The largest dark area follows the line <em>y</em> = Φ<em>x</em>, where Φ represents the <a href="Golden_ratio" title="wikilink">Golden ratio</a>.</figcaption>
</figure>

<p>The computational efficiency of Euclid's algorithm has been studied thoroughly.<a class="footnoteRef" href="#fn90" id="fnref90"><sup>90</sup></a> This efficiency can be described by the number of division steps the algorithm requires, multiplied by the computational expense of each step. The first known analysis of Euclid's algorithm is due to A.-A.-L. Reynaud in 1811,<a class="footnoteRef" href="#fn91" id="fnref91"><sup>91</sup></a> who showed that the number of division steps on input (<em>u</em>, <em>v</em>) is bounded by <em>v</em>; later he improved this to <em>v</em>/2  + 2. Later, in 1841, P.-J.-E. Finck showed<a class="footnoteRef" href="#fn92" id="fnref92"><sup>92</sup></a> that the number of division steps is at most 2 log<sub>2</sub> <em>v</em> + 1, and hence Euclid's algorithm runs in time polynomial in the size of the input; also see.<a class="footnoteRef" href="#fn93" id="fnref93"><sup>93</sup></a> His analysis was refined by <a href="Gabriel_Lamé" title="wikilink">Gabriel Lamé</a> in 1844,<a class="footnoteRef" href="#fn94" id="fnref94"><sup>94</sup></a> who showed that the number of steps required for completion is never more than five times the number <em>h</em> of base-10 digits of the smaller number <em>b</em>.<a class="footnoteRef" href="#fn95" id="fnref95"><sup>95</sup></a><a class="footnoteRef" href="#fn96" id="fnref96"><sup>96</sup></a></p>

<p>In the <a href="uniform_cost_model" title="wikilink">uniform cost model</a> (suitable for analyzing the complexity of gcd calculation on numbers that fit into a single machine word), each step of the algorithm takes <a href="constant_time" title="wikilink">constant time</a>, and Lamé's analysis implies that the total running time is also <em>O</em>(<em>h</em>). However, in a model of computation suitable for computation with larger numbers, the computational expense of a single remainder computation in the algorithm can be as large as <em>O</em>(<em>h</em><sup>2</sup>).<a class="footnoteRef" href="#fn97" id="fnref97"><sup>97</sup></a> In this case the total time for all of the steps of the algorithm can be analyzed using a <a href="telescoping_series" title="wikilink">telescoping series</a>, showing that it is also <em>O</em>(<em>h</em><sup>2</sup>). Modern algorithmic techniques based on the <a href="Schönhage–Strassen_algorithm" title="wikilink">Schönhage–Strassen algorithm</a> for fast integer multiplication can be used to speed this up, leading to subquadratic algorithms for the GCD.<a class="footnoteRef" href="#fn98" id="fnref98"><sup>98</sup></a><a class="footnoteRef" href="#fn99" id="fnref99"><sup>99</sup></a></p>
<h3 id="number-of-steps">Number of steps</h3>

<p>The number of steps to calculate the GCD of two natural numbers, <em>a</em> and <em>b</em>, may be denoted by <em>T</em>(<em>a</em>, <em>b</em>).<a class="footnoteRef" href="#fn100" id="fnref100"><sup>100</sup></a> If <em>g</em> is the GCD of <em>a</em> and <em>b</em>, then <em>a</em> = <em>mg</em> and <em>b</em> = <em>ng</em> for two coprime numbers <em>m</em> and <em>n</em>. Then</p>
<dl>
<dd>

<math display="inline" id="Euclidean_algorithm:29">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo>,</mo>
     <mi>b</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>m</mi>
     <mo>,</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <interval closure="open">
      <ci>a</ci>
      <ci>b</ci>
     </interval>
    </apply>
    <apply>
     <times></times>
     <ci>T</ci>
     <interval closure="open">
      <ci>m</ci>
      <ci>n</ci>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(a,b)=T(m,n)
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>as may be seen by dividing all the steps in the Euclidean algorithm by <em>g</em>.<a class="footnoteRef" href="#fn101" id="fnref101"><sup>101</sup></a> By the same argument, the number of steps remains the same if <em>a</em> and <em>b</em> are multiplied by a common factor <em>w</em>: <em>T</em>(<em>a</em>, <em>b</em>) = <em>T</em>(<em>wa</em>, <em>wb</em>). Therefore, the number of steps <em>T</em> may vary dramatically between neighboring pairs of numbers, such as T(<em>a</em>, <em>b</em>) and T(<em>a</em>, <em>b</em> + 1), depending on the size of the two GCDs.</p>

<p>The recursive nature of the Euclidean algorithm gives another equation</p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>where <em>T</em>(<em>x</em>, 0) = 0 by assumption.<a class="footnoteRef" href="#fn102" id="fnref102"><sup>102</sup></a></p>
<h4 id="worst-case">Worst-case</h4>

<p>If the Euclidean algorithm requires <em>N</em> steps for a pair of natural numbers <em>a</em> &gt; <em>b</em> &gt; 0, the smallest values of <em>a</em> and <em>b</em> for which this is true are the <a href="Fibonacci_number" title="wikilink">Fibonacci numbers</a> <em>F</em><sub><em>N</em>+2</sub> and <em>F</em><sub><em>N</em>+1</sub>, respectively.<a class="footnoteRef" href="#fn103" id="fnref103"><sup>103</sup></a> This can be shown by <a href="mathematical_induction" title="wikilink">induction</a>.<a class="footnoteRef" href="#fn104" id="fnref104"><sup>104</sup></a> If <em>N</em> = 1, <em>b</em> divides <em>a</em> with no remainder; the smallest natural numbers for which this is true is <em>b</em> = 1 and <em>a</em> = 2, which are <em>F</em><sub>2</sub> and <em>F</em><sub>3</sub>, respectively. Now assume that the result holds for all values of <em>N</em> up to <em>M</em> − 1. The first step of the <em>M</em>-step algorithm is <em>a</em> = <em>q</em><sub>0</sub><em>b</em> + <em>r</em><sub>0</sub>, and the second step is <em>b</em> = <em>q</em><sub>1</sub><em>r</em><sub>0</sub> + <em>r</em><sub>1</sub>. Since the algorithm is recursive, it required <em>M</em> − 1 steps to find gcd(<em>b</em>, <em>r</em><sub>0</sub>) and their smallest values are <em>F</em><sub><em>M</em>+1</sub> and <em>F</em><sub><em>M</em></sub>. The smallest value of <em>a</em> is therefore when <em>q</em><sub>0</sub> = 1, which gives <em>a</em> = <em>b</em> + <em>r</em><sub>0</sub> = <em>F</em><sub><em>M</em>+1</sub> + <em>F</em><sub><em>M</em></sub> = <em>F</em><sub><em>M</em>+2</sub>. This proof, published by <a href="Gabriel_Lamé" title="wikilink">Gabriel Lamé</a> in 1844, represents the beginning of <a href="computational_complexity_theory" title="wikilink">computational complexity theory</a>,<a class="footnoteRef" href="#fn105" id="fnref105"><sup>105</sup></a> and also the first practical application of the Fibonacci numbers.<a class="footnoteRef" href="#fn106" id="fnref106"><sup>106</sup></a></p>

<p>This result suffices to show that the number of steps in Euclid's algorithm can never be more than five times the number of its digits (base 10).<a class="footnoteRef" href="#fn107" id="fnref107"><sup>107</sup></a> For if the algorithm requires <em>N</em> steps, then <em>b</em> is greater than or equal to <em>F</em><sub><em>N</em>+1</sub> which in turn is greater than or equal to <em>φ</em><sup><em>N</em>−1</sup>, where <em>φ</em> is the <a href="golden_ratio" title="wikilink">golden ratio</a>. Since <em>b</em> ≥ <em>φ</em><sup><em>N</em>−1</sup>, then <em>N</em> − 1 ≤ log<sub><em>φ</em></sub><em>b</em>. Since log<sub>10</sub><em>φ</em> &gt; 1/5, (<em>N</em> − 1)/5 10<em>φ</em> log<sub><em>φ</em></sub><em>b</em> = log<sub>10</sub><em>b</em>. Thus, <em>N</em> ≤ 5 log<sub>10</sub><em>b</em>. Thus, the Euclidean algorithm always needs less than <a href="Big_O_notation" title="wikilink"><em>O</em>(<em>h</em>)</a> divisions, where <em>h</em> is the number of digits in the smaller number <em>b</em>.</p>
<h4 id="average">Average</h4>

<p>The average number of steps taken by the Euclidean algorithm has been defined in three different ways. The first definition is the average time <em>T</em>(<em>a</em>) required to calculate the GCD of a given number <em>a</em> and a smaller natural number <em>b</em> chosen with equal probability from the integers 0 to <em>a</em> − 1<a class="footnoteRef" href="#fn108" id="fnref108"><sup>108</sup></a></p>

<p>

<math display="block" id="Euclidean_algorithm:30">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mo>-</mo>
     <mfrac>
      <mn>1</mn>
      <mn>2</mn>
     </mfrac>
    </mrow>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mrow>
       <mn>6</mn>
       <mrow>
        <mi>ln</mi>
        <mn>2</mn>
       </mrow>
      </mrow>
      <msup>
       <mi>π</mi>
       <mn>2</mn>
      </msup>
     </mfrac>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mrow>
        <mrow>
         <mrow>
          <mn>4</mn>
          <mi>γ</mi>
         </mrow>
         <mo>-</mo>
         <mrow>
          <mn>24</mn>
          <msup>
           <mi>π</mi>
           <mn>2</mn>
          </msup>
          <msup>
           <mi>ζ</mi>
           <mo>′</mo>
          </msup>
          <mrow>
           <mo stretchy="false">(</mo>
           <mn>2</mn>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
        </mrow>
        <mo>+</mo>
        <mrow>
         <mn>3</mn>
         <mrow>
          <mi>ln</mi>
          <mn>2</mn>
         </mrow>
        </mrow>
       </mrow>
       <mo>-</mo>
       <mn>2</mn>
      </mrow>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mn>1.467</mn>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <ci>C</ci>
     <apply>
      <plus></plus>
      <apply>
       <minus></minus>
       <apply>
        <divide></divide>
        <cn type="integer">1</cn>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <times></times>
       <apply>
        <divide></divide>
        <apply>
         <times></times>
         <cn type="integer">6</cn>
         <apply>
          <ln></ln>
          <cn type="integer">2</cn>
         </apply>
        </apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <ci>π</ci>
         <cn type="integer">2</cn>
        </apply>
       </apply>
       <apply>
        <minus></minus>
        <apply>
         <plus></plus>
         <apply>
          <minus></minus>
          <apply>
           <times></times>
           <cn type="integer">4</cn>
           <ci>γ</ci>
          </apply>
          <apply>
           <times></times>
           <cn type="integer">24</cn>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>π</ci>
            <cn type="integer">2</cn>
           </apply>
           <apply>
            <csymbol cd="ambiguous">superscript</csymbol>
            <ci>ζ</ci>
            <ci>normal-′</ci>
           </apply>
           <cn type="integer">2</cn>
          </apply>
         </apply>
         <apply>
          <times></times>
          <cn type="integer">3</cn>
          <apply>
           <ln></ln>
           <cn type="integer">2</cn>
          </apply>
         </apply>
        </apply>
        <cn type="integer">2</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <approx></approx>
     <share href="#.cmml">
     </share>
     <cn type="float">1.467</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=-\frac{1}{2}+\frac{6\ln 2}{\pi^{2}}(4\gamma-24\pi^{2}\zeta^{\prime}(2)+3\ln 2%
-2)\approx 1.467
  </annotation>
 </semantics>
</math>

</p>

<p>with the residual error being of order <em>a</em><sup>−(1/6) + ε</sup>, where ε is <a class="uri" href="infinitesimal" title="wikilink">infinitesimal</a>. The constant <em>C</em> (<em>Porter's Constant</em><a class="footnoteRef" href="#fn109" id="fnref109"><sup>109</sup></a>)in this formula equals</p>

<p>

<math display="block" id="Euclidean_algorithm:31">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mfrac>
     <mn>1</mn>
     <mi>a</mi>
    </mfrac>
    <mrow>
     <munder>
      <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
      <mrow>
       <mi>d</mi>
       <mo>∣</mo>
       <mi>a</mi>
      </mrow>
     </munder>
     <mrow>
      <mi>φ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>d</mi>
       <mo stretchy="false">)</mo>
      </mrow>
      <mi>τ</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>d</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <divide></divide>
      <cn type="integer">1</cn>
      <ci>a</ci>
     </apply>
     <apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <sum></sum>
       <cerror>
        <csymbol cd="ambiguous">fragments</csymbol>
        <csymbol cd="unknown">d</csymbol>
        <ci>normal-∣</ci>
        <csymbol cd="unknown">a</csymbol>
       </cerror>
      </apply>
      <apply>
       <times></times>
       <ci>φ</ci>
       <ci>d</ci>
       <ci>τ</ci>
       <ci>d</ci>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(a)=\frac{1}{a}\sum_{d\mid a}\varphi(d)\tau(d)
  </annotation>
 </semantics>
</math>

</p>

<p>where γ is the <a href="Euler–Mascheroni_constant" title="wikilink">Euler–Mascheroni constant</a> and ζ' is the <a class="uri" href="derivative" title="wikilink">derivative</a> of the <a href="Riemann_zeta_function" title="wikilink">Riemann zeta function</a>.<a class="footnoteRef" href="#fn110" id="fnref110"><sup>110</sup></a><a class="footnoteRef" href="#fn111" id="fnref111"><sup>111</sup></a> The leading coefficient (12/π<sup>2</sup>) ln 2 was determined by two independent methods.<a class="footnoteRef" href="#fn112" id="fnref112"><sup>112</sup></a><a class="footnoteRef" href="#fn113" id="fnref113"><sup>113</sup></a></p>

<p>Since the first average can be calculated from the tau average by summing over the divisors <em>d</em> of <em>a</em><a class="footnoteRef" href="#fn114" id="fnref114"><sup>114</sup></a></p>

<p>

<math display="block" id="Euclidean_algorithm:32">
 <semantics>
  <mrow>
   <mrow>
    <mi>T</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>a</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mi>C</mi>
    <mo>+</mo>
    <mrow>
     <mfrac>
      <mn>12</mn>
      <msup>
       <mi>π</mi>
       <mn>2</mn>
      </msup>
     </mfrac>
     <mrow>
      <mi>ln</mi>
      <mn>2</mn>
     </mrow>
     <mrow>
      <mo>(</mo>
      <mrow>
       <mrow>
        <mi>ln</mi>
        <mi>a</mi>
       </mrow>
       <mo>-</mo>
       <mrow>
        <munder>
         <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
         <mrow>
          <mi>d</mi>
          <mo>∣</mo>
          <mi>a</mi>
         </mrow>
        </munder>
        <mfrac>
         <mrow>
          <mi mathvariant="normal">Λ</mi>
          <mrow>
           <mo stretchy="false">(</mo>
           <mi>d</mi>
           <mo stretchy="false">)</mo>
          </mrow>
         </mrow>
         <mi>d</mi>
        </mfrac>
       </mrow>
      </mrow>
      <mo>)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>T</ci>
     <ci>a</ci>
    </apply>
    <apply>
     <plus></plus>
     <ci>C</ci>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">12</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>π</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <ln></ln>
       <cn type="integer">2</cn>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <ln></ln>
        <ci>a</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <cerror>
          <csymbol cd="ambiguous">fragments</csymbol>
          <csymbol cd="unknown">d</csymbol>
          <ci>normal-∣</ci>
          <csymbol cd="unknown">a</csymbol>
         </cerror>
        </apply>
        <apply>
         <divide></divide>
         <apply>
          <times></times>
          <ci>normal-Λ</ci>
          <ci>d</ci>
         </apply>
         <ci>d</ci>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T(a)\approx C+\frac{12}{\pi^{2}}\ln 2\left(\ln a-\sum_{d\mid a}\frac{\Lambda(d%
)}{d}\right)
  </annotation>
 </semantics>
</math>

</p>

<p>it can be approximated by the formula<a class="footnoteRef" href="#fn115" id="fnref115"><sup>115</sup></a></p>

<p>

<math display="block" id="Euclidean_algorithm:33">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>Y</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>n</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <msup>
       <mi>n</mi>
       <mn>2</mn>
      </msup>
     </mfrac>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>a</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <munderover>
        <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
        <mrow>
         <mi>b</mi>
         <mo>=</mo>
         <mn>1</mn>
        </mrow>
        <mi>n</mi>
       </munderover>
       <mrow>
        <mi>T</mi>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>a</mi>
         <mo>,</mo>
         <mi>b</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>=</mo>
    <mrow>
     <mfrac>
      <mn>1</mn>
      <mi>n</mi>
     </mfrac>
     <mrow>
      <munderover>
       <mo largeop="true" movablelimits="false" symmetric="true">∑</mo>
       <mrow>
        <mi>a</mi>
        <mo>=</mo>
        <mn>1</mn>
       </mrow>
       <mi>n</mi>
      </munderover>
      <mrow>
       <mi>T</mi>
       <mrow>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>Y</ci>
      <ci>n</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>n</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>a</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <apply>
         <csymbol cd="ambiguous">superscript</csymbol>
         <apply>
          <csymbol cd="ambiguous">subscript</csymbol>
          <sum></sum>
          <apply>
           <eq></eq>
           <ci>b</ci>
           <cn type="integer">1</cn>
          </apply>
         </apply>
         <ci>n</ci>
        </apply>
        <apply>
         <times></times>
         <ci>T</ci>
         <interval closure="open">
          <ci>a</ci>
          <ci>b</ci>
         </interval>
        </apply>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">1</cn>
       <ci>n</ci>
      </apply>
      <apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <sum></sum>
         <apply>
          <eq></eq>
          <ci>a</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>n</ci>
       </apply>
       <apply>
        <times></times>
        <ci>T</ci>
        <ci>a</ci>
       </apply>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y(n)=\frac{1}{n^{2}}\sum_{a=1}^{n}\sum_{b=1}^{n}T(a,b)=\frac{1}{n}\sum_{a=1}^{%
n}T(a).
  </annotation>
 </semantics>
</math>

</p>

<p>where Λ(<em>d</em>) is the <a href="von_Mangoldt_function" title="wikilink">Mangoldt function</a>.<a class="footnoteRef" href="#fn116" id="fnref116"><sup>116</sup></a></p>

<p>A third average <em>Y</em>(<em>n</em>) is defined as the mean number of steps required when both <em>a</em> and <em>b</em> are chosen randomly (with uniform distribution) from 1 to <em>n</em><a class="footnoteRef" href="#fn117" id="fnref117"><sup>117</sup></a></p>

<p>

<math display="block" id="Euclidean_algorithm:34">
 <semantics>
  <mrow>
   <mrow>
    <mi>Y</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>n</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>≈</mo>
   <mrow>
    <mrow>
     <mfrac>
      <mn>12</mn>
      <msup>
       <mi>π</mi>
       <mn>2</mn>
      </msup>
     </mfrac>
     <mrow>
      <mi>ln</mi>
      <mrow>
       <mn>2</mn>
       <mrow>
        <mi>ln</mi>
        <mi>n</mi>
       </mrow>
      </mrow>
     </mrow>
    </mrow>
    <mo>+</mo>
    <mn>0.06.</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <times></times>
     <ci>Y</ci>
     <ci>n</ci>
    </apply>
    <apply>
     <plus></plus>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <cn type="integer">12</cn>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <ci>π</ci>
        <cn type="integer">2</cn>
       </apply>
      </apply>
      <apply>
       <ln></ln>
       <apply>
        <times></times>
        <cn type="integer">2</cn>
        <apply>
         <ln></ln>
         <ci>n</ci>
        </apply>
       </apply>
      </apply>
     </apply>
     <cn type="float">0.06.</cn>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Y(n)\approx\frac{12}{\pi^{2}}\ln 2\ln n+0.06.
  </annotation>
 </semantics>
</math>

</p>

<p>Substituting the approximate formula for <em>T</em>(<em>a</em>) into this equation yields an estimate for <em>Y</em>(<em>n</em>)<a class="footnoteRef" href="#fn118" id="fnref118"><sup>118</sup></a></p>

<p>

<math display="inline" id="Euclidean_algorithm:35">
 <semantics>
  <mrow>
   <mrow>
    <mi>a</mi>
    <mo>/</mo>
    <mi>b</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mrow>
     <mrow>
      <mi>m</mi>
      <mi>g</mi>
     </mrow>
     <mo>/</mo>
     <mi>n</mi>
    </mrow>
    <mi>g</mi>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>m</mi>
    <mo>/</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <divide></divide>
      <ci>a</ci>
      <ci>b</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <divide></divide>
       <apply>
        <times></times>
        <ci>m</ci>
        <ci>g</ci>
       </apply>
       <ci>n</ci>
      </apply>
      <ci>g</ci>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <ci>m</ci>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a/b=mg/ng=m/n
  </annotation>
 </semantics>
</math>

</p>
<h3 id="computational-expense-per-step">Computational expense per step</h3>

<p>In each step <em>k</em> of the Euclidean algorithm, the quotient <em>q</em><sub><em>k</em></sub> and remainder <em>r</em><sub><em>k</em></sub> are computed for a given pair of integers <em>r</em><sub><em>k</em>−2</sub> and <em>r</em><sub><em>k</em>−1</sub></p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>The computational expense per step is associated chiefly with finding <em>q</em><sub><em>k</em></sub>, since the remainder <em>r</em><sub><em>k</em></sub> can be calculated quickly from <em>r</em><sub><em>k</em>−2</sub>, <em>r</em><sub><em>k</em>−1</sub>, and <em>q</em><sub><em>k</em></sub></p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>The computational expense of dividing <em>h</em>-bit numbers scales as <em>O</em>(<em>h</em>(<em>ℓ</em>+1)), where <em>ℓ</em> is the length of the quotient.<a class="footnoteRef" href="#fn119" id="fnref119"><sup>119</sup></a></p>

<p>For comparison, Euclid's original subtraction-based algorithm can be much slower. A single integer division is equivalent to the quotient <em>q</em> number of subtractions. If the ratio of <em>a</em> and <em>b</em> is very large, the quotient is large and many subtractions will be required. On the other hand, it has been shown that the quotients are very likely to be small integers. The probability of a given quotient <em>q</em> is approximately ln|<em>u</em>/(<em>u</em> − 1)| where <em>u</em> = (<em>q</em> + 1)<sup>2</sup>.<a class="footnoteRef" href="#fn120" id="fnref120"><sup>120</sup></a> For illustration, the probability of a quotient of 1, 2, 3, or 4 is roughly 41.5%, 17.0%, 9.3%, and 5.9%, respectively. Since the operation of subtraction is faster than division, particularly for large numbers,<a class="footnoteRef" href="#fn121" id="fnref121"><sup>121</sup></a> the subtraction-based Euclid's algorithm is competitive with the division-based version.<a class="footnoteRef" href="#fn122" id="fnref122"><sup>122</sup></a> This is exploited in the <a href="binary_GCD_algorithm" title="wikilink">binary version</a> of Euclid's algorithm.<a class="footnoteRef" href="#fn123" id="fnref123"><sup>123</sup></a></p>

<p>Combining the estimated number of steps with the estimated computational expense per step shows that the Euclid's algorithm grows quadratically (<em>h</em><sup>2</sup>) with the average number of digits <em>h</em> in the initial two numbers <em>a</em> and <em>b</em>. Let <em>h</em><sub>0</sub>, <em>h</em><sub>1</sub>, …, <em>h</em><sub><em>N</em>−1</sub> represent the number of digits in the successive remainders <em>r</em><sub>0</sub>, <em>r</em><sub>1</sub>, …, <em>r</em><sub><em>N</em>−1</sub>. Since the number of steps <em>N</em> grows linearly with <em>h</em>, the running time is bounded by</p>

<p>

<math display="block" id="Euclidean_algorithm:36">
 <semantics>
  <mrow>
   <mrow>
    <mi>ω</mi>
    <mo>=</mo>
    <msqrt>
     <mi>D</mi>
    </msqrt>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>ω</ci>
    <apply>
     <root></root>
     <ci>D</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \omega=\sqrt{D}.\,
  </annotation>
 </semantics>
</math>

</p>
<h3 id="polynomials">Polynomials</h3>

<p>Polynomials in a single variable <em>x</em> can be added, multiplied and factored into <a href="irreducible_polynomial" title="wikilink">irreducible polynomials</a>, which are the analogs of the prime numbers for integers. The greatest common divisor polynomial <em>g</em>(<em>x</em>) of two polynomials <em>a</em>(<em>x</em>) and <em>b</em>(<em>x</em>) is defined as the product of their shared irreducible polynomials, which can be identified using the Euclidean algorithm.<a class="footnoteRef" href="#fn124" id="fnref124"><sup>124</sup></a> The basic procedure is similar to integers. At each step <em>k</em>, a quotient polynomial <em>q</em><sub><em>k</em></sub>(<em>x</em>) and a remainder polynomial <em>r</em><sub><em>k</em></sub>(<em>x</em>) are identified to satisfy the recursive equation</p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>where <em>r</em><sub>−2</sub>(<em>x</em>) = <em>a</em>(<em>x</em>) and <em>r</em><sub>−1</sub>(<em>x</em>) = <em>b</em>(<em>x</em>). The quotient polynomial is chosen so that the leading term of <em>q</em><sub><em>k</em></sub>(<em>x</em>) <em>r</em><sub><em>k</em>−1</sub>(<em>x</em>) equals the leading term of <em>r</em><sub><em>k</em>−2</sub>(<em>x</em>); this ensures that the degree of each remainder is smaller than the degree of its predecessor deg[<em>r</em><sub><em>k</em></sub>(<em>x</em>)] <em>k</em>−1(<em>x</em>)]. Since the degree is a nonnegative integer, and since it decreases with every step, the Euclidean algorithm concludes in a finite number of steps. The final nonzero remainder is the greatest common divisor of the original two polynomials, <em>a</em>(<em>x</em>) and <em>b</em>(<em>x</em>).<a class="footnoteRef" href="#fn125" id="fnref125"><sup>125</sup></a></p>

<p>For example, consider the following two quartic polynomials, which each factor into two quadratic polynomials</p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>and</p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>

<p><a href="polynomial_long_division" title="wikilink">Dividing</a> <em>a</em>(<em>x</em>) by <em>b</em>(<em>x</em>) yields a remainder <em>r</em><sub>0</sub>(<em>x</em>) = <em>x</em><sup>3</sup> + (2/3) <em>x</em><sup>2</sup> + (5/3) <em>x</em> − (2/3). In the next step, <em>b</em>(<em>x</em>) is divided by <em>r</em><sub>0</sub>(<em>x</em>) yielding a remainder <em>r</em><sub>1</sub>(<em>x</em>) = <em>x</em><sup>2</sup> + <em>x</em> + 2. Finally, dividing <em>r</em><sub>0</sub>(<em>x</em>) by <em>r</em><sub>1</sub>(<em>x</em>) yields a zero remainder, indicating that <em>r</em><sub>1</sub>(<em>x</em>) is the greatest common divisor polynomial of <em>a</em>(<em>x</em>) and <em>b</em>(<em>x</em>), consistent with their factorization.</p>

<p>Many of the applications described above for integers carry over to polynomials.<a class="footnoteRef" href="#fn126" id="fnref126"><sup>126</sup></a> The Euclidean algorithm can be used to solve linear Diophantine equations and Chinese remainder problems for polynomials; continued fractions of polynomials can also be defined.</p>

<p>The polynomial Euclidean algorithm has other applications, such as <a href="Sturm_chain" title="wikilink">Sturm chains</a>, a method for counting the <a href="zero_of_a_function" title="wikilink">zeros of a polynomial</a> that lie inside a given <a href="Interval_(mathematics)" title="wikilink">real interval</a>.<a class="footnoteRef" href="#fn127" id="fnref127"><sup>127</sup></a> This in turn has applications in several areas, such as the <a href="Routh–Hurwitz_stability_criterion" title="wikilink">Routh–Hurwitz stability criterion</a> in <a href="control_theory" title="wikilink">control theory</a>.<a class="footnoteRef" href="#fn128" id="fnref128"><sup>128</sup></a></p>

<p>Finally, the coefficients of the polynomials need not be drawn from integers, real numbers or even the complex numbers. For example, the coefficients may be drawn from a general field, such as the finite fields GF(<em>p</em>) described above. The corresponding conclusions about the Euclidean algorithm and its applications hold even for such polynomials.<a class="footnoteRef" href="#fn129" id="fnref129"><sup>129</sup></a></p>
<h3 id="gaussian-integers">Gaussian integers</h3>
<figure><b>(Figure)</b>
<figcaption>Distribution of Gaussian primes <em>u</em> + <em>vi</em> in the complex plane, with norms <em>u</em><sup>2</sup> + <em>v</em><sup>2</sup> less than 500</figcaption>
</figure>

<p>The Gaussian integers are <a href="complex_number" title="wikilink">complex numbers</a> of the form α = <em>u</em> + <em>vi</em>, where <em>u</em> and <em>v</em> are ordinary <a href="integer" title="wikilink">integers</a> and <em>i</em> is the <a href="imaginary_unit" title="wikilink">square root of negative one</a>.<a class="footnoteRef" href="#fn130" id="fnref130"><sup>130</sup></a> By defining an analog of the Euclidean algorithm, Gaussian integers can be shown to be uniquely factorizable, by the argument <a href="#Bézout's_identity" title="wikilink">above</a>.<a class="footnoteRef" href="#fn131" id="fnref131"><sup>131</sup></a> This unique factorization is helpful in many applications, such as deriving all <a href="Pythagorean_triple" title="wikilink">Pythagorean triples</a> or proving <a href="Fermat's_theorem_on_sums_of_two_squares" title="wikilink">Fermat's theorem on sums of two squares</a>.<a class="footnoteRef" href="#fn132" id="fnref132"><sup>132</sup></a> In general, the Euclidean algorithm is convenient in such applications, but not essential; for example, the theorems can often be proven by other arguments.</p>

<p>The Euclidean algorithm developed for two Gaussian integers α and β is nearly the same as that for normal integers,<a class="footnoteRef" href="#fn133" id="fnref133"><sup>133</sup></a> but differs in two respects. As before, the task at each step <em>k</em> is to identify a quotient <em>q</em><sub><em>k</em></sub> and a remainder <em>r</em><sub><em>k</em></sub> such that</p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>where <em>r</em><sub><em>k</em>−2</sub> = α, <em>r</em><sub><em>k</em>−1</sub> = β, and every remainder is strictly smaller than its predecessor, |<em>r</em><sub><em>k</em></sub>| <em>k</em>−1|. The first difference is that the quotients and remainders are themselves Gaussian integers, and thus are <a href="complex_number" title="wikilink">complex numbers</a>. The quotients <em>q</em><sub><em>k</em></sub> are generally found by rounding the real and complex parts of the exact ratio (such as the complex number α/β) to the nearest integers.<a class="footnoteRef" href="#fn134" id="fnref134"><sup>134</sup></a> The second difference lies in the necessity of defining how one complex remainder can be "smaller" than another. To do this, a <a href="norm_(mathematics)" title="wikilink">norm function</a> <em>f</em>(<em>u</em> + <em>v</em>i) = <em>u</em><sup>2</sup> + <em>v</em><sup>2</sup> is defined, which converts every Gaussian integer <em>u</em> + <em>vi</em> into a normal integer. After each step <em>k</em> of the Euclidean algorithm, the norm of the remainder <em>f</em>(<em>r</em><sub><em>k</em></sub>) is smaller than the norm of the preceding remainder, <em>f</em>(<em>r</em><sub><em>k</em>−1</sub>). Since the norm is a nonnegative integer and decreases with every step, the Euclidean algorithm for Gaussian integers ends in a finite number of steps.<a class="footnoteRef" href="#fn135" id="fnref135"><sup>135</sup></a> The final nonzero remainder is the gcd(α,β), the Gaussian integer of largest norm that divides both α and β; it is unique up to multiplication by a unit, ±1 or ±<em>i</em>.<a class="footnoteRef" href="#fn136" id="fnref136"><sup>136</sup></a></p>

<p>Many of the other applications of the Euclidean algorithm carry over to Gaussian integers. For example, it can be used to solve linear Diophantine equations and Chinese remainder problems for Gaussian integers;<a class="footnoteRef" href="#fn137" id="fnref137"><sup>137</sup></a> continued fractions of Gaussian integers can also be defined.<a class="footnoteRef" href="#fn138" id="fnref138"><sup>138</sup></a></p>
<h3 id="euclidean-domains">Euclidean domains</h3>

<p>A set of elements under two <a href="binary_operation" title="wikilink">binary operations</a>, + and −, is called a <a href="Euclidean_domain" title="wikilink">Euclidean domain</a> if it forms a <a href="commutative_ring" title="wikilink">commutative ring</a> <em>R</em> and, roughly speaking, if a generalized Euclidean algorithm can be performed on them.<a class="footnoteRef" href="#fn139" id="fnref139"><sup>139</sup></a><a class="footnoteRef" href="#fn140" id="fnref140"><sup>140</sup></a> The two operations of such a ring need not be the addition and multiplication of ordinary arithmetic; rather, they can be more general, such as the operations of a <a href="group_(mathematics)" title="wikilink">mathematical group</a> or <a class="uri" href="monoid" title="wikilink">monoid</a>. Nevertheless, these general operations should respect many of the laws governing ordinary arithmetic, such as <a href="commutative_property" title="wikilink">commutativity</a>, <a href="associative_property" title="wikilink">associativity</a> and <a href="distributive_property" title="wikilink">distributivity</a>.</p>

<p>The generalized Euclidean algorithm requires a <em>Euclidean function</em>, i.e., a mapping <em>f</em> from <em>R</em> into the set of nonnegative integers such that, for any two nonzero elements <em>a</em> and <em>b</em> in <em>R</em>, there exist <em>q</em> and <em>r</em> in <em>R</em> such that <em>a</em> = <em>qb</em> + <em>r</em> and <em>f</em>(<em>r</em>)  An example of this mapping is the norm function used to order the Gaussian integers <a href="#Gaussian_integers" title="wikilink">above</a>.<a class="footnoteRef" href="#fn141" id="fnref141"><sup>141</sup></a> The function <em>f</em> can be the magnitude of the number, or the <a href="degree_of_a_polynomial" title="wikilink">degree of a polynomial</a>.<a class="footnoteRef" href="#fn142" id="fnref142"><sup>142</sup></a> The basic principle is that each step of the algorithm reduces <em>f</em> inexorably; hence, if <em>f</em> can be reduced only a finite number of times, the algorithm must stop in a finite number of steps. This principle relies heavily on the natural <a href="well-order" title="wikilink">well-ordering</a> of the non-negative integers;<a class="footnoteRef" href="#fn143" id="fnref143"><sup>143</sup></a> roughly speaking, this requires that every non-empty set of non-negative integers has a smallest member.</p>

<p>The <a href="fundamental_theorem_of_arithmetic" title="wikilink">fundamental theorem of arithmetic</a> applies to any Euclidean domain: Any number from a Euclidean domain can be factored uniquely into <a href="irreducible_element" title="wikilink">irreducible elements</a>. Any Euclidean domain is a <a href="unique_factorization_domain" title="wikilink">unique factorization domain</a> (UFD), although the converse is not true.<a class="footnoteRef" href="#fn144" id="fnref144"><sup>144</sup></a> The Euclidean domains and the UFD's are subclasses of the <a href="GCD_domain" title="wikilink">GCD domains</a>, domains in which a greatest common divisor of two numbers always exists.<a class="footnoteRef" href="#fn145" id="fnref145"><sup>145</sup></a> In other words, a greatest common divisor may exist (for all pairs of elements in a domain), although it may not be possible to find it using a Euclidean algorithm. A Euclidean domain is always a <a href="principal_ideal_domain" title="wikilink">principal ideal domain</a> (PID), an <a href="integral_domain" title="wikilink">integral domain</a> in which every <a href="ideal_(ring_theory)" title="wikilink">ideal</a> is a <a href="principal_ideal" title="wikilink">principal ideal</a>.<a class="footnoteRef" href="#fn146" id="fnref146"><sup>146</sup></a> Again, the converse is not true: not every PID is a Euclidean domain.</p>

<p>The unique factorization of Euclidean domains is useful in many applications. For example, the unique factorization of the Gaussian integers is convenient in deriving formulae for all <a href="Pythagorean_triple" title="wikilink">Pythagorean triples</a> and in proving <a href="Fermat's_theorem_on_sums_of_two_squares" title="wikilink">Fermat's theorem on sums of two squares</a>.<a class="footnoteRef" href="#fn147" id="fnref147"><sup>147</sup></a> Unique factorization was also a key element in an attempted proof of <a href="Fermat's_Last_Theorem" title="wikilink">Fermat's Last Theorem</a> published in 1847 by Gabriel Lamé, the same mathematician who analyzed the efficiency of Euclid's algorithm, based on a suggestion of <a href="Joseph_Liouville" title="wikilink">Joseph Liouville</a>.<a class="footnoteRef" href="#fn148" id="fnref148"><sup>148</sup></a> Lamé's approach required the unique factorization of numbers of the form <em>x</em> + ω<em>y</em>, where <em>x</em> and <em>y</em> are integers, and ω = <em>e</em><sup>2<em>i</em>π/<em>n</em></sup> is an <em>n</em>th root of 1, that is, ω<sup><em>n</em></sup> = 1. Although this approach succeeds for some values of <em>n</em> (such as <em>n</em>=3, the <a href="Eisenstein_integer" title="wikilink">Eisenstein integers</a>), in general such numbers do <em>not</em> factor uniquely. This failure of unique factorization in some <a href="cyclotomic_field" title="wikilink">cyclotomic fields</a> led <a href="Ernst_Kummer" title="wikilink">Ernst Kummer</a> to the concept of <a href="ideal_number" title="wikilink">ideal numbers</a> and, later, <a href="Richard_Dedekind" title="wikilink">Richard Dedekind</a> to <a href="ideal_(ring_theory)" title="wikilink">ideals</a>.<a class="footnoteRef" href="#fn149" id="fnref149"><sup>149</sup></a></p>
<h4 id="unique-factorization-of-quadratic-integers">Unique factorization of quadratic integers</h4>
<figure><b>(Figure)</b>
<figcaption>Distribution of Eisenstein primes <em>u</em> + <em>v</em>ω in the complex plane, with norms less than 500. The number ω equals the <a href="root_of_unity" title="wikilink">cube root of 1</a>.</figcaption>
</figure>

<p>The <a href="quadratic_integer" title="wikilink">quadratic integer</a> rings are helpful to illustrate Euclidean domains. Quadratic integers are generalizations of the Gaussian integers in which the <a href="imaginary_unit" title="wikilink">imaginary unit</a> <em>i</em> is replaced by a number ω. Thus, they have the form <em>u</em> + <em>v</em> ω, where <em>u</em> and <em>v</em> are integers and ω has one of two forms, depending on a parameter <em>D</em>. If <em>D</em> does not equal a multiple of four plus one, then</p>

<p><span class="LaTeX">$$\omega = \sqrt{D}. \,$$</span></p>

<p>If, however, <em>D</em> does equal a multiple of four plus one, then</p>

<p><span class="LaTeX">$$\omega = \frac{1 + \sqrt{D}}{2}.$$</span></p>

<p>If the function <em>f</em> corresponds to a <a href="field_norm" title="wikilink">norm</a> function, such as that used to order the Gaussian integers <a href="#Gaussian_integers" title="wikilink">above</a>, then the domain is known as <em><a href="Norm-Euclidean_field" title="wikilink">norm-Euclidean</a></em>. The norm-Euclidean rings of quadratic integers are exactly those where <em>D</em> = −11, −7, −3, −2, −1, 2, 3, 5, 6, 7, 11, 13, 17, 19, 21, 29, 33, 37, 41, 57 or 73.<a class="footnoteRef" href="#fn150" id="fnref150"><sup>150</sup></a><a class="footnoteRef" href="#fn151" id="fnref151"><sup>151</sup></a> The quadratic integers with <em>D</em> = −1 and −3 are known as the <a href="Gaussian_integer" title="wikilink">Gaussian integers</a> and <a href="Eisenstein_integer" title="wikilink">Eisenstein integers</a>, respectively.</p>

<p>If <em>f</em> is allowed to be any Euclidean function, then the list of possible <em>D</em> values for which the domain is Euclidean is not yet known.<a class="footnoteRef" href="#fn152" id="fnref152"><sup>152</sup></a> The first example of a Euclidean domain that was not norm-Euclidean (with <em>D</em> = 69) was published in 1994.<a class="footnoteRef" href="#fn153" id="fnref153"><sup>153</sup></a> In 1973, Weinberger proved that a quadratic integer ring with <em>D</em> &gt; 0 is Euclidean if, and only if, it is a <a href="principal_ideal_domain" title="wikilink">principal ideal domain</a>, provided that the <a href="generalized_Riemann_hypothesis" title="wikilink">generalized Riemann hypothesis</a> holds.<a class="footnoteRef" href="#fn154" id="fnref154"><sup>154</sup></a></p>
<h3 id="noncommutative-rings">Noncommutative rings</h3>

<p>The Euclidean algorithm may be applied to noncommutative rings such as the set of <a href="Hurwitz_quaternion" title="wikilink">Hurwitz quaternions</a>.<a class="footnoteRef" href="#fn155" id="fnref155"><sup>155</sup></a> Let α and β represent two elements from such a ring. They have a common right divisor δ if α = ξδ and β = ηδ for some choice of ξ and η in the ring. Similarly, they have a common left divisor if α = δξ and β = δη for some choice of ξ and η in the ring. Since multiplication is not commutative, there are two versions of the Euclidean algorithm, one for right divisors and one for left divisors.<a class="footnoteRef" href="#fn156" id="fnref156"><sup>156</sup></a> Choosing the right divisors, the first step in finding the gcd(α, β) by the Euclidean algorithm can be written</p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>where ψ<sub>0</sub> represents the quotient and ρ<sub>0</sub> the remainder. This equation shows that any common right divisor of α and β is likewise a common divisor of the remainder ρ<sub>0</sub>. The analogous equation for the left divisors would be</p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>With either choice, the process is repeated as above until the greatest common right or left divisor is identified. As in the Euclidean domain, the "size" of the remainder ρ<sub>0</sub> must be strictly smaller than β, and there must be only a finite number of possible sizes for ρ<sub>0</sub>, so that the algorithm is guaranteed to terminate.<a class="footnoteRef" href="#fn157" id="fnref157"><sup>157</sup></a></p>

<p>Most of the results for the GCD carry over to noncommutative numbers. For example, <a href="Bézout's_identity" title="wikilink">Bézout's identity</a> states that the right gcd(α, β) can be expressed as a linear combination of α and β.<a class="footnoteRef" href="#fn158" id="fnref158"><sup>158</sup></a> In other words, there are numbers σ and τ such that</p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>The analogous identity for the left GCD is nearly the same:</p>
<dl>
<dd><mtpl></mtpl>
</dd>
</dl>

<p>Bézout's identity can be used to solve Diophantine equations. For instance, one of the standard proofs of <a href="Lagrange's_four-square_theorem" title="wikilink">Lagrange's four-square theorem</a>, that every positive integer can be represented as a sum of four squares, is based on quaternion GCDs in this way.<a class="footnoteRef" href="#fn159" id="fnref159"><sup>159</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Euclidean_rhythm" title="wikilink">Euclidean rhythm</a>, a method for using the Euclidean algorithm to generate musical rhythms</li>
</ul>
<h2 id="notes">Notes</h2>
<ul>
<li><strong>a.</strong>  Some widely used textbooks, such as <a href="I._N._Herstein" title="wikilink">I. N. Herstein</a>'s <em>Topics in Algebra</em> and <a href="Serge_Lang" title="wikilink">Serge Lang</a>'s <em>Algebra</em>, use the term "Euclidean algorithm" to refer to <a href="Euclidean_division" title="wikilink">Euclidean division</a>.</li>
</ul>
<h2 id="references">References</h2>
<h2 id="bibliography">Bibliography</h2>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li>

<p>. See also <a href="Vorlesungen_über_Zahlentheorie" title="wikilink">Vorlesungen über Zahlentheorie</a></p></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.math.sc.edu/~sumner/numbertheory/euclidean/euclidean.html">Demonstrations of Euclid's algorithm</a></li>
<li></li>
<li><a href="http://www.cut-the-knot.org/blue/Euclid.shtml">Euclid's Algorithm</a> at <a class="uri" href="cut-the-knot" title="wikilink">cut-the-knot</a></li>
<li></li>
<li><a href="http://www.mathpages.com/home/kmath384.htm">The Euclidean Algorithm</a> at MathPages</li>
<li><a href="http://www.cut-the-knot.org/blue/EuclidAlg.shtml">Euclid's Game</a> at <a class="uri" href="cut-the-knot" title="wikilink">cut-the-knot</a></li>
<li><a href="http://plus.maths.org/issue40/features/wardhaugh/index.html">Music and Euclid's algorithm</a></li>
</ul>

<p>"</p>

<p><a href="Category:Number_theoretic_algorithms" title="wikilink">Category:Number theoretic algorithms</a> <a href="Category:Articles_with_example_pseudocode" title="wikilink">Category:Articles with example pseudocode</a> <a href="Category:Articles_containing_proofs" title="wikilink">Category:Articles containing proofs</a> <a href="Category:Euclid" title="wikilink">Algorithm</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"></li>
<li id="fn11"><a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15">, p. 320<a href="#fnref15">↩</a></li>
<li id="fn16"><a href="#fnref16">↩</a></li>
<li id="fn17"><a href="#fnref17">↩</a></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19">, pp. 319–320<a href="#fnref19">↩</a></li>
<li id="fn20">, pp. 318–319<a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"><a href="#fnref22">↩</a></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"></li>
<li id="fn25"></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27">, p. 318<a href="#fnref27">↩</a></li>
<li id="fn28"><a href="#fnref28">↩</a></li>
<li id="fn29"><a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
<li id="fn31"></li>
<li id="fn32"><a href="#fnref32">↩</a></li>
<li id="fn33"><a href="#fnref33">↩</a></li>
<li id="fn34"><a href="#fnref34">↩</a></li>
<li id="fn35"><a href="#fnref35">↩</a></li>
<li id="fn36"><a href="#fnref36">↩</a></li>
<li id="fn37"><a href="#fnref37">↩</a></li>
<li id="fn38"><a href="#fnref38">↩</a></li>
<li id="fn39"><a href="#fnref39">↩</a></li>
<li id="fn40"><a href="#fnref40">↩</a></li>
<li id="fn41"></li>
<li id="fn42"><a href="#fnref42">↩</a></li>
<li id="fn43"></li>
<li id="fn44"></li>
<li id="fn45"><a href="#fnref45">↩</a></li>
<li id="fn46"><a href="#fnref46">↩</a></li>
<li id="fn47"><a href="Richard_Dedekind" title="wikilink">Richard Dedekind</a> in <a href="#fnref47">↩</a></li>
<li id="fn48"><a href="#fnref48">↩</a></li>
<li id="fn49"><a href="#fnref49">↩</a></li>
<li id="fn50"><a href="#fnref50">↩</a></li>
<li id="fn51"><a href="#fnref51">↩</a></li>
<li id="fn52"><a href="#fnref52">↩</a></li>
<li id="fn53"><a href="#fnref53">↩</a></li>
<li id="fn54"><a href="#fnref54">↩</a></li>
<li id="fn55"><a href="#fnref55">↩</a></li>
<li id="fn56"><a href="#fnref56">↩</a></li>
<li id="fn57"><a href="#fnref57">↩</a></li>
<li id="fn58"><a href="#fnref58">↩</a></li>
<li id="fn59"><a href="#fnref59">↩</a></li>
<li id="fn60"><a href="#fnref60">↩</a></li>
<li id="fn61"><a href="#fnref61">↩</a></li>
<li id="fn62"><a href="#fnref62">↩</a></li>
<li id="fn63"><a href="#fnref63">↩</a></li>
<li id="fn64"><a href="#fnref64">↩</a></li>
<li id="fn65"></li>
<li id="fn66"><a href="#fnref66">↩</a></li>
<li id="fn67"><a href="#fnref67">↩</a></li>
<li id="fn68"><a href="#fnref68">↩</a></li>
<li id="fn69"></li>
<li id="fn70"><a href="#fnref70">↩</a></li>
<li id="fn71"><a href="#fnref71">↩</a></li>
<li id="fn72"><a href="#fnref72">↩</a></li>
<li id="fn73"><a href="#fnref73">↩</a></li>
<li id="fn74"><a href="#fnref74">↩</a></li>
<li id="fn75"><a href="#fnref75">↩</a></li>
<li id="fn76"><a href="#fnref76">↩</a></li>
<li id="fn77"><a href="#fnref77">↩</a></li>
<li id="fn78"><a href="#fnref78">↩</a></li>
<li id="fn79"><a href="#fnref79">↩</a></li>
<li id="fn80"><a href="#fnref80">↩</a></li>
<li id="fn81"><a href="#fnref81">↩</a></li>
<li id="fn82"><a href="#fnref82">↩</a></li>
<li id="fn83"><a href="#fnref83">↩</a></li>
<li id="fn84">, pp. 225–349<a href="#fnref84">↩</a></li>
<li id="fn85">, pp. 369–371<a href="#fnref85">↩</a></li>
<li id="fn86"><a href="#fnref86">↩</a></li>
<li id="fn87"><a href="#fnref87">↩</a></li>
<li id="fn88"><a href="#fnref88">↩</a></li>
<li id="fn89">, pp. 380–384<a href="#fnref89">↩</a></li>
<li id="fn90">, pp. 339–364<a href="#fnref90">↩</a></li>
<li id="fn91"> As cited by .<a href="#fnref91">↩</a></li>
<li id="fn92"><a href="#fnref92">↩</a></li>
<li id="fn93"><a href="#fnref93">↩</a></li>
<li id="fn94"><a href="#fnref94">↩</a></li>
<li id="fn95"><a href="#fnref95">↩</a></li>
<li id="fn96"><a href="#fnref96">↩</a></li>
<li id="fn97"></li>
<li id="fn98"></li>
<li id="fn99"></li>
<li id="fn100">, p. 344<a href="#fnref100">↩</a></li>
<li id="fn101"><a href="#fnref101">↩</a></li>
<li id="fn102"></li>
<li id="fn103">, p. 343<a href="#fnref103">↩</a></li>
<li id="fn104"><a href="#fnref104">↩</a></li>
<li id="fn105"><a href="#fnref105">↩</a></li>
<li id="fn106"></li>
<li id="fn107"><a href="#fnref107">↩</a></li>
<li id="fn108"></li>
<li id="fn109"><a href="#fnref109">↩</a></li>
<li id="fn110"><a href="#fnref110">↩</a></li>
<li id="fn111"><a href="#fnref111">↩</a></li>
<li id="fn112"><a href="#fnref112">↩</a></li>
<li id="fn113"><a href="#fnref113">↩</a></li>
<li id="fn114">, p. 354<a href="#fnref114">↩</a></li>
<li id="fn115"><a href="#fnref115">↩</a></li>
<li id="fn116">, p. 355<a href="#fnref116">↩</a></li>
<li id="fn117"></li>
<li id="fn118">, p. 356<a href="#fnref118">↩</a></li>
<li id="fn119">, pp. 257–261<a href="#fnref119">↩</a></li>
<li id="fn120">, p. 352<a href="#fnref120">↩</a></li>
<li id="fn121"><a href="#fnref121">↩</a></li>
<li id="fn122"><a href="#fnref122">↩</a></li>
<li id="fn123"><a href="#fnref123">↩</a></li>
<li id="fn124"><a href="#fnref124">↩</a></li>
<li id="fn125"><a href="#fnref125">↩</a></li>
<li id="fn126"><a href="#fnref126">↩</a></li>
<li id="fn127">.<a href="#fnref127">↩</a></li>
<li id="fn128"><a href="#fnref128">↩</a></li>
<li id="fn129"></li>
<li id="fn130"></li>
<li id="fn131"> Reprinted in <a href="#fnref131">↩</a></li>
<li id="fn132"><a href="#fnref132">↩</a></li>
<li id="fn133"><a href="#fnref133">↩</a></li>
<li id="fn134"></li>
<li id="fn135"><a href="#fnref135">↩</a></li>
<li id="fn136"><a href="#fnref136">↩</a></li>
<li id="fn137"><a href="#fnref137">↩</a></li>
<li id="fn138"></li>
<li id="fn139"><a href="#fnref139">↩</a></li>
<li id="fn140"><a href="#fnref140">↩</a></li>
<li id="fn141">, p. 132<a href="#fnref141">↩</a></li>
<li id="fn142">, p. 161<a href="#fnref142">↩</a></li>
<li id="fn143"><a href="#fnref143">↩</a></li>
<li id="fn144"></li>
<li id="fn145">, p. 52<a href="#fnref145">↩</a></li>
<li id="fn146">, p. 131<a href="#fnref146">↩</a></li>
<li id="fn147"></li>
<li id="fn148"><mtpl></mtpl><a href="#fnref148">↩</a></li>
<li id="fn149"><a href="#fnref149">↩</a></li>
<li id="fn150"></li>
<li id="fn151"><a href="#fnref151">↩</a></li>
<li id="fn152"><a href="#fnref152">↩</a></li>
<li id="fn153"></li>
<li id="fn154"><a href="#fnref154">↩</a></li>
<li id="fn155"><a href="#fnref155">↩</a></li>
<li id="fn156"></li>
<li id="fn157"><a href="#fnref157">↩</a></li>
<li id="fn158"><a href="#fnref158">↩</a></li>
<li id="fn159"></li>
</ol>
</section>
</body>
</html>
