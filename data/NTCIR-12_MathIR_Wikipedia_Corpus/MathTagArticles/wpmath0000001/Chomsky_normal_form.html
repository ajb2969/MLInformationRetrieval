<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="252">Chomsky normal form</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Chomsky normal form</h1>
<hr/>

<p>In <a href="formal_language" title="wikilink">formal language</a> theory, a <a href="context-free_grammar" title="wikilink">context-free grammar</a> <em>G</em> is said to be in <strong>Chomsky normal form</strong> (discovered by <a href="Noam_Chomsky" title="wikilink">Noam Chomsky</a>)<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> if all of its <a href="production_(computer_science)" title="wikilink">production rules</a> are of the form:<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>
<dl>
<dd><em>A</em> → <em>BC</em>,   or
</dd>
<dd><em>A</em> → <em>a</em>,   or
</dd>
<dd><em>S</em> → ε,
</dd>
</dl>

<p>where <em>A</em>, <em>B</em>, and <em>C</em> are <a href="nonterminal_symbol" title="wikilink">nonterminal symbols</a>, <em>a</em> is a <a href="terminal_symbol" title="wikilink">terminal symbol</a> (a symbol that represents a constant value), <em>S</em> is the start symbol, and ε denotes the <a href="empty_string" title="wikilink">empty string</a>. Also, neither <em>B</em> nor <em>C</em> may be the <a href="Start_symbol_(formal_languages)" title="wikilink">start symbol</a>, and the third production rule can only appear if ε is in <em>L</em>(<em>G</em>), namely, the language produced by the context-free grammar <em>G</em>.</p>

<p>Every grammar in Chomsky normal form is <a href="Context-free_grammar" title="wikilink">context-free</a>, and conversely, every context-free grammar can be transformed into an equivalent one which is in Chomsky normal form and has a size no larger than the square of the original grammar's size.</p>
<h2 id="converting-a-grammar-to-chomsky-normal-form">Converting a grammar to Chomsky normal form</h2>

<p>To convert a grammar to Chomsky normal form, a sequence of simple transformations is applied in a certain order; this is described in most textbooks on automata theory.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a><a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a><a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a> The presentation here follows Hopcroft, Ullman (1979), but is adapted to use the transformation names from Lange, Leiß (2009).<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a><a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> Each of the following transformations establishes one of the properties required for Chomsky normal form.</p>
<h3 id="start-eliminate-the-start-symbol-from-right-hand-sides">START: Eliminate the start symbol from right-hand sides</h3>

<p>Introduce a new start symbol <em>S</em><sub>0</sub>, and a new rule</p>
<dl>
<dd><em>S</em><sub>0</sub> → <em>S</em>,
</dd>
</dl>

<p>where <em>S</em> is the previous start symbol. This doesn't change the grammar's produced language, and <em>S</em><sub>0</sub> won't occur on any rule's right-hand side.</p>
<h3 id="term-eliminate-rules-with-nonsolitary-terminals">TERM: Eliminate rules with nonsolitary terminals</h3>

<p>To eliminate each rule</p>
<dl>
<dd><em>A</em> → <em>X</em><sub>1</sub> ... <em>a</em> ... <em>X</em><sub><em>n</em></sub>
</dd>
</dl>

<p>with a terminal symbol <em>a</em> being not the only symbol on the right-hand side, introduce, for every such terminal, a new nonterminal symbol <em>N</em><sub><em>a</em></sub>, and a new rule</p>
<dl>
<dd><em>N</em><sub><em>a</em></sub> → <em>a</em>.
</dd>
</dl>

<p>Change every rule</p>
<dl>
<dd><em>A</em> → <em>X</em><sub>1</sub> ... <em>a</em> ... <em>X</em><sub><em>n</em></sub>
</dd>
</dl>

<p>to</p>
<dl>
<dd><em>A</em> → <em>X</em><sub>1</sub> ... <em>N</em><sub><em>a</em></sub> ... <em>X</em><sub><em>n</em></sub>.
</dd>
</dl>

<p>If several terminal symbols occur on the right-hand side, simultaneously replace each of them by its associated nonterminal symbol. This doesn't change the grammar's produced language.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>
<h3 id="bin-eliminate-right-hand-sides-with-more-than-2-nonterminals">BIN: Eliminate right-hand sides with more than 2 nonterminals</h3>

<p>Replace each rule</p>
<dl>
<dd><em>A</em> → <em>X</em><sub>1</sub> <em>X</em><sub>2</sub> ... <em>X</em><sub><em>n</em></sub>
</dd>
</dl>

<p>with more than 2 nonterminals <em>X</em><sub>1</sub>,...,<em>X</em><sub><em>n</em></sub> by rules</p>
<dl>
<dd><em>A</em> → <em>X</em><sub>1</sub> <em>A</em><sub>1</sub>,
</dd>
<dd><em>A</em><sub>1</sub> → <em>X</em><sub>2</sub> <em>A</em><sub>2</sub>,
</dd>
<dd>... ,
</dd>
<dd><em>A</em><sub><em>n</em>-2</sub> → <em>X</em><sub><em>n</em>-1</sub> <em>X</em><sub><em>n</em></sub>,
</dd>
</dl>

<p>where <em>A</em><sub><em>i</em></sub> are new nonterminal symbols. Again, this doesn't change the grammar's produced language.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h3 id="del-eliminate-ε-rules">DEL: Eliminate ε-rules</h3>

<p>An ε-rule is a rules of the form</p>
<dl>
<dd><em>A</em> → ε,
</dd>
</dl>

<p>where <em>A</em> is not the grammar's start symbol.</p>

<p>To eliminate all rules of this form, first determine the set of all nonterminals that derive ε. Hopcroft and Ullman (1979) call such nonterminals <em>nullable</em>, and compute them as follows:</p>
<ul>
<li>If a rule <em>A</em> → ε exists, then <em>A</em> is nullable.</li>
<li>If a rule <em>A</em> → <em>X</em><sub>1</sub> ... <em>X</em><sub><em>n</em></sub> exists, and each <em>X</em><sub><em>i</em></sub> is nullable, then <em>A</em> is nullable, too.</li>
</ul>

<p>Obtain an intermediate grammar by replacing each rule</p>
<dl>
<dd><em>A</em> → <em>X</em><sub>1</sub> ... <em>X</em><sub><em>n</em></sub>
</dd>
</dl>

<p>by all versions with some nullable <em>X</em><sub><em>i</em></sub> omitted. By deleting in this grammar each ε-rule, unless its left-hand side is the start symbol, the transformed grammar is obtained.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>For example, in the following grammar, with start symbol <em>S</em><sub>0</sub>,</p>
<dl>
<dd><em>S</em><sub>0</sub> → <em>AbB</em> | <em>C</em>
</dd>
<dd><em>B</em> → <em>AA</em> | <em>AC</em>
</dd>
<dd><em>C</em> → <em>b</em> | <em>c</em>
</dd>
<dd><em>A</em> → <em>a</em> | ε
</dd>
</dl>

<p>the nonterminal <em>A</em>, and hence also <em>B</em>, is nullable, while neither <em>C</em> nor <em>S</em><sub>0</sub> is. Hence the following intermediate grammar is obtained:<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>
<dl>
<dd><em>S</em><sub>0</sub> → <em>b</em> | <em>b<mtpl></mtpl></em> | <em><mtpl></mtpl>b</em> | <em><mtpl></mtpl>b<mtpl></mtpl></em>   |   <em>C</em>
</dd>
<dd><em>B</em> → <em></em> | <em><mtpl></mtpl></em> | <em><mtpl></mtpl></em> | <em><mtpl></mtpl>ε<mtpl></mtpl></em>   |   <em>C</em> | <em><mtpl></mtpl>C</em>
</dd>
<dd><em>C</em> → <em>b</em> | <em>c</em>
</dd>
<dd><em>A</em> → <em>a</em> | ε
</dd>
</dl>

<p>In this grammar, all ε-rules have been "<a href="inlining" title="wikilink">inlined</a> at the call site".<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> In the next step, they can hence be deleted, yielding the grammar:</p>
<dl>
<dd><em>S</em><sub>0</sub> → <em>AbB</em> | <em>Ab</em> | <em>bB</em> | <em>b</em>   |   <em>C</em>
</dd>
<dd><em>B</em> → <em>AA</em> | <em>A</em>   |   <em>AC</em> | <em>C</em>
</dd>
<dd><em>C</em> → <em>b</em> | <em>c</em>
</dd>
<dd><em>A</em> → <em>a</em>
</dd>
</dl>

<p>This grammar produces the same language as the original example grammar, viz. {<em>ab</em>,<em>aba</em>,<em>abaa</em>,<em>abab</em>,<em>abac</em>,<em>abb</em>,<em>abc</em>,<em>b</em>,<em>bab</em>,<em>bac</em>,<em>bb</em>,<em>bc</em>,<em>c</em>}, but apparently has no ε-rules.</p>
<h3 id="unit-eliminate-unit-rules">UNIT: Eliminate unit rules</h3>

<p>A unit rule is a rule of the form</p>
<dl>
<dd><em>A</em> → <em>B</em>,
</dd>
</dl>

<p>where <em>A</em>, <em>B</em> are nonterminal symbols. To remove it, for each rule</p>
<dl>
<dd><em>B</em> → <em>X</em><sub>1</sub> ... <em>X</em><sub><em>n</em></sub>,
</dd>
</dl>

<p>where <em>X</em><sub>1</sub> ... <em>X</em><sub><em>n</em></sub> is a string of nonterminals and terminals, add rule</p>
<dl>
<dd><em>A</em> → <em>X</em><sub>1</sub> ... <em>X</em><sub><em>n</em></sub>
</dd>
</dl>

<p>unless this is a unit rule which has already been removed.</p>
<h3 id="order-of-transformations">Order of transformations</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">
<p>Mutual preservation<br/>
of transformation results</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p>Transformation <em>X</em>  ()<br/>
resp.  () the result of <em>Y</em>:</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><sub><em>X</em></sub><strong>\</strong><sup><em>Y</em></sup></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>START</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>TERM</strong></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>BIN</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><strong>DEL</strong></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><strong>UNIT</strong></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><sup>*</sup><strong>UNIT</strong> preserves the result of <strong>DEL</strong><br/>
  if <strong>START</strong> had been called before.</p></td>
</tr>
</tbody>
</table>

<p>When choosing the order in which the above transformations are to be applied, it has to be considered that some transformations may destroy the result achieved by other ones. For example, <strong>START</strong> will re-introduce a unit rule if it is applied after <strong>UNIT</strong>. The table shows which orderings are admitted.</p>

<p>Moreover, the worst-case bloat in grammar size<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> depends on the transformation order. Using |<em>G</em>| to denote the size of the original grammar <em>G</em>, the size blow-up in the worst case may range from |<em>G</em>|<sup>2</sup> to 2<sup>2 |G|</sup>, depending on the transformation algorithm used.<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> The blow-up in grammar size depends on the order between <strong>DEL</strong> and <strong>BIN</strong>. It may be exponential when <strong>DEL</strong> is done first, but is linear otherwise. <strong>UNIT</strong> can incur a quadratic blow-up in the size of the grammar.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> The orderings <strong>START</strong>,<strong>TERM</strong>,<strong>BIN</strong>,<strong>DEL</strong>,<strong>UNIT</strong> and <strong>START</strong>,<strong>BIN</strong>,<strong>DEL</strong>,<strong>UNIT</strong>,<strong>TERM</strong> lead to the least (i.e. quadratic) blow-up.</p>
<h2 id="example">Example</h2>

<p> The following grammar, with start symbol <em>Expr</em>, describes a simplified version of the set of all syntactical valid arithmetic expressions in imperative programming languages like <a href="C_(programming_language)" title="wikilink">C</a> or <a class="uri" href="Algol60" title="wikilink">Algol60</a>. Both <em>number</em> and <em>variable</em> are considered terminal symbols here for simplicity, since in a <a href="compiler_front-end" title="wikilink">compiler front-end</a> their internal structure is usually not considered by the <a class="uri" href="parser" title="wikilink">parser</a>. The terminal symbol "^" denoted <a class="uri" href="exponentiation" title="wikilink">exponentiation</a> in Algol60.</p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>Expr</em></p></td>
<td style="text-align: left;">
<p>→ <em>Term</em></p></td>
<td style="text-align: left;">
<p>| | <em>Expr</em> <em>AddOp</em> <em>Term</em></p></td>
<td style="text-align: left;">
<p>| | <em>AddOp</em> <em>Term</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>Term</em></p></td>
<td style="text-align: left;">
<p>→ <em>Factor</em></p></td>
<td style="text-align: left;">
<p>| | <em>Term</em> <em>MulOp</em> <em>Factor</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>Factor</em></p></td>
<td style="text-align: left;">
<p>→ <em>Primary</em></p></td>
<td style="text-align: left;">
<p>| | <em>Factor</em> ^ <em>Primary</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>Primary</em></p></td>
<td style="text-align: left;">
<p>→ <em>number</em></p></td>
<td style="text-align: left;">
<p>| | <em>variable</em></p></td>
<td style="text-align: left;">
<p>| | ( <em>Expr</em> )</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>AddOp</em></p></td>
<td style="text-align: left;">
<p>→ +</p></td>
<td style="text-align: left;">
<p>| | −</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>MulOp</em></p></td>
<td style="text-align: left;">
<p>→ *</p></td>
<td style="text-align: left;">
<p>| | /</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>In step "START" of the <a href="#Converting_a_grammar_to_Chomsky_Normal_Form" title="wikilink">above</a> conversion algorithm, just a rule <em>S</em><sub>0</sub>→<em>Expr</em> is added to the grammar. After step "TERM", the grammar looks like this:</p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>S</em><sub>0</sub></p></td>
<td style="text-align: left;">
<p>→ <em>Expr</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>Expr</em></p></td>
<td style="text-align: left;">
<p>→ <em>Term</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>Term</em></p></td>
<td style="text-align: left;">
<p>→ <em>Factor</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>Factor</em></p></td>
<td style="text-align: left;">
<p>→ <em>Primary</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>Primary</em></p></td>
<td style="text-align: left;">
<p>→ <em>number</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>AddOp</em></p></td>
<td style="text-align: left;">
<p>→ +</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>MulOp</em></p></td>
<td style="text-align: left;">
<p>→ *</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>PowOp</em></p></td>
<td style="text-align: left;">
<p>→ ^</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>Open</em></p></td>
<td style="text-align: left;">
<p>→ (</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>Close</em></p></td>
<td style="text-align: left;">
<p>→ )</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>After step "BIN", the following grammar is obtained:</p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>S</em><sub>0</sub></p></td>
<td style="text-align: left;">
<p>→ <em>Expr</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>Expr</em></p></td>
<td style="text-align: left;">
<p>→ <em>Term</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>Term</em></p></td>
<td style="text-align: left;">
<p>→ <em>Factor</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>Factor</em></p></td>
<td style="text-align: left;">
<p>→ <em>Primary</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>Primary</em></p></td>
<td style="text-align: left;">
<p>→ <em>number</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>AddOp</em></p></td>
<td style="text-align: left;">
<p>→ +</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>MulOp</em></p></td>
<td style="text-align: left;">
<p>→ *</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>PowOp</em></p></td>
<td style="text-align: left;">
<p>→ ^</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>Open</em></p></td>
<td style="text-align: left;">
<p>→ (</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>Close</em></p></td>
<td style="text-align: left;">
<p>→ )</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>AddOp_Term</em></p></td>
<td style="text-align: left;">
<p>→ <em>AddOp</em> <em>Term</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>MulOp_Factor</em></p></td>
<td style="text-align: left;">
<p>→ <em>MulOp</em> <em>Factor</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>PowOp_Primary</em></p></td>
<td style="text-align: left;">
<p>→ <em>PowOp</em> <em>Primary</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>Expr_Close</em></p></td>
<td style="text-align: left;">
<p>→ <em>Expr</em> <em>Close</em></p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>Since there are no ε-rules, step "DEL" doesn't change the grammar. After step "UNIT", the following grammar is obtained, which is in Chomsky normal form:</p>
<dl>
<dd>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">
<p><em>S</em><sub>0</sub></p></td>
<td style="text-align: left;">
<p>→ <em>number</em></p></td>
<td style="text-align: left;">
<p>| | <em>variable</em></p></td>
<td style="text-align: left;">
<p>| | <em>Open</em> <em>Expr_Close</em></p></td>
<td style="text-align: left;">
<p>| | <em>Factor</em> <em>PowOp_Primary</em></p></td>
<td style="text-align: left;">
<p>| | <em>Term</em> <em>MulOp_Factor</em></p></td>
<td style="text-align: left;">
<p>| | <em>Expr</em> <em>AddOp_Term</em></p></td>
<td style="text-align: left;">
<p>| | <em>AddOp</em> <em>Term</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>Expr</em></p></td>
<td style="text-align: left;">
<p>→ <em>number</em></p></td>
<td style="text-align: left;">
<p>| | <em>variable</em></p></td>
<td style="text-align: left;">
<p>| | <em>Open</em> <em>Expr_Close</em></p></td>
<td style="text-align: left;">
<p>| | <em>Factor</em> <em>PowOp_Primary</em></p></td>
<td style="text-align: left;">
<p>| | <em>Term</em> <em>MulOp_Factor</em></p></td>
<td style="text-align: left;">
<p>| | <em>Expr</em> <em>AddOp_Term</em></p></td>
<td style="text-align: left;">
<p>| | <em>AddOp</em> <em>Term</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>Term</em></p></td>
<td style="text-align: left;">
<p>→ <em>number</em></p></td>
<td style="text-align: left;">
<p>| | <em>variable</em></p></td>
<td style="text-align: left;">
<p>| | <em>Open</em> <em>Expr_Close</em></p></td>
<td style="text-align: left;">
<p>| | <em>Factor</em> <em>PowOp_Primary</em></p></td>
<td style="text-align: left;">
<p>| | <em>Term</em> <em>MulOp_Factor</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>Factor</em></p></td>
<td style="text-align: left;">
<p>→ <em>number</em></p></td>
<td style="text-align: left;">
<p>| | <em>variable</em></p></td>
<td style="text-align: left;">
<p>| | <em>Open</em> <em>Expr_Close</em></p></td>
<td style="text-align: left;">
<p>| | <em>Factor</em> <em>PowOp_Primary</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>Primary</em></p></td>
<td style="text-align: left;">
<p>→ <em>number</em></p></td>
<td style="text-align: left;">
<p>| | <em>variable</em></p></td>
<td style="text-align: left;">
<p>| | <em>Open</em> <em>Expr_Close</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>AddOp</em></p></td>
<td style="text-align: left;">
<p>→ +</p></td>
<td style="text-align: left;">
<p>| | −</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>MulOp</em></p></td>
<td style="text-align: left;">
<p>→ *</p></td>
<td style="text-align: left;">
<p>| | /</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>PowOp</em></p></td>
<td style="text-align: left;">
<p>→ ^</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>Open</em></p></td>
<td style="text-align: left;">
<p>→ (</p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>Close</em></p></td>
<td style="text-align: left;">
<p>→ )</p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>AddOp_Term</em></p></td>
<td style="text-align: left;">
<p>→ <em>AddOp</em> <em>Term</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>MulOp_Factor</em></p></td>
<td style="text-align: left;">
<p>→ <em>MulOp</em> <em>Factor</em></p></td>
</tr>
<tr class="odd">
<td style="text-align: left;">
<p><em>PowOp_Primary</em></p></td>
<td style="text-align: left;">
<p>→ <em>PowOp</em> <em>Primary</em></p></td>
</tr>
<tr class="even">
<td style="text-align: left;">
<p><em>Expr_Close</em></p></td>
<td style="text-align: left;">
<p>→ <em>Expr</em> <em>Close</em></p></td>
</tr>
</tbody>
</table>
</dd>
</dl>

<p>The <em>N</em><sub><em>a</em></sub> introduced in step "TERM" are <em>PowOp</em>, <em>Open</em>, and <em>Close</em>. The <em>A</em><sub><em>i</em></sub> introduced in step "BIN" are <em>AddOp_Term</em>, <em>MulOp_Factor</em>, <em>PowOp_Primary</em>, and <em>Expr_Close</em>.</p>
<h2 id="alternative-definition">Alternative definition</h2>
<h3 id="chomsky-reduced-form">Chomsky reduced form</h3>

<p>Another way<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a><a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> to define the Chomsky normal form is:</p>

<p>A <a href="formal_grammar" title="wikilink">formal grammar</a> is in <strong>Chomsky reduced form</strong> if all of its production rules are of the form:</p>

<p>

<math display="block" id="Chomsky_normal_form:0">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo rspace="4.2pt">→</mo>
   <mrow>
    <mi>B</mi>
    <mi>C</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>B</ci>
     <ci>C</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\rightarrow\,BC
  </annotation>
 </semantics>
</math>

 or</p>

<p>

<math display="block" id="Chomsky_normal_form:1">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo rspace="4.2pt">→</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>A</ci>
    <ci>a</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\rightarrow\,a
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Chomsky_normal_form:2">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Chomsky_normal_form:3">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>


 and 

<math display="inline" id="Chomsky_normal_form:4">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 are nonterminal symbols, and 

<math display="inline" id="Chomsky_normal_form:5">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is a <a href="terminal_symbol" title="wikilink">terminal symbol</a>. When using this definition, 

<math display="inline" id="Chomsky_normal_form:6">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   B
  </annotation>
 </semantics>
</math>

 or 

<math display="inline" id="Chomsky_normal_form:7">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C
  </annotation>
 </semantics>
</math>

 may be the start symbol. Only those context-free grammars which do not generate the <a href="empty_string" title="wikilink">empty string</a> can be transformed into Chomsky reduced form.</p>
<h3 id="floyd-normal-form">Floyd normal form</h3>

<p>In a paper where he proposed a term <a href="Backus-Naur_Form" title="wikilink">Backus-Naur Form</a> (BNF), <a href="Donald_E._Knuth" title="wikilink">Donald E. Knuth</a> implied a BNF "syntax in which all definitions have such a form may be said to be in "Floyd Normal Form","</p>

<p>

<math display="block" id="Chomsky_normal_form:8">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>A</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>:</mo>
   <mo rspace="4.2pt">:=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>B</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>∣</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>C</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-⟩</ci>
    </cerror>
    <ci>normal-:</ci>
    <csymbol cd="latexml">assign</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-⟩</ci>
    </cerror>
    <ci>normal-∣</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-⟩</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle A\rangle::=\,\langle B\rangle\mid\langle C\rangle
  </annotation>
 </semantics>
</math>

 or</p>

<p>

<math display="block" id="Chomsky_normal_form:9">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>A</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>:</mo>
   <mo rspace="4.2pt">:=</mo>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>B</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>C</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-⟩</ci>
    </cerror>
    <ci>normal-:</ci>
    <csymbol cd="latexml">assign</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-⟩</ci>
    </cerror>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-⟩</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle A\rangle::=\,\langle B\rangle\langle C\rangle
  </annotation>
 </semantics>
</math>

 or</p>

<p>

<math display="block" id="Chomsky_normal_form:10">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>A</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
   <mo>:</mo>
   <mo rspace="4.2pt">:=</mo>
   <mi>a</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-⟨</ci>
     <csymbol cd="unknown">A</csymbol>
     <ci>normal-⟩</ci>
    </cerror>
    <ci>normal-:</ci>
    <csymbol cd="latexml">assign</csymbol>
    <csymbol cd="unknown">a</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle A\rangle::=\,a
  </annotation>
 </semantics>
</math>

, where 

<math display="inline" id="Chomsky_normal_form:11">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>A</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-⟨⟩</csymbol>
    <ci>A</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle A\rangle
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Chomsky_normal_form:12">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>B</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-⟨⟩</csymbol>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle B\rangle
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Chomsky_normal_form:13">
 <semantics>
  <mrow>
   <mo stretchy="false">⟨</mo>
   <mi>C</mi>
   <mo stretchy="false">⟩</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">delimited-⟨⟩</csymbol>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \langle C\rangle
  </annotation>
 </semantics>
</math>


 are nonterminal symbols, and 

<math display="inline" id="Chomsky_normal_form:14">
 <semantics>
  <mi>a</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>a</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   a
  </annotation>
 </semantics>
</math>

 is a <a href="terminal_symbol" title="wikilink">terminal symbol</a>, because <a href="Robert_W._Floyd" title="wikilink">Robert W. Floyd</a> found any BNF syntax can be converted to the above one in 1961.<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a> But he withdrew this term, "since doubtless many people have independently used this simple fact in their own work, and the point is only incidental to the main considerations of Floyd's note."<a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a></p>
<h2 id="application">Application</h2>

<p>Besides its theoretical significance, CNF conversion is used in some algorithms as a preprocessing step, e.g., the <a href="CYK_algorithm" title="wikilink">CYK algorithm</a>, a <a href="bottom-up_parsing" title="wikilink">bottom-up parsing</a> for context-free grammars, and its variant probabilistic CKY.<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a></p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Backus-Naur_form" title="wikilink">Backus-Naur form</a></li>
<li><a href="CYK_algorithm" title="wikilink">CYK algorithm</a></li>
<li><a href="Greibach_normal_form" title="wikilink">Greibach normal form</a></li>
<li><a href="Kuroda_normal_form" title="wikilink">Kuroda normal form</a></li>
<li><a href="Pumping_lemma_for_context-free_languages" title="wikilink">Pumping lemma for context-free languages</a> — its proof relies on the Chomsky normal form</li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<references>
</references>
<h2 id="further-reading">Further reading</h2>
<ul>
<li>Cole, Richard. <em>Converting CFGs to CNF (Chomsky Normal Form)</em>, October 17, 2007. <a href="http://cs.nyu.edu/courses/fall07/V22.0453-001/cnf.pdf">(pdf)</a> — uses the order TERM, BIN, START, DEL, UNIT.</li>
<li>

<p><em>(Pages 237–240 of section 6.6: simplified forms and normal forms.)</em></p></li>
<li>

<p><em>(Pages 98–101 of section 2.1: context-free grammars. Page 156.)</em></p></li>
<li>Sipser, Michael. <em>Introduction to the Theory of Computation,</em> 2nd edition.</li>
</ul>

<p>"</p>

<p><a href="Category:Formal_languages" title="wikilink">Category:Formal languages</a> <a href="Category:Noam_Chomsky" title="wikilink">Category:Noam Chomsky</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3"></li>
<li id="fn4"> Section 7.1.5, p.272<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"> Section 6.2 "Die Chomsky-Normalform für kontextfreie Grammatiken", p.149-152<a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8">For example, Hopcroft, Ullman (1979) merged <strong>TERM</strong> and <strong>BIN</strong> into a single transformation.<a href="#fnref8">↩</a></li>
<li id="fn9"></li>
<li id="fn10"></li>
<li id="fn11"></li>
<li id="fn12">indicating a kept and omitted nonterminal <em>N</em> by <em></em> and <em><mtpl></mtpl></em>, respectively<a href="#fnref12">↩</a></li>
<li id="fn13">If the grammar had a rule <em>S</em><sub>0</sub> → ε, it could not be "inlined", since it had no "call sites". Therefore it couldn't be deleted in the next step.<a href="#fnref13">↩</a></li>
<li id="fn14">i.e. written length, measured in symbols<a href="#fnref14">↩</a></li>
<li id="fn15"></li>
<li id="fn16"></li>
<li id="fn17"></li>
<li id="fn18">Hopcroft et al. (2006)<a href="#fnref18">↩</a></li>
<li id="fn19"><a href="#fnref19">↩</a></li>
<li id="fn20"></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
</ol>
</section>
</body>
</html>
