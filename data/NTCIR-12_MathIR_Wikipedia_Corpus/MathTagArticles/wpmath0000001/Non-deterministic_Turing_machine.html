<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="727">Non-deterministic Turing machine</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Non-deterministic Turing machine</h1>
<hr/>

<p>In <a href="theoretical_computer_science" title="wikilink">theoretical computer science</a>, a <a href="Turing_machine" title="wikilink">Turing machine</a> is a theoretical machine that is used in <a href="thought_experiment" title="wikilink">thought experiments</a> to examine the abilities and limitations of computers.</p>

<p>In essence, a Turing machine is imagined to be a simple computer that reads and writes symbols one at a time on an endless tape by strictly following a set of rules. It determines what action it should perform next according to its internal "state" and what symbol it currently sees. An example of one of a Turing Machine's rules might thus be: "If you are in state 2 and you see an 'A', change it to 'B' and move left."</p>

<p>In a <strong>deterministic Turing machine</strong>, the set of rules prescribes at most one action to be performed for any given situation. A <strong>non-deterministic Turing machine</strong> (<strong>NTM</strong>), by contrast, may have a set of rules that prescribes more than one action for a given situation. For example, a non-deterministic Turing machine may have both "If you are in state 2 and you see an 'A', change it to a 'B' and move left" and "If you are in state 2 and you see an 'A', change it to a 'C' and move right" in its rule set.</p>

<p>An ordinary (deterministic) Turing machine (DTM) has a transition function that, for a given state and symbol under the tape head, specifies three things: the symbol to be written to the tape, the direction (left, right or neither) in which the head should move, and the subsequent state of the finite control. For example, an X on the tape in state 3 might make the DTM write a Y on the tape, move the head one position to the right, and switch to state 5.</p>

<p>A non-deterministic Turing machine (NTM) differs in that the state and tape symbol no longer <em>uniquely</em> specify these things; rather, many different actions may apply for the same combination of state and symbol. For example, an X on the tape in state 3 might now allow the NTM to write a Y, move right, and switch to state 5 <em>or</em> to write an X, move left, and stay in state 3.</p>
<h2 id="definition">Definition</h2>

<p>A non-deterministic Turing machine can be formally defined as a 6-tuple 

<math display="inline" id="Non-deterministic_Turing_machine:0">
 <semantics>
  <mrow>
   <mi>M</mi>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Q</mi>
    <mo>,</mo>
    <mi mathvariant="normal">Σ</mi>
    <mo>,</mo>
    <mi>ι</mi>
    <mo>,</mo>
    <mo>⊔</mo>
    <mo>,</mo>
    <mi>A</mi>
    <mo>,</mo>
    <mi>δ</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>M</ci>
    <vector>
     <ci>Q</ci>
     <ci>normal-Σ</ci>
     <ci>ι</ci>
     <csymbol cd="latexml">square-union</csymbol>
     <ci>A</ci>
     <ci>δ</ci>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M=(Q,\Sigma,\iota,\sqcup,A,\delta)
  </annotation>
 </semantics>
</math>

, where</p>
<ul>
<li>

<math display="inline" id="Non-deterministic_Turing_machine:1">
 <semantics>
  <mi>Q</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>Q</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   Q
  </annotation>
 </semantics>
</math>

 is a finite set of states</li>
<li>

<math display="inline" id="Non-deterministic_Turing_machine:2">
 <semantics>
  <mi mathvariant="normal">Σ</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-Σ</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \Sigma
  </annotation>
 </semantics>
</math>

 is a finite set of symbols (the tape alphabet)</li>
<li>

<math display="inline" id="Non-deterministic_Turing_machine:3">
 <semantics>
  <mrow>
   <mi>ι</mi>
   <mo>∈</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <in></in>
    <ci>ι</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \iota\in Q
  </annotation>
 </semantics>
</math>

 is the initial state</li>
<li>

<math display="inline" id="Non-deterministic_Turing_machine:4">
 <semantics>
  <mrow>
   <mo>⊔</mo>
   <mo>∈</mo>
   <mi mathvariant="normal">Σ</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="latexml">square-union</csymbol>
    <in></in>
    <csymbol cd="unknown">Σ</csymbol>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \sqcup\in\Sigma
  </annotation>
 </semantics>
</math>

 is the blank symbol</li>
<li>

<math display="inline" id="Non-deterministic_Turing_machine:5">
 <semantics>
  <mrow>
   <mi>A</mi>
   <mo>⊆</mo>
   <mi>Q</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>A</ci>
    <ci>Q</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A\subseteq Q
  </annotation>
 </semantics>
</math>

 is the set of accepting (final) states</li>
<li>

<math display="inline" id="Non-deterministic_Turing_machine:6">
 <semantics>
  <mrow>
   <mi>δ</mi>
   <mo>⊆</mo>
   <mrow>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mrow>
       <mi>Q</mi>
       <mo>\</mo>
       <mi>A</mi>
      </mrow>
      <mo>×</mo>
      <mi mathvariant="normal">Σ</mi>
     </mrow>
     <mo>)</mo>
    </mrow>
    <mo>×</mo>
    <mrow>
     <mo>(</mo>
     <mrow>
      <mi>Q</mi>
      <mo>×</mo>
      <mi mathvariant="normal">Σ</mi>
      <mo>×</mo>
      <mrow>
       <mo stretchy="false">{</mo>
       <mi>L</mi>
       <mo>,</mo>
       <mi>R</mi>
       <mo stretchy="false">}</mo>
      </mrow>
     </mrow>
     <mo>)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <subset></subset>
    <ci>δ</ci>
    <apply>
     <times></times>
     <apply>
      <times></times>
      <apply>
       <ci>normal-\</ci>
       <ci>Q</ci>
       <ci>A</ci>
      </apply>
      <ci>normal-Σ</ci>
     </apply>
     <apply>
      <times></times>
      <ci>Q</ci>
      <ci>normal-Σ</ci>
      <set>
       <ci>L</ci>
       <ci>R</ci>
      </set>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \delta\subseteq\left(Q\backslash A\times\Sigma\right)\times\left(Q\times\Sigma%
\times\{L,R\}\right)
  </annotation>
 </semantics>
</math>

 is a relation on states and symbols called the <em>transition relation</em>. 

<math display="inline" id="Non-deterministic_Turing_machine:7">
 <semantics>
  <mi>L</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>L</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L
  </annotation>
 </semantics>
</math>

 is the movement to the left, and 

<math display="inline" id="Non-deterministic_Turing_machine:8">
 <semantics>
  <mi>R</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>R</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R
  </annotation>
 </semantics>
</math>

 is to the right.</li>
</ul>

<p>The difference with a standard (deterministic) <a href="Turing_machine" title="wikilink">Turing machine</a> is that for those, the transition relation is a function (the transition function).</p>

<p>Configurations and the <em>yields</em> relation on configurations, which describes the possible actions of the Turing machine given any possible contents of the tape, are as for standard Turing machines, except that the <em>yields</em> relation is no longer single-valued. The notion of string acceptance is unchanged: a non-deterministic Turing machine accepts a string if, when the machine is started on the configuration in which the tape head is on the first character of the string (if any), and the tape is all blank otherwise, at least one of the machine's possible computations from that configuration puts the machine into a state in 

<math display="inline" id="Non-deterministic_Turing_machine:9">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

. (If the machine is deterministic, the possible computations are the prefixes of a single, possibly infinite, path.)</p>
<h3 id="resolution-of-multiple-rules">Resolution of multiple rules</h3>

<p>How does the NTM "know" which of these actions it should take? There are two ways of looking at it. One is to say that the machine is the "luckiest possible guesser"; it always picks a transition that eventually leads to an accepting state, if there is such a transition. The other is to imagine that the machine "<a href="many-worlds_theory" title="wikilink">branches</a>" into many copies, each of which follows one of the possible transitions. Whereas a DTM has a single "computation path" that it follows, an NTM has a "computation tree". If at least one branch of the tree halts with an "accept" condition, we say that the NTM accepts the input.</p>
<h2 id="equivalence-with-dtms">Equivalence with DTMs</h2>

<p>In particular, nondeterministic Turing machines are equivalent with deterministic Turing machines. This equivalency refers to what can be computed, as opposed to how quickly.</p>

<p>NTMs effectively include DTMs as special cases, so it is immediately clear that DTMs are not more powerful. It might seem that NTMs are more powerful than DTMs, since they can allow trees of possible computations arising from the same initial configuration, accepting a string if any one branch in the tree accepts it.</p>

<p>However, it is possible to simulate NTMs with DTMs: One approach is to use a DTM of which the configurations represent multiple configurations of the NTM, and the DTM's operation consists of visiting each of them in turn, executing a single step at each visit, and spawning new configurations whenever the transition relation defines multiple continuations.</p>

<p>Another construction<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> simulates NTMs with 3-tape DTMs, of which the first tape always holds the original input string, the second is used to simulate a particular computation of the NTM, and the third encodes a path in the NTM's computation tree. The 3-tape DTMs are easily simulated with a normal single-tape DTM.</p>

<p>In this construction, the resulting DTM effectively performs a <a href="breadth-first_search" title="wikilink">breadth-first search</a> of the NTM's computation tree, visiting all possible computations of the NTM in order of increasing length until it finds an accepting one. Therefore, the length of an accepting computation of the DTM is, in general, exponential in the length of the shortest accepting computation of the NTM. This is considered to be a general property of simulations of NTMs by DTMs; the most famous unresolved question in computer science, the <a href="P_=_NP_problem" title="wikilink">P = NP problem</a>, is related to this issue.</p>
<h2 id="bounded-non-determinism">Bounded non-determinism</h2>

<p>An NTM has the property of bounded non-determinism, <em>i.e.</em>, if an NTM always halts on a given input tape <em>T</em> then it halts in a bounded number of steps, and therefore can only have a bounded number of possible configurations.</p>
<h2 id="comparison-with-quantum-computers">Comparison with quantum computers</h2>

<p> It is a common misconception that <a href="quantum_computer" title="wikilink">quantum computers</a> are NTMs.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> It is believed but has not been proven that the power of quantum computers is incomparable to that of NTMs.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> That is, problems likely exist that an NTM could efficiently solve that a quantum computer cannot. A likely example of problems solvable by NTMs but not by quantum computers in polynomial time are <a class="uri" href="NP-complete" title="wikilink">NP-complete</a> problems.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Probabilistic_Turing_machine" title="wikilink">Probabilistic Turing machine</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>

<p>Section 4.6: Nondeterministic Turing machines, pp. 204–211.</p></li>
<li>

<p>Section 9.6: Nondeterministic Turing machines, pp. 277–281.</p></li>
<li>

<p>Section 2.7: Nondeterministic machines, pp. 45–50.</p></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://web.archive.org/web/20080515023814/http://semillon.wpi.edu/~aofa/AofA/msg00020.html">C++ Simulator of a Nondeterministic Multitape Turing Machine</a> (free software).</li>
<li><a href="http://sourceforge.net/projects/turing-machine/">C++ Simulator of a Nondeterministic Multitape Turing Machine download link from sourceforge.net</a></li>
</ul>

<p>"</p>

<p><a href="Category:Turing_machine" title="wikilink">Category:Turing machine</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><em>Elements of the Theory of Computation</em>, by Harry R. Lewis and Christos H. Papadimitriou, Prentice-Hall, Englewood Cliffs, New Jersey, 1981, ISBN 0-13-273417-6, pp. 206-211<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="http://www.scottaaronson.com/blog/?p=198">The Orion Quantum Computer Anti-Hype FAQ</a>, <a href="Scott_Aaronson" title="wikilink">Scott Aaronson</a>.<a href="#fnref2">↩</a></li>
<li id="fn3">.<a href="#fnref3">↩</a></li>
</ol>
</section>
</body>
</html>
