<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="125">Block cipher</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Block cipher</h1>
<hr/>

<p>In <a class="uri" href="cryptography" title="wikilink">cryptography</a>, a <strong>block cipher</strong> is a <a href="deterministic_algorithm" title="wikilink">deterministic algorithm</a> operating on fixed-length groups of <a href="bit" title="wikilink">bits</a>, called <em>blocks</em>, with an unvarying transformation that is specified by a <a href="symmetric_key" title="wikilink">symmetric key</a>. Block ciphers are important <a href="cryptographic_primitive" title="wikilink">elementary components</a> in the design of many <a href="cryptographic_protocol" title="wikilink">cryptographic protocols</a>, and are widely used to implement <a class="uri" href="encryption" title="wikilink">encryption</a> of bulk data.</p>

<p>The modern design of block ciphers is based on the concept of an <em>iterated</em> <a href="product_cipher" title="wikilink">product cipher</a>. Product ciphers were suggested and analyzed by <a href="Claude_Shannon" title="wikilink">Claude Shannon</a> in his seminal 1949 publication <em><a href="Communication_Theory_of_Secrecy_Systems" title="wikilink">Communication Theory of Secrecy Systems</a></em> as a means to effectively improve security by combining simple operations such as <a href="substitution_cipher" title="wikilink">substitutions</a> and <a href="transposition_cipher" title="wikilink">permutations</a>.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> Iterated product ciphers carry out encryption in multiple rounds, each of which uses a different subkey derived from the original key. One widespread implementation of such ciphers is called a <a href="Feistel_network" title="wikilink">Feistel network</a>, named after <a href="Horst_Feistel" title="wikilink">Horst Feistel</a>, and notably implemented in the <a href="Data_Encryption_Standard" title="wikilink">DES</a> cipher.<a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a> Many other realizations of block ciphers, such as the <a href="Advanced_Encryption_Standard" title="wikilink">AES</a>, are classified as <a href="substitution-permutation_network" title="wikilink">substitution-permutation networks</a>.</p>

<p>The publication of the DES cipher by the U.S. National Bureau of Standards (now <a href="National_Institute_of_Standards_and_Technology" title="wikilink">National Institute of Standards and Technology</a>, NIST) in 1977 was fundamental in the public understanding of modern block cipher design. In the same way, it influenced the academic development of <a href="cryptanalysis" title="wikilink">cryptanalytic attacks</a>. Both <a href="differential_cryptanalysis" title="wikilink">differential</a> and <a href="linear_cryptanalysis" title="wikilink">linear cryptanalysis</a> arose out of studies on the DES design. Today, there is a palette of attack techniques against which a block cipher must be secure, in addition to being robust against <a href="brute_force_attack" title="wikilink">brute force attacks</a>.</p>

<p>Even a secure block cipher is suitable only for the encryption of a single block under a fixed key. A multitude of <a href="block_cipher_modes_of_operation" title="wikilink">modes of operation</a> have been designed to allow their repeated use in a secure way, commonly to achieve the security goals of <a class="uri" href="confidentiality" title="wikilink">confidentiality</a> and <a href="authentication" title="wikilink">authenticity</a>. However, block ciphers may also be used as building blocks in other cryptographic protocols, such as <a href="universal_hash_function" title="wikilink">universal hash functions</a> and <a href="pseudo-random_number_generator" title="wikilink">pseudo-random number generators</a>.</p>
<h2 id="definition">Definition</h2>

<p>A block cipher consists of two paired <a href="algorithm" title="wikilink">algorithms</a>, one for encryption, <em>E</em>, and the other for decryption, <em>D</em>.<a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> Both algorithms accept two inputs: an input block of size <em>n</em> bits and a <a href="key_(cryptography)" title="wikilink">key</a> of size <em>k</em> bits; and both yield an <em>n</em>-bit output block. The decryption algorithm <em>D</em> is defined to be the <a href="inverse_function" title="wikilink">inverse function</a> of encryption, i.e., <em>D</em> = <em>E</em><sup>−1</sup>. More formally,<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a> a block cipher is specified by an encryption function</p>

<p>

<math display="block" id="Block_cipher:0">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msub>
       <mi>E</mi>
       <mi>K</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>P</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>:=</mo>
     <mrow>
      <mi>E</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>K</mi>
       <mo>,</mo>
       <mi>P</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">{</mo>
        <mn>0</mn>
        <mo>,</mo>
        <mn>1</mn>
        <mo stretchy="false">}</mo>
       </mrow>
       <mi>k</mi>
      </msup>
      <mo>×</mo>
      <msup>
       <mrow>
        <mo stretchy="false">{</mo>
        <mn>0</mn>
        <mo>,</mo>
        <mn>1</mn>
        <mo stretchy="false">}</mo>
       </mrow>
       <mi>n</mi>
      </msup>
     </mrow>
     <mo>→</mo>
     <msup>
      <mrow>
       <mo stretchy="false">{</mo>
       <mn>0</mn>
       <mo>,</mo>
       <mn>1</mn>
       <mo stretchy="false">}</mo>
      </mrow>
      <mi>n</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="latexml">assign</csymbol>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>E</ci>
       <ci>K</ci>
      </apply>
      <ci>P</ci>
     </apply>
     <apply>
      <times></times>
      <ci>E</ci>
      <interval closure="open">
       <ci>K</ci>
       <ci>P</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <set>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
       </set>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <set>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
       </set>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <set>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </set>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{K}(P):=E(K,P):\{0,1\}^{k}\times\{0,1\}^{n}\rightarrow\{0,1\}^{n},
  </annotation>
 </semantics>
</math>

 which takes as input a key <em>K</em> of bit length <em>k</em>, called the <em>key size</em>, and a bit string <em>P</em> of length <em>n</em>, called the <em>block size</em>, and returns a string <em>C</em> of <em>n</em> bits. <em>P</em> is called the <a class="uri" href="plaintext" title="wikilink">plaintext</a>, and <em>C</em> is termed the <a class="uri" href="ciphertext" title="wikilink">ciphertext</a>. For each <em>K</em>, the function <em>E</em><sub><em>K</em></sub>(<em>P</em>) is required to be an invertible mapping on {0,1}<sup><em>n</em></sup>. The inverse for <em>E</em> is defined as a function</p>

<p>

<math display="block" id="Block_cipher:1">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mrow>
      <msubsup>
       <mi>E</mi>
       <mi>K</mi>
       <mrow>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msubsup>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>C</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>:=</mo>
     <mrow>
      <msub>
       <mi>D</mi>
       <mi>K</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>C</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mrow>
      <mi>D</mi>
      <mrow>
       <mo stretchy="false">(</mo>
       <mi>K</mi>
       <mo>,</mo>
       <mi>C</mi>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <msup>
       <mrow>
        <mo stretchy="false">{</mo>
        <mn>0</mn>
        <mo>,</mo>
        <mn>1</mn>
        <mo stretchy="false">}</mo>
       </mrow>
       <mi>k</mi>
      </msup>
      <mo>×</mo>
      <msup>
       <mrow>
        <mo stretchy="false">{</mo>
        <mn>0</mn>
        <mo>,</mo>
        <mn>1</mn>
        <mo stretchy="false">}</mo>
       </mrow>
       <mi>n</mi>
      </msup>
     </mrow>
     <mo>→</mo>
     <msup>
      <mrow>
       <mo stretchy="false">{</mo>
       <mn>0</mn>
       <mo>,</mo>
       <mn>1</mn>
       <mo stretchy="false">}</mo>
      </mrow>
      <mi>n</mi>
     </msup>
    </mrow>
   </mrow>
   <mo>,</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <and></and>
     <apply>
      <csymbol cd="latexml">assign</csymbol>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>E</ci>
         <ci>K</ci>
        </apply>
        <apply>
         <minus></minus>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <ci>C</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>D</ci>
        <ci>K</ci>
       </apply>
       <ci>C</ci>
      </apply>
     </apply>
     <apply>
      <eq></eq>
      <share href="#.cmml">
      </share>
      <apply>
       <times></times>
       <ci>D</ci>
       <interval closure="open">
        <ci>K</ci>
        <ci>C</ci>
       </interval>
      </apply>
     </apply>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <set>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
       </set>
       <ci>k</ci>
      </apply>
      <apply>
       <csymbol cd="ambiguous">superscript</csymbol>
       <set>
        <cn type="integer">0</cn>
        <cn type="integer">1</cn>
       </set>
       <ci>n</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <set>
       <cn type="integer">0</cn>
       <cn type="integer">1</cn>
      </set>
      <ci>n</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   E_{K}^{-1}(C):=D_{K}(C)=D(K,C):\{0,1\}^{k}\times\{0,1\}^{n}\rightarrow\{0,1\}^%
{n},
  </annotation>
 </semantics>
</math>

 taking a key <em>K</em> and a ciphertext <em>C</em> to return a plaintext value <em>P</em>, such that</p>

<p>

<math display="block" id="Block_cipher:2">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mo>∀</mo>
     <mi>K</mi>
    </mrow>
    <mo>:</mo>
    <mrow>
     <mrow>
      <msub>
       <mi>D</mi>
       <mi>K</mi>
      </msub>
      <mrow>
       <mo stretchy="false">(</mo>
       <mrow>
        <msub>
         <mi>E</mi>
         <mi>K</mi>
        </msub>
        <mrow>
         <mo stretchy="false">(</mo>
         <mi>P</mi>
         <mo stretchy="false">)</mo>
        </mrow>
       </mrow>
       <mo stretchy="false">)</mo>
      </mrow>
     </mrow>
     <mo>=</mo>
     <mi>P</mi>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <csymbol cd="latexml">for-all</csymbol>
     <ci>K</ci>
    </apply>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>D</ci>
       <ci>K</ci>
      </apply>
      <apply>
       <times></times>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>E</ci>
        <ci>K</ci>
       </apply>
       <ci>P</ci>
      </apply>
     </apply>
     <ci>P</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \forall K:D_{K}(E_{K}(P))=P.
  </annotation>
 </semantics>
</math>

</p>

<p>For example, a block cipher encryption algorithm might take a 128-bit block of plaintext as input, and output a corresponding 128-bit block of ciphertext. The exact transformation is controlled using a second input – the secret key. Decryption is similar: the decryption algorithm takes, in this example, a 128-bit block of ciphertext together with the secret key, and yields the original 128-bit block of plain text.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>For each key <em>K</em>, <em>E<sub>K</sub></em> is a <a class="uri" href="permutation" title="wikilink">permutation</a> (a <a class="uri" href="bijective" title="wikilink">bijective</a> mapping) over the set of input blocks. Each key selects one permutation from the possible set of 

<math display="inline" id="Block_cipher:3">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msup>
     <mn>2</mn>
     <mi>n</mi>
    </msup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo lspace="0pt" rspace="3.5pt">!</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <factorial></factorial>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <cn type="integer">2</cn>
     <ci>n</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (2^{n})!
  </annotation>
 </semantics>
</math>

.</p>
<h2 id="design">Design</h2>
<h3 id="iterated-block-ciphers">Iterated block ciphers</h3>

<p>Most block cipher algorithms are classified as <em>iterated block ciphers</em> which means that they transform fixed-size blocks of plain-text into identical size blocks of ciphertext, via the repeated application of an invertible transformation known as the <em>round function</em>, with each iteration referred to as a <em>round</em>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a></p>

<p>Usually, the round function <em>R</em> takes different <em>round keys</em> <em>K<sub>i</sub></em> as second input, which are derived from the original key:</p>

<p>

<math display="block" id="Block_cipher:4">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>R</mi>
     <msub>
      <mi>K</mi>
      <mi>i</mi>
     </msub>
    </msub>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>M</mi>
      <mrow>
       <mi>i</mi>
       <mo>-</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>i</ci>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <apply>
       <minus></minus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{i}=R_{K_{i}}(M_{i-1})
  </annotation>
 </semantics>
</math>

 where 

<math display="inline" id="Block_cipher:5">
 <semantics>
  <msub>
   <mi>M</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{0}
  </annotation>
 </semantics>
</math>

 is the plaintext and 

<math display="inline" id="Block_cipher:6">
 <semantics>
  <msub>
   <mi>M</mi>
   <mi>r</mi>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>M</ci>
    <ci>r</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{r}
  </annotation>
 </semantics>
</math>

 the ciphertext, with <em>r</em> being the round number.</p>

<p>Frequently, <a href="key_whitening" title="wikilink">key whitening</a> is used in addition to this. At the beginning and the end, the data is modified with key material (often with <a href="Exclusive_or" title="wikilink">XOR</a>, but simple arithmetic operations like adding and subtracting are also used):</p>

<p>

<math display="block" id="Block_cipher:7">
 <semantics>
  <mrow>
   <msub>
    <mi>M</mi>
    <mn>0</mn>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi>M</mi>
    <mo>⊕</mo>
    <msub>
     <mi>K</mi>
     <mn>0</mn>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>M</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <ci>M</ci>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <cn type="integer">0</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{0}=M\oplus K_{0}
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Block_cipher:8">
 <semantics>
  <mrow>
   <mrow>
    <msub>
     <mi>M</mi>
     <mi>i</mi>
    </msub>
    <mo>=</mo>
    <mrow>
     <msub>
      <mi>R</mi>
      <msub>
       <mi>K</mi>
       <mi>i</mi>
      </msub>
     </msub>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>M</mi>
       <mrow>
        <mi>i</mi>
        <mo>-</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo rspace="5.3pt" stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo rspace="5.3pt">;</mo>
   <mrow>
    <mi>i</mi>
    <mo>=</mo>
    <mrow>
     <mn>1</mn>
     <mi mathvariant="normal">…</mi>
     <mi>r</mi>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">formulae-sequence</csymbol>
    <apply>
     <eq></eq>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>M</ci>
       <apply>
        <minus></minus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <ci>i</ci>
     <apply>
      <times></times>
      <cn type="integer">1</cn>
      <ci>normal-…</ci>
      <ci>r</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   M_{i}=R_{K_{i}}(M_{i-1})\;;\;i=1\dots r
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Block_cipher:9">
 <semantics>
  <mrow>
   <mi>C</mi>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>M</mi>
     <mi>r</mi>
    </msub>
    <mo>⊕</mo>
    <msub>
     <mi>K</mi>
     <mrow>
      <mi>r</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>C</ci>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>M</ci>
      <ci>r</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>K</ci>
      <apply>
       <plus></plus>
       <ci>r</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   C=M_{r}\oplus K_{r+1}
  </annotation>
 </semantics>
</math>

</p>

<p>Given one of the standard iterated block cipher design schemes, it is fairly easy to construct a block cipher that is cryptographically secure, simply by using a large number of rounds. However, this will make the cipher inefficient. Thus, efficiency is the most important additional design criterion for professional ciphers. Further, a good block cipher is designed to avoid side-channel attacks, such as input-dependent memory accesses that might leak secret data via the cache state or the execution time. In addition, the cipher should be concise, for small hardware and software implementations. Finally, the cipher should be easily cryptanalyzable, such that it can be shown to how many rounds the cipher needs to be reduced such that the existing cryptographic attacks would work and, conversely, that the number of actual rounds is large enough to protect against them.</p>
<h3 id="substitution-permutation-networks">Substitution-permutation networks</h3>

<p> </p>

<p>One important type of iterated block cipher known as a <em><a href="substitution-permutation_network" title="wikilink">substitution-permutation network</a> (SPN)</em> takes a block of the plaintext and the key as inputs, and applies several alternating rounds consisting of a <a href="Substitution_box" title="wikilink">substitution stage</a> followed by a <a href="Permutation_box" title="wikilink">permutation stage</a>—to produce each block of ciphertext output.<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> The non-linear substitution stage mixes the key bits with those of the plaintext, creating Shannon's <em><a href="confusion_(cryptography)" title="wikilink">confusion</a></em>. The linear permutation stage then dissipates redundancies, creating <em><a href="diffusion_(cryptography)" title="wikilink">diffusion</a></em>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a><a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>

<p>A <em><a href="substitution_box" title="wikilink">substitution box</a> (S-box)</em> substitutes a small block of input bits with another block of output bits. This substitution must be <a href="Bijection" title="wikilink">one-to-one</a>, to ensure invertibility (hence decryption). A secure S-box will have the property that changing one input bit will change about half of the output bits on average, exhibiting what is known as the <a href="avalanche_effect" title="wikilink">avalanche effect</a>—i.e. it has the property that each output bit will depend on every input bit.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a></p>

<p>A <em><a href="permutation_box" title="wikilink">permutation box</a> (P-box)</em> is a <a class="uri" href="permutation" title="wikilink">permutation</a> of all the bits: it takes the outputs of all the S-boxes of one round, permutes the bits, and feeds them into the S-boxes of the next round. A good P-box has the property that the output bits of any S-box are distributed to as many S-box inputs as possible.</p>

<p>At each round, the round key (obtained from the key with some simple operations, for instance, using S-boxes and P-boxes) is combined using some group operation, typically <a class="uri" href="XOR" title="wikilink">XOR</a>.</p>

<p><a class="uri" href="Decryption" title="wikilink">Decryption</a> is done by simply reversing the process (using the inverses of the S-boxes and P-boxes and applying the round keys in reversed order).</p>
<h3 id="feistel-ciphers">Feistel ciphers</h3>

<p>  In a <em><a href="Feistel_cipher" title="wikilink">Feistel cipher</a></em>, the block of plain text to be encrypted is split into two equal-sized halves. The round function is applied to one half, using a subkey, and then the output is XORed with the other half. The two halves are then swapped.</p>

<p>Let 

<math display="inline" id="Block_cipher:10">
 <semantics>
  <mi mathvariant="normal">F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm F}
  </annotation>
 </semantics>
</math>

 be the round function and let 

<math display="inline" id="Block_cipher:11">
 <semantics>
  <mrow>
   <msub>
    <mi>K</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>K</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>K</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{0},K_{1},\ldots,K_{n}
  </annotation>
 </semantics>
</math>

 be the sub-keys for the rounds 

<math display="inline" id="Block_cipher:12">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
    <ci>normal-…</ci>
    <ci>n</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0,1,\ldots,n
  </annotation>
 </semantics>
</math>

 respectively.</p>

<p>Then the basic operation is as follows:</p>

<p>Split the plaintext block into two equal pieces, (

<math display="inline" id="Block_cipher:13">
 <semantics>
  <msub>
   <mi>L</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{0}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Block_cipher:14">
 <semantics>
  <msub>
   <mi>R</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{0}
  </annotation>
 </semantics>
</math>

)</p>

<p>For each round 

<math display="inline" id="Block_cipher:15">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=0,1,\dots,n
  </annotation>
 </semantics>
</math>

, compute</p>

<p>

<math display="block" id="Block_cipher:16">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <msub>
     <mi>R</mi>
     <mi>i</mi>
    </msub>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>i</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{i+1}=R_{i}\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Block_cipher:17">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mrow>
     <mi>i</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>L</mi>
     <mi>i</mi>
    </msub>
    <mo>⊕</mo>
    <mrow>
     <mi mathvariant="normal">F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>R</mi>
       <mi>i</mi>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>K</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <ci>i</ci>
     </apply>
     <apply>
      <times></times>
      <ci>normal-F</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>R</ci>
        <ci>i</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <ci>i</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{i+1}=L_{i}\oplus{\rm F}(R_{i},K_{i})
  </annotation>
 </semantics>
</math>

.</p>

<p>Then the ciphertext is 

<math display="inline" id="Block_cipher:18">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>R</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>L</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (R_{n+1},L_{n+1})
  </annotation>
 </semantics>
</math>

.</p>

<p>Decryption of a ciphertext 

<math display="inline" id="Block_cipher:19">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>R</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>L</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (R_{n+1},L_{n+1})
  </annotation>
 </semantics>
</math>

 is accomplished by computing for 

<math display="inline" id="Block_cipher:20">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mi>n</mi>
    <mo>,</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <ci>n</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <cn type="integer">0</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=n,n-1,\ldots,0
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Block_cipher:21">
 <semantics>
  <mrow>
   <msub>
    <mi>R</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mpadded width="+1.7pt">
    <msub>
     <mi>L</mi>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
   </mpadded>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <apply>
      <plus></plus>
      <ci>i</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{i}=L_{i+1}\,
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Block_cipher:22">
 <semantics>
  <mrow>
   <msub>
    <mi>L</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <msub>
     <mi>R</mi>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>⊕</mo>
    <mrow>
     <mi mathvariant="normal">F</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <msub>
       <mi>L</mi>
       <mrow>
        <mi>i</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
      </msub>
      <mo>,</mo>
      <msub>
       <mi>K</mi>
       <mi>i</mi>
      </msub>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">direct-sum</csymbol>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <apply>
       <plus></plus>
       <ci>i</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <times></times>
      <ci>normal-F</ci>
      <interval closure="open">
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>L</ci>
        <apply>
         <plus></plus>
         <ci>i</ci>
         <cn type="integer">1</cn>
        </apply>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>K</ci>
        <ci>i</ci>
       </apply>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{i}=R_{i+1}\oplus{\rm F}(L_{i+1},K_{i})
  </annotation>
 </semantics>
</math>

.</p>

<p>Then 

<math display="inline" id="Block_cipher:23">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>L</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>R</mi>
    <mn>0</mn>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <cn type="integer">0</cn>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (L_{0},R_{0})
  </annotation>
 </semantics>
</math>

 is the plaintext again.</p>

<p>One advantage of the Feistel model compared to a <a href="substitution-permutation_network" title="wikilink">substitution-permutation network</a> is that the round function 

<math display="inline" id="Block_cipher:24">
 <semantics>
  <mi mathvariant="normal">F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   {\rm F}
  </annotation>
 </semantics>
</math>

 does not have to be invertible.</p>
<h3 id="lai-massey-ciphers">Lai-Massey ciphers</h3>

<p> </p>

<p>The Lai-Massey scheme offers security properties similar to those of the <a href="Feistel_structure" title="wikilink">Feistel structure</a>. It also shares its advantage that the round function 

<math display="inline" id="Block_cipher:25">
 <semantics>
  <mi mathvariant="normal">F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{F}
  </annotation>
 </semantics>
</math>

 does not have to be invertible. Another similarity is that is also splits the input block into two equal pieces. However, the round function is applied to the difference between the two, and the result is then added to both half blocks.</p>

<p>Let 

<math display="inline" id="Block_cipher:26">
 <semantics>
  <mi mathvariant="normal">F</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-F</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{F}
  </annotation>
 </semantics>
</math>

 be the round function and 

<math display="inline" id="Block_cipher:27">
 <semantics>
  <mi mathvariant="normal">H</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>normal-H</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \mathrm{H}
  </annotation>
 </semantics>
</math>

 a half-round function and let 

<math display="inline" id="Block_cipher:28">
 <semantics>
  <mrow>
   <msub>
    <mi>K</mi>
    <mn>0</mn>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>K</mi>
    <mn>1</mn>
   </msub>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <msub>
    <mi>K</mi>
    <mi>n</mi>
   </msub>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <cn type="integer">0</cn>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <cn type="integer">1</cn>
    </apply>
    <ci>normal-…</ci>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>K</ci>
     <ci>n</ci>
    </apply>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   K_{0},K_{1},\ldots,K_{n}
  </annotation>
 </semantics>
</math>

 be the sub-keys for the rounds 

<math display="inline" id="Block_cipher:29">
 <semantics>
  <mrow>
   <mn>0</mn>
   <mo>,</mo>
   <mn>1</mn>
   <mo>,</mo>
   <mi mathvariant="normal">…</mi>
   <mo>,</mo>
   <mi>n</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <list>
    <cn type="integer">0</cn>
    <cn type="integer">1</cn>
    <ci>normal-…</ci>
    <ci>n</ci>
   </list>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   0,1,\ldots,n
  </annotation>
 </semantics>
</math>

 respectively.</p>

<p>Then the basic operation is as follows:</p>

<p>Split the plaintext block into two equal pieces, (

<math display="inline" id="Block_cipher:30">
 <semantics>
  <msub>
   <mi>L</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>L</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   L_{0}
  </annotation>
 </semantics>
</math>

, 

<math display="inline" id="Block_cipher:31">
 <semantics>
  <msub>
   <mi>R</mi>
   <mn>0</mn>
  </msub>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">subscript</csymbol>
    <ci>R</ci>
    <cn type="integer">0</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   R_{0}
  </annotation>
 </semantics>
</math>

)</p>

<p>For each round 

<math display="inline" id="Block_cipher:32">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mn>0</mn>
    <mo>,</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mi>n</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <cn type="integer">0</cn>
     <cn type="integer">1</cn>
     <ci>normal-…</ci>
     <ci>n</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=0,1,\dots,n
  </annotation>
 </semantics>
</math>

, compute</p>

<p>

<math display="block" id="Block_cipher:33">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>L</mi>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo>′</mo>
    </msubsup>
    <mo>,</mo>
    <msubsup>
     <mi>R</mi>
     <mrow>
      <mi>i</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo>′</mo>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msubsup>
       <mi>L</mi>
       <mi>i</mi>
       <mo>′</mo>
      </msubsup>
      <mo>+</mo>
      <msub>
       <mi>T</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msubsup>
       <mi>R</mi>
       <mi>i</mi>
       <mo>′</mo>
      </msubsup>
      <mo>+</mo>
      <msub>
       <mi>T</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <apply>
        <plus></plus>
        <ci>i</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-′</ci>
     </apply>
    </interval>
    <apply>
     <times></times>
     <ci>normal-H</ci>
     <interval closure="open">
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <ci>i</ci>
        </apply>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <plus></plus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <ci>i</ci>
        </apply>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (L_{i+1}^{\prime},R_{i+1}^{\prime})=\mathrm{H}(L_{i}^{\prime}+T_{i},R_{i}^{%
\prime}+T_{i})
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Block_cipher:34">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msubsup>
       <mi>L</mi>
       <mi>i</mi>
       <mo>′</mo>
      </msubsup>
      <mo>-</mo>
      <msubsup>
       <mi>R</mi>
       <mi>i</mi>
       <mo>′</mo>
      </msubsup>
     </mrow>
     <mo>,</mo>
     <msub>
      <mi>K</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-F</ci>
     <interval closure="open">
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <ci>i</ci>
        </apply>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <ci>i</ci>
        </apply>
        <ci>normal-′</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>i</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{i}=\mathrm{F}(L_{i}^{\prime}-R_{i}^{\prime},K_{i})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Block_cipher:35">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>L</mi>
     <mn>0</mn>
     <mo>′</mo>
    </msubsup>
    <mo>,</mo>
    <msubsup>
     <mi>R</mi>
     <mn>0</mn>
     <mo>′</mo>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">H</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>L</mi>
      <mn>0</mn>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>R</mi>
      <mn>0</mn>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>normal-′</ci>
     </apply>
    </interval>
    <apply>
     <times></times>
     <ci>normal-H</ci>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <cn type="integer">0</cn>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <cn type="integer">0</cn>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (L_{0}^{\prime},R_{0}^{\prime})=\mathrm{H}(L_{0},R_{0})
  </annotation>
 </semantics>
</math>

</p>

<p>Then the ciphertext is 

<math display="inline" id="Block_cipher:36">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>L</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>R</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>L</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo>′</mo>
    </msubsup>
    <mo>,</mo>
    <msubsup>
     <mi>R</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo>′</mo>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <apply>
       <plus></plus>
       <ci>n</ci>
       <cn type="integer">1</cn>
      </apply>
     </apply>
    </interval>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-′</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (L_{n+1},R_{n+1})=(L_{n+1}^{\prime},R_{n+1}^{\prime})
  </annotation>
 </semantics>
</math>

.</p>

<p>Decryption of a ciphertext 

<math display="inline" id="Block_cipher:37">
 <semantics>
  <mrow>
   <mo stretchy="false">(</mo>
   <msub>
    <mi>L</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo>,</mo>
   <msub>
    <mi>R</mi>
    <mrow>
     <mi>n</mi>
     <mo>+</mo>
     <mn>1</mn>
    </mrow>
   </msub>
   <mo stretchy="false">)</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <interval closure="open">
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>L</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>R</ci>
     <apply>
      <plus></plus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
    </apply>
   </interval>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (L_{n+1},R_{n+1})
  </annotation>
 </semantics>
</math>

 is accomplished by computing for 

<math display="inline" id="Block_cipher:38">
 <semantics>
  <mrow>
   <mi>i</mi>
   <mo>=</mo>
   <mrow>
    <mi>n</mi>
    <mo>,</mo>
    <mrow>
     <mi>n</mi>
     <mo>-</mo>
     <mn>1</mn>
    </mrow>
    <mo>,</mo>
    <mi mathvariant="normal">…</mi>
    <mo>,</mo>
    <mn>0</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <ci>i</ci>
    <list>
     <ci>n</ci>
     <apply>
      <minus></minus>
      <ci>n</ci>
      <cn type="integer">1</cn>
     </apply>
     <ci>normal-…</ci>
     <cn type="integer">0</cn>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   i=n,n-1,\ldots,0
  </annotation>
 </semantics>
</math>

</p>

<p>

<math display="block" id="Block_cipher:39">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>L</mi>
     <mi>i</mi>
     <mo>′</mo>
    </msubsup>
    <mo>,</mo>
    <msubsup>
     <mi>R</mi>
     <mi>i</mi>
     <mo>′</mo>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi mathvariant="normal">H</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msubsup>
       <mi>L</mi>
       <mrow>
        <mi>i</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo>′</mo>
      </msubsup>
      <mo>-</mo>
      <msub>
       <mi>T</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo>,</mo>
     <mrow>
      <msubsup>
       <mi>R</mi>
       <mrow>
        <mi>i</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo>′</mo>
      </msubsup>
      <mo>-</mo>
      <msub>
       <mi>T</mi>
       <mi>i</mi>
      </msub>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <ci>i</ci>
      </apply>
      <ci>normal-′</ci>
     </apply>
    </interval>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-H</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <interval closure="open">
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <apply>
          <plus></plus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <ci>i</ci>
       </apply>
      </apply>
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <apply>
          <plus></plus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">subscript</csymbol>
        <ci>T</ci>
        <ci>i</ci>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (L_{i}^{\prime},R_{i}^{\prime})=\mathrm{H}^{-1}(L_{i+1}^{\prime}-T_{i},R_{i+1}%
^{\prime}-T_{i})
  </annotation>
 </semantics>
</math>

</p>

<p>where 

<math display="inline" id="Block_cipher:40">
 <semantics>
  <mrow>
   <msub>
    <mi>T</mi>
    <mi>i</mi>
   </msub>
   <mo>=</mo>
   <mrow>
    <mi mathvariant="normal">F</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <msubsup>
       <mi>L</mi>
       <mrow>
        <mi>i</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo>′</mo>
      </msubsup>
      <mo>-</mo>
      <msubsup>
       <mi>R</mi>
       <mrow>
        <mi>i</mi>
        <mo>+</mo>
        <mn>1</mn>
       </mrow>
       <mo>′</mo>
      </msubsup>
     </mrow>
     <mo>,</mo>
     <msub>
      <mi>K</mi>
      <mi>i</mi>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>T</ci>
     <ci>i</ci>
    </apply>
    <apply>
     <times></times>
     <ci>normal-F</ci>
     <interval closure="open">
      <apply>
       <minus></minus>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>L</ci>
         <apply>
          <plus></plus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>normal-′</ci>
       </apply>
       <apply>
        <csymbol cd="ambiguous">superscript</csymbol>
        <apply>
         <csymbol cd="ambiguous">subscript</csymbol>
         <ci>R</ci>
         <apply>
          <plus></plus>
          <ci>i</ci>
          <cn type="integer">1</cn>
         </apply>
        </apply>
        <ci>normal-′</ci>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>K</ci>
       <ci>i</ci>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   T_{i}=\mathrm{F}(L_{i+1}^{\prime}-R_{i+1}^{\prime},K_{i})
  </annotation>
 </semantics>
</math>

 and 

<math display="inline" id="Block_cipher:41">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>L</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo>′</mo>
    </msubsup>
    <mo>,</mo>
    <msubsup>
     <mi>R</mi>
     <mrow>
      <mi>n</mi>
      <mo>+</mo>
      <mn>1</mn>
     </mrow>
     <mo>′</mo>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <msup>
     <mi mathvariant="normal">H</mi>
     <mrow>
      <mo>-</mo>
      <mn>1</mn>
     </mrow>
    </msup>
    <mrow>
     <mo stretchy="false">(</mo>
     <msub>
      <mi>L</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo>,</mo>
     <msub>
      <mi>R</mi>
      <mrow>
       <mi>n</mi>
       <mo>+</mo>
       <mn>1</mn>
      </mrow>
     </msub>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <ci>normal-′</ci>
     </apply>
    </interval>
    <apply>
     <times></times>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>normal-H</ci>
      <apply>
       <minus></minus>
       <cn type="integer">1</cn>
      </apply>
     </apply>
     <interval closure="open">
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <apply>
        <plus></plus>
        <ci>n</ci>
        <cn type="integer">1</cn>
       </apply>
      </apply>
     </interval>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (L_{n+1}^{\prime},R_{n+1}^{\prime})=\mathrm{H}^{-1}(L_{n+1},R_{n+1})
  </annotation>
 </semantics>
</math>

</p>

<p>Then 

<math display="inline" id="Block_cipher:42">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <msub>
     <mi>L</mi>
     <mn>0</mn>
    </msub>
    <mo>,</mo>
    <msub>
     <mi>R</mi>
     <mn>0</mn>
    </msub>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <msubsup>
     <mi>L</mi>
     <mn>0</mn>
     <mo>′</mo>
    </msubsup>
    <mo>,</mo>
    <msubsup>
     <mi>R</mi>
     <mn>0</mn>
     <mo>′</mo>
    </msubsup>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>L</ci>
      <cn type="integer">0</cn>
     </apply>
     <apply>
      <csymbol cd="ambiguous">subscript</csymbol>
      <ci>R</ci>
      <cn type="integer">0</cn>
     </apply>
    </interval>
    <interval closure="open">
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>L</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>normal-′</ci>
     </apply>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <apply>
       <csymbol cd="ambiguous">subscript</csymbol>
       <ci>R</ci>
       <cn type="integer">0</cn>
      </apply>
      <ci>normal-′</ci>
     </apply>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   (L_{0},R_{0})=(L_{0}^{\prime},R_{0}^{\prime})
  </annotation>
 </semantics>
</math>

 is the plaintext again.</p>
<h3 id="operations">Operations</h3>
<h4 id="arx-add-rotate-xor">ARX add-rotate-xor</h4>

<p>Many modern block ciphers and hashes are <strong>ARX</strong> algorithms—their round function involves only three operations: <a href="modular_addition" title="wikilink">modular addition</a>, <a href="circular_shift" title="wikilink">rotation</a> with fixed rotation amounts, and <a href="exclusive_or" title="wikilink">XOR</a> (ARX). Examples include <a class="uri" href="Salsa20" title="wikilink">Salsa20</a> and <a href="Speck_(cipher)" title="wikilink">Speck</a> and <a href="BLAKE_(hash_function)" title="wikilink">BLAKE</a>. Many authors draw an ARX network, a kind of <a href="data_flow_diagram" title="wikilink">data flow diagram</a>, to illustrate such a round function.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a></p>

<p>These ARX operations are popular because they are relatively fast and cheap in hardware and software, and also because they run in constant time, and are therefore immune to <a href="timing_attack" title="wikilink">timing attacks</a>. The <a href="rotational_cryptanalysis" title="wikilink">rotational cryptanalysis</a> technique attempts to attack such round functions.</p>
<h4 id="other-operations">other operations</h4>

<p>Other operations often used in block ciphers include data-dependent rotations as in <a class="uri" href="RC5" title="wikilink">RC5</a> and <a class="uri" href="RC6" title="wikilink">RC6</a>, a <a href="substitution_box" title="wikilink">substitution box</a> implemented as a <a href="lookup_table" title="wikilink">lookup table</a> as in <a href="Data_Encryption_Standard" title="wikilink">Data Encryption Standard</a> and <a href="Advanced_Encryption_Standard" title="wikilink">Advanced Encryption Standard</a>, a <a href="permutation_box" title="wikilink">permutation box</a>, and multiplication as in <a href="IDEA_(cipher)" title="wikilink">IDEA</a>.</p>
<h2 id="modes-of-operation">Modes of operation</h2>

<p> A block cipher by itself allows encryption only of a single data block of the cipher's block length. For a variable-length message, the data must first be partitioned into separate cipher blocks. In the simplest case, known as the <a href="electronic_codebook" title="wikilink">electronic codebook</a> (ECB) mode, a message is first split into separate blocks of the cipher's block size (possibly extending the last block with <a href="Padding_(cryptography)" title="wikilink">padding</a> bits), and then each block is encrypted and decrypted independently. However, such a naive method is generally insecure because equal plaintext blocks will always generate equal ciphertext blocks (for the same key), so patterns in the plaintext message become evident in the ciphertext output.</p>

<p>To overcome this limitation, several so-called <a href="block_cipher_modes_of_operation" title="wikilink">block cipher modes of operation</a> have been designed<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a> and specified in national recommendations such as NIST 800-38A<a class="footnoteRef" href="#fn14" id="fnref14"><sup>14</sup></a> and <a href="Bundesamt_für_Sicherheit_in_der_Informationstechnik" title="wikilink">BSI</a> TR-02102<a class="footnoteRef" href="#fn15" id="fnref15"><sup>15</sup></a> and international standards such as <a href="ISO/IEC_10116" title="wikilink">ISO/IEC 10116</a>.<a class="footnoteRef" href="#fn16" id="fnref16"><sup>16</sup></a> The general concept is to use <a class="uri" href="randomization" title="wikilink">randomization</a> of the plaintext data based on an additional input value, frequently called an <a href="initialization_vector" title="wikilink">initialization vector</a>, to create what is termed <a href="probabilistic_encryption" title="wikilink">probabilistic encryption</a>. In the popular <a href="cipher_block_chaining" title="wikilink">cipher block chaining</a> (CBC) mode, for encryption to be <a href="semantic_security" title="wikilink">secure</a> the initialization vector passed along with the plaintext message must be a random or <a class="uri" href="pseudo-random" title="wikilink">pseudo-random</a> value, which is added in an <a href="Exclusive_or" title="wikilink">exclusive-or</a> manner to the first plaintext block before it is being encrypted. The resultant ciphertext block is then used as the new initialization vector for the next plaintext block. In the <a href="cipher_feedback" title="wikilink">cipher feedback</a> (CFB) mode, which emulates a <a href="stream_cipher#Self-synchronizing_stream_ciphers" title="wikilink">self-synchronizing stream cipher</a>, the initialization vector is first encrypted and then added to the plaintext block. The <a href="output_feedback" title="wikilink">output feedback</a> (OFB) mode repeatedly encrypts the initialization vector to create a <a href="key_stream" title="wikilink">key stream</a> for the emulation of a <a href="Stream_cipher#Synchronous_stream_ciphers" title="wikilink">synchronous stream cipher</a>. The newer <a href="counter_mode" title="wikilink">counter</a> (CTR) mode similarly creates a key stream, but has the advantage of only needing unique and not (pseudo-)random values as initialization vectors; the needed randomness is derived internally by using the initialization vector as a block counter and encrypting this counter for each block.<a class="footnoteRef" href="#fn17" id="fnref17"><sup>17</sup></a></p>

<p>From a <a href="provable_security" title="wikilink">security-theoretic</a> point of view, modes of operation must provide what is known as <a href="semantic_security" title="wikilink">semantic security</a>. Informally, it means that given some ciphertext under an unknown key one cannot practically derive any information from the ciphertext (other than the length of the message) over what one would have known without seeing the ciphertext. It has been shown that all of the modes discussed above, with the exception of the ECB mode, provide this property under so-called <a href="chosen_plaintext_attack" title="wikilink">chosen plaintext attacks</a>.</p>
<h2 id="padding">Padding</h2>

<p>Some modes such as the CBC mode only operate on complete plaintext blocks. Simply extending the last block of a message with zero-bits is insufficient since it does not allow a receiver to easily distinguish messages that differ only in the amount of padding bits. More importantly, such a simple solution gives rise to very efficient <a href="padding_oracle_attack" title="wikilink">padding oracle attacks</a>.<a class="footnoteRef" href="#fn18" id="fnref18"><sup>18</sup></a> A suitable <a href="padding_(cryptography)" title="wikilink">padding scheme</a> is therefore needed to extend the last plaintext block to the cipher's block size. While many popular schemes described in standards and in the literature have been shown to be vulnerable to padding oracle attacks,<a class="footnoteRef" href="#fn19" id="fnref19"><sup>19</sup></a><a class="footnoteRef" href="#fn20" id="fnref20"><sup>20</sup></a> a solution which adds a one-bit and then extends the last block with zero-bits, standardized as "padding method 2" in <a href="ISO/IEC_9797-1" title="wikilink">ISO/IEC 9797-1</a>,<a class="footnoteRef" href="#fn21" id="fnref21"><sup>21</sup></a> has been proven secure against these attacks.<a class="footnoteRef" href="#fn22" id="fnref22"><sup>22</sup></a></p>
<h2 id="cryptanalysis">Cryptanalysis</h2>
<h3 id="brute-force-attacks">Brute force attacks</h3>

<p>Due to a block cipher's characteristic as an invertible function, its output becomes <a href="distinguishing_attack" title="wikilink">distinguishable</a> from a truly random output string over time due to the <a href="birthday_attack" title="wikilink">birthday attack</a>. This property results in the cipher's security degrading quadratically, and needs to be taken into account when selecting a block size. There is a trade-off though as large block sizes can result in the algorithm becoming inefficient to operate.<a class="footnoteRef" href="#fn23" id="fnref23"><sup>23</sup></a> Earlier block ciphers such as the <a href="Data_Encryption_Standard" title="wikilink">DES</a> have typically selected a 64-bit block size, while newer designs such as the <a href="Advanced_Encryption_Standard" title="wikilink">AES</a> support block sizes of 128 bits or more, with some ciphers supporting a range of different block sizes.<a class="footnoteRef" href="#fn24" id="fnref24"><sup>24</sup></a></p>
<h3 id="differential-cryptanalysis">Differential cryptanalysis</h3>
<h3 id="linear-cryptanalysis">Linear cryptanalysis</h3>

<p><em><a href="Linear_cryptanalysis" title="wikilink">Linear cryptanalysis</a></em> is a form of cryptanalysis based on finding <a href="affine_transformation" title="wikilink">affine</a> approximations to the action of a <a class="uri" href="cipher" title="wikilink">cipher</a>. Linear cryptanalysis is one of the two most widely used attacks on block ciphers; the other being <a href="differential_cryptanalysis" title="wikilink">differential cryptanalysis</a>. </p>

<p>The discovery is attributed to <a href="Mitsuru_Matsui" title="wikilink">Mitsuru Matsui</a>, who first applied the technique to the <a class="uri" href="FEAL" title="wikilink">FEAL</a> cipher (Matsui and Yamagishi, 1992).<a class="footnoteRef" href="#fn25" id="fnref25"><sup>25</sup></a></p>
<h3 id="integral-cryptanalysis">Integral cryptanalysis</h3>

<p><em><a href="Integral_cryptanalysis" title="wikilink">Integral cryptanalysis</a></em> is a cryptanalytic attack that is particularly applicable to block ciphers based on substitution-permutation networks. Unlike differential cryptanalysis, which uses pairs of chosen plaintexts with a fixed XOR difference, integral cryptanalysis uses sets or even multisets of chosen plaintexts of which part is held constant and another part varies through all possibilities. For example, an attack might use 256 chosen plaintexts that have all but 8 of their bits the same, but all differ in those 8 bits. Such a set necessarily has an XOR sum of 0, and the XOR sums of the corresponding sets of ciphertexts provide information about the cipher's operation. This contrast between the differences of pairs of texts and the sums of larger sets of texts inspired the name "integral cryptanalysis", borrowing the terminology of calculus.</p>
<h3 id="other-techniques">Other techniques</h3>

<p> In addition to linear and differential cryptanalysis, there is a growing catalog of attacks: <a href="truncated_differential_cryptanalysis" title="wikilink">truncated differential cryptanalysis</a>, partial differential cryptanalysis, <a href="integral_cryptanalysis" title="wikilink">integral cryptanalysis</a>, which encompasses square and integral attacks, <a href="slide_attack" title="wikilink">slide attacks</a>, <a href="boomerang_attack" title="wikilink">boomerang attacks</a>, the <a href="XSL_attack" title="wikilink">XSL attack</a>, <a href="impossible_differential_cryptanalysis" title="wikilink">impossible differential cryptanalysis</a> and algebraic attacks. For a new block cipher design to have any credibility, it must demonstrate evidence of security against known attacks.</p>
<h2 id="provable-security">Provable security</h2>

<p>When a block cipher is used in a given <a href="Block_cipher_mode_of_operation" title="wikilink">mode of operation</a>, the resulting algorithm should ideally be about as secure as the block cipher itself. ECB (discussed above) emphatically lacks this property: regardless of how secure the underlying block cipher is, ECB mode can easily be attacked. On the other hand, CBC mode can be proven to be secure under the assumption that the underlying block cipher is likewise secure. Note, however, that making statements like this requires formal mathematical definitions for what it means for an encryption algorithm or a block cipher to "be secure". This section describes two common notions for what properties a block cipher should have. Each corresponds to a mathematical model that can be used to prove properties of higher level algorithms, such as CBC.</p>

<p>This general approach to cryptography---proving higher-level algorithms (such as CBC) are secure under explicitly stated assumptions regarding their components (such as a block cipher)---is known as <em>provable security</em>.</p>
<h3 id="standard-model">Standard model</h3>

<p>Informally, a block cipher is secure in the standard model if an attacker cannot tell the difference between the block cipher (equipped with a random key) and a random permutation.</p>

<p>To be a bit more precise, let <em>E</em> be an <em>n</em>-bit block cipher. We imagine the following game:</p>
<ol>
<li>The person running the game flips a coin.
<ul>
<li>If the coin lands on heads, he chooses a random key <em>K</em> and defines the function <em>f = E<sub>K</sub></em>.</li>
<li>If the coin lands on tails, he chooses a random permutation <em>

<math display="inline" id="Block_cipher:43">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

</em> on the set of <em>n</em>-bit strings, and defines the function <em>f = 

<math display="inline" id="Block_cipher:44">
 <semantics>
  <mi>π</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>π</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \pi
  </annotation>
 </semantics>
</math>

</em>.</li>
</ul></li>
<li>The attacker chooses an <em>n</em>-bit string <em>X</em>, and the person running the game tells him the value of <em>f(X)</em>.</li>
<li>Step 2 is repeated a total of <em>q</em> times. (Each of these <em>q</em> interactions is a <em>query</em>.)</li>
<li>The attacker guesses how the coin landed. He wins if his guess is correct.</li>
</ol>

<p>The attacker, which we can model as an algorithm, is called an <em><a href="Adversary_(cryptography)" title="wikilink">adversary</a></em>. The function <em>f</em> (which the adversary was able to query) is called an <em><a href="Oracle_machine" title="wikilink">oracle</a></em>.</p>

<p>Note that an adversary can trivially ensure a 50% chance of winning simply by guessing at random (or even by, for example, always guessing "heads"). Therefore let <em>P<sub>E</sub>(A)</em> denote the probability that the adversary <em>A</em> wins this game against <em>E</em>, and define the <em>advantage</em> of <em>A</em> as 2(<em>P<sub>E</sub>(A)</em> - 1/2). It follows that if <em>A</em> guesses randomly, its advantage will be 0; on the other hand, if <em>A</em> always wins, then its advantage is 1. The block cipher <em>E</em> is a <em>pseudo-random permutation</em> (PRP) if no adversary has an advantage significantly greater than 0, given specified restrictions on <em>q</em> and the adversary's running time. If in Step 2 above adversaries have the option of learning <em>f<sup>−1</sup>(X)</em> instead of <em>f(X)</em> (but still have only small advantages) then <em>E</em> is a <em>strong</em> PRP (SPRP). An adversary is <em>non-adaptive</em> if it chooses all <em>q</em> values for <em>X</em> before the game begins (that is, it does not use any information gleaned from previous queries to choose each <em>X</em> as it goes).</p>

<p>These definitions have proven useful for analyzing various modes of operation. For example, one can define a similar game for measuring the security of a block cipher-based encryption algorithm, and then try to show (through a <a href="Reduction_(complexity)" title="wikilink">reduction argument</a>) that the probability of an adversary winning this new game is not much more than <em>P<sub>E</sub>(A)</em> for some <em>A</em>. (The reduction typically provides limits on <em>q</em> and the running time of <em>A</em>.) Equivalently, if <em>P<sub>E</sub>(A)</em> is small for all relevant <em>A</em>, then no attacker has a significant probability of winning the new game. This formalizes the idea that the higher-level algorithm inherits the block cipher's security.</p>
<h3 id="ideal-cipher-model">Ideal cipher model</h3>
<h2 id="practical-evaluation">Practical evaluation</h2>

<p>Block ciphers may be evaluated according to multiple criteria in practice. Common factors include:<a class="footnoteRef" href="#fn26" id="fnref26"><sup>26</sup></a></p>
<ul>
<li>Key parameters, such as its key size and block size, both which provide an upper bound on the security of the cipher.</li>
<li>The <em>estimated security level</em>, which is based on the confidence gained in the block cipher design after it has largely withstood major efforts in cryptanalysis over time, the design's mathematical soundness, and the existence of practical or certificational attacks.</li>
<li>The cipher's <em>complexity</em> and its suitability for implementation in <a href="electronic_hardware" title="wikilink">hardware</a> or <a class="uri" href="software" title="wikilink">software</a>. Hardware implementations may measure the complexity in terms of <a href="gate_count" title="wikilink">gate count</a> or energy consumption, which are important parameters for resource-constrained devices.</li>
<li>The cipher's <em>performance</em> in terms of processing <a class="uri" href="throughput" title="wikilink">throughput</a> on various platforms, including its <a href="computer_memory" title="wikilink">memory</a> requirements.</li>
<li>The <em>cost</em> of the cipher, which refers to licensing requirements that may apply due to <a href="intellectual_property_right" title="wikilink">intellectual property rights</a>.</li>
<li>The <em>flexibility</em> of the cipher, which includes its ability to support multiple key sizes and block lengths.</li>
</ul>
<h2 id="notable-block-ciphers">Notable block ciphers</h2>
<h3 id="lucifer-des">Lucifer / DES</h3>

<p><a href="Lucifer_(cipher)" title="wikilink">Lucifer</a> is generally considered to be the first civilian block cipher, developed at <a class="uri" href="IBM" title="wikilink">IBM</a> in the 1970s based on work done by <a href="Horst_Feistel" title="wikilink">Horst Feistel</a>. A revised version of the algorithm was adopted as a <a href="United_States" title="wikilink">U.S.</a> government <a href="Federal_Information_Processing_Standard" title="wikilink">Federal Information Processing Standard</a>: FIPS PUB 46 <a href="Data_Encryption_Standard" title="wikilink">Data Encryption Standard</a> (DES).<a class="footnoteRef" href="#fn27" id="fnref27"><sup>27</sup></a> It was chosen by the U.S. National Bureau of Standards (NBS) after a public invitation for submissions and some internal changes by <a href="National_Institute_of_Standards_and_Technology" title="wikilink">NBS</a> (and, potentially, the <a class="uri" href="NSA" title="wikilink">NSA</a>). DES was publicly released in 1976 and has been widely used.</p>

<p>DES was designed to, among other things, resist a certain cryptanalytic attack known to the NSA and rediscovered by IBM, though unknown publicly until rediscovered again and published by <a href="Eli_Biham" title="wikilink">Eli Biham</a> and <a href="Adi_Shamir" title="wikilink">Adi Shamir</a> in the late 1980s. The technique is called <a href="differential_cryptanalysis" title="wikilink">differential cryptanalysis</a> and remains one of the few general attacks against block ciphers; <a href="linear_cryptanalysis" title="wikilink">linear cryptanalysis</a> is another, but may have been unknown even to the NSA, prior to its publication by <a href="Mitsuru_Matsui" title="wikilink">Mitsuru Matsui</a>. DES prompted a large amount of other work and publications in cryptography and <a class="uri" href="cryptanalysis" title="wikilink">cryptanalysis</a> in the open community and it inspired many new cipher designs.</p>

<p>DES has a block size of 64 bits and a <a href="key_size" title="wikilink">key size</a> of 56 bits. 64-bit blocks became common in block cipher designs after DES. Key length depended on several factors, including government regulation. Many observers in the 1970s commented that the 56-bit key length used for DES was too short. As time went on, its inadequacy became apparent, especially after a <a href="EFF_DES_cracker" title="wikilink">special purpose machine designed to break DES</a> was demonstrated in 1998 by the <a href="Electronic_Frontier_Foundation" title="wikilink">Electronic Frontier Foundation</a>. An extension to DES, <a href="Triple_DES" title="wikilink">Triple DES</a>, triple-encrypts each block with either two independent keys (112-bit key and 80-bit security) or three independent keys (168-bit key and 112-bit security). It was widely adopted as a replacement. As of 2011, the three-key version is still considered secure, though the <a href="National_Institute_of_Standards_and_Technology" title="wikilink">National Institute of Standards and Technology</a> (NIST) standards no longer permit the use of the two-key version in new applications, due to its 80-bit security level.<a class="footnoteRef" href="#fn28" id="fnref28"><sup>28</sup></a></p>
<h3 id="idea">IDEA</h3>

<p>The <em><a href="International_Data_Encryption_Algorithm" title="wikilink">International Data Encryption Algorithm</a></em> (<em>IDEA</em>) is a block cipher designed by <a href="James_Massey" title="wikilink">James Massey</a> of <a href="ETH_Zurich" title="wikilink">ETH Zurich</a> and <a href="Xuejia_Lai" title="wikilink">Xuejia Lai</a>; it was first described in 1991, as an intended replacement for DES.</p>

<p>IDEA operates on 64-bit <a href="block_size_(cryptography)" title="wikilink">blocks</a> using a 128-bit key, and consists of a series of eight identical transformations (a <em>round</em>) and an output transformation (the <em>half-round</em>). The processes for encryption and decryption are similar. IDEA derives much of its security by interleaving operations from different <a href="group_(mathematics)" title="wikilink">groups</a> — <a href="modular_arithmetic" title="wikilink">modular</a> addition and multiplication, and bitwise <em><a href="exclusive_or" title="wikilink">exclusive or</a> (XOR)</em> — which are algebraically "incompatible" in some sense.</p>

<p>The designers analysed IDEA to measure its strength against <a href="differential_cryptanalysis" title="wikilink">differential cryptanalysis</a> and concluded that it is immune under certain assumptions. No successful <a href="linear_cryptanalysis" title="wikilink">linear</a> or algebraic weaknesses have been reported. , the best attack which applies to all keys can break full 8.5 round IDEA using a narrow-bicliques attack about four times faster than brute force.</p>
<h3 id="rc5">RC5</h3>

<p>  RC5 is a block cipher designed by <a href="Ron_Rivest" title="wikilink">Ronald Rivest</a> in 1994 which, unlike many other ciphers, has a variable block size (32, 64 or 128 bits), key size (0 to 2040 bits) and number of rounds (0 to 255). The original suggested choice of parameters were a block size of 64 bits, a 128-bit key and 12 rounds.</p>

<p>A key feature of RC5 is the use of data-dependent rotations; one of the goals of RC5 was to prompt the study and evaluation of such operations as a cryptographic primitive. RC5 also consists of a number of <a href="modular_arithmetic" title="wikilink">modular</a> additions and XORs. The general structure of the algorithm is a <a href="Feistel_cipher" title="wikilink">Feistel</a>-like network. The encryption and decryption routines can be specified in a few lines of code. The key schedule, however, is more complex, expanding the key using an essentially <a href="one-way_function" title="wikilink">one-way function</a> with the binary expansions of both <a href="e_(mathematical_constant)" title="wikilink">e</a> and the <a href="golden_ratio" title="wikilink">golden ratio</a> as sources of "<a href="nothing_up_my_sleeve_number" title="wikilink">nothing up my sleeve numbers</a>". The tantalising simplicity of the algorithm together with the novelty of the data-dependent rotations has made RC5 an attractive object of study for cryptanalysts.</p>

<p>12-round RC5 (with 64-bit blocks) is susceptible to a <a href="differential_cryptanalysis" title="wikilink">differential attack</a> using 2<sup>44</sup> chosen plaintexts.<a class="footnoteRef" href="#fn29" id="fnref29"><sup>29</sup></a> 18–20 rounds are suggested as sufficient protection.</p>
<h3 id="rijndael-aes">Rijndael / AES</h3>

<p>DES has been superseded as a United States Federal Standard by the AES, adopted by NIST in 2001 after a 5-year <a href="Advanced_Encryption_Standard_process" title="wikilink">public competition</a>. The cipher was developed by two Belgian cryptographers, <a href="Joan_Daemen" title="wikilink">Joan Daemen</a> and <a href="Vincent_Rijmen" title="wikilink">Vincent Rijmen</a>, and submitted under the name <em>Rijndael</em>.</p>

<p>AES has a fixed block size of 128 bits and a key size of 128, 192, or 256 bits, whereas Rijndael can be specified with block and key sizes in any multiple of 32 bits, with a minimum of 128 bits. The blocksize has a maximum of 256 bits, but the keysize has no theoretical maximum. AES operates on a 4×4 <a href="column-major_order" title="wikilink">column-major order</a> matrix of bytes, termed the <em>state</em> (versions of Rijndael with a larger block size have additional columns in the state).</p>
<h3 id="blowfish">Blowfish</h3>

<p><em><a href="Blowfish_(cipher)" title="wikilink">Blowfish</a></em> is a block cipher, designed in 1993 by <a href="Bruce_Schneier" title="wikilink">Bruce Schneier</a> and included in a large number of cipher suites and encryption products. Blowfish has a 64-bit block size and a variable <a href="key_length" title="wikilink">key length</a> from 1 bit up to 448 bits.<a class="footnoteRef" href="#fn30" id="fnref30"><sup>30</sup></a> It is a 16-round <a href="Feistel_cipher" title="wikilink">Feistel cipher</a> and uses large key-dependent <a href="Substitution_box" title="wikilink">S-boxes</a>. Notable features of the design include the key-dependent <a href="S-box" title="wikilink">S-boxes</a> and a highly complex <a href="key_schedule" title="wikilink">key schedule</a>.</p>

<p>Schneier designed Blowfish as a general-purpose algorithm, intended as an alternative to the ageing DES and free of the problems and constraints associated with other algorithms. At the time Blowfish was released, many other designs were proprietary, encumbered by <a href="patent" title="wikilink">patents</a> or were commercial/government secrets. Schneier has stated that, "Blowfish is unpatented, and will remain so in all countries. The algorithm is hereby placed in the <a href="public_domain" title="wikilink">public domain</a>, and can be freely used by anyone." Blowfish provides a good encryption rate in software and no effective <a class="uri" href="cryptanalysis" title="wikilink">cryptanalysis</a> of the full-round version has been found to date.</p>
<h2 id="generalizations">Generalizations</h2>
<h3 id="tweakable-block-ciphers">Tweakable block ciphers</h3>

<p>M. Liskov, R. Rivest, and D. Wagner have described a generalized version of block ciphers called "tweakable" block ciphers.<a class="footnoteRef" href="#fn31" id="fnref31"><sup>31</sup></a> A tweakable block cipher accepts a second input called the <em>tweak</em> along with its usual plaintext or ciphertext input. The tweak, along with the key, selects the permutation computed by the cipher. If changing tweaks is sufficiently lightweight (compared with a usually fairly expensive key setup operation), then some interesting new operation modes become possible. The <a href="disk_encryption_theory" title="wikilink">disk encryption theory</a> article describes some of these modes.</p>
<h3 id="format-preserving-encryption">Format-preserving encryption</h3>

<p>Block ciphers traditionally work over a binary <a href="Alphabet_(computer_science)" title="wikilink">alphabet</a>. That is, both the input and the output are binary strings, consisting of <em>n</em> zeroes and ones. In some situations, however, one may wish to have a block cipher that works over some other alphabet; for example, encrypting 16-digit credit card numbers in such a way that the ciphertext is also a 16-digit number might facilitate adding an encryption layer to legacy software. This is an example of <em>format-preserving encryption</em>. More generally, format-preserving encryption requires a keyed permutation on some finite <a href="Formal_language" title="wikilink">language</a>. This makes format-preserving encryption schemes a natural generalization of (tweakable) block ciphers. In contrast, traditional encryption schemes, such as CBC, are not permutations because the same plaintext can encrypt to multiple different ciphertexts, even when using a fixed key.</p>
<h2 id="relation-to-other-cryptographic-primitives">Relation to other cryptographic primitives</h2>

<p>Block ciphers can be used to build other cryptographic primitives, such as those below. For these other primitives to be cryptographically secure, care has to be taken to build them the right way.</p>
<ul>
<li><a href="Stream_cipher" title="wikilink">Stream ciphers</a> can be built using block ciphers. OFB-mode and CTR mode are block modes that turn a block cipher into a stream cipher.</li>
</ul>
<ul>
<li><a href="Cryptographic_hash_function" title="wikilink">Cryptographic hash functions</a> can be built using block ciphers.<a class="footnoteRef" href="#fn32" id="fnref32"><sup>32</sup></a> See <a href="one-way_compression_function" title="wikilink">one-way compression function</a> for descriptions of several such methods. The methods resemble the block cipher modes of operation usually used for encryption.</li>
</ul>
<ul>
<li><a href="Cryptographically_secure_pseudorandom_number_generator" title="wikilink">Cryptographically secure pseudorandom number generators</a> (CSPRNGs) can be built using block ciphers.<a class="footnoteRef" href="#fn33" id="fnref33"><sup>33</sup></a></li>
</ul>
<ul>
<li>Secure <a href="pseudorandom_permutation" title="wikilink">pseudorandom permutations</a> of arbitrarily sized finite sets can be constructed with block ciphers; see <a href="Format-Preserving_Encryption" title="wikilink">Format-Preserving Encryption</a>.</li>
</ul>
<ul>
<li><a href="Message_authentication_code" title="wikilink">Message authentication codes</a> (MACs) are often built from block ciphers. <a class="uri" href="CBC-MAC" title="wikilink">CBC-MAC</a>, <a href="One-key_MAC" title="wikilink">OMAC</a> and <a href="PMAC_(cryptography)" title="wikilink">PMAC</a> are such MACs.</li>
</ul>
<ul>
<li><a href="Authenticated_encryption" title="wikilink">Authenticated encryption</a> is also built from block ciphers. It means to both encrypt and MAC at the same time. That is to both provide <a class="uri" href="confidentiality" title="wikilink">confidentiality</a> and <a class="uri" href="authentication" title="wikilink">authentication</a>. <a href="CCM_mode" title="wikilink">CCM</a>, <a href="EAX_mode" title="wikilink">EAX</a>, <a href="Galois/Counter_Mode" title="wikilink">GCM</a> and <a href="OCB_mode" title="wikilink">OCB</a> are such authenticated encryption modes.</li>
</ul>

<p>Just as block ciphers can be used to build hash functions, hash functions can be used to build block ciphers. Examples of such block ciphers are <a class="uri" href="SHACAL" title="wikilink">SHACAL</a>, BEAR and LION.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Cipher_security_summary" title="wikilink">Cipher security summary</a></li>
<li><a href="Topics_in_cryptography" title="wikilink">Topics in cryptography</a></li>
</ul>
<h2 id="references">References</h2>
<h2 id="further-reading">Further reading</h2>
<ul>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://www.users.zetnet.co.uk/hopwood/crypto/scan/cs.html">A list of many symmetric algorithms, the majority of which are block ciphers.</a></li>
<li><a href="http://www.mat.dtu.dk/people/Lars.R.Knudsen/bc.html">The block cipher lounge</a></li>
<li><a href="http://www.rsa.com/rsalabs/node.asp?id=2168">What is a block cipher?</a> from RSA <a class="uri" href="FAQ" title="wikilink">FAQ</a></li>
</ul>

<p>"</p>

<p><a href="Category:Block_ciphers" title="wikilink">*</a> <a href="Category:Cryptographic_primitives" title="wikilink">Category:Cryptographic primitives</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="#fnref1">↩</a></li>
<li id="fn2">, p. 455.<a href="#fnref2">↩</a></li>
<li id="fn3"><a href="#fnref3">↩</a></li>
<li id="fn4"><a href="#fnref4">↩</a></li>
<li id="fn5">, chapter 3.<a href="#fnref5">↩</a></li>
<li id="fn6"><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8"><a href="#fnref8">↩</a></li>
<li id="fn9"><a href="#fnref9">↩</a></li>
<li id="fn10"><a href="#fnref10">↩</a></li>
<li id="fn11">, pages 166-167.<a href="#fnref11">↩</a></li>
<li id="fn12"><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="#fnref13">↩</a></li>
<li id="fn14"><a href="#fnref14">↩</a></li>
<li id="fn15"><a href="#fnref15">↩</a></li>
<li id="fn16"><a href="http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=38761">ISO/IEC 10116:2006 <em>Information technology — Security techniques — Modes of operation for an n-bit block cipher</em></a><a href="#fnref16">↩</a></li>
<li id="fn17"></li>
<li id="fn18"><a href="#fnref18">↩</a></li>
<li id="fn19"></li>
<li id="fn20"><a href="#fnref20">↩</a></li>
<li id="fn21"><a href="#fnref21">↩</a></li>
<li id="fn22"></li>
<li id="fn23"><a href="#fnref23">↩</a></li>
<li id="fn24"><a href="#fnref24">↩</a></li>
<li id="fn25"><a href="#fnref25">↩</a></li>
<li id="fn26"><a href="#fnref26">↩</a></li>
<li id="fn27"><a href="http://csrc.nist.gov/publications/fips/fips46-3/fips46-3.pdf">FIPS PUB 46-3 <em>Data Encryption Standard (DES)</em></a> (This is the third edition, 1999, but includes historical information in the preliminary section 12.)<a href="#fnref27">↩</a></li>
<li id="fn28"><a href="http://csrc.nist.gov/publications/nistpubs/800-57/sp800-57-Part1-revised2_Mar08-2007.pdf">NIST Special Publication 800-57 <em>Recommendation for Key Management — Part 1: General (Revised)</em>, March, 2007</a><a href="#fnref28">↩</a></li>
<li id="fn29">Biryukov A. and Kushilevitz E. (1998). Improved Cryptanalysis of RC5. EUROCRYPT 1998.<a href="#fnref29">↩</a></li>
<li id="fn30"><a href="#fnref30">↩</a></li>
<li id="fn31"><a href="#fnref31">↩</a></li>
<li id="fn32"><a href="http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=44737">ISO/IEC 10118-2:2010 <em>Information technology — Security techniques — Hash-functions — Part 2: Hash-functions using an n-bit block cipher</em></a><a href="#fnref32">↩</a></li>
<li id="fn33"><a href="http://csrc.nist.gov/publications/nistpubs/800-90A/SP800-90A.pdf">NIST Special Publication 800-90A <em>Recommendation for Random Number Generation Using Deterministic Random Bit Generators</em></a><a href="#fnref33">↩</a></li>
</ol>
</section>
</body>
</html>
