<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="208">Currying</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Currying</h1>
<hr/>

<p>In <a class="uri" href="mathematics" title="wikilink">mathematics</a> and <a href="computer_science" title="wikilink">computer science</a>, <strong>currying</strong> is the technique of translating the evaluation of a <a href="function_(mathematics)" title="wikilink">function</a> that takes multiple <a href="parameter_(computer_science)" title="wikilink">arguments</a> (or a <a class="uri" href="tuple" title="wikilink">tuple</a> of arguments) into evaluating a sequence of functions, each with a single argument (<a href="partial_application" title="wikilink">partial application</a>). It was introduced by <a href="Moses_Schönfinkel" title="wikilink">Moses Schönfinkel</a><a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a><a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a><a class="footnoteRef" href="#fn3" id="fnref3"><sup>3</sup></a> and later developed by <a href="Haskell_Curry" title="wikilink">Haskell Curry</a>.<a class="footnoteRef" href="#fn4" id="fnref4"><sup>4</sup></a><a class="footnoteRef" href="#fn5" id="fnref5"><sup>5</sup></a></p>

<p><strong>Uncurrying</strong> is the <a href="Duality_(mathematics)" title="wikilink">dual</a> transformation to currying, and can be seen as a form of <a class="uri" href="defunctionalization" title="wikilink">defunctionalization</a>. It takes a function <em>f</em>(<strong>x</strong>) which returns another function <em>g</em>(<strong>y</strong>) as a result, and yields a new function  which takes a number of additional parameters and applies them to the function returned by function <em>f</em>. The process can be iterated if necessary.</p>
<h2 id="motivation">Motivation</h2>

<p>There are analytical techniques that can only be applied to <a href="function_(mathematics)" title="wikilink">functions</a> with a single argument. Practical functions frequently take more arguments than this. <a href="Gottlob_Frege" title="wikilink">Frege</a> showed that it was sufficient to provide solutions for the single argument case, as it was possible to transform a function with multiple arguments into a chain of single-argument functions instead. This transformation is the process now known as currying.<a class="footnoteRef" href="#fn6" id="fnref6"><sup>6</sup></a></p>

<p>Currying is similar to the process of calculating a function of multiple variables for some given values on paper.</p>

<p>For example, given the function 

<math display="inline" id="Currying:0">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>y</mi>
    <mo>/</mo>
    <mi>x</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <divide></divide>
     <ci>y</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)=y/x
  </annotation>
 </semantics>
</math>

:</p>
<dl>
<dd>To evaluate 

<math display="inline" id="Currying:1">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mn>3</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <interval closure="open">
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(2,3)
  </annotation>
 </semantics>
</math>

, first replace 

<math display="inline" id="Currying:2">
 <semantics>
  <mi>x</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>x</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   x
  </annotation>
 </semantics>
</math>

 with 

<math display="inline" id="Currying:3">
 <semantics>
  <mn>2</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">2</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   2
  </annotation>
 </semantics>
</math>


</dd>
</dl>
<dl>
<dd>Since the result is a function of 

<math display="inline" id="Currying:4">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

, this new function 

<math display="inline" id="Currying:5">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>y</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>g</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(y)
  </annotation>
 </semantics>
</math>

 can be defined as 

<math display="inline" id="Currying:6">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>y</mi>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <cn type="integer">2</cn>
       <ci>y</ci>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <ci>y</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(y)=f(2,y)=y/2
  </annotation>
 </semantics>
</math>


</dd>
</dl>
<dl>
<dd>Next, replace the 

<math display="inline" id="Currying:7">
 <semantics>
  <mi>y</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>y</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   y
  </annotation>
 </semantics>
</math>

 argument with 

<math display="inline" id="Currying:8">
 <semantics>
  <mn>3</mn>
  <annotation-xml encoding="MathML-Content">
   <cn type="integer">3</cn>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   3
  </annotation>
 </semantics>
</math>

, producing 

<math display="inline" id="Currying:9">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>3</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mn>3</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mn>3</mn>
    <mo>/</mo>
    <mn>2</mn>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>g</ci>
      <cn type="integer">3</cn>
     </apply>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <cn type="integer">2</cn>
       <cn type="integer">3</cn>
      </interval>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <apply>
      <divide></divide>
      <cn type="integer">3</cn>
      <cn type="integer">2</cn>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(3)=f(2,3)=3/2
  </annotation>
 </semantics>
</math>


</dd>
</dl>

<p>On paper, using classical notation, this is usually done all in one step. However, each argument can be replaced sequentially as well. Each replacement results in a function taking exactly one argument. This produces a chain of functions as in <a href="lambda_calculus" title="wikilink">lambda calculus</a>, and multi-argument functions are usually represented in curried form.</p>

<p>Some <a href="programming_language" title="wikilink">programming languages</a> almost always use curried functions to achieve multiple arguments; notable examples are <a href="ML_programming_language" title="wikilink">ML</a> and <a href="Haskell_(programming_language)" title="wikilink">Haskell</a>, where in both cases all functions have exactly one argument.</p>

<p>If we let <em>f</em> be a function</p>

<p>

<math display="block" id="Currying:10">
 <semantics>
  <mrow>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mfrac>
    <mi>y</mi>
    <mi>x</mi>
   </mfrac>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <eq></eq>
    <apply>
     <times></times>
     <ci>f</ci>
     <interval closure="open">
      <ci>x</ci>
      <ci>y</ci>
     </interval>
    </apply>
    <apply>
     <divide></divide>
     <ci>y</ci>
     <ci>x</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f(x,y)=\frac{y}{x}
  </annotation>
 </semantics>
</math>

 then the function <em>h</em> where</p>

<p>

<math display="block" id="Currying:11">
 <semantics>
  <mrow>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>y</mi>
   <mo>↦</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>x</mi>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>h</ci>
      <ci>x</ci>
     </apply>
     <ci>y</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <ci>x</ci>
       <ci>y</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   h(x)=y\mapsto f(x,y)
  </annotation>
 </semantics>
</math>

 is a curried version of 

<math display="inline" id="Currying:12">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   f
  </annotation>
 </semantics>
</math>

. Here, 

<math display="inline" id="Currying:13">
 <semantics>
  <mrow>
   <mi>y</mi>
   <mo>↦</mo>
   <mi>z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="latexml">maps-to</csymbol>
    <ci>y</ci>
    <ci>z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle y\mapsto z
  </annotation>
 </semantics>
</math>

 is a function that <a href="map_(higher-order_function)" title="wikilink">maps</a> an argument <em>y</em> to result <em>z</em>. In particular,</p>

<p>

<math display="block" id="Currying:14">
 <semantics>
  <mrow>
   <mrow>
    <mi>g</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mrow>
    <mi>h</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>2</mn>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>=</mo>
   <mi>y</mi>
   <mo>↦</mo>
   <mrow>
    <mi>f</mi>
    <mrow>
     <mo stretchy="false">(</mo>
     <mn>2</mn>
     <mo>,</mo>
     <mi>y</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <eq></eq>
     <apply>
      <times></times>
      <ci>g</ci>
      <ci>y</ci>
     </apply>
     <apply>
      <times></times>
      <ci>h</ci>
      <cn type="integer">2</cn>
     </apply>
    </apply>
    <apply>
     <eq></eq>
     <share href="#.cmml">
     </share>
     <ci>y</ci>
    </apply>
    <apply>
     <csymbol cd="latexml">maps-to</csymbol>
     <share href="#.cmml">
     </share>
     <apply>
      <times></times>
      <ci>f</ci>
      <interval closure="open">
       <cn type="integer">2</cn>
       <ci>y</ci>
      </interval>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   g(y)=h(2)=y\mapsto f(2,y)
  </annotation>
 </semantics>
</math>

 is the curried equivalent of the example above. Note, however, that currying, while similar, <a href="#Contrast_with_partial_function_application" title="wikilink">is not the same operation as partial function application</a>.</p>
<h2 id="definition">Definition</h2>

<p>Given a function 

<math display="inline" id="Currying:15">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle f
  </annotation>
 </semantics>
</math>

 of type 

<math display="inline" id="Currying:16">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>X</mi>
      <mo>×</mo>
      <mi>Y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>Z</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>Y</ci>
     </apply>
     <ci>Z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle f\colon(X\times Y)\to Z
  </annotation>
 </semantics>
</math>

, <strong>currying</strong> it makes a function 

<math display="inline" id="Currying:17">
 <semantics>
  <mrow>
   <mtext>curry</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>:</mo>
   <mi>X</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo>→</mo>
    <mi>Z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>curry</mtext>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-:</ci>
    <csymbol cd="unknown">X</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">Z</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\text{curry}(f)\colon X\to(Y\to Z)
  </annotation>
 </semantics>
</math>

. That is, 

<math display="inline" id="Currying:18">
 <semantics>
  <mrow>
   <mtext>curry</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>curry</mtext>
    <ci>f</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\text{curry}(f)
  </annotation>
 </semantics>
</math>

 takes an argument of type 

<math display="inline" id="Currying:19">
 <semantics>
  <mi>X</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>X</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle X
  </annotation>
 </semantics>
</math>

 and returns a function of type 

<math display="inline" id="Currying:20">
 <semantics>
  <mrow>
   <mi>Y</mi>
   <mo>→</mo>
   <mi>Z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-→</ci>
    <ci>Y</ci>
    <ci>Z</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle Y\to Z
  </annotation>
 </semantics>
</math>

. <strong>Uncurrying</strong> is the reverse transformation, and is most easily understood in terms of its right adjoint, <a class="uri" href="apply" title="wikilink">apply</a>.</p>

<p>The → operator is often considered <a class="uri" href="right-associative" title="wikilink">right-associative</a>, so the curried function type 

<math display="inline" id="Currying:21">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo>→</mo>
    <mi>Z</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <csymbol cd="unknown">X</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">Z</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle X\to(Y\to Z)
  </annotation>
 </semantics>
</math>

 is often written as 

<math display="inline" id="Currying:22">
 <semantics>
  <mrow>
   <mi>X</mi>
   <mo>→</mo>
   <mi>Y</mi>
   <mo>→</mo>
   <mi>Z</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <and></and>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
     <ci>Y</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <share href="#.cmml">
     </share>
     <ci>Z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle X\to Y\to Z
  </annotation>
 </semantics>
</math>

. Conversely, <a href="function_application" title="wikilink">function application</a> is considered to be left-associative, so that 

<math display="inline" id="Currying:23">
 <semantics>
  <mrow>
   <mpadded width="+2.8pt">
    <mi>f</mi>
   </mpadded>
   <mrow>
    <mo stretchy="false">⟨</mo>
    <mi>x</mi>
    <mo>,</mo>
    <mi>y</mi>
    <mo stretchy="false">⟩</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <list>
     <ci>x</ci>
     <ci>y</ci>
    </list>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle f\;\langle x,y\rangle
  </annotation>
 </semantics>
</math>

 is equivalent to 

<math display="inline" id="Currying:24">
 <semantics>
  <mrow>
   <mtext>curry</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo rspace="5.3pt" stretchy="false">)</mo>
   </mrow>
   <mpadded width="+2.8pt">
    <mi>x</mi>
   </mpadded>
   <mi>y</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <mtext>curry</mtext>
    <ci>f</ci>
    <ci>x</ci>
    <ci>y</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\text{curry}(f)\;x\;y
  </annotation>
 </semantics>
</math>

.</p>

<p>Curried functions may be used in any language that supports <a href="closure_(computer_science)" title="wikilink">closures</a>; however, uncurried functions are generally preferred for efficiency reasons, since the overhead of partial application and closure creation can then be avoided for most function calls.</p>
<h2 id="mathematical-view">Mathematical view</h2>

<p>In <a href="theoretical_computer_science" title="wikilink">theoretical computer science</a>, currying provides a way to study functions with multiple arguments in very simple theoretical models such as the <a href="lambda_calculus" title="wikilink">lambda calculus</a> in which functions only take a single argument.</p>

<p>In a set-theoretic paradigm, currying is the natural correspondence between the set 

<math display="inline" id="Currying:25">
 <semantics>
  <msup>
   <mi>A</mi>
   <mrow>
    <mi>B</mi>
    <mo>×</mo>
    <mi>C</mi>
   </mrow>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <ci>A</ci>
    <apply>
     <times></times>
     <ci>B</ci>
     <ci>C</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle A^{B\times C}
  </annotation>
 </semantics>
</math>

 of functions from 

<math display="inline" id="Currying:26">
 <semantics>
  <mrow>
   <mi>B</mi>
   <mo>×</mo>
   <mi>C</mi>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>B</ci>
    <ci>C</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle B\times C
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Currying:27">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   A
  </annotation>
 </semantics>
</math>

, and the set 

<math display="inline" id="Currying:28">
 <semantics>
  <msup>
   <mrow>
    <mo>(</mo>
    <msup>
     <mi>A</mi>
     <mi>C</mi>
    </msup>
    <mo>)</mo>
   </mrow>
   <mi>B</mi>
  </msup>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <csymbol cd="ambiguous">superscript</csymbol>
    <apply>
     <csymbol cd="ambiguous">superscript</csymbol>
     <ci>A</ci>
     <ci>C</ci>
    </apply>
    <ci>B</ci>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\left(A^{C}\right)^{B}
  </annotation>
 </semantics>
</math>

 of functions from 

<math display="inline" id="Currying:29">
 <semantics>
  <mi>B</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>B</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle B
  </annotation>
 </semantics>
</math>

 to the set of functions from 

<math display="inline" id="Currying:30">
 <semantics>
  <mi>C</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>C</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle C
  </annotation>
 </semantics>
</math>

 to 

<math display="inline" id="Currying:31">
 <semantics>
  <mi>A</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>A</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle A
  </annotation>
 </semantics>
</math>

. In <a href="category_theory" title="wikilink">category theory</a>, currying can be found in the <a href="universal_property" title="wikilink">universal property</a> of an <a href="exponential_object" title="wikilink">exponential object</a>, which gives rise to the following adjunction in <a href="cartesian_closed_category" title="wikilink">cartesian closed categories</a>: There is a <a href="Natural_transformation" title="wikilink">natural</a> <a class="uri" href="isomorphism" title="wikilink">isomorphism</a> between the <a href="morphism_(category_theory)" title="wikilink">morphisms</a> from a <a href="product_(category_theory)" title="wikilink">binary product</a> 

<math display="inline" id="Currying:32">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>X</mi>
      <mo>×</mo>
      <mi>Y</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>Z</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>Y</ci>
     </apply>
     <ci>Z</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle f\colon(X\times Y)\to Z
  </annotation>
 </semantics>
</math>

 and the morphisms to an exponential object 

<math display="inline" id="Currying:33">
 <semantics>
  <mrow>
   <mi>g</mi>
   <mo>:</mo>
   <mrow>
    <mi>X</mi>
    <mo>→</mo>
    <msup>
     <mi>Z</mi>
     <mi>Y</mi>
    </msup>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>g</ci>
    <apply>
     <ci>normal-→</ci>
     <ci>X</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>Z</ci>
      <ci>Y</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle g\colon X\to Z^{Y}
  </annotation>
 </semantics>
</math>

. In other words, currying is the statement that <a href="Product_(category_theory)" title="wikilink">product</a> and <a href="Hom_functor" title="wikilink">Hom</a> are <a href="adjoint_functors" title="wikilink">adjoint functors</a>; that is, there is a <a href="natural_transformation" title="wikilink">natural transformation</a>:</p>

<p>

<math display="block" id="Currying:34">
 <semantics>
  <mrow>
   <mrow>
    <mrow>
     <mi>hom</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mrow>
       <mi>A</mi>
       <mo>×</mo>
       <mi>B</mi>
      </mrow>
      <mo>,</mo>
      <mi>C</mi>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
    <mo>≅</mo>
    <mrow>
     <mi>hom</mi>
     <mrow>
      <mo stretchy="false">(</mo>
      <mi>A</mi>
      <mo>,</mo>
      <msup>
       <mi>C</mi>
       <mi>B</mi>
      </msup>
      <mo stretchy="false">)</mo>
     </mrow>
    </mrow>
   </mrow>
   <mo>.</mo>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <approx></approx>
    <apply>
     <ci>hom</ci>
     <apply>
      <times></times>
      <ci>A</ci>
      <ci>B</ci>
     </apply>
     <ci>C</ci>
    </apply>
    <apply>
     <ci>hom</ci>
     <ci>A</ci>
     <apply>
      <csymbol cd="ambiguous">superscript</csymbol>
      <ci>C</ci>
      <ci>B</ci>
     </apply>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \hom(A\times B,C)\cong\hom(A,C^{B}).
  </annotation>
 </semantics>
</math>

</p>

<p>This is the key property of being a <a href="Cartesian_closed_category" title="wikilink">Cartesian closed category</a>, and more generally, a <a href="closed_monoidal_category" title="wikilink">closed monoidal category</a>.<a class="footnoteRef" href="#fn7" id="fnref7"><sup>7</sup></a> The latter, though more rarely discussed, is interesting, as it is the suitable setting for <a href="quantum_computation" title="wikilink">quantum computation</a>,<a class="footnoteRef" href="#fn8" id="fnref8"><sup>8</sup></a> whereas the former is sufficient for classical logic. The difference is that the <a href="Cartesian_product" title="wikilink">Cartesian product</a> can be interpreted simply as a pair of items (or a list), whereas the <a href="tensor_product" title="wikilink">tensor product</a>, used to define a <a href="monoidal_category" title="wikilink">monoidal category</a>, is suitable for describing <a href="entangled_quantum_states" title="wikilink">entangled quantum states</a>.<a class="footnoteRef" href="#fn9" id="fnref9"><sup>9</sup></a></p>

<p>Under the <a href="Curry–Howard_correspondence" title="wikilink">Curry–Howard correspondence</a>, the existence of currying and uncurrying is equivalent to the logical theorem 

<math display="inline" id="Currying:35">
 <semantics>
  <mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>A</mi>
    <mi mathvariant="italic">and</mi>
    <mi>B</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>→</mo>
   <mi>C</mi>
   <mo>⇔</mo>
   <mi>A</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>B</mi>
    <mo>→</mo>
    <mi>C</mi>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">A</csymbol>
     <csymbol cd="unknown">and</csymbol>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-→</ci>
    <csymbol cd="unknown">C</csymbol>
    <ci>normal-⇔</ci>
    <csymbol cd="unknown">A</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">B</csymbol>
     <ci>normal-→</ci>
     <csymbol cd="unknown">C</csymbol>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle(A\and B)\to C\Leftrightarrow A\to(B\to C)
  </annotation>
 </semantics>
</math>

, as <a href="tuple" title="wikilink">tuples</a> (<a href="product_type" title="wikilink">product type</a>) corresponds to conjunction in logic, and function type corresponds to implication.</p>

<p>Curry is a <a href="continuous_function" title="wikilink">continuous function</a> in the <a href="Scott_topology" title="wikilink">Scott topology</a>.<a class="footnoteRef" href="#fn10" id="fnref10"><sup>10</sup></a></p>
<h2 id="naming">Naming</h2>

<p>The name "currying", coined by <a href="Christopher_Strachey" title="wikilink">Christopher Strachey</a> in 1967, is a reference to logician <a href="Haskell_Curry" title="wikilink">Haskell Curry</a>. The alternative name "Schönfinkelisation" has been proposed as a reference to <a href="Moses_Schönfinkel" title="wikilink">Moses Schönfinkel</a>.<a class="footnoteRef" href="#fn11" id="fnref11"><sup>11</sup></a> In the mathematical context, the principle can be traced back to work in 1893 by <a href="Gottlob_Frege" title="wikilink">Frege</a>.</p>
<h2 id="contrast-with-partial-function-application">Contrast with partial function application</h2>

<p>Currying and partial function application are often conflated.<a class="footnoteRef" href="#fn12" id="fnref12"><sup>12</sup></a> One of the significant differences between the two is that a call to a partially applied function returns the result right away, not another function down the currying chain; this distinction can be illustrated clearly for functions whose <a class="uri" href="arity" title="wikilink">arity</a> is greater than two.<a class="footnoteRef" href="#fn13" id="fnref13"><sup>13</sup></a></p>

<p>Given a function of type 

<math display="inline" id="Currying:36">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>X</mi>
      <mo>×</mo>
      <mi>Y</mi>
      <mo>×</mo>
      <mi>Z</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <ci>f</ci>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>X</ci>
      <ci>Y</ci>
      <ci>Z</ci>
     </apply>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle f\colon(X\times Y\times Z)\to N
  </annotation>
 </semantics>
</math>

, currying produces 

<math display="inline" id="Currying:37">
 <semantics>
  <mrow>
   <mtext>curry</mtext>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>f</mi>
    <mo stretchy="false">)</mo>
   </mrow>
   <mo>:</mo>
   <mi>X</mi>
   <mo>→</mo>
   <mrow>
    <mo stretchy="false">(</mo>
    <mi>Y</mi>
    <mo>→</mo>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>Z</mi>
     <mo>→</mo>
     <mi>N</mi>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <cerror>
    <csymbol cd="ambiguous">fragments</csymbol>
    <mtext>curry</mtext>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">f</csymbol>
     <ci>normal-)</ci>
    </cerror>
    <ci>normal-:</ci>
    <csymbol cd="unknown">X</csymbol>
    <ci>normal-→</ci>
    <cerror>
     <csymbol cd="ambiguous">fragments</csymbol>
     <ci>normal-(</ci>
     <csymbol cd="unknown">Y</csymbol>
     <ci>normal-→</ci>
     <cerror>
      <csymbol cd="ambiguous">fragments</csymbol>
      <ci>normal-(</ci>
      <csymbol cd="unknown">Z</csymbol>
      <ci>normal-→</ci>
      <csymbol cd="unknown">N</csymbol>
      <ci>normal-)</ci>
     </cerror>
     <ci>normal-)</ci>
    </cerror>
   </cerror>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\text{curry}(f)\colon X\to(Y\to(Z\to N))
  </annotation>
 </semantics>
</math>

. That is, while an evaluation of the first function might be represented as 

<math display="inline" id="Currying:38">
 <semantics>
  <mrow>
   <mi>f</mi>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo>,</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mn>3</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <ci>f</ci>
    <vector>
     <cn type="integer">1</cn>
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
    </vector>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle f(1,2,3)
  </annotation>
 </semantics>
</math>

, evaluation of the curried function would be represented as 

<math display="inline" id="Currying:39">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mtext>curried</mtext>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo stretchy="false">)</mo>
   </mrow>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>3</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <mtext>curried</mtext>
    </apply>
    <cn type="integer">1</cn>
    <cn type="integer">2</cn>
    <cn type="integer">3</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle f_{\text{curried}}(1)(2)(3)
  </annotation>
 </semantics>
</math>

, applying each argument in turn to a single-argument function returned by the previous invocation. Note that after calling 

<math display="inline" id="Currying:40">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mtext>curried</mtext>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>1</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <mtext>curried</mtext>
    </apply>
    <cn type="integer">1</cn>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle f_{\text{curried}}(1)
  </annotation>
 </semantics>
</math>

, we are left with a function that takes a single argument and returns another function, not a function that takes two arguments.</p>

<p>In contrast, <strong>partial function application</strong> refers to the process of fixing a number of arguments to a function, producing another function of smaller arity. Given the definition of 

<math display="inline" id="Currying:41">
 <semantics>
  <mi>f</mi>
  <annotation-xml encoding="MathML-Content">
   <ci>f</ci>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle f
  </annotation>
 </semantics>
</math>

 above, we might fix (or 'bind') the first argument, producing a function of type 

<math display="inline" id="Currying:42">
 <semantics>
  <mrow>
   <mrow>
    <mtext>partial</mtext>
    <mrow>
     <mo stretchy="false">(</mo>
     <mi>f</mi>
     <mo stretchy="false">)</mo>
    </mrow>
   </mrow>
   <mo>:</mo>
   <mrow>
    <mrow>
     <mo stretchy="false">(</mo>
     <mrow>
      <mi>Y</mi>
      <mo>×</mo>
      <mi>Z</mi>
     </mrow>
     <mo stretchy="false">)</mo>
    </mrow>
    <mo>→</mo>
    <mi>N</mi>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <ci>normal-:</ci>
    <apply>
     <times></times>
     <mtext>partial</mtext>
     <ci>f</ci>
    </apply>
    <apply>
     <ci>normal-→</ci>
     <apply>
      <times></times>
      <ci>Y</ci>
      <ci>Z</ci>
     </apply>
     <ci>N</ci>
    </apply>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle\text{partial}(f)\colon(Y\times Z)\to N
  </annotation>
 </semantics>
</math>

. Evaluation of this function might be represented as 

<math display="inline" id="Currying:43">
 <semantics>
  <mrow>
   <msub>
    <mi>f</mi>
    <mtext>partial</mtext>
   </msub>
   <mrow>
    <mo stretchy="false">(</mo>
    <mn>2</mn>
    <mo>,</mo>
    <mn>3</mn>
    <mo stretchy="false">)</mo>
   </mrow>
  </mrow>
  <annotation-xml encoding="MathML-Content">
   <apply>
    <times></times>
    <apply>
     <csymbol cd="ambiguous">subscript</csymbol>
     <ci>f</ci>
     <mtext>partial</mtext>
    </apply>
    <interval closure="open">
     <cn type="integer">2</cn>
     <cn type="integer">3</cn>
    </interval>
   </apply>
  </annotation-xml>
  <annotation encoding="application/x-tex">
   \scriptstyle f_{\text{partial}}(2,3)
  </annotation>
 </semantics>
</math>

. Note that the result of partial function application in this case is a function that takes two arguments.</p>

<p>Intuitively, partial function application says "if you fix the first <a href="parameter_(computer_science)" title="wikilink">arguments</a> of the function, you get a function of the remaining arguments". For example, if function <em>div</em> stands for the division operation <em>x</em>/<em>y</em>, then <em>div</em> with the parameter <em>x</em> fixed at 1 (i.e., <em>div</em> 1) is another function: the same as the function <em>inv</em> that returns the multiplicative inverse of its argument, defined by <em>inv</em>(<em>y</em>) = 1/<em>y</em>.</p>

<p>The practical motivation for partial application is that very often the functions obtained by supplying some but not all of the arguments to a function are useful; for example, many languages have a function or operator similar to <code>plus_one</code>. Partial application makes it easy to define these functions, for example by creating a function that represents the addition operator with 1 bound as its first argument.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Lazy_evaluation" title="wikilink">Lazy evaluation</a></li>
<li><a href="Closure_(computer_science)" title="wikilink">Closure (computer science)</a></li>
<li><a href="smn_theorem" title="wikilink">s<sub>mn</sub> theorem</a></li>
<li><a href="Closed_monoidal_category" title="wikilink">Closed monoidal category</a></li>
</ul>
<h2 id="notes">Notes</h2>
<h2 id="references">References</h2>
<ul>
<li></li>
<li></li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://c2.com/cgi/wiki?CurryingSchonfinkelling">Currying Schonfinkelling</a> at the <a href="Portland_Pattern_Repository" title="wikilink">Portland Pattern Repository</a></li>
<li><a href="http://lambda-the-ultimate.org/node/2266">Currying != Generalized Partial Application!</a> - post at Lambda-the-Ultimate.org</li>
</ul>

<p>"</p>

<p><a href="Category:Higher-order_functions" title="wikilink">Category:Higher-order functions</a> <a href="Category:Functional_programming" title="wikilink">Category:Functional programming</a> <a href="Category:Lambda_calculus" title="wikilink">Category:Lambda calculus</a> <a href="Category:Articles_with_example_Java_code" title="wikilink">Category:Articles with example Java code</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"> (Reprinted lecture notes from 1967.)<a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
<li id="fn3">Kenneth Slonneger and Barry L. Kurtz. <em>Formal Syntax and Semantics of Programming Languages</em>. p. 144.<a href="#fnref3">↩</a></li>
<li id="fn4">Henk Barendregt, Erik Barendsen, "<a href="ftp://ftp.cs.ru.nl/pub/CompMath.Found/lambda.pdf">Introduction to Lambda Calculus</a>", March 2000, page 8.<a href="#fnref4">↩</a></li>
<li id="fn5"><a href="#fnref5">↩</a></li>
<li id="fn6"><a href="http://www.cs.nott.ac.uk/~gmh/faq.html#currying">Frequently Asked Questions for comp.lang.functional: Currying</a> by <a href="Graham_Hutton" title="wikilink">Graham Hutton</a><a href="#fnref6">↩</a></li>
<li id="fn7"><a href="#fnref7">↩</a></li>
<li id="fn8">Samson Abramsky and Bob Coecke, "A Categorical Semantics for Quantum Protocols", "<a href="http://arxiv.org/abs/quantph/0402130/">1</a>.<a href="#fnref8">↩</a></li>
<li id="fn9">John c. Baez and Mike Stay, "<a href="http://math.ucr.edu/home/baez/rosetta/rose3.pdf">Physics, Topology, Logic and Computation: A Rosetta Stone</a>", (2009) <a href="http://arxiv.org/abs/0903.0340/">ArXiv 0903.0340</a> in <em>New Structures for Physics</em>, ed. Bob Coecke, <em>Lecture Notes in Physics</em> vol. <strong>813</strong>, Springer, Berlin, 2011, pp. 95-174.<a href="#fnref9">↩</a></li>
<li id="fn10"> <em>(See theorems 1.2.13, 1.2.14)</em><a href="#fnref10">↩</a></li>
<li id="fn11">I. Heim and A. Kratzer (1998). <em>Semantics in Generative Grammar</em>. Blackwell.<a href="#fnref11">↩</a></li>
<li id="fn12"><a href="http://www.uncarved.com/blog/not_currying.mrk">Partial Function Application is not Currying</a><a href="#fnref12">↩</a></li>
<li id="fn13"><a href="http://slid.es/gsklee/functional-programming-in-5-minutes">Functional Programming in 5 Minutes</a><a href="#fnref13">↩</a></li>
</ol>
</section>
</body>
</html>
