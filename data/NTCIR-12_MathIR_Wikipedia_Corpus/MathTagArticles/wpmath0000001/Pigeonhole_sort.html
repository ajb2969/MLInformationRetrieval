<html lang="en">
<head>
<meta charset="utf-8"/>
<title offset="836">Pigeonhole sort</title>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript">
</script>
</head>
<body>
<h1>Pigeonhole sort</h1>
<hr/>

<p><strong>Pigeonhole sorting</strong>, also known as <strong>count sort</strong> (not to be confused with <a href="counting_sort" title="wikilink">counting sort</a>), is a <a href="sorting_algorithm" title="wikilink">sorting algorithm</a> that is suitable for sorting lists of elements where the number of elements (<em>n</em>) and the number of possible key values (<em>N</em>) are approximately the same.<a class="footnoteRef" href="#fn1" id="fnref1"><sup>1</sup></a> It requires <a href="big_O_notation" title="wikilink">O</a>(<em>n</em> + <em>N</em>) time.</p>

<p>The pigeonhole algorithm works as follows:</p>
<ol>
<li>Given an array of values to be sorted, set up an auxiliary array of initially empty "pigeonholes," one pigeonhole for each key through the <a href="Range_(computer_science)" title="wikilink">range</a> of the original array.</li>
<li>Going over the original array, put each value into the pigeonhole corresponding to its key, such that each pigeonhole eventually contains a list of all values with that key.</li>
<li>Iterate over the pigeonhole array in order, and put elements from non-empty pigeonholes back into the original array.</li>
</ol>
<h2 id="example">Example</h2>

<p>Suppose we were sorting these value pairs by their first element:</p>
<ul>
<li>(5, "hello")</li>
<li>(3, "pie")</li>
<li>(8, "apple")</li>
<li>(5, "king")</li>
</ul>

<p>For each value between 3 and 8 we set up a pigeonhole, then move each element to its pigeonhole:</p>
<ul>
<li>3: (3, "pie")</li>
<li>4:</li>
<li>5: (5, "hello"), (5, "king")</li>
<li>6:</li>
<li>7:</li>
<li>8: (8, "apple")</li>
</ul>

<p>We then iterate over the pigeonhole array in order and move them back to the original list.</p>

<p>The difference between pigeonhole sort and counting sort is that in counting sort, the auxiliary array does not contain lists of input elements, only counts:</p>
<ul>
<li>3: 1</li>
<li>4: 0</li>
<li>5: 2</li>
<li>6: 0</li>
<li>7: 0</li>
<li>8: 1</li>
</ul>

<p>Using this information we can perform a series of exchanges on the input array that puts it in order, moving items only once. Pigeonhole sort, in contrast, moves items twice: once onto the pigeonhole/bucket array and again onto the destination array. <a class="footnoteRef" href="#fn2" id="fnref2"><sup>2</sup></a></p>

<p>For arrays where <em>N</em> is much larger than <em>n</em>, <a href="bucket_sort" title="wikilink">bucket sort</a> is a generalization that is more efficient in space and time.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="Pigeonhole_principle" title="wikilink">Pigeonhole principle</a></li>
<li><a href="Radix_sort" title="wikilink">Radix sort</a></li>
</ul>
<h2 id="references">References</h2>
<references>
</references>

<p><a href="ru:Сортировка_подсчётом#Алгоритм_со_списком" title="wikilink">ru:Сортировка подсчётом#Алгоритм со списком</a>"</p>

<p><a href="Category:Sorting_algorithms" title="wikilink">Category:Sorting algorithms</a> <a href="Category:Stable_sorts" title="wikilink">Category:Stable sorts</a></p>
<section class="footnotes">
<hr/>
<ol>
<li id="fn1"><a href="http://www.nist.gov/dads/HTML/pigeonholeSort.html">NIST's Dictionary of Algorithms and Data Structures: pigeonhole sort</a><a href="#fnref1">↩</a></li>
<li id="fn2"><a href="#fnref2">↩</a></li>
</ol>
</section>
</body>
</html>
